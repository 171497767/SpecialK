; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	C:\Users\andon\Source\Repos\SpecialK\src\io_monitor.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?hShutdownWMI@@3PAXA				; hShutdownWMI
PUBLIC	?perfmon@@3Uthread_events@@A			; perfmon
_BSS	SEGMENT
?hShutdownWMI@@3PAXA DD 01H DUP (?)			; hShutdownWMI
?perfmon@@3Uthread_events@@A DB 060H DUP (?)		; perfmon
_BSS	ENDS
CONST	SEGMENT
$SG165915 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165916 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'c', 00H, 'r', 00H, 'e'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 'R', 00H, 'e', 00H
	DB	'f', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'h', 00H, 'e', 00H, 'r'
	DB	00H, ' ', 00H, 'I', 00H, 'n', 00H, 's', 00H, 't', 00H, 'a', 00H
	DB	'n', 00H, 'c', 00H, 'e', 00H, ' ', 00H, '(', 00H, '%', 00H, 's'
	DB	00H, ':', 00H, '%', 00H, 'd', 00H, ')', 00H, 00H, 00H
	ORG $+6
$SG165919 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165920 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'Q', 00H, 'u', 00H, 'e'
	DB	00H, 'r', 00H, 'y', 00H, ' ', 00H, 'R', 00H, 'e', 00H, 'f', 00H
	DB	'r', 00H, 'e', 00H, 's', 00H, 'h', 00H, 'e', 00H, 'r', 00H, ' '
	DB	00H, 'I', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'f', 00H
	DB	'a', 00H, 'c', 00H, 'e', 00H, ' ', 00H, '(', 00H, '%', 00H, 's'
	DB	00H, ':', 00H, '%', 00H, 'd', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG165950 DB	'P', 00H, 'e', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, 'I', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'r'
	DB	00H, 'u', 00H, 'p', 00H, 't', 00H, 'T', 00H, 'i', 00H, 'm', 00H
	DB	'e', 00H, 00H, 00H
	ORG $+2
$SG165923 DB	'W', 00H, 'i', 00H, 'n', 00H, '3', 00H, '2', 00H, '_', 00H
	DB	'P', 00H, 'e', 00H, 'r', 00H, 'f', 00H, 'F', 00H, 'o', 00H, 'r'
	DB	00H, 'm', 00H, 'a', 00H, 't', 00H, 't', 00H, 'e', 00H, 'd', 00H
	DB	'D', 00H, 'a', 00H, 't', 00H, 'a', 00H, '_', 00H, 'P', 00H, 'e'
	DB	00H, 'r', 00H, 'f', 00H, 'O', 00H, 'S', 00H, '_', 00H, 'P', 00H
	DB	'r', 00H, 'o', 00H, 'c', 00H, 'e', 00H, 's', 00H, 's', 00H, 'o'
	DB	00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG165955 DB	'P', 00H, 'e', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, 'P', 00H, 'r', 00H, 'i', 00H, 'v', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 'g', 00H, 'e', 00H, 'd', 00H, 'T', 00H, 'i', 00H
	DB	'm', 00H, 'e', 00H, 00H, 00H
$SG165924 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165925 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'A', 00H, 'd', 00H, 'd'
	DB	00H, ' ', 00H, 'E', 00H, 'n', 00H, 'u', 00H, 'm', 00H, 'e', 00H
	DB	'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '('
	DB	00H, '%', 00H, 's', 00H, ':', 00H, '%', 00H, 'd', 00H, ')', 00H
	DB	' ', 00H, '-', 00H, ' ', 00H, '%', 00H, '0', 00H, '4', 00H, 'X'
	DB	00H, 00H, 00H
	ORG $+2
$SG165927 DB	'C', 00H, 'P', 00H, 'U', 00H, 'M', 00H, 'o', 00H, 'n', 00H
	DB	' ', 00H, 'S', 00H, 'h', 00H, 'u', 00H, 't', 00H, 'd', 00H, 'o'
	DB	00H, 'w', 00H, 'n', 00H, ' ', 00H, 'S', 00H, 'i', 00H, 'g', 00H
	DB	'n', 00H, 'a', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG165960 DB	'P', 00H, 'e', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, 'U', 00H, 's', 00H, 'e', 00H, 'r', 00H, 'T', 00H, 'i'
	DB	00H, 'm', 00H, 'e', 00H, 00H, 00H
$SG165965 DB	'P', 00H, 'e', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'c', 00H, 'e', 00H, 's'
	DB	00H, 's', 00H, 'o', 00H, 'r', 00H, 'T', 00H, 'i', 00H, 'm', 00H
	DB	'e', 00H, 00H, 00H
	ORG $+2
$SG165931 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165932 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'R', 00H, 'e', 00H, 'f'
	DB	00H, 'r', 00H, 'e', 00H, 's', 00H, 'h', 00H, ' ', 00H, 'C', 00H
	DB	'P', 00H, 'U', 00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':'
	DB	00H, '%', 00H, 'd', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG165937 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165938 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'O', 00H, 'u', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'f', 00H
	DB	' ', 00H, 'M', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y'
	DB	00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':', 00H, '%', 00H
	DB	'd', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG165941 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165942 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'g', 00H, 'e', 00H, 't'
	DB	00H, ' ', 00H, 'C', 00H, 'P', 00H, 'U', 00H, ' ', 00H, 'O', 00H
	DB	'b', 00H, 'j', 00H, 'e', 00H, 'c', 00H, 't', 00H, 's', 00H, ' '
	DB	00H, '(', 00H, '%', 00H, 's', 00H, ':', 00H, '%', 00H, 'd', 00H
	DB	')', 00H, 00H, 00H
	ORG $+2
$SG165945 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165946 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'U', 00H, 'N', 00H, 'K', 00H, 'N', 00H, 'O', 00H, 'W', 00H
	DB	'N', 00H, ' ', 00H, 'E', 00H, 'R', 00H, 'R', 00H, 'O', 00H, 'R'
	DB	00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':', 00H, '%', 00H
	DB	'd', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG165951 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165952 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'a', 00H, 'c', 00H, 'q'
	DB	00H, 'u', 00H, 'i', 00H, 'r', 00H, 'e', 00H, ' ', 00H, 'p', 00H
	DB	'r', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 't', 00H, 'y'
	DB	00H, ' ', 00H, 'h', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'l', 00H
	DB	'e', 00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':', 00H, '%'
	DB	00H, 'd', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG165956 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165957 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'a', 00H, 'c', 00H, 'q'
	DB	00H, 'u', 00H, 'i', 00H, 'r', 00H, 'e', 00H, ' ', 00H, 'p', 00H
	DB	'r', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 't', 00H, 'y'
	DB	00H, ' ', 00H, 'h', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'l', 00H
	DB	'e', 00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':', 00H, '%'
	DB	00H, 'd', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG165961 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165962 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'a', 00H, 'c', 00H, 'q'
	DB	00H, 'u', 00H, 'i', 00H, 'r', 00H, 'e', 00H, ' ', 00H, 'p', 00H
	DB	'r', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 't', 00H, 'y'
	DB	00H, ' ', 00H, 'h', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'l', 00H
	DB	'e', 00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':', 00H, '%'
	DB	00H, 'd', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG165966 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165967 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'a', 00H, 'c', 00H, 'q'
	DB	00H, 'u', 00H, 'i', 00H, 'r', 00H, 'e', 00H, ' ', 00H, 'p', 00H
	DB	'r', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 't', 00H, 'y'
	DB	00H, ' ', 00H, 'h', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'l', 00H
	DB	'e', 00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':', 00H, '%'
	DB	00H, 'd', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG165970 DB	'P', 00H, 'e', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, 'I', 00H, 'd', 00H, 'l', 00H, 'e', 00H, 'T', 00H, 'i'
	DB	00H, 'm', 00H, 'e', 00H, 00H, 00H
$SG165971 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165972 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'a', 00H, 'c', 00H, 'q'
	DB	00H, 'u', 00H, 'i', 00H, 'r', 00H, 'e', 00H, ' ', 00H, 'p', 00H
	DB	'r', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 't', 00H, 'y'
	DB	00H, ' ', 00H, 'h', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'l', 00H
	DB	'e', 00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':', 00H, '%'
	DB	00H, 'd', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG165975 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'C', 00H, 'P', 00H, 'U', 00H, ' ', 00H, 'a', 00H, 'p', 00H
	DB	'E', 00H, 'n', 00H, 'u', 00H, 'm', 00H, 'A', 00H, 'c', 00H, 'c'
	DB	00H, 'e', 00H, 's', 00H, 's', 00H, ' ', 00H, '[', 00H, '%', 00H
	DB	'l', 00H, 'u', 00H, ']', 00H, ' ', 00H, '=', 00H, ' ', 00H, 'n'
	DB	00H, 'u', 00H, 'l', 00H, 'l', 00H, 'p', 00H, 't', 00H, 'r', 00H
	DB	00H, 00H
$SG166149 DB	'N', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG165978 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165979 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 'd', 00H, ' ', 00H, 'Q', 00H, 'u', 00H, 'a', 00H, 'd', 00H
	DB	'-', 00H, 'W', 00H, 'o', 00H, 'r', 00H, 'd', 00H, ' ', 00H, 'P'
	DB	00H, 'r', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 't', 00H
	DB	'y', 00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':', 00H, '%'
	DB	00H, 'd', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG165982 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165983 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 'd', 00H, ' ', 00H, 'Q', 00H, 'u', 00H, 'a', 00H, 'd', 00H
	DB	'-', 00H, 'W', 00H, 'o', 00H, 'r', 00H, 'd', 00H, ' ', 00H, 'P'
	DB	00H, 'r', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 't', 00H
	DB	'y', 00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':', 00H, '%'
	DB	00H, 'd', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG165986 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165987 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 'd', 00H, ' ', 00H, 'Q', 00H, 'u', 00H, 'a', 00H, 'd', 00H
	DB	'-', 00H, 'W', 00H, 'o', 00H, 'r', 00H, 'd', 00H, ' ', 00H, 'P'
	DB	00H, 'r', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 't', 00H
	DB	'y', 00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':', 00H, '%'
	DB	00H, 'd', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG165990 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165991 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 'd', 00H, ' ', 00H, 'Q', 00H, 'u', 00H, 'a', 00H, 'd', 00H
	DB	'-', 00H, 'W', 00H, 'o', 00H, 'r', 00H, 'd', 00H, ' ', 00H, 'P'
	DB	00H, 'r', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 't', 00H
	DB	'y', 00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':', 00H, '%'
	DB	00H, 'd', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG165994 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165995 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 'd', 00H, ' ', 00H, 'Q', 00H, 'u', 00H, 'a', 00H, 'd', 00H
	DB	'-', 00H, 'W', 00H, 'o', 00H, 'r', 00H, 'd', 00H, ' ', 00H, 'P'
	DB	00H, 'r', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 't', 00H
	DB	'y', 00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':', 00H, '%'
	DB	00H, 'd', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG166128 DB	'W', 00H, 'i', 00H, 'n', 00H, '3', 00H, '2', 00H, '_', 00H
	DB	'P', 00H, 'e', 00H, 'r', 00H, 'f', 00H, 'F', 00H, 'o', 00H, 'r'
	DB	00H, 'm', 00H, 'a', 00H, 't', 00H, 't', 00H, 'e', 00H, 'd', 00H
	DB	'D', 00H, 'a', 00H, 't', 00H, 'a', 00H, '_', 00H, 'P', 00H, 'e'
	DB	00H, 'r', 00H, 'f', 00H, 'D', 00H, 'i', 00H, 's', 00H, 'k', 00H
	DB	'_', 00H, 'L', 00H, 'o', 00H, 'g', 00H, 'i', 00H, 'c', 00H, 'a'
	DB	00H, 'l', 00H, 'D', 00H, 'i', 00H, 's', 00H, 'k', 00H, 00H, 00H
	ORG $+2
$SG166131 DB	'D', 00H, 'i', 00H, 's', 00H, 'k', 00H, 'M', 00H, 'o', 00H
	DB	'n', 00H, ' ', 00H, 'S', 00H, 'h', 00H, 'u', 00H, 't', 00H, 'd'
	DB	00H, 'o', 00H, 'w', 00H, 'n', 00H, ' ', 00H, 'S', 00H, 'i', 00H
	DB	'g', 00H, 'n', 00H, 'a', 00H, 'l', 00H, 00H, 00H
$SG166158 DB	'D', 00H, 'i', 00H, 's', 00H, 'k', 00H, 'W', 00H, 'r', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e'
	DB	00H, 's', 00H, 'P', 00H, 'e', 00H, 'r', 00H, 'S', 00H, 'e', 00H
	DB	'c', 00H, 00H, 00H
	ORG $+2
$SG166129 DB	'W', 00H, 'i', 00H, 'n', 00H, '3', 00H, '2', 00H, '_', 00H
	DB	'P', 00H, 'e', 00H, 'r', 00H, 'f', 00H, 'F', 00H, 'o', 00H, 'r'
	DB	00H, 'm', 00H, 'a', 00H, 't', 00H, 't', 00H, 'e', 00H, 'd', 00H
	DB	'D', 00H, 'a', 00H, 't', 00H, 'a', 00H, '_', 00H, 'P', 00H, 'e'
	DB	00H, 'r', 00H, 'f', 00H, 'D', 00H, 'i', 00H, 's', 00H, 'k', 00H
	DB	'_', 00H, 'P', 00H, 'h', 00H, 'y', 00H, 's', 00H, 'i', 00H, 'c'
	DB	00H, 'a', 00H, 'l', 00H, 'D', 00H, 'i', 00H, 's', 00H, 'k', 00H
	DB	00H, 00H
$SG166167 DB	'P', 00H, 'e', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, 'D', 00H, 'i', 00H, 's', 00H, 'k', 00H, 'W', 00H, 'r'
	DB	00H, 'i', 00H, 't', 00H, 'e', 00H, 'T', 00H, 'i', 00H, 'm', 00H
	DB	'e', 00H, 00H, 00H
	ORG $+2
$SG166146 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'D', 00H, 'i', 00H, 's', 00H, 'k', 00H, ' ', 00H, 'a', 00H
	DB	'p', 00H, 'E', 00H, 'n', 00H, 'u', 00H, 'm', 00H, 'A', 00H, 'c'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, 's', 00H, ' ', 00H, '[', 00H
	DB	'0', 00H, ']', 00H, ' ', 00H, '=', 00H, ' ', 00H, 'n', 00H, 'u'
	DB	00H, 'l', 00H, 'l', 00H, 'p', 00H, 't', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG166152 DB	'D', 00H, 'i', 00H, 's', 00H, 'k', 00H, 'B', 00H, 'y', 00H
	DB	't', 00H, 'e', 00H, 's', 00H, 'P', 00H, 'e', 00H, 'r', 00H, 'S'
	DB	00H, 'e', 00H, 'c', 00H, 00H, 00H
$SG166155 DB	'D', 00H, 'i', 00H, 's', 00H, 'k', 00H, 'R', 00H, 'e', 00H
	DB	'a', 00H, 'd', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's'
	DB	00H, 'P', 00H, 'e', 00H, 'r', 00H, 'S', 00H, 'e', 00H, 'c', 00H
	DB	00H, 00H
$SG166161 DB	'P', 00H, 'e', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, 'D', 00H, 'i', 00H, 's', 00H, 'k', 00H, 'T', 00H, 'i'
	DB	00H, 'm', 00H, 'e', 00H, 00H, 00H
$SG166164 DB	'P', 00H, 'e', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, 'D', 00H, 'i', 00H, 's', 00H, 'k', 00H, 'R', 00H, 'e'
	DB	00H, 'a', 00H, 'd', 00H, 'T', 00H, 'i', 00H, 'm', 00H, 'e', 00H
	DB	00H, 00H
$SG166170 DB	'P', 00H, 'e', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, 'I', 00H, 'd', 00H, 'l', 00H, 'e', 00H, 'T', 00H, 'i'
	DB	00H, 'm', 00H, 'e', 00H, 00H, 00H
$SG166188 DB	' ', 00H
	ORG $+2
$SG166190 DB	'Total', 00H
	ORG $+2
$SG166268 DB	'W', 00H, 'i', 00H, 'n', 00H, '3', 00H, '2', 00H, '_', 00H
	DB	'P', 00H, 'e', 00H, 'r', 00H, 'f', 00H, 'R', 00H, 'a', 00H, 'w'
	DB	00H, 'D', 00H, 'a', 00H, 't', 00H, 'a', 00H, '_', 00H, 'P', 00H
	DB	'e', 00H, 'r', 00H, 'f', 00H, 'O', 00H, 'S', 00H, '_', 00H, 'P'
	DB	00H, 'a', 00H, 'g', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 'F', 00H
	DB	'i', 00H, 'l', 00H, 'e', 00H, 00H, 00H
$SG166270 DB	'P', 00H, 'a', 00H, 'g', 00H, 'e', 00H, 'f', 00H, 'i', 00H
	DB	'l', 00H, 'e', 00H, ' ', 00H, 'M', 00H, 'o', 00H, 'n', 00H, 'i'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'S', 00H, 'h', 00H
	DB	'u', 00H, 't', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, ' '
	DB	00H, 'S', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'a', 00H, 'l', 00H
	DB	00H, 00H
	ORG $+2
$SG166291 DB	'N', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG166285 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'N', 00H, 'o', 00H, ' ', 00H, 'p', 00H, 'a', 00H, 'g', 00H
	DB	'e', 00H, 'f', 00H, 'i', 00H, 'l', 00H, 'e', 00H, ' ', 00H, 'e'
	DB	00H, 'x', 00H, 'i', 00H, 's', 00H, 't', 00H, 's', 00H, 00H, 00H
$SG166288 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'P', 00H, 'a', 00H, 'g', 00H, 'e', 00H, 'f', 00H, 'i', 00H
	DB	'l', 00H, 'e', 00H, ' ', 00H, 'a', 00H, 'p', 00H, 'E', 00H, 'n'
	DB	00H, 'u', 00H, 'm', 00H, 'A', 00H, 'c', 00H, 'c', 00H, 'e', 00H
	DB	's', 00H, 's', 00H, ' ', 00H, '[', 00H, '0', 00H, ']', 00H, ' '
	DB	00H, '=', 00H, ' ', 00H, 'n', 00H, 'u', 00H, 'l', 00H, 'l', 00H
	DB	'p', 00H, 't', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG166294 DB	'P', 00H, 'e', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, 'U', 00H, 's', 00H, 'a', 00H, 'g', 00H, 'e', 00H, 00H
	DB	00H
	ORG $+2
$SG166297 DB	'P', 00H, 'e', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, 'U', 00H, 's', 00H, 'a', 00H, 'g', 00H, 'e', 00H, 'P'
	DB	00H, 'e', 00H, 'a', 00H, 'k', 00H, 00H, 00H
	ORG $+2
$SG166300 DB	'P', 00H, 'e', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, 'U', 00H, 's', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '_'
	DB	00H, 'B', 00H, 'a', 00H, 's', 00H, 'e', 00H, 00H, 00H
$SG166310 DB	' ', 00H
	ORG $+2
$SG166312 DB	'Total', 00H
	ORG $+2
$SG166470 DB	'P', 00H, 'a', 00H, 'g', 00H, 'e', 00H, 'F', 00H, 'i', 00H
	DB	'l', 00H, 'e', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's'
	DB	00H, 00H, 00H
$SG166452 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG166453 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'c', 00H, 'r', 00H, 'e'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 'R', 00H, 'e', 00H
	DB	'f', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'h', 00H, 'e', 00H, 'r'
	DB	00H, ' ', 00H, 'I', 00H, 'n', 00H, 's', 00H, 't', 00H, 'a', 00H
	DB	'n', 00H, 'c', 00H, 'e', 00H, ' ', 00H, '(', 00H, '%', 00H, 's'
	DB	00H, ':', 00H, '%', 00H, 'd', 00H, ')', 00H, ' ', 00H, '-', 00H
	DB	'-', 00H, ' ', 00H, '0', 00H, 'x', 00H, '%', 00H, 'X', 00H, 00H
	DB	00H
	ORG $+2
$SG166473 DB	'P', 00H, 'a', 00H, 'g', 00H, 'e', 00H, 'F', 00H, 'i', 00H
	DB	'l', 00H, 'e', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's'
	DB	00H, 'P', 00H, 'e', 00H, 'a', 00H, 'k', 00H, 00H, 00H
$SG166456 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG166457 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'Q', 00H, 'u', 00H, 'e'
	DB	00H, 'r', 00H, 'y', 00H, ' ', 00H, 'R', 00H, 'e', 00H, 'f', 00H
	DB	'r', 00H, 'e', 00H, 's', 00H, 'h', 00H, 'e', 00H, 'r', 00H, ' '
	DB	00H, 'I', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'f', 00H
	DB	'a', 00H, 'c', 00H, 'e', 00H, ' ', 00H, '(', 00H, '%', 00H, 's'
	DB	00H, ':', 00H, '%', 00H, 'd', 00H, ')', 00H, ' ', 00H, '-', 00H
	DB	'-', 00H, ' ', 00H, '0', 00H, 'x', 00H, '%', 00H, 'X', 00H, 00H
	DB	00H
	ORG $+2
$SG166476 DB	'T', 00H, 'h', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'd', 00H
	DB	'C', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, 00H, 00H
$SG166479 DB	'P', 00H, 'r', 00H, 'i', 00H, 'v', 00H, 'a', 00H, 't', 00H
	DB	'e', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H, 00H
	DB	00H
	ORG $+2
$SG166460 DB	'W', 00H, 'i', 00H, 'n', 00H, '3', 00H, '2', 00H, '_', 00H
	DB	'P', 00H, 'e', 00H, 'r', 00H, 'f', 00H, 'F', 00H, 'o', 00H, 'r'
	DB	00H, 'm', 00H, 'a', 00H, 't', 00H, 't', 00H, 'e', 00H, 'd', 00H
	DB	'D', 00H, 'a', 00H, 't', 00H, 'a', 00H, '_', 00H, 'P', 00H, 'e'
	DB	00H, 'r', 00H, 'f', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'c', 00H
	DB	'_', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'c', 00H, 'e', 00H, 's'
	DB	00H, 's', 00H, '.', 00H, 'N', 00H, 'a', 00H, 'm', 00H, 'e', 00H
	DB	'=', 00H, '''', 00H, '%', 00H, 'w', 00H, 's', 00H, '''', 00H, 00H
	DB	00H
$SG166462 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG166463 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'A', 00H, 'd', 00H, 'd'
	DB	00H, 'O', 00H, 'b', 00H, 'j', 00H, 'e', 00H, 'c', 00H, 't', 00H
	DB	'B', 00H, 'y', 00H, 'P', 00H, 'a', 00H, 't', 00H, 'h', 00H, ' '
	DB	00H, '(', 00H, '%', 00H, 's', 00H, ':', 00H, '%', 00H, 'd', 00H
	DB	')', 00H, ' ', 00H, '-', 00H, '-', 00H, ' ', 00H, '0', 00H, 'x'
	DB	00H, '%', 00H, 'X', 00H, 00H, 00H
	ORG $+2
$SG166466 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG166467 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'Q', 00H, 'u', 00H, 'e'
	DB	00H, 'r', 00H, 'y', 00H, ' ', 00H, 'W', 00H, 'b', 00H, 'e', 00H
	DB	'm', 00H, 'O', 00H, 'b', 00H, 'j', 00H, 'e', 00H, 'c', 00H, 't'
	DB	00H, 'A', 00H, 'c', 00H, 'c', 00H, 'e', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 'I', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'f'
	DB	00H, 'a', 00H, 'c', 00H, 'e', 00H, ' ', 00H, '(', 00H, '%', 00H
	DB	's', 00H, ':', 00H, '%', 00H, 'd', 00H, ')', 00H, ' ', 00H, '-'
	DB	00H, '-', 00H, ' ', 00H, '0', 00H, 'x', 00H, '%', 00H, 'X', 00H
	DB	00H, 00H
$SG166482 DB	'W', 00H, 'o', 00H, 'r', 00H, 'k', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, 'S', 00H, 'e', 00H, 't', 00H, 'P', 00H, 'e', 00H, 'a'
	DB	00H, 'k', 00H, 00H, 00H
	ORG $+2
$SG166485 DB	'W', 00H, 'o', 00H, 'r', 00H, 'k', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, 'S', 00H, 'e', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG166488 DB	'V', 00H, 'i', 00H, 'r', 00H, 't', 00H, 'u', 00H, 'a', 00H
	DB	'l', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H, 'P'
	DB	00H, 'e', 00H, 'a', 00H, 'k', 00H, 00H, 00H
	ORG $+2
$SG166491 DB	'V', 00H, 'i', 00H, 'r', 00H, 't', 00H, 'u', 00H, 'a', 00H
	DB	'l', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H, 00H
	DB	00H
	ORG $+2
$SG166493 DB	'P', 00H, 'r', 00H, 'o', 00H, 'c', 00H, 'M', 00H, 'o', 00H
	DB	'n', 00H, ' ', 00H, 'S', 00H, 'h', 00H, 'u', 00H, 't', 00H, 'd'
	DB	00H, 'o', 00H, 'w', 00H, 'n', 00H, ' ', 00H, 'S', 00H, 'i', 00H
	DB	'g', 00H, 'n', 00H, 'a', 00H, 'l', 00H, 00H, 00H
$SG165718 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165719 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'c', 00H, 'r', 00H, 'e'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 'W', 00H, 'b', 00H
	DB	'e', 00H, 'm', 00H, ' ', 00H, 'L', 00H, 'o', 00H, 'c', 00H, 'a'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '(', 00H, '%', 00H
	DB	's', 00H, ':', 00H, '%', 00H, 'd', 00H, ')', 00H, ' ', 00H, '-'
	DB	00H, '-', 00H, ' ', 00H, '0', 00H, 'x', 00H, '%', 00H, 'X', 00H
	DB	00H, 00H
	ORG $+2
$SG165721 DB	'\', 00H, '\', 00H, '.', 00H, '\', 00H, 'R', 00H, 'o', 00H
	DB	'o', 00H, 't', 00H, '\', 00H, 'C', 00H, 'I', 00H, 'M', 00H, 'v'
	DB	00H, '2', 00H, 00H, 00H
	ORG $+2
$SG165723 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165724 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'O', 00H, 'u', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'f', 00H
	DB	' ', 00H, 'M', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y'
	DB	00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':', 00H, '%', 00H
	DB	'd', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG165727 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165728 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'u', 00H, 'r', 00H
	DB	'e', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'C', 00H, 'o'
	DB	00H, 'n', 00H, 'n', 00H, 'e', 00H, 'c', 00H, 't', 00H, ' ', 00H
	DB	't', 00H, 'o', 00H, ' ', 00H, 'W', 00H, 'b', 00H, 'e', 00H, 'm'
	DB	00H, ' ', 00H, 'S', 00H, 'e', 00H, 'r', 00H, 'v', 00H, 'e', 00H
	DB	'r', 00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':', 00H, '%'
	DB	00H, 'd', 00H, ')', 00H, ' ', 00H, '-', 00H, '-', 00H, ' ', 00H
	DB	'0', 00H, 'x', 00H, '%', 00H, 'X', 00H, 00H, 00H
	ORG $+2
$SG165733 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165734 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'u', 00H, 'r', 00H
	DB	'e', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 's', 00H, 'e'
	DB	00H, 't', 00H, ' ', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'x', 00H
	DB	'y', 00H, ' ', 00H, 'i', 00H, 'm', 00H, 'p', 00H, 'e', 00H, 'r'
	DB	00H, 's', 00H, 'o', 00H, 'n', 00H, 'a', 00H, 't', 00H, 'i', 00H
	DB	'o', 00H, 'n', 00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':'
	DB	00H, '%', 00H, 'd', 00H, ')', 00H, ' ', 00H, '-', 00H, '-', 00H
	DB	' ', 00H, '0', 00H, 'x', 00H, '%', 00H, 'X', 00H, 00H, 00H
$SG165737 DB	'[', 00H, ' ', 00H, 'S', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'K', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'U', 00H, 'n', 00H, 'l', 00H, 'o', 00H, 'a', 00H, 'd', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'S', 00H, 't', 00H, 'e'
	DB	00H, 'a', 00H, 'm', 00H, ' ', 00H, 'O', 00H, 'v', 00H, 'e', 00H
	DB	'r', 00H, 'l', 00H, 'a', 00H, 'y', 00H, '.', 00H, '.', 00H, '.'
	DB	00H, ' ', 00H, 00H, 00H
	ORG $+2
$SG165738 DB	'd', 00H, 'o', 00H, 'n', 00H, 'e', 00H, '!', 00H, 0aH, 00H
	DB	00H, 00H
	ORG $+2
$SG165829 DB	'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H, 'S', 00H, 'h', 00H
	DB	'u', 00H, 't', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 00H
	DB	00H
	ORG $+2
$SG165752 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165753 DB	'[', 00H, 'C', 00H, 'O', 00H, 'M', 00H, ' ', 00H, 'S', 00H
	DB	'e', 00H, 'c', 00H, 'u', 00H, 'r', 00H, 'e', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'u', 00H, 'r', 00H
	DB	'e', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'i', 00H, 'n'
	DB	00H, 'i', 00H, 't', 00H, 'i', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, ' ', 00H, 'C', 00H, 'O', 00H, 'M', 00H, ' '
	DB	00H, 'S', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 'r', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':'
	DB	00H, '%', 00H, 'd', 00H, ')', 00H, ' ', 00H, '-', 00H, '-', 00H
	DB	' ', 00H, '0', 00H, 'x', 00H, '%', 00H, 'X', 00H, 00H, 00H
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?wcsrchr@@YAPA_WPA_W_W@Z			; wcsrchr
PUBLIC	__InlineInterlockedExchangePointer
PUBLIC	__InlineInterlockedCompareExchangePointer
PUBLIC	_ReadAcquire
PUBLIC	_ReadPointerAcquire
PUBLIC	_RtlSecureZeroMemory
PUBLIC	?SK_ShutdownWMI@@YAXXZ				; SK_ShutdownWMI
PUBLIC	??0SK_AutoCOMInit@@QAE@XZ			; SK_AutoCOMInit::SK_AutoCOMInit
PUBLIC	??1SK_AutoCOMInit@@QAE@XZ			; SK_AutoCOMInit::~SK_AutoCOMInit
PUBLIC	?SK_CountIO@@YAXAAUio_perf_t@@N@Z		; SK_CountIO
PUBLIC	??0WMI_refresh_thread_t@@QAE@XZ			; WMI_refresh_thread_t::WMI_refresh_thread_t
PUBLIC	??0cpu_stat_s@cpu_perf_t@@QAE@XZ		; cpu_perf_t::cpu_stat_s::cpu_stat_s
PUBLIC	??0cpu_perf_t@@QAE@XZ				; cpu_perf_t::cpu_perf_t
PUBLIC	??0disk_stat_s@disk_perf_t@@QAE@XZ		; disk_perf_t::disk_stat_s::disk_stat_s
PUBLIC	??0disk_perf_t@@QAE@XZ				; disk_perf_t::disk_perf_t
PUBLIC	??0<unnamed-type-pagefiles>@pagefile_perf_t@@QAE@XZ ; pagefile_perf_t::<unnamed-type-pagefiles>::<unnamed-type-pagefiles>
PUBLIC	??0pagefile_perf_t@@QAE@XZ			; pagefile_perf_t::pagefile_perf_t
PUBLIC	?SK_MonitorCPU@@YGKPAX@Z			; SK_MonitorCPU
PUBLIC	?SK_MonitorDisk@@YGKPAX@Z			; SK_MonitorDisk
PUBLIC	?SK_MonitorPagefile@@YGKPAX@Z			; SK_MonitorPagefile
PUBLIC	?fpclassify@@YAHN@Z				; fpclassify
PUBLIC	??0Stats@Framerate@SK@@QAE@XZ			; SK::Framerate::Stats::Stats
PUBLIC	??0sample_t@Stats@Framerate@SK@@QAE@XZ		; SK::Framerate::Stats::sample_t::sample_t
PUBLIC	?addSample@Stats@Framerate@SK@@QAEXNT_LARGE_INTEGER@@@Z ; SK::Framerate::Stats::addSample
PUBLIC	?lock@SK_Thread_CriticalSection@@QAEXXZ		; SK_Thread_CriticalSection::lock
PUBLIC	?unlock@SK_Thread_CriticalSection@@QAEXXZ	; SK_Thread_CriticalSection::unlock
PUBLIC	?isActive@SK_Widget@@QBE_NXZ			; SK_Widget::isActive
PUBLIC	?Lock@WMI@Base@COM@@QAEXXZ			; COM::Base::WMI::Lock
PUBLIC	?Unlock@WMI@Base@COM@@QAEXXZ			; COM::Base::WMI::Unlock
PUBLIC	??0WMI@Base@COM@@QAE@XZ				; COM::Base::WMI::WMI
PUBLIC	??0Base@COM@@QAE@XZ				; COM::Base::Base
PUBLIC	?SK_WMI_ServerThread@@YGKPAX@Z			; SK_WMI_ServerThread
PUBLIC	?SK_InitCOM@@YA_NXZ				; SK_InitCOM
PUBLIC	?SK_InitWMI@@YA_NXZ				; SK_InitWMI
PUBLIC	??$min@K@std@@YAABKABK0@Z			; std::min<unsigned long>
PUBLIC	??$isnan@N@@YA_NN@Z				; isnan<double>
PUBLIC	??0WMI_refresh_instance_thread_t@@QAE@XZ	; WMI_refresh_instance_thread_t::WMI_refresh_instance_thread_t
PUBLIC	??0process_stats_t@@QAE@XZ			; process_stats_t::process_stats_t
PUBLIC	?SK_MonitorProcess@@YGKPAX@Z			; SK_MonitorProcess
PUBLIC	?cpu_stats@@3Ucpu_perf_t@@A			; cpu_stats
PUBLIC	?disk_stats@@3Udisk_perf_t@@A			; disk_stats
PUBLIC	?pagefile_stats@@3Upagefile_perf_t@@A		; pagefile_stats
PUBLIC	?base@COM@@3UBase@1@A				; COM::base
PUBLIC	?process_stats@@3Uprocess_stats_t@@A		; process_stats
PUBLIC	__real@3ea0000000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@4008000000000000
PUBLIC	__real@408f400000000000
PUBLIC	__real@416312d000000000
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	__imp__wcsrchr:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__QueryPerformanceFrequency@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__SetEvent@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__SleepEx@8:PROC
EXTRN	__imp__CreateEventW@16:PROC
EXTRN	__imp__GetCurrentProcess@0:PROC
EXTRN	__imp__CreateThread@24:PROC
EXTRN	__imp__GetCurrentThread@0:PROC
EXTRN	__imp__GetSystemTime@4:PROC
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__GetProcessIoCounters@8:PROC
EXTRN	__imp__QueryFullProcessImageNameW@16:PROC
EXTRN	__imp__SystemTimeToFileTime@8:PROC
EXTRN	__imp__wsprintfW:PROC
EXTRN	__imp__WideCharToMultiByte@32:PROC
EXTRN	__imp__timeGetTime@0:PROC
EXTRN	__imp__CoUninitialize@0:PROC
EXTRN	__imp__CoInitializeEx@8:PROC
EXTRN	__imp__CoInitializeSecurity@36:PROC
EXTRN	__imp__CoSetProxyBlanket@32:PROC
EXTRN	__imp__CoCreateInstance@20:PROC
EXTRN	__imp__SysAllocString@4:PROC
EXTRN	__imp__SysFreeString@4:PROC
EXTRN	__imp___dtest:PROC
EXTRN	?LogEx@iSK_Logger@@UAAX_NQB_WZZ:PROC		; iSK_Logger::LogEx
EXTRN	?Log@iSK_Logger@@UAAXQB_WZZ:PROC		; iSK_Logger::Log
EXTRN	?calcMean@Stats@Framerate@SK@@QAENN@Z:PROC	; SK::Framerate::Stats::calcMean
EXTRN	?SK_Steam_LoadOverlayEarly@@YA_NXZ:PROC		; SK_Steam_LoadOverlayEarly
EXTRN	?SK_QueryPerf@@YA?AT_LARGE_INTEGER@@XZ:PROC	; SK_QueryPerf
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__dtoui3:PROC
EXTRN	__dtoul3:PROC
EXTRN	__ultod3:PROC
EXTRN	_memset:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	_IID_IUnknown:BYTE
EXTRN	_IID_IWbemObjectAccess:BYTE
EXTRN	_IID_IWbemLocator:BYTE
EXTRN	_IID_IWbemRefresher:BYTE
EXTRN	_IID_IWbemConfigureRefresher:BYTE
EXTRN	_CLSID_WbemLocator:BYTE
EXTRN	_CLSID_WbemRefresher:BYTE
EXTRN	?dll_log@@3UiSK_Logger@@A:BYTE			; dll_log
EXTRN	?wmi_cs@@3PAVSK_Thread_HybridSpinlock@@A:DWORD	; wmi_cs
EXTRN	?freq@Stats@Framerate@SK@@2T_LARGE_INTEGER@@A:QWORD ; SK::Framerate::Stats::freq
EXTRN	?config@@3Usk_config_t@@A:BYTE			; config
EXTRN	?SK_ImGui_Widgets@@3USK_ImGui_WidgetRegistry@@A:BYTE ; SK_ImGui_Widgets
EXTRN	?hModOverlay@@3PAUHINSTANCE__@@A:DWORD		; hModOverlay
EXTRN	__fltused:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
_BSS	SEGMENT
?cpu_stats@@3Ucpu_perf_t@@A DB 0e48H DUP (?)		; cpu_stats
?disk_stats@@3Udisk_perf_t@@A DB 05d0H DUP (?)		; disk_stats
?pagefile_stats@@3Upagefile_perf_t@@A DB 010fcH DUP (?)	; pagefile_stats
_BSS	ENDS
;	COMDAT ?hProc@?1??SK_CountIO@@YAXAAUio_perf_t@@N@Z@4PAXA
_BSS	SEGMENT
?hProc@?1??SK_CountIO@@YAXAAUio_perf_t@@N@Z@4PAXA DD 01H DUP (?) ; `SK_CountIO'::`2'::hProc
_BSS	ENDS
;	COMDAT ?$TSS0@?1??SK_CountIO@@YAXAAUio_perf_t@@N@Z@4HA
_BSS	SEGMENT
?$TSS0@?1??SK_CountIO@@YAXAAUio_perf_t@@N@Z@4HA DD 01H DUP (?) ; TSS0<`template-parameter-2',UNKNOWN volatile * const volatile,untIO,AXAAUio_perf_t,double>
_BSS	ENDS
;	COMDAT ?write_rate@?ED@??SK_MonitorDisk@@YGKPAX@Z@4PAVStats@Framerate@SK@@A
_BSS	SEGMENT
?write_rate@?ED@??SK_MonitorDisk@@YGKPAX@Z@4PAVStats@Framerate@SK@@A DB 07880H DUP (?) ; `SK_MonitorDisk'::`67'::write_rate
_BSS	ENDS
;	COMDAT ?$TSS0@?ED@??SK_MonitorDisk@@YGKPAX@Z@4HA
_BSS	SEGMENT
?$TSS0@?ED@??SK_MonitorDisk@@YGKPAX@Z@4HA DD 01H DUP (?) ; TSS0<`template-parameter-67',unsigned __int128 volatile * const volatile,nitorDisk,int, ?? &>
_BSS	ENDS
;	COMDAT ?read_rate@?ED@??SK_MonitorDisk@@YGKPAX@Z@4PAVStats@Framerate@SK@@A
_BSS	SEGMENT
?read_rate@?ED@??SK_MonitorDisk@@YGKPAX@Z@4PAVStats@Framerate@SK@@A DB 07880H DUP (?) ; `SK_MonitorDisk'::`67'::read_rate
_BSS	ENDS
;	COMDAT ?combined_rate@?ED@??SK_MonitorDisk@@YGKPAX@Z@4PAVStats@Framerate@SK@@A
_BSS	SEGMENT
?combined_rate@?ED@??SK_MonitorDisk@@YGKPAX@Z@4PAVStats@Framerate@SK@@A DB 07880H DUP (?) ; `SK_MonitorDisk'::`67'::combined_rate
_BSS	ENDS
CRT$XCU	SEGMENT
?cpu_stats$initializer$@@3P6AXXZA DD FLAT:??__Ecpu_stats@@YAXXZ ; cpu_stats$initializer$
CRT$XCU	ENDS
;	COMDAT __real@416312d000000000
CONST	SEGMENT
__real@416312d000000000 DQ 0416312d000000000r	; 1e+07
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3ea0000000000000
CONST	SEGMENT
__real@3ea0000000000000 DQ 03ea0000000000000r	; 4.76837e-07
CONST	ENDS
_DATA	SEGMENT
?base@COM@@3UBase@1@A DB 014H DUP (?)
	DD	0ffffffffH				; COM::base
	DD	00H
	ORG $+4
?process_stats@@3Uprocess_stats_t@@A DD 0ffffffffH	; process_stats
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	01H
	DB	3 DUP(00H)
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?<lambda_invoker_stdcall>@<lambda_cb83650d3cb2992700975903e3ec6658>@@CGKPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?<lambda_invoker_stdcall>@<lambda_cb83650d3cb2992700975903e3ec6658>@@CGKPAX@Z$0
__ehfuncinfo$?<lambda_invoker_stdcall>@<lambda_cb83650d3cb2992700975903e3ec6658>@@CGKPAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?<lambda_invoker_stdcall>@<lambda_cb83650d3cb2992700975903e3ec6658>@@CGKPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??R<lambda_cb83650d3cb2992700975903e3ec6658>@@QBEKPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??R<lambda_cb83650d3cb2992700975903e3ec6658>@@QBEKPAX@Z$0
__ehfuncinfo$??R<lambda_cb83650d3cb2992700975903e3ec6658>@@QBEKPAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??R<lambda_cb83650d3cb2992700975903e3ec6658>@@QBEKPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?SK_MonitorProcess@@YGKPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_MonitorProcess@@YGKPAX@Z$13
__unwindtable$?SK_WMI_ServerThread@@YGKPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_WMI_ServerThread@@YGKPAX@Z$6
__unwindtable$?SK_MonitorPagefile@@YGKPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_MonitorPagefile@@YGKPAX@Z$17
__unwindtable$?SK_MonitorDisk@@YGKPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_MonitorDisk@@YGKPAX@Z$24
__unwindtable$?SK_MonitorCPU@@YGKPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_MonitorCPU@@YGKPAX@Z$18
__ehfuncinfo$?SK_MonitorProcess@@YGKPAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SK_MonitorProcess@@YGKPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SK_WMI_ServerThread@@YGKPAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SK_WMI_ServerThread@@YGKPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SK_MonitorPagefile@@YGKPAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SK_MonitorPagefile@@YGKPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SK_MonitorDisk@@YGKPAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SK_MonitorDisk@@YGKPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SK_MonitorCPU@@YGKPAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SK_MonitorCPU@@YGKPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
?disk_stats$initializer$@@3P6AXXZA DD FLAT:??__Edisk_stats@@YAXXZ ; disk_stats$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?pagefile_stats$initializer$@@3P6AXXZA DD FLAT:??__Epagefile_stats@@YAXXZ ; pagefile_stats$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstring.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstring.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
_TEXT	SEGMENT
_wszInstance$ = -1580					; size = 1024
_wszProcessName$ = -556					; size = 520
_update$1$ = -36					; size = 8
_dwProcessSize$ = -28					; size = 4
_pClassObj$ = -24					; size = 4
_variant$ = -20						; size = 4
_auto_com$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
_user$ = 8						; size = 4
?SK_MonitorProcess@@YGKPAX@Z PROC			; SK_MonitorProcess

; 1525 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?SK_MonitorProcess@@YGKPAX@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 1568				; 00000620H
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?base@COM@@3UBase@1@A+4
	push	esi
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 1526 :   while (! ReadAcquire (&COM::base.wmi.init))

	test	eax, eax
	jne	SHORT $LN3@SK_Monitor
	mov	esi, DWORD PTR __imp__SleepEx@8
$LL2@SK_Monitor:

; 1527 :     SleepEx (150, FALSE);

	push	0
	push	150					; 00000096H
	call	esi
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?base@COM@@3UBase@1@A+4
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 1526 :   while (! ReadAcquire (&COM::base.wmi.init))

	test	eax, eax
	je	SHORT $LL2@SK_Monitor
$LN3@SK_Monitor:
	push	ebx
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h

; 45   :     HRESULT hr = CoInitializeEx (NULL, COINIT_MULTITHREADED);

	push	0
	push	0

; 54   :   }
; 55   : 
; 56   : private:
; 57   :   bool success = false;

	xor	bl, bl
	call	DWORD PTR __imp__CoInitializeEx@8
	test	eax, eax
	movzx	ecx, bl
	mov	edx, 1
	cmovns	ecx, edx
	mov	BYTE PTR _auto_com$[ebp], cl
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 1533 :   COM::base.wmi.Lock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?Lock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Lock
	movss	xmm0, DWORD PTR ?config@@3Usk_config_t@@A+20

; 1534 : 
; 1535 :   process_stats_t& proc   = process_stats;
; 1536 :   const double     update = config.mem.interval;
; 1537 : 
; 1538 :   HRESULT hr;
; 1539 : 
; 1540 :   if (FAILED (hr = CoCreateInstance (

	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+8
	push	OFFSET _IID_IWbemRefresher
	cvtps2pd xmm0, xmm0
	push	1
	push	0
	push	OFFSET _CLSID_WbemRefresher
	movsd	QWORD PTR _update$1$[ebp], xmm0
	call	DWORD PTR __imp__CoCreateInstance@20
	pop	ebx
	test	eax, eax
	jns	SHORT $LN6@SK_Monitor

; 1541 :                      CLSID_WbemRefresher,
; 1542 :                      nullptr,
; 1543 :                      CLSCTX_INPROC_SERVER,
; 1544 :                      IID_IWbemRefresher,
; 1545 :                      (void**) &proc.pRefresher )
; 1546 :              )
; 1547 :      )
; 1548 :   {
; 1549 :     dll_log.Log(L"[ WMI Wbem ] Failed to create Refresher Instance (%s:%d) -- 0x%X",

	push	eax
	push	1550					; 0000060eH
	push	OFFSET $SG166452
	push	OFFSET $SG166453
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 20					; 00000014H

; 1550 :       __FILEW__, __LINE__, hr);
; 1551 :     goto PROC_CLEANUP;

	jmp	$PROC_CLEANUP$69
$LN6@SK_Monitor:

; 1552 :   }
; 1553 : 
; 1554 :   if (FAILED (hr = proc.pRefresher->QueryInterface (

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+8
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+12
	push	OFFSET _IID_IWbemConfigureRefresher
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx]
	test	eax, eax
	jns	SHORT $LN8@SK_Monitor

; 1555 :                      IID_IWbemConfigureRefresher,
; 1556 :                      (void **)&proc.pConfig )
; 1557 :              )
; 1558 :      )
; 1559 :   {
; 1560 :     dll_log.Log(L"[ WMI Wbem ] Failed to Query Refresher Interface (%s:%d) -- 0x%X",

	push	eax
	push	1561					; 00000619H
	push	OFFSET $SG166456
	push	OFFSET $SG166457
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 20					; 00000014H

; 1561 :       __FILEW__, __LINE__, hr);
; 1562 :     goto PROC_CLEANUP;

	jmp	$PROC_CLEANUP$69
$LN8@SK_Monitor:
	push	edi

; 1563 :   }
; 1564 : 
; 1565 :   IWbemClassObject *pClassObj = nullptr;

	mov	DWORD PTR _pClassObj$[ebp], 0

; 1566 : 
; 1567 :   HANDLE hProc = GetCurrentProcess ();

	call	DWORD PTR __imp__GetCurrentProcess@0

; 1568 : 
; 1569 :   DWORD   dwProcessSize = MAX_PATH;
; 1570 :   wchar_t wszProcessName [MAX_PATH];
; 1571 : 
; 1572 :   QueryFullProcessImageName (hProc, 0, wszProcessName, &dwProcessSize);

	lea	ecx, DWORD PTR _dwProcessSize$[ebp]
	mov	DWORD PTR _dwProcessSize$[ebp], 260	; 00000104H
	push	ecx
	lea	ecx, DWORD PTR _wszProcessName$[ebp]
	push	ecx
	push	0
	push	eax
	call	DWORD PTR __imp__QueryFullProcessImageNameW@16
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstring.h

; 546  :         return const_cast<wchar_t*>(wcsrchr(static_cast<wchar_t const*>(_String), _C));

	mov	esi, DWORD PTR __imp__wcsrchr
	lea	eax, DWORD PTR _wszProcessName$[ebp]
	push	92					; 0000005cH
	push	eax
	call	esi
	push	46					; 0000002eH
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 1574 :   wchar_t* pwszShortName = wcsrchr (wszProcessName, L'\\') + 1;

	lea	edi, DWORD PTR [eax+2]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstring.h

; 546  :         return const_cast<wchar_t*>(wcsrchr(static_cast<wchar_t const*>(_String), _C));

	push	edi
	call	esi
	add	esp, 16					; 00000010H
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 1577 :   if (pwszTruncName != nullptr)

	test	eax, eax
	je	SHORT $LN10@SK_Monitor

; 1578 :     *pwszTruncName = L'\0';

	xor	ecx, ecx
	mov	WORD PTR [eax], cx
$LN10@SK_Monitor:

; 1579 : 
; 1580 :   wchar_t wszInstance [512];
; 1581 :   wsprintf ( wszInstance,

	push	edi
	lea	eax, DWORD PTR _wszInstance$[ebp]
	push	OFFSET $SG166460
	push	eax
	call	DWORD PTR __imp__wsprintfW

; 1582 :                L"Win32_PerfFormattedData_PerfProc_Process.Name='%ws'",
; 1583 :                  pwszShortName );
; 1584 : 
; 1585 :   if (FAILED (hr = proc.pConfig->AddObjectByPath (

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+12
	lea	edx, DWORD PTR _pClassObj$[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	push	0
	push	edx
	push	0
	push	0
	lea	edx, DWORD PTR _wszInstance$[ebp]
	push	edx
	push	DWORD PTR ?base@COM@@3UBase@1@A+8
	push	eax
	call	DWORD PTR [ecx+12]
	test	eax, eax
	jns	SHORT $LN11@SK_Monitor

; 1586 :                      COM::base.wmi.pNameSpace,
; 1587 :                      wszInstance,
; 1588 :                      0,
; 1589 :                      nullptr,
; 1590 :                      &pClassObj,
; 1591 :                      nullptr )
; 1592 :              )
; 1593 :      )
; 1594 :   {
; 1595 :     dll_log.Log(L"[ WMI Wbem ] Failed to AddObjectByPath (%s:%d) -- 0x%X",

	push	eax
	push	1596					; 0000063cH
	push	OFFSET $SG166462
	push	OFFSET $SG166463
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 20					; 00000014H

; 1596 :       __FILEW__, __LINE__, hr);
; 1597 :     goto PROC_CLEANUP;

	jmp	$LN68@SK_Monitor
$LN11@SK_Monitor:

; 1598 :   }
; 1599 : 
; 1600 :   if (FAILED (hr = pClassObj->QueryInterface ( IID_IWbemObjectAccess,

	mov	eax, DWORD PTR _pClassObj$[ebp]
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+16
	push	OFFSET _IID_IWbemObjectAccess
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx]
	test	eax, eax
	jns	SHORT $LN13@SK_Monitor

; 1601 :                                                (void **)(&proc.pAccess ) )
; 1602 :              )
; 1603 :      )
; 1604 :   {
; 1605 :     dll_log.Log(L"[ WMI Wbem ] Failed to Query WbemObjectAccess Interface (%s:%d)"

	push	eax
	push	1607					; 00000647H
	push	OFFSET $SG166466
	push	OFFSET $SG166467
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 1606 :                 L" -- 0x%X",
; 1607 :       __FILEW__, __LINE__, hr);
; 1608 :     pClassObj->Release ();

	mov	eax, DWORD PTR _pClassObj$[ebp]
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]

; 1609 :     pClassObj = nullptr;

	mov	DWORD PTR _pClassObj$[ebp], 0

; 1610 : 
; 1611 :     goto PROC_CLEANUP;

	jmp	$LN68@SK_Monitor
$LN13@SK_Monitor:

; 1612 :   }
; 1613 : 
; 1614 :   pClassObj->Release ();

	mov	eax, DWORD PTR _pClassObj$[ebp]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]

; 1615 :   pClassObj = nullptr;
; 1616 : 
; 1617 :   CIMTYPE variant;
; 1618 :   if (FAILED (hr = proc.pAccess->GetPropertyHandle ( L"PageFileBytes",

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	lea	edx, DWORD PTR _variant$[ebp]
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+52
	push	edx
	mov	DWORD PTR _pClassObj$[ebp], 0
	mov	ecx, DWORD PTR [eax]
	push	OFFSET $SG166470
	push	eax
	call	DWORD PTR [ecx+108]
	test	eax, eax
	js	$LN68@SK_Monitor

; 1619 :                                                      &variant,
; 1620 :                                                      &proc.hPageFileBytes )
; 1621 :              )
; 1622 :      )
; 1623 :   {
; 1624 :     goto PROC_CLEANUP;
; 1625 :   }
; 1626 : 
; 1627 :   if (FAILED (hr = proc.pAccess->GetPropertyHandle ( L"PageFileBytesPeak",

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	lea	edx, DWORD PTR _variant$[ebp]
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+56
	push	edx
	push	OFFSET $SG166473
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+108]
	test	eax, eax
	js	$LN68@SK_Monitor

; 1628 :                                                      &variant,
; 1629 :                                                      &proc.hPageFileBytesPeak )
; 1630 :              )
; 1631 :      )
; 1632 :   {
; 1633 :     goto PROC_CLEANUP;
; 1634 :   }
; 1635 : 
; 1636 :   if (FAILED (hr = proc.pAccess->GetPropertyHandle ( L"ThreadCount",

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	lea	edx, DWORD PTR _variant$[ebp]
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+48
	push	edx
	push	OFFSET $SG166476
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+108]
	test	eax, eax
	js	$LN68@SK_Monitor

; 1637 :                                                      &variant,
; 1638 :                                                      &proc.hThreadCount )
; 1639 :              )
; 1640 :      )
; 1641 :   {
; 1642 :     goto PROC_CLEANUP;
; 1643 :   }
; 1644 : 
; 1645 :   if (FAILED (hr = proc.pAccess->GetPropertyHandle ( L"PrivateBytes",

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	lea	edx, DWORD PTR _variant$[ebp]
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+44
	push	edx
	push	OFFSET $SG166479
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+108]
	test	eax, eax
	js	$LN68@SK_Monitor

; 1646 :                                                      &variant,
; 1647 :                                                      &proc.hPrivateBytes )
; 1648 :              )
; 1649 :      )
; 1650 :   {
; 1651 :     goto PROC_CLEANUP;
; 1652 :   }
; 1653 : 
; 1654 :   if (FAILED (hr = proc.pAccess->GetPropertyHandle ( L"WorkingSetPeak",

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	lea	edx, DWORD PTR _variant$[ebp]
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+40
	push	edx
	push	OFFSET $SG166482
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+108]
	test	eax, eax
	js	$LN68@SK_Monitor

; 1655 :                                                      &variant,
; 1656 :                                                      &proc.hWorkingSetPeak )
; 1657 :              )
; 1658 :      )
; 1659 :   {
; 1660 :     goto PROC_CLEANUP;
; 1661 :   }
; 1662 : 
; 1663 :   if (FAILED (hr = proc.pAccess->GetPropertyHandle ( L"WorkingSet",

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	lea	edx, DWORD PTR _variant$[ebp]
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+36
	push	edx
	push	OFFSET $SG166485
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+108]
	test	eax, eax
	js	$LN68@SK_Monitor

; 1664 :                                                      &variant,
; 1665 :                                                      &proc.hWorkingSet )
; 1666 :              )
; 1667 :      )
; 1668 :   {
; 1669 :     goto PROC_CLEANUP;
; 1670 :   }
; 1671 : 
; 1672 :   if (FAILED (hr = proc.pAccess->GetPropertyHandle ( L"VirtualBytesPeak",

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	lea	edx, DWORD PTR _variant$[ebp]
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+32
	push	edx
	push	OFFSET $SG166488
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+108]
	test	eax, eax
	js	$LN68@SK_Monitor

; 1673 :                                                      &variant,
; 1674 :                                                      &proc.hVirtualBytesPeak )
; 1675 :              )
; 1676 :      )
; 1677 :   {
; 1678 :     goto PROC_CLEANUP;
; 1679 :   }
; 1680 : 
; 1681 :   if (FAILED (hr = proc.pAccess->GetPropertyHandle ( L"VirtualBytes",

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	lea	edx, DWORD PTR _variant$[ebp]
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+28
	push	edx
	push	OFFSET $SG166491
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+108]
	test	eax, eax
	js	$LN68@SK_Monitor

; 1682 :                                                      &variant,
; 1683 :                                                      &proc.hVirtualBytes )
; 1684 :              )
; 1685 :      )
; 1686 :   {
; 1687 :     goto PROC_CLEANUP;
; 1688 :   }
; 1689 : 
; 1690 :   proc.pConfig->Release ();

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+12
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]

; 1691 :   proc.pConfig = nullptr;
; 1692 : 
; 1693 :   int iter = 0;
; 1694 : 
; 1695 :   proc.lID = 1;
; 1696 : 
; 1697 :   proc.hShutdownSignal = CreateEvent (nullptr, FALSE, FALSE, L"ProcMon Shutdown Signal");

	push	OFFSET $SG166493
	push	0
	push	0
	push	0
	mov	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+12, 0
	mov	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+20, 1
	call	DWORD PTR __imp__CreateEventW@16

; 1698 : 
; 1699 :   COM::base.wmi.Unlock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	mov	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+4, eax
	call	?Unlock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Unlock

; 1700 : 
; 1701 :   while (proc.lID != 0)

	cmp	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+20, 0
	je	$LN68@SK_Monitor
	movsd	xmm0, QWORD PTR _update$1$[ebp]
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	call	__dtoui3
	mov	edi, DWORD PTR __imp__WaitForSingleObject@8
	mov	esi, eax
	npad	4
$LL4@SK_Monitor:

; 1702 :   {
; 1703 :     // Sleep until ready
; 1704 :     if (WaitForSingleObject (proc.hShutdownSignal, (DWORD (update * 1000.0))) == WAIT_OBJECT_0)

	mov	ecx, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+4
	push	esi
	push	ecx
	call	edi
	test	eax, eax
	je	$LN68@SK_Monitor

; 1705 :       break;
; 1706 : 
; 1707 :     // Only poll WMI while the data view is visible
; 1708 :     if (! config.mem.show)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+12, 0
	je	$LN60@SK_Monitor

; 1709 :       continue;
; 1710 : 
; 1711 :     COM::base.wmi.Lock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	call	?Lock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Lock

; 1712 : 
; 1713 :     if (FAILED (hr = proc.pRefresher->Refresh (0L)))

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+8
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+12]
	test	eax, eax
	js	$LN68@SK_Monitor

; 1714 :     {
; 1715 :       goto PROC_CLEANUP;
; 1716 :     }
; 1717 : 
; 1718 :     proc.pAccess->ReadQWORD ( proc.hVirtualBytes,

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+64
	push	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+28
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+128]

; 1719 :                                 &proc.memory.virtual_bytes );
; 1720 :     proc.pAccess->ReadQWORD ( proc.hVirtualBytesPeak,

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+72
	push	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+32
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+128]

; 1721 :                                 &proc.memory.virtual_bytes_peak );
; 1722 : 
; 1723 :     proc.pAccess->ReadQWORD ( proc.hWorkingSet,

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+80
	push	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+36
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+128]

; 1724 :                                 &proc.memory.working_set );
; 1725 :     proc.pAccess->ReadQWORD ( proc.hWorkingSetPeak,

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+88
	push	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+40
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+128]

; 1726 :                                 &proc.memory.working_set_peak );
; 1727 : 
; 1728 :     proc.pAccess->ReadQWORD ( proc.hPrivateBytes,

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+96
	push	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+44
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+128]

; 1729 :                                 &proc.memory.private_bytes );
; 1730 : 
; 1731 :     proc.pAccess->ReadDWORD ( proc.hThreadCount,

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+120
	push	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+48
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+120]

; 1732 :                                 (DWORD *)&proc.tasks.thread_count );
; 1733 : 
; 1734 :     proc.pAccess->ReadQWORD ( proc.hPageFileBytes,

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+104
	push	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+52
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+128]

; 1735 :                                 &proc.memory.page_file_bytes );
; 1736 :     proc.pAccess->ReadQWORD ( proc.hPageFileBytesPeak,

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+112
	push	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+56
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+128]

; 1737 :                                 &proc.memory.page_file_bytes_peak );
; 1738 : 
; 1739 :     proc.booting = false;
; 1740 : 
; 1741 :     ++iter;
; 1742 : 
; 1743 :     COM::base.wmi.Unlock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	mov	BYTE PTR ?process_stats@@3Uprocess_stats_t@@A+24, 0
	call	?Unlock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Unlock
$LN60@SK_Monitor:

; 1700 : 
; 1701 :   while (proc.lID != 0)

	cmp	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+20, 0
	jne	$LL4@SK_Monitor
$LN68@SK_Monitor:
	pop	edi
$PROC_CLEANUP$69:

; 1744 :   }
; 1745 : 
; 1746 : PROC_CLEANUP:
; 1747 :   // dll_log.Log (L" >> PROC_CLEANUP");
; 1748 : 
; 1749 :   if (proc.pAccess != nullptr)

	mov	ecx, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	pop	esi
	test	ecx, ecx
	je	SHORT $LN35@SK_Monitor

; 1750 :   {
; 1751 :     proc.pAccess->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 1752 :     proc.pAccess = nullptr;

	mov	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16, 0
$LN35@SK_Monitor:

; 1753 :   }
; 1754 : 
; 1755 :   if (proc.pConfig != nullptr)

	mov	ecx, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+12
	test	ecx, ecx
	je	SHORT $LN36@SK_Monitor

; 1756 :   {
; 1757 :     proc.pConfig->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 1758 :     proc.pConfig = nullptr;

	mov	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+12, 0
$LN36@SK_Monitor:

; 1759 :   }
; 1760 : 
; 1761 :   if (proc.pRefresher != nullptr)

	mov	ecx, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+8
	test	ecx, ecx
	je	SHORT $LN37@SK_Monitor

; 1762 :   {
; 1763 :     proc.pRefresher->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 1764 :     proc.pRefresher = nullptr;

	mov	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+8, 0
$LN37@SK_Monitor:

; 1765 :   }
; 1766 : 
; 1767 :   if (proc.hShutdownSignal != INVALID_HANDLE_VALUE)

	cmp	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+4, -1
	je	SHORT $LN38@SK_Monitor

; 1768 :   {
; 1769 :     CloseHandle (proc.hShutdownSignal);

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+4
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 1770 :     proc.hShutdownSignal = INVALID_HANDLE_VALUE;

	mov	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+4, -1
$LN38@SK_Monitor:

; 1771 :   }
; 1772 : 
; 1773 :   COM::base.wmi.Unlock   ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	call	?Unlock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Unlock
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h

; 52   :     if (success)

	cmp	BYTE PTR _auto_com$[ebp], 0
	je	SHORT $LN65@SK_Monitor

; 53   :       CoUninitialize ();

	call	DWORD PTR __imp__CoUninitialize@0
$LN65@SK_Monitor:
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 1776 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	xor	eax, eax
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_MonitorProcess@@YGKPAX@Z$13:
	lea	ecx, DWORD PTR _auto_com$[ebp]
	jmp	??1SK_AutoCOMInit@@QAE@XZ		; SK_AutoCOMInit::~SK_AutoCOMInit
__ehhandler$?SK_MonitorProcess@@YGKPAX@Z:
	mov	eax, OFFSET __ehfuncinfo$?SK_MonitorProcess@@YGKPAX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_MonitorProcess@@YGKPAX@Z ENDP			; SK_MonitorProcess
; Function compile flags: /Ogtp
;	COMDAT ??0process_stats_t@@QAE@XZ
_TEXT	SEGMENT
??0process_stats_t@@QAE@XZ PROC				; process_stats_t::process_stats_t, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], -1
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], -1
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
	mov	BYTE PTR [ecx+24], 1
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+40], 0
	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+52], 0
	mov	DWORD PTR [ecx+56], 0
	ret	0
??0process_stats_t@@QAE@XZ ENDP				; process_stats_t::process_stats_t
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0WMI_refresh_instance_thread_t@@QAE@XZ
_TEXT	SEGMENT
??0WMI_refresh_instance_thread_t@@QAE@XZ PROC		; WMI_refresh_instance_thread_t::WMI_refresh_instance_thread_t, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], -1
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], -1
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
	mov	BYTE PTR [ecx+24], 1
	ret	0
??0WMI_refresh_instance_thread_t@@QAE@XZ ENDP		; WMI_refresh_instance_thread_t::WMI_refresh_instance_thread_t
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
;	COMDAT ??__Epagefile_stats@@YAXXZ
text$di	SEGMENT
??__Epagefile_stats@@YAXXZ PROC				; `dynamic initializer for 'pagefile_stats'', COMDAT

; 1180 : pagefile_perf_t pagefile_stats;

	mov	ecx, OFFSET ?pagefile_stats@@3Upagefile_perf_t@@A ; pagefile_stats
	jmp	??0pagefile_perf_t@@QAE@XZ
??__Epagefile_stats@@YAXXZ ENDP				; `dynamic initializer for 'pagefile_stats''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
;	COMDAT ??$isnan@N@@YA_NN@Z
_TEXT	SEGMENT
__X$ = 8						; size = 8
__X$ = 8						; size = 8
??$isnan@N@@YA_NN@Z PROC				; isnan<double>, COMDAT

; 402  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 403  :         return fpclassify(_X) == FP_NAN;

	movsd	xmm0, QWORD PTR __X$[ebp]

; 285  :         return _dtest(&_X);

	lea	eax, DWORD PTR __X$[ebp]
	push	eax

; 403  :         return fpclassify(_X) == FP_NAN;

	movsd	QWORD PTR __X$[ebp], xmm0

; 285  :         return _dtest(&_X);

	call	DWORD PTR __imp___dtest

; 403  :         return fpclassify(_X) == FP_NAN;

	xor	ecx, ecx

; 285  :         return _dtest(&_X);

	add	esp, 4

; 403  :         return fpclassify(_X) == FP_NAN;

	cmp	ax, 2
	sete	al

; 404  :     }

	pop	ebp
	ret	0
??$isnan@N@@YA_NN@Z ENDP				; isnan<double>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
;	COMDAT ??__Edisk_stats@@YAXXZ
text$di	SEGMENT
??__Edisk_stats@@YAXXZ PROC				; `dynamic initializer for 'disk_stats'', COMDAT

; 763  : disk_perf_t disk_stats;

	mov	ecx, OFFSET ?disk_stats@@3Udisk_perf_t@@A ; disk_stats
	jmp	??0disk_perf_t@@QAE@XZ
??__Edisk_stats@@YAXXZ ENDP				; `dynamic initializer for 'disk_stats''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
;	COMDAT ??$min@K@std@@YAABKABK0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@K@std@@YAABKABK0@Z PROC				; std::min<unsigned long>, COMDAT

; 3778 : 	{	// return smaller of _Left and _Right

	npad	2
	push	ebp
	mov	ebp, esp

; 3779 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	cmovb	eax, edx

; 3780 : 	}

	pop	ebp
	ret	0
??$min@K@std@@YAABKABK0@Z ENDP				; std::min<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
;	COMDAT ??__Ecpu_stats@@YAXXZ
text$di	SEGMENT
??__Ecpu_stats@@YAXXZ PROC				; `dynamic initializer for 'cpu_stats'', COMDAT

; 408  : cpu_perf_t cpu_stats;

	mov	ecx, OFFSET ?cpu_stats@@3Ucpu_perf_t@@A	; cpu_stats
	jmp	??0cpu_perf_t@@QAE@XZ
??__Ecpu_stats@@YAXXZ ENDP				; `dynamic initializer for 'cpu_stats''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
;	COMDAT ??B<lambda_cb83650d3cb2992700975903e3ec6658>@@QBEP6GKPAX@ZXZ
_TEXT	SEGMENT
??B<lambda_cb83650d3cb2992700975903e3ec6658>@@QBEP6GKPAX@ZXZ PROC ; <lambda_cb83650d3cb2992700975903e3ec6658>::operator unsigned long (__stdcall*)(void *), COMDAT
; _this$ = ecx

; 374  :                   },

	mov	eax, OFFSET ?<lambda_invoker_stdcall>@<lambda_cb83650d3cb2992700975903e3ec6658>@@CGKPAX@Z ; <lambda_cb83650d3cb2992700975903e3ec6658>::<lambda_invoker_stdcall>
	ret	0
??B<lambda_cb83650d3cb2992700975903e3ec6658>@@QBEP6GKPAX@ZXZ ENDP ; <lambda_cb83650d3cb2992700975903e3ec6658>::operator unsigned long (__stdcall*)(void *)
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
;	COMDAT ?<lambda_invoker_stdcall>@<lambda_cb83650d3cb2992700975903e3ec6658>@@CGKPAX@Z
_TEXT	SEGMENT
_auto_com$2 = -13					; size = 1
__$EHRec$ = -12						; size = 12
___p1$ = 8						; size = 4
?<lambda_invoker_stdcall>@<lambda_cb83650d3cb2992700975903e3ec6658>@@CGKPAX@Z PROC ; <lambda_cb83650d3cb2992700975903e3ec6658>::<lambda_invoker_stdcall>, COMDAT

; 374  :                   },

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?<lambda_invoker_stdcall>@<lambda_cb83650d3cb2992700975903e3ec6658>@@CGKPAX@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi

; 366  :                     InterlockedExchangePointer ( &COM::base.wmi.hServerThread,

	call	DWORD PTR __imp__GetCurrentThread@0
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 5265 :     return (PVOID)InterlockedExchange((LONG volatile *) Destination,

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+20
	xchg	DWORD PTR [ecx], eax
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h

; 45   :     HRESULT hr = CoInitializeEx (NULL, COINIT_MULTITHREADED);

	push	0
	push	0

; 54   :   }
; 55   : 
; 56   : private:
; 57   :   bool success = false;

	xor	bl, bl
	call	DWORD PTR __imp__CoInitializeEx@8
	test	eax, eax
	movzx	ebx, bl
	mov	ecx, 1
	cmovns	ebx, ecx
	mov	BYTE PTR _auto_com$2[ebp], bl
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 369  :                     SK_AutoCOMInit auto_com;

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 370  : 
; 371  :                     SK_InitCOM ();

	call	?SK_InitCOM@@YA_NXZ			; SK_InitCOM

; 372  : 
; 373  :                     return SK_WMI_ServerThread (nullptr);

	push	0
	call	?SK_WMI_ServerThread@@YGKPAX@Z		; SK_WMI_ServerThread
	mov	esi, eax
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h

; 52   :     if (success)

	test	bl, bl
	je	SHORT $LN12@

; 53   :       CoUninitialize ();

	call	DWORD PTR __imp__CoUninitialize@0
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 374  :                   },

	mov	eax, esi
$LN12@:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?<lambda_invoker_stdcall>@<lambda_cb83650d3cb2992700975903e3ec6658>@@CGKPAX@Z$0:
	lea	ecx, DWORD PTR _auto_com$2[ebp]
	jmp	??1SK_AutoCOMInit@@QAE@XZ		; SK_AutoCOMInit::~SK_AutoCOMInit
__ehhandler$?<lambda_invoker_stdcall>@<lambda_cb83650d3cb2992700975903e3ec6658>@@CGKPAX@Z:
	mov	eax, OFFSET __ehfuncinfo$?<lambda_invoker_stdcall>@<lambda_cb83650d3cb2992700975903e3ec6658>@@CGKPAX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?<lambda_invoker_stdcall>@<lambda_cb83650d3cb2992700975903e3ec6658>@@CGKPAX@Z ENDP ; <lambda_cb83650d3cb2992700975903e3ec6658>::<lambda_invoker_stdcall>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
;	COMDAT ??R<lambda_cb83650d3cb2992700975903e3ec6658>@@QBEKPAX@Z
_TEXT	SEGMENT
_auto_com$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
??R<lambda_cb83650d3cb2992700975903e3ec6658>@@QBEKPAX@Z PROC ; <lambda_cb83650d3cb2992700975903e3ec6658>::operator(), COMDAT
; _this$ = ecx

; 365  :                   {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??R<lambda_cb83650d3cb2992700975903e3ec6658>@@QBEKPAX@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi

; 366  :                     InterlockedExchangePointer ( &COM::base.wmi.hServerThread,

	call	DWORD PTR __imp__GetCurrentThread@0
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 5265 :     return (PVOID)InterlockedExchange((LONG volatile *) Destination,

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+20
	xchg	DWORD PTR [ecx], eax
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h

; 45   :     HRESULT hr = CoInitializeEx (NULL, COINIT_MULTITHREADED);

	push	0
	push	0

; 54   :   }
; 55   : 
; 56   : private:
; 57   :   bool success = false;

	xor	bl, bl
	call	DWORD PTR __imp__CoInitializeEx@8
	test	eax, eax
	movzx	ebx, bl
	mov	ecx, 1
	cmovns	ebx, ecx
	mov	BYTE PTR _auto_com$[ebp], bl
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 369  :                     SK_AutoCOMInit auto_com;

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 370  : 
; 371  :                     SK_InitCOM ();

	call	?SK_InitCOM@@YA_NXZ			; SK_InitCOM

; 373  :                     return SK_WMI_ServerThread (nullptr);

	push	0
	call	?SK_WMI_ServerThread@@YGKPAX@Z		; SK_WMI_ServerThread
	mov	esi, eax
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h

; 52   :     if (success)

	test	bl, bl
	je	SHORT $LN10@operator

; 53   :       CoUninitialize ();

	call	DWORD PTR __imp__CoUninitialize@0
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 373  :                     return SK_WMI_ServerThread (nullptr);

	mov	eax, esi
$LN10@operator:

; 374  :                   },

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??R<lambda_cb83650d3cb2992700975903e3ec6658>@@QBEKPAX@Z$0:
	lea	ecx, DWORD PTR _auto_com$[ebp]
	jmp	??1SK_AutoCOMInit@@QAE@XZ		; SK_AutoCOMInit::~SK_AutoCOMInit
__ehhandler$??R<lambda_cb83650d3cb2992700975903e3ec6658>@@QBEKPAX@Z:
	mov	eax, OFFSET __ehfuncinfo$??R<lambda_cb83650d3cb2992700975903e3ec6658>@@QBEKPAX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??R<lambda_cb83650d3cb2992700975903e3ec6658>@@QBEKPAX@Z ENDP ; <lambda_cb83650d3cb2992700975903e3ec6658>::operator()
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
_TEXT	SEGMENT
tv172 = -8						; size = 4
_auto_com$2$ = -1					; size = 1
?SK_InitWMI@@YA_NXZ PROC				; SK_InitWMI

; 343  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h

; 45   :     HRESULT hr = CoInitializeEx (NULL, COINIT_MULTITHREADED);

	push	0
	push	0

; 54   :   }
; 55   : 
; 56   : private:
; 57   :   bool success = false;

	mov	BYTE PTR _auto_com$2$[ebp], 0
	call	DWORD PTR __imp__CoInitializeEx@8
	movzx	ecx, BYTE PTR _auto_com$2$[ebp]
	test	eax, eax
	mov	edx, 1
	cmovns	ecx, edx
	mov	DWORD PTR tv172[ebp], ecx
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 346  :   if (! SK_InitCOM ())

	call	?SK_InitCOM@@YA_NXZ			; SK_InitCOM
	test	al, al
	jne	SHORT $LN4@SK_InitWMI
	xor	bl, bl
	jmp	$LN11@SK_InitWMI
$LN4@SK_InitWMI:

; 347  :     return false;
; 348  : 
; 349  :   COM::base.wmi.Lock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	call	?Lock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Lock
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?base@COM@@3UBase@1@A+4
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 351  :   if (ReadAcquire (&COM::base.wmi.init) > 0)

	test	eax, eax
	jle	SHORT $LN5@SK_InitWMI

; 352  :   {
; 353  :     COM::base.wmi.Unlock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	call	?Unlock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Unlock
	jmp	SHORT $LN3@SK_InitWMI
$LN5@SK_InitWMI:
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 5286 :     return (PVOID)InterlockedCompareExchange((LONG volatile *) Destination,

	xor	ecx, ecx
	mov	edx, OFFSET ?base@COM@@3UBase@1@A+20
	or	eax, -1
	lock	 cmpxchg DWORD PTR [edx], ecx
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 357  :   if (InterlockedCompareExchangePointer (&COM::base.wmi.hServerThread, nullptr, INVALID_HANDLE_VALUE) == INVALID_HANDLE_VALUE)

	cmp	eax, -1
	jne	SHORT $LN36@SK_InitWMI

; 358  :   {
; 359  :     COM::base.wmi.hShutdownServer =

	push	OFFSET $SG165829
	push	0
	push	1
	push	0
	call	DWORD PTR __imp__CreateEventW@16

; 360  :       CreateEvent (nullptr, TRUE, FALSE, L"WMI Shutdown");
; 361  : 
; 362  :     CreateThread (nullptr, 0,

	push	0
	push	0
	push	0
	push	OFFSET ?<lambda_invoker_stdcall>@<lambda_cb83650d3cb2992700975903e3ec6658>@@CGKPAX@Z ; <lambda_cb83650d3cb2992700975903e3ec6658>::<lambda_invoker_stdcall>
	push	0
	push	0
	mov	DWORD PTR ?base@COM@@3UBase@1@A+24, eax
	call	DWORD PTR __imp__CreateThread@24

; 363  :                   [](LPVOID) ->
; 364  :                   DWORD
; 365  :                   {
; 366  :                     InterlockedExchangePointer ( &COM::base.wmi.hServerThread,
; 367  :                                                    GetCurrentThread () );
; 368  : 
; 369  :                     SK_AutoCOMInit auto_com;
; 370  : 
; 371  :                     SK_InitCOM ();
; 372  : 
; 373  :                     return SK_WMI_ServerThread (nullptr);
; 374  :                   },
; 375  :                   nullptr, 0x00, nullptr
; 376  :                   );
; 377  :   }
; 378  : 
; 379  :   else

	jmp	SHORT $LN3@SK_InitWMI
$LN36@SK_InitWMI:
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?base@COM@@3UBase@1@A+4
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 381  :     while (! ReadAcquire (&COM::base.wmi.init))

	test	eax, eax
	jne	SHORT $LN3@SK_InitWMI
	push	esi
	mov	esi, DWORD PTR __imp__SleepEx@8
$LL2@SK_InitWMI:

; 382  :       SleepEx (333, FALSE);

	push	0
	push	333					; 0000014dH
	call	esi
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?base@COM@@3UBase@1@A+4
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 381  :     while (! ReadAcquire (&COM::base.wmi.init))

	test	eax, eax
	je	SHORT $LL2@SK_InitWMI
	pop	esi
$LN3@SK_InitWMI:

; 385  :   return true;

	mov	bl, 1
$LN11@SK_InitWMI:
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h

; 52   :     if (success)

	cmp	BYTE PTR tv172[ebp], 0
	je	SHORT $LN40@SK_InitWMI

; 53   :       CoUninitialize ();

	call	DWORD PTR __imp__CoUninitialize@0
$LN40@SK_InitWMI:
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 385  :   return true;

	mov	al, bl
	pop	ebx

; 386  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SK_InitWMI@@YA_NXZ ENDP				; SK_InitWMI
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
_TEXT	SEGMENT
?SK_InitCOM@@YA_NXZ PROC				; SK_InitCOM

; 309  :   HRESULT hr;
; 310  : 
; 311  :   //
; 312  :   // HACK to address problems with Steam Overlay
; 313  :   //
; 314  :   SleepEx (50, TRUE);

	push	1
	push	50					; 00000032H
	call	DWORD PTR __imp__SleepEx@8

; 315  : 
; 316  :   if (FAILED (hr = CoInitializeSecurity (

	push	0
	push	0
	push	0
	push	3
	push	1
	push	0
	push	0
	push	-1
	push	0
	call	DWORD PTR __imp__CoInitializeSecurity@36
	test	eax, eax
	jns	SHORT $LN3@SK_InitCOM

; 317  :                      nullptr,
; 318  :                      -1,
; 319  :                      nullptr,
; 320  :                      nullptr,
; 321  :                      RPC_C_AUTHN_LEVEL_NONE,
; 322  :                      RPC_C_IMP_LEVEL_IMPERSONATE,
; 323  :                      nullptr, EOAC_NONE, nullptr )
; 324  :              )
; 325  :      )
; 326  :   {
; 327  :     // It's possible that the application already did this, in which case
; 328  :     //   it is immutable and we should try to deal with whatever the app
; 329  :     //     initialized it to.
; 330  :     if (hr != RPC_E_TOO_LATE)

	cmp	eax, -2147417831			; 80010119H
	je	SHORT $LN3@SK_InitCOM

; 331  :     {
; 332  :       dll_log.Log (L"[COM Secure] Failure to initialize COM Security (%s:%d) -- 0x%X",

	push	eax
	push	333					; 0000014dH
	push	OFFSET $SG165752
	push	OFFSET $SG165753
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 20					; 00000014H

; 333  :         __FILEW__, __LINE__, hr);
; 334  :       return false;

	xor	al, al

; 339  : }

	ret	0
$LN3@SK_InitCOM:

; 335  :     }
; 336  :   }
; 337  : 
; 338  :   return true;

	mov	al, 1

; 339  : }

	ret	0
?SK_InitCOM@@YA_NXZ ENDP				; SK_InitCOM
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
_TEXT	SEGMENT
_pUnk$ = -20						; size = 4
_auto_com$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
_lpUser$ = 8						; size = 4
?SK_WMI_ServerThread@@YGKPAX@Z PROC			; SK_WMI_ServerThread

; 173  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SK_WMI_ServerThread@@YGKPAX@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h

; 45   :     HRESULT hr = CoInitializeEx (NULL, COINIT_MULTITHREADED);

	push	0
	push	0

; 54   :   }
; 55   : 
; 56   : private:
; 57   :   bool success = false;

	xor	bl, bl
	call	DWORD PTR __imp__CoInitializeEx@8
	test	eax, eax
	movzx	ebx, bl
	mov	esi, 1
	cmovns	ebx, esi
	mov	BYTE PTR _auto_com$[ebp], bl
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 176  :   if (config.steam.preload_overlay)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+389, 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	je	SHORT $LN4@SK_WMI_Ser

; 177  :   {
; 178  :     extern bool SK_Steam_LoadOverlayEarly (void);
; 179  :                 SK_Steam_LoadOverlayEarly (    );

	call	?SK_Steam_LoadOverlayEarly@@YA_NXZ	; SK_Steam_LoadOverlayEarly
$LN4@SK_WMI_Ser:

; 180  :   }
; 181  : 
; 182  :   UNREFERENCED_PARAMETER (lpUser);
; 183  : 
; 184  :   HRESULT hr;
; 185  : 
; 186  :   if (FAILED (hr = CoCreateInstance (

	push	OFFSET ?base@COM@@3UBase@1@A+12
	push	OFFSET _IID_IWbemLocator
	push	1
	push	0
	push	OFFSET _CLSID_WbemLocator
	call	DWORD PTR __imp__CoCreateInstance@20
	test	eax, eax
	jns	$LN5@SK_WMI_Ser

; 187  :                      CLSID_WbemLocator, 
; 188  :                      nullptr,
; 189  :                      CLSCTX_INPROC_SERVER,
; 190  :                      IID_IWbemLocator,
; 191  :                      (void**) &COM::base.wmi.pWbemLocator )
; 192  :              )
; 193  :      )
; 194  :   {
; 195  :     dll_log.Log (L"[ WMI Wbem ] Failed to create Wbem Locator (%s:%d) -- 0x%X",

	push	eax
	push	196					; 000000c4H
	push	OFFSET $SG165718
	push	OFFSET $SG165719
$LN34@SK_WMI_Ser:

; 211  :                      COM::base.wmi.bstrNameSpace,
; 212  :                      nullptr, // User name
; 213  :                      nullptr, // Password
; 214  :                      nullptr, // Locale
; 215  :                      0L,      // Security flags
; 216  :                      nullptr, // Authority
; 217  :                      nullptr, // Wbem context
; 218  :                      &COM::base.wmi.pNameSpace )
; 219  :              )
; 220  :      )
; 221  :   {
; 222  :     dll_log.Log (L"[ WMI Wbem ] Failure to Connect to Wbem Server (%s:%d) -- 0x%X",

	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 20					; 00000014H
$WMI_CLEANUP$35:

; 273  :   }
; 274  : 
; 275  :   goto WMI_CLEANUP_WITHOUT_LOCK;
; 276  : 
; 277  : 
; 278  : WMI_CLEANUP:
; 279  :   COM::base.wmi.Unlock ();

	mov	edi, OFFSET ?base@COM@@3UBase@1@A+4
	mov	ecx, edi
	call	?Unlock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Unlock
$WMI_CLEANUP_WITHOUT_LOCK$36:

; 280  : 
; 281  : 
; 282  : WMI_CLEANUP_WITHOUT_LOCK:
; 283  :   if (COM::base.wmi.bstrNameSpace != nullptr)

	mov	eax, DWORD PTR ?base@COM@@3UBase@1@A+16
	test	eax, eax
	je	SHORT $LN17@SK_WMI_Ser

; 284  :   {
; 285  :     SysFreeString (COM::base.wmi.bstrNameSpace);

	push	eax
	call	DWORD PTR __imp__SysFreeString@4

; 286  :     COM::base.wmi.bstrNameSpace       = nullptr;

	mov	DWORD PTR ?base@COM@@3UBase@1@A+16, 0
$LN17@SK_WMI_Ser:

; 287  :   }
; 288  : 
; 289  :   if (COM::base.wmi.pWbemLocator != nullptr)

	mov	ecx, DWORD PTR ?base@COM@@3UBase@1@A+12
	test	ecx, ecx
	je	SHORT $LN18@SK_WMI_Ser

; 290  :   {
; 291  :     COM::base.wmi.pWbemLocator->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 292  :     COM::base.wmi.pWbemLocator   = nullptr;

	mov	DWORD PTR ?base@COM@@3UBase@1@A+12, 0
$LN18@SK_WMI_Ser:

; 293  :   }
; 294  : 
; 295  :   if (COM::base.wmi.pNameSpace != nullptr)

	mov	ecx, DWORD PTR ?base@COM@@3UBase@1@A+8
	test	ecx, ecx
	je	SHORT $LN19@SK_WMI_Ser

; 296  :   {
; 297  :     COM::base.wmi.pNameSpace->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 298  :     COM::base.wmi.pNameSpace   = nullptr;

	mov	DWORD PTR ?base@COM@@3UBase@1@A+8, 0
$LN19@SK_WMI_Ser:

; 299  :   }
; 300  : 
; 301  :   InterlockedExchange (&COM::base.wmi.init, 0);

	xor	eax, eax
	xchg	DWORD PTR [edi], eax
	pop	edi
	pop	esi
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h

; 52   :     if (success)

	test	bl, bl
	pop	ebx
	je	SHORT $LN32@SK_WMI_Ser

; 53   :       CoUninitialize ();

	call	DWORD PTR __imp__CoUninitialize@0
$LN32@SK_WMI_Ser:
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 304  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	xor	eax, eax
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN5@SK_WMI_Ser:

; 196  :       __FILEW__, __LINE__, hr);
; 197  :     goto WMI_CLEANUP;
; 198  :   }
; 199  : 
; 200  :   // Connect to the desired namespace.
; 201  :   COM::base.wmi.bstrNameSpace = SysAllocString (L"\\\\.\\Root\\CIMv2");

	push	OFFSET $SG165721
	call	DWORD PTR __imp__SysAllocString@4
	mov	edx, eax
	mov	DWORD PTR ?base@COM@@3UBase@1@A+16, edx

; 202  :   if (COM::base.wmi.bstrNameSpace == nullptr)

	test	edx, edx
	jne	SHORT $LN7@SK_WMI_Ser

; 203  :   {
; 204  :     dll_log.Log (L"[ WMI Wbem ] Out of Memory (%s:%d)",

	push	205					; 000000cdH
	push	OFFSET $SG165723
	push	OFFSET $SG165724
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 205  :       __FILEW__, __LINE__);
; 206  :     hr = E_OUTOFMEMORY;
; 207  :     goto WMI_CLEANUP;

	jmp	$WMI_CLEANUP$35
$LN7@SK_WMI_Ser:

; 208  :   }
; 209  : 
; 210  :   if (FAILED (hr = COM::base.wmi.pWbemLocator->ConnectServer (

	mov	eax, DWORD PTR ?base@COM@@3UBase@1@A+12
	push	OFFSET ?base@COM@@3UBase@1@A+8
	push	0
	push	0
	mov	ecx, DWORD PTR [eax]
	push	0
	push	0
	push	0
	push	0
	push	edx
	push	eax
	call	DWORD PTR [ecx+12]
	test	eax, eax
	jns	SHORT $LN9@SK_WMI_Ser

; 211  :                      COM::base.wmi.bstrNameSpace,
; 212  :                      nullptr, // User name
; 213  :                      nullptr, // Password
; 214  :                      nullptr, // Locale
; 215  :                      0L,      // Security flags
; 216  :                      nullptr, // Authority
; 217  :                      nullptr, // Wbem context
; 218  :                      &COM::base.wmi.pNameSpace )
; 219  :              )
; 220  :      )
; 221  :   {
; 222  :     dll_log.Log (L"[ WMI Wbem ] Failure to Connect to Wbem Server (%s:%d) -- 0x%X",

	push	eax
	push	223					; 000000dfH
	push	OFFSET $SG165727
	push	OFFSET $SG165728

; 223  :       __FILEW__, __LINE__, hr);
; 224  :     goto WMI_CLEANUP;

	jmp	$LN34@SK_WMI_Ser
$LN9@SK_WMI_Ser:

; 225  :   }
; 226  : 
; 227  :   IUnknown* pUnk = nullptr;
; 228  : 
; 229  :   if (FAILED (COM::base.wmi.pNameSpace->QueryInterface (IID_IUnknown, (void **)&pUnk)))

	mov	eax, DWORD PTR ?base@COM@@3UBase@1@A+8
	lea	edx, DWORD PTR _pUnk$[ebp]
	push	edx
	mov	DWORD PTR _pUnk$[ebp], 0
	push	OFFSET _IID_IUnknown
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx]
	test	eax, eax
	js	$WMI_CLEANUP$35

; 230  :     goto WMI_CLEANUP;
; 231  : 
; 232  :   // Set the proxy so that impersonation of the client occurs.
; 233  :   if (FAILED (hr = CoSetProxyBlanket (

	push	0
	push	0
	push	3
	push	3
	push	0
	push	0
	push	10					; 0000000aH
	push	DWORD PTR _pUnk$[ebp]
	call	DWORD PTR __imp__CoSetProxyBlanket@32
	test	eax, eax
	jns	SHORT $LN13@SK_WMI_Ser

; 234  :                      pUnk,
; 235  :                      RPC_C_AUTHN_WINNT,
; 236  :                      RPC_C_AUTHZ_NONE,
; 237  :                      nullptr,
; 238  :                      RPC_C_AUTHN_LEVEL_CALL,
; 239  :                      RPC_C_IMP_LEVEL_IMPERSONATE,
; 240  :                      nullptr,
; 241  :                      EOAC_NONE )
; 242  :              )
; 243  :      )
; 244  :   {
; 245  :     dll_log.Log (L"[ WMI Wbem ] Failure to set proxy impersonation (%s:%d) -- 0x%X",

	push	eax
	push	246					; 000000f6H
	push	OFFSET $SG165733
	push	OFFSET $SG165734
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 246  :       __FILEW__, __LINE__, hr);
; 247  :     pUnk->Release ();

	mov	eax, DWORD PTR _pUnk$[ebp]
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
	jmp	$WMI_CLEANUP$35
$LN13@SK_WMI_Ser:

; 248  :     goto WMI_CLEANUP;
; 249  :   }
; 250  : 
; 251  :   pUnk->Release ();

	mov	eax, DWORD PTR _pUnk$[ebp]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]

; 252  : 
; 253  :   SleepEx (1500UL, TRUE);

	push	1
	push	1500					; 000005dcH
	call	DWORD PTR __imp__SleepEx@8

; 254  : 
; 255  :   COM::base.wmi.Unlock (                      );

	mov	edi, OFFSET ?base@COM@@3UBase@1@A+4
	mov	ecx, edi
	call	?Unlock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Unlock

; 256  : 
; 257  :   InterlockedExchange   (&COM::base.wmi.init, 1);

	xchg	DWORD PTR [edi], esi
	mov	esi, DWORD PTR __imp__WaitForSingleObject@8
	npad	4
$LL2@SK_WMI_Ser:

; 258  : 
; 259  :   // Keep the thread alive indefinitely so that the WMI stuff continues running
; 260  :   while (WaitForSingleObject (COM::base.wmi.hShutdownServer, INFINITE) != WAIT_OBJECT_0)

	push	-1
	push	DWORD PTR ?base@COM@@3UBase@1@A+24
	call	esi
	test	eax, eax
	jne	SHORT $LL2@SK_WMI_Ser

; 261  :     ;
; 262  : 
; 263  : 
; 264  :   extern HMODULE hModOverlay;
; 265  :   if (hModOverlay != nullptr)

	cmp	DWORD PTR ?hModOverlay@@3PAUHINSTANCE__@@A, eax ; hModOverlay
	je	$WMI_CLEANUP_WITHOUT_LOCK$36

; 266  :   {
; 267  :     dll_log.LogEx (true, L"[ SpecialK ] Unloading Steam Overlay... ");

	push	OFFSET $SG165737
	push	1
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	add	esp, 12					; 0000000cH

; 268  :   
; 269  :     FreeLibrary (hModOverlay);

	push	DWORD PTR ?hModOverlay@@3PAUHINSTANCE__@@A ; hModOverlay
	call	DWORD PTR __imp__FreeLibrary@4

; 270  :     hModOverlay = nullptr;
; 271  :   
; 272  :     dll_log.LogEx (false, L"done!\n");

	push	OFFSET $SG165738
	push	0
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	mov	DWORD PTR ?hModOverlay@@3PAUHINSTANCE__@@A, 0 ; hModOverlay
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	add	esp, 12					; 0000000cH
	jmp	$WMI_CLEANUP_WITHOUT_LOCK$36
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_WMI_ServerThread@@YGKPAX@Z$6:
	lea	ecx, DWORD PTR _auto_com$[ebp]
	jmp	??1SK_AutoCOMInit@@QAE@XZ		; SK_AutoCOMInit::~SK_AutoCOMInit
__ehhandler$?SK_WMI_ServerThread@@YGKPAX@Z:
	mov	eax, OFFSET __ehfuncinfo$?SK_WMI_ServerThread@@YGKPAX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_WMI_ServerThread@@YGKPAX@Z ENDP			; SK_WMI_ServerThread
; Function compile flags: /Ogtp
;	COMDAT ??0Base@COM@@QAE@XZ
_TEXT	SEGMENT
??0Base@COM@@QAE@XZ PROC				; COM::Base::Base, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], -1
	mov	DWORD PTR [ecx+24], 0
	ret	0
??0Base@COM@@QAE@XZ ENDP				; COM::Base::Base
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0WMI@Base@COM@@QAE@XZ
_TEXT	SEGMENT
??0WMI@Base@COM@@QAE@XZ PROC				; COM::Base::WMI::WMI, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], -1
	mov	DWORD PTR [ecx+20], 0
	ret	0
??0WMI@Base@COM@@QAE@XZ ENDP				; COM::Base::WMI::WMI
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
_TEXT	SEGMENT
?Unlock@WMI@Base@COM@@QAEXXZ PROC			; COM::Base::WMI::Unlock
; _this$ = ecx
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h

; 269  :     LeaveCriticalSection (cs_);

	mov	eax, DWORD PTR ?wmi_cs@@3PAVSK_Thread_HybridSpinlock@@A ; wmi_cs
	push	DWORD PTR [eax]
	call	DWORD PTR __imp__LeaveCriticalSection@4
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 168  : }

	ret	0
?Unlock@WMI@Base@COM@@QAEXXZ ENDP			; COM::Base::WMI::Unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
_TEXT	SEGMENT
?Lock@WMI@Base@COM@@QAEXXZ PROC				; COM::Base::WMI::Lock
; _this$ = ecx
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h

; 264  :     EnterCriticalSection (cs_);

	mov	eax, DWORD PTR ?wmi_cs@@3PAVSK_Thread_HybridSpinlock@@A ; wmi_cs
	push	DWORD PTR [eax]
	call	DWORD PTR __imp__EnterCriticalSection@4
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 161  : }

	ret	0
?Lock@WMI@Base@COM@@QAEXXZ ENDP				; COM::Base::WMI::Lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\widgets\widget.h
;	COMDAT ?isActive@SK_Widget@@QBE_NXZ
_TEXT	SEGMENT
?isActive@SK_Widget@@QBE_NXZ PROC			; SK_Widget::isActive, COMDAT
; _this$ = ecx

; 129  :         bool         isActive        (void) const { return    active;         }

	mov	al, BYTE PTR [ecx+185]
	ret	0
?isActive@SK_Widget@@QBE_NXZ ENDP			; SK_Widget::isActive
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ?unlock@SK_Thread_CriticalSection@@QAEXXZ
_TEXT	SEGMENT
?unlock@SK_Thread_CriticalSection@@QAEXXZ PROC		; SK_Thread_CriticalSection::unlock, COMDAT
; _this$ = ecx

; 269  :     LeaveCriticalSection (cs_);

	push	DWORD PTR [ecx]
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 270  :   }

	ret	0
?unlock@SK_Thread_CriticalSection@@QAEXXZ ENDP		; SK_Thread_CriticalSection::unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ?lock@SK_Thread_CriticalSection@@QAEXXZ
_TEXT	SEGMENT
?lock@SK_Thread_CriticalSection@@QAEXXZ PROC		; SK_Thread_CriticalSection::lock, COMDAT
; _this$ = ecx

; 264  :     EnterCriticalSection (cs_);

	push	DWORD PTR [ecx]
	call	DWORD PTR __imp__EnterCriticalSection@4

; 265  :   }

	ret	0
?lock@SK_Thread_CriticalSection@@QAEXXZ ENDP		; SK_Thread_CriticalSection::lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\framerate.h
;	COMDAT ?addSample@Stats@Framerate@SK@@QAEXNT_LARGE_INTEGER@@@Z
_TEXT	SEGMENT
_sample$ = 8						; size = 8
_time$ = 16						; size = 8
?addSample@Stats@Framerate@SK@@QAEXNT_LARGE_INTEGER@@@Z PROC ; SK::Framerate::Stats::addSample, COMDAT
; _this$ = ecx

; 112  :       {

	npad	2
	push	ebp
	mov	ebp, esp

; 113  :         data [samples % MAX_SAMPLES].val  = sample;

	mov	eax, DWORD PTR [ecx+1920]
	cdq
	push	esi
	mov	esi, 120				; 00000078H
	movsd	xmm0, QWORD PTR _sample$[ebp]
	idiv	esi
	add	edx, edx
	movsd	QWORD PTR [ecx+edx*8], xmm0

; 114  :         data [samples % MAX_SAMPLES].when = time;

	mov	eax, DWORD PTR [ecx+1920]
	cdq
	idiv	esi
	mov	eax, DWORD PTR _time$[ebp]
	add	edx, edx
	pop	esi
	mov	DWORD PTR [ecx+edx*8+8], eax
	mov	eax, DWORD PTR _time$[ebp+4]
	mov	DWORD PTR [ecx+edx*8+12], eax

; 115  : 
; 116  :         samples++;

	inc	DWORD PTR [ecx+1920]

; 117  :       }

	pop	ebp
	ret	16					; 00000010H
?addSample@Stats@Framerate@SK@@QAEXNT_LARGE_INTEGER@@@Z ENDP ; SK::Framerate::Stats::addSample
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0sample_t@Stats@Framerate@SK@@QAE@XZ
_TEXT	SEGMENT
??0sample_t@Stats@Framerate@SK@@QAE@XZ PROC		; SK::Framerate::Stats::sample_t::sample_t, COMDAT
; _this$ = ecx
	xorps	xmm0, xmm0
	mov	DWORD PTR [ecx+8], 0
	movsd	QWORD PTR [ecx], xmm0
	mov	eax, ecx
	mov	DWORD PTR [ecx+12], 0
	ret	0
??0sample_t@Stats@Framerate@SK@@QAE@XZ ENDP		; SK::Framerate::Stats::sample_t::sample_t
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\framerate.h
;	COMDAT ??0Stats@Framerate@SK@@QAE@XZ
_TEXT	SEGMENT
??0Stats@Framerate@SK@@QAE@XZ PROC			; SK::Framerate::Stats::Stats, COMDAT
; _this$ = ecx

; 100  :       Stats (void) {

	npad	2
	push	esi
	mov	esi, ecx
	mov	edx, 120				; 00000078H
	xorps	xmm0, xmm0
	lea	eax, DWORD PTR [esi+12]
$LL4@Stats:
	movsd	QWORD PTR [eax-12], xmm0
	lea	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [eax-20], 0
	mov	DWORD PTR [eax-16], 0
	sub	edx, 1
	jne	SHORT $LL4@Stats

; 101  :         QueryPerformanceFrequency (&freq);

	push	OFFSET ?freq@Stats@Framerate@SK@@2T_LARGE_INTEGER@@A ; SK::Framerate::Stats::freq

; 103  : 
; 104  :     #define MAX_SAMPLES 120
; 105  :       struct sample_t {
; 106  :         double        val  = 0.0;
; 107  :         LARGE_INTEGER when = { 0ULL };
; 108  :       } data [MAX_SAMPLES];
; 109  :       int    samples       = 0;

	mov	DWORD PTR [esi+1920], edx
	call	DWORD PTR __imp__QueryPerformanceFrequency@4
	mov	eax, esi
	pop	esi
	ret	0
??0Stats@Framerate@SK@@QAE@XZ ENDP			; SK::Framerate::Stats::Stats
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
;	COMDAT ?fpclassify@@YAHN@Z
_TEXT	SEGMENT
__X$ = 8						; size = 8
?fpclassify@@YAHN@Z PROC				; fpclassify, COMDAT

; 284  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 285  :         return _dtest(&_X);

	lea	eax, DWORD PTR __X$[ebp]
	push	eax
	call	DWORD PTR __imp___dtest
	add	esp, 4
	cwde

; 286  :     }

	pop	ebp
	ret	0
?fpclassify@@YAHN@Z ENDP				; fpclassify
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
_TEXT	SEGMENT
_name$2 = -572						; size = 512
_PercentUsage_BaseType$3 = -60				; size = 4
_PercentUsagePeakType$4 = -56				; size = 4
_PercentUsageType$5 = -52				; size = 4
_NameType$6 = -48					; size = 4
_update$1$ = -44					; size = 8
tv1561 = -40						; size = 4
_usage_peak$7 = -36					; size = 4
_usage$8 = -32						; size = 4
_size$9 = -28						; size = 4
_bytes$10 = -24						; size = 4
_iter$1$ = -20						; size = 4
_auto_com$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
_user$ = 8						; size = 4
?SK_MonitorPagefile@@YGKPAX@Z PROC			; SK_MonitorPagefile

; 1185 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?SK_MonitorPagefile@@YGKPAX@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 560				; 00000230H
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?base@COM@@3UBase@1@A+4
	push	ebx
	push	esi
	push	edi
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 1186 :   while (! ReadAcquire (&COM::base.wmi.init))

	test	eax, eax
	jne	SHORT $LN3@SK_Monitor
	mov	esi, DWORD PTR __imp__SleepEx@8
$LL2@SK_Monitor:

; 1187 :     SleepEx (150, FALSE);

	push	0
	push	150					; 00000096H
	call	esi
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?base@COM@@3UBase@1@A+4
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 1186 :   while (! ReadAcquire (&COM::base.wmi.init))

	test	eax, eax
	je	SHORT $LL2@SK_Monitor
$LN3@SK_Monitor:
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h

; 45   :     HRESULT hr = CoInitializeEx (NULL, COINIT_MULTITHREADED);

	push	0
	push	0

; 54   :   }
; 55   : 
; 56   : private:
; 57   :   bool success = false;

	xor	bl, bl
	call	DWORD PTR __imp__CoInitializeEx@8
	test	eax, eax
	movzx	ecx, bl
	mov	edx, 1
	cmovns	ecx, edx
	mov	BYTE PTR _auto_com$[ebp], cl
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 1193 :   COM::base.wmi.Lock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?Lock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Lock
	movss	xmm0, DWORD PTR ?config@@3Usk_config_t@@A+152

; 1194 : 
; 1195 :   pagefile_perf_t&  pagefile = pagefile_stats;
; 1196 : 
; 1197 :                     pagefile.dwNumReturned = 0;
; 1198 :                     pagefile.dwNumObjects  = 0;
; 1199 : 
; 1200 :   const double update = config.pagefile.interval;
; 1201 : 
; 1202 :   HRESULT hr;
; 1203 : 
; 1204 :   if (FAILED (hr = CoCreateInstance (

	push	OFFSET ?pagefile_stats@@3Upagefile_perf_t@@A+8
	push	OFFSET _IID_IWbemRefresher
	cvtps2pd xmm0, xmm0
	push	1
	push	0
	push	OFFSET _CLSID_WbemRefresher
	mov	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+32, 0
	mov	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+28, 0
	movsd	QWORD PTR _update$1$[ebp], xmm0
	call	DWORD PTR __imp__CoCreateInstance@20
	test	eax, eax
	jns	SHORT $LN12@SK_Monitor
$LN87@SK_Monitor:

; 1205 :                      CLSID_WbemRefresher,
; 1206 :                      nullptr,
; 1207 :                      CLSCTX_INPROC_SERVER,
; 1208 :                      IID_IWbemRefresher, 
; 1209 :                      (void**) &pagefile.pRefresher )
; 1210 :              )
; 1211 :      )
; 1212 :   {
; 1213 :     config.pagefile.show = false;

	mov	BYTE PTR ?config@@3Usk_config_t@@A+148, 0

; 1214 :     goto PAGEFILE_CLEANUP;

	jmp	$PAGEFILE_CLEANUP$116
$LN12@SK_Monitor:

; 1215 :   }
; 1216 : 
; 1217 :   if (FAILED (hr = pagefile.pRefresher->QueryInterface (

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+8
	push	OFFSET ?pagefile_stats@@3Upagefile_perf_t@@A+12
	push	OFFSET _IID_IWbemConfigureRefresher
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx]
	test	eax, eax
	jns	SHORT $LN14@SK_Monitor

; 1218 :                         IID_IWbemConfigureRefresher,
; 1219 :                         (void **)&pagefile.pConfig )
; 1220 :              )
; 1221 :      )
; 1222 :   {
; 1223 :     config.pagefile.show = false;

	mov	BYTE PTR ?config@@3Usk_config_t@@A+148, 0

; 1224 :     goto PAGEFILE_CLEANUP;

	jmp	$PAGEFILE_CLEANUP$116
$LN14@SK_Monitor:

; 1225 :   }
; 1226 : 
; 1227 :   // Add an enumerator to the refresher.
; 1228 :   if (FAILED (hr = pagefile.pConfig->AddEnum (

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+12
	push	OFFSET ?pagefile_stats@@3Upagefile_perf_t@@A+24
	push	OFFSET ?pagefile_stats@@3Upagefile_perf_t@@A+16
	push	0
	mov	ecx, DWORD PTR [eax]
	push	0
	push	OFFSET $SG166268
	push	DWORD PTR ?base@COM@@3UBase@1@A+8
	push	eax
	call	DWORD PTR [ecx+28]
	test	eax, eax
	jns	SHORT $LN16@SK_Monitor

; 1229 :                      COM::base.wmi.pNameSpace,
; 1230 :                      L"Win32_PerfRawData_PerfOS_PagingFile",
; 1231 :                      0,
; 1232 :                      nullptr,
; 1233 :                      &pagefile.pEnum,
; 1234 :                      &pagefile.lID )
; 1235 :              )
; 1236 :      )
; 1237 :   {
; 1238 :     config.pagefile.show = false;

	mov	BYTE PTR ?config@@3Usk_config_t@@A+148, 0

; 1239 :     goto PAGEFILE_CLEANUP;

	jmp	$PAGEFILE_CLEANUP$116
$LN16@SK_Monitor:

; 1240 :   }
; 1241 : 
; 1242 :   pagefile.pConfig->Release ();

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+12
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]

; 1243 :   pagefile.pConfig = nullptr;
; 1244 : 
; 1245 :   int iter = 0;

	xor	ebx, ebx
	mov	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+12, 0

; 1246 : 
; 1247 :   pagefile.hShutdownSignal = CreateEvent (nullptr, FALSE, FALSE, L"Pagefile Monitor Shutdown Signal");

	push	OFFSET $SG166270
	push	ebx
	push	ebx
	push	ebx
	mov	DWORD PTR _iter$1$[ebp], ebx
	call	DWORD PTR __imp__CreateEventW@16

; 1248 : 
; 1249 :   COM::base.wmi.Unlock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	mov	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+4, eax
	call	?Unlock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Unlock

; 1250 : 
; 1251 :   while (pagefile.lID != 0)

	cmp	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+24, ebx
	je	$LN112@SK_Monitor
	movsd	xmm0, QWORD PTR _update$1$[ebp]
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	call	__dtoui3
	mov	ecx, eax
	lea	esi, DWORD PTR [ebx+4]
	mov	DWORD PTR tv1561[ebp], ecx
	mov	edi, OFFSET ?pagefile_stats@@3Upagefile_perf_t@@A+28
$LL4@SK_Monitor:

; 1252 :   {
; 1253 :     if (WaitForSingleObject (pagefile.hShutdownSignal, DWORD (update * 1000.0)) == WAIT_OBJECT_0)

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+4
	push	ecx
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
	test	eax, eax
	je	$LN112@SK_Monitor

; 1254 :       break;
; 1255 : 
; 1256 :     // Only poll WMI while the pagefile stats are shown
; 1257 :     if (! config.pagefile.show)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+148, 0
	je	$LN100@SK_Monitor

; 1258 :       continue;
; 1259 : 
; 1260 :     pagefile.dwNumReturned = 0;
; 1261 : 
; 1262 :     COM::base.wmi.Lock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	mov	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+32, 0
	call	?Lock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Lock

; 1263 : 
; 1264 :     if (FAILED (hr = pagefile.pRefresher->Refresh (0L)))

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+8
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+12]
	test	eax, eax
	js	$LN87@SK_Monitor

; 1265 :     {
; 1266 :       config.pagefile.show = false;
; 1267 :       goto PAGEFILE_CLEANUP;
; 1268 :     }
; 1269 : 
; 1270 :     hr = pagefile.pEnum->GetObjects ( 0L,

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+16
	push	OFFSET ?pagefile_stats@@3Upagefile_perf_t@@A+32
	push	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+20
	push	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+28
	mov	ecx, DWORD PTR [eax]
	push	0
	push	eax
	call	DWORD PTR [ecx+20]

; 1271 :                                       pagefile.dwNumObjects,
; 1272 :                                       pagefile.apEnumAccess,
; 1273 :                                       &pagefile.dwNumReturned );
; 1274 : 
; 1275 :     // If the buffer was not big enough,
; 1276 :     // allocate a bigger buffer and retry.
; 1277 :     if (hr == WBEM_E_BUFFER_TOO_SMALL 
; 1278 :         && pagefile.dwNumReturned > pagefile.dwNumObjects)

	cmp	eax, -2147217348			; 8004103cH
	jne	$LN22@SK_Monitor
	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+32
	cmp	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+28
	jbe	$LN87@SK_Monitor

; 1279 :     {
; 1280 :       pagefile.apEnumAccess = new IWbemObjectAccess* [pagefile.dwNumReturned + 1];

	xor	ecx, ecx
	inc	eax
	mul	esi
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+20, edx

; 1281 :       if (pagefile.apEnumAccess == nullptr)

	test	edx, edx
	je	$LN52@SK_Monitor

; 1282 :       {
; 1283 :         hr = E_OUTOFMEMORY;
; 1284 :         goto PAGEFILE_CLEANUP;
; 1285 :       }
; 1286 : 
; 1287 :       SecureZeroMemory (pagefile.apEnumAccess,

	mov	esi, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+32
	lea	eax, DWORD PTR [esi*4]
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 17796:     while (cnt) {

	test	eax, eax
	je	SHORT $LN67@SK_Monitor
$LL66@SK_Monitor:

; 17797: 
; 17798: #if !defined(_M_CEE) && defined(_M_ARM)
; 17799: 
; 17800:         __iso_volatile_store8(vptr, 0);
; 17801: 
; 17802: #else
; 17803: 
; 17804:         *vptr = 0;

	mov	BYTE PTR [edx], 0

; 17805: 
; 17806: #endif
; 17807: 
; 17808:         vptr++;

	lea	edx, DWORD PTR [edx+1]

; 17809:         cnt--;

	sub	eax, 1
	jne	SHORT $LL66@SK_Monitor

; 17796:     while (cnt) {

	mov	esi, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+32
	mov	edx, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+20
$LN67@SK_Monitor:
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 1292 :       if (FAILED (hr = pagefile.pEnum->GetObjects ( 0L,

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+16
	push	OFFSET ?pagefile_stats@@3Upagefile_perf_t@@A+32
	push	edx
	push	esi
	mov	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+28, esi
	mov	ecx, DWORD PTR [eax]
	push	0
	push	eax
	call	DWORD PTR [ecx+20]
	test	eax, eax
	js	$LN87@SK_Monitor
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 3779 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+32
	mov	ecx, OFFSET ?pagefile_stats@@3Upagefile_perf_t@@A+32
	cmp	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+28
	cmovae	ecx, edi
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 1303 :       pagefile.dwNumReturned = std::min (pagefile.dwNumObjects, pagefile.dwNumReturned);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+32, eax

; 1304 :     }
; 1305 :     else

	jmp	SHORT $LN28@SK_Monitor
$LN22@SK_Monitor:

; 1306 :     {
; 1307 :       if (hr != WBEM_S_NO_ERROR)

	test	eax, eax
	jne	$LN87@SK_Monitor
$LN28@SK_Monitor:

; 1308 :       {
; 1309 :         hr = WBEM_E_NOT_FOUND;
; 1310 :         config.pagefile.show = false;
; 1311 :         goto PAGEFILE_CLEANUP;
; 1312 :       }
; 1313 :     }
; 1314 : 
; 1315 :     // First time through, get the handles.
; 1316 :     if (iter == 0)

	test	ebx, ebx
	jne	$LN41@SK_Monitor

; 1317 :     {
; 1318 :       if (pagefile.dwNumReturned <= 0)

	cmp	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+32, ebx
	jbe	$LN91@SK_Monitor

; 1323 :       }
; 1324 : 
; 1325 :       if (pagefile.apEnumAccess [0] == nullptr)

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+20
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	$LN92@SK_Monitor

; 1330 :       }
; 1331 : 
; 1332 :       CIMTYPE NameType;
; 1333 : 
; 1334 :       CIMTYPE PercentUsageType;
; 1335 :       CIMTYPE PercentUsagePeakType;
; 1336 :       CIMTYPE PercentUsage_BaseType;
; 1337 : 
; 1338 :       if (FAILED (hr = pagefile.apEnumAccess [0]->GetPropertyHandle (

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR _NameType$6[ebp]
	push	OFFSET ?pagefile_stats@@3Upagefile_perf_t@@A+40
	push	edx
	push	OFFSET $SG166291
	push	ecx
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN87@SK_Monitor

; 1339 :                             L"Name",
; 1340 :                             &NameType,
; 1341 :                             &pagefile.lNameHandle )
; 1342 :                  )
; 1343 :          )
; 1344 :       {
; 1345 :         config.pagefile.show = false;
; 1346 :         goto PAGEFILE_CLEANUP;
; 1347 :       }
; 1348 : 
; 1349 :       if (FAILED (hr = pagefile.apEnumAccess [0]->GetPropertyHandle (

	mov	ecx, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+20
	lea	edx, DWORD PTR _PercentUsageType$5[ebp]
	push	OFFSET ?pagefile_stats@@3Upagefile_perf_t@@A+44
	push	edx
	push	OFFSET $SG166294
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN87@SK_Monitor

; 1350 :                             L"PercentUsage",
; 1351 :                             &PercentUsageType,
; 1352 :                             &pagefile.lPercentUsageHandle )
; 1353 :                  )
; 1354 :          )
; 1355 :       {
; 1356 :         config.pagefile.show = false;
; 1357 :         goto PAGEFILE_CLEANUP;
; 1358 :       }
; 1359 : 
; 1360 :       if (FAILED (hr = pagefile.apEnumAccess [0]->GetPropertyHandle (

	mov	ecx, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+20
	lea	edx, DWORD PTR _PercentUsagePeakType$4[ebp]
	push	OFFSET ?pagefile_stats@@3Upagefile_perf_t@@A+48
	push	edx
	push	OFFSET $SG166297
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN87@SK_Monitor

; 1361 :                             L"PercentUsagePeak",
; 1362 :                             &PercentUsagePeakType,
; 1363 :                             &pagefile.lPercentUsagePeakHandle )
; 1364 :                  )
; 1365 :          )
; 1366 :       {
; 1367 :         config.pagefile.show = false;
; 1368 :         goto PAGEFILE_CLEANUP;
; 1369 :       }
; 1370 : 
; 1371 :       if (FAILED (hr = pagefile.apEnumAccess [0]->GetPropertyHandle (

	mov	ecx, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+20
	lea	edx, DWORD PTR _PercentUsage_BaseType$3[ebp]
	push	OFFSET ?pagefile_stats@@3Upagefile_perf_t@@A+52
	push	edx
	push	OFFSET $SG166300
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN87@SK_Monitor
$LN41@SK_Monitor:

; 1372 :                             L"PercentUsage_Base",
; 1373 :                             &PercentUsage_BaseType,
; 1374 :                             &pagefile.lPercentUsage_BaseHandle )
; 1375 :                  )
; 1376 :          )
; 1377 :       {
; 1378 :         config.pagefile.show = false;
; 1379 :         goto PAGEFILE_CLEANUP;
; 1380 :       }
; 1381 :     }
; 1382 : 
; 1383 :     for (unsigned int i = 0; i < pagefile.dwNumReturned; i++)

	xor	esi, esi
	cmp	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+32, esi
	jbe	$LN7@SK_Monitor
	mov	edi, OFFSET ?pagefile_stats@@3Upagefile_perf_t@@A+87
$LL8@SK_Monitor:

; 1384 :     {
; 1385 :       DWORD size;
; 1386 :       DWORD usage;
; 1387 :       DWORD usage_peak;
; 1388 : 
; 1389 :       if (FAILED (hr = pagefile.apEnumAccess [i]->ReadDWORD (

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+20
	lea	edx, DWORD PTR _usage$8[ebp]
	push	edx
	push	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+44
	mov	eax, DWORD PTR [eax+esi*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+120]
	test	eax, eax
	js	$PAGEFILE_CLEANUP$116

; 1390 :                                  pagefile.lPercentUsageHandle,
; 1391 :                                  &usage )
; 1392 :                  )
; 1393 :          )
; 1394 :       {
; 1395 :         goto PAGEFILE_CLEANUP;
; 1396 :       }
; 1397 : 
; 1398 :       if (FAILED (hr = pagefile.apEnumAccess [i]->ReadDWORD (

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+20
	lea	edx, DWORD PTR _usage_peak$7[ebp]
	push	edx
	push	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+48
	mov	eax, DWORD PTR [eax+esi*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+120]
	test	eax, eax
	js	$PAGEFILE_CLEANUP$116

; 1399 :                                  pagefile.lPercentUsagePeakHandle,
; 1400 :                                  &usage_peak )
; 1401 :                  )
; 1402 :          )
; 1403 :       {
; 1404 :         goto PAGEFILE_CLEANUP;
; 1405 :       }
; 1406 : 
; 1407 :       if (FAILED (hr = pagefile.apEnumAccess [i]->ReadDWORD (

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+20
	lea	edx, DWORD PTR _size$9[ebp]
	push	edx
	push	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+52
	mov	eax, DWORD PTR [eax+esi*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+120]
	test	eax, eax
	js	$PAGEFILE_CLEANUP$116

; 1408 :                                  pagefile.lPercentUsage_BaseHandle,
; 1409 :                                  &size )
; 1410 :                  )
; 1411 :          )
; 1412 :       {
; 1413 :         goto PAGEFILE_CLEANUP;
; 1414 :       }
; 1415 : 
; 1416 :       long    bytes      =  0;
; 1417 :       wchar_t name [256] = { };

	push	512					; 00000200H
	lea	eax, DWORD PTR _name$2[ebp]
	mov	DWORD PTR _bytes$10[ebp], 0
	push	0
	push	eax
	call	_memset

; 1418 : 
; 1419 :       if (FAILED (hr = pagefile.apEnumAccess [i]->ReadPropertyValue (

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+20
	lea	edx, DWORD PTR _name$2[ebp]
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR [eax+esi*4]
	push	edx
	lea	edx, DWORD PTR _bytes$10[ebp]
	push	edx
	mov	ecx, DWORD PTR [eax]
	push	510					; 000001feH
	push	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+40
	push	eax
	call	DWORD PTR [ecx+116]
	test	eax, eax
	js	$LN87@SK_Monitor

; 1420 :                              pagefile.lNameHandle,
; 1421 :                              sizeof (wchar_t) * 255,
; 1422 :                              &bytes,
; 1423 :                              reinterpret_cast <LPBYTE> (name) )
; 1424 :                  )
; 1425 :          )
; 1426 :       {
; 1427 :         config.pagefile.show = false;
; 1428 :         goto PAGEFILE_CLEANUP;
; 1429 :       }
; 1430 : 
; 1431 :       WideCharToMultiByte (CP_OEMCP, 0, name, 255, pagefile.pagefiles [i].name,

	push	0
	push	OFFSET $SG166310
	push	255					; 000000ffH
	lea	ebx, DWORD PTR [edi-31]
	push	ebx
	push	255					; 000000ffH
	lea	eax, DWORD PTR _name$2[ebp]
	push	eax
	push	0
	push	1
	call	DWORD PTR __imp__WideCharToMultiByte@32

; 1432 :                            255, " ", nullptr);
; 1433 : 
; 1434 :       pagefile.pagefiles [i].name [31] = '\0';

	mov	BYTE PTR [edi], 0

; 1435 : 
; 1436 :       if (i == (pagefile.dwNumReturned - 1))

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+32
	dec	eax
	cmp	esi, eax
	jne	SHORT $LN51@SK_Monitor

; 1437 :         strcpy (pagefile.pagefiles [i].name, "Total");

	mov	eax, DWORD PTR $SG166312
	mov	DWORD PTR [ebx], eax
	mov	ax, WORD PTR $SG166312+4
	mov	WORD PTR [ebx+4], ax
$LN51@SK_Monitor:

; 1438 : 
; 1439 :       pagefile.pagefiles [i].size  = (pagefile.pagefiles [i].size  + size) / 2;

	mov	eax, DWORD PTR [edi+225]
	add	eax, DWORD PTR _size$9[ebp]
	shr	eax, 1
	mov	DWORD PTR [edi+225], eax

; 1440 :       pagefile.pagefiles [i].usage = (pagefile.pagefiles [i].usage + usage)/ 2;

	mov	eax, DWORD PTR [edi+229]
	add	eax, DWORD PTR _usage$8[ebp]
	shr	eax, 1
	mov	DWORD PTR [edi+229], eax

; 1441 :       pagefile.pagefiles [i].usage_peak

	mov	eax, DWORD PTR [edi+233]
	add	eax, DWORD PTR _usage_peak$7[ebp]
	shr	eax, 1
	mov	DWORD PTR [edi+233], eax

; 1442 :                                    = (pagefile.pagefiles [i].usage_peak
; 1443 :                                                                    +
; 1444 :                                                                usage_peak) / 2;
; 1445 : 
; 1446 :       // Done with the object
; 1447 :       pagefile.apEnumAccess [i]->Release ();

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+20
	mov	eax, DWORD PTR [eax+esi*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]

; 1448 :       pagefile.apEnumAccess [i] = nullptr;

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+20
	add	edi, 268				; 0000010cH
	mov	DWORD PTR [eax+esi*4], 0
	inc	esi
	cmp	esi, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+32
	jb	$LL8@SK_Monitor
	mov	ebx, DWORD PTR _iter$1$[ebp]
	mov	edi, OFFSET ?pagefile_stats@@3Upagefile_perf_t@@A+28
$LN7@SK_Monitor:

; 1449 :     }
; 1450 : 
; 1451 :     pagefile.num_pagefiles = pagefile.dwNumReturned;

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+32

; 1452 :     pagefile.booting       = false;
; 1453 : 
; 1454 :     COM::base.wmi.Unlock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	mov	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+4344, eax
	mov	BYTE PTR ?pagefile_stats@@3Upagefile_perf_t@@A+36, 0
	call	?Unlock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Unlock

; 1455 : 
; 1456 :     ++iter;

	inc	ebx
	mov	esi, 4
	mov	DWORD PTR _iter$1$[ebp], ebx
$LN100@SK_Monitor:

; 1250 : 
; 1251 :   while (pagefile.lID != 0)

	cmp	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+24, 0
	je	SHORT $LN112@SK_Monitor
	mov	ecx, DWORD PTR tv1561[ebp]
	jmp	$LL4@SK_Monitor
$LN92@SK_Monitor:

; 1326 :       {
; 1327 :         dll_log.Log (L"[ WMI Wbem ] Pagefile apEnumAccess [0] = nullptr");

	push	OFFSET $SG166288
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8

; 1328 :         config.pagefile.show = false;

	mov	BYTE PTR ?config@@3Usk_config_t@@A+148, 0

; 1329 :         goto PAGEFILE_CLEANUP;

	jmp	SHORT $PAGEFILE_CLEANUP$116
$LN91@SK_Monitor:

; 1319 :       {
; 1320 :         dll_log.Log (L"[ WMI Wbem ] No pagefile exists");

	push	OFFSET $SG166285
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8

; 1321 :         config.pagefile.show = false;

	mov	BYTE PTR ?config@@3Usk_config_t@@A+148, 0

; 1322 :         goto PAGEFILE_CLEANUP;

	jmp	SHORT $PAGEFILE_CLEANUP$116
$LN112@SK_Monitor:

; 1457 :   }
; 1458 : 
; 1459 :   COM::base.wmi.Lock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	call	?Lock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Lock
$PAGEFILE_CLEANUP$116:

; 1460 : 
; 1461 : PAGEFILE_CLEANUP:
; 1462 :   //dll_log.Log (L" >> PAGEFILE_CLEANUP");
; 1463 : 
; 1464 :   if (pagefile.apEnumAccess != nullptr)

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+20
	test	eax, eax
	je	SHORT $LN52@SK_Monitor

; 1465 :   {
; 1466 :     for (unsigned int i = 0; i < pagefile.dwNumReturned; i++)

	xor	esi, esi
	cmp	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+32, esi
	jbe	SHORT $LN10@SK_Monitor
	npad	2
$LL11@SK_Monitor:

; 1467 :     {
; 1468 :       if (pagefile.apEnumAccess [i] != nullptr)

	mov	ecx, DWORD PTR [eax+esi*4]
	test	ecx, ecx
	je	SHORT $LN9@SK_Monitor

; 1469 :       {
; 1470 :         pagefile.apEnumAccess [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 1471 :         pagefile.apEnumAccess [i] = nullptr;

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+20
	mov	DWORD PTR [eax+esi*4], 0
	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+20
$LN9@SK_Monitor:

; 1465 :   {
; 1466 :     for (unsigned int i = 0; i < pagefile.dwNumReturned; i++)

	inc	esi
	cmp	esi, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+32
	jb	SHORT $LL11@SK_Monitor
$LN10@SK_Monitor:

; 1472 :       }
; 1473 :     }
; 1474 :     delete [] pagefile.apEnumAccess;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN52@SK_Monitor:

; 1475 :   }
; 1476 : 
; 1477 :   if (pagefile.pEnum)

	mov	ecx, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+16
	pop	edi
	pop	esi
	pop	ebx
	test	ecx, ecx
	je	SHORT $LN54@SK_Monitor

; 1478 :   {
; 1479 :     pagefile.pEnum->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 1480 :     pagefile.pEnum = nullptr;

	mov	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+16, 0
$LN54@SK_Monitor:

; 1481 :   }
; 1482 : 
; 1483 :   if (pagefile.pConfig != nullptr)

	mov	ecx, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+12
	test	ecx, ecx
	je	SHORT $LN55@SK_Monitor

; 1484 :   {
; 1485 :     pagefile.pConfig->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 1486 :     pagefile.pConfig = nullptr;

	mov	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+12, 0
$LN55@SK_Monitor:

; 1487 :   }
; 1488 : 
; 1489 :   if (pagefile.pRefresher != nullptr)

	mov	ecx, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+8
	test	ecx, ecx
	je	SHORT $LN56@SK_Monitor

; 1490 :   {
; 1491 :     pagefile.pRefresher->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 1492 :     pagefile.pRefresher = nullptr;

	mov	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+8, 0
$LN56@SK_Monitor:

; 1493 :   }
; 1494 : 
; 1495 :   if (pagefile.hShutdownSignal != INVALID_HANDLE_VALUE)

	cmp	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+4, -1
	je	SHORT $LN57@SK_Monitor

; 1496 :   {
; 1497 :     CloseHandle (pagefile.hShutdownSignal);

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+4
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 1498 :     pagefile.hShutdownSignal = INVALID_HANDLE_VALUE;

	mov	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+4, -1
$LN57@SK_Monitor:

; 1499 :   }
; 1500 : 
; 1501 :   COM::base.wmi.Unlock   ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	call	?Unlock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Unlock
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h

; 52   :     if (success)

	cmp	BYTE PTR _auto_com$[ebp], 0
	je	SHORT $LN113@SK_Monitor

; 53   :       CoUninitialize ();

	call	DWORD PTR __imp__CoUninitialize@0
$LN113@SK_Monitor:
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 1504 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	xor	eax, eax
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_MonitorPagefile@@YGKPAX@Z$17:
	lea	ecx, DWORD PTR _auto_com$[ebp]
	jmp	??1SK_AutoCOMInit@@QAE@XZ		; SK_AutoCOMInit::~SK_AutoCOMInit
__ehhandler$?SK_MonitorPagefile@@YGKPAX@Z:
	mov	eax, OFFSET __ehfuncinfo$?SK_MonitorPagefile@@YGKPAX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_MonitorPagefile@@YGKPAX@Z ENDP			; SK_MonitorPagefile
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\framerate.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\framerate.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\framerate.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
_TEXT	SEGMENT
_name$2 = -292						; size = 128
_PercentIdleTimeType$3 = -164				; size = 4
_PercentDiskWriteTimeType$4 = -160			; size = 4
_PercentDiskReadTimeType$5 = -156			; size = 4
_PercentDiskTimeType$6 = -152				; size = 4
_DiskWriteBytesPerSecType$7 = -148			; size = 4
_DiskReadBytesPerSecType$8 = -144			; size = 4
_DiskBytesPerSecType$9 = -140				; size = 4
_NameType$10 = -136					; size = 4
_bytes_sec$11 = -132					; size = 8
_bytes_read_sec$12 = -124				; size = 8
_bytes_write_sec$13 = -116				; size = 8
_percent_write$14 = -108				; size = 8
_percent_read$15 = -100					; size = 8
_percent_load$16 = -92					; size = 8
_percent_idle$17 = -84					; size = 8
tv1928 = -76						; size = 4
$T18 = -72						; size = 4
_bytes$19 = -68						; size = 4
_update$1$ = -64					; size = 8
_read_mean$20 = -64					; size = 8
tv933 = -56						; size = 8
tv1905 = -52						; size = 4
_write_mean$21 = -48					; size = 8
tv1908 = -44						; size = 4
$T22 = -40						; size = 4
_iter$1$ = -36						; size = 4
_i$1$ = -32						; size = 4
tv953 = -28						; size = 8
tv943 = -28						; size = 8
_combined_mean$23 = -28					; size = 8
tv1918 = -20						; size = 4
_auto_com$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
_user$ = 8						; size = 4
?SK_MonitorDisk@@YGKPAX@Z PROC				; SK_MonitorDisk

; 768  : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?SK_MonitorDisk@@YGKPAX@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 280				; 00000118H
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?base@COM@@3UBase@1@A+4
	push	ebx
	push	esi
	push	edi
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 769  :   while (! ReadAcquire (&COM::base.wmi.init))

	test	eax, eax
	jne	SHORT $LN3@SK_Monitor
	mov	esi, DWORD PTR __imp__SleepEx@8
$LL2@SK_Monitor:

; 770  :     SleepEx (150, FALSE);

	push	0
	push	150					; 00000096H
	call	esi
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?base@COM@@3UBase@1@A+4
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 769  :   while (! ReadAcquire (&COM::base.wmi.init))

	test	eax, eax
	je	SHORT $LL2@SK_Monitor
$LN3@SK_Monitor:
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h

; 45   :     HRESULT hr = CoInitializeEx (NULL, COINIT_MULTITHREADED);

	push	0
	push	0

; 54   :   }
; 55   : 
; 56   : private:
; 57   :   bool success = false;

	xor	bl, bl
	call	DWORD PTR __imp__CoInitializeEx@8
	test	eax, eax
	movzx	ecx, bl
	mov	edx, 1
	cmovns	ecx, edx
	mov	BYTE PTR _auto_com$[ebp], cl
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 776  :   COM::base.wmi.Lock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?Lock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Lock
	movss	xmm0, DWORD PTR ?config@@3Usk_config_t@@A+136

; 777  : 
; 778  :   //Win32_PerfFormattedData_PerfDisk_LogicalDisk
; 779  : 
; 780  :   disk_perf_t&  disk  = disk_stats;
; 781  :   const double update = config.disk.interval;
; 782  : 
; 783  :   HRESULT hr;
; 784  : 
; 785  :   if (FAILED (hr = CoCreateInstance (

	push	OFFSET ?disk_stats@@3Udisk_perf_t@@A+8
	push	OFFSET _IID_IWbemRefresher
	cvtps2pd xmm0, xmm0
	push	1
	push	0
	push	OFFSET _CLSID_WbemRefresher
	movsd	QWORD PTR _update$1$[ebp], xmm0
	call	DWORD PTR __imp__CoCreateInstance@20
	test	eax, eax
	js	$LN216@SK_Monitor

; 786  :                      CLSID_WbemRefresher,
; 787  :                      nullptr,
; 788  :                      CLSCTX_INPROC_SERVER,
; 789  :                      IID_IWbemRefresher, 
; 790  :                      (void**) &disk.pRefresher )
; 791  :              )
; 792  :      )
; 793  :   {
; 794  :     goto DISK_CLEANUP;
; 795  :   }
; 796  : 
; 797  :   if (FAILED (hr = disk.pRefresher->QueryInterface (

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+8
	push	OFFSET ?disk_stats@@3Udisk_perf_t@@A+12
	push	OFFSET _IID_IWbemConfigureRefresher
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx]
	test	eax, eax
	js	$LN216@SK_Monitor

; 798  :                         IID_IWbemConfigureRefresher,
; 799  :                         (void **)&disk.pConfig )
; 800  :              )
; 801  :      )
; 802  :   {
; 803  :     goto DISK_CLEANUP;
; 804  :   }
; 805  : 
; 806  :   // Add an enumerator to the refresher.
; 807  :   if (FAILED (hr = disk.pConfig->AddEnum (

	cmp	DWORD PTR ?config@@3Usk_config_t@@A+140, 1
	mov	eax, OFFSET $SG166128
	mov	ecx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+12
	mov	esi, OFFSET $SG166129
	push	OFFSET ?disk_stats@@3Udisk_perf_t@@A+24
	push	OFFSET ?disk_stats@@3Udisk_perf_t@@A+16
	push	0
	mov	edx, DWORD PTR [ecx]
	cmovne	eax, esi
	push	0
	push	eax
	push	DWORD PTR ?base@COM@@3UBase@1@A+8
	push	ecx
	call	DWORD PTR [edx+28]
	test	eax, eax
	js	$LN216@SK_Monitor

; 808  :                      COM::base.wmi.pNameSpace,
; 809  :                      config.disk.type == 1 ? 
; 810  :                      L"Win32_PerfFormattedData_PerfDisk_LogicalDisk" :
; 811  :                      L"Win32_PerfFormattedData_PerfDisk_PhysicalDisk",
; 812  :                      0,
; 813  :                      nullptr,
; 814  :                      &disk.pEnum,
; 815  :                      &disk.lID )
; 816  :              )
; 817  :      )
; 818  :   {
; 819  :     goto DISK_CLEANUP;
; 820  :   }
; 821  : 
; 822  :   disk.pConfig->Release ();

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+12
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]

; 823  :   disk.pConfig = nullptr;
; 824  : 
; 825  :   int iter = 0;

	xor	ebx, ebx
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+12, 0

; 826  : 
; 827  :   disk.dwNumReturned = 0;
; 828  :   disk.dwNumObjects  = 0;
; 829  : 
; 830  :   disk.hShutdownSignal = CreateEvent (nullptr, FALSE, FALSE, L"DiskMon Shutdown Signal");

	push	OFFSET $SG166131
	push	ebx
	push	ebx
	push	ebx
	mov	DWORD PTR _iter$1$[ebp], ebx
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+32, ebx
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+28, ebx
	call	DWORD PTR __imp__CreateEventW@16

; 831  : 
; 832  :   COM::base.wmi.Unlock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+4, eax
	call	?Unlock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Unlock

; 833  : 
; 834  :   while (disk_stats.lID != 0)

	cmp	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+24, ebx
	je	$LN214@SK_Monitor
	movsd	xmm0, QWORD PTR _update$1$[ebp]
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	call	__dtoui3
	mov	ecx, eax
	mov	DWORD PTR tv1928[ebp], ecx
$LL4@SK_Monitor:

; 835  :   {
; 836  :     if (WaitForSingleObject (disk_stats.hShutdownSignal, DWORD (update * 1000.0)) == WAIT_OBJECT_0)

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+4
	push	ecx
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
	test	eax, eax
	je	$LN214@SK_Monitor

; 837  :       break;
; 838  : 
; 839  :     // Only poll WMI while the data view is visible
; 840  :     if (! config.disk.show)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+132, 0
	je	$LN190@SK_Monitor

; 841  :       continue;
; 842  : 
; 843  :     extern LARGE_INTEGER SK_QueryPerf (void);
; 844  :      LARGE_INTEGER now = SK_QueryPerf ();

	call	?SK_QueryPerf@@YA?AT_LARGE_INTEGER@@XZ	; SK_QueryPerf
	mov	esi, eax

; 845  : 
; 846  :     disk.dwNumReturned = 0;

	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+32, 0
	mov	edi, edx
	mov	DWORD PTR $T22[ebp], esi

; 847  : 
; 848  :     COM::base.wmi.Lock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	mov	DWORD PTR $T18[ebp], edi
	call	?Lock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Lock

; 849  : 
; 850  :     if (FAILED (hr = disk.pRefresher->Refresh (0L)))

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+8
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+12]
	test	eax, eax
	js	$LN216@SK_Monitor

; 851  :     {
; 852  :       goto DISK_CLEANUP;
; 853  :     }
; 854  : 
; 855  :     hr = disk.pEnum->GetObjects ( 0L,

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+16
	push	OFFSET ?disk_stats@@3Udisk_perf_t@@A+32
	push	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	push	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+28
	mov	ecx, DWORD PTR [eax]
	push	0
	push	eax
	call	DWORD PTR [ecx+20]

; 856  :                                   disk.dwNumObjects,
; 857  :                                   disk.apEnumAccess,
; 858  :                                  &disk.dwNumReturned );
; 859  : 
; 860  :     // If the buffer was not big enough,
; 861  :     // allocate a bigger buffer and retry.
; 862  :     if (hr == WBEM_E_BUFFER_TOO_SMALL 
; 863  :         && disk.dwNumReturned > disk.dwNumObjects)

	cmp	eax, -2147217348			; 8004103cH
	jne	$LN25@SK_Monitor
	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+32
	cmp	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+28
	jbe	$DISK_CLEANUP$219

; 864  :     {
; 865  :       disk.apEnumAccess = new IWbemObjectAccess* [disk.dwNumReturned];

	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20, edx

; 866  :       if (disk.apEnumAccess == nullptr)

	test	edx, edx
	je	$LN69@SK_Monitor

; 867  :       {
; 868  :         hr = E_OUTOFMEMORY;
; 869  :         goto DISK_CLEANUP;
; 870  :       }
; 871  : 
; 872  :       SecureZeroMemory (disk.apEnumAccess,

	mov	ebx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+32
	lea	eax, DWORD PTR [ebx*4]
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 17796:     while (cnt) {

	test	eax, eax
	je	SHORT $LN93@SK_Monitor
	npad	1
$LL92@SK_Monitor:

; 17797: 
; 17798: #if !defined(_M_CEE) && defined(_M_ARM)
; 17799: 
; 17800:         __iso_volatile_store8(vptr, 0);
; 17801: 
; 17802: #else
; 17803: 
; 17804:         *vptr = 0;

	mov	BYTE PTR [edx], 0

; 17805: 
; 17806: #endif
; 17807: 
; 17808:         vptr++;

	lea	edx, DWORD PTR [edx+1]

; 17809:         cnt--;

	sub	eax, 1
	jne	SHORT $LL92@SK_Monitor

; 17796:     while (cnt) {

	mov	ebx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+32
	mov	edx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
$LN93@SK_Monitor:
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 877  :       if (FAILED (hr = disk.pEnum->GetObjects ( 0L,

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+16
	push	OFFSET ?disk_stats@@3Udisk_perf_t@@A+32
	push	edx
	push	ebx
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+28, ebx
	mov	ecx, DWORD PTR [eax]
	push	0
	push	eax
	call	DWORD PTR [ecx+20]
	test	eax, eax
	js	$LN216@SK_Monitor
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 3779 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+32
	mov	ecx, OFFSET ?disk_stats@@3Udisk_perf_t@@A+32
	cmp	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+28
	mov	eax, OFFSET ?disk_stats@@3Udisk_perf_t@@A+28
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 889  :     else

	mov	ebx, DWORD PTR _iter$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 3779 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovae	ecx, eax
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 887  :       disk.dwNumReturned = std::min (disk.dwNumObjects, disk.dwNumReturned);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+32, eax

; 889  :     else

	jmp	SHORT $LN31@SK_Monitor
$LN25@SK_Monitor:

; 890  :     {
; 891  :       if (hr != WBEM_S_NO_ERROR)

	test	eax, eax
	jne	$LN216@SK_Monitor
	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+32
$LN31@SK_Monitor:

; 892  :       {
; 893  :         hr = WBEM_E_NOT_FOUND;
; 894  :         goto DISK_CLEANUP;
; 895  :       }
; 896  :     }
; 897  : 
; 898  :     // First time through, get the handles.
; 899  :     if (iter == 0)

	test	ebx, ebx
	jne	$LN50@SK_Monitor

; 900  :     {
; 901  :       CIMTYPE NameType;
; 902  : 
; 903  :       CIMTYPE DiskBytesPerSecType;
; 904  :       CIMTYPE DiskReadBytesPerSecType;
; 905  :       CIMTYPE DiskWriteBytesPerSecType;
; 906  : 
; 907  :       CIMTYPE PercentDiskTimeType;
; 908  :       CIMTYPE PercentDiskReadTimeType;
; 909  :       CIMTYPE PercentDiskWriteTimeType;
; 910  :       CIMTYPE PercentIdleTimeType;
; 911  : 
; 912  :       if (disk.apEnumAccess [0] == nullptr)

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	$LN166@SK_Monitor

; 916  :       }
; 917  : 
; 918  :       if (FAILED (hr = disk.apEnumAccess [0]->GetPropertyHandle (

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR _NameType$10[ebp]
	push	OFFSET ?disk_stats@@3Udisk_perf_t@@A+40
	push	edx
	push	OFFSET $SG166149
	push	ecx
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN216@SK_Monitor

; 919  :                             L"Name",
; 920  :                             &NameType,
; 921  :                             &disk.lNameHandle )
; 922  :                  )
; 923  :          )
; 924  :       {
; 925  :         goto DISK_CLEANUP;
; 926  :       }
; 927  : 
; 928  :       if (FAILED (hr = disk.apEnumAccess [0]->GetPropertyHandle (

	mov	ecx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	lea	edx, DWORD PTR _DiskBytesPerSecType$9[ebp]
	push	OFFSET ?disk_stats@@3Udisk_perf_t@@A+44
	push	edx
	push	OFFSET $SG166152
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN216@SK_Monitor

; 929  :                             L"DiskBytesPerSec",
; 930  :                             &DiskBytesPerSecType,
; 931  :                             &disk.lDiskBytesPerSecHandle )
; 932  :                  )
; 933  :          )
; 934  :       {
; 935  :         goto DISK_CLEANUP;
; 936  :       }
; 937  : 
; 938  :       if (FAILED (hr = disk.apEnumAccess [0]->GetPropertyHandle (

	mov	ecx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	lea	edx, DWORD PTR _DiskReadBytesPerSecType$8[ebp]
	push	OFFSET ?disk_stats@@3Udisk_perf_t@@A+48
	push	edx
	push	OFFSET $SG166155
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN216@SK_Monitor

; 939  :                             L"DiskReadBytesPerSec",
; 940  :                             &DiskReadBytesPerSecType,
; 941  :                             &disk.lDiskReadBytesPerSecHandle )
; 942  :                  )
; 943  :          )
; 944  :       {
; 945  :         goto DISK_CLEANUP;
; 946  :       }
; 947  : 
; 948  :       if (FAILED (hr = disk.apEnumAccess [0]->GetPropertyHandle (

	mov	ecx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	lea	edx, DWORD PTR _DiskWriteBytesPerSecType$7[ebp]
	push	OFFSET ?disk_stats@@3Udisk_perf_t@@A+52
	push	edx
	push	OFFSET $SG166158
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN216@SK_Monitor

; 949  :                             L"DiskWriteBytesPerSec",
; 950  :                             &DiskWriteBytesPerSecType,
; 951  :                             &disk.lDiskWriteBytesPerSecHandle )
; 952  :                  )
; 953  :          )
; 954  :       {
; 955  :         goto DISK_CLEANUP;
; 956  :       }
; 957  : 
; 958  :       if (FAILED (hr = disk.apEnumAccess [0]->GetPropertyHandle (

	mov	ecx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	lea	edx, DWORD PTR _PercentDiskTimeType$6[ebp]
	push	OFFSET ?disk_stats@@3Udisk_perf_t@@A+64
	push	edx
	push	OFFSET $SG166161
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN216@SK_Monitor

; 959  :                             L"PercentDiskTime",
; 960  :                             &PercentDiskTimeType,
; 961  :                             &disk.lPercentDiskTimeHandle )
; 962  :                  )
; 963  :          )
; 964  :       {
; 965  :         goto DISK_CLEANUP;
; 966  :       }
; 967  : 
; 968  :       if (FAILED (hr = disk.apEnumAccess [0]->GetPropertyHandle (

	mov	ecx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	lea	edx, DWORD PTR _PercentDiskReadTimeType$5[ebp]
	push	OFFSET ?disk_stats@@3Udisk_perf_t@@A+56
	push	edx
	push	OFFSET $SG166164
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN216@SK_Monitor

; 969  :                             L"PercentDiskReadTime",
; 970  :                             &PercentDiskReadTimeType,
; 971  :                             &disk.lPercentDiskReadTimeHandle )
; 972  :                  )
; 973  :          )
; 974  :       {
; 975  :         goto DISK_CLEANUP;
; 976  :       }
; 977  : 
; 978  :       if (FAILED (hr = disk.apEnumAccess [0]->GetPropertyHandle (

	mov	ecx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	lea	edx, DWORD PTR _PercentDiskWriteTimeType$4[ebp]
	push	OFFSET ?disk_stats@@3Udisk_perf_t@@A+60
	push	edx
	push	OFFSET $SG166167
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN216@SK_Monitor

; 979  :                             L"PercentDiskWriteTime",
; 980  :                             &PercentDiskWriteTimeType,
; 981  :                             &disk.lPercentDiskWriteTimeHandle )
; 982  :                  )
; 983  :          )
; 984  :       {
; 985  :         goto DISK_CLEANUP;
; 986  :       }
; 987  : 
; 988  :       if (FAILED (hr = disk.apEnumAccess [0]->GetPropertyHandle (

	mov	ecx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	lea	edx, DWORD PTR _PercentIdleTimeType$3[ebp]
	push	OFFSET ?disk_stats@@3Udisk_perf_t@@A+68
	push	edx
	push	OFFSET $SG166170
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN216@SK_Monitor
	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+32
$LN50@SK_Monitor:

; 989  :                             L"PercentIdleTime",
; 990  :                             &PercentIdleTimeType,
; 991  :                             &disk.lPercentIdleTimeHandle )
; 992  :                  )
; 993  :          )
; 994  :       {
; 995  :         goto DISK_CLEANUP;
; 996  :       }
; 997  :     }
; 998  : 
; 999  :     for (unsigned int i = 0; i < disk.dwNumReturned; i++)

	xor	ebx, ebx
	mov	DWORD PTR _i$1$[ebp], ebx
	test	eax, eax
	je	$LN7@SK_Monitor
	npad	6
$LL8@SK_Monitor:

; 1000 :     {
; 1001 :       uint64_t percent_read;
; 1002 :       uint64_t percent_write;
; 1003 :       uint64_t percent_load;
; 1004 :       uint64_t percent_idle;
; 1005 : 
; 1006 :       uint64_t bytes_sec;
; 1007 :       uint64_t bytes_read_sec;
; 1008 :       uint64_t bytes_write_sec;
; 1009 : 
; 1010 :       if (FAILED (hr = disk.apEnumAccess [i]->ReadQWORD (

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	lea	edx, DWORD PTR _percent_read$15[ebp]
	push	edx
	push	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+56
	mov	eax, DWORD PTR [eax+ebx*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+128]
	test	eax, eax
	js	$LN216@SK_Monitor

; 1011 :                              disk.lPercentDiskReadTimeHandle,
; 1012 :                             &percent_read )
; 1013 :                  )
; 1014 :          )
; 1015 :       {
; 1016 :         goto DISK_CLEANUP;
; 1017 :       }
; 1018 : 
; 1019 :       if (FAILED (hr = disk.apEnumAccess [i]->ReadQWORD (

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	lea	edx, DWORD PTR _percent_write$14[ebp]
	push	edx
	push	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+60
	mov	eax, DWORD PTR [eax+ebx*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+128]
	test	eax, eax
	js	$LN216@SK_Monitor

; 1020 :                              disk.lPercentDiskWriteTimeHandle,
; 1021 :                             &percent_write )
; 1022 :                  )
; 1023 :          )
; 1024 :       {
; 1025 :         goto DISK_CLEANUP;
; 1026 :       }
; 1027 : 
; 1028 :       if (FAILED (hr = disk.apEnumAccess [i]->ReadQWORD (

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	lea	edx, DWORD PTR _percent_load$16[ebp]
	push	edx
	push	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+64
	mov	eax, DWORD PTR [eax+ebx*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+128]
	test	eax, eax
	js	$LN216@SK_Monitor

; 1029 :                              disk.lPercentDiskTimeHandle,
; 1030 :                             &percent_load )
; 1031 :                  )
; 1032 :          )
; 1033 :       {
; 1034 :         goto DISK_CLEANUP;
; 1035 :       }
; 1036 : 
; 1037 :       if (FAILED (hr = disk.apEnumAccess [i]->ReadQWORD (

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	lea	edx, DWORD PTR _percent_idle$17[ebp]
	push	edx
	push	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+68
	mov	eax, DWORD PTR [eax+ebx*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+128]
	test	eax, eax
	js	$LN216@SK_Monitor

; 1038 :                              disk.lPercentIdleTimeHandle,
; 1039 :                             &percent_idle )
; 1040 :                  )
; 1041 :          )
; 1042 :       {
; 1043 :         goto DISK_CLEANUP;
; 1044 :       }
; 1045 : 
; 1046 :       if (FAILED (hr = disk.apEnumAccess [i]->ReadQWORD (

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	lea	edx, DWORD PTR _bytes_sec$11[ebp]
	push	edx
	push	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+44
	mov	eax, DWORD PTR [eax+ebx*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+128]
	test	eax, eax
	js	$LN216@SK_Monitor

; 1047 :                              disk.lDiskBytesPerSecHandle,
; 1048 :                             &bytes_sec )
; 1049 :                  )
; 1050 :          )
; 1051 :       {
; 1052 :         goto DISK_CLEANUP;
; 1053 :       }
; 1054 : 
; 1055 :       if (FAILED (hr = disk.apEnumAccess [i]->ReadQWORD (

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	lea	edx, DWORD PTR _bytes_write_sec$13[ebp]
	push	edx
	push	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+52
	mov	eax, DWORD PTR [eax+ebx*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+128]
	test	eax, eax
	js	$LN216@SK_Monitor

; 1056 :                              disk.lDiskWriteBytesPerSecHandle,
; 1057 :                             &bytes_write_sec )
; 1058 :                  )
; 1059 :          )
; 1060 :       {
; 1061 :         goto DISK_CLEANUP;
; 1062 :       }
; 1063 : 
; 1064 :       if (FAILED (hr = disk.apEnumAccess [i]->ReadQWORD (

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	lea	edx, DWORD PTR _bytes_read_sec$12[ebp]
	push	edx
	push	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+48
	mov	eax, DWORD PTR [eax+ebx*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+128]
	test	eax, eax
	js	$LN216@SK_Monitor

; 1065 :                              disk.lDiskReadBytesPerSecHandle,
; 1066 :                             &bytes_read_sec )
; 1067 :                  )
; 1068 :          )
; 1069 :       {
; 1070 :         goto DISK_CLEANUP;
; 1071 :       }
; 1072 : 
; 1073 :       long    bytes     =  0;
; 1074 :       wchar_t name [64] = { };

	push	128					; 00000080H
	lea	eax, DWORD PTR _name$2[ebp]
	mov	DWORD PTR _bytes$19[ebp], 0
	push	0
	push	eax
	call	_memset

; 1075 : 
; 1076 :       if (FAILED (hr = disk.apEnumAccess [i]->ReadPropertyValue (

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	lea	edx, DWORD PTR _name$2[ebp]
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR [eax+ebx*4]
	push	edx
	lea	edx, DWORD PTR _bytes$19[ebp]
	push	edx
	mov	ecx, DWORD PTR [eax]
	push	128					; 00000080H
	push	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+40
	push	eax
	call	DWORD PTR [ecx+116]
	test	eax, eax
	js	$LN216@SK_Monitor

; 1077 :                              disk.lNameHandle,
; 1078 :                              sizeof (wchar_t) * 64,
; 1079 :                              &bytes,
; 1080 :                              reinterpret_cast <LPBYTE> (name) )
; 1081 :                  )
; 1082 :          )
; 1083 :       {
; 1084 :         goto DISK_CLEANUP;
; 1085 :       }
; 1086 : 
; 1087 :       WideCharToMultiByte (CP_OEMCP, 0, name, 31, disk.disks [i].name, 31, " ", nullptr);

	push	0
	imul	eax, ebx, 88
	push	OFFSET $SG166188
	push	31					; 0000001fH
	mov	DWORD PTR tv1918[ebp], eax
	lea	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[eax+72]
	push	eax
	push	31					; 0000001fH
	lea	eax, DWORD PTR _name$2[ebp]
	push	eax
	push	0
	push	1
	call	DWORD PTR __imp__WideCharToMultiByte@32

; 1088 :       disk.disks [i].name [31] = '\0';

	mov	edx, DWORD PTR tv1918[ebp]
	mov	BYTE PTR ?disk_stats@@3Udisk_perf_t@@A[edx+103], 0

; 1089 : 
; 1090 :       if (i == 0)

	test	ebx, ebx
	jne	SHORT $LN68@SK_Monitor

; 1091 :         strcpy (disk.disks [i].name, "Total");

	mov	eax, DWORD PTR $SG166190
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+72, eax
	mov	ax, WORD PTR $SG166190+4
	mov	WORD PTR ?disk_stats@@3Udisk_perf_t@@A+76, ax
$LN68@SK_Monitor:

; 1095 :       static SK::Framerate::Stats write_rate    [16];

	mov	eax, DWORD PTR __tls_index
	mov	ecx, DWORD PTR fs:__tls_array
	mov	BYTE PTR ?disk_stats@@3Udisk_perf_t@@A[edx+87], 0
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ?$TSS0@?ED@??SK_MonitorDisk@@YGKPAX@Z@4HA
	cmp	eax, DWORD PTR __Init_thread_epoch[ecx]
	jle	$LN9@SK_Monitor
	push	OFFSET ?$TSS0@?ED@??SK_MonitorDisk@@YGKPAX@Z@4HA
	call	__Init_thread_header
	add	esp, 4
	cmp	DWORD PTR ?$TSS0@?ED@??SK_MonitorDisk@@YGKPAX@Z@4HA, -1
	jne	$LN217@SK_Monitor
	mov	esi, 16					; 00000010H
	mov	ebx, OFFSET ?write_rate@?ED@??SK_MonitorDisk@@YGKPAX@Z@4PAVStats@Framerate@SK@@A+1920
	npad	7
$LL99@SK_Monitor:
	dec	esi
	lea	eax, DWORD PTR [ebx-1908]
	mov	ecx, 120				; 00000078H
	xorps	xmm0, xmm0
	npad	1
$LL105@SK_Monitor:
	movsd	QWORD PTR [eax-12], xmm0
	lea	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [eax-20], 0
	mov	DWORD PTR [eax-16], 0
	sub	ecx, 1
	jne	SHORT $LL105@SK_Monitor
; File c:\users\andon\source\repos\specialk\include\specialk\framerate.h

; 101  :         QueryPerformanceFrequency (&freq);

	push	OFFSET ?freq@Stats@Framerate@SK@@2T_LARGE_INTEGER@@A ; SK::Framerate::Stats::freq

; 102  :       }
; 103  : 
; 104  :     #define MAX_SAMPLES 120
; 105  :       struct sample_t {
; 106  :         double        val  = 0.0;
; 107  :         LARGE_INTEGER when = { 0ULL };
; 108  :       } data [MAX_SAMPLES];
; 109  :       int    samples       = 0;

	mov	DWORD PTR [ebx], ecx
	call	DWORD PTR __imp__QueryPerformanceFrequency@4
	add	ebx, 1928				; 00000788H
	test	esi, esi
	jne	SHORT $LL99@SK_Monitor
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 1096 :       static SK::Framerate::Stats read_rate     [16];

	mov	edi, 16					; 00000010H
	mov	ebx, OFFSET ?read_rate@?ED@??SK_MonitorDisk@@YGKPAX@Z@4PAVStats@Framerate@SK@@A+1920
	npad	4
$LL112@SK_Monitor:
	dec	edi
	lea	eax, DWORD PTR [ebx-1908]
	mov	ecx, 120				; 00000078H
	xorps	xmm0, xmm0
	npad	1
$LL118@SK_Monitor:
	movsd	QWORD PTR [eax-12], xmm0
	lea	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [eax-20], 0
	mov	DWORD PTR [eax-16], 0
	sub	ecx, 1
	jne	SHORT $LL118@SK_Monitor
; File c:\users\andon\source\repos\specialk\include\specialk\framerate.h

; 101  :         QueryPerformanceFrequency (&freq);

	push	OFFSET ?freq@Stats@Framerate@SK@@2T_LARGE_INTEGER@@A ; SK::Framerate::Stats::freq

; 102  :       }
; 103  : 
; 104  :     #define MAX_SAMPLES 120
; 105  :       struct sample_t {
; 106  :         double        val  = 0.0;
; 107  :         LARGE_INTEGER when = { 0ULL };
; 108  :       } data [MAX_SAMPLES];
; 109  :       int    samples       = 0;

	mov	DWORD PTR [ebx], ecx
	call	DWORD PTR __imp__QueryPerformanceFrequency@4
	add	ebx, 1928				; 00000788H
	test	edi, edi
	jne	SHORT $LL112@SK_Monitor
	mov	edi, DWORD PTR $T18[ebp]
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 1097 :       static SK::Framerate::Stats combined_rate [16];

	mov	esi, 16					; 00000010H
	mov	ebx, OFFSET ?combined_rate@?ED@??SK_MonitorDisk@@YGKPAX@Z@4PAVStats@Framerate@SK@@A+1920
	npad	1
$LL125@SK_Monitor:
	dec	esi
	lea	eax, DWORD PTR [ebx-1908]
	mov	ecx, 120				; 00000078H
	xorps	xmm0, xmm0
	npad	1
$LL131@SK_Monitor:
	movsd	QWORD PTR [eax-12], xmm0
	lea	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [eax-20], 0
	mov	DWORD PTR [eax-16], 0
	sub	ecx, 1
	jne	SHORT $LL131@SK_Monitor
; File c:\users\andon\source\repos\specialk\include\specialk\framerate.h

; 101  :         QueryPerformanceFrequency (&freq);

	push	OFFSET ?freq@Stats@Framerate@SK@@2T_LARGE_INTEGER@@A ; SK::Framerate::Stats::freq

; 102  :       }
; 103  : 
; 104  :     #define MAX_SAMPLES 120
; 105  :       struct sample_t {
; 106  :         double        val  = 0.0;
; 107  :         LARGE_INTEGER when = { 0ULL };
; 108  :       } data [MAX_SAMPLES];
; 109  :       int    samples       = 0;

	mov	DWORD PTR [ebx], ecx
	call	DWORD PTR __imp__QueryPerformanceFrequency@4
	add	ebx, 1928				; 00000788H
	test	esi, esi
	jne	SHORT $LL125@SK_Monitor
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 1095 :       static SK::Framerate::Stats write_rate    [16];

	push	OFFSET ?$TSS0@?ED@??SK_MonitorDisk@@YGKPAX@Z@4HA
	call	__Init_thread_footer
	mov	esi, DWORD PTR $T22[ebp]
	add	esp, 4
	mov	ebx, DWORD PTR _i$1$[ebp]
$LN217@SK_Monitor:
	mov	edx, DWORD PTR tv1918[ebp]
$LN9@SK_Monitor:

; 1098 : 
; 1099 :       disk.disks [i].percent_idle   = (disk.disks [i].percent_idle   + percent_idle)   / 2;

	mov	ecx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[edx+128]
	add	ecx, DWORD PTR _percent_idle$17[ebp]
	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[edx+132]
	adc	eax, DWORD PTR _percent_idle$17[ebp+4]
	shrd	ecx, eax, 1

; 1100 :       disk.disks [i].percent_load   = (disk.disks [i].percent_load   + percent_load)   / 2;
; 1101 :       disk.disks [i].percent_read   = (disk.disks [i].percent_read   + percent_read)   / 2;
; 1102 :       disk.disks [i].percent_write  = (disk.disks [i].percent_write  + percent_write)  / 2;
; 1103 : 
; 1104 :       write_rate    [i].addSample ( static_cast <double> (bytes_write_sec), now );

	push	edi
	shr	eax, 1
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[edx+128], ecx
	mov	ecx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[edx+104]
	add	ecx, DWORD PTR _percent_load$16[ebp]
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[edx+132], eax
	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[edx+108]
	adc	eax, DWORD PTR _percent_load$16[ebp+4]
	shrd	ecx, eax, 1
	push	esi
	shr	eax, 1
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[edx+104], ecx
	mov	ecx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[edx+120]
	add	ecx, DWORD PTR _percent_read$15[ebp]
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[edx+108], eax
	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[edx+124]
	adc	eax, DWORD PTR _percent_read$15[ebp+4]
	shrd	ecx, eax, 1
	shr	eax, 1
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[edx+120], ecx
	mov	ecx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[edx+112]
	add	ecx, DWORD PTR _percent_write$14[ebp]
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[edx+124], eax
	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[edx+116]
	adc	eax, DWORD PTR _percent_write$14[ebp+4]
	shrd	ecx, eax, 1
	imul	ebx, ebx, 1928
	shr	eax, 1
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[edx+116], eax
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[edx+112], ecx
	mov	edx, DWORD PTR _bytes_write_sec$13[ebp+4]
	mov	ecx, DWORD PTR _bytes_write_sec$13[ebp]
	lea	eax, DWORD PTR ?write_rate@?ED@??SK_MonitorDisk@@YGKPAX@Z@4PAVStats@Framerate@SK@@A[ebx]
	mov	DWORD PTR tv1908[ebp], eax
	call	__ultod3
	sub	esp, 8
	lea	ecx, DWORD PTR ?write_rate@?ED@??SK_MonitorDisk@@YGKPAX@Z@4PAVStats@Framerate@SK@@A[ebx]
	movsd	QWORD PTR [esp], xmm0
	call	?addSample@Stats@Framerate@SK@@QAEXNT_LARGE_INTEGER@@@Z ; SK::Framerate::Stats::addSample

; 1105 :       read_rate     [i].addSample (static_cast <double> (bytes_read_sec),   now );

	mov	edx, DWORD PTR _bytes_read_sec$12[ebp+4]
	lea	eax, DWORD PTR ?read_rate@?ED@??SK_MonitorDisk@@YGKPAX@Z@4PAVStats@Framerate@SK@@A[ebx]
	mov	ecx, DWORD PTR _bytes_read_sec$12[ebp]
	push	edi
	push	esi
	mov	DWORD PTR tv1905[ebp], eax
	call	__ultod3
	sub	esp, 8
	lea	ecx, DWORD PTR ?read_rate@?ED@??SK_MonitorDisk@@YGKPAX@Z@4PAVStats@Framerate@SK@@A[ebx]
	movsd	QWORD PTR [esp], xmm0
	call	?addSample@Stats@Framerate@SK@@QAEXNT_LARGE_INTEGER@@@Z ; SK::Framerate::Stats::addSample

; 1106 :       combined_rate [i].addSample (static_cast <double> (bytes_sec),        now );

	mov	edx, DWORD PTR _bytes_sec$11[ebp+4]
	lea	ebx, DWORD PTR ?combined_rate@?ED@??SK_MonitorDisk@@YGKPAX@Z@4PAVStats@Framerate@SK@@A[ebx]
	mov	ecx, DWORD PTR _bytes_sec$11[ebp]
	push	edi
	push	esi
	call	__ultod3
	sub	esp, 8
	mov	ecx, ebx
	movsd	QWORD PTR [esp], xmm0
	call	?addSample@Stats@Framerate@SK@@QAEXNT_LARGE_INTEGER@@@Z ; SK::Framerate::Stats::addSample

; 1107 : 
; 1108 :       double combined_mean = combined_rate [i].calcMean (3.0);

	movsd	xmm0, QWORD PTR __real@4008000000000000
	sub	esp, 8
	mov	ecx, ebx
	movsd	QWORD PTR [esp], xmm0
	call	?calcMean@Stats@Framerate@SK@@QAENN@Z	; SK::Framerate::Stats::calcMean

; 1109 :       double write_mean    = write_rate    [i].calcMean (3.0);

	movsd	xmm0, QWORD PTR __real@4008000000000000
	sub	esp, 8
	mov	ecx, DWORD PTR tv1908[ebp]
	fstp	QWORD PTR _combined_mean$23[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	?calcMean@Stats@Framerate@SK@@QAENN@Z	; SK::Framerate::Stats::calcMean

; 1110 :       double read_mean     = read_rate     [i].calcMean (3.0);

	movsd	xmm0, QWORD PTR __real@4008000000000000
	sub	esp, 8
	mov	ecx, DWORD PTR tv1905[ebp]
	fstp	QWORD PTR _write_mean$21[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	?calcMean@Stats@Framerate@SK@@QAENN@Z	; SK::Framerate::Stats::calcMean

; 1111 : 
; 1112 :       disk.disks [i].bytes_sec       = isnan (combined_mean) ? 0ULL : static_cast <uint64_t> (combined_mean);

	movsd	xmm0, QWORD PTR _combined_mean$23[ebp]
	sub	esp, 8
	fstp	QWORD PTR _read_mean$20[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	??$isnan@N@@YA_NN@Z			; isnan<double>
	add	esp, 8
	test	al, al
	je	SHORT $LN76@SK_Monitor
	xorps	xmm0, xmm0
	movlpd	QWORD PTR tv933[ebp], xmm0
	mov	edx, DWORD PTR tv933[ebp+4]
	mov	eax, DWORD PTR tv933[ebp]
	jmp	SHORT $LN77@SK_Monitor
$LN76@SK_Monitor:
	movsd	xmm0, QWORD PTR _combined_mean$23[ebp]
	call	__dtoul3
$LN77@SK_Monitor:
	mov	ebx, DWORD PTR tv1918[ebp]

; 1113 :       disk.disks [i].write_bytes_sec = isnan (write_mean)    ? 0ULL : static_cast <uint64_t> (write_mean);

	sub	esp, 8
	movsd	xmm0, QWORD PTR _write_mean$21[ebp]
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[ebx+152], eax
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[ebx+156], edx
	movsd	QWORD PTR [esp], xmm0
	call	??$isnan@N@@YA_NN@Z			; isnan<double>
	add	esp, 8
	test	al, al
	je	SHORT $LN78@SK_Monitor
	xorps	xmm0, xmm0
	movlpd	QWORD PTR tv943[ebp], xmm0
	mov	edx, DWORD PTR tv943[ebp+4]
	mov	eax, DWORD PTR tv943[ebp]
	jmp	SHORT $LN79@SK_Monitor
$LN78@SK_Monitor:
	movsd	xmm0, QWORD PTR _write_mean$21[ebp]
	call	__dtoul3
$LN79@SK_Monitor:

; 1114 :       disk.disks [i].read_bytes_sec  = isnan (read_mean)     ? 0ULL : static_cast <uint64_t> (read_mean);

	movsd	xmm0, QWORD PTR _read_mean$20[ebp]
	sub	esp, 8
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[ebx+144], eax
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[ebx+148], edx
	movsd	QWORD PTR [esp], xmm0
	call	??$isnan@N@@YA_NN@Z			; isnan<double>
	add	esp, 8
	test	al, al
	je	SHORT $LN80@SK_Monitor
	xorps	xmm0, xmm0
	movlpd	QWORD PTR tv953[ebp], xmm0
	mov	edx, DWORD PTR tv953[ebp+4]
	mov	eax, DWORD PTR tv953[ebp]
	jmp	SHORT $LN81@SK_Monitor
$LN80@SK_Monitor:
	movsd	xmm0, QWORD PTR _read_mean$20[ebp]
	call	__dtoul3
$LN81@SK_Monitor:
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[ebx+136], eax
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[ebx+140], edx

; 1115 : 
; 1116 :       //disk.disks [i].bytes_sec       = (disk.disks [i].bytes_sec       + bytes_sec)       >> 1;
; 1117 :       //disk.disks [i].write_bytes_sec = (disk.disks [i].write_bytes_sec + bytes_write_sec) >> 1;
; 1118 :       //disk.disks [i].read_bytes_sec  = (disk.disks [i].read_bytes_sec  + bytes_read_sec)  >> 1;
; 1119 : 
; 1120 :       // Done with the object
; 1121 :       disk.apEnumAccess [i]->Release ();

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	mov	ebx, DWORD PTR _i$1$[ebp]
	mov	eax, DWORD PTR [eax+ebx*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]

; 1122 :       disk.apEnumAccess [i] = nullptr;

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	mov	DWORD PTR [eax+ebx*4], 0
	inc	ebx
	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+32
	mov	DWORD PTR _i$1$[ebp], ebx
	cmp	ebx, eax
	jb	$LL8@SK_Monitor
$LN7@SK_Monitor:

; 1123 :     }
; 1124 : 
; 1125 :     disk.num_disks = disk.dwNumReturned;
; 1126 :     disk.booting   = false;
; 1127 : 
; 1128 :     ++iter;

	mov	ebx, DWORD PTR _iter$1$[ebp]

; 1129 : 
; 1130 :     COM::base.wmi.Unlock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	inc	ebx
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+1480, eax
	mov	BYTE PTR ?disk_stats@@3Udisk_perf_t@@A+36, 0
	mov	DWORD PTR _iter$1$[ebp], ebx
	call	?Unlock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Unlock
$LN190@SK_Monitor:

; 833  : 
; 834  :   while (disk_stats.lID != 0)

	cmp	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+24, 0
	je	SHORT $LN214@SK_Monitor
	mov	ecx, DWORD PTR tv1928[ebp]
	jmp	$LL4@SK_Monitor
$LN166@SK_Monitor:

; 913  :       {
; 914  :         dll_log.Log (L"[ WMI Wbem ] Disk apEnumAccess [0] = nullptr");

	push	OFFSET $SG166146
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8

; 915  :         goto DISK_CLEANUP;

	jmp	SHORT $LN216@SK_Monitor
$LN214@SK_Monitor:

; 1131 :   }
; 1132 : 
; 1133 :   COM::base.wmi.Lock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	call	?Lock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Lock
$LN216@SK_Monitor:
	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+32
$DISK_CLEANUP$219:

; 1134 : 
; 1135 : DISK_CLEANUP:
; 1136 :   //dll_log.Log (L" >> DISK_CLEANUP");
; 1137 : 
; 1138 :   if (disk.apEnumAccess != nullptr)

	mov	edx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	test	edx, edx
	je	SHORT $LN69@SK_Monitor

; 1139 :   {
; 1140 :     for (unsigned int i = 0; i < disk.dwNumReturned; i++)

	xor	esi, esi
	test	eax, eax
	je	SHORT $LN13@SK_Monitor
$LL14@SK_Monitor:

; 1141 :     {
; 1142 :       if (disk.apEnumAccess [i] != nullptr)

	mov	ecx, DWORD PTR [edx+esi*4]
	test	ecx, ecx
	je	SHORT $LN12@SK_Monitor

; 1143 :       {
; 1144 :         disk.apEnumAccess [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 1145 :         disk.apEnumAccess [i] = nullptr;

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	mov	DWORD PTR [eax+esi*4], 0
	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+32
	mov	edx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
$LN12@SK_Monitor:

; 1139 :   {
; 1140 :     for (unsigned int i = 0; i < disk.dwNumReturned; i++)

	inc	esi
	cmp	esi, eax
	jb	SHORT $LL14@SK_Monitor
$LN13@SK_Monitor:

; 1146 :       }
; 1147 :     }
; 1148 :     delete [] disk.apEnumAccess;

	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN69@SK_Monitor:

; 1149 :   }
; 1150 : 
; 1151 :   if (disk.pEnum)

	mov	ecx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+16
	pop	edi
	pop	esi
	pop	ebx
	test	ecx, ecx
	je	SHORT $LN71@SK_Monitor

; 1152 :   {
; 1153 :     disk.pEnum->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 1154 :     disk.pEnum = nullptr;

	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+16, 0
$LN71@SK_Monitor:

; 1155 :   }
; 1156 : 
; 1157 :   if (disk.pConfig != nullptr)

	mov	ecx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+12
	test	ecx, ecx
	je	SHORT $LN72@SK_Monitor

; 1158 :   {
; 1159 :     disk.pConfig->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 1160 :     disk.pConfig = nullptr;

	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+12, 0
$LN72@SK_Monitor:

; 1161 :   }
; 1162 : 
; 1163 :   if (disk.pRefresher != nullptr)

	mov	ecx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+8
	test	ecx, ecx
	je	SHORT $LN73@SK_Monitor

; 1164 :   {
; 1165 :     disk.pRefresher->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 1166 :     disk.pRefresher = nullptr;

	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+8, 0
$LN73@SK_Monitor:

; 1167 :   }
; 1168 : 
; 1169 :   if (disk.hShutdownSignal != INVALID_HANDLE_VALUE)

	cmp	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+4, -1
	je	SHORT $LN74@SK_Monitor

; 1170 :   {
; 1171 :     CloseHandle (disk.hShutdownSignal);

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+4
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 1172 :     disk.hShutdownSignal = INVALID_HANDLE_VALUE;

	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+4, -1
$LN74@SK_Monitor:

; 1173 :   }
; 1174 : 
; 1175 :   COM::base.wmi.Unlock   ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	call	?Unlock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Unlock
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h

; 52   :     if (success)

	cmp	BYTE PTR _auto_com$[ebp], 0
	je	SHORT $LN215@SK_Monitor

; 53   :       CoUninitialize ();

	call	DWORD PTR __imp__CoUninitialize@0
$LN215@SK_Monitor:
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 1178 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	xor	eax, eax
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_MonitorDisk@@YGKPAX@Z$24:
	lea	ecx, DWORD PTR _auto_com$[ebp]
	jmp	??1SK_AutoCOMInit@@QAE@XZ		; SK_AutoCOMInit::~SK_AutoCOMInit
__ehhandler$?SK_MonitorDisk@@YGKPAX@Z:
	mov	eax, OFFSET __ehfuncinfo$?SK_MonitorDisk@@YGKPAX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_MonitorDisk@@YGKPAX@Z ENDP				; SK_MonitorDisk
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
_TEXT	SEGMENT
_interrupt$2 = -84					; size = 8
_kernel$3 = -76						; size = 8
_user$4 = -68						; size = 8
_load$5 = -60						; size = 8
_idle$6 = -52						; size = 8
_PercentIdleTimeType$7 = -44				; size = 4
_PercentProcessorTimeType$8 = -40			; size = 4
_PercentUserTimeType$9 = -36				; size = 4
_PercentPrivilegedTimeType$10 = -32			; size = 4
_PercentInterruptTimeType$11 = -28			; size = 4
_update$1$ = -24					; size = 8
tv1795 = -20						; size = 4
_auto_com$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
_user_param$ = 8					; size = 4
?SK_MonitorCPU@@YGKPAX@Z PROC				; SK_MonitorCPU

; 415  : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?SK_MonitorCPU@@YGKPAX@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 72					; 00000048H
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?base@COM@@3UBase@1@A+4
	push	esi
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 416  :   while (! ReadAcquire (&COM::base.wmi.init))

	test	eax, eax
	jne	SHORT $LN3@SK_Monitor
	mov	esi, DWORD PTR __imp__SleepEx@8
	npad	3
$LL2@SK_Monitor:

; 417  :     SleepEx (150, FALSE);

	push	0
	push	150					; 00000096H
	call	esi
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?base@COM@@3UBase@1@A+4
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 416  :   while (! ReadAcquire (&COM::base.wmi.init))

	test	eax, eax
	je	SHORT $LL2@SK_Monitor
$LN3@SK_Monitor:
	push	ebx
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h

; 45   :     HRESULT hr = CoInitializeEx (NULL, COINIT_MULTITHREADED);

	push	0
	push	0

; 54   :   }
; 55   : 
; 56   : private:
; 57   :   bool success = false;

	xor	bl, bl
	call	DWORD PTR __imp__CoInitializeEx@8
	test	eax, eax
	movzx	ecx, bl
	mov	edx, 1
	cmovns	ecx, edx
	mov	BYTE PTR _auto_com$[ebp], cl
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 423  :   COM::base.wmi.Lock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?Lock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Lock
	movss	xmm0, DWORD PTR ?config@@3Usk_config_t@@A+100

; 424  : 
; 425  :   cpu_perf_t&  cpu    = cpu_stats;
; 426  :   const double update = config.cpu.interval;
; 427  : 
; 428  :   HRESULT hr;
; 429  : 
; 430  :   if (FAILED (hr = CoCreateInstance (

	push	OFFSET ?cpu_stats@@3Ucpu_perf_t@@A+8
	push	OFFSET _IID_IWbemRefresher
	cvtps2pd xmm0, xmm0
	push	1
	push	0
	push	OFFSET _CLSID_WbemRefresher
	movsd	QWORD PTR _update$1$[ebp], xmm0
	call	DWORD PTR __imp__CoCreateInstance@20
	test	eax, eax
	jns	SHORT $LN12@SK_Monitor

; 431  :                      CLSID_WbemRefresher,
; 432  :                      nullptr,
; 433  :                      CLSCTX_INPROC_SERVER,
; 434  :                      IID_IWbemRefresher, 
; 435  :                      (void**) &cpu.pRefresher )
; 436  :              )
; 437  :      )
; 438  :   {
; 439  :     dll_log.Log (L"[ WMI Wbem ] Failed to create Refresher Instance (%s:%d)",

	push	440					; 000001b8H
	push	OFFSET $SG165915
	push	OFFSET $SG165916
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 440  :       __FILEW__, __LINE__);
; 441  :     goto CPU_CLEANUP;

	jmp	$CPU_CLEANUP$120
$LN12@SK_Monitor:

; 442  :   }
; 443  : 
; 444  :   if (FAILED (hr = cpu.pRefresher->QueryInterface (

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+8
	push	OFFSET ?cpu_stats@@3Ucpu_perf_t@@A+12
	push	OFFSET _IID_IWbemConfigureRefresher
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx]
	test	eax, eax
	jns	SHORT $LN14@SK_Monitor

; 445  :                         IID_IWbemConfigureRefresher,
; 446  :                         (void **)&cpu.pConfig )
; 447  :              )
; 448  :      )
; 449  :   {
; 450  :     dll_log.Log (L"[ WMI Wbem ] Failed to Query Refresher Interface (%s:%d)",

	push	451					; 000001c3H
	push	OFFSET $SG165919
	push	OFFSET $SG165920
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 451  :       __FILEW__, __LINE__);
; 452  :     goto CPU_CLEANUP;

	jmp	$CPU_CLEANUP$120
$LN14@SK_Monitor:

; 453  :   }
; 454  : 
; 455  :   // Add an enumerator to the refresher.
; 456  :   if (FAILED (hr = cpu.pConfig->AddEnum (

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+12
	push	OFFSET ?cpu_stats@@3Ucpu_perf_t@@A+24
	push	OFFSET ?cpu_stats@@3Ucpu_perf_t@@A+16
	push	0
	mov	ecx, DWORD PTR [eax]
	push	0
	push	OFFSET $SG165923
	push	DWORD PTR ?base@COM@@3UBase@1@A+8
	push	eax
	call	DWORD PTR [ecx+28]
	test	eax, eax
	jns	SHORT $LN16@SK_Monitor

; 457  :                      COM::base.wmi.pNameSpace,
; 458  :                      L"Win32_PerfFormattedData_PerfOS_Processor",
; 459  :                      0,
; 460  :                      nullptr,
; 461  :                      &cpu.pEnum,
; 462  :                      &cpu.lID )
; 463  :              )
; 464  :      )
; 465  :   {
; 466  :     dll_log.Log (L"[ WMI Wbem ] Failed to Add Enumerator (%s:%d) - %04X",

	push	eax
	push	467					; 000001d3H
	push	OFFSET $SG165924
	push	OFFSET $SG165925
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 20					; 00000014H

; 467  :       __FILEW__, __LINE__, hr);
; 468  :     goto CPU_CLEANUP;

	jmp	$CPU_CLEANUP$120
$LN16@SK_Monitor:

; 469  :   }
; 470  : 
; 471  :   cpu.pConfig->Release ();

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+12
	push	edi
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]

; 472  :   cpu.pConfig = nullptr;
; 473  : 
; 474  :   int iter = 0;

	xor	ebx, ebx
	mov	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+12, 0

; 475  : 
; 476  :   cpu.dwNumReturned = 0;
; 477  :   cpu.dwNumObjects  = 0;
; 478  : 
; 479  :   cpu.hShutdownSignal = CreateEvent (nullptr, FALSE, FALSE, L"CPUMon Shutdown Signal");

	push	OFFSET $SG165927
	push	ebx
	push	ebx
	push	ebx
	mov	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+32, ebx
	mov	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+28, ebx
	call	DWORD PTR __imp__CreateEventW@16

; 480  : 
; 481  :   COM::base.wmi.Unlock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	mov	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+4, eax
	call	?Unlock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Unlock

; 482  : 
; 483  :   while (cpu.lID != 0)

	cmp	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+24, ebx
	je	$LN5@SK_Monitor
	movsd	xmm0, QWORD PTR _update$1$[ebp]
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	call	__dtoui3
	mov	DWORD PTR tv1795[ebp], eax
	lea	esi, DWORD PTR [ebx+4]
	mov	edi, OFFSET ?cpu_stats@@3Ucpu_perf_t@@A+28
	npad	5
$LL4@SK_Monitor:

; 484  :   {
; 485  :     if (WaitForSingleObject (cpu.hShutdownSignal, DWORD (update * 1000.0)) == WAIT_OBJECT_0)

	push	eax
	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+4
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
	test	eax, eax
	je	$LN5@SK_Monitor

; 486  :       break;
; 487  : 
; 488  :     // Only poll WMI while the data view is visible
; 489  :     if (! (config.cpu.show || SK_ImGui_Widgets.cpu_monitor->isActive ()))

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+96, 0
	jne	SHORT $LN19@SK_Monitor
	mov	eax, DWORD PTR ?SK_ImGui_Widgets@@3USK_ImGui_WidgetRegistry@@A+16
	cmp	BYTE PTR [eax+185], 0
	je	$LN104@SK_Monitor
$LN19@SK_Monitor:

; 490  :       continue;
; 491  : 
; 492  :     cpu.dwNumReturned = 0;
; 493  : 
; 494  :     COM::base.wmi.Lock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	mov	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+32, 0
	call	?Lock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Lock

; 495  : 
; 496  :     if (FAILED (hr = cpu.pRefresher->Refresh (0L)))

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+8
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+12]
	test	eax, eax
	js	$LN92@SK_Monitor

; 501  :     }
; 502  : 
; 503  :     hr = cpu.pEnum->GetObjects ( 0L,

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+16
	push	OFFSET ?cpu_stats@@3Ucpu_perf_t@@A+32
	push	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
	push	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+28
	mov	ecx, DWORD PTR [eax]
	push	0
	push	eax
	call	DWORD PTR [ecx+20]

; 504  :                                  cpu.dwNumObjects,
; 505  :                                  cpu.apEnumAccess,
; 506  :                                  &cpu.dwNumReturned );
; 507  : 
; 508  : 
; 509  :     // If the buffer was not big enough,
; 510  :     // allocate a bigger buffer and retry.
; 511  :     if (hr == WBEM_E_BUFFER_TOO_SMALL 
; 512  :         && cpu.dwNumReturned > cpu.dwNumObjects)

	cmp	eax, -2147217348			; 8004103cH
	jne	$LN22@SK_Monitor
	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+32
	cmp	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+28
	jbe	$LN95@SK_Monitor

; 513  :     {
; 514  :       cpu.apEnumAccess = new IWbemObjectAccess* [cpu.dwNumReturned];

	xor	ecx, ecx
	mul	esi
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20, edx

; 515  :       if (cpu.apEnumAccess == nullptr)

	test	edx, edx
	je	$LN93@SK_Monitor

; 521  :       }
; 522  : 
; 523  :       SecureZeroMemory (cpu.apEnumAccess,

	mov	esi, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+32
	lea	eax, DWORD PTR [esi*4]
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 17796:     while (cnt) {

	test	eax, eax
	je	SHORT $LN70@SK_Monitor
	npad	8
$LL69@SK_Monitor:

; 17797: 
; 17798: #if !defined(_M_CEE) && defined(_M_ARM)
; 17799: 
; 17800:         __iso_volatile_store8(vptr, 0);
; 17801: 
; 17802: #else
; 17803: 
; 17804:         *vptr = 0;

	mov	BYTE PTR [edx], 0

; 17805: 
; 17806: #endif
; 17807: 
; 17808:         vptr++;

	lea	edx, DWORD PTR [edx+1]

; 17809:         cnt--;

	sub	eax, 1
	jne	SHORT $LL69@SK_Monitor

; 17796:     while (cnt) {

	mov	esi, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+32
	mov	edx, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
$LN70@SK_Monitor:
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 528  :       if (FAILED (hr = cpu.pEnum->GetObjects ( 0L,

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+16
	push	OFFSET ?cpu_stats@@3Ucpu_perf_t@@A+32
	push	edx
	push	esi
	mov	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+28, esi
	mov	ecx, DWORD PTR [eax]
	push	0
	push	eax
	call	DWORD PTR [ecx+20]
	test	eax, eax
	js	$LN94@SK_Monitor
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 3779 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+32
	mov	ecx, OFFSET ?cpu_stats@@3Ucpu_perf_t@@A+32
	cmp	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+28
	cmovae	ecx, edi
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 541  :       cpu.dwNumReturned = std::min (cpu.dwNumObjects, cpu.dwNumReturned);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+32, eax

; 542  :     }
; 543  :     else

	jmp	SHORT $LN28@SK_Monitor
$LN22@SK_Monitor:

; 544  :     {
; 545  :       if (hr != WBEM_S_NO_ERROR)

	test	eax, eax
	jne	$LN95@SK_Monitor
	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+32
$LN28@SK_Monitor:

; 551  :       }
; 552  :     }
; 553  : 
; 554  :     // First time through, get the handles.
; 555  :     if (iter == 0)

	test	ebx, ebx
	jne	$LN39@SK_Monitor

; 556  :     {
; 557  :       CIMTYPE PercentInterruptTimeType;
; 558  :       CIMTYPE PercentPrivilegedTimeType;
; 559  :       CIMTYPE PercentUserTimeType;
; 560  :       CIMTYPE PercentProcessorTimeType;
; 561  :       CIMTYPE PercentIdleTimeType;
; 562  : 
; 563  :       if (FAILED (hr = cpu.apEnumAccess [0]->GetPropertyHandle (

	mov	ecx, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
	lea	edx, DWORD PTR _PercentInterruptTimeType$11[ebp]
	push	OFFSET ?cpu_stats@@3Ucpu_perf_t@@A+40
	push	edx
	push	OFFSET $SG165950
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN96@SK_Monitor

; 573  :       }
; 574  : 
; 575  :       if (FAILED (hr = cpu.apEnumAccess [0]->GetPropertyHandle (

	mov	ecx, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
	lea	edx, DWORD PTR _PercentPrivilegedTimeType$10[ebp]
	push	OFFSET ?cpu_stats@@3Ucpu_perf_t@@A+44
	push	edx
	push	OFFSET $SG165955
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN97@SK_Monitor

; 585  :       }
; 586  : 
; 587  :       if (FAILED (hr = cpu.apEnumAccess [0]->GetPropertyHandle (

	mov	ecx, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
	lea	edx, DWORD PTR _PercentUserTimeType$9[ebp]
	push	OFFSET ?cpu_stats@@3Ucpu_perf_t@@A+48
	push	edx
	push	OFFSET $SG165960
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN98@SK_Monitor

; 597  :       }
; 598  : 
; 599  :       if (FAILED (hr = cpu.apEnumAccess [0]->GetPropertyHandle (

	mov	ecx, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
	lea	edx, DWORD PTR _PercentProcessorTimeType$8[ebp]
	push	OFFSET ?cpu_stats@@3Ucpu_perf_t@@A+52
	push	edx
	push	OFFSET $SG165965
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN99@SK_Monitor

; 609  :       }
; 610  : 
; 611  :       if (FAILED (hr = cpu.apEnumAccess [0]->GetPropertyHandle (

	mov	ecx, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
	lea	edx, DWORD PTR _PercentIdleTimeType$7[ebp]
	push	OFFSET ?cpu_stats@@3Ucpu_perf_t@@A+56
	push	edx
	push	OFFSET $SG165970
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN100@SK_Monitor
	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+32
$LN39@SK_Monitor:

; 621  :       }
; 622  :     }
; 623  : 
; 624  :     for (unsigned int i = 0; i < cpu.dwNumReturned; i++)

	xor	esi, esi
	test	eax, eax
	je	$LN7@SK_Monitor
	mov	edi, OFFSET ?cpu_stats@@3Ucpu_perf_t@@A+72
	npad	9
$LL8@SK_Monitor:

; 625  :     {
; 626  :       uint64_t interrupt;
; 627  :       uint64_t kernel;
; 628  :       uint64_t user;
; 629  :       uint64_t load;
; 630  :       uint64_t idle;
; 631  : 
; 632  :       if (cpu.apEnumAccess [i] == nullptr)

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
	mov	ecx, DWORD PTR [eax+esi*4]
	test	ecx, ecx
	je	$LN85@SK_Monitor

; 636  :       }
; 637  : 
; 638  :       if (FAILED (hr = cpu.apEnumAccess [i]->ReadQWORD (

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR _interrupt$2[ebp]
	push	edx
	push	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+40
	push	ecx
	call	DWORD PTR [eax+128]
	test	eax, eax
	js	$LN86@SK_Monitor

; 647  :       }
; 648  : 
; 649  :       if (FAILED (hr = cpu.apEnumAccess [i]->ReadQWORD (

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
	lea	edx, DWORD PTR _kernel$3[ebp]
	push	edx
	push	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+44
	mov	eax, DWORD PTR [eax+esi*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+128]
	test	eax, eax
	js	$LN87@SK_Monitor

; 658  :       }
; 659  : 
; 660  :       if (FAILED (hr = cpu.apEnumAccess [i]->ReadQWORD (

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
	lea	edx, DWORD PTR _user$4[ebp]
	push	edx
	push	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+48
	mov	eax, DWORD PTR [eax+esi*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+128]
	test	eax, eax
	js	$LN88@SK_Monitor

; 669  :       }
; 670  : 
; 671  :       if (FAILED (hr = cpu.apEnumAccess [i]->ReadQWORD (

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
	lea	edx, DWORD PTR _load$5[ebp]
	push	edx
	push	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+52
	mov	eax, DWORD PTR [eax+esi*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+128]
	test	eax, eax
	js	$LN89@SK_Monitor

; 680  :       }
; 681  : 
; 682  :       if (FAILED (hr = cpu.apEnumAccess [i]->ReadQWORD (

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
	lea	edx, DWORD PTR _idle$6[ebp]
	push	edx
	push	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+56
	mov	eax, DWORD PTR [eax+esi*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+128]
	test	eax, eax
	js	$LN90@SK_Monitor

; 691  :       }
; 692  : 
; 693  :       cpu.cpus [i].percent_idle   = (cpu.cpus [i].percent_idle   + idle)   / 2;

	mov	ecx, DWORD PTR [edi]
	add	ecx, DWORD PTR _idle$6[ebp]
	mov	eax, DWORD PTR [edi+4]
	adc	eax, DWORD PTR _idle$6[ebp+4]
	shrd	ecx, eax, 1
	shr	eax, 1
	mov	DWORD PTR [edi+4], eax

; 694  :       cpu.cpus [i].percent_load   = (cpu.cpus [i].percent_load   + load)   / 2;

	mov	eax, DWORD PTR _load$5[ebp+4]
	mov	DWORD PTR [edi], ecx
	mov	ecx, DWORD PTR _load$5[ebp]
	add	ecx, DWORD PTR [edi-8]
	adc	eax, DWORD PTR [edi-4]
	shrd	ecx, eax, 1
	shr	eax, 1
	mov	DWORD PTR [edi-8], ecx

; 695  :       cpu.cpus [i].percent_user   = (cpu.cpus [i].percent_user   + user)   / 2;

	mov	ecx, DWORD PTR [edi+16]
	add	ecx, DWORD PTR _user$4[ebp]
	mov	DWORD PTR [edi-4], eax
	mov	eax, DWORD PTR [edi+20]
	adc	eax, DWORD PTR _user$4[ebp+4]
	shrd	ecx, eax, 1
	shr	eax, 1
	mov	DWORD PTR [edi+16], ecx

; 696  :       cpu.cpus [i].percent_kernel = (cpu.cpus [i].percent_kernel + kernel) / 2;

	mov	ecx, DWORD PTR [edi+8]
	add	ecx, DWORD PTR _kernel$3[ebp]
	mov	DWORD PTR [edi+20], eax
	mov	eax, DWORD PTR [edi+12]
	adc	eax, DWORD PTR _kernel$3[ebp+4]
	shrd	ecx, eax, 1
	shr	eax, 1
	mov	DWORD PTR [edi+8], ecx

; 697  :       cpu.cpus [i].percent_interrupt

	mov	ecx, DWORD PTR [edi+24]
	add	ecx, DWORD PTR _interrupt$2[ebp]
	mov	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [edi+28]
	adc	eax, DWORD PTR _interrupt$2[ebp+4]
	shrd	ecx, eax, 1
	shr	eax, 1
	mov	DWORD PTR [edi+24], ecx
	mov	DWORD PTR [edi+28], eax

; 698  :                                   = ( cpu.cpus [i].percent_interrupt + 
; 699  :                                       interrupt ) / 2;
; 700  : 
; 701  :       cpu.cpus [i].update_time = timeGetTime ();

	call	DWORD PTR __imp__timeGetTime@0
	mov	DWORD PTR [edi+40], eax

; 702  : 
; 703  :       // Done with the object
; 704  :       cpu.apEnumAccess [i]->Release ();

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
	mov	eax, DWORD PTR [eax+esi*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]

; 705  :       cpu.apEnumAccess [i] = nullptr;

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
	add	edi, 56					; 00000038H
	mov	DWORD PTR [eax+esi*4], 0
	inc	esi
	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+32
	cmp	esi, eax
	jb	$LL8@SK_Monitor
	mov	edi, OFFSET ?cpu_stats@@3Ucpu_perf_t@@A+28
$LN7@SK_Monitor:

; 706  :     }
; 707  : 
; 708  :     cpu.num_cpus = cpu.dwNumReturned;
; 709  :     cpu.booting  = false;
; 710  : 
; 711  :     ++iter;
; 712  : 
; 713  :     COM::base.wmi.Unlock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	mov	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+3648, eax
	mov	BYTE PTR ?cpu_stats@@3Ucpu_perf_t@@A+36, 0
	inc	ebx
	call	?Unlock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Unlock
	mov	esi, 4
$LN104@SK_Monitor:

; 482  : 
; 483  :   while (cpu.lID != 0)

	cmp	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+24, 0
	je	$LN5@SK_Monitor
	mov	eax, DWORD PTR tv1795[ebp]
	jmp	$LL4@SK_Monitor
$LN94@SK_Monitor:

; 529  :                                                cpu.dwNumObjects,
; 530  :                                                cpu.apEnumAccess,
; 531  :                                                &cpu.dwNumReturned )
; 532  :                  )
; 533  :          )
; 534  :       {
; 535  :         dll_log.Log (L"[ WMI Wbem ] Failed to get CPU Objects (%s:%d)",

	push	536					; 00000218H
	push	OFFSET $SG165941
	push	OFFSET $SG165942
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 536  :           __FILEW__, __LINE__);
; 537  : 
; 538  :         goto CPU_CLEANUP;

	jmp	$LN119@SK_Monitor
$LN93@SK_Monitor:

; 516  :       {
; 517  :         dll_log.Log (L"[ WMI Wbem ] Out of Memory (%s:%d)",

	push	518					; 00000206H
	push	OFFSET $SG165937
	push	OFFSET $SG165938
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 518  :           __FILEW__, __LINE__);
; 519  :         hr = E_OUTOFMEMORY;
; 520  :         goto CPU_CLEANUP;

	jmp	$LN119@SK_Monitor
$LN100@SK_Monitor:

; 612  :                             L"PercentIdleTime",
; 613  :                             &PercentIdleTimeType,
; 614  :                             &cpu.lPercentIdleTimeHandle )
; 615  :                  )
; 616  :          )
; 617  :       {
; 618  :         dll_log.Log (L"[ WMI Wbem ] Failed to acquire property handle (%s:%d)",

	push	619					; 0000026bH
	push	OFFSET $SG165971
	push	OFFSET $SG165972
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 619  :           __FILEW__, __LINE__);
; 620  :         goto CPU_CLEANUP;

	jmp	$LN119@SK_Monitor
$LN99@SK_Monitor:

; 600  :                             L"PercentProcessorTime",
; 601  :                             &PercentProcessorTimeType,
; 602  :                             &cpu.lPercentProcessorTimeHandle )
; 603  :                  )
; 604  :          )
; 605  :       {
; 606  :         dll_log.Log (L"[ WMI Wbem ] Failed to acquire property handle (%s:%d)",

	push	607					; 0000025fH
	push	OFFSET $SG165966
	push	OFFSET $SG165967
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 607  :           __FILEW__, __LINE__);
; 608  :         goto CPU_CLEANUP;

	jmp	$LN119@SK_Monitor
$LN98@SK_Monitor:

; 588  :                             L"PercentUserTime",
; 589  :                             &PercentUserTimeType,
; 590  :                             &cpu.lPercentUserTimeHandle )
; 591  :                  )
; 592  :          )
; 593  :       {
; 594  :         dll_log.Log (L"[ WMI Wbem ] Failed to acquire property handle (%s:%d)",

	push	595					; 00000253H
	push	OFFSET $SG165961
	push	OFFSET $SG165962
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 595  :           __FILEW__, __LINE__);
; 596  :         goto CPU_CLEANUP;

	jmp	$LN119@SK_Monitor
$LN97@SK_Monitor:

; 576  :                             L"PercentPrivilegedTime",
; 577  :                             &PercentPrivilegedTimeType,
; 578  :                             &cpu.lPercentPrivilegedTimeHandle )
; 579  :                  )
; 580  :          )
; 581  :       {
; 582  :         dll_log.Log (L"[ WMI Wbem ] Failed to acquire property handle (%s:%d)",

	push	583					; 00000247H
	push	OFFSET $SG165956
	push	OFFSET $SG165957
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 583  :           __FILEW__, __LINE__);
; 584  :         goto CPU_CLEANUP;

	jmp	$LN119@SK_Monitor
$LN96@SK_Monitor:

; 564  :                             L"PercentInterruptTime",
; 565  :                             &PercentInterruptTimeType,
; 566  :                             &cpu.lPercentInterruptTimeHandle )
; 567  :                  )
; 568  :          )
; 569  :       {
; 570  :         dll_log.Log (L"[ WMI Wbem ] Failed to acquire property handle (%s:%d)",

	push	571					; 0000023bH
	push	OFFSET $SG165951
	push	OFFSET $SG165952
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 571  :           __FILEW__, __LINE__);
; 572  :         goto CPU_CLEANUP;

	jmp	$LN119@SK_Monitor
$LN90@SK_Monitor:

; 683  :                              cpu.lPercentIdleTimeHandle,
; 684  :                              &idle )
; 685  :                  )
; 686  :          )
; 687  :       {
; 688  :         dll_log.Log (L"[ WMI Wbem ] Failed to read Quad-Word Property (%s:%d)",

	push	689					; 000002b1H
	push	OFFSET $SG165994
	push	OFFSET $SG165995
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 689  :           __FILEW__, __LINE__);
; 690  :         goto CPU_CLEANUP;

	jmp	$LN119@SK_Monitor
$LN89@SK_Monitor:

; 672  :                              cpu.lPercentProcessorTimeHandle,
; 673  :                              &load )
; 674  :                  )
; 675  :          )
; 676  :       {
; 677  :         dll_log.Log (L"[ WMI Wbem ] Failed to read Quad-Word Property (%s:%d)",

	push	678					; 000002a6H
	push	OFFSET $SG165990
	push	OFFSET $SG165991
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 678  :           __FILEW__, __LINE__);
; 679  :         goto CPU_CLEANUP;

	jmp	$LN119@SK_Monitor
$LN88@SK_Monitor:

; 661  :                              cpu.lPercentUserTimeHandle,
; 662  :                              &user )
; 663  :                  )
; 664  :          )
; 665  :       {
; 666  :         dll_log.Log (L"[ WMI Wbem ] Failed to read Quad-Word Property (%s:%d)",

	push	667					; 0000029bH
	push	OFFSET $SG165986
	push	OFFSET $SG165987
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 667  :           __FILEW__, __LINE__);
; 668  :         goto CPU_CLEANUP;

	jmp	$LN119@SK_Monitor
$LN87@SK_Monitor:

; 650  :                              cpu.lPercentPrivilegedTimeHandle,
; 651  :                              &kernel )
; 652  :                  )
; 653  :          )
; 654  :       {
; 655  :         dll_log.Log (L"[ WMI Wbem ] Failed to read Quad-Word Property (%s:%d)",

	push	656					; 00000290H
	push	OFFSET $SG165982
	push	OFFSET $SG165983
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 656  :           __FILEW__, __LINE__);
; 657  :         goto CPU_CLEANUP;

	jmp	SHORT $LN119@SK_Monitor
$LN86@SK_Monitor:

; 639  :                              cpu.lPercentInterruptTimeHandle,
; 640  :                              &interrupt )
; 641  :                  )
; 642  :          )
; 643  :       {
; 644  :         dll_log.Log (L"[ WMI Wbem ] Failed to read Quad-Word Property (%s:%d)",

	push	645					; 00000285H
	push	OFFSET $SG165978
	push	OFFSET $SG165979
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 645  :           __FILEW__, __LINE__);
; 646  :         goto CPU_CLEANUP;

	jmp	SHORT $LN119@SK_Monitor
$LN85@SK_Monitor:

; 633  :       {
; 634  :         dll_log.Log (L"[ WMI Wbem ] CPU apEnumAccess [%lu] = nullptr",  i);

	push	esi
	push	OFFSET $SG165975
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH

; 635  :         goto CPU_CLEANUP;

	jmp	SHORT $LN119@SK_Monitor
$LN95@SK_Monitor:

; 546  :       {
; 547  :         dll_log.Log (L"[ WMI Wbem ] UNKNOWN ERROR (%s:%d)",

	push	548					; 00000224H
	push	OFFSET $SG165945
	push	OFFSET $SG165946
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 548  :           __FILEW__, __LINE__);
; 549  :         hr = WBEM_E_NOT_FOUND;
; 550  :         goto CPU_CLEANUP;

	jmp	SHORT $LN119@SK_Monitor
$LN92@SK_Monitor:

; 497  :     {
; 498  :       dll_log.Log (L"[ WMI Wbem ] Failed to Refresh CPU (%s:%d)",

	push	499					; 000001f3H
	push	OFFSET $SG165931
	push	OFFSET $SG165932
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 499  :         __FILEW__, __LINE__);
; 500  :       goto CPU_CLEANUP;

	jmp	SHORT $LN119@SK_Monitor
$LN5@SK_Monitor:

; 714  :   }
; 715  : 
; 716  :   COM::base.wmi.Lock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	call	?Lock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Lock
$LN119@SK_Monitor:
	pop	edi
$CPU_CLEANUP$120:

; 717  : 
; 718  : CPU_CLEANUP:
; 719  :   //dll_log.Log (L" >> CPU_CLEANUP");
; 720  : 
; 721  :   if (cpu.apEnumAccess != nullptr)

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
	pop	ebx
	test	eax, eax
	je	SHORT $LN53@SK_Monitor

; 722  :   {
; 723  :     for (unsigned int i = 0; i < cpu.dwNumReturned; i++)

	mov	edx, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+32
	xor	esi, esi
	test	edx, edx
	je	SHORT $LN10@SK_Monitor
	npad	1
$LL11@SK_Monitor:

; 724  :     {
; 725  :       if (cpu.apEnumAccess [i] != nullptr)

	mov	ecx, DWORD PTR [eax+esi*4]
	test	ecx, ecx
	je	SHORT $LN9@SK_Monitor

; 726  :       {
; 727  :         cpu.apEnumAccess [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 728  :         cpu.apEnumAccess [i] = nullptr;

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
	mov	DWORD PTR [eax+esi*4], 0
	mov	edx, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+32
	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
$LN9@SK_Monitor:

; 722  :   {
; 723  :     for (unsigned int i = 0; i < cpu.dwNumReturned; i++)

	inc	esi
	cmp	esi, edx
	jb	SHORT $LL11@SK_Monitor
$LN10@SK_Monitor:

; 729  :       }
; 730  :     }
; 731  :     delete [] cpu.apEnumAccess;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN53@SK_Monitor:

; 732  :   }
; 733  : 
; 734  :   if (cpu.pEnum)

	mov	ecx, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+16
	pop	esi
	test	ecx, ecx
	je	SHORT $LN55@SK_Monitor

; 735  :   {
; 736  :     cpu.pEnum->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 737  :     cpu.pEnum = nullptr;

	mov	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+16, 0
$LN55@SK_Monitor:

; 738  :   }
; 739  : 
; 740  :   if (cpu.pConfig != nullptr)

	mov	ecx, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+12
	test	ecx, ecx
	je	SHORT $LN56@SK_Monitor

; 741  :   {
; 742  :     cpu.pConfig->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 743  :     cpu.pConfig = nullptr;

	mov	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+12, 0
$LN56@SK_Monitor:

; 744  :   }
; 745  : 
; 746  :   if (cpu.pRefresher != nullptr)

	mov	ecx, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+8
	test	ecx, ecx
	je	SHORT $LN57@SK_Monitor

; 747  :   {
; 748  :     cpu.pRefresher->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 749  :     cpu.pRefresher = nullptr;

	mov	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+8, 0
$LN57@SK_Monitor:

; 750  :   }
; 751  : 
; 752  :   if (cpu.hShutdownSignal != INVALID_HANDLE_VALUE)

	cmp	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+4, -1
	je	SHORT $LN58@SK_Monitor

; 753  :   {
; 754  :     CloseHandle (cpu.hShutdownSignal);

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+4
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 755  :     cpu.hShutdownSignal = nullptr;

	mov	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+4, 0
$LN58@SK_Monitor:

; 756  :   }
; 757  : 
; 758  :   COM::base.wmi.Unlock   ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	call	?Unlock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Unlock
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h

; 52   :     if (success)

	cmp	BYTE PTR _auto_com$[ebp], 0
	je	SHORT $LN117@SK_Monitor

; 53   :       CoUninitialize ();

	call	DWORD PTR __imp__CoUninitialize@0
$LN117@SK_Monitor:
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 761  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	xor	eax, eax
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_MonitorCPU@@YGKPAX@Z$18:
	lea	ecx, DWORD PTR _auto_com$[ebp]
	jmp	??1SK_AutoCOMInit@@QAE@XZ		; SK_AutoCOMInit::~SK_AutoCOMInit
__ehhandler$?SK_MonitorCPU@@YGKPAX@Z:
	mov	eax, OFFSET __ehfuncinfo$?SK_MonitorCPU@@YGKPAX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_MonitorCPU@@YGKPAX@Z ENDP				; SK_MonitorCPU
; Function compile flags: /Ogtp
;	COMDAT ??0pagefile_perf_t@@QAE@XZ
_TEXT	SEGMENT
??0pagefile_perf_t@@QAE@XZ PROC				; pagefile_perf_t::pagefile_perf_t, COMDAT
; _this$ = ecx
	mov	edx, ecx
	mov	ecx, 16					; 00000010H
	mov	DWORD PTR [edx], -1
	lea	eax, DWORD PTR [edx+316]
	mov	DWORD PTR [edx+4], -1
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR [edx+12], 0
	mov	DWORD PTR [edx+16], 0
	mov	DWORD PTR [edx+20], 0
	mov	DWORD PTR [edx+24], 0
	mov	DWORD PTR [edx+28], 0
	mov	DWORD PTR [edx+32], 0
	mov	BYTE PTR [edx+36], 1
	mov	DWORD PTR [edx+40], 0
	mov	DWORD PTR [edx+44], 0
	mov	DWORD PTR [edx+48], 0
	mov	DWORD PTR [edx+52], 0
	npad	5
$LL7@pagefile_p:
	mov	DWORD PTR [eax-4], 0
	lea	eax, DWORD PTR [eax+268]
	mov	DWORD PTR [eax-268], 0
	mov	DWORD PTR [eax-264], 0
	sub	ecx, 1
	jne	SHORT $LL7@pagefile_p
	mov	DWORD PTR [edx+4344], ecx
	mov	eax, edx
	ret	0
??0pagefile_perf_t@@QAE@XZ ENDP				; pagefile_perf_t::pagefile_perf_t
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0<unnamed-type-pagefiles>@pagefile_perf_t@@QAE@XZ
_TEXT	SEGMENT
??0<unnamed-type-pagefiles>@pagefile_perf_t@@QAE@XZ PROC ; pagefile_perf_t::<unnamed-type-pagefiles>::<unnamed-type-pagefiles>, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx+256], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+260], 0
	mov	DWORD PTR [ecx+264], 0
	ret	0
??0<unnamed-type-pagefiles>@pagefile_perf_t@@QAE@XZ ENDP ; pagefile_perf_t::<unnamed-type-pagefiles>::<unnamed-type-pagefiles>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0disk_perf_t@@QAE@XZ
_TEXT	SEGMENT
??0disk_perf_t@@QAE@XZ PROC				; disk_perf_t::disk_perf_t, COMDAT
; _this$ = ecx
	mov	edx, ecx
	mov	ecx, 16					; 00000010H
	mov	DWORD PTR [edx], -1
	lea	eax, DWORD PTR [edx+112]
	mov	DWORD PTR [edx+4], -1
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR [edx+12], 0
	mov	DWORD PTR [edx+16], 0
	mov	DWORD PTR [edx+20], 0
	mov	DWORD PTR [edx+24], 0
	mov	DWORD PTR [edx+28], 0
	mov	DWORD PTR [edx+32], 0
	mov	BYTE PTR [edx+36], 1
	mov	DWORD PTR [edx+40], 0
	mov	DWORD PTR [edx+44], 0
	mov	DWORD PTR [edx+48], 0
	mov	DWORD PTR [edx+52], 0
	mov	DWORD PTR [edx+56], 0
	mov	DWORD PTR [edx+60], 0
	mov	DWORD PTR [edx+64], 0
	mov	DWORD PTR [edx+68], 0
$LL7@disk_perf_:
	mov	DWORD PTR [eax-8], 0
	lea	eax, DWORD PTR [eax+88]
	mov	DWORD PTR [eax-92], 0
	mov	DWORD PTR [eax-88], 0
	mov	DWORD PTR [eax-84], 0
	mov	DWORD PTR [eax-80], 0
	mov	DWORD PTR [eax-76], 0
	mov	DWORD PTR [eax-72], 0
	mov	DWORD PTR [eax-68], 0
	mov	DWORD PTR [eax-64], 0
	mov	DWORD PTR [eax-60], 0
	mov	DWORD PTR [eax-56], 0
	mov	DWORD PTR [eax-52], 0
	mov	DWORD PTR [eax-48], 0
	mov	DWORD PTR [eax-44], 0
	sub	ecx, 1
	jne	SHORT $LL7@disk_perf_
	mov	DWORD PTR [edx+1480], ecx
	mov	eax, edx
	ret	0
??0disk_perf_t@@QAE@XZ ENDP				; disk_perf_t::disk_perf_t
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0disk_stat_s@disk_perf_t@@QAE@XZ
_TEXT	SEGMENT
??0disk_stat_s@disk_perf_t@@QAE@XZ PROC			; disk_perf_t::disk_stat_s::disk_stat_s, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx+32], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+40], 0
	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+52], 0
	mov	DWORD PTR [ecx+56], 0
	mov	DWORD PTR [ecx+60], 0
	mov	DWORD PTR [ecx+64], 0
	mov	DWORD PTR [ecx+68], 0
	mov	DWORD PTR [ecx+72], 0
	mov	DWORD PTR [ecx+76], 0
	mov	DWORD PTR [ecx+80], 0
	mov	DWORD PTR [ecx+84], 0
	ret	0
??0disk_stat_s@disk_perf_t@@QAE@XZ ENDP			; disk_perf_t::disk_stat_s::disk_stat_s
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0cpu_perf_t@@QAE@XZ
_TEXT	SEGMENT
??0cpu_perf_t@@QAE@XZ PROC				; cpu_perf_t::cpu_perf_t, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], -1
	lea	eax, DWORD PTR [ecx+64]
	mov	DWORD PTR [ecx+4], -1
	mov	edx, 64					; 00000040H
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+32], 0
	mov	BYTE PTR [ecx+36], 1
	mov	DWORD PTR [ecx+40], 0
	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+52], 0
	mov	DWORD PTR [ecx+56], 0
	npad	3
$LL7@cpu_perf_t:
	mov	DWORD PTR [eax], 0
	lea	eax, DWORD PTR [eax+56]
	mov	DWORD PTR [eax-52], 0
	mov	DWORD PTR [eax-48], 0
	mov	DWORD PTR [eax-44], 0
	mov	DWORD PTR [eax-40], 0
	mov	DWORD PTR [eax-36], 0
	mov	DWORD PTR [eax-32], 0
	mov	DWORD PTR [eax-28], 0
	mov	DWORD PTR [eax-24], 0
	mov	DWORD PTR [eax-20], 0
	mov	DWORD PTR [eax-16], 0
	mov	DWORD PTR [eax-12], 0
	mov	DWORD PTR [eax-8], 0
	sub	edx, 1
	jne	SHORT $LL7@cpu_perf_t
	mov	DWORD PTR [ecx+3648], edx
	mov	eax, ecx
	ret	0
??0cpu_perf_t@@QAE@XZ ENDP				; cpu_perf_t::cpu_perf_t
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0cpu_stat_s@cpu_perf_t@@QAE@XZ
_TEXT	SEGMENT
??0cpu_stat_s@cpu_perf_t@@QAE@XZ PROC			; cpu_perf_t::cpu_stat_s::cpu_stat_s, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+40], 0
	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR [ecx+48], 0
	ret	0
??0cpu_stat_s@cpu_perf_t@@QAE@XZ ENDP			; cpu_perf_t::cpu_stat_s::cpu_stat_s
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0WMI_refresh_thread_t@@QAE@XZ
_TEXT	SEGMENT
??0WMI_refresh_thread_t@@QAE@XZ PROC			; WMI_refresh_thread_t::WMI_refresh_thread_t, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], -1
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], -1
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+32], 0
	mov	BYTE PTR [ecx+36], 1
	ret	0
??0WMI_refresh_thread_t@@QAE@XZ ENDP			; WMI_refresh_thread_t::WMI_refresh_thread_t
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
_TEXT	SEGMENT
_current_io$ = -104					; size = 48
_update_time$ = -56					; size = 16
_dOC$1$ = -48						; size = 8
_dWC$1$ = -40						; size = 8
_dRC$1$ = -32						; size = 8
tv374 = -24						; size = 8
tv369 = -16						; size = 8
tv364 = -8						; size = 8
_update_ftime$ = -8					; size = 8
_ioc$ = 8						; size = 4
_update$ = 12						; size = 8
?SK_CountIO@@YAXAAUio_perf_t@@N@Z PROC			; SK_CountIO

; 42   : {

	npad	2
	push	ebp
	mov	ebp, esp

; 43   :   static HANDLE hProc = GetCurrentProcess ();

	mov	eax, DWORD PTR fs:__tls_array
	sub	esp, 104				; 00000068H
	mov	ecx, DWORD PTR __tls_index
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ?$TSS0@?1??SK_CountIO@@YAXAAUio_perf_t@@N@Z@4HA
	cmp	eax, DWORD PTR __Init_thread_epoch[ecx]
	jg	$LN6@SK_CountIO
$LN2@SK_CountIO:
	push	ebx
	push	esi

; 44   : 
; 45   :   if (ioc.init == false)

	mov	esi, DWORD PTR _ioc$[ebp]
	push	edi
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN3@SK_CountIO

; 46   :   {
; 47   :     memset (&ioc, 0, sizeof (io_perf_t));

	push	168					; 000000a8H
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 48   :     ioc.init = true;

	mov	BYTE PTR [esi], 1
$LN3@SK_CountIO:

; 49   :   }
; 50   : 
; 51   :   SYSTEMTIME     update_time;
; 52   :   FILETIME       update_ftime;
; 53   :   ULARGE_INTEGER update_ul;
; 54   : 
; 55   :   IO_COUNTERS current_io;
; 56   : 
; 57   :   GetProcessIoCounters (hProc, &current_io);

	lea	eax, DWORD PTR _current_io$[ebp]
	push	eax
	push	DWORD PTR ?hProc@?1??SK_CountIO@@YAXAAUio_perf_t@@N@Z@4PAXA
	call	DWORD PTR __imp__GetProcessIoCounters@8

; 58   :   GetSystemTime        (&update_time);

	lea	eax, DWORD PTR _update_time$[ebp]
	push	eax
	call	DWORD PTR __imp__GetSystemTime@4

; 59   :   SystemTimeToFileTime (&update_time, &update_ftime);

	lea	eax, DWORD PTR _update_ftime$[ebp]
	push	eax
	lea	eax, DWORD PTR _update_time$[ebp]
	push	eax
	call	DWORD PTR __imp__SystemTimeToFileTime@8

; 60   : 
; 61   :   update_ul.HighPart = update_ftime.dwHighDateTime;
; 62   :   update_ul.LowPart  = update_ftime.dwLowDateTime;

	mov	ebx, DWORD PTR _update_ftime$[ebp]

; 63   : 
; 64   :   ioc.dt += update_ul.QuadPart - ioc.last_update.QuadPart;

	mov	ecx, ebx
	sub	ecx, DWORD PTR [esi+8]
	mov	edi, DWORD PTR _update_ftime$[ebp+4]
	mov	eax, edi
	sbb	eax, DWORD PTR [esi+12]
	add	DWORD PTR [esi+64], ecx

; 65   : 
; 66   :   ioc.accum.ReadTransferCount +=

	mov	ecx, DWORD PTR _current_io$[ebp+24]
	adc	DWORD PTR [esi+68], eax
	sub	ecx, DWORD PTR [esi+96]
	mov	eax, DWORD PTR _current_io$[ebp+28]
	sbb	eax, DWORD PTR [esi+100]
	add	DWORD PTR [esi+40], ecx

; 67   :     current_io.ReadTransferCount - ioc.last_counter.ReadTransferCount;
; 68   :   ioc.accum.WriteTransferCount +=

	mov	ecx, DWORD PTR _current_io$[ebp+32]
	adc	DWORD PTR [esi+44], eax
	sub	ecx, DWORD PTR [esi+104]
	mov	eax, DWORD PTR _current_io$[ebp+36]
	sbb	eax, DWORD PTR [esi+108]
	add	DWORD PTR [esi+48], ecx

; 69   :     current_io.WriteTransferCount - ioc.last_counter.WriteTransferCount;
; 70   :   ioc.accum.OtherTransferCount +=

	mov	ecx, DWORD PTR _current_io$[ebp+40]
	adc	DWORD PTR [esi+52], eax
	sub	ecx, DWORD PTR [esi+112]
	mov	eax, DWORD PTR _current_io$[ebp+44]
	sbb	eax, DWORD PTR [esi+116]
	add	DWORD PTR [esi+56], ecx

; 71   :     current_io.OtherTransferCount - ioc.last_counter.OtherTransferCount;
; 72   : 
; 73   :   ioc.accum.ReadOperationCount +=

	mov	ecx, DWORD PTR _current_io$[ebp]
	adc	DWORD PTR [esi+60], eax
	sub	ecx, DWORD PTR [esi+72]
	mov	eax, DWORD PTR _current_io$[ebp+4]
	sbb	eax, DWORD PTR [esi+76]
	add	DWORD PTR [esi+16], ecx

; 74   :     current_io.ReadOperationCount - ioc.last_counter.ReadOperationCount;
; 75   :   ioc.accum.WriteOperationCount +=

	mov	ecx, DWORD PTR _current_io$[ebp+8]
	adc	DWORD PTR [esi+20], eax
	sub	ecx, DWORD PTR [esi+80]
	mov	eax, DWORD PTR _current_io$[ebp+12]
	sbb	eax, DWORD PTR [esi+84]
	add	DWORD PTR [esi+24], ecx

; 76   :     current_io.WriteOperationCount - ioc.last_counter.WriteOperationCount;
; 77   :   ioc.accum.OtherOperationCount +=

	mov	ecx, DWORD PTR _current_io$[ebp+16]
	adc	DWORD PTR [esi+28], eax
	sub	ecx, DWORD PTR [esi+88]
	mov	eax, DWORD PTR _current_io$[ebp+20]
	sbb	eax, DWORD PTR [esi+92]
	add	DWORD PTR [esi+32], ecx

; 81   :   auto dWB = static_cast <double> (ioc.accum.WriteTransferCount);

	mov	edx, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [esi+48]
	adc	DWORD PTR [esi+36], eax
	call	__ultod3

; 82   :   auto dOB = static_cast <double> (ioc.accum.OtherTransferCount);

	mov	edx, DWORD PTR [esi+60]
	mov	ecx, DWORD PTR [esi+56]
	movsd	QWORD PTR tv369[ebp], xmm0
	call	__ultod3

; 83   : 
; 84   :   auto dRC = static_cast <double> (ioc.accum.ReadOperationCount);

	mov	edx, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [esi+16]
	movsd	QWORD PTR tv374[ebp], xmm0
	call	__ultod3

; 85   :   auto dWC = static_cast <double> (ioc.accum.WriteOperationCount);

	mov	edx, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [esi+24]
	movsd	QWORD PTR _dRC$1$[ebp], xmm0
	call	__ultod3

; 86   :   auto dOC = static_cast <double> (ioc.accum.OtherOperationCount);

	mov	edx, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [esi+32]
	movsd	QWORD PTR _dWC$1$[ebp], xmm0
	call	__ultod3

; 87   : 
; 88   :   double& read_mb_sec   = ioc.read_mb_sec;
; 89   :   double& write_mb_sec  = ioc.write_mb_sec;
; 90   :   double& other_mb_sec  = ioc.other_mb_sec;
; 91   : 
; 92   :   double& read_iop_sec  = ioc.read_iop_sec;
; 93   :   double& write_iop_sec = ioc.write_iop_sec;
; 94   :   double& other_iop_sec = ioc.other_iop_sec;
; 95   : 
; 96   :   if (ioc.dt >= update)

	mov	edx, DWORD PTR [esi+68]
	mov	ecx, DWORD PTR [esi+64]
	movsd	QWORD PTR _dOC$1$[ebp], xmm0
	call	__ultod3
	comisd	xmm0, QWORD PTR _update$[ebp]
	movsd	QWORD PTR tv364[ebp], xmm0
	jb	$LN4@SK_CountIO

; 78   :     current_io.OtherOperationCount - ioc.last_counter.OtherOperationCount;
; 79   : 
; 80   :   auto dRB = static_cast <double> (ioc.accum.ReadTransferCount);

	mov	edx, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR [esi+40]
	call	__ultod3

; 97   :   {
; 98   :     read_mb_sec  = (

	movsd	xmm1, QWORD PTR __real@416312d000000000
	divsd	xmm1, QWORD PTR tv364[ebp]
	mulsd	xmm0, QWORD PTR __real@3ea0000000000000
	mulsd	xmm0, xmm1
	movsd	xmm1, QWORD PTR [esi+120]
	mulsd	xmm1, QWORD PTR __real@3fe0000000000000
	addsd	xmm0, xmm1
	movsd	QWORD PTR [esi+120], xmm0

; 99   :       read_mb_sec + ((dRB / 1048576.0) / (1.0e-7 * static_cast <double> (ioc.dt)))
; 100  :                    ) / 2.0;
; 101  :     write_mb_sec = (

	mov	edx, DWORD PTR [esi+68]
	mov	ecx, DWORD PTR [esi+64]
	call	__ultod3
	movsd	xmm1, QWORD PTR __real@416312d000000000
	divsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR tv369[ebp]
	mulsd	xmm0, QWORD PTR __real@3ea0000000000000
	mulsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR [esi+128]
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	addsd	xmm1, xmm0
	movsd	QWORD PTR [esi+128], xmm1

; 102  :       write_mb_sec + ((dWB / 1048576.0) / (1.0e-7 * static_cast <double> (ioc.dt)))
; 103  :                    ) / 2.0;
; 104  :     other_mb_sec = (

	mov	edx, DWORD PTR [esi+68]
	mov	ecx, DWORD PTR [esi+64]
	call	__ultod3
	movsd	xmm1, QWORD PTR __real@416312d000000000
	divsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR tv374[ebp]
	mulsd	xmm0, QWORD PTR __real@3ea0000000000000
	mulsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR [esi+136]
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	addsd	xmm1, xmm0
	movsd	QWORD PTR [esi+136], xmm1

; 105  :       other_mb_sec + ((dOB / 1048576.0) / (1.0e-7 * static_cast <double> (ioc.dt)))
; 106  :                    ) / 2.0;
; 107  : 
; 108  :     read_iop_sec  = (read_iop_sec  + (dRC / (1.0e-7 * static_cast <double> (ioc.dt)))) / 2.0;

	mov	edx, DWORD PTR [esi+68]
	mov	ecx, DWORD PTR [esi+64]
	call	__ultod3
	movsd	xmm1, QWORD PTR __real@416312d000000000
	divsd	xmm1, xmm0
	mulsd	xmm1, QWORD PTR _dRC$1$[ebp]
	addsd	xmm1, QWORD PTR [esi+144]
	mulsd	xmm1, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR [esi+144], xmm1

; 109  :     write_iop_sec = (write_iop_sec + (dWC / (1.0e-7 * static_cast <double> (ioc.dt)))) / 2.0;

	mov	edx, DWORD PTR [esi+68]
	mov	ecx, DWORD PTR [esi+64]
	call	__ultod3
	movsd	xmm1, QWORD PTR __real@416312d000000000
	divsd	xmm1, xmm0
	mulsd	xmm1, QWORD PTR _dWC$1$[ebp]
	addsd	xmm1, QWORD PTR [esi+152]
	mulsd	xmm1, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR [esi+152], xmm1

; 110  :     other_iop_sec = (other_iop_sec + (dOC / (1.0e-7 * static_cast <double> (ioc.dt)))) / 2.0;

	mov	edx, DWORD PTR [esi+68]
	mov	ecx, DWORD PTR [esi+64]
	call	__ultod3
	movsd	xmm1, QWORD PTR __real@416312d000000000
	divsd	xmm1, xmm0
	mulsd	xmm1, QWORD PTR _dOC$1$[ebp]
	addsd	xmm1, QWORD PTR [esi+160]
	mulsd	xmm1, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR [esi+160], xmm1

; 111  : 
; 112  :     ioc.accum.ReadTransferCount   = 0;

	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0

; 113  :     ioc.accum.WriteTransferCount  = 0;

	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+52], 0

; 114  :     ioc.accum.OtherTransferCount  = 0;

	mov	DWORD PTR [esi+56], 0
	mov	DWORD PTR [esi+60], 0

; 115  : 
; 116  :     ioc.accum.ReadOperationCount  = 0;

	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0

; 117  :     ioc.accum.WriteOperationCount = 0;

	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0

; 118  :     ioc.accum.OtherOperationCount = 0;

	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0

; 119  : 
; 120  :     ioc.dt = 0;

	mov	DWORD PTR [esi+64], 0
	mov	DWORD PTR [esi+68], 0
$LN4@SK_CountIO:

; 121  :   }
; 122  : 
; 123  :   ioc.last_update.QuadPart = update_ul.QuadPart;
; 124  :   memcpy (&ioc.last_counter, &current_io, sizeof (IO_COUNTERS));

	movups	xmm0, XMMWORD PTR _current_io$[ebp]
	mov	DWORD PTR [esi+12], edi
	pop	edi
	movups	XMMWORD PTR [esi+72], xmm0
	mov	DWORD PTR [esi+8], ebx
	movups	xmm0, XMMWORD PTR _current_io$[ebp+16]
	movups	XMMWORD PTR [esi+88], xmm0
	movups	xmm0, XMMWORD PTR _current_io$[ebp+32]
	movups	XMMWORD PTR [esi+104], xmm0
	pop	esi
	pop	ebx

; 125  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@SK_CountIO:

; 43   :   static HANDLE hProc = GetCurrentProcess ();

	push	OFFSET ?$TSS0@?1??SK_CountIO@@YAXAAUio_perf_t@@N@Z@4HA
	call	__Init_thread_header
	add	esp, 4
	cmp	DWORD PTR ?$TSS0@?1??SK_CountIO@@YAXAAUio_perf_t@@N@Z@4HA, -1
	jne	$LN2@SK_CountIO
	call	DWORD PTR __imp__GetCurrentProcess@0
	push	OFFSET ?$TSS0@?1??SK_CountIO@@YAXAAUio_perf_t@@N@Z@4HA
	mov	DWORD PTR ?hProc@?1??SK_CountIO@@YAXAAUio_perf_t@@N@Z@4PAXA, eax
	call	__Init_thread_footer
	add	esp, 4
	jmp	$LN2@SK_CountIO
?SK_CountIO@@YAXAAUio_perf_t@@N@Z ENDP			; SK_CountIO
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h
;	COMDAT ??1SK_AutoCOMInit@@QAE@XZ
_TEXT	SEGMENT
??1SK_AutoCOMInit@@QAE@XZ PROC				; SK_AutoCOMInit::~SK_AutoCOMInit, COMDAT
; _this$ = ecx

; 52   :     if (success)

	cmp	BYTE PTR [ecx], 0
	je	SHORT $LN2@SK_AutoCOM

; 53   :       CoUninitialize ();

	jmp	DWORD PTR __imp__CoUninitialize@0
$LN2@SK_AutoCOM:

; 54   :   }

	ret	0
??1SK_AutoCOMInit@@QAE@XZ ENDP				; SK_AutoCOMInit::~SK_AutoCOMInit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h
;	COMDAT ??0SK_AutoCOMInit@@QAE@XZ
_TEXT	SEGMENT
??0SK_AutoCOMInit@@QAE@XZ PROC				; SK_AutoCOMInit::SK_AutoCOMInit, COMDAT
; _this$ = ecx

; 44   :   SK_AutoCOMInit (void) {

	npad	2
	push	esi
	mov	esi, ecx

; 45   :     HRESULT hr = CoInitializeEx (NULL, COINIT_MULTITHREADED);

	push	0
	push	0

; 50   : 
; 51   :   ~SK_AutoCOMInit (void) {
; 52   :     if (success)
; 53   :       CoUninitialize ();
; 54   :   }
; 55   : 
; 56   : private:
; 57   :   bool success = false;

	mov	BYTE PTR [esi], 0
	call	DWORD PTR __imp__CoInitializeEx@8
	test	eax, eax
	mov	eax, esi
	js	SHORT $LN2@SK_AutoCOM

; 46   : 
; 47   :     if (SUCCEEDED (hr))
; 48   :       success = true;

	mov	BYTE PTR [esi], 1
$LN2@SK_AutoCOM:
	pop	esi

; 49   :   }

	ret	0
??0SK_AutoCOMInit@@QAE@XZ ENDP				; SK_AutoCOMInit::SK_AutoCOMInit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
_TEXT	SEGMENT
?SK_ShutdownWMI@@YAXXZ PROC				; SK_ShutdownWMI

; 391  :   if (InterlockedCompareExchange (&COM::base.wmi.init, 0, 1))

	xor	ecx, ecx
	mov	edx, OFFSET ?base@COM@@3UBase@1@A+4
	mov	eax, 1
	lock	 cmpxchg DWORD PTR [edx], ecx
	test	eax, eax
	je	SHORT $LN3@SK_Shutdow

; 392  :   {
; 393  :     HANDLE hServerThread = 
; 394  :      ReadPointerAcquire (&COM::base.wmi.hServerThread);

	push	esi
	mov	esi, DWORD PTR ?base@COM@@3UBase@1@A+20

; 395  : 
; 396  :     SetEvent (COM::base.wmi.hShutdownServer);

	push	DWORD PTR ?base@COM@@3UBase@1@A+24
	call	DWORD PTR __imp__SetEvent@4

; 397  : 
; 398  :     if (hServerThread)

	test	esi, esi
	je	SHORT $LN15@SK_Shutdow
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 5265 :     return (PVOID)InterlockedExchange((LONG volatile *) Destination,

	xor	eax, eax
	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+20
	xchg	DWORD PTR [ecx], eax
$LN15@SK_Shutdow:

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?base@COM@@3UBase@1@A+4
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 403  :     while (ReadAcquire (&COM::base.wmi.init))

	test	eax, eax
	je	SHORT $LN19@SK_Shutdow
	mov	esi, DWORD PTR __imp__SleepEx@8
$LL2@SK_Shutdow:

; 404  :       SleepEx (333, TRUE);

	push	1
	push	333					; 0000014dH
	call	esi
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?base@COM@@3UBase@1@A+4
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 403  :     while (ReadAcquire (&COM::base.wmi.init))

	test	eax, eax
	jne	SHORT $LL2@SK_Shutdow
$LN19@SK_Shutdow:
	pop	esi
$LN3@SK_Shutdow:

; 405  :   }
; 406  : }

	ret	0
?SK_ShutdownWMI@@YAXXZ ENDP				; SK_ShutdownWMI
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
;	COMDAT _RtlSecureZeroMemory
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory PROC				; COMDAT

; 17787: {

	npad	2
	push	ebp
	mov	ebp, esp

; 17788:     volatile char *vptr = (volatile char *)ptr;
; 17789: 
; 17790: #if defined(_M_AMD64)
; 17791: 
; 17792:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);
; 17793: 
; 17794: #else
; 17795: 
; 17796:     while (cnt) {

	mov	edx, DWORD PTR _cnt$[ebp]
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	ecx, eax
	test	edx, edx
	je	SHORT $LN3@RtlSecureZ
$LL2@RtlSecureZ:

; 17797: 
; 17798: #if !defined(_M_CEE) && defined(_M_ARM)
; 17799: 
; 17800:         __iso_volatile_store8(vptr, 0);
; 17801: 
; 17802: #else
; 17803: 
; 17804:         *vptr = 0;

	mov	BYTE PTR [ecx], 0

; 17805: 
; 17806: #endif
; 17807: 
; 17808:         vptr++;

	lea	ecx, DWORD PTR [ecx+1]

; 17809:         cnt--;

	sub	edx, 1
	jne	SHORT $LL2@RtlSecureZ
$LN3@RtlSecureZ:

; 17810:     }
; 17811: 
; 17812: #endif // _M_AMD64
; 17813: 
; 17814:     return ptr;
; 17815: }

	pop	ebp
	ret	0
_RtlSecureZeroMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
;	COMDAT _ReadPointerAcquire
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_ReadPointerAcquire PROC				; COMDAT

; 8591 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	eax, DWORD PTR [eax]

; 8592 : 
; 8593 :     return (PVOID)ReadAcquire((PLONG)Source);
; 8594 : }

	pop	ebp
	ret	0
_ReadPointerAcquire ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
;	COMDAT _ReadAcquire
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_ReadAcquire PROC					; COMDAT

; 8059 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 8060 : 
; 8061 :     LONG Value;
; 8062 : 
; 8063 :     Value = *Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	eax, DWORD PTR [eax]

; 8064 :     return Value;
; 8065 : }

	pop	ebp
	ret	0
_ReadAcquire ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
;	COMDAT __InlineInterlockedCompareExchangePointer
_TEXT	SEGMENT
_Destination$ = 8					; size = 4
_ExChange$ = 12						; size = 4
_Comperand$ = 16					; size = 4
__InlineInterlockedCompareExchangePointer PROC		; COMDAT

; 5285 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 5286 :     return (PVOID)InterlockedCompareExchange((LONG volatile *) Destination,

	mov	edx, DWORD PTR _ExChange$[ebp]
	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	eax, DWORD PTR _Comperand$[ebp]
	lock	 cmpxchg DWORD PTR [ecx], edx

; 5287 :                                              (LONG) ExChange,
; 5288 :                                              (LONG) Comperand);
; 5289 : }

	pop	ebp
	ret	0
__InlineInterlockedCompareExchangePointer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
;	COMDAT __InlineInterlockedExchangePointer
_TEXT	SEGMENT
_Destination$ = 8					; size = 4
_Value$ = 12						; size = 4
__InlineInterlockedExchangePointer PROC			; COMDAT

; 5264 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 5265 :     return (PVOID)InterlockedExchange((LONG volatile *) Destination,

	mov	eax, DWORD PTR _Value$[ebp]
	mov	ecx, DWORD PTR _Destination$[ebp]
	xchg	DWORD PTR [ecx], eax

; 5266 :                                       (LONG) Value);
; 5267 : }

	pop	ebp
	ret	0
__InlineInterlockedExchangePointer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstring.h
;	COMDAT ?wcsrchr@@YAPA_WPA_W_W@Z
_TEXT	SEGMENT
__String$ = 8						; size = 4
__C$ = 12						; size = 2
?wcsrchr@@YAPA_WPA_W_W@Z PROC				; wcsrchr, COMDAT

; 545  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 547  :     }

	pop	ebp

; 546  :         return const_cast<wchar_t*>(wcsrchr(static_cast<wchar_t const*>(_String), _C));

	jmp	DWORD PTR __imp__wcsrchr
?wcsrchr@@YAPA_WPA_W_W@Z ENDP				; wcsrchr
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___n$[ebp]
	test	esi, esi
	je	SHORT $LN6@vector
	push	ebx
	mov	ebx, DWORD PTR ___f$[ebp]
	push	edi
	mov	edi, DWORD PTR ___t$[ebp]
$LL2@vector:
	mov	ecx, edi
	call	ebx
	add	edi, DWORD PTR ___s$[ebp]
	sub	esi, 1
	jne	SHORT $LL2@vector
	pop	edi
	pop	ebx
$LN6@vector:
	pop	esi
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
