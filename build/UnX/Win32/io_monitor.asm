; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	C:\Users\andon\Source\Repos\SpecialK\src\io_monitor.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?hShutdownWMI@@3PAXA				; hShutdownWMI
PUBLIC	?perfmon@@3Uthread_events@@A			; perfmon
_BSS	SEGMENT
?hShutdownWMI@@3PAXA DD 01H DUP (?)			; hShutdownWMI
?perfmon@@3Uthread_events@@A DB 060H DUP (?)		; perfmon
_BSS	ENDS
CONST	SEGMENT
$SG165888 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165889 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 'd', 00H, ' ', 00H, 'Q', 00H, 'u', 00H, 'a', 00H, 'd', 00H
	DB	'-', 00H, 'W', 00H, 'o', 00H, 'r', 00H, 'd', 00H, ' ', 00H, 'P'
	DB	00H, 'r', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 't', 00H
	DB	'y', 00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':', 00H, '%'
	DB	00H, 'd', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG165892 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165893 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 'd', 00H, ' ', 00H, 'Q', 00H, 'u', 00H, 'a', 00H, 'd', 00H
	DB	'-', 00H, 'W', 00H, 'o', 00H, 'r', 00H, 'd', 00H, ' ', 00H, 'P'
	DB	00H, 'r', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 't', 00H
	DB	'y', 00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':', 00H, '%'
	DB	00H, 'd', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG165896 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165897 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 'd', 00H, ' ', 00H, 'Q', 00H, 'u', 00H, 'a', 00H, 'd', 00H
	DB	'-', 00H, 'W', 00H, 'o', 00H, 'r', 00H, 'd', 00H, ' ', 00H, 'P'
	DB	00H, 'r', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 't', 00H
	DB	'y', 00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':', 00H, '%'
	DB	00H, 'd', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG165900 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165901 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 'd', 00H, ' ', 00H, 'Q', 00H, 'u', 00H, 'a', 00H, 'd', 00H
	DB	'-', 00H, 'W', 00H, 'o', 00H, 'r', 00H, 'd', 00H, ' ', 00H, 'P'
	DB	00H, 'r', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 't', 00H
	DB	'y', 00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':', 00H, '%'
	DB	00H, 'd', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG165904 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165905 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 'd', 00H, ' ', 00H, 'Q', 00H, 'u', 00H, 'a', 00H, 'd', 00H
	DB	'-', 00H, 'W', 00H, 'o', 00H, 'r', 00H, 'd', 00H, ' ', 00H, 'P'
	DB	00H, 'r', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 't', 00H
	DB	'y', 00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':', 00H, '%'
	DB	00H, 'd', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG166038 DB	'W', 00H, 'i', 00H, 'n', 00H, '3', 00H, '2', 00H, '_', 00H
	DB	'P', 00H, 'e', 00H, 'r', 00H, 'f', 00H, 'F', 00H, 'o', 00H, 'r'
	DB	00H, 'm', 00H, 'a', 00H, 't', 00H, 't', 00H, 'e', 00H, 'd', 00H
	DB	'D', 00H, 'a', 00H, 't', 00H, 'a', 00H, '_', 00H, 'P', 00H, 'e'
	DB	00H, 'r', 00H, 'f', 00H, 'D', 00H, 'i', 00H, 's', 00H, 'k', 00H
	DB	'_', 00H, 'L', 00H, 'o', 00H, 'g', 00H, 'i', 00H, 'c', 00H, 'a'
	DB	00H, 'l', 00H, 'D', 00H, 'i', 00H, 's', 00H, 'k', 00H, 00H, 00H
	ORG $+2
$SG166041 DB	'D', 00H, 'i', 00H, 's', 00H, 'k', 00H, 'M', 00H, 'o', 00H
	DB	'n', 00H, ' ', 00H, 'S', 00H, 'h', 00H, 'u', 00H, 't', 00H, 'd'
	DB	00H, 'o', 00H, 'w', 00H, 'n', 00H, ' ', 00H, 'S', 00H, 'i', 00H
	DB	'g', 00H, 'n', 00H, 'a', 00H, 'l', 00H, 00H, 00H
$SG166059 DB	'N', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG166039 DB	'W', 00H, 'i', 00H, 'n', 00H, '3', 00H, '2', 00H, '_', 00H
	DB	'P', 00H, 'e', 00H, 'r', 00H, 'f', 00H, 'F', 00H, 'o', 00H, 'r'
	DB	00H, 'm', 00H, 'a', 00H, 't', 00H, 't', 00H, 'e', 00H, 'd', 00H
	DB	'D', 00H, 'a', 00H, 't', 00H, 'a', 00H, '_', 00H, 'P', 00H, 'e'
	DB	00H, 'r', 00H, 'f', 00H, 'D', 00H, 'i', 00H, 's', 00H, 'k', 00H
	DB	'_', 00H, 'P', 00H, 'h', 00H, 'y', 00H, 's', 00H, 'i', 00H, 'c'
	DB	00H, 'a', 00H, 'l', 00H, 'D', 00H, 'i', 00H, 's', 00H, 'k', 00H
	DB	00H, 00H
$SG166068 DB	'D', 00H, 'i', 00H, 's', 00H, 'k', 00H, 'W', 00H, 'r', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e'
	DB	00H, 's', 00H, 'P', 00H, 'e', 00H, 'r', 00H, 'S', 00H, 'e', 00H
	DB	'c', 00H, 00H, 00H
	ORG $+2
$SG166056 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'D', 00H, 'i', 00H, 's', 00H, 'k', 00H, ' ', 00H, 'a', 00H
	DB	'p', 00H, 'E', 00H, 'n', 00H, 'u', 00H, 'm', 00H, 'A', 00H, 'c'
	DB	00H, 'c', 00H, 'e', 00H, 's', 00H, 's', 00H, ' ', 00H, '[', 00H
	DB	'0', 00H, ']', 00H, ' ', 00H, '=', 00H, ' ', 00H, 'n', 00H, 'u'
	DB	00H, 'l', 00H, 'l', 00H, 'p', 00H, 't', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG166062 DB	'D', 00H, 'i', 00H, 's', 00H, 'k', 00H, 'B', 00H, 'y', 00H
	DB	't', 00H, 'e', 00H, 's', 00H, 'P', 00H, 'e', 00H, 'r', 00H, 'S'
	DB	00H, 'e', 00H, 'c', 00H, 00H, 00H
$SG166065 DB	'D', 00H, 'i', 00H, 's', 00H, 'k', 00H, 'R', 00H, 'e', 00H
	DB	'a', 00H, 'd', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's'
	DB	00H, 'P', 00H, 'e', 00H, 'r', 00H, 'S', 00H, 'e', 00H, 'c', 00H
	DB	00H, 00H
$SG166071 DB	'P', 00H, 'e', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, 'D', 00H, 'i', 00H, 's', 00H, 'k', 00H, 'T', 00H, 'i'
	DB	00H, 'm', 00H, 'e', 00H, 00H, 00H
$SG166074 DB	'P', 00H, 'e', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, 'D', 00H, 'i', 00H, 's', 00H, 'k', 00H, 'R', 00H, 'e'
	DB	00H, 'a', 00H, 'd', 00H, 'T', 00H, 'i', 00H, 'm', 00H, 'e', 00H
	DB	00H, 00H
$SG166077 DB	'P', 00H, 'e', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, 'D', 00H, 'i', 00H, 's', 00H, 'k', 00H, 'W', 00H, 'r'
	DB	00H, 'i', 00H, 't', 00H, 'e', 00H, 'T', 00H, 'i', 00H, 'm', 00H
	DB	'e', 00H, 00H, 00H
	ORG $+2
$SG166080 DB	'P', 00H, 'e', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, 'I', 00H, 'd', 00H, 'l', 00H, 'e', 00H, 'T', 00H, 'i'
	DB	00H, 'm', 00H, 'e', 00H, 00H, 00H
$SG166098 DB	' ', 00H
	ORG $+2
$SG166100 DB	'Total', 00H
	ORG $+2
$SG166201 DB	'N', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG166178 DB	'W', 00H, 'i', 00H, 'n', 00H, '3', 00H, '2', 00H, '_', 00H
	DB	'P', 00H, 'e', 00H, 'r', 00H, 'f', 00H, 'R', 00H, 'a', 00H, 'w'
	DB	00H, 'D', 00H, 'a', 00H, 't', 00H, 'a', 00H, '_', 00H, 'P', 00H
	DB	'e', 00H, 'r', 00H, 'f', 00H, 'O', 00H, 'S', 00H, '_', 00H, 'P'
	DB	00H, 'a', 00H, 'g', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 'F', 00H
	DB	'i', 00H, 'l', 00H, 'e', 00H, 00H, 00H
$SG166180 DB	'P', 00H, 'a', 00H, 'g', 00H, 'e', 00H, 'f', 00H, 'i', 00H
	DB	'l', 00H, 'e', 00H, ' ', 00H, 'M', 00H, 'o', 00H, 'n', 00H, 'i'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'S', 00H, 'h', 00H
	DB	'u', 00H, 't', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, ' '
	DB	00H, 'S', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'a', 00H, 'l', 00H
	DB	00H, 00H
	ORG $+2
$SG166204 DB	'P', 00H, 'e', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, 'U', 00H, 's', 00H, 'a', 00H, 'g', 00H, 'e', 00H, 00H
	DB	00H
	ORG $+2
$SG166195 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'N', 00H, 'o', 00H, ' ', 00H, 'p', 00H, 'a', 00H, 'g', 00H
	DB	'e', 00H, 'f', 00H, 'i', 00H, 'l', 00H, 'e', 00H, ' ', 00H, 'e'
	DB	00H, 'x', 00H, 'i', 00H, 's', 00H, 't', 00H, 's', 00H, 00H, 00H
$SG166198 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'P', 00H, 'a', 00H, 'g', 00H, 'e', 00H, 'f', 00H, 'i', 00H
	DB	'l', 00H, 'e', 00H, ' ', 00H, 'a', 00H, 'p', 00H, 'E', 00H, 'n'
	DB	00H, 'u', 00H, 'm', 00H, 'A', 00H, 'c', 00H, 'c', 00H, 'e', 00H
	DB	's', 00H, 's', 00H, ' ', 00H, '[', 00H, '0', 00H, ']', 00H, ' '
	DB	00H, '=', 00H, ' ', 00H, 'n', 00H, 'u', 00H, 'l', 00H, 'l', 00H
	DB	'p', 00H, 't', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG166207 DB	'P', 00H, 'e', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, 'U', 00H, 's', 00H, 'a', 00H, 'g', 00H, 'e', 00H, 'P'
	DB	00H, 'e', 00H, 'a', 00H, 'k', 00H, 00H, 00H
	ORG $+2
$SG166210 DB	'P', 00H, 'e', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, 'U', 00H, 's', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '_'
	DB	00H, 'B', 00H, 'a', 00H, 's', 00H, 'e', 00H, 00H, 00H
$SG166220 DB	' ', 00H
	ORG $+2
$SG166222 DB	'Total', 00H
	ORG $+2
$SG166362 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG166363 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'c', 00H, 'r', 00H, 'e'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 'R', 00H, 'e', 00H
	DB	'f', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'h', 00H, 'e', 00H, 'r'
	DB	00H, ' ', 00H, 'I', 00H, 'n', 00H, 's', 00H, 't', 00H, 'a', 00H
	DB	'n', 00H, 'c', 00H, 'e', 00H, ' ', 00H, '(', 00H, '%', 00H, 's'
	DB	00H, ':', 00H, '%', 00H, 'd', 00H, ')', 00H, ' ', 00H, '-', 00H
	DB	'-', 00H, ' ', 00H, '0', 00H, 'x', 00H, '%', 00H, 'X', 00H, 00H
	DB	00H
	ORG $+2
$SG166380 DB	'P', 00H, 'a', 00H, 'g', 00H, 'e', 00H, 'F', 00H, 'i', 00H
	DB	'l', 00H, 'e', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's'
	DB	00H, 00H, 00H
$SG166366 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG166367 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'Q', 00H, 'u', 00H, 'e'
	DB	00H, 'r', 00H, 'y', 00H, ' ', 00H, 'R', 00H, 'e', 00H, 'f', 00H
	DB	'r', 00H, 'e', 00H, 's', 00H, 'h', 00H, 'e', 00H, 'r', 00H, ' '
	DB	00H, 'I', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'f', 00H
	DB	'a', 00H, 'c', 00H, 'e', 00H, ' ', 00H, '(', 00H, '%', 00H, 's'
	DB	00H, ':', 00H, '%', 00H, 'd', 00H, ')', 00H, ' ', 00H, '-', 00H
	DB	'-', 00H, ' ', 00H, '0', 00H, 'x', 00H, '%', 00H, 'X', 00H, 00H
	DB	00H
	ORG $+2
$SG166383 DB	'P', 00H, 'a', 00H, 'g', 00H, 'e', 00H, 'F', 00H, 'i', 00H
	DB	'l', 00H, 'e', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's'
	DB	00H, 'P', 00H, 'e', 00H, 'a', 00H, 'k', 00H, 00H, 00H
$SG166370 DB	'W', 00H, 'i', 00H, 'n', 00H, '3', 00H, '2', 00H, '_', 00H
	DB	'P', 00H, 'e', 00H, 'r', 00H, 'f', 00H, 'F', 00H, 'o', 00H, 'r'
	DB	00H, 'm', 00H, 'a', 00H, 't', 00H, 't', 00H, 'e', 00H, 'd', 00H
	DB	'D', 00H, 'a', 00H, 't', 00H, 'a', 00H, '_', 00H, 'P', 00H, 'e'
	DB	00H, 'r', 00H, 'f', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'c', 00H
	DB	'_', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'c', 00H, 'e', 00H, 's'
	DB	00H, 's', 00H, '.', 00H, 'N', 00H, 'a', 00H, 'm', 00H, 'e', 00H
	DB	'=', 00H, '''', 00H, '%', 00H, 'w', 00H, 's', 00H, '''', 00H, 00H
	DB	00H
$SG166372 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG166373 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'A', 00H, 'd', 00H, 'd'
	DB	00H, 'O', 00H, 'b', 00H, 'j', 00H, 'e', 00H, 'c', 00H, 't', 00H
	DB	'B', 00H, 'y', 00H, 'P', 00H, 'a', 00H, 't', 00H, 'h', 00H, ' '
	DB	00H, '(', 00H, '%', 00H, 's', 00H, ':', 00H, '%', 00H, 'd', 00H
	DB	')', 00H, ' ', 00H, '-', 00H, '-', 00H, ' ', 00H, '0', 00H, 'x'
	DB	00H, '%', 00H, 'X', 00H, 00H, 00H
	ORG $+2
$SG166376 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG166377 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'Q', 00H, 'u', 00H, 'e'
	DB	00H, 'r', 00H, 'y', 00H, ' ', 00H, 'W', 00H, 'b', 00H, 'e', 00H
	DB	'm', 00H, 'O', 00H, 'b', 00H, 'j', 00H, 'e', 00H, 'c', 00H, 't'
	DB	00H, 'A', 00H, 'c', 00H, 'c', 00H, 'e', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 'I', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'f'
	DB	00H, 'a', 00H, 'c', 00H, 'e', 00H, ' ', 00H, '(', 00H, '%', 00H
	DB	's', 00H, ':', 00H, '%', 00H, 'd', 00H, ')', 00H, ' ', 00H, '-'
	DB	00H, '-', 00H, ' ', 00H, '0', 00H, 'x', 00H, '%', 00H, 'X', 00H
	DB	00H, 00H
$SG166386 DB	'T', 00H, 'h', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'd', 00H
	DB	'C', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, 00H, 00H
$SG166389 DB	'P', 00H, 'r', 00H, 'i', 00H, 'v', 00H, 'a', 00H, 't', 00H
	DB	'e', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H, 00H
	DB	00H
	ORG $+2
$SG166392 DB	'W', 00H, 'o', 00H, 'r', 00H, 'k', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, 'S', 00H, 'e', 00H, 't', 00H, 'P', 00H, 'e', 00H, 'a'
	DB	00H, 'k', 00H, 00H, 00H
	ORG $+2
$SG166395 DB	'W', 00H, 'o', 00H, 'r', 00H, 'k', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, 'S', 00H, 'e', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG166398 DB	'V', 00H, 'i', 00H, 'r', 00H, 't', 00H, 'u', 00H, 'a', 00H
	DB	'l', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H, 'P'
	DB	00H, 'e', 00H, 'a', 00H, 'k', 00H, 00H, 00H
	ORG $+2
$SG166401 DB	'V', 00H, 'i', 00H, 'r', 00H, 't', 00H, 'u', 00H, 'a', 00H
	DB	'l', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H, 00H
	DB	00H
	ORG $+2
$SG166403 DB	'P', 00H, 'r', 00H, 'o', 00H, 'c', 00H, 'M', 00H, 'o', 00H
	DB	'n', 00H, ' ', 00H, 'S', 00H, 'h', 00H, 'u', 00H, 't', 00H, 'd'
	DB	00H, 'o', 00H, 'w', 00H, 'n', 00H, ' ', 00H, 'S', 00H, 'i', 00H
	DB	'g', 00H, 'n', 00H, 'a', 00H, 'l', 00H, 00H, 00H
$SG165739 DB	'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H, 'S', 00H, 'h', 00H
	DB	'u', 00H, 't', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 00H
	DB	00H
	ORG $+2
$SG165687 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165688 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'c', 00H, 'r', 00H, 'e'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 'W', 00H, 'b', 00H
	DB	'e', 00H, 'm', 00H, ' ', 00H, 'L', 00H, 'o', 00H, 'c', 00H, 'a'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '(', 00H, '%', 00H
	DB	's', 00H, ':', 00H, '%', 00H, 'd', 00H, ')', 00H, ' ', 00H, '-'
	DB	00H, '-', 00H, ' ', 00H, '0', 00H, 'x', 00H, '%', 00H, 'X', 00H
	DB	00H, 00H
	ORG $+2
$SG165690 DB	'\', 00H, '\', 00H, '.', 00H, '\', 00H, 'R', 00H, 'o', 00H
	DB	'o', 00H, 't', 00H, '\', 00H, 'C', 00H, 'I', 00H, 'M', 00H, 'v'
	DB	00H, '2', 00H, 00H, 00H
	ORG $+2
$SG165692 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165693 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'O', 00H, 'u', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'f', 00H
	DB	' ', 00H, 'M', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y'
	DB	00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':', 00H, '%', 00H
	DB	'd', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG165696 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165697 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'u', 00H, 'r', 00H
	DB	'e', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'C', 00H, 'o'
	DB	00H, 'n', 00H, 'n', 00H, 'e', 00H, 'c', 00H, 't', 00H, ' ', 00H
	DB	't', 00H, 'o', 00H, ' ', 00H, 'W', 00H, 'b', 00H, 'e', 00H, 'm'
	DB	00H, ' ', 00H, 'S', 00H, 'e', 00H, 'r', 00H, 'v', 00H, 'e', 00H
	DB	'r', 00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':', 00H, '%'
	DB	00H, 'd', 00H, ')', 00H, ' ', 00H, '-', 00H, '-', 00H, ' ', 00H
	DB	'0', 00H, 'x', 00H, '%', 00H, 'X', 00H, 00H, 00H
	ORG $+2
$SG165702 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165703 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'u', 00H, 'r', 00H
	DB	'e', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 's', 00H, 'e'
	DB	00H, 't', 00H, ' ', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'x', 00H
	DB	'y', 00H, ' ', 00H, 'i', 00H, 'm', 00H, 'p', 00H, 'e', 00H, 'r'
	DB	00H, 's', 00H, 'o', 00H, 'n', 00H, 'a', 00H, 't', 00H, 'i', 00H
	DB	'o', 00H, 'n', 00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':'
	DB	00H, '%', 00H, 'd', 00H, ')', 00H, ' ', 00H, '-', 00H, '-', 00H
	DB	' ', 00H, '0', 00H, 'x', 00H, '%', 00H, 'X', 00H, 00H, 00H
$SG165706 DB	'[', 00H, ' ', 00H, 'S', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'K', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'U', 00H, 'n', 00H, 'l', 00H, 'o', 00H, 'a', 00H, 'd', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'S', 00H, 't', 00H, 'e'
	DB	00H, 'a', 00H, 'm', 00H, ' ', 00H, 'O', 00H, 'v', 00H, 'e', 00H
	DB	'r', 00H, 'l', 00H, 'a', 00H, 'y', 00H, '.', 00H, '.', 00H, '.'
	DB	00H, ' ', 00H, 00H, 00H
	ORG $+2
$SG165707 DB	'd', 00H, 'o', 00H, 'n', 00H, 'e', 00H, '!', 00H, 0aH, 00H
	DB	00H, 00H
	ORG $+2
$SG165860 DB	'P', 00H, 'e', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, 'I', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'r'
	DB	00H, 'u', 00H, 'p', 00H, 't', 00H, 'T', 00H, 'i', 00H, 'm', 00H
	DB	'e', 00H, 00H, 00H
	ORG $+2
$SG165721 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165722 DB	'[', 00H, 'C', 00H, 'O', 00H, 'M', 00H, ' ', 00H, 'S', 00H
	DB	'e', 00H, 'c', 00H, 'u', 00H, 'r', 00H, 'e', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'u', 00H, 'r', 00H
	DB	'e', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'i', 00H, 'n'
	DB	00H, 'i', 00H, 't', 00H, 'i', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, ' ', 00H, 'C', 00H, 'O', 00H, 'M', 00H, ' '
	DB	00H, 'S', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 'r', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':'
	DB	00H, '%', 00H, 'd', 00H, ')', 00H, ' ', 00H, '-', 00H, '-', 00H
	DB	' ', 00H, '0', 00H, 'x', 00H, '%', 00H, 'X', 00H, 00H, 00H
$SG165825 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165826 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'c', 00H, 'r', 00H, 'e'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 'R', 00H, 'e', 00H
	DB	'f', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'h', 00H, 'e', 00H, 'r'
	DB	00H, ' ', 00H, 'I', 00H, 'n', 00H, 's', 00H, 't', 00H, 'a', 00H
	DB	'n', 00H, 'c', 00H, 'e', 00H, ' ', 00H, '(', 00H, '%', 00H, 's'
	DB	00H, ':', 00H, '%', 00H, 'd', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG165865 DB	'P', 00H, 'e', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, 'P', 00H, 'r', 00H, 'i', 00H, 'v', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 'g', 00H, 'e', 00H, 'd', 00H, 'T', 00H, 'i', 00H
	DB	'm', 00H, 'e', 00H, 00H, 00H
$SG165829 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165830 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'Q', 00H, 'u', 00H, 'e'
	DB	00H, 'r', 00H, 'y', 00H, ' ', 00H, 'R', 00H, 'e', 00H, 'f', 00H
	DB	'r', 00H, 'e', 00H, 's', 00H, 'h', 00H, 'e', 00H, 'r', 00H, ' '
	DB	00H, 'I', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'f', 00H
	DB	'a', 00H, 'c', 00H, 'e', 00H, ' ', 00H, '(', 00H, '%', 00H, 's'
	DB	00H, ':', 00H, '%', 00H, 'd', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG165870 DB	'P', 00H, 'e', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, 'U', 00H, 's', 00H, 'e', 00H, 'r', 00H, 'T', 00H, 'i'
	DB	00H, 'm', 00H, 'e', 00H, 00H, 00H
$SG165875 DB	'P', 00H, 'e', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'c', 00H, 'e', 00H, 's'
	DB	00H, 's', 00H, 'o', 00H, 'r', 00H, 'T', 00H, 'i', 00H, 'm', 00H
	DB	'e', 00H, 00H, 00H
	ORG $+2
$SG165833 DB	'W', 00H, 'i', 00H, 'n', 00H, '3', 00H, '2', 00H, '_', 00H
	DB	'P', 00H, 'e', 00H, 'r', 00H, 'f', 00H, 'F', 00H, 'o', 00H, 'r'
	DB	00H, 'm', 00H, 'a', 00H, 't', 00H, 't', 00H, 'e', 00H, 'd', 00H
	DB	'D', 00H, 'a', 00H, 't', 00H, 'a', 00H, '_', 00H, 'P', 00H, 'e'
	DB	00H, 'r', 00H, 'f', 00H, 'O', 00H, 'S', 00H, '_', 00H, 'P', 00H
	DB	'r', 00H, 'o', 00H, 'c', 00H, 'e', 00H, 's', 00H, 's', 00H, 'o'
	DB	00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG165880 DB	'P', 00H, 'e', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, 'I', 00H, 'd', 00H, 'l', 00H, 'e', 00H, 'T', 00H, 'i'
	DB	00H, 'm', 00H, 'e', 00H, 00H, 00H
	ORG $+4
$SG165834 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165835 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'A', 00H, 'd', 00H, 'd'
	DB	00H, ' ', 00H, 'E', 00H, 'n', 00H, 'u', 00H, 'm', 00H, 'e', 00H
	DB	'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '('
	DB	00H, '%', 00H, 's', 00H, ':', 00H, '%', 00H, 'd', 00H, ')', 00H
	DB	' ', 00H, '-', 00H, ' ', 00H, '%', 00H, '0', 00H, '4', 00H, 'X'
	DB	00H, 00H, 00H
	ORG $+2
$SG165837 DB	'C', 00H, 'P', 00H, 'U', 00H, 'M', 00H, 'o', 00H, 'n', 00H
	DB	' ', 00H, 'S', 00H, 'h', 00H, 'u', 00H, 't', 00H, 'd', 00H, 'o'
	DB	00H, 'w', 00H, 'n', 00H, ' ', 00H, 'S', 00H, 'i', 00H, 'g', 00H
	DB	'n', 00H, 'a', 00H, 'l', 00H, 00H, 00H
	ORG $+6
$SG165841 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165842 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'R', 00H, 'e', 00H, 'f'
	DB	00H, 'r', 00H, 'e', 00H, 's', 00H, 'h', 00H, ' ', 00H, 'C', 00H
	DB	'P', 00H, 'U', 00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':'
	DB	00H, '%', 00H, 'd', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG165847 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165848 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'O', 00H, 'u', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'f', 00H
	DB	' ', 00H, 'M', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y'
	DB	00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':', 00H, '%', 00H
	DB	'd', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG165851 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165852 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'g', 00H, 'e', 00H, 't'
	DB	00H, ' ', 00H, 'C', 00H, 'P', 00H, 'U', 00H, ' ', 00H, 'O', 00H
	DB	'b', 00H, 'j', 00H, 'e', 00H, 'c', 00H, 't', 00H, 's', 00H, ' '
	DB	00H, '(', 00H, '%', 00H, 's', 00H, ':', 00H, '%', 00H, 'd', 00H
	DB	')', 00H, 00H, 00H
	ORG $+2
$SG165855 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165856 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'U', 00H, 'N', 00H, 'K', 00H, 'N', 00H, 'O', 00H, 'W', 00H
	DB	'N', 00H, ' ', 00H, 'E', 00H, 'R', 00H, 'R', 00H, 'O', 00H, 'R'
	DB	00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':', 00H, '%', 00H
	DB	'd', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG165861 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165862 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'a', 00H, 'c', 00H, 'q'
	DB	00H, 'u', 00H, 'i', 00H, 'r', 00H, 'e', 00H, ' ', 00H, 'p', 00H
	DB	'r', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 't', 00H, 'y'
	DB	00H, ' ', 00H, 'h', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'l', 00H
	DB	'e', 00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':', 00H, '%'
	DB	00H, 'd', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG165866 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165867 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'a', 00H, 'c', 00H, 'q'
	DB	00H, 'u', 00H, 'i', 00H, 'r', 00H, 'e', 00H, ' ', 00H, 'p', 00H
	DB	'r', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 't', 00H, 'y'
	DB	00H, ' ', 00H, 'h', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'l', 00H
	DB	'e', 00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':', 00H, '%'
	DB	00H, 'd', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG165871 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165872 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'a', 00H, 'c', 00H, 'q'
	DB	00H, 'u', 00H, 'i', 00H, 'r', 00H, 'e', 00H, ' ', 00H, 'p', 00H
	DB	'r', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 't', 00H, 'y'
	DB	00H, ' ', 00H, 'h', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'l', 00H
	DB	'e', 00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':', 00H, '%'
	DB	00H, 'd', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG165876 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165877 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'a', 00H, 'c', 00H, 'q'
	DB	00H, 'u', 00H, 'i', 00H, 'r', 00H, 'e', 00H, ' ', 00H, 'p', 00H
	DB	'r', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 't', 00H, 'y'
	DB	00H, ' ', 00H, 'h', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'l', 00H
	DB	'e', 00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':', 00H, '%'
	DB	00H, 'd', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG165881 DB	'c', 00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'n', 00H, '\', 00H, 's', 00H, 'o', 00H, 'u', 00H, 'r', 00H
	DB	'c', 00H, 'e', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 's', 00H, '\', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 'k', 00H, '\', 00H, 's', 00H, 'r'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'o', 00H, '_', 00H, 'm', 00H
	DB	'o', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'o', 00H, 'r', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H
$SG165882 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'a', 00H, 'c', 00H, 'q'
	DB	00H, 'u', 00H, 'i', 00H, 'r', 00H, 'e', 00H, ' ', 00H, 'p', 00H
	DB	'r', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 't', 00H, 'y'
	DB	00H, ' ', 00H, 'h', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'l', 00H
	DB	'e', 00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ':', 00H, '%'
	DB	00H, 'd', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG165885 DB	'[', 00H, ' ', 00H, 'W', 00H, 'M', 00H, 'I', 00H, ' ', 00H
	DB	'W', 00H, 'b', 00H, 'e', 00H, 'm', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'C', 00H, 'P', 00H, 'U', 00H, ' ', 00H, 'a', 00H, 'p', 00H
	DB	'E', 00H, 'n', 00H, 'u', 00H, 'm', 00H, 'A', 00H, 'c', 00H, 'c'
	DB	00H, 'e', 00H, 's', 00H, 's', 00H, ' ', 00H, '[', 00H, '%', 00H
	DB	'l', 00H, 'u', 00H, ']', 00H, ' ', 00H, '=', 00H, ' ', 00H, 'n'
	DB	00H, 'u', 00H, 'l', 00H, 'l', 00H, 'p', 00H, 't', 00H, 'r', 00H
	DB	00H, 00H
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?wcsrchr@@YAPA_WPA_W_W@Z			; wcsrchr
PUBLIC	__InlineInterlockedExchangePointer
PUBLIC	__InlineInterlockedCompareExchangePointer
PUBLIC	_ReadAcquire
PUBLIC	_ReadPointerAcquire
PUBLIC	_RtlSecureZeroMemory
PUBLIC	?SK_ShutdownWMI@@YAXXZ				; SK_ShutdownWMI
PUBLIC	??0SK_AutoCOMInit@@QAE@XZ			; SK_AutoCOMInit::SK_AutoCOMInit
PUBLIC	??1SK_AutoCOMInit@@QAE@XZ			; SK_AutoCOMInit::~SK_AutoCOMInit
PUBLIC	?SK_CountIO@@YAXAAUio_perf_t@@N@Z		; SK_CountIO
PUBLIC	??0WMI_refresh_thread_t@@QAE@XZ			; WMI_refresh_thread_t::WMI_refresh_thread_t
PUBLIC	??0cpu_stat_s@cpu_perf_t@@QAE@XZ		; cpu_perf_t::cpu_stat_s::cpu_stat_s
PUBLIC	??0cpu_perf_t@@QAE@XZ				; cpu_perf_t::cpu_perf_t
PUBLIC	??0disk_stat_s@disk_perf_t@@QAE@XZ		; disk_perf_t::disk_stat_s::disk_stat_s
PUBLIC	??0disk_perf_t@@QAE@XZ				; disk_perf_t::disk_perf_t
PUBLIC	??0<unnamed-type-pagefiles>@pagefile_perf_t@@QAE@XZ ; pagefile_perf_t::<unnamed-type-pagefiles>::<unnamed-type-pagefiles>
PUBLIC	??0pagefile_perf_t@@QAE@XZ			; pagefile_perf_t::pagefile_perf_t
PUBLIC	?SK_MonitorCPU@@YGKPAX@Z			; SK_MonitorCPU
PUBLIC	?SK_MonitorDisk@@YGKPAX@Z			; SK_MonitorDisk
PUBLIC	?SK_MonitorPagefile@@YGKPAX@Z			; SK_MonitorPagefile
PUBLIC	?fpclassify@@YAHN@Z				; fpclassify
PUBLIC	??0Stats@Framerate@SK@@QAE@XZ			; SK::Framerate::Stats::Stats
PUBLIC	??0sample_t@Stats@Framerate@SK@@QAE@XZ		; SK::Framerate::Stats::sample_t::sample_t
PUBLIC	?addSample@Stats@Framerate@SK@@QAEXNT_LARGE_INTEGER@@@Z ; SK::Framerate::Stats::addSample
PUBLIC	?lock@SK_Thread_CriticalSection@@QAEXXZ		; SK_Thread_CriticalSection::lock
PUBLIC	?unlock@SK_Thread_CriticalSection@@QAEXXZ	; SK_Thread_CriticalSection::unlock
PUBLIC	?isActive@SK_Widget@@QBE_NXZ			; SK_Widget::isActive
PUBLIC	?Lock@WMI@Base@COM@@QAEXXZ			; COM::Base::WMI::Lock
PUBLIC	?Unlock@WMI@Base@COM@@QAEXXZ			; COM::Base::WMI::Unlock
PUBLIC	??0WMI@Base@COM@@QAE@XZ				; COM::Base::WMI::WMI
PUBLIC	??0Base@COM@@QAE@XZ				; COM::Base::Base
PUBLIC	?SK_WMI_ServerThread@@YGKPAX@Z			; SK_WMI_ServerThread
PUBLIC	?SK_InitCOM@@YA_NXZ				; SK_InitCOM
PUBLIC	?SK_InitWMI@@YA_NXZ				; SK_InitWMI
PUBLIC	??$min@K@std@@YAABKABK0@Z			; std::min<unsigned long>
PUBLIC	??$isnan@N@@YA_NN@Z				; isnan<double>
PUBLIC	??0WMI_refresh_instance_thread_t@@QAE@XZ	; WMI_refresh_instance_thread_t::WMI_refresh_instance_thread_t
PUBLIC	??0process_stats_t@@QAE@XZ			; process_stats_t::process_stats_t
PUBLIC	?SK_MonitorProcess@@YGKPAX@Z			; SK_MonitorProcess
PUBLIC	?cpu_stats@@3Ucpu_perf_t@@A			; cpu_stats
PUBLIC	?disk_stats@@3Udisk_perf_t@@A			; disk_stats
PUBLIC	?pagefile_stats@@3Upagefile_perf_t@@A		; pagefile_stats
PUBLIC	?base@COM@@3UBase@1@A				; COM::base
PUBLIC	?process_stats@@3Uprocess_stats_t@@A		; process_stats
PUBLIC	__real@3ea0000000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@4008000000000000
PUBLIC	__real@408f400000000000
PUBLIC	__real@416312d000000000
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	__imp__wcsrchr:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__QueryPerformanceFrequency@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__SetEvent@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__SleepEx@8:PROC
EXTRN	__imp__CreateEventW@16:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__GetCurrentProcess@0:PROC
EXTRN	__imp__GetCurrentThread@0:PROC
EXTRN	__imp__GetSystemTime@4:PROC
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__GetProcessIoCounters@8:PROC
EXTRN	__imp__QueryFullProcessImageNameW@16:PROC
EXTRN	__imp__SystemTimeToFileTime@8:PROC
EXTRN	__imp__wsprintfW:PROC
EXTRN	__imp__WideCharToMultiByte@32:PROC
EXTRN	__imp__timeGetTime@0:PROC
EXTRN	__imp__CoUninitialize@0:PROC
EXTRN	__imp__CoInitializeEx@8:PROC
EXTRN	__imp__CoInitializeSecurity@36:PROC
EXTRN	__imp__CoSetProxyBlanket@32:PROC
EXTRN	__imp__CoCreateInstance@20:PROC
EXTRN	__imp__SysAllocString@4:PROC
EXTRN	__imp__SysFreeString@4:PROC
EXTRN	__imp___dtest:PROC
EXTRN	?LogEx@iSK_Logger@@UAAX_NQB_WZZ:PROC		; iSK_Logger::LogEx
EXTRN	?Log@iSK_Logger@@UAAXQB_WZZ:PROC		; iSK_Logger::Log
EXTRN	?calcMean@Stats@Framerate@SK@@QAENN@Z:PROC	; SK::Framerate::Stats::calcMean
EXTRN	?SK_Steam_LoadOverlayEarly@@YA_NXZ:PROC		; SK_Steam_LoadOverlayEarly
EXTRN	?SK_QueryPerf@@YA?AT_LARGE_INTEGER@@XZ:PROC	; SK_QueryPerf
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__dtoui3:PROC
EXTRN	__dtoul3:PROC
EXTRN	__ultod3:PROC
EXTRN	_memset:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	_IID_IUnknown:BYTE
EXTRN	_IID_IWbemObjectAccess:BYTE
EXTRN	_IID_IWbemLocator:BYTE
EXTRN	_IID_IWbemRefresher:BYTE
EXTRN	_IID_IWbemConfigureRefresher:BYTE
EXTRN	_CLSID_WbemLocator:BYTE
EXTRN	_CLSID_WbemRefresher:BYTE
EXTRN	?dll_log@@3UiSK_Logger@@A:BYTE			; dll_log
EXTRN	?wmi_cs@@3PAVSK_Thread_HybridSpinlock@@A:DWORD	; wmi_cs
EXTRN	?freq@Stats@Framerate@SK@@2T_LARGE_INTEGER@@A:QWORD ; SK::Framerate::Stats::freq
EXTRN	?config@@3Usk_config_t@@A:BYTE			; config
EXTRN	?SK_ImGui_Widgets@@3USK_ImGui_WidgetRegistry@@A:BYTE ; SK_ImGui_Widgets
EXTRN	?hModOverlay@@3PAUHINSTANCE__@@A:DWORD		; hModOverlay
EXTRN	__fltused:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
_BSS	SEGMENT
?cpu_stats@@3Ucpu_perf_t@@A DB 0e48H DUP (?)		; cpu_stats
?disk_stats@@3Udisk_perf_t@@A DB 05d0H DUP (?)		; disk_stats
?pagefile_stats@@3Upagefile_perf_t@@A DB 010fcH DUP (?)	; pagefile_stats
_BSS	ENDS
;	COMDAT ?hProc@?1??SK_CountIO@@YAXAAUio_perf_t@@N@Z@4PAXA
_BSS	SEGMENT
?hProc@?1??SK_CountIO@@YAXAAUio_perf_t@@N@Z@4PAXA DD 01H DUP (?) ; `SK_CountIO'::`2'::hProc
_BSS	ENDS
;	COMDAT ?$TSS0@?1??SK_CountIO@@YAXAAUio_perf_t@@N@Z@4HA
_BSS	SEGMENT
?$TSS0@?1??SK_CountIO@@YAXAAUio_perf_t@@N@Z@4HA DD 01H DUP (?) ; TSS0<`template-parameter-2',UNKNOWN volatile * const volatile,untIO,AXAAUio_perf_t,double>
_BSS	ENDS
;	COMDAT ?write_rate@?ED@??SK_MonitorDisk@@YGKPAX@Z@4PAVStats@Framerate@SK@@A
_BSS	SEGMENT
?write_rate@?ED@??SK_MonitorDisk@@YGKPAX@Z@4PAVStats@Framerate@SK@@A DB 07880H DUP (?) ; `SK_MonitorDisk'::`67'::write_rate
_BSS	ENDS
;	COMDAT ?$TSS0@?ED@??SK_MonitorDisk@@YGKPAX@Z@4HA
_BSS	SEGMENT
?$TSS0@?ED@??SK_MonitorDisk@@YGKPAX@Z@4HA DD 01H DUP (?) ; TSS0<`template-parameter-67',unsigned __int128 volatile * const volatile,nitorDisk,int, ?? &>
_BSS	ENDS
;	COMDAT ?read_rate@?ED@??SK_MonitorDisk@@YGKPAX@Z@4PAVStats@Framerate@SK@@A
_BSS	SEGMENT
?read_rate@?ED@??SK_MonitorDisk@@YGKPAX@Z@4PAVStats@Framerate@SK@@A DB 07880H DUP (?) ; `SK_MonitorDisk'::`67'::read_rate
_BSS	ENDS
;	COMDAT ?combined_rate@?ED@??SK_MonitorDisk@@YGKPAX@Z@4PAVStats@Framerate@SK@@A
_BSS	SEGMENT
?combined_rate@?ED@??SK_MonitorDisk@@YGKPAX@Z@4PAVStats@Framerate@SK@@A DB 07880H DUP (?) ; `SK_MonitorDisk'::`67'::combined_rate
_BSS	ENDS
CRT$XCU	SEGMENT
?cpu_stats$initializer$@@3P6AXXZA DD FLAT:??__Ecpu_stats@@YAXXZ ; cpu_stats$initializer$
CRT$XCU	ENDS
;	COMDAT __real@416312d000000000
CONST	SEGMENT
__real@416312d000000000 DQ 0416312d000000000r	; 1e+07
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3ea0000000000000
CONST	SEGMENT
__real@3ea0000000000000 DQ 03ea0000000000000r	; 4.76837e-07
CONST	ENDS
_DATA	SEGMENT
?base@COM@@3UBase@1@A DB 014H DUP (?)
	DD	0ffffffffH				; COM::base
	DD	00H
	ORG $+4
?process_stats@@3Uprocess_stats_t@@A DD 0ffffffffH	; process_stats
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DB	01H
	DB	3 DUP(00H)
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
xdata$x	SEGMENT
__unwindtable$?SK_MonitorProcess@@YGKPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_MonitorProcess@@YGKPAX@Z$13
__unwindtable$?SK_InitWMI@@YA_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_InitWMI@@YA_NXZ$0
__unwindtable$?SK_WMI_ServerThread@@YGKPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_WMI_ServerThread@@YGKPAX@Z$6
__unwindtable$?SK_MonitorPagefile@@YGKPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_MonitorPagefile@@YGKPAX@Z$17
__unwindtable$?SK_MonitorDisk@@YGKPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_MonitorDisk@@YGKPAX@Z$24
__unwindtable$?SK_MonitorCPU@@YGKPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_MonitorCPU@@YGKPAX@Z$18
__ehfuncinfo$?SK_MonitorProcess@@YGKPAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SK_MonitorProcess@@YGKPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SK_InitWMI@@YA_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SK_InitWMI@@YA_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SK_WMI_ServerThread@@YGKPAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SK_WMI_ServerThread@@YGKPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SK_MonitorPagefile@@YGKPAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SK_MonitorPagefile@@YGKPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SK_MonitorDisk@@YGKPAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SK_MonitorDisk@@YGKPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SK_MonitorCPU@@YGKPAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SK_MonitorCPU@@YGKPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
?disk_stats$initializer$@@3P6AXXZA DD FLAT:??__Edisk_stats@@YAXXZ ; disk_stats$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?pagefile_stats$initializer$@@3P6AXXZA DD FLAT:??__Epagefile_stats@@YAXXZ ; pagefile_stats$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstring.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstring.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
_TEXT	SEGMENT
_wszInstance$ = -1580					; size = 1024
_wszProcessName$ = -556					; size = 520
_update$1$ = -36					; size = 8
_dwProcessSize$ = -28					; size = 4
_pClassObj$ = -24					; size = 4
_variant$ = -20						; size = 4
_auto_com$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
_user$ = 8						; size = 4
?SK_MonitorProcess@@YGKPAX@Z PROC			; SK_MonitorProcess

; 1513 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?SK_MonitorProcess@@YGKPAX@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 1568				; 00000620H
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?base@COM@@3UBase@1@A+4
	push	esi
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 1514 :   while (! ReadAcquire (&COM::base.wmi.init))

	test	eax, eax
	jne	SHORT $LN3@SK_Monitor
	mov	esi, DWORD PTR __imp__SleepEx@8
$LL2@SK_Monitor:

; 1515 :     SleepEx (150, FALSE);

	push	0
	push	150					; 00000096H
	call	esi
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?base@COM@@3UBase@1@A+4
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 1514 :   while (! ReadAcquire (&COM::base.wmi.init))

	test	eax, eax
	je	SHORT $LL2@SK_Monitor
$LN3@SK_Monitor:
	push	ebx
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h

; 45   :     HRESULT hr = CoInitializeEx (NULL, COINIT_MULTITHREADED);

	push	0
	push	0

; 54   :   }
; 55   : 
; 56   : private:
; 57   :   bool success = false;

	xor	bl, bl
	call	DWORD PTR __imp__CoInitializeEx@8
	test	eax, eax
	movzx	ecx, bl
	mov	edx, 1
	cmovns	ecx, edx
	mov	BYTE PTR _auto_com$[ebp], cl
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 1521 :   COM::base.wmi.Lock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?Lock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Lock
	movss	xmm0, DWORD PTR ?config@@3Usk_config_t@@A+20

; 1522 : 
; 1523 :   process_stats_t& proc   = process_stats;
; 1524 :   const double     update = config.mem.interval;
; 1525 : 
; 1526 :   HRESULT hr;
; 1527 : 
; 1528 :   if (FAILED (hr = CoCreateInstance (

	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+8
	push	OFFSET _IID_IWbemRefresher
	cvtps2pd xmm0, xmm0
	push	1
	push	0
	push	OFFSET _CLSID_WbemRefresher
	movsd	QWORD PTR _update$1$[ebp], xmm0
	call	DWORD PTR __imp__CoCreateInstance@20
	pop	ebx
	test	eax, eax
	jns	SHORT $LN6@SK_Monitor

; 1529 :                      CLSID_WbemRefresher,
; 1530 :                      nullptr,
; 1531 :                      CLSCTX_INPROC_SERVER,
; 1532 :                      IID_IWbemRefresher,
; 1533 :                      (void**) &proc.pRefresher )
; 1534 :              )
; 1535 :      )
; 1536 :   {
; 1537 :     dll_log.Log(L"[ WMI Wbem ] Failed to create Refresher Instance (%s:%d) -- 0x%X",

	push	eax
	push	1538					; 00000602H
	push	OFFSET $SG166362
	push	OFFSET $SG166363
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 20					; 00000014H

; 1538 :       __FILEW__, __LINE__, hr);
; 1539 :     goto PROC_CLEANUP;

	jmp	$PROC_CLEANUP$69
$LN6@SK_Monitor:

; 1540 :   }
; 1541 : 
; 1542 :   if (FAILED (hr = proc.pRefresher->QueryInterface (

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+8
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+12
	push	OFFSET _IID_IWbemConfigureRefresher
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx]
	test	eax, eax
	jns	SHORT $LN8@SK_Monitor

; 1543 :                      IID_IWbemConfigureRefresher,
; 1544 :                      (void **)&proc.pConfig )
; 1545 :              )
; 1546 :      )
; 1547 :   {
; 1548 :     dll_log.Log(L"[ WMI Wbem ] Failed to Query Refresher Interface (%s:%d) -- 0x%X",

	push	eax
	push	1549					; 0000060dH
	push	OFFSET $SG166366
	push	OFFSET $SG166367
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 20					; 00000014H

; 1549 :       __FILEW__, __LINE__, hr);
; 1550 :     goto PROC_CLEANUP;

	jmp	$PROC_CLEANUP$69
$LN8@SK_Monitor:
	push	edi

; 1551 :   }
; 1552 : 
; 1553 :   IWbemClassObject *pClassObj = nullptr;

	mov	DWORD PTR _pClassObj$[ebp], 0

; 1554 : 
; 1555 :   HANDLE hProc = GetCurrentProcess ();

	call	DWORD PTR __imp__GetCurrentProcess@0

; 1556 : 
; 1557 :   DWORD   dwProcessSize = MAX_PATH;
; 1558 :   wchar_t wszProcessName [MAX_PATH];
; 1559 : 
; 1560 :   QueryFullProcessImageName (hProc, 0, wszProcessName, &dwProcessSize);

	lea	ecx, DWORD PTR _dwProcessSize$[ebp]
	mov	DWORD PTR _dwProcessSize$[ebp], 260	; 00000104H
	push	ecx
	lea	ecx, DWORD PTR _wszProcessName$[ebp]
	push	ecx
	push	0
	push	eax
	call	DWORD PTR __imp__QueryFullProcessImageNameW@16
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstring.h

; 546  :         return const_cast<wchar_t*>(wcsrchr(static_cast<wchar_t const*>(_String), _C));

	mov	esi, DWORD PTR __imp__wcsrchr
	lea	eax, DWORD PTR _wszProcessName$[ebp]
	push	92					; 0000005cH
	push	eax
	call	esi
	push	46					; 0000002eH
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 1562 :   wchar_t* pwszShortName = wcsrchr (wszProcessName, L'\\') + 1;

	lea	edi, DWORD PTR [eax+2]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstring.h

; 546  :         return const_cast<wchar_t*>(wcsrchr(static_cast<wchar_t const*>(_String), _C));

	push	edi
	call	esi
	add	esp, 16					; 00000010H
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 1565 :   if (pwszTruncName != nullptr)

	test	eax, eax
	je	SHORT $LN10@SK_Monitor

; 1566 :     *pwszTruncName = L'\0';

	xor	ecx, ecx
	mov	WORD PTR [eax], cx
$LN10@SK_Monitor:

; 1567 : 
; 1568 :   wchar_t wszInstance [512];
; 1569 :   wsprintf ( wszInstance,

	push	edi
	lea	eax, DWORD PTR _wszInstance$[ebp]
	push	OFFSET $SG166370
	push	eax
	call	DWORD PTR __imp__wsprintfW

; 1570 :                L"Win32_PerfFormattedData_PerfProc_Process.Name='%ws'",
; 1571 :                  pwszShortName );
; 1572 : 
; 1573 :   if (FAILED (hr = proc.pConfig->AddObjectByPath (

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+12
	lea	edx, DWORD PTR _pClassObj$[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	push	0
	push	edx
	push	0
	push	0
	lea	edx, DWORD PTR _wszInstance$[ebp]
	push	edx
	push	DWORD PTR ?base@COM@@3UBase@1@A+8
	push	eax
	call	DWORD PTR [ecx+12]
	test	eax, eax
	jns	SHORT $LN11@SK_Monitor

; 1574 :                      COM::base.wmi.pNameSpace,
; 1575 :                      wszInstance,
; 1576 :                      0,
; 1577 :                      nullptr,
; 1578 :                      &pClassObj,
; 1579 :                      nullptr )
; 1580 :              )
; 1581 :      )
; 1582 :   {
; 1583 :     dll_log.Log(L"[ WMI Wbem ] Failed to AddObjectByPath (%s:%d) -- 0x%X",

	push	eax
	push	1584					; 00000630H
	push	OFFSET $SG166372
	push	OFFSET $SG166373
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 20					; 00000014H

; 1584 :       __FILEW__, __LINE__, hr);
; 1585 :     goto PROC_CLEANUP;

	jmp	$LN68@SK_Monitor
$LN11@SK_Monitor:

; 1586 :   }
; 1587 : 
; 1588 :   if (FAILED (hr = pClassObj->QueryInterface ( IID_IWbemObjectAccess,

	mov	eax, DWORD PTR _pClassObj$[ebp]
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+16
	push	OFFSET _IID_IWbemObjectAccess
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx]
	test	eax, eax
	jns	SHORT $LN13@SK_Monitor

; 1589 :                                                (void **)(&proc.pAccess ) )
; 1590 :              )
; 1591 :      )
; 1592 :   {
; 1593 :     dll_log.Log(L"[ WMI Wbem ] Failed to Query WbemObjectAccess Interface (%s:%d)"

	push	eax
	push	1595					; 0000063bH
	push	OFFSET $SG166376
	push	OFFSET $SG166377
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 1594 :                 L" -- 0x%X",
; 1595 :       __FILEW__, __LINE__, hr);
; 1596 :     pClassObj->Release ();

	mov	eax, DWORD PTR _pClassObj$[ebp]
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]

; 1597 :     pClassObj = nullptr;

	mov	DWORD PTR _pClassObj$[ebp], 0

; 1598 : 
; 1599 :     goto PROC_CLEANUP;

	jmp	$LN68@SK_Monitor
$LN13@SK_Monitor:

; 1600 :   }
; 1601 : 
; 1602 :   pClassObj->Release ();

	mov	eax, DWORD PTR _pClassObj$[ebp]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]

; 1603 :   pClassObj = nullptr;
; 1604 : 
; 1605 :   CIMTYPE variant;
; 1606 :   if (FAILED (hr = proc.pAccess->GetPropertyHandle ( L"PageFileBytes",

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	lea	edx, DWORD PTR _variant$[ebp]
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+52
	push	edx
	mov	DWORD PTR _pClassObj$[ebp], 0
	mov	ecx, DWORD PTR [eax]
	push	OFFSET $SG166380
	push	eax
	call	DWORD PTR [ecx+108]
	test	eax, eax
	js	$LN68@SK_Monitor

; 1607 :                                                      &variant,
; 1608 :                                                      &proc.hPageFileBytes )
; 1609 :              )
; 1610 :      )
; 1611 :   {
; 1612 :     goto PROC_CLEANUP;
; 1613 :   }
; 1614 : 
; 1615 :   if (FAILED (hr = proc.pAccess->GetPropertyHandle ( L"PageFileBytesPeak",

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	lea	edx, DWORD PTR _variant$[ebp]
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+56
	push	edx
	push	OFFSET $SG166383
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+108]
	test	eax, eax
	js	$LN68@SK_Monitor

; 1616 :                                                      &variant,
; 1617 :                                                      &proc.hPageFileBytesPeak )
; 1618 :              )
; 1619 :      )
; 1620 :   {
; 1621 :     goto PROC_CLEANUP;
; 1622 :   }
; 1623 : 
; 1624 :   if (FAILED (hr = proc.pAccess->GetPropertyHandle ( L"ThreadCount",

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	lea	edx, DWORD PTR _variant$[ebp]
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+48
	push	edx
	push	OFFSET $SG166386
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+108]
	test	eax, eax
	js	$LN68@SK_Monitor

; 1625 :                                                      &variant,
; 1626 :                                                      &proc.hThreadCount )
; 1627 :              )
; 1628 :      )
; 1629 :   {
; 1630 :     goto PROC_CLEANUP;
; 1631 :   }
; 1632 : 
; 1633 :   if (FAILED (hr = proc.pAccess->GetPropertyHandle ( L"PrivateBytes",

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	lea	edx, DWORD PTR _variant$[ebp]
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+44
	push	edx
	push	OFFSET $SG166389
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+108]
	test	eax, eax
	js	$LN68@SK_Monitor

; 1634 :                                                      &variant,
; 1635 :                                                      &proc.hPrivateBytes )
; 1636 :              )
; 1637 :      )
; 1638 :   {
; 1639 :     goto PROC_CLEANUP;
; 1640 :   }
; 1641 : 
; 1642 :   if (FAILED (hr = proc.pAccess->GetPropertyHandle ( L"WorkingSetPeak",

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	lea	edx, DWORD PTR _variant$[ebp]
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+40
	push	edx
	push	OFFSET $SG166392
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+108]
	test	eax, eax
	js	$LN68@SK_Monitor

; 1643 :                                                      &variant,
; 1644 :                                                      &proc.hWorkingSetPeak )
; 1645 :              )
; 1646 :      )
; 1647 :   {
; 1648 :     goto PROC_CLEANUP;
; 1649 :   }
; 1650 : 
; 1651 :   if (FAILED (hr = proc.pAccess->GetPropertyHandle ( L"WorkingSet",

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	lea	edx, DWORD PTR _variant$[ebp]
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+36
	push	edx
	push	OFFSET $SG166395
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+108]
	test	eax, eax
	js	$LN68@SK_Monitor

; 1652 :                                                      &variant,
; 1653 :                                                      &proc.hWorkingSet )
; 1654 :              )
; 1655 :      )
; 1656 :   {
; 1657 :     goto PROC_CLEANUP;
; 1658 :   }
; 1659 : 
; 1660 :   if (FAILED (hr = proc.pAccess->GetPropertyHandle ( L"VirtualBytesPeak",

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	lea	edx, DWORD PTR _variant$[ebp]
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+32
	push	edx
	push	OFFSET $SG166398
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+108]
	test	eax, eax
	js	$LN68@SK_Monitor

; 1661 :                                                      &variant,
; 1662 :                                                      &proc.hVirtualBytesPeak )
; 1663 :              )
; 1664 :      )
; 1665 :   {
; 1666 :     goto PROC_CLEANUP;
; 1667 :   }
; 1668 : 
; 1669 :   if (FAILED (hr = proc.pAccess->GetPropertyHandle ( L"VirtualBytes",

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	lea	edx, DWORD PTR _variant$[ebp]
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+28
	push	edx
	push	OFFSET $SG166401
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+108]
	test	eax, eax
	js	$LN68@SK_Monitor

; 1670 :                                                      &variant,
; 1671 :                                                      &proc.hVirtualBytes )
; 1672 :              )
; 1673 :      )
; 1674 :   {
; 1675 :     goto PROC_CLEANUP;
; 1676 :   }
; 1677 : 
; 1678 :   proc.pConfig->Release ();

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+12
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]

; 1679 :   proc.pConfig = nullptr;
; 1680 : 
; 1681 :   int iter = 0;
; 1682 : 
; 1683 :   proc.lID = 1;
; 1684 : 
; 1685 :   proc.hShutdownSignal = CreateEvent (nullptr, FALSE, FALSE, L"ProcMon Shutdown Signal");

	push	OFFSET $SG166403
	push	0
	push	0
	push	0
	mov	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+12, 0
	mov	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+20, 1
	call	DWORD PTR __imp__CreateEventW@16

; 1686 : 
; 1687 :   COM::base.wmi.Unlock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	mov	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+4, eax
	call	?Unlock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Unlock

; 1688 : 
; 1689 :   while (proc.lID != 0)

	cmp	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+20, 0
	je	$LN68@SK_Monitor
	movsd	xmm0, QWORD PTR _update$1$[ebp]
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	call	__dtoui3
	mov	edi, DWORD PTR __imp__WaitForSingleObject@8
	mov	esi, eax
	npad	4
$LL4@SK_Monitor:

; 1690 :   {
; 1691 :     // Sleep until ready
; 1692 :     if (WaitForSingleObject (proc.hShutdownSignal, (DWORD (update * 1000.0))) == WAIT_OBJECT_0)

	mov	ecx, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+4
	push	esi
	push	ecx
	call	edi
	test	eax, eax
	je	$LN68@SK_Monitor

; 1693 :       break;
; 1694 : 
; 1695 :     // Only poll WMI while the data view is visible
; 1696 :     if (! config.mem.show)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+12, 0
	je	$LN60@SK_Monitor

; 1697 :       continue;
; 1698 : 
; 1699 :     COM::base.wmi.Lock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	call	?Lock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Lock

; 1700 : 
; 1701 :     if (FAILED (hr = proc.pRefresher->Refresh (0L)))

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+8
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+12]
	test	eax, eax
	js	$LN68@SK_Monitor

; 1702 :     {
; 1703 :       goto PROC_CLEANUP;
; 1704 :     }
; 1705 : 
; 1706 :     proc.pAccess->ReadQWORD ( proc.hVirtualBytes,

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+64
	push	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+28
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+128]

; 1707 :                                 &proc.memory.virtual_bytes );
; 1708 :     proc.pAccess->ReadQWORD ( proc.hVirtualBytesPeak,

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+72
	push	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+32
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+128]

; 1709 :                                 &proc.memory.virtual_bytes_peak );
; 1710 : 
; 1711 :     proc.pAccess->ReadQWORD ( proc.hWorkingSet,

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+80
	push	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+36
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+128]

; 1712 :                                 &proc.memory.working_set );
; 1713 :     proc.pAccess->ReadQWORD ( proc.hWorkingSetPeak,

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+88
	push	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+40
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+128]

; 1714 :                                 &proc.memory.working_set_peak );
; 1715 : 
; 1716 :     proc.pAccess->ReadQWORD ( proc.hPrivateBytes,

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+96
	push	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+44
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+128]

; 1717 :                                 &proc.memory.private_bytes );
; 1718 : 
; 1719 :     proc.pAccess->ReadDWORD ( proc.hThreadCount,

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+120
	push	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+48
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+120]

; 1720 :                                 (DWORD *)&proc.tasks.thread_count );
; 1721 : 
; 1722 :     proc.pAccess->ReadQWORD ( proc.hPageFileBytes,

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+104
	push	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+52
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+128]

; 1723 :                                 &proc.memory.page_file_bytes );
; 1724 :     proc.pAccess->ReadQWORD ( proc.hPageFileBytesPeak,

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	push	OFFSET ?process_stats@@3Uprocess_stats_t@@A+112
	push	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+56
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+128]

; 1725 :                                 &proc.memory.page_file_bytes_peak );
; 1726 : 
; 1727 :     proc.booting = false;
; 1728 : 
; 1729 :     ++iter;
; 1730 : 
; 1731 :     COM::base.wmi.Unlock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	mov	BYTE PTR ?process_stats@@3Uprocess_stats_t@@A+24, 0
	call	?Unlock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Unlock
$LN60@SK_Monitor:

; 1688 : 
; 1689 :   while (proc.lID != 0)

	cmp	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+20, 0
	jne	$LL4@SK_Monitor
$LN68@SK_Monitor:
	pop	edi
$PROC_CLEANUP$69:

; 1732 :   }
; 1733 : 
; 1734 : PROC_CLEANUP:
; 1735 :   // dll_log.Log (L" >> PROC_CLEANUP");
; 1736 : 
; 1737 :   if (proc.pAccess != nullptr)

	mov	ecx, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16
	pop	esi
	test	ecx, ecx
	je	SHORT $LN35@SK_Monitor

; 1738 :   {
; 1739 :     proc.pAccess->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 1740 :     proc.pAccess = nullptr;

	mov	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+16, 0
$LN35@SK_Monitor:

; 1741 :   }
; 1742 : 
; 1743 :   if (proc.pConfig != nullptr)

	mov	ecx, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+12
	test	ecx, ecx
	je	SHORT $LN36@SK_Monitor

; 1744 :   {
; 1745 :     proc.pConfig->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 1746 :     proc.pConfig = nullptr;

	mov	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+12, 0
$LN36@SK_Monitor:

; 1747 :   }
; 1748 : 
; 1749 :   if (proc.pRefresher != nullptr)

	mov	ecx, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+8
	test	ecx, ecx
	je	SHORT $LN37@SK_Monitor

; 1750 :   {
; 1751 :     proc.pRefresher->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 1752 :     proc.pRefresher = nullptr;

	mov	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+8, 0
$LN37@SK_Monitor:

; 1753 :   }
; 1754 : 
; 1755 :   if (proc.hShutdownSignal != INVALID_HANDLE_VALUE)

	cmp	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+4, -1
	je	SHORT $LN38@SK_Monitor

; 1756 :   {
; 1757 :     CloseHandle (proc.hShutdownSignal);

	mov	eax, DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+4
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 1758 :     proc.hShutdownSignal = INVALID_HANDLE_VALUE;

	mov	DWORD PTR ?process_stats@@3Uprocess_stats_t@@A+4, -1
$LN38@SK_Monitor:

; 1759 :   }
; 1760 : 
; 1761 :   COM::base.wmi.Unlock   ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	call	?Unlock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Unlock
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h

; 52   :     if (success)

	cmp	BYTE PTR _auto_com$[ebp], 0
	je	SHORT $LN65@SK_Monitor

; 53   :       CoUninitialize ();

	call	DWORD PTR __imp__CoUninitialize@0
$LN65@SK_Monitor:
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 1764 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	xor	eax, eax
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_MonitorProcess@@YGKPAX@Z$13:
	lea	ecx, DWORD PTR _auto_com$[ebp]
	jmp	??1SK_AutoCOMInit@@QAE@XZ		; SK_AutoCOMInit::~SK_AutoCOMInit
__ehhandler$?SK_MonitorProcess@@YGKPAX@Z:
	mov	eax, OFFSET __ehfuncinfo$?SK_MonitorProcess@@YGKPAX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_MonitorProcess@@YGKPAX@Z ENDP			; SK_MonitorProcess
; Function compile flags: /Ogtp
;	COMDAT ??0process_stats_t@@QAE@XZ
_TEXT	SEGMENT
??0process_stats_t@@QAE@XZ PROC				; process_stats_t::process_stats_t, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], -1
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], -1
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
	mov	BYTE PTR [ecx+24], 1
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+40], 0
	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+52], 0
	mov	DWORD PTR [ecx+56], 0
	ret	0
??0process_stats_t@@QAE@XZ ENDP				; process_stats_t::process_stats_t
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0WMI_refresh_instance_thread_t@@QAE@XZ
_TEXT	SEGMENT
??0WMI_refresh_instance_thread_t@@QAE@XZ PROC		; WMI_refresh_instance_thread_t::WMI_refresh_instance_thread_t, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], -1
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], -1
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
	mov	BYTE PTR [ecx+24], 1
	ret	0
??0WMI_refresh_instance_thread_t@@QAE@XZ ENDP		; WMI_refresh_instance_thread_t::WMI_refresh_instance_thread_t
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
;	COMDAT ??__Epagefile_stats@@YAXXZ
text$di	SEGMENT
??__Epagefile_stats@@YAXXZ PROC				; `dynamic initializer for 'pagefile_stats'', COMDAT

; 1168 : pagefile_perf_t pagefile_stats;

	mov	ecx, OFFSET ?pagefile_stats@@3Upagefile_perf_t@@A ; pagefile_stats
	jmp	??0pagefile_perf_t@@QAE@XZ
??__Epagefile_stats@@YAXXZ ENDP				; `dynamic initializer for 'pagefile_stats''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
;	COMDAT ??$isnan@N@@YA_NN@Z
_TEXT	SEGMENT
__X$ = 8						; size = 8
__X$ = 8						; size = 8
??$isnan@N@@YA_NN@Z PROC				; isnan<double>, COMDAT

; 402  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 403  :         return fpclassify(_X) == FP_NAN;

	movsd	xmm0, QWORD PTR __X$[ebp]

; 285  :         return _dtest(&_X);

	lea	eax, DWORD PTR __X$[ebp]
	push	eax

; 403  :         return fpclassify(_X) == FP_NAN;

	movsd	QWORD PTR __X$[ebp], xmm0

; 285  :         return _dtest(&_X);

	call	DWORD PTR __imp___dtest

; 403  :         return fpclassify(_X) == FP_NAN;

	xor	ecx, ecx

; 285  :         return _dtest(&_X);

	add	esp, 4

; 403  :         return fpclassify(_X) == FP_NAN;

	cmp	ax, 2
	sete	al

; 404  :     }

	pop	ebp
	ret	0
??$isnan@N@@YA_NN@Z ENDP				; isnan<double>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
;	COMDAT ??__Edisk_stats@@YAXXZ
text$di	SEGMENT
??__Edisk_stats@@YAXXZ PROC				; `dynamic initializer for 'disk_stats'', COMDAT

; 751  : disk_perf_t disk_stats;

	mov	ecx, OFFSET ?disk_stats@@3Udisk_perf_t@@A ; disk_stats
	jmp	??0disk_perf_t@@QAE@XZ
??__Edisk_stats@@YAXXZ ENDP				; `dynamic initializer for 'disk_stats''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
;	COMDAT ??$min@K@std@@YAABKABK0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@K@std@@YAABKABK0@Z PROC				; std::min<unsigned long>, COMDAT

; 3778 : 	{	// return smaller of _Left and _Right

	npad	2
	push	ebp
	mov	ebp, esp

; 3779 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	cmovb	eax, edx

; 3780 : 	}

	pop	ebp
	ret	0
??$min@K@std@@YAABKABK0@Z ENDP				; std::min<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
;	COMDAT ??__Ecpu_stats@@YAXXZ
text$di	SEGMENT
??__Ecpu_stats@@YAXXZ PROC				; `dynamic initializer for 'cpu_stats'', COMDAT

; 396  : cpu_perf_t cpu_stats;

	mov	ecx, OFFSET ?cpu_stats@@3Ucpu_perf_t@@A	; cpu_stats
	jmp	??0cpu_perf_t@@QAE@XZ
??__Ecpu_stats@@YAXXZ ENDP				; `dynamic initializer for 'cpu_stats''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
_TEXT	SEGMENT
_auto_com$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
?SK_InitWMI@@YA_NXZ PROC				; SK_InitWMI

; 342  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SK_InitWMI@@YA_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h

; 45   :     HRESULT hr = CoInitializeEx (NULL, COINIT_MULTITHREADED);

	push	0
	push	0

; 54   :   }
; 55   : 
; 56   : private:
; 57   :   bool success = false;

	xor	bl, bl
	call	DWORD PTR __imp__CoInitializeEx@8
	test	eax, eax
	movzx	ecx, bl
	mov	edx, 1
	cmovns	ecx, edx
	mov	BYTE PTR _auto_com$[ebp], cl
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 343  :   SK_AutoCOMInit auto_com;

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 344  : 
; 345  :   if (! SK_InitCOM ())

	call	?SK_InitCOM@@YA_NXZ			; SK_InitCOM
	test	al, al
	je	SHORT $LN11@SK_InitWMI
$LN4@SK_InitWMI:

; 346  :     return false;
; 347  : 
; 348  :   COM::base.wmi.Lock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	call	?Lock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Lock
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?base@COM@@3UBase@1@A+4
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 350  :   if (ReadAcquire (&COM::base.wmi.init) > 0)

	test	eax, eax
	jle	SHORT $LN5@SK_InitWMI

; 351  :   {
; 352  :     COM::base.wmi.Unlock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	call	?Unlock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Unlock
	jmp	SHORT $LN41@SK_InitWMI
$LN5@SK_InitWMI:
	push	esi
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 5286 :     return (PVOID)InterlockedCompareExchange((LONG volatile *) Destination,

	xor	ecx, ecx
	mov	esi, OFFSET ?base@COM@@3UBase@1@A+20
	or	eax, -1
	lock	 cmpxchg DWORD PTR [esi], ecx
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 356  :   if (InterlockedCompareExchangePointer (&COM::base.wmi.hServerThread, nullptr, INVALID_HANDLE_VALUE) == INVALID_HANDLE_VALUE)

	cmp	eax, -1
	jne	SHORT $LN35@SK_InitWMI

; 357  :   {
; 358  :     COM::base.wmi.hShutdownServer =

	push	OFFSET $SG165739
	push	0
	push	1
	push	0
	call	DWORD PTR __imp__CreateEventW@16
	mov	DWORD PTR ?base@COM@@3UBase@1@A+24, eax

; 359  :       CreateEvent (nullptr, TRUE, FALSE, L"WMI Shutdown");
; 360  : 
; 361  :     InterlockedExchangePointer ( &COM::base.wmi.hServerThread,

	call	DWORD PTR __imp__GetCurrentThread@0
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 5265 :     return (PVOID)InterlockedExchange((LONG volatile *) Destination,

	xchg	DWORD PTR [esi], eax
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 364  :     SK_WMI_ServerThread (nullptr);

	push	0
	call	?SK_WMI_ServerThread@@YGKPAX@Z		; SK_WMI_ServerThread

; 365  :   }
; 366  : 
; 367  :   else

	jmp	SHORT $LN3@SK_InitWMI
$LN35@SK_InitWMI:
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?base@COM@@3UBase@1@A+4
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 369  :     while (! ReadAcquire (&COM::base.wmi.init))

	test	eax, eax
	jne	SHORT $LN3@SK_InitWMI
	mov	esi, DWORD PTR __imp__SleepEx@8
$LL2@SK_InitWMI:

; 370  :       SleepEx (333, FALSE);

	push	0
	push	333					; 0000014dH
	call	esi
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?base@COM@@3UBase@1@A+4
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 369  :     while (! ReadAcquire (&COM::base.wmi.init))

	test	eax, eax
	je	SHORT $LL2@SK_InitWMI
$LN3@SK_InitWMI:
	pop	esi
$LN41@SK_InitWMI:

; 371  :   }
; 372  : 
; 373  :   return true;

	mov	bl, 1
$LN11@SK_InitWMI:
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h

; 52   :     if (success)

	cmp	BYTE PTR _auto_com$[ebp], 0
	je	SHORT $LN39@SK_InitWMI

; 53   :       CoUninitialize ();

	call	DWORD PTR __imp__CoUninitialize@0
$LN39@SK_InitWMI:
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 374  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	al, bl
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_InitWMI@@YA_NXZ$0:
	lea	ecx, DWORD PTR _auto_com$[ebp]
	jmp	??1SK_AutoCOMInit@@QAE@XZ		; SK_AutoCOMInit::~SK_AutoCOMInit
__ehhandler$?SK_InitWMI@@YA_NXZ:
	mov	eax, OFFSET __ehfuncinfo$?SK_InitWMI@@YA_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_InitWMI@@YA_NXZ ENDP				; SK_InitWMI
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
_TEXT	SEGMENT
?SK_InitCOM@@YA_NXZ PROC				; SK_InitCOM

; 308  :   HRESULT hr;
; 309  : 
; 310  :   //
; 311  :   // HACK to address problems with Steam Overlay
; 312  :   //
; 313  :   SleepEx (50, TRUE);

	push	1
	push	50					; 00000032H
	call	DWORD PTR __imp__SleepEx@8

; 314  : 
; 315  :   if (FAILED (hr = CoInitializeSecurity (

	push	0
	push	0
	push	0
	push	3
	push	1
	push	0
	push	0
	push	-1
	push	0
	call	DWORD PTR __imp__CoInitializeSecurity@36
	test	eax, eax
	jns	SHORT $LN3@SK_InitCOM

; 316  :                      nullptr,
; 317  :                      -1,
; 318  :                      nullptr,
; 319  :                      nullptr,
; 320  :                      RPC_C_AUTHN_LEVEL_NONE,
; 321  :                      RPC_C_IMP_LEVEL_IMPERSONATE,
; 322  :                      nullptr, EOAC_NONE, nullptr )
; 323  :              )
; 324  :      )
; 325  :   {
; 326  :     // It's possible that the application already did this, in which case
; 327  :     //   it is immutable and we should try to deal with whatever the app
; 328  :     //     initialized it to.
; 329  :     if (hr != RPC_E_TOO_LATE)

	cmp	eax, -2147417831			; 80010119H
	je	SHORT $LN3@SK_InitCOM

; 330  :     {
; 331  :       dll_log.Log (L"[COM Secure] Failure to initialize COM Security (%s:%d) -- 0x%X",

	push	eax
	push	332					; 0000014cH
	push	OFFSET $SG165721
	push	OFFSET $SG165722
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 20					; 00000014H

; 332  :         __FILEW__, __LINE__, hr);
; 333  :       return false;

	xor	al, al

; 338  : }

	ret	0
$LN3@SK_InitCOM:

; 334  :     }
; 335  :   }
; 336  : 
; 337  :   return true;

	mov	al, 1

; 338  : }

	ret	0
?SK_InitCOM@@YA_NXZ ENDP				; SK_InitCOM
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
_TEXT	SEGMENT
_pUnk$ = -20						; size = 4
_auto_com$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
_lpUser$ = 8						; size = 4
?SK_WMI_ServerThread@@YGKPAX@Z PROC			; SK_WMI_ServerThread

; 173  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SK_WMI_ServerThread@@YGKPAX@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h

; 45   :     HRESULT hr = CoInitializeEx (NULL, COINIT_MULTITHREADED);

	push	0
	push	0

; 54   :   }
; 55   : 
; 56   : private:
; 57   :   bool success = false;

	xor	bl, bl
	call	DWORD PTR __imp__CoInitializeEx@8
	test	eax, eax
	movzx	ebx, bl
	mov	edi, 1
	cmovns	ebx, edi
	mov	BYTE PTR _auto_com$[ebp], bl
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 176  :   if (config.steam.preload_overlay)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+389, 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	je	SHORT $LN2@SK_WMI_Ser

; 177  :   {
; 178  :     extern bool SK_Steam_LoadOverlayEarly (void);
; 179  :                 SK_Steam_LoadOverlayEarly (    );

	call	?SK_Steam_LoadOverlayEarly@@YA_NXZ	; SK_Steam_LoadOverlayEarly
$LN2@SK_WMI_Ser:

; 180  :   }
; 181  : 
; 182  :   UNREFERENCED_PARAMETER (lpUser);
; 183  : 
; 184  :   HRESULT hr;
; 185  : 
; 186  :   if (FAILED (hr = CoCreateInstance (

	push	OFFSET ?base@COM@@3UBase@1@A+12
	push	OFFSET _IID_IWbemLocator
	push	1
	push	0
	push	OFFSET _CLSID_WbemLocator
	call	DWORD PTR __imp__CoCreateInstance@20
	test	eax, eax
	jns	$LN3@SK_WMI_Ser

; 187  :                      CLSID_WbemLocator, 
; 188  :                      nullptr,
; 189  :                      CLSCTX_INPROC_SERVER,
; 190  :                      IID_IWbemLocator,
; 191  :                      (void**) &COM::base.wmi.pWbemLocator )
; 192  :              )
; 193  :      )
; 194  :   {
; 195  :     dll_log.Log (L"[ WMI Wbem ] Failed to create Wbem Locator (%s:%d) -- 0x%X",

	push	eax
	push	196					; 000000c4H
	push	OFFSET $SG165687
	push	OFFSET $SG165688
$LN29@SK_WMI_Ser:

; 211  :                      COM::base.wmi.bstrNameSpace,
; 212  :                      nullptr, // User name
; 213  :                      nullptr, // Password
; 214  :                      nullptr, // Locale
; 215  :                      0L,      // Security flags
; 216  :                      nullptr, // Authority
; 217  :                      nullptr, // Wbem context
; 218  :                      &COM::base.wmi.pNameSpace )
; 219  :              )
; 220  :      )
; 221  :   {
; 222  :     dll_log.Log (L"[ WMI Wbem ] Failure to Connect to Wbem Server (%s:%d) -- 0x%X",

	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 20					; 00000014H
$WMI_CLEANUP$30:

; 272  :   }
; 273  : 
; 274  :   goto WMI_CLEANUP_WITHOUT_LOCK;
; 275  : 
; 276  : 
; 277  : WMI_CLEANUP:
; 278  :   COM::base.wmi.Unlock ();

	mov	esi, OFFSET ?base@COM@@3UBase@1@A+4
	mov	ecx, esi
	call	?Unlock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Unlock
$WMI_CLEANUP_WITHOUT_LOCK$31:

; 279  : 
; 280  : 
; 281  : WMI_CLEANUP_WITHOUT_LOCK:
; 282  :   if (COM::base.wmi.bstrNameSpace != nullptr)

	mov	eax, DWORD PTR ?base@COM@@3UBase@1@A+16
	test	eax, eax
	je	SHORT $LN15@SK_WMI_Ser

; 283  :   {
; 284  :     SysFreeString (COM::base.wmi.bstrNameSpace);

	push	eax
	call	DWORD PTR __imp__SysFreeString@4

; 285  :     COM::base.wmi.bstrNameSpace       = nullptr;

	mov	DWORD PTR ?base@COM@@3UBase@1@A+16, 0
$LN15@SK_WMI_Ser:

; 286  :   }
; 287  : 
; 288  :   if (COM::base.wmi.pWbemLocator != nullptr)

	mov	ecx, DWORD PTR ?base@COM@@3UBase@1@A+12
	test	ecx, ecx
	je	SHORT $LN16@SK_WMI_Ser

; 289  :   {
; 290  :     COM::base.wmi.pWbemLocator->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 291  :     COM::base.wmi.pWbemLocator   = nullptr;

	mov	DWORD PTR ?base@COM@@3UBase@1@A+12, 0
$LN16@SK_WMI_Ser:

; 292  :   }
; 293  : 
; 294  :   if (COM::base.wmi.pNameSpace != nullptr)

	mov	ecx, DWORD PTR ?base@COM@@3UBase@1@A+8
	test	ecx, ecx
	je	SHORT $LN17@SK_WMI_Ser

; 295  :   {
; 296  :     COM::base.wmi.pNameSpace->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 297  :     COM::base.wmi.pNameSpace   = nullptr;

	mov	DWORD PTR ?base@COM@@3UBase@1@A+8, 0
$LN17@SK_WMI_Ser:

; 298  :   }
; 299  : 
; 300  :   InterlockedExchange (&COM::base.wmi.init, 0);

	xor	eax, eax
	xchg	DWORD PTR [esi], eax
	pop	edi
	pop	esi
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h

; 52   :     if (success)

	test	bl, bl
	pop	ebx
	je	SHORT $LN27@SK_WMI_Ser

; 53   :       CoUninitialize ();

	call	DWORD PTR __imp__CoUninitialize@0
$LN27@SK_WMI_Ser:
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 303  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	xor	eax, eax
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN3@SK_WMI_Ser:

; 196  :       __FILEW__, __LINE__, hr);
; 197  :     goto WMI_CLEANUP;
; 198  :   }
; 199  : 
; 200  :   // Connect to the desired namespace.
; 201  :   COM::base.wmi.bstrNameSpace = SysAllocString (L"\\\\.\\Root\\CIMv2");

	push	OFFSET $SG165690
	call	DWORD PTR __imp__SysAllocString@4
	mov	edx, eax
	mov	DWORD PTR ?base@COM@@3UBase@1@A+16, edx

; 202  :   if (COM::base.wmi.bstrNameSpace == nullptr)

	test	edx, edx
	jne	SHORT $LN5@SK_WMI_Ser

; 203  :   {
; 204  :     dll_log.Log (L"[ WMI Wbem ] Out of Memory (%s:%d)",

	push	205					; 000000cdH
	push	OFFSET $SG165692
	push	OFFSET $SG165693
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 205  :       __FILEW__, __LINE__);
; 206  :     hr = E_OUTOFMEMORY;
; 207  :     goto WMI_CLEANUP;

	jmp	$WMI_CLEANUP$30
$LN5@SK_WMI_Ser:

; 208  :   }
; 209  : 
; 210  :   if (FAILED (hr = COM::base.wmi.pWbemLocator->ConnectServer (

	mov	eax, DWORD PTR ?base@COM@@3UBase@1@A+12
	push	OFFSET ?base@COM@@3UBase@1@A+8
	push	0
	push	0
	mov	ecx, DWORD PTR [eax]
	push	0
	push	0
	push	0
	push	0
	push	edx
	push	eax
	call	DWORD PTR [ecx+12]
	test	eax, eax
	jns	SHORT $LN7@SK_WMI_Ser

; 211  :                      COM::base.wmi.bstrNameSpace,
; 212  :                      nullptr, // User name
; 213  :                      nullptr, // Password
; 214  :                      nullptr, // Locale
; 215  :                      0L,      // Security flags
; 216  :                      nullptr, // Authority
; 217  :                      nullptr, // Wbem context
; 218  :                      &COM::base.wmi.pNameSpace )
; 219  :              )
; 220  :      )
; 221  :   {
; 222  :     dll_log.Log (L"[ WMI Wbem ] Failure to Connect to Wbem Server (%s:%d) -- 0x%X",

	push	eax
	push	223					; 000000dfH
	push	OFFSET $SG165696
	push	OFFSET $SG165697

; 223  :       __FILEW__, __LINE__, hr);
; 224  :     goto WMI_CLEANUP;

	jmp	$LN29@SK_WMI_Ser
$LN7@SK_WMI_Ser:

; 225  :   }
; 226  : 
; 227  :   IUnknown* pUnk = nullptr;
; 228  : 
; 229  :   if (FAILED (COM::base.wmi.pNameSpace->QueryInterface (IID_IUnknown, (void **)&pUnk)))

	mov	eax, DWORD PTR ?base@COM@@3UBase@1@A+8
	lea	edx, DWORD PTR _pUnk$[ebp]
	push	edx
	mov	DWORD PTR _pUnk$[ebp], 0
	push	OFFSET _IID_IUnknown
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx]
	test	eax, eax
	js	$WMI_CLEANUP$30

; 230  :     goto WMI_CLEANUP;
; 231  : 
; 232  :   // Set the proxy so that impersonation of the client occurs.
; 233  :   if (FAILED (hr = CoSetProxyBlanket (

	push	0
	push	0
	push	3
	push	3
	push	0
	push	0
	push	10					; 0000000aH
	push	DWORD PTR _pUnk$[ebp]
	call	DWORD PTR __imp__CoSetProxyBlanket@32
	test	eax, eax
	jns	SHORT $LN11@SK_WMI_Ser

; 234  :                      pUnk,
; 235  :                      RPC_C_AUTHN_WINNT,
; 236  :                      RPC_C_AUTHZ_NONE,
; 237  :                      nullptr,
; 238  :                      RPC_C_AUTHN_LEVEL_CALL,
; 239  :                      RPC_C_IMP_LEVEL_IMPERSONATE,
; 240  :                      nullptr,
; 241  :                      EOAC_NONE )
; 242  :              )
; 243  :      )
; 244  :   {
; 245  :     dll_log.Log (L"[ WMI Wbem ] Failure to set proxy impersonation (%s:%d) -- 0x%X",

	push	eax
	push	246					; 000000f6H
	push	OFFSET $SG165702
	push	OFFSET $SG165703
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 246  :       __FILEW__, __LINE__, hr);
; 247  :     pUnk->Release ();

	mov	eax, DWORD PTR _pUnk$[ebp]
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
	jmp	$WMI_CLEANUP$30
$LN11@SK_WMI_Ser:

; 248  :     goto WMI_CLEANUP;
; 249  :   }
; 250  : 
; 251  :   pUnk->Release ();

	mov	eax, DWORD PTR _pUnk$[ebp]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]

; 252  : 
; 253  :   Sleep (1500UL);

	push	1500					; 000005dcH
	call	DWORD PTR __imp__Sleep@4

; 254  : 
; 255  :   COM::base.wmi.Unlock (                      );

	mov	esi, OFFSET ?base@COM@@3UBase@1@A+4
	mov	ecx, esi
	call	?Unlock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Unlock

; 256  : 
; 257  :   InterlockedExchange   (&COM::base.wmi.init, 1);

	xchg	DWORD PTR [esi], edi

; 258  : 
; 259  :   // Keep the thread alive indefinitely so that the WMI stuff continues running
; 260  :   WaitForSingleObject (COM::base.wmi.hShutdownServer, INFINITE);

	push	-1
	push	DWORD PTR ?base@COM@@3UBase@1@A+24
	call	DWORD PTR __imp__WaitForSingleObject@8

; 261  : 
; 262  : 
; 263  :   extern HMODULE hModOverlay;
; 264  :   if (hModOverlay != nullptr)

	cmp	DWORD PTR ?hModOverlay@@3PAUHINSTANCE__@@A, 0 ; hModOverlay
	je	$WMI_CLEANUP_WITHOUT_LOCK$31

; 265  :   {
; 266  :     dll_log.LogEx (true, L"[ SpecialK ] Unloading Steam Overlay... ");

	push	OFFSET $SG165706
	push	1
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	add	esp, 12					; 0000000cH

; 267  :   
; 268  :     FreeLibrary (hModOverlay);

	push	DWORD PTR ?hModOverlay@@3PAUHINSTANCE__@@A ; hModOverlay
	call	DWORD PTR __imp__FreeLibrary@4

; 269  :     hModOverlay = nullptr;
; 270  :   
; 271  :     dll_log.LogEx (false, L"done!\n");

	push	OFFSET $SG165707
	push	0
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	mov	DWORD PTR ?hModOverlay@@3PAUHINSTANCE__@@A, 0 ; hModOverlay
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	add	esp, 12					; 0000000cH
	jmp	$WMI_CLEANUP_WITHOUT_LOCK$31
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_WMI_ServerThread@@YGKPAX@Z$6:
	lea	ecx, DWORD PTR _auto_com$[ebp]
	jmp	??1SK_AutoCOMInit@@QAE@XZ		; SK_AutoCOMInit::~SK_AutoCOMInit
__ehhandler$?SK_WMI_ServerThread@@YGKPAX@Z:
	mov	eax, OFFSET __ehfuncinfo$?SK_WMI_ServerThread@@YGKPAX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_WMI_ServerThread@@YGKPAX@Z ENDP			; SK_WMI_ServerThread
; Function compile flags: /Ogtp
;	COMDAT ??0Base@COM@@QAE@XZ
_TEXT	SEGMENT
??0Base@COM@@QAE@XZ PROC				; COM::Base::Base, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], -1
	mov	DWORD PTR [ecx+24], 0
	ret	0
??0Base@COM@@QAE@XZ ENDP				; COM::Base::Base
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0WMI@Base@COM@@QAE@XZ
_TEXT	SEGMENT
??0WMI@Base@COM@@QAE@XZ PROC				; COM::Base::WMI::WMI, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], -1
	mov	DWORD PTR [ecx+20], 0
	ret	0
??0WMI@Base@COM@@QAE@XZ ENDP				; COM::Base::WMI::WMI
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
_TEXT	SEGMENT
?Unlock@WMI@Base@COM@@QAEXXZ PROC			; COM::Base::WMI::Unlock
; _this$ = ecx
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h

; 266  :     LeaveCriticalSection (cs_);

	mov	eax, DWORD PTR ?wmi_cs@@3PAVSK_Thread_HybridSpinlock@@A ; wmi_cs
	push	DWORD PTR [eax]
	call	DWORD PTR __imp__LeaveCriticalSection@4
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 168  : }

	ret	0
?Unlock@WMI@Base@COM@@QAEXXZ ENDP			; COM::Base::WMI::Unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
_TEXT	SEGMENT
?Lock@WMI@Base@COM@@QAEXXZ PROC				; COM::Base::WMI::Lock
; _this$ = ecx
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h

; 261  :     EnterCriticalSection (cs_);

	mov	eax, DWORD PTR ?wmi_cs@@3PAVSK_Thread_HybridSpinlock@@A ; wmi_cs
	push	DWORD PTR [eax]
	call	DWORD PTR __imp__EnterCriticalSection@4
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 161  : }

	ret	0
?Lock@WMI@Base@COM@@QAEXXZ ENDP				; COM::Base::WMI::Lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\widgets\widget.h
;	COMDAT ?isActive@SK_Widget@@QBE_NXZ
_TEXT	SEGMENT
?isActive@SK_Widget@@QBE_NXZ PROC			; SK_Widget::isActive, COMDAT
; _this$ = ecx

; 129  :         bool         isActive        (void) const { return    active;         }

	mov	al, BYTE PTR [ecx+185]
	ret	0
?isActive@SK_Widget@@QBE_NXZ ENDP			; SK_Widget::isActive
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ?unlock@SK_Thread_CriticalSection@@QAEXXZ
_TEXT	SEGMENT
?unlock@SK_Thread_CriticalSection@@QAEXXZ PROC		; SK_Thread_CriticalSection::unlock, COMDAT
; _this$ = ecx

; 266  :     LeaveCriticalSection (cs_);

	push	DWORD PTR [ecx]
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 267  :   }

	ret	0
?unlock@SK_Thread_CriticalSection@@QAEXXZ ENDP		; SK_Thread_CriticalSection::unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ?lock@SK_Thread_CriticalSection@@QAEXXZ
_TEXT	SEGMENT
?lock@SK_Thread_CriticalSection@@QAEXXZ PROC		; SK_Thread_CriticalSection::lock, COMDAT
; _this$ = ecx

; 261  :     EnterCriticalSection (cs_);

	push	DWORD PTR [ecx]
	call	DWORD PTR __imp__EnterCriticalSection@4

; 262  :   }

	ret	0
?lock@SK_Thread_CriticalSection@@QAEXXZ ENDP		; SK_Thread_CriticalSection::lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\framerate.h
;	COMDAT ?addSample@Stats@Framerate@SK@@QAEXNT_LARGE_INTEGER@@@Z
_TEXT	SEGMENT
_sample$ = 8						; size = 8
_time$ = 16						; size = 8
?addSample@Stats@Framerate@SK@@QAEXNT_LARGE_INTEGER@@@Z PROC ; SK::Framerate::Stats::addSample, COMDAT
; _this$ = ecx

; 112  :       {

	npad	2
	push	ebp
	mov	ebp, esp

; 113  :         data [samples % MAX_SAMPLES].val  = sample;

	mov	eax, DWORD PTR [ecx+1920]
	cdq
	push	esi
	mov	esi, 120				; 00000078H
	movsd	xmm0, QWORD PTR _sample$[ebp]
	idiv	esi
	add	edx, edx
	movsd	QWORD PTR [ecx+edx*8], xmm0

; 114  :         data [samples % MAX_SAMPLES].when = time;

	mov	eax, DWORD PTR [ecx+1920]
	cdq
	idiv	esi
	mov	eax, DWORD PTR _time$[ebp]
	add	edx, edx
	pop	esi
	mov	DWORD PTR [ecx+edx*8+8], eax
	mov	eax, DWORD PTR _time$[ebp+4]
	mov	DWORD PTR [ecx+edx*8+12], eax

; 115  : 
; 116  :         samples++;

	inc	DWORD PTR [ecx+1920]

; 117  :       }

	pop	ebp
	ret	16					; 00000010H
?addSample@Stats@Framerate@SK@@QAEXNT_LARGE_INTEGER@@@Z ENDP ; SK::Framerate::Stats::addSample
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0sample_t@Stats@Framerate@SK@@QAE@XZ
_TEXT	SEGMENT
??0sample_t@Stats@Framerate@SK@@QAE@XZ PROC		; SK::Framerate::Stats::sample_t::sample_t, COMDAT
; _this$ = ecx
	xorps	xmm0, xmm0
	mov	DWORD PTR [ecx+8], 0
	movsd	QWORD PTR [ecx], xmm0
	mov	eax, ecx
	mov	DWORD PTR [ecx+12], 0
	ret	0
??0sample_t@Stats@Framerate@SK@@QAE@XZ ENDP		; SK::Framerate::Stats::sample_t::sample_t
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\framerate.h
;	COMDAT ??0Stats@Framerate@SK@@QAE@XZ
_TEXT	SEGMENT
??0Stats@Framerate@SK@@QAE@XZ PROC			; SK::Framerate::Stats::Stats, COMDAT
; _this$ = ecx

; 100  :       Stats (void) {

	npad	2
	push	esi
	mov	esi, ecx
	mov	edx, 120				; 00000078H
	xorps	xmm0, xmm0
	lea	eax, DWORD PTR [esi+12]
$LL4@Stats:
	movsd	QWORD PTR [eax-12], xmm0
	lea	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [eax-20], 0
	mov	DWORD PTR [eax-16], 0
	sub	edx, 1
	jne	SHORT $LL4@Stats

; 101  :         QueryPerformanceFrequency (&freq);

	push	OFFSET ?freq@Stats@Framerate@SK@@2T_LARGE_INTEGER@@A ; SK::Framerate::Stats::freq

; 103  : 
; 104  :     #define MAX_SAMPLES 120
; 105  :       struct sample_t {
; 106  :         double        val  = 0.0;
; 107  :         LARGE_INTEGER when = { 0ULL };
; 108  :       } data [MAX_SAMPLES];
; 109  :       int    samples       = 0;

	mov	DWORD PTR [esi+1920], edx
	call	DWORD PTR __imp__QueryPerformanceFrequency@4
	mov	eax, esi
	pop	esi
	ret	0
??0Stats@Framerate@SK@@QAE@XZ ENDP			; SK::Framerate::Stats::Stats
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
;	COMDAT ?fpclassify@@YAHN@Z
_TEXT	SEGMENT
__X$ = 8						; size = 8
?fpclassify@@YAHN@Z PROC				; fpclassify, COMDAT

; 284  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 285  :         return _dtest(&_X);

	lea	eax, DWORD PTR __X$[ebp]
	push	eax
	call	DWORD PTR __imp___dtest
	add	esp, 4
	cwde

; 286  :     }

	pop	ebp
	ret	0
?fpclassify@@YAHN@Z ENDP				; fpclassify
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
_TEXT	SEGMENT
_name$2 = -572						; size = 512
_PercentUsage_BaseType$3 = -60				; size = 4
_PercentUsagePeakType$4 = -56				; size = 4
_PercentUsageType$5 = -52				; size = 4
_NameType$6 = -48					; size = 4
_update$1$ = -44					; size = 8
tv1561 = -40						; size = 4
_usage_peak$7 = -36					; size = 4
_usage$8 = -32						; size = 4
_size$9 = -28						; size = 4
_bytes$10 = -24						; size = 4
_iter$1$ = -20						; size = 4
_auto_com$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
_user$ = 8						; size = 4
?SK_MonitorPagefile@@YGKPAX@Z PROC			; SK_MonitorPagefile

; 1173 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?SK_MonitorPagefile@@YGKPAX@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 560				; 00000230H
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?base@COM@@3UBase@1@A+4
	push	ebx
	push	esi
	push	edi
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 1174 :   while (! ReadAcquire (&COM::base.wmi.init))

	test	eax, eax
	jne	SHORT $LN3@SK_Monitor
	mov	esi, DWORD PTR __imp__SleepEx@8
$LL2@SK_Monitor:

; 1175 :     SleepEx (150, FALSE);

	push	0
	push	150					; 00000096H
	call	esi
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?base@COM@@3UBase@1@A+4
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 1174 :   while (! ReadAcquire (&COM::base.wmi.init))

	test	eax, eax
	je	SHORT $LL2@SK_Monitor
$LN3@SK_Monitor:
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h

; 45   :     HRESULT hr = CoInitializeEx (NULL, COINIT_MULTITHREADED);

	push	0
	push	0

; 54   :   }
; 55   : 
; 56   : private:
; 57   :   bool success = false;

	xor	bl, bl
	call	DWORD PTR __imp__CoInitializeEx@8
	test	eax, eax
	movzx	ecx, bl
	mov	edx, 1
	cmovns	ecx, edx
	mov	BYTE PTR _auto_com$[ebp], cl
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 1181 :   COM::base.wmi.Lock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?Lock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Lock
	movss	xmm0, DWORD PTR ?config@@3Usk_config_t@@A+152

; 1182 : 
; 1183 :   pagefile_perf_t&  pagefile = pagefile_stats;
; 1184 : 
; 1185 :                     pagefile.dwNumReturned = 0;
; 1186 :                     pagefile.dwNumObjects  = 0;
; 1187 : 
; 1188 :   const double update = config.pagefile.interval;
; 1189 : 
; 1190 :   HRESULT hr;
; 1191 : 
; 1192 :   if (FAILED (hr = CoCreateInstance (

	push	OFFSET ?pagefile_stats@@3Upagefile_perf_t@@A+8
	push	OFFSET _IID_IWbemRefresher
	cvtps2pd xmm0, xmm0
	push	1
	push	0
	push	OFFSET _CLSID_WbemRefresher
	mov	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+32, 0
	mov	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+28, 0
	movsd	QWORD PTR _update$1$[ebp], xmm0
	call	DWORD PTR __imp__CoCreateInstance@20
	test	eax, eax
	jns	SHORT $LN12@SK_Monitor
$LN87@SK_Monitor:

; 1193 :                      CLSID_WbemRefresher,
; 1194 :                      nullptr,
; 1195 :                      CLSCTX_INPROC_SERVER,
; 1196 :                      IID_IWbemRefresher, 
; 1197 :                      (void**) &pagefile.pRefresher )
; 1198 :              )
; 1199 :      )
; 1200 :   {
; 1201 :     config.pagefile.show = false;

	mov	BYTE PTR ?config@@3Usk_config_t@@A+148, 0

; 1202 :     goto PAGEFILE_CLEANUP;

	jmp	$PAGEFILE_CLEANUP$116
$LN12@SK_Monitor:

; 1203 :   }
; 1204 : 
; 1205 :   if (FAILED (hr = pagefile.pRefresher->QueryInterface (

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+8
	push	OFFSET ?pagefile_stats@@3Upagefile_perf_t@@A+12
	push	OFFSET _IID_IWbemConfigureRefresher
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx]
	test	eax, eax
	jns	SHORT $LN14@SK_Monitor

; 1206 :                         IID_IWbemConfigureRefresher,
; 1207 :                         (void **)&pagefile.pConfig )
; 1208 :              )
; 1209 :      )
; 1210 :   {
; 1211 :     config.pagefile.show = false;

	mov	BYTE PTR ?config@@3Usk_config_t@@A+148, 0

; 1212 :     goto PAGEFILE_CLEANUP;

	jmp	$PAGEFILE_CLEANUP$116
$LN14@SK_Monitor:

; 1213 :   }
; 1214 : 
; 1215 :   // Add an enumerator to the refresher.
; 1216 :   if (FAILED (hr = pagefile.pConfig->AddEnum (

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+12
	push	OFFSET ?pagefile_stats@@3Upagefile_perf_t@@A+24
	push	OFFSET ?pagefile_stats@@3Upagefile_perf_t@@A+16
	push	0
	mov	ecx, DWORD PTR [eax]
	push	0
	push	OFFSET $SG166178
	push	DWORD PTR ?base@COM@@3UBase@1@A+8
	push	eax
	call	DWORD PTR [ecx+28]
	test	eax, eax
	jns	SHORT $LN16@SK_Monitor

; 1217 :                      COM::base.wmi.pNameSpace,
; 1218 :                      L"Win32_PerfRawData_PerfOS_PagingFile",
; 1219 :                      0,
; 1220 :                      nullptr,
; 1221 :                      &pagefile.pEnum,
; 1222 :                      &pagefile.lID )
; 1223 :              )
; 1224 :      )
; 1225 :   {
; 1226 :     config.pagefile.show = false;

	mov	BYTE PTR ?config@@3Usk_config_t@@A+148, 0

; 1227 :     goto PAGEFILE_CLEANUP;

	jmp	$PAGEFILE_CLEANUP$116
$LN16@SK_Monitor:

; 1228 :   }
; 1229 : 
; 1230 :   pagefile.pConfig->Release ();

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+12
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]

; 1231 :   pagefile.pConfig = nullptr;
; 1232 : 
; 1233 :   int iter = 0;

	xor	ebx, ebx
	mov	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+12, 0

; 1234 : 
; 1235 :   pagefile.hShutdownSignal = CreateEvent (nullptr, FALSE, FALSE, L"Pagefile Monitor Shutdown Signal");

	push	OFFSET $SG166180
	push	ebx
	push	ebx
	push	ebx
	mov	DWORD PTR _iter$1$[ebp], ebx
	call	DWORD PTR __imp__CreateEventW@16

; 1236 : 
; 1237 :   COM::base.wmi.Unlock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	mov	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+4, eax
	call	?Unlock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Unlock

; 1238 : 
; 1239 :   while (pagefile.lID != 0)

	cmp	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+24, ebx
	je	$LN112@SK_Monitor
	movsd	xmm0, QWORD PTR _update$1$[ebp]
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	call	__dtoui3
	mov	ecx, eax
	lea	esi, DWORD PTR [ebx+4]
	mov	DWORD PTR tv1561[ebp], ecx
	mov	edi, OFFSET ?pagefile_stats@@3Upagefile_perf_t@@A+28
$LL4@SK_Monitor:

; 1240 :   {
; 1241 :     if (WaitForSingleObject (pagefile.hShutdownSignal, DWORD (update * 1000.0)) == WAIT_OBJECT_0)

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+4
	push	ecx
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
	test	eax, eax
	je	$LN112@SK_Monitor

; 1242 :       break;
; 1243 : 
; 1244 :     // Only poll WMI while the pagefile stats are shown
; 1245 :     if (! config.pagefile.show)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+148, 0
	je	$LN100@SK_Monitor

; 1246 :       continue;
; 1247 : 
; 1248 :     pagefile.dwNumReturned = 0;
; 1249 : 
; 1250 :     COM::base.wmi.Lock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	mov	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+32, 0
	call	?Lock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Lock

; 1251 : 
; 1252 :     if (FAILED (hr = pagefile.pRefresher->Refresh (0L)))

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+8
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+12]
	test	eax, eax
	js	$LN87@SK_Monitor

; 1253 :     {
; 1254 :       config.pagefile.show = false;
; 1255 :       goto PAGEFILE_CLEANUP;
; 1256 :     }
; 1257 : 
; 1258 :     hr = pagefile.pEnum->GetObjects ( 0L,

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+16
	push	OFFSET ?pagefile_stats@@3Upagefile_perf_t@@A+32
	push	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+20
	push	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+28
	mov	ecx, DWORD PTR [eax]
	push	0
	push	eax
	call	DWORD PTR [ecx+20]

; 1259 :                                       pagefile.dwNumObjects,
; 1260 :                                       pagefile.apEnumAccess,
; 1261 :                                       &pagefile.dwNumReturned );
; 1262 : 
; 1263 :     // If the buffer was not big enough,
; 1264 :     // allocate a bigger buffer and retry.
; 1265 :     if (hr == WBEM_E_BUFFER_TOO_SMALL 
; 1266 :         && pagefile.dwNumReturned > pagefile.dwNumObjects)

	cmp	eax, -2147217348			; 8004103cH
	jne	$LN22@SK_Monitor
	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+32
	cmp	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+28
	jbe	$LN87@SK_Monitor

; 1267 :     {
; 1268 :       pagefile.apEnumAccess = new IWbemObjectAccess* [pagefile.dwNumReturned + 1];

	xor	ecx, ecx
	inc	eax
	mul	esi
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+20, edx

; 1269 :       if (pagefile.apEnumAccess == nullptr)

	test	edx, edx
	je	$LN52@SK_Monitor

; 1270 :       {
; 1271 :         hr = E_OUTOFMEMORY;
; 1272 :         goto PAGEFILE_CLEANUP;
; 1273 :       }
; 1274 : 
; 1275 :       SecureZeroMemory (pagefile.apEnumAccess,

	mov	esi, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+32
	lea	eax, DWORD PTR [esi*4]
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 17796:     while (cnt) {

	test	eax, eax
	je	SHORT $LN67@SK_Monitor
$LL66@SK_Monitor:

; 17797: 
; 17798: #if !defined(_M_CEE) && defined(_M_ARM)
; 17799: 
; 17800:         __iso_volatile_store8(vptr, 0);
; 17801: 
; 17802: #else
; 17803: 
; 17804:         *vptr = 0;

	mov	BYTE PTR [edx], 0

; 17805: 
; 17806: #endif
; 17807: 
; 17808:         vptr++;

	lea	edx, DWORD PTR [edx+1]

; 17809:         cnt--;

	sub	eax, 1
	jne	SHORT $LL66@SK_Monitor

; 17796:     while (cnt) {

	mov	esi, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+32
	mov	edx, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+20
$LN67@SK_Monitor:
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 1280 :       if (FAILED (hr = pagefile.pEnum->GetObjects ( 0L,

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+16
	push	OFFSET ?pagefile_stats@@3Upagefile_perf_t@@A+32
	push	edx
	push	esi
	mov	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+28, esi
	mov	ecx, DWORD PTR [eax]
	push	0
	push	eax
	call	DWORD PTR [ecx+20]
	test	eax, eax
	js	$LN87@SK_Monitor
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 3779 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+32
	mov	ecx, OFFSET ?pagefile_stats@@3Upagefile_perf_t@@A+32
	cmp	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+28
	cmovae	ecx, edi
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 1291 :       pagefile.dwNumReturned = std::min (pagefile.dwNumObjects, pagefile.dwNumReturned);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+32, eax

; 1292 :     }
; 1293 :     else

	jmp	SHORT $LN28@SK_Monitor
$LN22@SK_Monitor:

; 1294 :     {
; 1295 :       if (hr != WBEM_S_NO_ERROR)

	test	eax, eax
	jne	$LN87@SK_Monitor
$LN28@SK_Monitor:

; 1296 :       {
; 1297 :         hr = WBEM_E_NOT_FOUND;
; 1298 :         config.pagefile.show = false;
; 1299 :         goto PAGEFILE_CLEANUP;
; 1300 :       }
; 1301 :     }
; 1302 : 
; 1303 :     // First time through, get the handles.
; 1304 :     if (iter == 0)

	test	ebx, ebx
	jne	$LN41@SK_Monitor

; 1305 :     {
; 1306 :       if (pagefile.dwNumReturned <= 0)

	cmp	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+32, ebx
	jbe	$LN91@SK_Monitor

; 1311 :       }
; 1312 : 
; 1313 :       if (pagefile.apEnumAccess [0] == nullptr)

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+20
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	$LN92@SK_Monitor

; 1318 :       }
; 1319 : 
; 1320 :       CIMTYPE NameType;
; 1321 : 
; 1322 :       CIMTYPE PercentUsageType;
; 1323 :       CIMTYPE PercentUsagePeakType;
; 1324 :       CIMTYPE PercentUsage_BaseType;
; 1325 : 
; 1326 :       if (FAILED (hr = pagefile.apEnumAccess [0]->GetPropertyHandle (

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR _NameType$6[ebp]
	push	OFFSET ?pagefile_stats@@3Upagefile_perf_t@@A+40
	push	edx
	push	OFFSET $SG166201
	push	ecx
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN87@SK_Monitor

; 1327 :                             L"Name",
; 1328 :                             &NameType,
; 1329 :                             &pagefile.lNameHandle )
; 1330 :                  )
; 1331 :          )
; 1332 :       {
; 1333 :         config.pagefile.show = false;
; 1334 :         goto PAGEFILE_CLEANUP;
; 1335 :       }
; 1336 : 
; 1337 :       if (FAILED (hr = pagefile.apEnumAccess [0]->GetPropertyHandle (

	mov	ecx, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+20
	lea	edx, DWORD PTR _PercentUsageType$5[ebp]
	push	OFFSET ?pagefile_stats@@3Upagefile_perf_t@@A+44
	push	edx
	push	OFFSET $SG166204
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN87@SK_Monitor

; 1338 :                             L"PercentUsage",
; 1339 :                             &PercentUsageType,
; 1340 :                             &pagefile.lPercentUsageHandle )
; 1341 :                  )
; 1342 :          )
; 1343 :       {
; 1344 :         config.pagefile.show = false;
; 1345 :         goto PAGEFILE_CLEANUP;
; 1346 :       }
; 1347 : 
; 1348 :       if (FAILED (hr = pagefile.apEnumAccess [0]->GetPropertyHandle (

	mov	ecx, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+20
	lea	edx, DWORD PTR _PercentUsagePeakType$4[ebp]
	push	OFFSET ?pagefile_stats@@3Upagefile_perf_t@@A+48
	push	edx
	push	OFFSET $SG166207
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN87@SK_Monitor

; 1349 :                             L"PercentUsagePeak",
; 1350 :                             &PercentUsagePeakType,
; 1351 :                             &pagefile.lPercentUsagePeakHandle )
; 1352 :                  )
; 1353 :          )
; 1354 :       {
; 1355 :         config.pagefile.show = false;
; 1356 :         goto PAGEFILE_CLEANUP;
; 1357 :       }
; 1358 : 
; 1359 :       if (FAILED (hr = pagefile.apEnumAccess [0]->GetPropertyHandle (

	mov	ecx, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+20
	lea	edx, DWORD PTR _PercentUsage_BaseType$3[ebp]
	push	OFFSET ?pagefile_stats@@3Upagefile_perf_t@@A+52
	push	edx
	push	OFFSET $SG166210
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN87@SK_Monitor
$LN41@SK_Monitor:

; 1360 :                             L"PercentUsage_Base",
; 1361 :                             &PercentUsage_BaseType,
; 1362 :                             &pagefile.lPercentUsage_BaseHandle )
; 1363 :                  )
; 1364 :          )
; 1365 :       {
; 1366 :         config.pagefile.show = false;
; 1367 :         goto PAGEFILE_CLEANUP;
; 1368 :       }
; 1369 :     }
; 1370 : 
; 1371 :     for (unsigned int i = 0; i < pagefile.dwNumReturned; i++)

	xor	esi, esi
	cmp	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+32, esi
	jbe	$LN7@SK_Monitor
	mov	edi, OFFSET ?pagefile_stats@@3Upagefile_perf_t@@A+87
$LL8@SK_Monitor:

; 1372 :     {
; 1373 :       DWORD size;
; 1374 :       DWORD usage;
; 1375 :       DWORD usage_peak;
; 1376 : 
; 1377 :       if (FAILED (hr = pagefile.apEnumAccess [i]->ReadDWORD (

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+20
	lea	edx, DWORD PTR _usage$8[ebp]
	push	edx
	push	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+44
	mov	eax, DWORD PTR [eax+esi*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+120]
	test	eax, eax
	js	$PAGEFILE_CLEANUP$116

; 1378 :                                  pagefile.lPercentUsageHandle,
; 1379 :                                  &usage )
; 1380 :                  )
; 1381 :          )
; 1382 :       {
; 1383 :         goto PAGEFILE_CLEANUP;
; 1384 :       }
; 1385 : 
; 1386 :       if (FAILED (hr = pagefile.apEnumAccess [i]->ReadDWORD (

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+20
	lea	edx, DWORD PTR _usage_peak$7[ebp]
	push	edx
	push	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+48
	mov	eax, DWORD PTR [eax+esi*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+120]
	test	eax, eax
	js	$PAGEFILE_CLEANUP$116

; 1387 :                                  pagefile.lPercentUsagePeakHandle,
; 1388 :                                  &usage_peak )
; 1389 :                  )
; 1390 :          )
; 1391 :       {
; 1392 :         goto PAGEFILE_CLEANUP;
; 1393 :       }
; 1394 : 
; 1395 :       if (FAILED (hr = pagefile.apEnumAccess [i]->ReadDWORD (

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+20
	lea	edx, DWORD PTR _size$9[ebp]
	push	edx
	push	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+52
	mov	eax, DWORD PTR [eax+esi*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+120]
	test	eax, eax
	js	$PAGEFILE_CLEANUP$116

; 1396 :                                  pagefile.lPercentUsage_BaseHandle,
; 1397 :                                  &size )
; 1398 :                  )
; 1399 :          )
; 1400 :       {
; 1401 :         goto PAGEFILE_CLEANUP;
; 1402 :       }
; 1403 : 
; 1404 :       long    bytes      =  0;
; 1405 :       wchar_t name [256] = { };

	push	512					; 00000200H
	lea	eax, DWORD PTR _name$2[ebp]
	mov	DWORD PTR _bytes$10[ebp], 0
	push	0
	push	eax
	call	_memset

; 1406 : 
; 1407 :       if (FAILED (hr = pagefile.apEnumAccess [i]->ReadPropertyValue (

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+20
	lea	edx, DWORD PTR _name$2[ebp]
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR [eax+esi*4]
	push	edx
	lea	edx, DWORD PTR _bytes$10[ebp]
	push	edx
	mov	ecx, DWORD PTR [eax]
	push	510					; 000001feH
	push	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+40
	push	eax
	call	DWORD PTR [ecx+116]
	test	eax, eax
	js	$LN87@SK_Monitor

; 1408 :                              pagefile.lNameHandle,
; 1409 :                              sizeof (wchar_t) * 255,
; 1410 :                              &bytes,
; 1411 :                              reinterpret_cast <LPBYTE> (name) )
; 1412 :                  )
; 1413 :          )
; 1414 :       {
; 1415 :         config.pagefile.show = false;
; 1416 :         goto PAGEFILE_CLEANUP;
; 1417 :       }
; 1418 : 
; 1419 :       WideCharToMultiByte (CP_OEMCP, 0, name, 255, pagefile.pagefiles [i].name,

	push	0
	push	OFFSET $SG166220
	push	255					; 000000ffH
	lea	ebx, DWORD PTR [edi-31]
	push	ebx
	push	255					; 000000ffH
	lea	eax, DWORD PTR _name$2[ebp]
	push	eax
	push	0
	push	1
	call	DWORD PTR __imp__WideCharToMultiByte@32

; 1420 :                            255, " ", nullptr);
; 1421 : 
; 1422 :       pagefile.pagefiles [i].name [31] = '\0';

	mov	BYTE PTR [edi], 0

; 1423 : 
; 1424 :       if (i == (pagefile.dwNumReturned - 1))

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+32
	dec	eax
	cmp	esi, eax
	jne	SHORT $LN51@SK_Monitor

; 1425 :         strcpy (pagefile.pagefiles [i].name, "Total");

	mov	eax, DWORD PTR $SG166222
	mov	DWORD PTR [ebx], eax
	mov	ax, WORD PTR $SG166222+4
	mov	WORD PTR [ebx+4], ax
$LN51@SK_Monitor:

; 1426 : 
; 1427 :       pagefile.pagefiles [i].size  = (pagefile.pagefiles [i].size  + size) / 2;

	mov	eax, DWORD PTR [edi+225]
	add	eax, DWORD PTR _size$9[ebp]
	shr	eax, 1
	mov	DWORD PTR [edi+225], eax

; 1428 :       pagefile.pagefiles [i].usage = (pagefile.pagefiles [i].usage + usage)/ 2;

	mov	eax, DWORD PTR [edi+229]
	add	eax, DWORD PTR _usage$8[ebp]
	shr	eax, 1
	mov	DWORD PTR [edi+229], eax

; 1429 :       pagefile.pagefiles [i].usage_peak

	mov	eax, DWORD PTR [edi+233]
	add	eax, DWORD PTR _usage_peak$7[ebp]
	shr	eax, 1
	mov	DWORD PTR [edi+233], eax

; 1430 :                                    = (pagefile.pagefiles [i].usage_peak
; 1431 :                                                                    +
; 1432 :                                                                usage_peak) / 2;
; 1433 : 
; 1434 :       // Done with the object
; 1435 :       pagefile.apEnumAccess [i]->Release ();

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+20
	mov	eax, DWORD PTR [eax+esi*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]

; 1436 :       pagefile.apEnumAccess [i] = nullptr;

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+20
	add	edi, 268				; 0000010cH
	mov	DWORD PTR [eax+esi*4], 0
	inc	esi
	cmp	esi, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+32
	jb	$LL8@SK_Monitor
	mov	ebx, DWORD PTR _iter$1$[ebp]
	mov	edi, OFFSET ?pagefile_stats@@3Upagefile_perf_t@@A+28
$LN7@SK_Monitor:

; 1437 :     }
; 1438 : 
; 1439 :     pagefile.num_pagefiles = pagefile.dwNumReturned;

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+32

; 1440 :     pagefile.booting       = false;
; 1441 : 
; 1442 :     COM::base.wmi.Unlock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	mov	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+4344, eax
	mov	BYTE PTR ?pagefile_stats@@3Upagefile_perf_t@@A+36, 0
	call	?Unlock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Unlock

; 1443 : 
; 1444 :     ++iter;

	inc	ebx
	mov	esi, 4
	mov	DWORD PTR _iter$1$[ebp], ebx
$LN100@SK_Monitor:

; 1238 : 
; 1239 :   while (pagefile.lID != 0)

	cmp	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+24, 0
	je	SHORT $LN112@SK_Monitor
	mov	ecx, DWORD PTR tv1561[ebp]
	jmp	$LL4@SK_Monitor
$LN92@SK_Monitor:

; 1314 :       {
; 1315 :         dll_log.Log (L"[ WMI Wbem ] Pagefile apEnumAccess [0] = nullptr");

	push	OFFSET $SG166198
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8

; 1316 :         config.pagefile.show = false;

	mov	BYTE PTR ?config@@3Usk_config_t@@A+148, 0

; 1317 :         goto PAGEFILE_CLEANUP;

	jmp	SHORT $PAGEFILE_CLEANUP$116
$LN91@SK_Monitor:

; 1307 :       {
; 1308 :         dll_log.Log (L"[ WMI Wbem ] No pagefile exists");

	push	OFFSET $SG166195
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8

; 1309 :         config.pagefile.show = false;

	mov	BYTE PTR ?config@@3Usk_config_t@@A+148, 0

; 1310 :         goto PAGEFILE_CLEANUP;

	jmp	SHORT $PAGEFILE_CLEANUP$116
$LN112@SK_Monitor:

; 1445 :   }
; 1446 : 
; 1447 :   COM::base.wmi.Lock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	call	?Lock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Lock
$PAGEFILE_CLEANUP$116:

; 1448 : 
; 1449 : PAGEFILE_CLEANUP:
; 1450 :   //dll_log.Log (L" >> PAGEFILE_CLEANUP");
; 1451 : 
; 1452 :   if (pagefile.apEnumAccess != nullptr)

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+20
	test	eax, eax
	je	SHORT $LN52@SK_Monitor

; 1453 :   {
; 1454 :     for (unsigned int i = 0; i < pagefile.dwNumReturned; i++)

	xor	esi, esi
	cmp	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+32, esi
	jbe	SHORT $LN10@SK_Monitor
	npad	2
$LL11@SK_Monitor:

; 1455 :     {
; 1456 :       if (pagefile.apEnumAccess [i] != nullptr)

	mov	ecx, DWORD PTR [eax+esi*4]
	test	ecx, ecx
	je	SHORT $LN9@SK_Monitor

; 1457 :       {
; 1458 :         pagefile.apEnumAccess [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 1459 :         pagefile.apEnumAccess [i] = nullptr;

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+20
	mov	DWORD PTR [eax+esi*4], 0
	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+20
$LN9@SK_Monitor:

; 1453 :   {
; 1454 :     for (unsigned int i = 0; i < pagefile.dwNumReturned; i++)

	inc	esi
	cmp	esi, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+32
	jb	SHORT $LL11@SK_Monitor
$LN10@SK_Monitor:

; 1460 :       }
; 1461 :     }
; 1462 :     delete [] pagefile.apEnumAccess;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN52@SK_Monitor:

; 1463 :   }
; 1464 : 
; 1465 :   if (pagefile.pEnum)

	mov	ecx, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+16
	pop	edi
	pop	esi
	pop	ebx
	test	ecx, ecx
	je	SHORT $LN54@SK_Monitor

; 1466 :   {
; 1467 :     pagefile.pEnum->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 1468 :     pagefile.pEnum = nullptr;

	mov	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+16, 0
$LN54@SK_Monitor:

; 1469 :   }
; 1470 : 
; 1471 :   if (pagefile.pConfig != nullptr)

	mov	ecx, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+12
	test	ecx, ecx
	je	SHORT $LN55@SK_Monitor

; 1472 :   {
; 1473 :     pagefile.pConfig->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 1474 :     pagefile.pConfig = nullptr;

	mov	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+12, 0
$LN55@SK_Monitor:

; 1475 :   }
; 1476 : 
; 1477 :   if (pagefile.pRefresher != nullptr)

	mov	ecx, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+8
	test	ecx, ecx
	je	SHORT $LN56@SK_Monitor

; 1478 :   {
; 1479 :     pagefile.pRefresher->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 1480 :     pagefile.pRefresher = nullptr;

	mov	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+8, 0
$LN56@SK_Monitor:

; 1481 :   }
; 1482 : 
; 1483 :   if (pagefile.hShutdownSignal != INVALID_HANDLE_VALUE)

	cmp	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+4, -1
	je	SHORT $LN57@SK_Monitor

; 1484 :   {
; 1485 :     CloseHandle (pagefile.hShutdownSignal);

	mov	eax, DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+4
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 1486 :     pagefile.hShutdownSignal = INVALID_HANDLE_VALUE;

	mov	DWORD PTR ?pagefile_stats@@3Upagefile_perf_t@@A+4, -1
$LN57@SK_Monitor:

; 1487 :   }
; 1488 : 
; 1489 :   COM::base.wmi.Unlock   ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	call	?Unlock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Unlock
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h

; 52   :     if (success)

	cmp	BYTE PTR _auto_com$[ebp], 0
	je	SHORT $LN113@SK_Monitor

; 53   :       CoUninitialize ();

	call	DWORD PTR __imp__CoUninitialize@0
$LN113@SK_Monitor:
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 1492 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	xor	eax, eax
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_MonitorPagefile@@YGKPAX@Z$17:
	lea	ecx, DWORD PTR _auto_com$[ebp]
	jmp	??1SK_AutoCOMInit@@QAE@XZ		; SK_AutoCOMInit::~SK_AutoCOMInit
__ehhandler$?SK_MonitorPagefile@@YGKPAX@Z:
	mov	eax, OFFSET __ehfuncinfo$?SK_MonitorPagefile@@YGKPAX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_MonitorPagefile@@YGKPAX@Z ENDP			; SK_MonitorPagefile
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\framerate.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\framerate.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\framerate.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
_TEXT	SEGMENT
_name$2 = -292						; size = 128
_PercentIdleTimeType$3 = -164				; size = 4
_PercentDiskWriteTimeType$4 = -160			; size = 4
_PercentDiskReadTimeType$5 = -156			; size = 4
_PercentDiskTimeType$6 = -152				; size = 4
_DiskWriteBytesPerSecType$7 = -148			; size = 4
_DiskReadBytesPerSecType$8 = -144			; size = 4
_DiskBytesPerSecType$9 = -140				; size = 4
_NameType$10 = -136					; size = 4
_bytes_sec$11 = -132					; size = 8
_bytes_read_sec$12 = -124				; size = 8
_bytes_write_sec$13 = -116				; size = 8
_percent_write$14 = -108				; size = 8
_percent_read$15 = -100					; size = 8
_percent_load$16 = -92					; size = 8
_percent_idle$17 = -84					; size = 8
tv1928 = -76						; size = 4
$T18 = -72						; size = 4
_bytes$19 = -68						; size = 4
_update$1$ = -64					; size = 8
_read_mean$20 = -64					; size = 8
tv933 = -56						; size = 8
tv1905 = -52						; size = 4
_write_mean$21 = -48					; size = 8
tv1908 = -44						; size = 4
$T22 = -40						; size = 4
_iter$1$ = -36						; size = 4
_i$1$ = -32						; size = 4
tv953 = -28						; size = 8
tv943 = -28						; size = 8
_combined_mean$23 = -28					; size = 8
tv1918 = -20						; size = 4
_auto_com$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
_user$ = 8						; size = 4
?SK_MonitorDisk@@YGKPAX@Z PROC				; SK_MonitorDisk

; 756  : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?SK_MonitorDisk@@YGKPAX@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 280				; 00000118H
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?base@COM@@3UBase@1@A+4
	push	ebx
	push	esi
	push	edi
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 757  :   while (! ReadAcquire (&COM::base.wmi.init))

	test	eax, eax
	jne	SHORT $LN3@SK_Monitor
	mov	esi, DWORD PTR __imp__SleepEx@8
$LL2@SK_Monitor:

; 758  :     SleepEx (150, FALSE);

	push	0
	push	150					; 00000096H
	call	esi
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?base@COM@@3UBase@1@A+4
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 757  :   while (! ReadAcquire (&COM::base.wmi.init))

	test	eax, eax
	je	SHORT $LL2@SK_Monitor
$LN3@SK_Monitor:
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h

; 45   :     HRESULT hr = CoInitializeEx (NULL, COINIT_MULTITHREADED);

	push	0
	push	0

; 54   :   }
; 55   : 
; 56   : private:
; 57   :   bool success = false;

	xor	bl, bl
	call	DWORD PTR __imp__CoInitializeEx@8
	test	eax, eax
	movzx	ecx, bl
	mov	edx, 1
	cmovns	ecx, edx
	mov	BYTE PTR _auto_com$[ebp], cl
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 764  :   COM::base.wmi.Lock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?Lock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Lock
	movss	xmm0, DWORD PTR ?config@@3Usk_config_t@@A+136

; 765  : 
; 766  :   //Win32_PerfFormattedData_PerfDisk_LogicalDisk
; 767  : 
; 768  :   disk_perf_t&  disk  = disk_stats;
; 769  :   const double update = config.disk.interval;
; 770  : 
; 771  :   HRESULT hr;
; 772  : 
; 773  :   if (FAILED (hr = CoCreateInstance (

	push	OFFSET ?disk_stats@@3Udisk_perf_t@@A+8
	push	OFFSET _IID_IWbemRefresher
	cvtps2pd xmm0, xmm0
	push	1
	push	0
	push	OFFSET _CLSID_WbemRefresher
	movsd	QWORD PTR _update$1$[ebp], xmm0
	call	DWORD PTR __imp__CoCreateInstance@20
	test	eax, eax
	js	$LN216@SK_Monitor

; 774  :                      CLSID_WbemRefresher,
; 775  :                      nullptr,
; 776  :                      CLSCTX_INPROC_SERVER,
; 777  :                      IID_IWbemRefresher, 
; 778  :                      (void**) &disk.pRefresher )
; 779  :              )
; 780  :      )
; 781  :   {
; 782  :     goto DISK_CLEANUP;
; 783  :   }
; 784  : 
; 785  :   if (FAILED (hr = disk.pRefresher->QueryInterface (

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+8
	push	OFFSET ?disk_stats@@3Udisk_perf_t@@A+12
	push	OFFSET _IID_IWbemConfigureRefresher
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx]
	test	eax, eax
	js	$LN216@SK_Monitor

; 786  :                         IID_IWbemConfigureRefresher,
; 787  :                         (void **)&disk.pConfig )
; 788  :              )
; 789  :      )
; 790  :   {
; 791  :     goto DISK_CLEANUP;
; 792  :   }
; 793  : 
; 794  :   // Add an enumerator to the refresher.
; 795  :   if (FAILED (hr = disk.pConfig->AddEnum (

	cmp	DWORD PTR ?config@@3Usk_config_t@@A+140, 1
	mov	eax, OFFSET $SG166038
	mov	ecx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+12
	mov	esi, OFFSET $SG166039
	push	OFFSET ?disk_stats@@3Udisk_perf_t@@A+24
	push	OFFSET ?disk_stats@@3Udisk_perf_t@@A+16
	push	0
	mov	edx, DWORD PTR [ecx]
	cmovne	eax, esi
	push	0
	push	eax
	push	DWORD PTR ?base@COM@@3UBase@1@A+8
	push	ecx
	call	DWORD PTR [edx+28]
	test	eax, eax
	js	$LN216@SK_Monitor

; 796  :                      COM::base.wmi.pNameSpace,
; 797  :                      config.disk.type == 1 ? 
; 798  :                      L"Win32_PerfFormattedData_PerfDisk_LogicalDisk" :
; 799  :                      L"Win32_PerfFormattedData_PerfDisk_PhysicalDisk",
; 800  :                      0,
; 801  :                      nullptr,
; 802  :                      &disk.pEnum,
; 803  :                      &disk.lID )
; 804  :              )
; 805  :      )
; 806  :   {
; 807  :     goto DISK_CLEANUP;
; 808  :   }
; 809  : 
; 810  :   disk.pConfig->Release ();

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+12
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]

; 811  :   disk.pConfig = nullptr;
; 812  : 
; 813  :   int iter = 0;

	xor	ebx, ebx
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+12, 0

; 814  : 
; 815  :   disk.dwNumReturned = 0;
; 816  :   disk.dwNumObjects  = 0;
; 817  : 
; 818  :   disk.hShutdownSignal = CreateEvent (nullptr, FALSE, FALSE, L"DiskMon Shutdown Signal");

	push	OFFSET $SG166041
	push	ebx
	push	ebx
	push	ebx
	mov	DWORD PTR _iter$1$[ebp], ebx
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+32, ebx
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+28, ebx
	call	DWORD PTR __imp__CreateEventW@16

; 819  : 
; 820  :   COM::base.wmi.Unlock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+4, eax
	call	?Unlock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Unlock

; 821  : 
; 822  :   while (disk_stats.lID != 0)

	cmp	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+24, ebx
	je	$LN214@SK_Monitor
	movsd	xmm0, QWORD PTR _update$1$[ebp]
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	call	__dtoui3
	mov	ecx, eax
	mov	DWORD PTR tv1928[ebp], ecx
$LL4@SK_Monitor:

; 823  :   {
; 824  :     if (WaitForSingleObject (disk_stats.hShutdownSignal, DWORD (update * 1000.0)) == WAIT_OBJECT_0)

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+4
	push	ecx
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
	test	eax, eax
	je	$LN214@SK_Monitor

; 825  :       break;
; 826  : 
; 827  :     // Only poll WMI while the data view is visible
; 828  :     if (! config.disk.show)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+132, 0
	je	$LN190@SK_Monitor

; 829  :       continue;
; 830  : 
; 831  :     extern LARGE_INTEGER SK_QueryPerf (void);
; 832  :      LARGE_INTEGER now = SK_QueryPerf ();

	call	?SK_QueryPerf@@YA?AT_LARGE_INTEGER@@XZ	; SK_QueryPerf
	mov	esi, eax

; 833  : 
; 834  :     disk.dwNumReturned = 0;

	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+32, 0
	mov	edi, edx
	mov	DWORD PTR $T22[ebp], esi

; 835  : 
; 836  :     COM::base.wmi.Lock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	mov	DWORD PTR $T18[ebp], edi
	call	?Lock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Lock

; 837  : 
; 838  :     if (FAILED (hr = disk.pRefresher->Refresh (0L)))

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+8
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+12]
	test	eax, eax
	js	$LN216@SK_Monitor

; 839  :     {
; 840  :       goto DISK_CLEANUP;
; 841  :     }
; 842  : 
; 843  :     hr = disk.pEnum->GetObjects ( 0L,

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+16
	push	OFFSET ?disk_stats@@3Udisk_perf_t@@A+32
	push	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	push	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+28
	mov	ecx, DWORD PTR [eax]
	push	0
	push	eax
	call	DWORD PTR [ecx+20]

; 844  :                                   disk.dwNumObjects,
; 845  :                                   disk.apEnumAccess,
; 846  :                                  &disk.dwNumReturned );
; 847  : 
; 848  :     // If the buffer was not big enough,
; 849  :     // allocate a bigger buffer and retry.
; 850  :     if (hr == WBEM_E_BUFFER_TOO_SMALL 
; 851  :         && disk.dwNumReturned > disk.dwNumObjects)

	cmp	eax, -2147217348			; 8004103cH
	jne	$LN25@SK_Monitor
	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+32
	cmp	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+28
	jbe	$DISK_CLEANUP$219

; 852  :     {
; 853  :       disk.apEnumAccess = new IWbemObjectAccess* [disk.dwNumReturned];

	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20, edx

; 854  :       if (disk.apEnumAccess == nullptr)

	test	edx, edx
	je	$LN69@SK_Monitor

; 855  :       {
; 856  :         hr = E_OUTOFMEMORY;
; 857  :         goto DISK_CLEANUP;
; 858  :       }
; 859  : 
; 860  :       SecureZeroMemory (disk.apEnumAccess,

	mov	ebx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+32
	lea	eax, DWORD PTR [ebx*4]
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 17796:     while (cnt) {

	test	eax, eax
	je	SHORT $LN93@SK_Monitor
	npad	1
$LL92@SK_Monitor:

; 17797: 
; 17798: #if !defined(_M_CEE) && defined(_M_ARM)
; 17799: 
; 17800:         __iso_volatile_store8(vptr, 0);
; 17801: 
; 17802: #else
; 17803: 
; 17804:         *vptr = 0;

	mov	BYTE PTR [edx], 0

; 17805: 
; 17806: #endif
; 17807: 
; 17808:         vptr++;

	lea	edx, DWORD PTR [edx+1]

; 17809:         cnt--;

	sub	eax, 1
	jne	SHORT $LL92@SK_Monitor

; 17796:     while (cnt) {

	mov	ebx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+32
	mov	edx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
$LN93@SK_Monitor:
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 865  :       if (FAILED (hr = disk.pEnum->GetObjects ( 0L,

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+16
	push	OFFSET ?disk_stats@@3Udisk_perf_t@@A+32
	push	edx
	push	ebx
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+28, ebx
	mov	ecx, DWORD PTR [eax]
	push	0
	push	eax
	call	DWORD PTR [ecx+20]
	test	eax, eax
	js	$LN216@SK_Monitor
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 3779 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+32
	mov	ecx, OFFSET ?disk_stats@@3Udisk_perf_t@@A+32
	cmp	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+28
	mov	eax, OFFSET ?disk_stats@@3Udisk_perf_t@@A+28
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 877  :     else

	mov	ebx, DWORD PTR _iter$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 3779 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	cmovae	ecx, eax
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 875  :       disk.dwNumReturned = std::min (disk.dwNumObjects, disk.dwNumReturned);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+32, eax

; 877  :     else

	jmp	SHORT $LN31@SK_Monitor
$LN25@SK_Monitor:

; 878  :     {
; 879  :       if (hr != WBEM_S_NO_ERROR)

	test	eax, eax
	jne	$LN216@SK_Monitor
	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+32
$LN31@SK_Monitor:

; 880  :       {
; 881  :         hr = WBEM_E_NOT_FOUND;
; 882  :         goto DISK_CLEANUP;
; 883  :       }
; 884  :     }
; 885  : 
; 886  :     // First time through, get the handles.
; 887  :     if (iter == 0)

	test	ebx, ebx
	jne	$LN50@SK_Monitor

; 888  :     {
; 889  :       CIMTYPE NameType;
; 890  : 
; 891  :       CIMTYPE DiskBytesPerSecType;
; 892  :       CIMTYPE DiskReadBytesPerSecType;
; 893  :       CIMTYPE DiskWriteBytesPerSecType;
; 894  : 
; 895  :       CIMTYPE PercentDiskTimeType;
; 896  :       CIMTYPE PercentDiskReadTimeType;
; 897  :       CIMTYPE PercentDiskWriteTimeType;
; 898  :       CIMTYPE PercentIdleTimeType;
; 899  : 
; 900  :       if (disk.apEnumAccess [0] == nullptr)

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	$LN166@SK_Monitor

; 904  :       }
; 905  : 
; 906  :       if (FAILED (hr = disk.apEnumAccess [0]->GetPropertyHandle (

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR _NameType$10[ebp]
	push	OFFSET ?disk_stats@@3Udisk_perf_t@@A+40
	push	edx
	push	OFFSET $SG166059
	push	ecx
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN216@SK_Monitor

; 907  :                             L"Name",
; 908  :                             &NameType,
; 909  :                             &disk.lNameHandle )
; 910  :                  )
; 911  :          )
; 912  :       {
; 913  :         goto DISK_CLEANUP;
; 914  :       }
; 915  : 
; 916  :       if (FAILED (hr = disk.apEnumAccess [0]->GetPropertyHandle (

	mov	ecx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	lea	edx, DWORD PTR _DiskBytesPerSecType$9[ebp]
	push	OFFSET ?disk_stats@@3Udisk_perf_t@@A+44
	push	edx
	push	OFFSET $SG166062
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN216@SK_Monitor

; 917  :                             L"DiskBytesPerSec",
; 918  :                             &DiskBytesPerSecType,
; 919  :                             &disk.lDiskBytesPerSecHandle )
; 920  :                  )
; 921  :          )
; 922  :       {
; 923  :         goto DISK_CLEANUP;
; 924  :       }
; 925  : 
; 926  :       if (FAILED (hr = disk.apEnumAccess [0]->GetPropertyHandle (

	mov	ecx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	lea	edx, DWORD PTR _DiskReadBytesPerSecType$8[ebp]
	push	OFFSET ?disk_stats@@3Udisk_perf_t@@A+48
	push	edx
	push	OFFSET $SG166065
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN216@SK_Monitor

; 927  :                             L"DiskReadBytesPerSec",
; 928  :                             &DiskReadBytesPerSecType,
; 929  :                             &disk.lDiskReadBytesPerSecHandle )
; 930  :                  )
; 931  :          )
; 932  :       {
; 933  :         goto DISK_CLEANUP;
; 934  :       }
; 935  : 
; 936  :       if (FAILED (hr = disk.apEnumAccess [0]->GetPropertyHandle (

	mov	ecx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	lea	edx, DWORD PTR _DiskWriteBytesPerSecType$7[ebp]
	push	OFFSET ?disk_stats@@3Udisk_perf_t@@A+52
	push	edx
	push	OFFSET $SG166068
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN216@SK_Monitor

; 937  :                             L"DiskWriteBytesPerSec",
; 938  :                             &DiskWriteBytesPerSecType,
; 939  :                             &disk.lDiskWriteBytesPerSecHandle )
; 940  :                  )
; 941  :          )
; 942  :       {
; 943  :         goto DISK_CLEANUP;
; 944  :       }
; 945  : 
; 946  :       if (FAILED (hr = disk.apEnumAccess [0]->GetPropertyHandle (

	mov	ecx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	lea	edx, DWORD PTR _PercentDiskTimeType$6[ebp]
	push	OFFSET ?disk_stats@@3Udisk_perf_t@@A+64
	push	edx
	push	OFFSET $SG166071
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN216@SK_Monitor

; 947  :                             L"PercentDiskTime",
; 948  :                             &PercentDiskTimeType,
; 949  :                             &disk.lPercentDiskTimeHandle )
; 950  :                  )
; 951  :          )
; 952  :       {
; 953  :         goto DISK_CLEANUP;
; 954  :       }
; 955  : 
; 956  :       if (FAILED (hr = disk.apEnumAccess [0]->GetPropertyHandle (

	mov	ecx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	lea	edx, DWORD PTR _PercentDiskReadTimeType$5[ebp]
	push	OFFSET ?disk_stats@@3Udisk_perf_t@@A+56
	push	edx
	push	OFFSET $SG166074
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN216@SK_Monitor

; 957  :                             L"PercentDiskReadTime",
; 958  :                             &PercentDiskReadTimeType,
; 959  :                             &disk.lPercentDiskReadTimeHandle )
; 960  :                  )
; 961  :          )
; 962  :       {
; 963  :         goto DISK_CLEANUP;
; 964  :       }
; 965  : 
; 966  :       if (FAILED (hr = disk.apEnumAccess [0]->GetPropertyHandle (

	mov	ecx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	lea	edx, DWORD PTR _PercentDiskWriteTimeType$4[ebp]
	push	OFFSET ?disk_stats@@3Udisk_perf_t@@A+60
	push	edx
	push	OFFSET $SG166077
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN216@SK_Monitor

; 967  :                             L"PercentDiskWriteTime",
; 968  :                             &PercentDiskWriteTimeType,
; 969  :                             &disk.lPercentDiskWriteTimeHandle )
; 970  :                  )
; 971  :          )
; 972  :       {
; 973  :         goto DISK_CLEANUP;
; 974  :       }
; 975  : 
; 976  :       if (FAILED (hr = disk.apEnumAccess [0]->GetPropertyHandle (

	mov	ecx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	lea	edx, DWORD PTR _PercentIdleTimeType$3[ebp]
	push	OFFSET ?disk_stats@@3Udisk_perf_t@@A+68
	push	edx
	push	OFFSET $SG166080
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN216@SK_Monitor
	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+32
$LN50@SK_Monitor:

; 977  :                             L"PercentIdleTime",
; 978  :                             &PercentIdleTimeType,
; 979  :                             &disk.lPercentIdleTimeHandle )
; 980  :                  )
; 981  :          )
; 982  :       {
; 983  :         goto DISK_CLEANUP;
; 984  :       }
; 985  :     }
; 986  : 
; 987  :     for (unsigned int i = 0; i < disk.dwNumReturned; i++)

	xor	ebx, ebx
	mov	DWORD PTR _i$1$[ebp], ebx
	test	eax, eax
	je	$LN7@SK_Monitor
	npad	6
$LL8@SK_Monitor:

; 988  :     {
; 989  :       uint64_t percent_read;
; 990  :       uint64_t percent_write;
; 991  :       uint64_t percent_load;
; 992  :       uint64_t percent_idle;
; 993  : 
; 994  :       uint64_t bytes_sec;
; 995  :       uint64_t bytes_read_sec;
; 996  :       uint64_t bytes_write_sec;
; 997  : 
; 998  :       if (FAILED (hr = disk.apEnumAccess [i]->ReadQWORD (

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	lea	edx, DWORD PTR _percent_read$15[ebp]
	push	edx
	push	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+56
	mov	eax, DWORD PTR [eax+ebx*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+128]
	test	eax, eax
	js	$LN216@SK_Monitor

; 999  :                              disk.lPercentDiskReadTimeHandle,
; 1000 :                             &percent_read )
; 1001 :                  )
; 1002 :          )
; 1003 :       {
; 1004 :         goto DISK_CLEANUP;
; 1005 :       }
; 1006 : 
; 1007 :       if (FAILED (hr = disk.apEnumAccess [i]->ReadQWORD (

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	lea	edx, DWORD PTR _percent_write$14[ebp]
	push	edx
	push	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+60
	mov	eax, DWORD PTR [eax+ebx*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+128]
	test	eax, eax
	js	$LN216@SK_Monitor

; 1008 :                              disk.lPercentDiskWriteTimeHandle,
; 1009 :                             &percent_write )
; 1010 :                  )
; 1011 :          )
; 1012 :       {
; 1013 :         goto DISK_CLEANUP;
; 1014 :       }
; 1015 : 
; 1016 :       if (FAILED (hr = disk.apEnumAccess [i]->ReadQWORD (

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	lea	edx, DWORD PTR _percent_load$16[ebp]
	push	edx
	push	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+64
	mov	eax, DWORD PTR [eax+ebx*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+128]
	test	eax, eax
	js	$LN216@SK_Monitor

; 1017 :                              disk.lPercentDiskTimeHandle,
; 1018 :                             &percent_load )
; 1019 :                  )
; 1020 :          )
; 1021 :       {
; 1022 :         goto DISK_CLEANUP;
; 1023 :       }
; 1024 : 
; 1025 :       if (FAILED (hr = disk.apEnumAccess [i]->ReadQWORD (

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	lea	edx, DWORD PTR _percent_idle$17[ebp]
	push	edx
	push	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+68
	mov	eax, DWORD PTR [eax+ebx*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+128]
	test	eax, eax
	js	$LN216@SK_Monitor

; 1026 :                              disk.lPercentIdleTimeHandle,
; 1027 :                             &percent_idle )
; 1028 :                  )
; 1029 :          )
; 1030 :       {
; 1031 :         goto DISK_CLEANUP;
; 1032 :       }
; 1033 : 
; 1034 :       if (FAILED (hr = disk.apEnumAccess [i]->ReadQWORD (

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	lea	edx, DWORD PTR _bytes_sec$11[ebp]
	push	edx
	push	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+44
	mov	eax, DWORD PTR [eax+ebx*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+128]
	test	eax, eax
	js	$LN216@SK_Monitor

; 1035 :                              disk.lDiskBytesPerSecHandle,
; 1036 :                             &bytes_sec )
; 1037 :                  )
; 1038 :          )
; 1039 :       {
; 1040 :         goto DISK_CLEANUP;
; 1041 :       }
; 1042 : 
; 1043 :       if (FAILED (hr = disk.apEnumAccess [i]->ReadQWORD (

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	lea	edx, DWORD PTR _bytes_write_sec$13[ebp]
	push	edx
	push	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+52
	mov	eax, DWORD PTR [eax+ebx*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+128]
	test	eax, eax
	js	$LN216@SK_Monitor

; 1044 :                              disk.lDiskWriteBytesPerSecHandle,
; 1045 :                             &bytes_write_sec )
; 1046 :                  )
; 1047 :          )
; 1048 :       {
; 1049 :         goto DISK_CLEANUP;
; 1050 :       }
; 1051 : 
; 1052 :       if (FAILED (hr = disk.apEnumAccess [i]->ReadQWORD (

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	lea	edx, DWORD PTR _bytes_read_sec$12[ebp]
	push	edx
	push	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+48
	mov	eax, DWORD PTR [eax+ebx*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+128]
	test	eax, eax
	js	$LN216@SK_Monitor

; 1053 :                              disk.lDiskReadBytesPerSecHandle,
; 1054 :                             &bytes_read_sec )
; 1055 :                  )
; 1056 :          )
; 1057 :       {
; 1058 :         goto DISK_CLEANUP;
; 1059 :       }
; 1060 : 
; 1061 :       long    bytes     =  0;
; 1062 :       wchar_t name [64] = { };

	push	128					; 00000080H
	lea	eax, DWORD PTR _name$2[ebp]
	mov	DWORD PTR _bytes$19[ebp], 0
	push	0
	push	eax
	call	_memset

; 1063 : 
; 1064 :       if (FAILED (hr = disk.apEnumAccess [i]->ReadPropertyValue (

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	lea	edx, DWORD PTR _name$2[ebp]
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR [eax+ebx*4]
	push	edx
	lea	edx, DWORD PTR _bytes$19[ebp]
	push	edx
	mov	ecx, DWORD PTR [eax]
	push	128					; 00000080H
	push	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+40
	push	eax
	call	DWORD PTR [ecx+116]
	test	eax, eax
	js	$LN216@SK_Monitor

; 1065 :                              disk.lNameHandle,
; 1066 :                              sizeof (wchar_t) * 64,
; 1067 :                              &bytes,
; 1068 :                              reinterpret_cast <LPBYTE> (name) )
; 1069 :                  )
; 1070 :          )
; 1071 :       {
; 1072 :         goto DISK_CLEANUP;
; 1073 :       }
; 1074 : 
; 1075 :       WideCharToMultiByte (CP_OEMCP, 0, name, 31, disk.disks [i].name, 31, " ", nullptr);

	push	0
	imul	eax, ebx, 88
	push	OFFSET $SG166098
	push	31					; 0000001fH
	mov	DWORD PTR tv1918[ebp], eax
	lea	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[eax+72]
	push	eax
	push	31					; 0000001fH
	lea	eax, DWORD PTR _name$2[ebp]
	push	eax
	push	0
	push	1
	call	DWORD PTR __imp__WideCharToMultiByte@32

; 1076 :       disk.disks [i].name [31] = '\0';

	mov	edx, DWORD PTR tv1918[ebp]
	mov	BYTE PTR ?disk_stats@@3Udisk_perf_t@@A[edx+103], 0

; 1077 : 
; 1078 :       if (i == 0)

	test	ebx, ebx
	jne	SHORT $LN68@SK_Monitor

; 1079 :         strcpy (disk.disks [i].name, "Total");

	mov	eax, DWORD PTR $SG166100
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+72, eax
	mov	ax, WORD PTR $SG166100+4
	mov	WORD PTR ?disk_stats@@3Udisk_perf_t@@A+76, ax
$LN68@SK_Monitor:

; 1083 :       static SK::Framerate::Stats write_rate    [16];

	mov	eax, DWORD PTR __tls_index
	mov	ecx, DWORD PTR fs:__tls_array
	mov	BYTE PTR ?disk_stats@@3Udisk_perf_t@@A[edx+87], 0
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ?$TSS0@?ED@??SK_MonitorDisk@@YGKPAX@Z@4HA
	cmp	eax, DWORD PTR __Init_thread_epoch[ecx]
	jle	$LN9@SK_Monitor
	push	OFFSET ?$TSS0@?ED@??SK_MonitorDisk@@YGKPAX@Z@4HA
	call	__Init_thread_header
	add	esp, 4
	cmp	DWORD PTR ?$TSS0@?ED@??SK_MonitorDisk@@YGKPAX@Z@4HA, -1
	jne	$LN217@SK_Monitor
	mov	esi, 16					; 00000010H
	mov	ebx, OFFSET ?write_rate@?ED@??SK_MonitorDisk@@YGKPAX@Z@4PAVStats@Framerate@SK@@A+1920
	npad	7
$LL99@SK_Monitor:
	dec	esi
	lea	eax, DWORD PTR [ebx-1908]
	mov	ecx, 120				; 00000078H
	xorps	xmm0, xmm0
	npad	1
$LL105@SK_Monitor:
	movsd	QWORD PTR [eax-12], xmm0
	lea	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [eax-20], 0
	mov	DWORD PTR [eax-16], 0
	sub	ecx, 1
	jne	SHORT $LL105@SK_Monitor
; File c:\users\andon\source\repos\specialk\include\specialk\framerate.h

; 101  :         QueryPerformanceFrequency (&freq);

	push	OFFSET ?freq@Stats@Framerate@SK@@2T_LARGE_INTEGER@@A ; SK::Framerate::Stats::freq

; 102  :       }
; 103  : 
; 104  :     #define MAX_SAMPLES 120
; 105  :       struct sample_t {
; 106  :         double        val  = 0.0;
; 107  :         LARGE_INTEGER when = { 0ULL };
; 108  :       } data [MAX_SAMPLES];
; 109  :       int    samples       = 0;

	mov	DWORD PTR [ebx], ecx
	call	DWORD PTR __imp__QueryPerformanceFrequency@4
	add	ebx, 1928				; 00000788H
	test	esi, esi
	jne	SHORT $LL99@SK_Monitor
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 1084 :       static SK::Framerate::Stats read_rate     [16];

	mov	edi, 16					; 00000010H
	mov	ebx, OFFSET ?read_rate@?ED@??SK_MonitorDisk@@YGKPAX@Z@4PAVStats@Framerate@SK@@A+1920
	npad	4
$LL112@SK_Monitor:
	dec	edi
	lea	eax, DWORD PTR [ebx-1908]
	mov	ecx, 120				; 00000078H
	xorps	xmm0, xmm0
	npad	1
$LL118@SK_Monitor:
	movsd	QWORD PTR [eax-12], xmm0
	lea	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [eax-20], 0
	mov	DWORD PTR [eax-16], 0
	sub	ecx, 1
	jne	SHORT $LL118@SK_Monitor
; File c:\users\andon\source\repos\specialk\include\specialk\framerate.h

; 101  :         QueryPerformanceFrequency (&freq);

	push	OFFSET ?freq@Stats@Framerate@SK@@2T_LARGE_INTEGER@@A ; SK::Framerate::Stats::freq

; 102  :       }
; 103  : 
; 104  :     #define MAX_SAMPLES 120
; 105  :       struct sample_t {
; 106  :         double        val  = 0.0;
; 107  :         LARGE_INTEGER when = { 0ULL };
; 108  :       } data [MAX_SAMPLES];
; 109  :       int    samples       = 0;

	mov	DWORD PTR [ebx], ecx
	call	DWORD PTR __imp__QueryPerformanceFrequency@4
	add	ebx, 1928				; 00000788H
	test	edi, edi
	jne	SHORT $LL112@SK_Monitor
	mov	edi, DWORD PTR $T18[ebp]
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 1085 :       static SK::Framerate::Stats combined_rate [16];

	mov	esi, 16					; 00000010H
	mov	ebx, OFFSET ?combined_rate@?ED@??SK_MonitorDisk@@YGKPAX@Z@4PAVStats@Framerate@SK@@A+1920
	npad	1
$LL125@SK_Monitor:
	dec	esi
	lea	eax, DWORD PTR [ebx-1908]
	mov	ecx, 120				; 00000078H
	xorps	xmm0, xmm0
	npad	1
$LL131@SK_Monitor:
	movsd	QWORD PTR [eax-12], xmm0
	lea	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [eax-20], 0
	mov	DWORD PTR [eax-16], 0
	sub	ecx, 1
	jne	SHORT $LL131@SK_Monitor
; File c:\users\andon\source\repos\specialk\include\specialk\framerate.h

; 101  :         QueryPerformanceFrequency (&freq);

	push	OFFSET ?freq@Stats@Framerate@SK@@2T_LARGE_INTEGER@@A ; SK::Framerate::Stats::freq

; 102  :       }
; 103  : 
; 104  :     #define MAX_SAMPLES 120
; 105  :       struct sample_t {
; 106  :         double        val  = 0.0;
; 107  :         LARGE_INTEGER when = { 0ULL };
; 108  :       } data [MAX_SAMPLES];
; 109  :       int    samples       = 0;

	mov	DWORD PTR [ebx], ecx
	call	DWORD PTR __imp__QueryPerformanceFrequency@4
	add	ebx, 1928				; 00000788H
	test	esi, esi
	jne	SHORT $LL125@SK_Monitor
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 1083 :       static SK::Framerate::Stats write_rate    [16];

	push	OFFSET ?$TSS0@?ED@??SK_MonitorDisk@@YGKPAX@Z@4HA
	call	__Init_thread_footer
	mov	esi, DWORD PTR $T22[ebp]
	add	esp, 4
	mov	ebx, DWORD PTR _i$1$[ebp]
$LN217@SK_Monitor:
	mov	edx, DWORD PTR tv1918[ebp]
$LN9@SK_Monitor:

; 1086 : 
; 1087 :       disk.disks [i].percent_idle   = (disk.disks [i].percent_idle   + percent_idle)   / 2;

	mov	ecx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[edx+128]
	add	ecx, DWORD PTR _percent_idle$17[ebp]
	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[edx+132]
	adc	eax, DWORD PTR _percent_idle$17[ebp+4]
	shrd	ecx, eax, 1

; 1088 :       disk.disks [i].percent_load   = (disk.disks [i].percent_load   + percent_load)   / 2;
; 1089 :       disk.disks [i].percent_read   = (disk.disks [i].percent_read   + percent_read)   / 2;
; 1090 :       disk.disks [i].percent_write  = (disk.disks [i].percent_write  + percent_write)  / 2;
; 1091 : 
; 1092 :       write_rate    [i].addSample ( static_cast <double> (bytes_write_sec), now );

	push	edi
	shr	eax, 1
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[edx+128], ecx
	mov	ecx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[edx+104]
	add	ecx, DWORD PTR _percent_load$16[ebp]
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[edx+132], eax
	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[edx+108]
	adc	eax, DWORD PTR _percent_load$16[ebp+4]
	shrd	ecx, eax, 1
	push	esi
	shr	eax, 1
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[edx+104], ecx
	mov	ecx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[edx+120]
	add	ecx, DWORD PTR _percent_read$15[ebp]
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[edx+108], eax
	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[edx+124]
	adc	eax, DWORD PTR _percent_read$15[ebp+4]
	shrd	ecx, eax, 1
	shr	eax, 1
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[edx+120], ecx
	mov	ecx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[edx+112]
	add	ecx, DWORD PTR _percent_write$14[ebp]
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[edx+124], eax
	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[edx+116]
	adc	eax, DWORD PTR _percent_write$14[ebp+4]
	shrd	ecx, eax, 1
	imul	ebx, ebx, 1928
	shr	eax, 1
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[edx+116], eax
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[edx+112], ecx
	mov	edx, DWORD PTR _bytes_write_sec$13[ebp+4]
	mov	ecx, DWORD PTR _bytes_write_sec$13[ebp]
	lea	eax, DWORD PTR ?write_rate@?ED@??SK_MonitorDisk@@YGKPAX@Z@4PAVStats@Framerate@SK@@A[ebx]
	mov	DWORD PTR tv1908[ebp], eax
	call	__ultod3
	sub	esp, 8
	lea	ecx, DWORD PTR ?write_rate@?ED@??SK_MonitorDisk@@YGKPAX@Z@4PAVStats@Framerate@SK@@A[ebx]
	movsd	QWORD PTR [esp], xmm0
	call	?addSample@Stats@Framerate@SK@@QAEXNT_LARGE_INTEGER@@@Z ; SK::Framerate::Stats::addSample

; 1093 :       read_rate     [i].addSample (static_cast <double> (bytes_read_sec),   now );

	mov	edx, DWORD PTR _bytes_read_sec$12[ebp+4]
	lea	eax, DWORD PTR ?read_rate@?ED@??SK_MonitorDisk@@YGKPAX@Z@4PAVStats@Framerate@SK@@A[ebx]
	mov	ecx, DWORD PTR _bytes_read_sec$12[ebp]
	push	edi
	push	esi
	mov	DWORD PTR tv1905[ebp], eax
	call	__ultod3
	sub	esp, 8
	lea	ecx, DWORD PTR ?read_rate@?ED@??SK_MonitorDisk@@YGKPAX@Z@4PAVStats@Framerate@SK@@A[ebx]
	movsd	QWORD PTR [esp], xmm0
	call	?addSample@Stats@Framerate@SK@@QAEXNT_LARGE_INTEGER@@@Z ; SK::Framerate::Stats::addSample

; 1094 :       combined_rate [i].addSample (static_cast <double> (bytes_sec),        now );

	mov	edx, DWORD PTR _bytes_sec$11[ebp+4]
	lea	ebx, DWORD PTR ?combined_rate@?ED@??SK_MonitorDisk@@YGKPAX@Z@4PAVStats@Framerate@SK@@A[ebx]
	mov	ecx, DWORD PTR _bytes_sec$11[ebp]
	push	edi
	push	esi
	call	__ultod3
	sub	esp, 8
	mov	ecx, ebx
	movsd	QWORD PTR [esp], xmm0
	call	?addSample@Stats@Framerate@SK@@QAEXNT_LARGE_INTEGER@@@Z ; SK::Framerate::Stats::addSample

; 1095 : 
; 1096 :       double combined_mean = combined_rate [i].calcMean (3.0);

	movsd	xmm0, QWORD PTR __real@4008000000000000
	sub	esp, 8
	mov	ecx, ebx
	movsd	QWORD PTR [esp], xmm0
	call	?calcMean@Stats@Framerate@SK@@QAENN@Z	; SK::Framerate::Stats::calcMean

; 1097 :       double write_mean    = write_rate    [i].calcMean (3.0);

	movsd	xmm0, QWORD PTR __real@4008000000000000
	sub	esp, 8
	mov	ecx, DWORD PTR tv1908[ebp]
	fstp	QWORD PTR _combined_mean$23[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	?calcMean@Stats@Framerate@SK@@QAENN@Z	; SK::Framerate::Stats::calcMean

; 1098 :       double read_mean     = read_rate     [i].calcMean (3.0);

	movsd	xmm0, QWORD PTR __real@4008000000000000
	sub	esp, 8
	mov	ecx, DWORD PTR tv1905[ebp]
	fstp	QWORD PTR _write_mean$21[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	?calcMean@Stats@Framerate@SK@@QAENN@Z	; SK::Framerate::Stats::calcMean

; 1099 : 
; 1100 :       disk.disks [i].bytes_sec       = isnan (combined_mean) ? 0ULL : static_cast <uint64_t> (combined_mean);

	movsd	xmm0, QWORD PTR _combined_mean$23[ebp]
	sub	esp, 8
	fstp	QWORD PTR _read_mean$20[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	??$isnan@N@@YA_NN@Z			; isnan<double>
	add	esp, 8
	test	al, al
	je	SHORT $LN76@SK_Monitor
	xorps	xmm0, xmm0
	movlpd	QWORD PTR tv933[ebp], xmm0
	mov	edx, DWORD PTR tv933[ebp+4]
	mov	eax, DWORD PTR tv933[ebp]
	jmp	SHORT $LN77@SK_Monitor
$LN76@SK_Monitor:
	movsd	xmm0, QWORD PTR _combined_mean$23[ebp]
	call	__dtoul3
$LN77@SK_Monitor:
	mov	ebx, DWORD PTR tv1918[ebp]

; 1101 :       disk.disks [i].write_bytes_sec = isnan (write_mean)    ? 0ULL : static_cast <uint64_t> (write_mean);

	sub	esp, 8
	movsd	xmm0, QWORD PTR _write_mean$21[ebp]
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[ebx+152], eax
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[ebx+156], edx
	movsd	QWORD PTR [esp], xmm0
	call	??$isnan@N@@YA_NN@Z			; isnan<double>
	add	esp, 8
	test	al, al
	je	SHORT $LN78@SK_Monitor
	xorps	xmm0, xmm0
	movlpd	QWORD PTR tv943[ebp], xmm0
	mov	edx, DWORD PTR tv943[ebp+4]
	mov	eax, DWORD PTR tv943[ebp]
	jmp	SHORT $LN79@SK_Monitor
$LN78@SK_Monitor:
	movsd	xmm0, QWORD PTR _write_mean$21[ebp]
	call	__dtoul3
$LN79@SK_Monitor:

; 1102 :       disk.disks [i].read_bytes_sec  = isnan (read_mean)     ? 0ULL : static_cast <uint64_t> (read_mean);

	movsd	xmm0, QWORD PTR _read_mean$20[ebp]
	sub	esp, 8
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[ebx+144], eax
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[ebx+148], edx
	movsd	QWORD PTR [esp], xmm0
	call	??$isnan@N@@YA_NN@Z			; isnan<double>
	add	esp, 8
	test	al, al
	je	SHORT $LN80@SK_Monitor
	xorps	xmm0, xmm0
	movlpd	QWORD PTR tv953[ebp], xmm0
	mov	edx, DWORD PTR tv953[ebp+4]
	mov	eax, DWORD PTR tv953[ebp]
	jmp	SHORT $LN81@SK_Monitor
$LN80@SK_Monitor:
	movsd	xmm0, QWORD PTR _read_mean$20[ebp]
	call	__dtoul3
$LN81@SK_Monitor:
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[ebx+136], eax
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A[ebx+140], edx

; 1103 : 
; 1104 :       //disk.disks [i].bytes_sec       = (disk.disks [i].bytes_sec       + bytes_sec)       >> 1;
; 1105 :       //disk.disks [i].write_bytes_sec = (disk.disks [i].write_bytes_sec + bytes_write_sec) >> 1;
; 1106 :       //disk.disks [i].read_bytes_sec  = (disk.disks [i].read_bytes_sec  + bytes_read_sec)  >> 1;
; 1107 : 
; 1108 :       // Done with the object
; 1109 :       disk.apEnumAccess [i]->Release ();

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	mov	ebx, DWORD PTR _i$1$[ebp]
	mov	eax, DWORD PTR [eax+ebx*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]

; 1110 :       disk.apEnumAccess [i] = nullptr;

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	mov	DWORD PTR [eax+ebx*4], 0
	inc	ebx
	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+32
	mov	DWORD PTR _i$1$[ebp], ebx
	cmp	ebx, eax
	jb	$LL8@SK_Monitor
$LN7@SK_Monitor:

; 1111 :     }
; 1112 : 
; 1113 :     disk.num_disks = disk.dwNumReturned;
; 1114 :     disk.booting   = false;
; 1115 : 
; 1116 :     ++iter;

	mov	ebx, DWORD PTR _iter$1$[ebp]

; 1117 : 
; 1118 :     COM::base.wmi.Unlock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	inc	ebx
	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+1480, eax
	mov	BYTE PTR ?disk_stats@@3Udisk_perf_t@@A+36, 0
	mov	DWORD PTR _iter$1$[ebp], ebx
	call	?Unlock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Unlock
$LN190@SK_Monitor:

; 821  : 
; 822  :   while (disk_stats.lID != 0)

	cmp	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+24, 0
	je	SHORT $LN214@SK_Monitor
	mov	ecx, DWORD PTR tv1928[ebp]
	jmp	$LL4@SK_Monitor
$LN166@SK_Monitor:

; 901  :       {
; 902  :         dll_log.Log (L"[ WMI Wbem ] Disk apEnumAccess [0] = nullptr");

	push	OFFSET $SG166056
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8

; 903  :         goto DISK_CLEANUP;

	jmp	SHORT $LN216@SK_Monitor
$LN214@SK_Monitor:

; 1119 :   }
; 1120 : 
; 1121 :   COM::base.wmi.Lock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	call	?Lock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Lock
$LN216@SK_Monitor:
	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+32
$DISK_CLEANUP$219:

; 1122 : 
; 1123 : DISK_CLEANUP:
; 1124 :   //dll_log.Log (L" >> DISK_CLEANUP");
; 1125 : 
; 1126 :   if (disk.apEnumAccess != nullptr)

	mov	edx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	test	edx, edx
	je	SHORT $LN69@SK_Monitor

; 1127 :   {
; 1128 :     for (unsigned int i = 0; i < disk.dwNumReturned; i++)

	xor	esi, esi
	test	eax, eax
	je	SHORT $LN13@SK_Monitor
$LL14@SK_Monitor:

; 1129 :     {
; 1130 :       if (disk.apEnumAccess [i] != nullptr)

	mov	ecx, DWORD PTR [edx+esi*4]
	test	ecx, ecx
	je	SHORT $LN12@SK_Monitor

; 1131 :       {
; 1132 :         disk.apEnumAccess [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 1133 :         disk.apEnumAccess [i] = nullptr;

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
	mov	DWORD PTR [eax+esi*4], 0
	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+32
	mov	edx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+20
$LN12@SK_Monitor:

; 1127 :   {
; 1128 :     for (unsigned int i = 0; i < disk.dwNumReturned; i++)

	inc	esi
	cmp	esi, eax
	jb	SHORT $LL14@SK_Monitor
$LN13@SK_Monitor:

; 1134 :       }
; 1135 :     }
; 1136 :     delete [] disk.apEnumAccess;

	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN69@SK_Monitor:

; 1137 :   }
; 1138 : 
; 1139 :   if (disk.pEnum)

	mov	ecx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+16
	pop	edi
	pop	esi
	pop	ebx
	test	ecx, ecx
	je	SHORT $LN71@SK_Monitor

; 1140 :   {
; 1141 :     disk.pEnum->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 1142 :     disk.pEnum = nullptr;

	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+16, 0
$LN71@SK_Monitor:

; 1143 :   }
; 1144 : 
; 1145 :   if (disk.pConfig != nullptr)

	mov	ecx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+12
	test	ecx, ecx
	je	SHORT $LN72@SK_Monitor

; 1146 :   {
; 1147 :     disk.pConfig->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 1148 :     disk.pConfig = nullptr;

	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+12, 0
$LN72@SK_Monitor:

; 1149 :   }
; 1150 : 
; 1151 :   if (disk.pRefresher != nullptr)

	mov	ecx, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+8
	test	ecx, ecx
	je	SHORT $LN73@SK_Monitor

; 1152 :   {
; 1153 :     disk.pRefresher->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 1154 :     disk.pRefresher = nullptr;

	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+8, 0
$LN73@SK_Monitor:

; 1155 :   }
; 1156 : 
; 1157 :   if (disk.hShutdownSignal != INVALID_HANDLE_VALUE)

	cmp	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+4, -1
	je	SHORT $LN74@SK_Monitor

; 1158 :   {
; 1159 :     CloseHandle (disk.hShutdownSignal);

	mov	eax, DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+4
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 1160 :     disk.hShutdownSignal = INVALID_HANDLE_VALUE;

	mov	DWORD PTR ?disk_stats@@3Udisk_perf_t@@A+4, -1
$LN74@SK_Monitor:

; 1161 :   }
; 1162 : 
; 1163 :   COM::base.wmi.Unlock   ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	call	?Unlock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Unlock
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h

; 52   :     if (success)

	cmp	BYTE PTR _auto_com$[ebp], 0
	je	SHORT $LN215@SK_Monitor

; 53   :       CoUninitialize ();

	call	DWORD PTR __imp__CoUninitialize@0
$LN215@SK_Monitor:
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 1166 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	xor	eax, eax
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_MonitorDisk@@YGKPAX@Z$24:
	lea	ecx, DWORD PTR _auto_com$[ebp]
	jmp	??1SK_AutoCOMInit@@QAE@XZ		; SK_AutoCOMInit::~SK_AutoCOMInit
__ehhandler$?SK_MonitorDisk@@YGKPAX@Z:
	mov	eax, OFFSET __ehfuncinfo$?SK_MonitorDisk@@YGKPAX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_MonitorDisk@@YGKPAX@Z ENDP				; SK_MonitorDisk
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
_TEXT	SEGMENT
_interrupt$2 = -84					; size = 8
_kernel$3 = -76						; size = 8
_user$4 = -68						; size = 8
_load$5 = -60						; size = 8
_idle$6 = -52						; size = 8
_PercentIdleTimeType$7 = -44				; size = 4
_PercentProcessorTimeType$8 = -40			; size = 4
_PercentUserTimeType$9 = -36				; size = 4
_PercentPrivilegedTimeType$10 = -32			; size = 4
_PercentInterruptTimeType$11 = -28			; size = 4
_update$1$ = -24					; size = 8
tv1795 = -20						; size = 4
_auto_com$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
_user_param$ = 8					; size = 4
?SK_MonitorCPU@@YGKPAX@Z PROC				; SK_MonitorCPU

; 403  : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?SK_MonitorCPU@@YGKPAX@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 72					; 00000048H
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?base@COM@@3UBase@1@A+4
	push	esi
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 404  :   while (! ReadAcquire (&COM::base.wmi.init))

	test	eax, eax
	jne	SHORT $LN3@SK_Monitor
	mov	esi, DWORD PTR __imp__SleepEx@8
	npad	3
$LL2@SK_Monitor:

; 405  :     SleepEx (150, FALSE);

	push	0
	push	150					; 00000096H
	call	esi
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?base@COM@@3UBase@1@A+4
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 404  :   while (! ReadAcquire (&COM::base.wmi.init))

	test	eax, eax
	je	SHORT $LL2@SK_Monitor
$LN3@SK_Monitor:
	push	ebx
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h

; 45   :     HRESULT hr = CoInitializeEx (NULL, COINIT_MULTITHREADED);

	push	0
	push	0

; 54   :   }
; 55   : 
; 56   : private:
; 57   :   bool success = false;

	xor	bl, bl
	call	DWORD PTR __imp__CoInitializeEx@8
	test	eax, eax
	movzx	ecx, bl
	mov	edx, 1
	cmovns	ecx, edx
	mov	BYTE PTR _auto_com$[ebp], cl
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 411  :   COM::base.wmi.Lock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?Lock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Lock
	movss	xmm0, DWORD PTR ?config@@3Usk_config_t@@A+100

; 412  : 
; 413  :   cpu_perf_t&  cpu    = cpu_stats;
; 414  :   const double update = config.cpu.interval;
; 415  : 
; 416  :   HRESULT hr;
; 417  : 
; 418  :   if (FAILED (hr = CoCreateInstance (

	push	OFFSET ?cpu_stats@@3Ucpu_perf_t@@A+8
	push	OFFSET _IID_IWbemRefresher
	cvtps2pd xmm0, xmm0
	push	1
	push	0
	push	OFFSET _CLSID_WbemRefresher
	movsd	QWORD PTR _update$1$[ebp], xmm0
	call	DWORD PTR __imp__CoCreateInstance@20
	test	eax, eax
	jns	SHORT $LN12@SK_Monitor

; 419  :                      CLSID_WbemRefresher,
; 420  :                      nullptr,
; 421  :                      CLSCTX_INPROC_SERVER,
; 422  :                      IID_IWbemRefresher, 
; 423  :                      (void**) &cpu.pRefresher )
; 424  :              )
; 425  :      )
; 426  :   {
; 427  :     dll_log.Log (L"[ WMI Wbem ] Failed to create Refresher Instance (%s:%d)",

	push	428					; 000001acH
	push	OFFSET $SG165825
	push	OFFSET $SG165826
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 428  :       __FILEW__, __LINE__);
; 429  :     goto CPU_CLEANUP;

	jmp	$CPU_CLEANUP$120
$LN12@SK_Monitor:

; 430  :   }
; 431  : 
; 432  :   if (FAILED (hr = cpu.pRefresher->QueryInterface (

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+8
	push	OFFSET ?cpu_stats@@3Ucpu_perf_t@@A+12
	push	OFFSET _IID_IWbemConfigureRefresher
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx]
	test	eax, eax
	jns	SHORT $LN14@SK_Monitor

; 433  :                         IID_IWbemConfigureRefresher,
; 434  :                         (void **)&cpu.pConfig )
; 435  :              )
; 436  :      )
; 437  :   {
; 438  :     dll_log.Log (L"[ WMI Wbem ] Failed to Query Refresher Interface (%s:%d)",

	push	439					; 000001b7H
	push	OFFSET $SG165829
	push	OFFSET $SG165830
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 439  :       __FILEW__, __LINE__);
; 440  :     goto CPU_CLEANUP;

	jmp	$CPU_CLEANUP$120
$LN14@SK_Monitor:

; 441  :   }
; 442  : 
; 443  :   // Add an enumerator to the refresher.
; 444  :   if (FAILED (hr = cpu.pConfig->AddEnum (

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+12
	push	OFFSET ?cpu_stats@@3Ucpu_perf_t@@A+24
	push	OFFSET ?cpu_stats@@3Ucpu_perf_t@@A+16
	push	0
	mov	ecx, DWORD PTR [eax]
	push	0
	push	OFFSET $SG165833
	push	DWORD PTR ?base@COM@@3UBase@1@A+8
	push	eax
	call	DWORD PTR [ecx+28]
	test	eax, eax
	jns	SHORT $LN16@SK_Monitor

; 445  :                      COM::base.wmi.pNameSpace,
; 446  :                      L"Win32_PerfFormattedData_PerfOS_Processor",
; 447  :                      0,
; 448  :                      nullptr,
; 449  :                      &cpu.pEnum,
; 450  :                      &cpu.lID )
; 451  :              )
; 452  :      )
; 453  :   {
; 454  :     dll_log.Log (L"[ WMI Wbem ] Failed to Add Enumerator (%s:%d) - %04X",

	push	eax
	push	455					; 000001c7H
	push	OFFSET $SG165834
	push	OFFSET $SG165835
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 20					; 00000014H

; 455  :       __FILEW__, __LINE__, hr);
; 456  :     goto CPU_CLEANUP;

	jmp	$CPU_CLEANUP$120
$LN16@SK_Monitor:

; 457  :   }
; 458  : 
; 459  :   cpu.pConfig->Release ();

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+12
	push	edi
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]

; 460  :   cpu.pConfig = nullptr;
; 461  : 
; 462  :   int iter = 0;

	xor	ebx, ebx
	mov	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+12, 0

; 463  : 
; 464  :   cpu.dwNumReturned = 0;
; 465  :   cpu.dwNumObjects  = 0;
; 466  : 
; 467  :   cpu.hShutdownSignal = CreateEvent (nullptr, FALSE, FALSE, L"CPUMon Shutdown Signal");

	push	OFFSET $SG165837
	push	ebx
	push	ebx
	push	ebx
	mov	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+32, ebx
	mov	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+28, ebx
	call	DWORD PTR __imp__CreateEventW@16

; 468  : 
; 469  :   COM::base.wmi.Unlock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	mov	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+4, eax
	call	?Unlock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Unlock

; 470  : 
; 471  :   while (cpu.lID != 0)

	cmp	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+24, ebx
	je	$LN5@SK_Monitor
	movsd	xmm0, QWORD PTR _update$1$[ebp]
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	call	__dtoui3
	mov	DWORD PTR tv1795[ebp], eax
	lea	esi, DWORD PTR [ebx+4]
	mov	edi, OFFSET ?cpu_stats@@3Ucpu_perf_t@@A+28
	npad	5
$LL4@SK_Monitor:

; 472  :   {
; 473  :     if (WaitForSingleObject (cpu.hShutdownSignal, DWORD (update * 1000.0)) == WAIT_OBJECT_0)

	push	eax
	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+4
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
	test	eax, eax
	je	$LN5@SK_Monitor

; 474  :       break;
; 475  : 
; 476  :     // Only poll WMI while the data view is visible
; 477  :     if (! (config.cpu.show || SK_ImGui_Widgets.cpu_monitor->isActive ()))

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+96, 0
	jne	SHORT $LN19@SK_Monitor
	mov	eax, DWORD PTR ?SK_ImGui_Widgets@@3USK_ImGui_WidgetRegistry@@A+16
	cmp	BYTE PTR [eax+185], 0
	je	$LN104@SK_Monitor
$LN19@SK_Monitor:

; 478  :       continue;
; 479  : 
; 480  :     cpu.dwNumReturned = 0;
; 481  : 
; 482  :     COM::base.wmi.Lock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	mov	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+32, 0
	call	?Lock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Lock

; 483  : 
; 484  :     if (FAILED (hr = cpu.pRefresher->Refresh (0L)))

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+8
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+12]
	test	eax, eax
	js	$LN92@SK_Monitor

; 489  :     }
; 490  : 
; 491  :     hr = cpu.pEnum->GetObjects ( 0L,

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+16
	push	OFFSET ?cpu_stats@@3Ucpu_perf_t@@A+32
	push	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
	push	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+28
	mov	ecx, DWORD PTR [eax]
	push	0
	push	eax
	call	DWORD PTR [ecx+20]

; 492  :                                  cpu.dwNumObjects,
; 493  :                                  cpu.apEnumAccess,
; 494  :                                  &cpu.dwNumReturned );
; 495  : 
; 496  : 
; 497  :     // If the buffer was not big enough,
; 498  :     // allocate a bigger buffer and retry.
; 499  :     if (hr == WBEM_E_BUFFER_TOO_SMALL 
; 500  :         && cpu.dwNumReturned > cpu.dwNumObjects)

	cmp	eax, -2147217348			; 8004103cH
	jne	$LN22@SK_Monitor
	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+32
	cmp	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+28
	jbe	$LN95@SK_Monitor

; 501  :     {
; 502  :       cpu.apEnumAccess = new IWbemObjectAccess* [cpu.dwNumReturned];

	xor	ecx, ecx
	mul	esi
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20, edx

; 503  :       if (cpu.apEnumAccess == nullptr)

	test	edx, edx
	je	$LN93@SK_Monitor

; 509  :       }
; 510  : 
; 511  :       SecureZeroMemory (cpu.apEnumAccess,

	mov	esi, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+32
	lea	eax, DWORD PTR [esi*4]
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 17796:     while (cnt) {

	test	eax, eax
	je	SHORT $LN70@SK_Monitor
	npad	8
$LL69@SK_Monitor:

; 17797: 
; 17798: #if !defined(_M_CEE) && defined(_M_ARM)
; 17799: 
; 17800:         __iso_volatile_store8(vptr, 0);
; 17801: 
; 17802: #else
; 17803: 
; 17804:         *vptr = 0;

	mov	BYTE PTR [edx], 0

; 17805: 
; 17806: #endif
; 17807: 
; 17808:         vptr++;

	lea	edx, DWORD PTR [edx+1]

; 17809:         cnt--;

	sub	eax, 1
	jne	SHORT $LL69@SK_Monitor

; 17796:     while (cnt) {

	mov	esi, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+32
	mov	edx, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
$LN70@SK_Monitor:
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 516  :       if (FAILED (hr = cpu.pEnum->GetObjects ( 0L,

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+16
	push	OFFSET ?cpu_stats@@3Ucpu_perf_t@@A+32
	push	edx
	push	esi
	mov	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+28, esi
	mov	ecx, DWORD PTR [eax]
	push	0
	push	eax
	call	DWORD PTR [ecx+20]
	test	eax, eax
	js	$LN94@SK_Monitor
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 3779 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+32
	mov	ecx, OFFSET ?cpu_stats@@3Ucpu_perf_t@@A+32
	cmp	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+28
	cmovae	ecx, edi
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 529  :       cpu.dwNumReturned = std::min (cpu.dwNumObjects, cpu.dwNumReturned);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+32, eax

; 530  :     }
; 531  :     else

	jmp	SHORT $LN28@SK_Monitor
$LN22@SK_Monitor:

; 532  :     {
; 533  :       if (hr != WBEM_S_NO_ERROR)

	test	eax, eax
	jne	$LN95@SK_Monitor
	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+32
$LN28@SK_Monitor:

; 539  :       }
; 540  :     }
; 541  : 
; 542  :     // First time through, get the handles.
; 543  :     if (iter == 0)

	test	ebx, ebx
	jne	$LN39@SK_Monitor

; 544  :     {
; 545  :       CIMTYPE PercentInterruptTimeType;
; 546  :       CIMTYPE PercentPrivilegedTimeType;
; 547  :       CIMTYPE PercentUserTimeType;
; 548  :       CIMTYPE PercentProcessorTimeType;
; 549  :       CIMTYPE PercentIdleTimeType;
; 550  : 
; 551  :       if (FAILED (hr = cpu.apEnumAccess [0]->GetPropertyHandle (

	mov	ecx, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
	lea	edx, DWORD PTR _PercentInterruptTimeType$11[ebp]
	push	OFFSET ?cpu_stats@@3Ucpu_perf_t@@A+40
	push	edx
	push	OFFSET $SG165860
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN96@SK_Monitor

; 561  :       }
; 562  : 
; 563  :       if (FAILED (hr = cpu.apEnumAccess [0]->GetPropertyHandle (

	mov	ecx, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
	lea	edx, DWORD PTR _PercentPrivilegedTimeType$10[ebp]
	push	OFFSET ?cpu_stats@@3Ucpu_perf_t@@A+44
	push	edx
	push	OFFSET $SG165865
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN97@SK_Monitor

; 573  :       }
; 574  : 
; 575  :       if (FAILED (hr = cpu.apEnumAccess [0]->GetPropertyHandle (

	mov	ecx, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
	lea	edx, DWORD PTR _PercentUserTimeType$9[ebp]
	push	OFFSET ?cpu_stats@@3Ucpu_perf_t@@A+48
	push	edx
	push	OFFSET $SG165870
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN98@SK_Monitor

; 585  :       }
; 586  : 
; 587  :       if (FAILED (hr = cpu.apEnumAccess [0]->GetPropertyHandle (

	mov	ecx, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
	lea	edx, DWORD PTR _PercentProcessorTimeType$8[ebp]
	push	OFFSET ?cpu_stats@@3Ucpu_perf_t@@A+52
	push	edx
	push	OFFSET $SG165875
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN99@SK_Monitor

; 597  :       }
; 598  : 
; 599  :       if (FAILED (hr = cpu.apEnumAccess [0]->GetPropertyHandle (

	mov	ecx, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
	lea	edx, DWORD PTR _PercentIdleTimeType$7[ebp]
	push	OFFSET ?cpu_stats@@3Ucpu_perf_t@@A+56
	push	edx
	push	OFFSET $SG165880
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	call	DWORD PTR [eax+108]
	test	eax, eax
	js	$LN100@SK_Monitor
	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+32
$LN39@SK_Monitor:

; 609  :       }
; 610  :     }
; 611  : 
; 612  :     for (unsigned int i = 0; i < cpu.dwNumReturned; i++)

	xor	esi, esi
	test	eax, eax
	je	$LN7@SK_Monitor
	mov	edi, OFFSET ?cpu_stats@@3Ucpu_perf_t@@A+72
	npad	9
$LL8@SK_Monitor:

; 613  :     {
; 614  :       uint64_t interrupt;
; 615  :       uint64_t kernel;
; 616  :       uint64_t user;
; 617  :       uint64_t load;
; 618  :       uint64_t idle;
; 619  : 
; 620  :       if (cpu.apEnumAccess [i] == nullptr)

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
	mov	ecx, DWORD PTR [eax+esi*4]
	test	ecx, ecx
	je	$LN85@SK_Monitor

; 624  :       }
; 625  : 
; 626  :       if (FAILED (hr = cpu.apEnumAccess [i]->ReadQWORD (

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR _interrupt$2[ebp]
	push	edx
	push	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+40
	push	ecx
	call	DWORD PTR [eax+128]
	test	eax, eax
	js	$LN86@SK_Monitor

; 635  :       }
; 636  : 
; 637  :       if (FAILED (hr = cpu.apEnumAccess [i]->ReadQWORD (

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
	lea	edx, DWORD PTR _kernel$3[ebp]
	push	edx
	push	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+44
	mov	eax, DWORD PTR [eax+esi*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+128]
	test	eax, eax
	js	$LN87@SK_Monitor

; 646  :       }
; 647  : 
; 648  :       if (FAILED (hr = cpu.apEnumAccess [i]->ReadQWORD (

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
	lea	edx, DWORD PTR _user$4[ebp]
	push	edx
	push	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+48
	mov	eax, DWORD PTR [eax+esi*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+128]
	test	eax, eax
	js	$LN88@SK_Monitor

; 657  :       }
; 658  : 
; 659  :       if (FAILED (hr = cpu.apEnumAccess [i]->ReadQWORD (

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
	lea	edx, DWORD PTR _load$5[ebp]
	push	edx
	push	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+52
	mov	eax, DWORD PTR [eax+esi*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+128]
	test	eax, eax
	js	$LN89@SK_Monitor

; 668  :       }
; 669  : 
; 670  :       if (FAILED (hr = cpu.apEnumAccess [i]->ReadQWORD (

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
	lea	edx, DWORD PTR _idle$6[ebp]
	push	edx
	push	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+56
	mov	eax, DWORD PTR [eax+esi*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+128]
	test	eax, eax
	js	$LN90@SK_Monitor

; 679  :       }
; 680  : 
; 681  :       cpu.cpus [i].percent_idle   = (cpu.cpus [i].percent_idle   + idle)   / 2;

	mov	ecx, DWORD PTR [edi]
	add	ecx, DWORD PTR _idle$6[ebp]
	mov	eax, DWORD PTR [edi+4]
	adc	eax, DWORD PTR _idle$6[ebp+4]
	shrd	ecx, eax, 1
	shr	eax, 1
	mov	DWORD PTR [edi+4], eax

; 682  :       cpu.cpus [i].percent_load   = (cpu.cpus [i].percent_load   + load)   / 2;

	mov	eax, DWORD PTR _load$5[ebp+4]
	mov	DWORD PTR [edi], ecx
	mov	ecx, DWORD PTR _load$5[ebp]
	add	ecx, DWORD PTR [edi-8]
	adc	eax, DWORD PTR [edi-4]
	shrd	ecx, eax, 1
	shr	eax, 1
	mov	DWORD PTR [edi-8], ecx

; 683  :       cpu.cpus [i].percent_user   = (cpu.cpus [i].percent_user   + user)   / 2;

	mov	ecx, DWORD PTR [edi+16]
	add	ecx, DWORD PTR _user$4[ebp]
	mov	DWORD PTR [edi-4], eax
	mov	eax, DWORD PTR [edi+20]
	adc	eax, DWORD PTR _user$4[ebp+4]
	shrd	ecx, eax, 1
	shr	eax, 1
	mov	DWORD PTR [edi+16], ecx

; 684  :       cpu.cpus [i].percent_kernel = (cpu.cpus [i].percent_kernel + kernel) / 2;

	mov	ecx, DWORD PTR [edi+8]
	add	ecx, DWORD PTR _kernel$3[ebp]
	mov	DWORD PTR [edi+20], eax
	mov	eax, DWORD PTR [edi+12]
	adc	eax, DWORD PTR _kernel$3[ebp+4]
	shrd	ecx, eax, 1
	shr	eax, 1
	mov	DWORD PTR [edi+8], ecx

; 685  :       cpu.cpus [i].percent_interrupt

	mov	ecx, DWORD PTR [edi+24]
	add	ecx, DWORD PTR _interrupt$2[ebp]
	mov	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [edi+28]
	adc	eax, DWORD PTR _interrupt$2[ebp+4]
	shrd	ecx, eax, 1
	shr	eax, 1
	mov	DWORD PTR [edi+24], ecx
	mov	DWORD PTR [edi+28], eax

; 686  :                                   = ( cpu.cpus [i].percent_interrupt + 
; 687  :                                       interrupt ) / 2;
; 688  : 
; 689  :       cpu.cpus [i].update_time = timeGetTime ();

	call	DWORD PTR __imp__timeGetTime@0
	mov	DWORD PTR [edi+40], eax

; 690  : 
; 691  :       // Done with the object
; 692  :       cpu.apEnumAccess [i]->Release ();

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
	mov	eax, DWORD PTR [eax+esi*4]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]

; 693  :       cpu.apEnumAccess [i] = nullptr;

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
	add	edi, 56					; 00000038H
	mov	DWORD PTR [eax+esi*4], 0
	inc	esi
	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+32
	cmp	esi, eax
	jb	$LL8@SK_Monitor
	mov	edi, OFFSET ?cpu_stats@@3Ucpu_perf_t@@A+28
$LN7@SK_Monitor:

; 694  :     }
; 695  : 
; 696  :     cpu.num_cpus = cpu.dwNumReturned;
; 697  :     cpu.booting  = false;
; 698  : 
; 699  :     ++iter;
; 700  : 
; 701  :     COM::base.wmi.Unlock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	mov	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+3648, eax
	mov	BYTE PTR ?cpu_stats@@3Ucpu_perf_t@@A+36, 0
	inc	ebx
	call	?Unlock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Unlock
	mov	esi, 4
$LN104@SK_Monitor:

; 470  : 
; 471  :   while (cpu.lID != 0)

	cmp	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+24, 0
	je	$LN5@SK_Monitor
	mov	eax, DWORD PTR tv1795[ebp]
	jmp	$LL4@SK_Monitor
$LN94@SK_Monitor:

; 517  :                                                cpu.dwNumObjects,
; 518  :                                                cpu.apEnumAccess,
; 519  :                                                &cpu.dwNumReturned )
; 520  :                  )
; 521  :          )
; 522  :       {
; 523  :         dll_log.Log (L"[ WMI Wbem ] Failed to get CPU Objects (%s:%d)",

	push	524					; 0000020cH
	push	OFFSET $SG165851
	push	OFFSET $SG165852
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 524  :           __FILEW__, __LINE__);
; 525  : 
; 526  :         goto CPU_CLEANUP;

	jmp	$LN119@SK_Monitor
$LN93@SK_Monitor:

; 504  :       {
; 505  :         dll_log.Log (L"[ WMI Wbem ] Out of Memory (%s:%d)",

	push	506					; 000001faH
	push	OFFSET $SG165847
	push	OFFSET $SG165848
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 506  :           __FILEW__, __LINE__);
; 507  :         hr = E_OUTOFMEMORY;
; 508  :         goto CPU_CLEANUP;

	jmp	$LN119@SK_Monitor
$LN100@SK_Monitor:

; 600  :                             L"PercentIdleTime",
; 601  :                             &PercentIdleTimeType,
; 602  :                             &cpu.lPercentIdleTimeHandle )
; 603  :                  )
; 604  :          )
; 605  :       {
; 606  :         dll_log.Log (L"[ WMI Wbem ] Failed to acquire property handle (%s:%d)",

	push	607					; 0000025fH
	push	OFFSET $SG165881
	push	OFFSET $SG165882
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 607  :           __FILEW__, __LINE__);
; 608  :         goto CPU_CLEANUP;

	jmp	$LN119@SK_Monitor
$LN99@SK_Monitor:

; 588  :                             L"PercentProcessorTime",
; 589  :                             &PercentProcessorTimeType,
; 590  :                             &cpu.lPercentProcessorTimeHandle )
; 591  :                  )
; 592  :          )
; 593  :       {
; 594  :         dll_log.Log (L"[ WMI Wbem ] Failed to acquire property handle (%s:%d)",

	push	595					; 00000253H
	push	OFFSET $SG165876
	push	OFFSET $SG165877
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 595  :           __FILEW__, __LINE__);
; 596  :         goto CPU_CLEANUP;

	jmp	$LN119@SK_Monitor
$LN98@SK_Monitor:

; 576  :                             L"PercentUserTime",
; 577  :                             &PercentUserTimeType,
; 578  :                             &cpu.lPercentUserTimeHandle )
; 579  :                  )
; 580  :          )
; 581  :       {
; 582  :         dll_log.Log (L"[ WMI Wbem ] Failed to acquire property handle (%s:%d)",

	push	583					; 00000247H
	push	OFFSET $SG165871
	push	OFFSET $SG165872
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 583  :           __FILEW__, __LINE__);
; 584  :         goto CPU_CLEANUP;

	jmp	$LN119@SK_Monitor
$LN97@SK_Monitor:

; 564  :                             L"PercentPrivilegedTime",
; 565  :                             &PercentPrivilegedTimeType,
; 566  :                             &cpu.lPercentPrivilegedTimeHandle )
; 567  :                  )
; 568  :          )
; 569  :       {
; 570  :         dll_log.Log (L"[ WMI Wbem ] Failed to acquire property handle (%s:%d)",

	push	571					; 0000023bH
	push	OFFSET $SG165866
	push	OFFSET $SG165867
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 571  :           __FILEW__, __LINE__);
; 572  :         goto CPU_CLEANUP;

	jmp	$LN119@SK_Monitor
$LN96@SK_Monitor:

; 552  :                             L"PercentInterruptTime",
; 553  :                             &PercentInterruptTimeType,
; 554  :                             &cpu.lPercentInterruptTimeHandle )
; 555  :                  )
; 556  :          )
; 557  :       {
; 558  :         dll_log.Log (L"[ WMI Wbem ] Failed to acquire property handle (%s:%d)",

	push	559					; 0000022fH
	push	OFFSET $SG165861
	push	OFFSET $SG165862
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 559  :           __FILEW__, __LINE__);
; 560  :         goto CPU_CLEANUP;

	jmp	$LN119@SK_Monitor
$LN90@SK_Monitor:

; 671  :                              cpu.lPercentIdleTimeHandle,
; 672  :                              &idle )
; 673  :                  )
; 674  :          )
; 675  :       {
; 676  :         dll_log.Log (L"[ WMI Wbem ] Failed to read Quad-Word Property (%s:%d)",

	push	677					; 000002a5H
	push	OFFSET $SG165904
	push	OFFSET $SG165905
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 677  :           __FILEW__, __LINE__);
; 678  :         goto CPU_CLEANUP;

	jmp	$LN119@SK_Monitor
$LN89@SK_Monitor:

; 660  :                              cpu.lPercentProcessorTimeHandle,
; 661  :                              &load )
; 662  :                  )
; 663  :          )
; 664  :       {
; 665  :         dll_log.Log (L"[ WMI Wbem ] Failed to read Quad-Word Property (%s:%d)",

	push	666					; 0000029aH
	push	OFFSET $SG165900
	push	OFFSET $SG165901
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 666  :           __FILEW__, __LINE__);
; 667  :         goto CPU_CLEANUP;

	jmp	$LN119@SK_Monitor
$LN88@SK_Monitor:

; 649  :                              cpu.lPercentUserTimeHandle,
; 650  :                              &user )
; 651  :                  )
; 652  :          )
; 653  :       {
; 654  :         dll_log.Log (L"[ WMI Wbem ] Failed to read Quad-Word Property (%s:%d)",

	push	655					; 0000028fH
	push	OFFSET $SG165896
	push	OFFSET $SG165897
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 655  :           __FILEW__, __LINE__);
; 656  :         goto CPU_CLEANUP;

	jmp	$LN119@SK_Monitor
$LN87@SK_Monitor:

; 638  :                              cpu.lPercentPrivilegedTimeHandle,
; 639  :                              &kernel )
; 640  :                  )
; 641  :          )
; 642  :       {
; 643  :         dll_log.Log (L"[ WMI Wbem ] Failed to read Quad-Word Property (%s:%d)",

	push	644					; 00000284H
	push	OFFSET $SG165892
	push	OFFSET $SG165893
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 644  :           __FILEW__, __LINE__);
; 645  :         goto CPU_CLEANUP;

	jmp	SHORT $LN119@SK_Monitor
$LN86@SK_Monitor:

; 627  :                              cpu.lPercentInterruptTimeHandle,
; 628  :                              &interrupt )
; 629  :                  )
; 630  :          )
; 631  :       {
; 632  :         dll_log.Log (L"[ WMI Wbem ] Failed to read Quad-Word Property (%s:%d)",

	push	633					; 00000279H
	push	OFFSET $SG165888
	push	OFFSET $SG165889
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 633  :           __FILEW__, __LINE__);
; 634  :         goto CPU_CLEANUP;

	jmp	SHORT $LN119@SK_Monitor
$LN85@SK_Monitor:

; 621  :       {
; 622  :         dll_log.Log (L"[ WMI Wbem ] CPU apEnumAccess [%lu] = nullptr",  i);

	push	esi
	push	OFFSET $SG165885
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH

; 623  :         goto CPU_CLEANUP;

	jmp	SHORT $LN119@SK_Monitor
$LN95@SK_Monitor:

; 534  :       {
; 535  :         dll_log.Log (L"[ WMI Wbem ] UNKNOWN ERROR (%s:%d)",

	push	536					; 00000218H
	push	OFFSET $SG165855
	push	OFFSET $SG165856
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 536  :           __FILEW__, __LINE__);
; 537  :         hr = WBEM_E_NOT_FOUND;
; 538  :         goto CPU_CLEANUP;

	jmp	SHORT $LN119@SK_Monitor
$LN92@SK_Monitor:

; 485  :     {
; 486  :       dll_log.Log (L"[ WMI Wbem ] Failed to Refresh CPU (%s:%d)",

	push	487					; 000001e7H
	push	OFFSET $SG165841
	push	OFFSET $SG165842
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 487  :         __FILEW__, __LINE__);
; 488  :       goto CPU_CLEANUP;

	jmp	SHORT $LN119@SK_Monitor
$LN5@SK_Monitor:

; 702  :   }
; 703  : 
; 704  :   COM::base.wmi.Lock ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	call	?Lock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Lock
$LN119@SK_Monitor:
	pop	edi
$CPU_CLEANUP$120:

; 705  : 
; 706  : CPU_CLEANUP:
; 707  :   //dll_log.Log (L" >> CPU_CLEANUP");
; 708  : 
; 709  :   if (cpu.apEnumAccess != nullptr)

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
	pop	ebx
	test	eax, eax
	je	SHORT $LN53@SK_Monitor

; 710  :   {
; 711  :     for (unsigned int i = 0; i < cpu.dwNumReturned; i++)

	mov	edx, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+32
	xor	esi, esi
	test	edx, edx
	je	SHORT $LN10@SK_Monitor
	npad	1
$LL11@SK_Monitor:

; 712  :     {
; 713  :       if (cpu.apEnumAccess [i] != nullptr)

	mov	ecx, DWORD PTR [eax+esi*4]
	test	ecx, ecx
	je	SHORT $LN9@SK_Monitor

; 714  :       {
; 715  :         cpu.apEnumAccess [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 716  :         cpu.apEnumAccess [i] = nullptr;

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
	mov	DWORD PTR [eax+esi*4], 0
	mov	edx, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+32
	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+20
$LN9@SK_Monitor:

; 710  :   {
; 711  :     for (unsigned int i = 0; i < cpu.dwNumReturned; i++)

	inc	esi
	cmp	esi, edx
	jb	SHORT $LL11@SK_Monitor
$LN10@SK_Monitor:

; 717  :       }
; 718  :     }
; 719  :     delete [] cpu.apEnumAccess;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN53@SK_Monitor:

; 720  :   }
; 721  : 
; 722  :   if (cpu.pEnum)

	mov	ecx, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+16
	pop	esi
	test	ecx, ecx
	je	SHORT $LN55@SK_Monitor

; 723  :   {
; 724  :     cpu.pEnum->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 725  :     cpu.pEnum = nullptr;

	mov	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+16, 0
$LN55@SK_Monitor:

; 726  :   }
; 727  : 
; 728  :   if (cpu.pConfig != nullptr)

	mov	ecx, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+12
	test	ecx, ecx
	je	SHORT $LN56@SK_Monitor

; 729  :   {
; 730  :     cpu.pConfig->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 731  :     cpu.pConfig = nullptr;

	mov	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+12, 0
$LN56@SK_Monitor:

; 732  :   }
; 733  : 
; 734  :   if (cpu.pRefresher != nullptr)

	mov	ecx, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+8
	test	ecx, ecx
	je	SHORT $LN57@SK_Monitor

; 735  :   {
; 736  :     cpu.pRefresher->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 737  :     cpu.pRefresher = nullptr;

	mov	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+8, 0
$LN57@SK_Monitor:

; 738  :   }
; 739  : 
; 740  :   if (cpu.hShutdownSignal != INVALID_HANDLE_VALUE)

	cmp	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+4, -1
	je	SHORT $LN58@SK_Monitor

; 741  :   {
; 742  :     CloseHandle (cpu.hShutdownSignal);

	mov	eax, DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+4
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 743  :     cpu.hShutdownSignal = nullptr;

	mov	DWORD PTR ?cpu_stats@@3Ucpu_perf_t@@A+4, 0
$LN58@SK_Monitor:

; 744  :   }
; 745  : 
; 746  :   COM::base.wmi.Unlock   ();

	mov	ecx, OFFSET ?base@COM@@3UBase@1@A+4
	call	?Unlock@WMI@Base@COM@@QAEXXZ		; COM::Base::WMI::Unlock
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h

; 52   :     if (success)

	cmp	BYTE PTR _auto_com$[ebp], 0
	je	SHORT $LN117@SK_Monitor

; 53   :       CoUninitialize ();

	call	DWORD PTR __imp__CoUninitialize@0
$LN117@SK_Monitor:
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 749  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	xor	eax, eax
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_MonitorCPU@@YGKPAX@Z$18:
	lea	ecx, DWORD PTR _auto_com$[ebp]
	jmp	??1SK_AutoCOMInit@@QAE@XZ		; SK_AutoCOMInit::~SK_AutoCOMInit
__ehhandler$?SK_MonitorCPU@@YGKPAX@Z:
	mov	eax, OFFSET __ehfuncinfo$?SK_MonitorCPU@@YGKPAX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_MonitorCPU@@YGKPAX@Z ENDP				; SK_MonitorCPU
; Function compile flags: /Ogtp
;	COMDAT ??0pagefile_perf_t@@QAE@XZ
_TEXT	SEGMENT
??0pagefile_perf_t@@QAE@XZ PROC				; pagefile_perf_t::pagefile_perf_t, COMDAT
; _this$ = ecx
	mov	edx, ecx
	mov	ecx, 16					; 00000010H
	mov	DWORD PTR [edx], -1
	lea	eax, DWORD PTR [edx+316]
	mov	DWORD PTR [edx+4], -1
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR [edx+12], 0
	mov	DWORD PTR [edx+16], 0
	mov	DWORD PTR [edx+20], 0
	mov	DWORD PTR [edx+24], 0
	mov	DWORD PTR [edx+28], 0
	mov	DWORD PTR [edx+32], 0
	mov	BYTE PTR [edx+36], 1
	mov	DWORD PTR [edx+40], 0
	mov	DWORD PTR [edx+44], 0
	mov	DWORD PTR [edx+48], 0
	mov	DWORD PTR [edx+52], 0
	npad	5
$LL7@pagefile_p:
	mov	DWORD PTR [eax-4], 0
	lea	eax, DWORD PTR [eax+268]
	mov	DWORD PTR [eax-268], 0
	mov	DWORD PTR [eax-264], 0
	sub	ecx, 1
	jne	SHORT $LL7@pagefile_p
	mov	DWORD PTR [edx+4344], ecx
	mov	eax, edx
	ret	0
??0pagefile_perf_t@@QAE@XZ ENDP				; pagefile_perf_t::pagefile_perf_t
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0<unnamed-type-pagefiles>@pagefile_perf_t@@QAE@XZ
_TEXT	SEGMENT
??0<unnamed-type-pagefiles>@pagefile_perf_t@@QAE@XZ PROC ; pagefile_perf_t::<unnamed-type-pagefiles>::<unnamed-type-pagefiles>, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx+256], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+260], 0
	mov	DWORD PTR [ecx+264], 0
	ret	0
??0<unnamed-type-pagefiles>@pagefile_perf_t@@QAE@XZ ENDP ; pagefile_perf_t::<unnamed-type-pagefiles>::<unnamed-type-pagefiles>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0disk_perf_t@@QAE@XZ
_TEXT	SEGMENT
??0disk_perf_t@@QAE@XZ PROC				; disk_perf_t::disk_perf_t, COMDAT
; _this$ = ecx
	mov	edx, ecx
	mov	ecx, 16					; 00000010H
	mov	DWORD PTR [edx], -1
	lea	eax, DWORD PTR [edx+112]
	mov	DWORD PTR [edx+4], -1
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR [edx+12], 0
	mov	DWORD PTR [edx+16], 0
	mov	DWORD PTR [edx+20], 0
	mov	DWORD PTR [edx+24], 0
	mov	DWORD PTR [edx+28], 0
	mov	DWORD PTR [edx+32], 0
	mov	BYTE PTR [edx+36], 1
	mov	DWORD PTR [edx+40], 0
	mov	DWORD PTR [edx+44], 0
	mov	DWORD PTR [edx+48], 0
	mov	DWORD PTR [edx+52], 0
	mov	DWORD PTR [edx+56], 0
	mov	DWORD PTR [edx+60], 0
	mov	DWORD PTR [edx+64], 0
	mov	DWORD PTR [edx+68], 0
$LL7@disk_perf_:
	mov	DWORD PTR [eax-8], 0
	lea	eax, DWORD PTR [eax+88]
	mov	DWORD PTR [eax-92], 0
	mov	DWORD PTR [eax-88], 0
	mov	DWORD PTR [eax-84], 0
	mov	DWORD PTR [eax-80], 0
	mov	DWORD PTR [eax-76], 0
	mov	DWORD PTR [eax-72], 0
	mov	DWORD PTR [eax-68], 0
	mov	DWORD PTR [eax-64], 0
	mov	DWORD PTR [eax-60], 0
	mov	DWORD PTR [eax-56], 0
	mov	DWORD PTR [eax-52], 0
	mov	DWORD PTR [eax-48], 0
	mov	DWORD PTR [eax-44], 0
	sub	ecx, 1
	jne	SHORT $LL7@disk_perf_
	mov	DWORD PTR [edx+1480], ecx
	mov	eax, edx
	ret	0
??0disk_perf_t@@QAE@XZ ENDP				; disk_perf_t::disk_perf_t
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0disk_stat_s@disk_perf_t@@QAE@XZ
_TEXT	SEGMENT
??0disk_stat_s@disk_perf_t@@QAE@XZ PROC			; disk_perf_t::disk_stat_s::disk_stat_s, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx+32], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+40], 0
	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+52], 0
	mov	DWORD PTR [ecx+56], 0
	mov	DWORD PTR [ecx+60], 0
	mov	DWORD PTR [ecx+64], 0
	mov	DWORD PTR [ecx+68], 0
	mov	DWORD PTR [ecx+72], 0
	mov	DWORD PTR [ecx+76], 0
	mov	DWORD PTR [ecx+80], 0
	mov	DWORD PTR [ecx+84], 0
	ret	0
??0disk_stat_s@disk_perf_t@@QAE@XZ ENDP			; disk_perf_t::disk_stat_s::disk_stat_s
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0cpu_perf_t@@QAE@XZ
_TEXT	SEGMENT
??0cpu_perf_t@@QAE@XZ PROC				; cpu_perf_t::cpu_perf_t, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], -1
	lea	eax, DWORD PTR [ecx+64]
	mov	DWORD PTR [ecx+4], -1
	mov	edx, 64					; 00000040H
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+32], 0
	mov	BYTE PTR [ecx+36], 1
	mov	DWORD PTR [ecx+40], 0
	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+52], 0
	mov	DWORD PTR [ecx+56], 0
	npad	3
$LL7@cpu_perf_t:
	mov	DWORD PTR [eax], 0
	lea	eax, DWORD PTR [eax+56]
	mov	DWORD PTR [eax-52], 0
	mov	DWORD PTR [eax-48], 0
	mov	DWORD PTR [eax-44], 0
	mov	DWORD PTR [eax-40], 0
	mov	DWORD PTR [eax-36], 0
	mov	DWORD PTR [eax-32], 0
	mov	DWORD PTR [eax-28], 0
	mov	DWORD PTR [eax-24], 0
	mov	DWORD PTR [eax-20], 0
	mov	DWORD PTR [eax-16], 0
	mov	DWORD PTR [eax-12], 0
	mov	DWORD PTR [eax-8], 0
	sub	edx, 1
	jne	SHORT $LL7@cpu_perf_t
	mov	DWORD PTR [ecx+3648], edx
	mov	eax, ecx
	ret	0
??0cpu_perf_t@@QAE@XZ ENDP				; cpu_perf_t::cpu_perf_t
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0cpu_stat_s@cpu_perf_t@@QAE@XZ
_TEXT	SEGMENT
??0cpu_stat_s@cpu_perf_t@@QAE@XZ PROC			; cpu_perf_t::cpu_stat_s::cpu_stat_s, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+40], 0
	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR [ecx+48], 0
	ret	0
??0cpu_stat_s@cpu_perf_t@@QAE@XZ ENDP			; cpu_perf_t::cpu_stat_s::cpu_stat_s
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0WMI_refresh_thread_t@@QAE@XZ
_TEXT	SEGMENT
??0WMI_refresh_thread_t@@QAE@XZ PROC			; WMI_refresh_thread_t::WMI_refresh_thread_t, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], -1
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], -1
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+32], 0
	mov	BYTE PTR [ecx+36], 1
	ret	0
??0WMI_refresh_thread_t@@QAE@XZ ENDP			; WMI_refresh_thread_t::WMI_refresh_thread_t
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
_TEXT	SEGMENT
_current_io$ = -104					; size = 48
_update_time$ = -56					; size = 16
_dOC$1$ = -48						; size = 8
_dWC$1$ = -40						; size = 8
_dRC$1$ = -32						; size = 8
tv374 = -24						; size = 8
tv369 = -16						; size = 8
tv364 = -8						; size = 8
_update_ftime$ = -8					; size = 8
_ioc$ = 8						; size = 4
_update$ = 12						; size = 8
?SK_CountIO@@YAXAAUio_perf_t@@N@Z PROC			; SK_CountIO

; 42   : {

	npad	2
	push	ebp
	mov	ebp, esp

; 43   :   static HANDLE hProc = GetCurrentProcess ();

	mov	eax, DWORD PTR fs:__tls_array
	sub	esp, 104				; 00000068H
	mov	ecx, DWORD PTR __tls_index
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ?$TSS0@?1??SK_CountIO@@YAXAAUio_perf_t@@N@Z@4HA
	cmp	eax, DWORD PTR __Init_thread_epoch[ecx]
	jg	$LN6@SK_CountIO
$LN2@SK_CountIO:
	push	ebx
	push	esi

; 44   : 
; 45   :   if (ioc.init == false)

	mov	esi, DWORD PTR _ioc$[ebp]
	push	edi
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN3@SK_CountIO

; 46   :   {
; 47   :     memset (&ioc, 0, sizeof (io_perf_t));

	push	168					; 000000a8H
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 48   :     ioc.init = true;

	mov	BYTE PTR [esi], 1
$LN3@SK_CountIO:

; 49   :   }
; 50   : 
; 51   :   SYSTEMTIME     update_time;
; 52   :   FILETIME       update_ftime;
; 53   :   ULARGE_INTEGER update_ul;
; 54   : 
; 55   :   IO_COUNTERS current_io;
; 56   : 
; 57   :   GetProcessIoCounters (hProc, &current_io);

	lea	eax, DWORD PTR _current_io$[ebp]
	push	eax
	push	DWORD PTR ?hProc@?1??SK_CountIO@@YAXAAUio_perf_t@@N@Z@4PAXA
	call	DWORD PTR __imp__GetProcessIoCounters@8

; 58   :   GetSystemTime        (&update_time);

	lea	eax, DWORD PTR _update_time$[ebp]
	push	eax
	call	DWORD PTR __imp__GetSystemTime@4

; 59   :   SystemTimeToFileTime (&update_time, &update_ftime);

	lea	eax, DWORD PTR _update_ftime$[ebp]
	push	eax
	lea	eax, DWORD PTR _update_time$[ebp]
	push	eax
	call	DWORD PTR __imp__SystemTimeToFileTime@8

; 60   : 
; 61   :   update_ul.HighPart = update_ftime.dwHighDateTime;
; 62   :   update_ul.LowPart  = update_ftime.dwLowDateTime;

	mov	ebx, DWORD PTR _update_ftime$[ebp]

; 63   : 
; 64   :   ioc.dt += update_ul.QuadPart - ioc.last_update.QuadPart;

	mov	ecx, ebx
	sub	ecx, DWORD PTR [esi+8]
	mov	edi, DWORD PTR _update_ftime$[ebp+4]
	mov	eax, edi
	sbb	eax, DWORD PTR [esi+12]
	add	DWORD PTR [esi+64], ecx

; 65   : 
; 66   :   ioc.accum.ReadTransferCount +=

	mov	ecx, DWORD PTR _current_io$[ebp+24]
	adc	DWORD PTR [esi+68], eax
	sub	ecx, DWORD PTR [esi+96]
	mov	eax, DWORD PTR _current_io$[ebp+28]
	sbb	eax, DWORD PTR [esi+100]
	add	DWORD PTR [esi+40], ecx

; 67   :     current_io.ReadTransferCount - ioc.last_counter.ReadTransferCount;
; 68   :   ioc.accum.WriteTransferCount +=

	mov	ecx, DWORD PTR _current_io$[ebp+32]
	adc	DWORD PTR [esi+44], eax
	sub	ecx, DWORD PTR [esi+104]
	mov	eax, DWORD PTR _current_io$[ebp+36]
	sbb	eax, DWORD PTR [esi+108]
	add	DWORD PTR [esi+48], ecx

; 69   :     current_io.WriteTransferCount - ioc.last_counter.WriteTransferCount;
; 70   :   ioc.accum.OtherTransferCount +=

	mov	ecx, DWORD PTR _current_io$[ebp+40]
	adc	DWORD PTR [esi+52], eax
	sub	ecx, DWORD PTR [esi+112]
	mov	eax, DWORD PTR _current_io$[ebp+44]
	sbb	eax, DWORD PTR [esi+116]
	add	DWORD PTR [esi+56], ecx

; 71   :     current_io.OtherTransferCount - ioc.last_counter.OtherTransferCount;
; 72   : 
; 73   :   ioc.accum.ReadOperationCount +=

	mov	ecx, DWORD PTR _current_io$[ebp]
	adc	DWORD PTR [esi+60], eax
	sub	ecx, DWORD PTR [esi+72]
	mov	eax, DWORD PTR _current_io$[ebp+4]
	sbb	eax, DWORD PTR [esi+76]
	add	DWORD PTR [esi+16], ecx

; 74   :     current_io.ReadOperationCount - ioc.last_counter.ReadOperationCount;
; 75   :   ioc.accum.WriteOperationCount +=

	mov	ecx, DWORD PTR _current_io$[ebp+8]
	adc	DWORD PTR [esi+20], eax
	sub	ecx, DWORD PTR [esi+80]
	mov	eax, DWORD PTR _current_io$[ebp+12]
	sbb	eax, DWORD PTR [esi+84]
	add	DWORD PTR [esi+24], ecx

; 76   :     current_io.WriteOperationCount - ioc.last_counter.WriteOperationCount;
; 77   :   ioc.accum.OtherOperationCount +=

	mov	ecx, DWORD PTR _current_io$[ebp+16]
	adc	DWORD PTR [esi+28], eax
	sub	ecx, DWORD PTR [esi+88]
	mov	eax, DWORD PTR _current_io$[ebp+20]
	sbb	eax, DWORD PTR [esi+92]
	add	DWORD PTR [esi+32], ecx

; 81   :   auto dWB = static_cast <double> (ioc.accum.WriteTransferCount);

	mov	edx, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [esi+48]
	adc	DWORD PTR [esi+36], eax
	call	__ultod3

; 82   :   auto dOB = static_cast <double> (ioc.accum.OtherTransferCount);

	mov	edx, DWORD PTR [esi+60]
	mov	ecx, DWORD PTR [esi+56]
	movsd	QWORD PTR tv369[ebp], xmm0
	call	__ultod3

; 83   : 
; 84   :   auto dRC = static_cast <double> (ioc.accum.ReadOperationCount);

	mov	edx, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [esi+16]
	movsd	QWORD PTR tv374[ebp], xmm0
	call	__ultod3

; 85   :   auto dWC = static_cast <double> (ioc.accum.WriteOperationCount);

	mov	edx, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [esi+24]
	movsd	QWORD PTR _dRC$1$[ebp], xmm0
	call	__ultod3

; 86   :   auto dOC = static_cast <double> (ioc.accum.OtherOperationCount);

	mov	edx, DWORD PTR [esi+36]
	mov	ecx, DWORD PTR [esi+32]
	movsd	QWORD PTR _dWC$1$[ebp], xmm0
	call	__ultod3

; 87   : 
; 88   :   double& read_mb_sec   = ioc.read_mb_sec;
; 89   :   double& write_mb_sec  = ioc.write_mb_sec;
; 90   :   double& other_mb_sec  = ioc.other_mb_sec;
; 91   : 
; 92   :   double& read_iop_sec  = ioc.read_iop_sec;
; 93   :   double& write_iop_sec = ioc.write_iop_sec;
; 94   :   double& other_iop_sec = ioc.other_iop_sec;
; 95   : 
; 96   :   if (ioc.dt >= update)

	mov	edx, DWORD PTR [esi+68]
	mov	ecx, DWORD PTR [esi+64]
	movsd	QWORD PTR _dOC$1$[ebp], xmm0
	call	__ultod3
	comisd	xmm0, QWORD PTR _update$[ebp]
	movsd	QWORD PTR tv364[ebp], xmm0
	jb	$LN4@SK_CountIO

; 78   :     current_io.OtherOperationCount - ioc.last_counter.OtherOperationCount;
; 79   : 
; 80   :   auto dRB = static_cast <double> (ioc.accum.ReadTransferCount);

	mov	edx, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR [esi+40]
	call	__ultod3

; 97   :   {
; 98   :     read_mb_sec  = (

	movsd	xmm1, QWORD PTR __real@416312d000000000
	divsd	xmm1, QWORD PTR tv364[ebp]
	mulsd	xmm0, QWORD PTR __real@3ea0000000000000
	mulsd	xmm0, xmm1
	movsd	xmm1, QWORD PTR [esi+120]
	mulsd	xmm1, QWORD PTR __real@3fe0000000000000
	addsd	xmm0, xmm1
	movsd	QWORD PTR [esi+120], xmm0

; 99   :       read_mb_sec + ((dRB / 1048576.0) / (1.0e-7 * static_cast <double> (ioc.dt)))
; 100  :                    ) / 2.0;
; 101  :     write_mb_sec = (

	mov	edx, DWORD PTR [esi+68]
	mov	ecx, DWORD PTR [esi+64]
	call	__ultod3
	movsd	xmm1, QWORD PTR __real@416312d000000000
	divsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR tv369[ebp]
	mulsd	xmm0, QWORD PTR __real@3ea0000000000000
	mulsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR [esi+128]
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	addsd	xmm1, xmm0
	movsd	QWORD PTR [esi+128], xmm1

; 102  :       write_mb_sec + ((dWB / 1048576.0) / (1.0e-7 * static_cast <double> (ioc.dt)))
; 103  :                    ) / 2.0;
; 104  :     other_mb_sec = (

	mov	edx, DWORD PTR [esi+68]
	mov	ecx, DWORD PTR [esi+64]
	call	__ultod3
	movsd	xmm1, QWORD PTR __real@416312d000000000
	divsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR tv374[ebp]
	mulsd	xmm0, QWORD PTR __real@3ea0000000000000
	mulsd	xmm1, xmm0
	movsd	xmm0, QWORD PTR [esi+136]
	mulsd	xmm0, QWORD PTR __real@3fe0000000000000
	addsd	xmm1, xmm0
	movsd	QWORD PTR [esi+136], xmm1

; 105  :       other_mb_sec + ((dOB / 1048576.0) / (1.0e-7 * static_cast <double> (ioc.dt)))
; 106  :                    ) / 2.0;
; 107  : 
; 108  :     read_iop_sec  = (read_iop_sec  + (dRC / (1.0e-7 * static_cast <double> (ioc.dt)))) / 2.0;

	mov	edx, DWORD PTR [esi+68]
	mov	ecx, DWORD PTR [esi+64]
	call	__ultod3
	movsd	xmm1, QWORD PTR __real@416312d000000000
	divsd	xmm1, xmm0
	mulsd	xmm1, QWORD PTR _dRC$1$[ebp]
	addsd	xmm1, QWORD PTR [esi+144]
	mulsd	xmm1, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR [esi+144], xmm1

; 109  :     write_iop_sec = (write_iop_sec + (dWC / (1.0e-7 * static_cast <double> (ioc.dt)))) / 2.0;

	mov	edx, DWORD PTR [esi+68]
	mov	ecx, DWORD PTR [esi+64]
	call	__ultod3
	movsd	xmm1, QWORD PTR __real@416312d000000000
	divsd	xmm1, xmm0
	mulsd	xmm1, QWORD PTR _dWC$1$[ebp]
	addsd	xmm1, QWORD PTR [esi+152]
	mulsd	xmm1, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR [esi+152], xmm1

; 110  :     other_iop_sec = (other_iop_sec + (dOC / (1.0e-7 * static_cast <double> (ioc.dt)))) / 2.0;

	mov	edx, DWORD PTR [esi+68]
	mov	ecx, DWORD PTR [esi+64]
	call	__ultod3
	movsd	xmm1, QWORD PTR __real@416312d000000000
	divsd	xmm1, xmm0
	mulsd	xmm1, QWORD PTR _dOC$1$[ebp]
	addsd	xmm1, QWORD PTR [esi+160]
	mulsd	xmm1, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR [esi+160], xmm1

; 111  : 
; 112  :     ioc.accum.ReadTransferCount   = 0;

	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0

; 113  :     ioc.accum.WriteTransferCount  = 0;

	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+52], 0

; 114  :     ioc.accum.OtherTransferCount  = 0;

	mov	DWORD PTR [esi+56], 0
	mov	DWORD PTR [esi+60], 0

; 115  : 
; 116  :     ioc.accum.ReadOperationCount  = 0;

	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0

; 117  :     ioc.accum.WriteOperationCount = 0;

	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0

; 118  :     ioc.accum.OtherOperationCount = 0;

	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0

; 119  : 
; 120  :     ioc.dt = 0;

	mov	DWORD PTR [esi+64], 0
	mov	DWORD PTR [esi+68], 0
$LN4@SK_CountIO:

; 121  :   }
; 122  : 
; 123  :   ioc.last_update.QuadPart = update_ul.QuadPart;
; 124  :   memcpy (&ioc.last_counter, &current_io, sizeof (IO_COUNTERS));

	movups	xmm0, XMMWORD PTR _current_io$[ebp]
	mov	DWORD PTR [esi+12], edi
	pop	edi
	movups	XMMWORD PTR [esi+72], xmm0
	mov	DWORD PTR [esi+8], ebx
	movups	xmm0, XMMWORD PTR _current_io$[ebp+16]
	movups	XMMWORD PTR [esi+88], xmm0
	movups	xmm0, XMMWORD PTR _current_io$[ebp+32]
	movups	XMMWORD PTR [esi+104], xmm0
	pop	esi
	pop	ebx

; 125  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@SK_CountIO:

; 43   :   static HANDLE hProc = GetCurrentProcess ();

	push	OFFSET ?$TSS0@?1??SK_CountIO@@YAXAAUio_perf_t@@N@Z@4HA
	call	__Init_thread_header
	add	esp, 4
	cmp	DWORD PTR ?$TSS0@?1??SK_CountIO@@YAXAAUio_perf_t@@N@Z@4HA, -1
	jne	$LN2@SK_CountIO
	call	DWORD PTR __imp__GetCurrentProcess@0
	push	OFFSET ?$TSS0@?1??SK_CountIO@@YAXAAUio_perf_t@@N@Z@4HA
	mov	DWORD PTR ?hProc@?1??SK_CountIO@@YAXAAUio_perf_t@@N@Z@4PAXA, eax
	call	__Init_thread_footer
	add	esp, 4
	jmp	$LN2@SK_CountIO
?SK_CountIO@@YAXAAUio_perf_t@@N@Z ENDP			; SK_CountIO
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h
;	COMDAT ??1SK_AutoCOMInit@@QAE@XZ
_TEXT	SEGMENT
??1SK_AutoCOMInit@@QAE@XZ PROC				; SK_AutoCOMInit::~SK_AutoCOMInit, COMDAT
; _this$ = ecx

; 52   :     if (success)

	cmp	BYTE PTR [ecx], 0
	je	SHORT $LN2@SK_AutoCOM

; 53   :       CoUninitialize ();

	jmp	DWORD PTR __imp__CoUninitialize@0
$LN2@SK_AutoCOM:

; 54   :   }

	ret	0
??1SK_AutoCOMInit@@QAE@XZ ENDP				; SK_AutoCOMInit::~SK_AutoCOMInit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\io_monitor.h
;	COMDAT ??0SK_AutoCOMInit@@QAE@XZ
_TEXT	SEGMENT
??0SK_AutoCOMInit@@QAE@XZ PROC				; SK_AutoCOMInit::SK_AutoCOMInit, COMDAT
; _this$ = ecx

; 44   :   SK_AutoCOMInit (void) {

	npad	2
	push	esi
	mov	esi, ecx

; 45   :     HRESULT hr = CoInitializeEx (NULL, COINIT_MULTITHREADED);

	push	0
	push	0

; 50   : 
; 51   :   ~SK_AutoCOMInit (void) {
; 52   :     if (success)
; 53   :       CoUninitialize ();
; 54   :   }
; 55   : 
; 56   : private:
; 57   :   bool success = false;

	mov	BYTE PTR [esi], 0
	call	DWORD PTR __imp__CoInitializeEx@8
	test	eax, eax
	mov	eax, esi
	js	SHORT $LN2@SK_AutoCOM

; 46   : 
; 47   :     if (SUCCEEDED (hr))
; 48   :       success = true;

	mov	BYTE PTR [esi], 1
$LN2@SK_AutoCOM:
	pop	esi

; 49   :   }

	ret	0
??0SK_AutoCOMInit@@QAE@XZ ENDP				; SK_AutoCOMInit::SK_AutoCOMInit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp
_TEXT	SEGMENT
_hServerThread$1 = -4					; size = 4
?SK_ShutdownWMI@@YAXXZ PROC				; SK_ShutdownWMI

; 378  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 379  :   if (InterlockedCompareExchange (&COM::base.wmi.init, 0, 1))

	xor	ecx, ecx
	mov	edx, OFFSET ?base@COM@@3UBase@1@A+4
	mov	eax, 1
	lock	 cmpxchg DWORD PTR [edx], ecx
	test	eax, eax
	je	SHORT $LN3@SK_Shutdow

; 380  :   {
; 381  :     HANDLE hServerThread = 
; 382  :      ReadPointerAcquire (&COM::base.wmi.hServerThread);

	mov	eax, DWORD PTR ?base@COM@@3UBase@1@A+20

; 383  : 
; 384  :     SetEvent (COM::base.wmi.hShutdownServer);

	push	DWORD PTR ?base@COM@@3UBase@1@A+24
	mov	DWORD PTR _hServerThread$1[ebp], eax
	call	DWORD PTR __imp__SetEvent@4

; 385  : 
; 386  :     if (hServerThread)

	cmp	DWORD PTR _hServerThread$1[ebp], 0
	je	SHORT $LN15@SK_Shutdow
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 5265 :     return (PVOID)InterlockedExchange((LONG volatile *) Destination,

	xor	eax, eax
	lea	ecx, DWORD PTR _hServerThread$1[ebp]
	xchg	DWORD PTR [ecx], eax
$LN15@SK_Shutdow:

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?base@COM@@3UBase@1@A+4
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 391  :     while (ReadAcquire (&COM::base.wmi.init))

	test	eax, eax
	je	SHORT $LN3@SK_Shutdow
	push	esi
	mov	esi, DWORD PTR __imp__SleepEx@8
	npad	5
$LL2@SK_Shutdow:

; 392  :       SleepEx (333, TRUE);

	push	1
	push	333					; 0000014dH
	call	esi
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?base@COM@@3UBase@1@A+4
; File c:\users\andon\source\repos\specialk\src\io_monitor.cpp

; 391  :     while (ReadAcquire (&COM::base.wmi.init))

	test	eax, eax
	jne	SHORT $LL2@SK_Shutdow
	pop	esi
$LN3@SK_Shutdow:

; 393  :   }
; 394  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SK_ShutdownWMI@@YAXXZ ENDP				; SK_ShutdownWMI
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
;	COMDAT _RtlSecureZeroMemory
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_cnt$ = 12						; size = 4
_RtlSecureZeroMemory PROC				; COMDAT

; 17787: {

	npad	2
	push	ebp
	mov	ebp, esp

; 17788:     volatile char *vptr = (volatile char *)ptr;
; 17789: 
; 17790: #if defined(_M_AMD64)
; 17791: 
; 17792:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);
; 17793: 
; 17794: #else
; 17795: 
; 17796:     while (cnt) {

	mov	edx, DWORD PTR _cnt$[ebp]
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	ecx, eax
	test	edx, edx
	je	SHORT $LN3@RtlSecureZ
$LL2@RtlSecureZ:

; 17797: 
; 17798: #if !defined(_M_CEE) && defined(_M_ARM)
; 17799: 
; 17800:         __iso_volatile_store8(vptr, 0);
; 17801: 
; 17802: #else
; 17803: 
; 17804:         *vptr = 0;

	mov	BYTE PTR [ecx], 0

; 17805: 
; 17806: #endif
; 17807: 
; 17808:         vptr++;

	lea	ecx, DWORD PTR [ecx+1]

; 17809:         cnt--;

	sub	edx, 1
	jne	SHORT $LL2@RtlSecureZ
$LN3@RtlSecureZ:

; 17810:     }
; 17811: 
; 17812: #endif // _M_AMD64
; 17813: 
; 17814:     return ptr;
; 17815: }

	pop	ebp
	ret	0
_RtlSecureZeroMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
;	COMDAT _ReadPointerAcquire
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_ReadPointerAcquire PROC				; COMDAT

; 8591 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	eax, DWORD PTR [eax]

; 8592 : 
; 8593 :     return (PVOID)ReadAcquire((PLONG)Source);
; 8594 : }

	pop	ebp
	ret	0
_ReadPointerAcquire ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
;	COMDAT _ReadAcquire
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_ReadAcquire PROC					; COMDAT

; 8059 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 8060 : 
; 8061 :     LONG Value;
; 8062 : 
; 8063 :     Value = *Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	eax, DWORD PTR [eax]

; 8064 :     return Value;
; 8065 : }

	pop	ebp
	ret	0
_ReadAcquire ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
;	COMDAT __InlineInterlockedCompareExchangePointer
_TEXT	SEGMENT
_Destination$ = 8					; size = 4
_ExChange$ = 12						; size = 4
_Comperand$ = 16					; size = 4
__InlineInterlockedCompareExchangePointer PROC		; COMDAT

; 5285 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 5286 :     return (PVOID)InterlockedCompareExchange((LONG volatile *) Destination,

	mov	edx, DWORD PTR _ExChange$[ebp]
	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	eax, DWORD PTR _Comperand$[ebp]
	lock	 cmpxchg DWORD PTR [ecx], edx

; 5287 :                                              (LONG) ExChange,
; 5288 :                                              (LONG) Comperand);
; 5289 : }

	pop	ebp
	ret	0
__InlineInterlockedCompareExchangePointer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
;	COMDAT __InlineInterlockedExchangePointer
_TEXT	SEGMENT
_Destination$ = 8					; size = 4
_Value$ = 12						; size = 4
__InlineInterlockedExchangePointer PROC			; COMDAT

; 5264 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 5265 :     return (PVOID)InterlockedExchange((LONG volatile *) Destination,

	mov	eax, DWORD PTR _Value$[ebp]
	mov	ecx, DWORD PTR _Destination$[ebp]
	xchg	DWORD PTR [ecx], eax

; 5266 :                                       (LONG) Value);
; 5267 : }

	pop	ebp
	ret	0
__InlineInterlockedExchangePointer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstring.h
;	COMDAT ?wcsrchr@@YAPA_WPA_W_W@Z
_TEXT	SEGMENT
__String$ = 8						; size = 4
__C$ = 12						; size = 2
?wcsrchr@@YAPA_WPA_W_W@Z PROC				; wcsrchr, COMDAT

; 545  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 547  :     }

	pop	ebp

; 546  :         return const_cast<wchar_t*>(wcsrchr(static_cast<wchar_t const*>(_String), _C));

	jmp	DWORD PTR __imp__wcsrchr
?wcsrchr@@YAPA_WPA_W_W@Z ENDP				; wcsrchr
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___n$[ebp]
	test	esi, esi
	je	SHORT $LN6@vector
	push	ebx
	mov	ebx, DWORD PTR ___f$[ebp]
	push	edi
	mov	edi, DWORD PTR ___t$[ebp]
$LL2@vector:
	mov	ecx, edi
	call	ebx
	add	edi, DWORD PTR ___s$[ebp]
	sub	esi, 1
	jne	SHORT $LL2@vector
	pop	edi
	pop	ebx
$LN6@vector:
	pop	esi
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
