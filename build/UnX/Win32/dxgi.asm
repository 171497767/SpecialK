; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	C:\Users\andon\Source\Repos\SpecialK\src\dxgi.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_pAtlModule@ATL@@3PAVCAtlModule@1@A		; ATL::_pAtlModule
PUBLIC	_LIBID_ATLLib
PUBLIC	_IID_IAxWinAmbientDispatchEx
PUBLIC	?SK_DXGI_use_factory1@@3_NA			; SK_DXGI_use_factory1
PUBLIC	?SK_DXGI_factory_init@@3_NA			; SK_DXGI_factory_init
PUBLIC	?__dxgi_ready@@3JC				; __dxgi_ready
PUBLIC	_IID_IInternalConnection
PUBLIC	___pobjMapEntryFirst
PUBLIC	___pobjMapEntryLast
PUBLIC	?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA	; ATL::_pPerfRegFunc
PUBLIC	?_pPerfUnRegFunc@ATL@@3P6AJXZA			; ATL::_pPerfUnRegFunc
PUBLIC	?_AtlRegisterPerUser@ATL@@3_NA			; ATL::_AtlRegisterPerUser
PUBLIC	?bAlwaysAllowFullscreen@@3_NA			; bAlwaysAllowFullscreen
PUBLIC	?_pModule@ATL@@3PAVCComModule@1@A		; ATL::_pModule
PUBLIC	?bFlipMode@@3_NA				; bFlipMode
PUBLIC	?bWait@@3_NA					; bWait
PUBLIC	?SK_DXGI_preferred_adapter@@3HA			; SK_DXGI_preferred_adapter
PUBLIC	?SK_D3D11_init_tid@@3JC				; SK_D3D11_init_tid
PUBLIC	?SK_D3D11_ansel_tid@@3JC			; SK_D3D11_ansel_tid
PUBLIC	?pfnChangeDisplaySettingsA@@3PAXA		; pfnChangeDisplaySettingsA
PUBLIC	?ChangeDisplaySettingsA_Original@@3P6GJPAU_devicemodeA@@K@ZA ; ChangeDisplaySettingsA_Original
PUBLIC	_CLSID_Registrar
PUBLIC	?CreateDXGIFactory_Import@@3P6GJABU_GUID@@PAPAX@ZA ; CreateDXGIFactory_Import
PUBLIC	?CreateDXGIFactory1_Import@@3P6GJABU_GUID@@PAPAX@ZA ; CreateDXGIFactory1_Import
PUBLIC	?CreateDXGIFactory2_Import@@3P6GJIABU_GUID@@PAPAX@ZA ; CreateDXGIFactory2_Import
PUBLIC	?dwRenderThread@@3KA				; dwRenderThread
PUBLIC	?hWndRender@@3PAUHWND__@@A			; hWndRender
PUBLIC	_IID_IRegistrar
PUBLIC	?PresentSwapChain_Original_Pre@@3P6GJPAUIDXGISwapChain@@II@ZA ; PresentSwapChain_Original_Pre
PUBLIC	?chDirSep@ATL@@3_WB				; ATL::chDirSep
PUBLIC	?chRightBracket@ATL@@3_WB			; ATL::chRightBracket
PUBLIC	?chLeftBracket@ATL@@3_WB			; ATL::chLeftBracket
PUBLIC	?chQuote@ATL@@3_WB				; ATL::chQuote
PUBLIC	?chEquals@ATL@@3_WB				; ATL::chEquals
PUBLIC	?szStringVal@ATL@@3QB_WB			; ATL::szStringVal
PUBLIC	?multiszStringVal@ATL@@3QB_WB			; ATL::multiszStringVal
PUBLIC	?szDwordVal@ATL@@3QB_WB				; ATL::szDwordVal
PUBLIC	?szBinaryVal@ATL@@3QB_WB			; ATL::szBinaryVal
PUBLIC	?szValToken@ATL@@3QB_WB				; ATL::szValToken
PUBLIC	?szForceRemove@ATL@@3QB_WB			; ATL::szForceRemove
PUBLIC	?szNoRemove@ATL@@3QB_WB				; ATL::szNoRemove
PUBLIC	?szDelete@ATL@@3QB_WB				; ATL::szDelete
PUBLIC	_IID_IDocHostUIHandlerDispatch
PUBLIC	?CreateSwapChain_Original@@3P6GJPAUIDXGIFactory@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@ZA ; CreateSwapChain_Original
PUBLIC	?Present_GuardBytes@@3PAEA			; Present_GuardBytes
PUBLIC	?Present_Target@@3P6GJPAUIDXGISwapChain@@II@ZA	; Present_Target
PUBLIC	?Present_Original@@3P6GJPAUIDXGISwapChain@@II@ZA ; Present_Original
PUBLIC	?Present1_Original@@3P6GJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@ZA ; Present1_Original
PUBLIC	?SetFullscreenState_Original@@3P6GJPAUIDXGISwapChain@@HPAUIDXGIOutput@@@ZA ; SetFullscreenState_Original
PUBLIC	?GetFullscreenState_Original@@3P6GJPAUIDXGISwapChain@@PAHPAPAUIDXGIOutput@@@ZA ; GetFullscreenState_Original
PUBLIC	?ResizeBuffers_Original@@3P6GJPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@ZA ; ResizeBuffers_Original
PUBLIC	?ResizeTarget_Original@@3P6GJPAUIDXGISwapChain@@PBUDXGI_MODE_DESC@@@ZA ; ResizeTarget_Original
PUBLIC	?GetDisplayModeList_Original@@3P6GJPAUIDXGIOutput@@W4DXGI_FORMAT@@IPAIPAUDXGI_MODE_DESC@@@ZA ; GetDisplayModeList_Original
PUBLIC	?FindClosestMatchingMode_Original@@3P6GJPAUIDXGIOutput@@PBUDXGI_MODE_DESC@@PAU2@PAUIUnknown@@@ZA ; FindClosestMatchingMode_Original
PUBLIC	?WaitForVBlank_Original@@3P6GJPAUIDXGIOutput@@@ZA ; WaitForVBlank_Original
PUBLIC	?CreateSwapChainForHwnd_Original@@3P6GJPAUIDXGIFactory2@@PAUIUnknown@@PAUHWND__@@PBUDXGI_SWAP_CHAIN_DESC1@@PBUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@ZA ; CreateSwapChainForHwnd_Original
PUBLIC	?CreateSwapChainForCoreWindow_Original@@3P6GJPAUIDXGIFactory2@@PAUIUnknown@@1PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@ZA ; CreateSwapChainForCoreWindow_Original
PUBLIC	?CreateSwapChainForComposition_Original@@3P6GJPAUIDXGIFactory2@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@ZA ; CreateSwapChainForComposition_Original
PUBLIC	?GetDesc_Original@@3P6GJPAUIDXGIAdapter@@PAUDXGI_ADAPTER_DESC@@@ZA ; GetDesc_Original
PUBLIC	?GetDesc1_Original@@3P6GJPAUIDXGIAdapter1@@PAUDXGI_ADAPTER_DESC1@@@ZA ; GetDesc1_Original
PUBLIC	?GetDesc2_Original@@3P6GJPAUIDXGIAdapter2@@PAUDXGI_ADAPTER_DESC2@@@ZA ; GetDesc2_Original
PUBLIC	?EnumAdapters_Original@@3P6GJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@@ZA ; EnumAdapters_Original
PUBLIC	?EnumAdapters1_Original@@3P6GJPAUIDXGIFactory1@@IPAPAUIDXGIAdapter1@@@ZA ; EnumAdapters1_Original
PUBLIC	?d3d11_hook_ctx@@3Usk_hook_d3d11_t@@A		; d3d11_hook_ctx
PUBLIC	?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A ; ATL::_pAtlAutoThreadModule
PUBLIC	_IID_IAxWinHostWindow
PUBLIC	?cegD3D11@@3PAVDirect3D11Renderer@CEGUI@@A	; cegD3D11
PUBLIC	_IID_IAxWinHostWindowLic
PUBLIC	?SK_achv_popup@@3PAVWindow@CEGUI@@A		; SK_achv_popup
PUBLIC	_IID_IAxWinAmbientDispatch
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_BSS	SEGMENT
?_pAtlModule@ATL@@3PAVCAtlModule@1@A DD 01H DUP (?)	; ATL::_pAtlModule
_BSS	ENDS
_BSS	SEGMENT
?SK_DXGI_use_factory1@@3_NA DB 01H DUP (?)		; SK_DXGI_use_factory1
	ALIGN	4

?SK_DXGI_factory_init@@3_NA DB 01H DUP (?)		; SK_DXGI_factory_init
	ALIGN	4

?__dxgi_ready@@3JC DD 01H DUP (?)			; __dxgi_ready
_BSS	ENDS
;	COMDAT ?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA
_BSS	SEGMENT
?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA DD 01H DUP (?) ; ATL::_pPerfRegFunc
_BSS	ENDS
;	COMDAT ?_pPerfUnRegFunc@ATL@@3P6AJXZA
_BSS	SEGMENT
?_pPerfUnRegFunc@ATL@@3P6AJXZA DD 01H DUP (?)		; ATL::_pPerfUnRegFunc
_BSS	ENDS
;	COMDAT ?_AtlRegisterPerUser@ATL@@3_NA
_BSS	SEGMENT
?_AtlRegisterPerUser@ATL@@3_NA DB 01H DUP (?)		; ATL::_AtlRegisterPerUser
_BSS	ENDS
;	COMDAT ?_pModule@ATL@@3PAVCComModule@1@A
_BSS	SEGMENT
?_pModule@ATL@@3PAVCComModule@1@A DD 01H DUP (?)	; ATL::_pModule
_BSS	ENDS
_BSS	SEGMENT
?bFlipMode@@3_NA DB 01H DUP (?)				; bFlipMode
	ALIGN	4

?bWait@@3_NA DB	01H DUP (?)				; bWait
	ALIGN	4

?SK_D3D11_init_tid@@3JC DD 01H DUP (?)			; SK_D3D11_init_tid
?SK_D3D11_ansel_tid@@3JC DD 01H DUP (?)			; SK_D3D11_ansel_tid
?pfnChangeDisplaySettingsA@@3PAXA DD 01H DUP (?)	; pfnChangeDisplaySettingsA
?ChangeDisplaySettingsA_Original@@3P6GJPAU_devicemodeA@@K@ZA DD 01H DUP (?) ; ChangeDisplaySettingsA_Original
?CreateDXGIFactory_Import@@3P6GJABU_GUID@@PAPAX@ZA DD 01H DUP (?) ; CreateDXGIFactory_Import
?CreateDXGIFactory1_Import@@3P6GJABU_GUID@@PAPAX@ZA DD 01H DUP (?) ; CreateDXGIFactory1_Import
?CreateDXGIFactory2_Import@@3P6GJIABU_GUID@@PAPAX@ZA DD 01H DUP (?) ; CreateDXGIFactory2_Import
?dwRenderThread@@3KA DD 01H DUP (?)			; dwRenderThread
?hWndRender@@3PAUHWND__@@A DD 01H DUP (?)		; hWndRender
?PresentSwapChain_Original_Pre@@3P6GJPAUIDXGISwapChain@@II@ZA DD 01H DUP (?) ; PresentSwapChain_Original_Pre
?CreateSwapChain_Original@@3P6GJPAUIDXGIFactory@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@ZA DD 01H DUP (?) ; CreateSwapChain_Original
?Present_GuardBytes@@3PAEA DB 010H DUP (?)		; Present_GuardBytes
?Present_Target@@3P6GJPAUIDXGISwapChain@@II@ZA DD 01H DUP (?) ; Present_Target
?Present_Original@@3P6GJPAUIDXGISwapChain@@II@ZA DD 01H DUP (?) ; Present_Original
?Present1_Original@@3P6GJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@ZA DD 01H DUP (?) ; Present1_Original
?SetFullscreenState_Original@@3P6GJPAUIDXGISwapChain@@HPAUIDXGIOutput@@@ZA DD 01H DUP (?) ; SetFullscreenState_Original
?GetFullscreenState_Original@@3P6GJPAUIDXGISwapChain@@PAHPAPAUIDXGIOutput@@@ZA DD 01H DUP (?) ; GetFullscreenState_Original
?ResizeBuffers_Original@@3P6GJPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@ZA DD 01H DUP (?) ; ResizeBuffers_Original
?ResizeTarget_Original@@3P6GJPAUIDXGISwapChain@@PBUDXGI_MODE_DESC@@@ZA DD 01H DUP (?) ; ResizeTarget_Original
?GetDisplayModeList_Original@@3P6GJPAUIDXGIOutput@@W4DXGI_FORMAT@@IPAIPAUDXGI_MODE_DESC@@@ZA DD 01H DUP (?) ; GetDisplayModeList_Original
?FindClosestMatchingMode_Original@@3P6GJPAUIDXGIOutput@@PBUDXGI_MODE_DESC@@PAU2@PAUIUnknown@@@ZA DD 01H DUP (?) ; FindClosestMatchingMode_Original
?WaitForVBlank_Original@@3P6GJPAUIDXGIOutput@@@ZA DD 01H DUP (?) ; WaitForVBlank_Original
?CreateSwapChainForHwnd_Original@@3P6GJPAUIDXGIFactory2@@PAUIUnknown@@PAUHWND__@@PBUDXGI_SWAP_CHAIN_DESC1@@PBUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@ZA DD 01H DUP (?) ; CreateSwapChainForHwnd_Original
?CreateSwapChainForCoreWindow_Original@@3P6GJPAUIDXGIFactory2@@PAUIUnknown@@1PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@ZA DD 01H DUP (?) ; CreateSwapChainForCoreWindow_Original
?CreateSwapChainForComposition_Original@@3P6GJPAUIDXGIFactory2@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@ZA DD 01H DUP (?) ; CreateSwapChainForComposition_Original
?GetDesc_Original@@3P6GJPAUIDXGIAdapter@@PAUDXGI_ADAPTER_DESC@@@ZA DD 01H DUP (?) ; GetDesc_Original
?GetDesc1_Original@@3P6GJPAUIDXGIAdapter1@@PAUDXGI_ADAPTER_DESC1@@@ZA DD 01H DUP (?) ; GetDesc1_Original
?GetDesc2_Original@@3P6GJPAUIDXGIAdapter2@@PAUDXGI_ADAPTER_DESC2@@@ZA DD 01H DUP (?) ; GetDesc2_Original
?EnumAdapters_Original@@3P6GJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@@ZA DD 01H DUP (?) ; EnumAdapters_Original
?EnumAdapters1_Original@@3P6GJPAUIDXGIFactory1@@IPAPAUIDXGIAdapter1@@@ZA DD 01H DUP (?) ; EnumAdapters1_Original
?d3d11_hook_ctx@@3Usk_hook_d3d11_t@@A DQ 01H DUP (?)	; d3d11_hook_ctx
?imgui_swap@@3PAUIDXGISwapChain@@A DD 01H DUP (?)	; imgui_swap
_BSS	ENDS
;	COMDAT ?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A
_BSS	SEGMENT
?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A DD 01H DUP (?) ; ATL::_pAtlAutoThreadModule
_BSS	ENDS
_BSS	SEGMENT
?cegD3D11@@3PAVDirect3D11Renderer@CEGUI@@A DD 01H DUP (?) ; cegD3D11
?__cegui_frames_drawn@@3KC DD 01H DUP (?)		; __cegui_frames_drawn
?SK_achv_popup@@3PAVWindow@CEGUI@@A DD 01H DUP (?)	; SK_achv_popup
_BSS	ENDS
;	COMDAT _IID_IAxWinAmbientDispatch
CONST	SEGMENT
_IID_IAxWinAmbientDispatch DD 0b6ea2051H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindowLic
CONST	SEGMENT
_IID_IAxWinHostWindowLic DD 03935bda8H
	DW	04ed9H
	DW	0495cH
	DB	086H
	DB	050H
	DB	0e0H
	DB	01fH
	DB	0c1H
	DB	0e3H
	DB	08aH
	DB	04bH
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindow
CONST	SEGMENT
_IID_IAxWinHostWindow DD 0b6ea2050H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT _IID_IDocHostUIHandlerDispatch
CONST	SEGMENT
_IID_IDocHostUIHandlerDispatch DD 0425b5af0H
	DW	065f1H
	DW	011d1H
	DB	096H
	DB	011H
	DB	00H
	DB	00H
	DB	0f8H
	DB	01eH
	DB	0dH
	DB	0dH
CONST	ENDS
;	COMDAT ?szDelete@ATL@@3QB_WB
CONST	SEGMENT
?szDelete@ATL@@3QB_WB DD FLAT:$SG211484			; ATL::szDelete
CONST	ENDS
;	COMDAT ?szNoRemove@ATL@@3QB_WB
CONST	SEGMENT
?szNoRemove@ATL@@3QB_WB DD FLAT:$SG211482		; ATL::szNoRemove
CONST	ENDS
;	COMDAT ?szForceRemove@ATL@@3QB_WB
CONST	SEGMENT
?szForceRemove@ATL@@3QB_WB DD FLAT:$SG211480		; ATL::szForceRemove
CONST	ENDS
;	COMDAT ?szValToken@ATL@@3QB_WB
CONST	SEGMENT
?szValToken@ATL@@3QB_WB DD FLAT:$SG211478		; ATL::szValToken
CONST	ENDS
;	COMDAT ?szBinaryVal@ATL@@3QB_WB
CONST	SEGMENT
?szBinaryVal@ATL@@3QB_WB DD FLAT:$SG211476		; ATL::szBinaryVal
CONST	ENDS
;	COMDAT ?szDwordVal@ATL@@3QB_WB
CONST	SEGMENT
?szDwordVal@ATL@@3QB_WB DD FLAT:$SG211474		; ATL::szDwordVal
CONST	ENDS
;	COMDAT ?multiszStringVal@ATL@@3QB_WB
CONST	SEGMENT
?multiszStringVal@ATL@@3QB_WB DD FLAT:$SG211472		; ATL::multiszStringVal
CONST	ENDS
;	COMDAT ?szStringVal@ATL@@3QB_WB
CONST	SEGMENT
?szStringVal@ATL@@3QB_WB DD FLAT:$SG211470		; ATL::szStringVal
CONST	ENDS
;	COMDAT ?chEquals@ATL@@3_WB
CONST	SEGMENT
?chEquals@ATL@@3_WB DW 03dH				; ATL::chEquals
CONST	ENDS
;	COMDAT ?chQuote@ATL@@3_WB
CONST	SEGMENT
?chQuote@ATL@@3_WB DW 027H				; ATL::chQuote
CONST	ENDS
;	COMDAT ?chLeftBracket@ATL@@3_WB
CONST	SEGMENT
?chLeftBracket@ATL@@3_WB DW 07bH			; ATL::chLeftBracket
CONST	ENDS
;	COMDAT ?chRightBracket@ATL@@3_WB
CONST	SEGMENT
?chRightBracket@ATL@@3_WB DW 07dH			; ATL::chRightBracket
CONST	ENDS
;	COMDAT ?chDirSep@ATL@@3_WB
CONST	SEGMENT
?chDirSep@ATL@@3_WB DW 05cH				; ATL::chDirSep
CONST	ENDS
;	COMDAT _IID_IRegistrar
CONST	SEGMENT
_IID_IRegistrar DD 044ec053bH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT _CLSID_Registrar
CONST	SEGMENT
_CLSID_Registrar DD 044ec053aH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
_DATA	SEGMENT
?bAlwaysAllowFullscreen@@3_NA DB 01H			; bAlwaysAllowFullscreen
	ORG $+3
?SK_DXGI_preferred_adapter@@3HA DD 0ffffffffH		; SK_DXGI_preferred_adapter
?__gui_reset@@3KC DD 01H				; __gui_reset
_DATA	ENDS
;	COMDAT ___pobjMapEntryLast
ATL$__z	SEGMENT
___pobjMapEntryLast DD 00H
ATL$__z	ENDS
;	COMDAT ___pobjMapEntryFirst
ATL$__a	SEGMENT
___pobjMapEntryFirst DD 00H
ATL$__a	ENDS
;	COMDAT _IID_IInternalConnection
CONST	SEGMENT
_IID_IInternalConnection DD 072ad0770H
	DW	06a9fH
	DW	011d1H
	DB	0bcH
	DB	0ecH
	DB	00H
	DB	060H
	DB	08H
	DB	08fH
	DB	044H
	DB	04eH
CONST	ENDS
;	COMDAT _IID_IAxWinAmbientDispatchEx
CONST	SEGMENT
_IID_IAxWinAmbientDispatchEx DD 0b2d0778bH
	DW	0ac99H
	DW	04c58H
	DB	0a5H
	DB	0c8H
	DB	0e7H
	DB	072H
	DB	04eH
	DB	053H
	DB	016H
	DB	0b5H
CONST	ENDS
;	COMDAT _LIBID_ATLLib
CONST	SEGMENT
_LIBID_ATLLib DD 044ec0535H
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
CONST	SEGMENT
$SG352256 DB	'/animations/', 00H
$SG352265 DB	00H
$SG352267 DB	00H
$SG352269 DB	00H
$SG352257 DB	'animations', 00H
$SG352271 DB	00H
$SG352258 DB	'imagesets', 00H
$SG352273 DB	00H
$SG352275 DB	00H
$SG200706 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'U', 00H, 't', 00H, 'i', 00H, 'l', 00H, 00H
	DB	00H
$SG352277 DB	00H
$SG352287 DB	00H
$SG352259 DB	'fonts', 00H
?piecewise_construct@std@@3Upiecewise_construct_t@1@B	ORG $+1 ; std::piecewise_construct
$SG352124 DB	00H
$SG352260 DB	'schemes', 00H
$SG352261 DB	'looknfeels', 00H
	ORG $+1
$SG352262 DB	'layouts', 00H
$SG352263 DB	'lua_scripts', 00H
$SG352264 DB	'animations', 00H
	ORG $+1
$SG352266 DB	'VanillaSkin.scheme', 00H
	ORG $+1
$SG352268 DB	'TaharezLook.scheme', 00H
	ORG $+1
$SG352270 DB	'DejaVuSans-10-NoScale.font', 00H
	ORG $+1
$SG352272 DB	'DejaVuSans-12-NoScale.font', 00H
	ORG $+1
$SG352274 DB	'Jura-18-NoScale.font', 00H
	ORG $+3
$SG352276 DB	'Jura-13-NoScale.font', 00H
	ORG $+3
$SG352278 DB	'Jura-10-NoScale.font', 00H
	ORG $+3
$SG352281 DB	'SchemaDefaultResourceGroup', 00H
	ORG $+1
$SG352282 DB	'schemas', 00H
$SG352283 DB	'SchemaDefaultResourceGroup', 00H
	ORG $+1
$SG352285 DB	'root', 00H
	ORG $+3
$SG352286 DB	'DefaultWindow', 00H
	ORG $+2
$SG352288 DB	'Achievements.layout', 00H
$SG356395 DB	'R', 00H, 'e', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H
	DB	'T', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'e', 00H, 't', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, 00H, 00H
$SG356393 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '@', 00H, ']', 00H, ' ', 00H, ' ', 00H, 'R', 00H
	DB	'e', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'n', 00H, ':', 00H, ' '
	DB	00H, '%', 00H, 's', 00H, ' ', 00H, ' ', 00H, '-', 00H, ' ', 00H
	DB	' ', 00H, '<', 00H, ' ', 00H, 'R', 00H, 'e', 00H, 's', 00H, 'i'
	DB	00H, 'z', 00H, 'e', 00H, 'T', 00H, 'a', 00H, 'r', 00H, 'g', 00H
	DB	'e', 00H, 't', 00H, '_', 00H, 'O', 00H, 'r', 00H, 'i', 00H, 'g'
	DB	00H, 'i', 00H, 'n', 00H, 'a', 00H, 'l', 00H, ' ', 00H, '(', 00H
	DB	'T', 00H, 'h', 00H, 'i', 00H, 's', 00H, ',', 00H, ' ', 00H, 'p'
	DB	00H, 'N', 00H, 'e', 00H, 'w', 00H, 'T', 00H, 'a', 00H, 'r', 00H
	DB	'g', 00H, 'e', 00H, 't', 00H, 'P', 00H, 'a', 00H, 'r', 00H, 'a'
	DB	00H, 'm', 00H, 'e', 00H, 't', 00H, 'e', 00H, 'r', 00H, 's', 00H
	DB	')', 00H, ' ', 00H, '>', 00H, 00H, 00H
$SG356396 DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'I', 00H, 'D', 00H
	DB	'X', 00H, 'G', 00H, 'I', 00H, 'S', 00H, 'w', 00H, 'a', 00H, 'p'
	DB	00H, 'C', 00H, 'h', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG356397 DB	'%', 00H, 's', 00H, ':', 00H, ':', 00H, '%', 00H, 's', 00H
	DB	' ', 00H, '(', 00H, 00H, 00H
	ORG $+2
$SG356399 DB	'%', 00H, 's', 00H, '%', 00H, 's', 00H, ')', 00H, 00H, 00H
$SG356398 DB	'{', 00H, ' ', 00H, '(', 00H, '%', 00H, 'l', 00H, 'u', 00H
	DB	'x', 00H, '%', 00H, 'l', 00H, 'u', 00H, '@', 00H, '%', 00H, '3'
	DB	00H, '.', 00H, '1', 00H, 'f', 00H, ' ', 00H, 'H', 00H, 'z', 00H
	DB	')', 00H, ',', 00H, 'f', 00H, 'm', 00H, 't', 00H, '=', 00H, '%'
	DB	00H, 'l', 00H, 'u', 00H, ',', 00H, 's', 00H, 'c', 00H, 'a', 00H
	DB	'l', 00H, 'i', 00H, 'n', 00H, 'g', 00H, '=', 00H, '0', 00H, 'x'
	DB	00H, '%', 00H, '0', 00H, '2', 00H, 'x', 00H, ',', 00H, 's', 00H
	DB	'c', 00H, 'a', 00H, 'n', 00H, 'l', 00H, 'i', 00H, 'n', 00H, 'e'
	DB	00H, 's', 00H, '=', 00H, '0', 00H, 'x', 00H, '%', 00H, '0', 00H
	DB	'2', 00H, 'x', 00H, ' ', 00H, '}', 00H, 00H, 00H
	ORG $+2
$SG356400 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '%', 00H, '-', 00H
	DB	'1', 00H, '0', 00H, '2', 00H, 's', 00H, ' ', 00H, '-', 00H, '-'
	DB	00H, ' ', 00H, '%', 00H, 's', 00H, 00H, 00H
$SG357425 DB	'(', 00H, '*', 00H, 'p', 00H, 'A', 00H, 'd', 00H, 'a', 00H
	DB	'p', 00H, 't', 00H, 'e', 00H, 'r', 00H, '2', 00H, ')', 00H, '-'
	DB	00H, '>', 00H, 'G', 00H, 'e', 00H, 't', 00H, 'D', 00H, 'e', 00H
	DB	's', 00H, 'c', 00H, '2', 00H, 00H, 00H
	ORG $+2
$SG200753 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'S', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 'r'
	DB	00H, 'i', 00H, 't', 00H, 'y', 00H, 00H, 00H
	ORG $+2
$SG357429 DB	'(', 00H, '*', 00H, 'p', 00H, 'A', 00H, 'd', 00H, 'a', 00H
	DB	'p', 00H, 't', 00H, 'e', 00H, 'r', 00H, '1', 00H, ')', 00H, '-'
	DB	00H, '>', 00H, 'G', 00H, 'e', 00H, 't', 00H, 'D', 00H, 'e', 00H
	DB	's', 00H, 'c', 00H, '1', 00H, 00H, 00H
	ORG $+2
$SG356406 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, '>', 00H, '>', 00H, ' ', 00H, 'R', 00H, 'e', 00H
	DB	'f', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'h', 00H, ' ', 00H, 'O'
	DB	00H, 'v', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'i', 00H, 'd', 00H
	DB	'e', 00H, ' ', 00H, '(', 00H, 'R', 00H, 'e', 00H, 'q', 00H, 'u'
	DB	00H, 'e', 00H, 's', 00H, 't', 00H, 'e', 00H, 'd', 00H, ':', 00H
	DB	' ', 00H, '%', 00H, 'f', 00H, ',', 00H, ' ', 00H, 'U', 00H, 's'
	DB	00H, 'i', 00H, 'n', 00H, 'g', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	'l', 00H, 'i', 00H, ')', 00H, 00H, 00H
$SG357432 DB	'(', 00H, '*', 00H, 'p', 00H, 'p', 00H, 'A', 00H, 'd', 00H
	DB	'a', 00H, 'p', 00H, 't', 00H, 'e', 00H, 'r', 00H, ')', 00H, '-'
	DB	00H, '>', 00H, 'G', 00H, 'e', 00H, 't', 00H, 'D', 00H, 'e', 00H
	DB	's', 00H, 'c', 00H, 00H, 00H
$SG354359 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, '*', 00H, '*', 00H, '*', 00H, ' ', 00H, 'B', 00H
	DB	'a', 00H, 'c', 00H, 'k', 00H, ' ', 00H, 'b', 00H, 'u', 00H, 'f'
	DB	00H, 'f', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'u', 00H, 'n', 00H
	DB	'a', 00H, 'v', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'a', 00H, 'b'
	DB	00H, 'l', 00H, 'e', 00H, '!', 00H, ' ', 00H, '*', 00H, '*', 00H
	DB	'*', 00H, 00H, 00H
	ORG $+2
$SG356408 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, '>', 00H, '>', 00H, ' ', 00H, 'S', 00H, 'c', 00H
	DB	'a', 00H, 'n', 00H, 'l', 00H, 'i', 00H, 'n', 00H, 'e', 00H, ' '
	DB	00H, 'O', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'i', 00H
	DB	'd', 00H, 'e', 00H, ' ', 00H, '(', 00H, 'R', 00H, 'e', 00H, 'q'
	DB	00H, 'u', 00H, 'e', 00H, 's', 00H, 't', 00H, 'e', 00H, 'd', 00H
	DB	':', 00H, ' ', 00H, '%', 00H, 's', 00H, ',', 00H, ' ', 00H, 'U'
	DB	00H, 's', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ':', 00H, ' ', 00H
	DB	'%', 00H, 's', 00H, ')', 00H, 00H, 00H
$SG357446 DB	' ', 00H, '[', 00H, 'R', 00H, 'e', 00H, 'm', 00H, 'o', 00H
	DB	't', 00H, 'e', 00H, ']', 00H, 00H, 00H
$SG356410 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, '>', 00H, '>', 00H, ' ', 00H, 'S', 00H, 'c', 00H
	DB	'a', 00H, 'l', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'O'
	DB	00H, 'v', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'i', 00H, 'd', 00H
	DB	'e', 00H, ' ', 00H, '(', 00H, 'R', 00H, 'e', 00H, 'q', 00H, 'u'
	DB	00H, 'e', 00H, 's', 00H, 't', 00H, 'e', 00H, 'd', 00H, ':', 00H
	DB	' ', 00H, '%', 00H, 's', 00H, ',', 00H, ' ', 00H, 'U', 00H, 's'
	DB	00H, 'i', 00H, 'n', 00H, 'g', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	's', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG357443 DB	' ', 00H, '<', 00H, 'S', 00H, 'o', 00H, 'f', 00H, 't', 00H
	DB	'w', 00H, 'a', 00H, 'r', 00H, 'e', 00H, '>', 00H, 00H, 00H
$SG357447 DB	0aH, 00H, 00H, 00H
$SG357435 DB	' ', 00H, '>', 00H, '>', 00H, ' ', 00H, 'A', 00H, 's', 00H
	DB	's', 00H, 'e', 00H, 'r', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n'
	DB	00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	':', 00H, ' ', 00H, 'Z', 00H, 'e', 00H, 'r', 00H, 'o', 00H, '-'
	DB	00H, 'l', 00H, 'e', 00H, 'n', 00H, 'g', 00H, 't', 00H, 'h', 00H
	DB	' ', 00H, 'a', 00H, 'd', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'e'
	DB	00H, 'r', 00H, ' ', 00H, 'n', 00H, 'a', 00H, 'm', 00H, 'e', 00H
	DB	'!', 00H, 0aH, 00H, 00H, 00H
$SG354363 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, '*', 00H, '*', 00H, '*', 00H, ' ', 00H, 'C', 00H
	DB	'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H, 'n', 00H, 'o'
	DB	00H, 't', 00H, ' ', 00H, 'q', 00H, 'u', 00H, 'e', 00H, 'r', 00H
	DB	'y', 00H, ' ', 00H, 'I', 00H, 'D', 00H, '3', 00H, 'D', 00H, '1'
	DB	00H, '1', 00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H
	DB	'e', 00H, '1', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e'
	DB	00H, 'r', 00H, 'f', 00H, 'a', 00H, 'c', 00H, 'e', 00H, '!', 00H
	DB	' ', 00H, '*', 00H, '*', 00H, '*', 00H, 00H, 00H
	ORG $+2
$SG357437 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '>', 00H, '>', 00H, ' ', 00H, '(', 00H, 'H', 00H, 'o', 00H
	DB	's', 00H, 't', 00H, ' ', 00H, 'A', 00H, 'p', 00H, 'p', 00H, 'l'
	DB	00H, 'i', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'o', 00H
	DB	'n', 00H, ' ', 00H, 'T', 00H, 'r', 00H, 'i', 00H, 'e', 00H, 'd'
	DB	00H, ' ', 00H, 'T', 00H, 'o', 00H, ' ', 00H, 'E', 00H, 'n', 00H
	DB	'u', 00H, 'm', 00H, ' ', 00H, 'I', 00H, 'n', 00H, 't', 00H, 'e'
	DB	00H, 'l', 00H, ' ', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'M', 00H
	DB	'i', 00H, 'c', 00H, 'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f'
	DB	00H, 't', 00H, ' ', 00H, 'A', 00H, 'd', 00H, 'a', 00H, 'p', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'a', 00H, 's', 00H, ' '
	DB	00H, 'A', 00H, 'd', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'e', 00H
	DB	'r', 00H, ' ', 00H, '0', 00H, ')', 00H, ' ', 00H, '-', 00H, '-'
	DB	00H, ' ', 00H, 'S', 00H, 'k', 00H, 'i', 00H, 'p', 00H, 'p', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'A', 00H, 'd', 00H, 'a'
	DB	00H, 'p', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H, '''', 00H
	DB	'%', 00H, 's', 00H, '''', 00H, ' ', 00H, '<', 00H, '<', 00H, 0aH
	DB	00H, 00H, 00H
$SG200800 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'S', 00H, 'y', 00H, 'n', 00H, 'c', 00H, 00H
	DB	00H
	ORG $+2
$SG357438 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, '@', 00H, ' ', 00H, 'R', 00H, 'e', 00H, 't', 00H
	DB	'u', 00H, 'r', 00H, 'n', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'A'
	DB	00H, 'd', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	' ', 00H, '%', 00H, 'l', 00H, 'u', 00H, ':', 00H, ' ', 00H, ''''
	DB	00H, '%', 00H, '3', 00H, '2', 00H, 's', 00H, '''', 00H, ' ', 00H
	DB	'(', 00H, 'L', 00H, 'U', 00H, 'I', 00H, 'D', 00H, ':', 00H, ' '
	DB	00H, '%', 00H, '0', 00H, '8', 00H, 'X', 00H, ':', 00H, '%', 00H
	DB	'0', 00H, '8', 00H, 'X', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG354366 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, '*', 00H, '*', 00H, '*', 00H, ' ', 00H, 'C', 00H
	DB	'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'D', 00H, 'e'
	DB	00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 'C', 00H, 'o', 00H
	DB	'n', 00H, 't', 00H, 'e', 00H, 'x', 00H, 't', 00H, 'S', 00H, 't'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, '(', 00H, '.', 00H
	DB	'.', 00H, '.', 00H, ')', 00H, ' ', 00H, 'f', 00H, 'a', 00H, 'i'
	DB	00H, 'l', 00H, 'e', 00H, 'd', 00H, '!', 00H, ' ', 00H, '*', 00H
	DB	'*', 00H, '*', 00H, 00H, 00H
	ORG $+2
$SG357444 DB	' ', 00H, '<', 00H, 'H', 00H, 'a', 00H, 'r', 00H, 'd', 00H
	DB	'w', 00H, 'a', 00H, 'r', 00H, 'e', 00H, '>', 00H, 00H, 00H
$SG357479 DB	'%', 00H, 's', 00H, ':', 00H, ':', 00H, '%', 00H, 's', 00H
	DB	' ', 00H, '(', 00H, 00H, 00H
	ORG $+2
$SG356415 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '@', 00H, ']', 00H, ' ', 00H, ' ', 00H, 'R', 00H
	DB	'e', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'n', 00H, ':', 00H, ' '
	DB	00H, '%', 00H, 's', 00H, ' ', 00H, ' ', 00H, '-', 00H, ' ', 00H
	DB	' ', 00H, '<', 00H, ' ', 00H, 'R', 00H, 'e', 00H, 's', 00H, 'i'
	DB	00H, 'z', 00H, 'e', 00H, 'T', 00H, 'a', 00H, 'r', 00H, 'g', 00H
	DB	'e', 00H, 't', 00H, '_', 00H, 'O', 00H, 'r', 00H, 'i', 00H, 'g'
	DB	00H, 'i', 00H, 'n', 00H, 'a', 00H, 'l', 00H, ' ', 00H, '(', 00H
	DB	'T', 00H, 'h', 00H, 'i', 00H, 's', 00H, ',', 00H, ' ', 00H, 'p'
	DB	00H, 'N', 00H, 'e', 00H, 'w', 00H, 'N', 00H, 'e', 00H, 'w', 00H
	DB	'T', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'e', 00H, 't', 00H, 'P'
	DB	00H, 'a', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 't', 00H
	DB	'e', 00H, 'r', 00H, 's', 00H, ')', 00H, ' ', 00H, '>', 00H, 00H
	DB	00H
	ORG $+2
$SG356419 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '@', 00H, ']', 00H, ' ', 00H, ' ', 00H, 'R', 00H
	DB	'e', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'n', 00H, ':', 00H, ' '
	DB	00H, '%', 00H, 's', 00H, ' ', 00H, ' ', 00H, '-', 00H, ' ', 00H
	DB	' ', 00H, '<', 00H, ' ', 00H, 'R', 00H, 'e', 00H, 's', 00H, 'i'
	DB	00H, 'z', 00H, 'e', 00H, 'T', 00H, 'a', 00H, 'r', 00H, 'g', 00H
	DB	'e', 00H, 't', 00H, '_', 00H, 'O', 00H, 'r', 00H, 'i', 00H, 'g'
	DB	00H, 'i', 00H, 'n', 00H, 'a', 00H, 'l', 00H, ' ', 00H, '(', 00H
	DB	'T', 00H, 'h', 00H, 'i', 00H, 's', 00H, ',', 00H, ' ', 00H, 'p'
	DB	00H, 'N', 00H, 'e', 00H, 'w', 00H, 'T', 00H, 'a', 00H, 'r', 00H
	DB	'g', 00H, 'e', 00H, 't', 00H, 'P', 00H, 'a', 00H, 'r', 00H, 'a'
	DB	00H, 'm', 00H, 'e', 00H, 't', 00H, 'e', 00H, 'r', 00H, 's', 00H
	DB	')', 00H, ' ', 00H, '>', 00H, 00H, 00H
$SG357478 DB	'E', 00H, 'n', 00H, 'u', 00H, 'm', 00H, 'A', 00H, 'd', 00H
	DB	'a', 00H, 'p', 00H, 't', 00H, 'e', 00H, 'r', 00H, 's', 00H, '1'
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, 00H, 00H
	ORG $+2
$SG357480 DB	'%', 00H, 'p', 00H, 'h', 00H, ',', 00H, ' ', 00H, '%', 00H
	DB	'u', 00H, ',', 00H, ' ', 00H, '%', 00H, 'p', 00H, 'h', 00H, 00H
	DB	00H
	ORG $+2
$SG357481 DB	'%', 00H, 's', 00H, '%', 00H, 's', 00H, ')', 00H, 00H, 00H
$SG357482 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '%', 00H, '-', 00H
	DB	'1', 00H, '0', 00H, '2', 00H, 's', 00H, ' ', 00H, '-', 00H, '-'
	DB	00H, ' ', 00H, '%', 00H, 's', 00H, 00H, 00H
$SG366710 DB	'I', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'F', 00H
	DB	'a', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'y', 00H, ':'
	DB	00H, ':', 00H, 'C', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 't', 00H
	DB	'e', 00H, 'S', 00H, 'w', 00H, 'a', 00H, 'p', 00H, 'C', 00H, 'h'
	DB	00H, 'a', 00H, 'i', 00H, 'n', 00H, 00H, 00H
$SG357483 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '@', 00H, ']', 00H, ' ', 00H, ' ', 00H, 'R', 00H
	DB	'e', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'n', 00H, ':', 00H, ' '
	DB	00H, '%', 00H, 's', 00H, ' ', 00H, ' ', 00H, '-', 00H, ' ', 00H
	DB	' ', 00H, '<', 00H, ' ', 00H, 'E', 00H, 'n', 00H, 'u', 00H, 'm'
	DB	00H, 'A', 00H, 'd', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '1', 00H, '_', 00H, 'O', 00H, 'r', 00H, 'i'
	DB	00H, 'g', 00H, 'i', 00H, 'n', 00H, 'a', 00H, 'l', 00H, ' ', 00H
	DB	'(', 00H, 'T', 00H, 'h', 00H, 'i', 00H, 's', 00H, ',', 00H, 'A'
	DB	00H, 'd', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	',', 00H, 'p', 00H, 'p', 00H, 'A', 00H, 'd', 00H, 'a', 00H, 'p'
	DB	00H, 't', 00H, 'e', 00H, 'r', 00H, ')', 00H, ' ', 00H, '>', 00H
	DB	00H, 00H
	ORG $+2
$SG366713 DB	'I', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'F', 00H
	DB	'a', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'y', 00H, '1'
	DB	00H, ':', 00H, ':', 00H, 'E', 00H, 'n', 00H, 'u', 00H, 'm', 00H
	DB	'A', 00H, 'd', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'e', 00H, 'r'
	DB	00H, 's', 00H, '1', 00H, 00H, 00H
	ORG $+2
$SG366714 DB	'I', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'F', 00H
	DB	'a', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'y', 00H, ':'
	DB	00H, ':', 00H, 'E', 00H, 'n', 00H, 'u', 00H, 'm', 00H, 'A', 00H
	DB	'd', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'e', 00H, 'r', 00H, 's'
	DB	00H, 00H, 00H
	ORG $+2
$SG366719 DB	'I', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'F', 00H
	DB	'a', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'y', 00H, '2'
	DB	00H, ':', 00H, ':', 00H, 'C', 00H, 'r', 00H, 'e', 00H, 'a', 00H
	DB	't', 00H, 'e', 00H, 'S', 00H, 'w', 00H, 'a', 00H, 'p', 00H, 'C'
	DB	00H, 'h', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'F', 00H, 'o', 00H
	DB	'r', 00H, 'H', 00H, 'w', 00H, 'n', 00H, 'd', 00H, 00H, 00H
$SG357507 DB	'E', 00H, 'n', 00H, 'u', 00H, 'm', 00H, 'A', 00H, 'd', 00H
	DB	'a', 00H, 'p', 00H, 't', 00H, 'e', 00H, 'r', 00H, 's', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, 00H, 00H
$SG366720 DB	'I', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'F', 00H
	DB	'a', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'y', 00H, '2'
	DB	00H, ':', 00H, ':', 00H, 'C', 00H, 'r', 00H, 'e', 00H, 'a', 00H
	DB	't', 00H, 'e', 00H, 'S', 00H, 'w', 00H, 'a', 00H, 'p', 00H, 'C'
	DB	00H, 'h', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'F', 00H, 'o', 00H
	DB	'r', 00H, 'C', 00H, 'o', 00H, 'r', 00H, 'e', 00H, 'W', 00H, 'i'
	DB	00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 00H, 00H
$SG366721 DB	'I', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'F', 00H
	DB	'a', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'y', 00H, '2'
	DB	00H, ':', 00H, ':', 00H, 'C', 00H, 'r', 00H, 'e', 00H, 'a', 00H
	DB	't', 00H, 'e', 00H, 'S', 00H, 'w', 00H, 'a', 00H, 'p', 00H, 'C'
	DB	00H, 'h', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'F', 00H, 'o', 00H
	DB	'r', 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'o', 00H, 's'
	DB	00H, 'i', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG357508 DB	'%', 00H, 's', 00H, ':', 00H, ':', 00H, '%', 00H, 's', 00H
	DB	' ', 00H, '(', 00H, 00H, 00H
	ORG $+2
$SG357509 DB	'%', 00H, 'p', 00H, 'h', 00H, ',', 00H, ' ', 00H, '%', 00H
	DB	'u', 00H, ',', 00H, ' ', 00H, '%', 00H, 'p', 00H, 'h', 00H, 00H
	DB	00H
	ORG $+2
$SG357510 DB	'%', 00H, 's', 00H, '%', 00H, 's', 00H, ')', 00H, 00H, 00H
$SG357511 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '%', 00H, '-', 00H
	DB	'1', 00H, '0', 00H, '2', 00H, 's', 00H, ' ', 00H, '-', 00H, '-'
	DB	00H, ' ', 00H, '%', 00H, 's', 00H, 00H, 00H
$SG200847 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'I', 00H, 'S', 00H, 'A', 00H, 'P', 00H, 'I'
	DB	00H, 00H, 00H
$SG357512 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '@', 00H, ']', 00H, ' ', 00H, ' ', 00H, 'R', 00H
	DB	'e', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'n', 00H, ':', 00H, ' '
	DB	00H, '%', 00H, 's', 00H, ' ', 00H, ' ', 00H, '-', 00H, ' ', 00H
	DB	' ', 00H, '<', 00H, ' ', 00H, 'E', 00H, 'n', 00H, 'u', 00H, 'm'
	DB	00H, 'A', 00H, 'd', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '_', 00H, 'O', 00H, 'r', 00H, 'i', 00H, 'g'
	DB	00H, 'i', 00H, 'n', 00H, 'a', 00H, 'l', 00H, ' ', 00H, '(', 00H
	DB	'T', 00H, 'h', 00H, 'i', 00H, 's', 00H, ',', 00H, ' ', 00H, 'A'
	DB	00H, 'd', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	',', 00H, ' ', 00H, 'p', 00H, 'p', 00H, 'A', 00H, 'd', 00H, 'a'
	DB	00H, 'p', 00H, 't', 00H, 'e', 00H, 'r', 00H, ')', 00H, ' ', 00H
	DB	'>', 00H, 00H, 00H
$SG199831 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r'
	DB	00H, 'a', 00H, 'l', 00H, 00H, 00H
$SG357538 DB	'%', 00H, 's', 00H, ' ', 00H, '(', 00H, 00H, 00H
	ORG $+2
$SG357537 DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, 'C', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'e'
	DB	00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'F', 00H, 'a', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'y', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	00H, 00H
$SG357539 DB	'%', 00H, 's', 00H, ',', 00H, ' ', 00H, '%', 00H, 'p', 00H
	DB	'h', 00H, 00H, 00H
$SG357540 DB	'%', 00H, 's', 00H, '%', 00H, 's', 00H, ')', 00H, 00H, 00H
$SG357541 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '%', 00H, '-', 00H
	DB	'1', 00H, '0', 00H, '2', 00H, 's', 00H, ' ', 00H, '-', 00H, '-'
	DB	00H, ' ', 00H, '%', 00H, 's', 00H, 00H, 00H
$SG357567 DB	'%', 00H, 's', 00H, ' ', 00H, '(', 00H, 00H, 00H
	ORG $+2
$SG357543 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '@', 00H, ']', 00H, ' ', 00H, ' ', 00H, 'R', 00H
	DB	'e', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'n', 00H, ':', 00H, ' '
	DB	00H, '%', 00H, 's', 00H, ' ', 00H, ' ', 00H, '-', 00H, ' ', 00H
	DB	' ', 00H, '<', 00H, ' ', 00H, 'C', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 't', 00H, 'e', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H
	DB	'F', 00H, 'a', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'y'
	DB	00H, '_', 00H, 'I', 00H, 'm', 00H, 'p', 00H, 'o', 00H, 'r', 00H
	DB	't', 00H, ' ', 00H, '(', 00H, 'r', 00H, 'i', 00H, 'i', 00H, 'd'
	DB	00H, ',', 00H, ' ', 00H, 'p', 00H, 'p', 00H, 'F', 00H, 'a', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'y', 00H, ')', 00H, ' '
	DB	00H, '>', 00H, 00H, 00H
$SG357566 DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, 'C', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'e'
	DB	00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'F', 00H, 'a', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'y', 00H, '1', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	00H, 00H
$SG357568 DB	'%', 00H, 's', 00H, ',', 00H, ' ', 00H, '%', 00H, 'p', 00H
	DB	'h', 00H, 00H, 00H
$SG212160 DB	'A', 00H, 'p', 00H, 'p', 00H, 'I', 00H, 'D', 00H, 00H, 00H
$SG357569 DB	'%', 00H, 's', 00H, '%', 00H, 's', 00H, ')', 00H, 00H, 00H
$SG212161 DB	'C', 00H, 'L', 00H, 'S', 00H, 'I', 00H, 'D', 00H, 00H, 00H
$SG357570 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '%', 00H, '-', 00H
	DB	'1', 00H, '0', 00H, '2', 00H, 's', 00H, ' ', 00H, '-', 00H, '-'
	DB	00H, ' ', 00H, '%', 00H, 's', 00H, 00H, 00H
$SG212162 DB	'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'o', 00H, 'n', 00H
	DB	'e', 00H, 'n', 00H, 't', 00H, ' ', 00H, 'C', 00H, 'a', 00H, 't'
	DB	00H, 'e', 00H, 'g', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'e', 00H
	DB	's', 00H, 00H, 00H
	ORG $+2
$SG212163 DB	'F', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'T', 00H, 'y', 00H
	DB	'p', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG212164 DB	'I', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'f', 00H
	DB	'a', 00H, 'c', 00H, 'e', 00H, 00H, 00H
$SG357573 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, '>', 00H, '>', 00H, ' ', 00H, 'F', 00H, 'a', 00H
	DB	'l', 00H, 'l', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'b'
	DB	00H, 'a', 00H, 'c', 00H, 'k', 00H, ' ', 00H, 't', 00H, 'o', 00H
	DB	' ', 00H, 'C', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'e'
	DB	00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'F', 00H, 'a', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'y', 00H, ' ', 00H, 'o'
	DB	00H, 'n', 00H, ' ', 00H, 'V', 00H, 'i', 00H, 's', 00H, 't', 00H
	DB	'a', 00H, '.', 00H, '.', 00H, '.', 00H, 00H, 00H
	ORG $+2
$SG212165 DB	'H', 00H, 'a', 00H, 'r', 00H, 'd', 00H, 'w', 00H, 'a', 00H
	DB	'r', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG212166 DB	'M', 00H, 'i', 00H, 'm', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG357575 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '@', 00H, ']', 00H, ' ', 00H, ' ', 00H, 'R', 00H
	DB	'e', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'n', 00H, ':', 00H, ' '
	DB	00H, '%', 00H, 's', 00H, ' ', 00H, ' ', 00H, '-', 00H, ' ', 00H
	DB	' ', 00H, '<', 00H, ' ', 00H, 'C', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 't', 00H, 'e', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H
	DB	'F', 00H, 'a', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'y'
	DB	00H, '1', 00H, '_', 00H, 'I', 00H, 'm', 00H, 'p', 00H, 'o', 00H
	DB	'r', 00H, 't', 00H, ' ', 00H, '(', 00H, 'r', 00H, 'i', 00H, 'i'
	DB	00H, 'd', 00H, ',', 00H, ' ', 00H, 'p', 00H, 'p', 00H, 'F', 00H
	DB	'a', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'y', 00H, ')'
	DB	00H, ' ', 00H, '>', 00H, 00H, 00H
	ORG $+2
$SG212167 DB	'S', 00H, 'A', 00H, 'M', 00H, 00H, 00H
$SG212168 DB	'S', 00H, 'E', 00H, 'C', 00H, 'U', 00H, 'R', 00H, 'I', 00H
	DB	'T', 00H, 'Y', 00H, 00H, 00H
	ORG $+2
$SG212169 DB	'S', 00H, 'Y', 00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H
	DB	00H, 00H
	ORG $+2
$SG352458 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, '*', 00H, '*', 00H, ' ', 00H, 'F', 00H, 'a', 00H
	DB	'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 't', 00H, 'o'
	DB	00H, ' ', 00H, 'a', 00H, 'c', 00H, 'q', 00H, 'u', 00H, 'i', 00H
	DB	'r', 00H, 'e', 00H, ' ', 00H, 'S', 00H, 'w', 00H, 'a', 00H, 'p'
	DB	00H, 'C', 00H, 'h', 00H, 'a', 00H, 'i', 00H, 'n', 00H, '''', 00H
	DB	's', 00H, ' ', 00H, 'B', 00H, 'a', 00H, 'c', 00H, 'k', 00H, 'b'
	DB	00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, ';', 00H
	DB	' ', 00H, 'w', 00H, 'i', 00H, 'l', 00H, 'l', 00H, ' ', 00H, 't'
	DB	00H, 'r', 00H, 'y', 00H, ' ', 00H, 'a', 00H, 'g', 00H, 'a', 00H
	DB	'i', 00H, 'n', 00H, ' ', 00H, 'n', 00H, 'e', 00H, 'x', 00H, 't'
	DB	00H, ' ', 00H, 'f', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H
	DB	'.', 00H, 00H, 00H
$SG212170 DB	'S', 00H, 'o', 00H, 'f', 00H, 't', 00H, 'w', 00H, 'a', 00H
	DB	'r', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG212171 DB	'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H, 'L', 00H, 'i', 00H
	DB	'b', 00H, 00H, 00H
$SG357598 DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, 'C', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'e'
	DB	00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'F', 00H, 'a', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'y', 00H, '2', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	00H, 00H
$SG199902 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'C', 00H, 'O', 00H, 'M', 00H, 00H, 00H
$SG357599 DB	'%', 00H, 's', 00H, ' ', 00H, '(', 00H, 00H, 00H
	ORG $+2
$SG357600 DB	'0', 00H, 'x', 00H, '%', 00H, '0', 00H, '4', 00H, 'X', 00H
	DB	',', 00H, ' ', 00H, '%', 00H, 's', 00H, ',', 00H, ' ', 00H, '%'
	DB	00H, 'p', 00H, 'h', 00H, 00H, 00H
$SG357601 DB	'%', 00H, 's', 00H, '%', 00H, 's', 00H, ')', 00H, 00H, 00H
$SG357602 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '%', 00H, '-', 00H
	DB	'1', 00H, '0', 00H, '2', 00H, 's', 00H, ' ', 00H, '-', 00H, '-'
	DB	00H, ' ', 00H, '%', 00H, 's', 00H, 00H, 00H
$SG357605 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, '>', 00H, '>', 00H, ' ', 00H, 'F', 00H, 'a', 00H
	DB	'l', 00H, 'l', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'b'
	DB	00H, 'a', 00H, 'c', 00H, 'k', 00H, ' ', 00H, 't', 00H, 'o', 00H
	DB	' ', 00H, 'C', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'e'
	DB	00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'F', 00H, 'a', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'y', 00H, '1', 00H, ' '
	DB	00H, 'o', 00H, 'n', 00H, ' ', 00H, 'V', 00H, 'i', 00H, 's', 00H
	DB	't', 00H, 'a', 00H, '/', 00H, '7', 00H, '.', 00H, '.', 00H, '.'
	DB	00H, 00H, 00H
$SG352492 DB	'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, '_', 00H, 'M', 00H
	DB	'O', 00H, 'D', 00H, 'E', 00H, '_', 00H, 'S', 00H, 'C', 00H, 'A'
	DB	00H, 'L', 00H, 'I', 00H, 'N', 00H, 'G', 00H, '_', 00H, 'U', 00H
	DB	'N', 00H, 'S', 00H, 'P', 00H, 'E', 00H, 'C', 00H, 'I', 00H, 'F'
	DB	00H, 'I', 00H, 'E', 00H, 'D', 00H, 00H, 00H
$SG357607 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '@', 00H, ']', 00H, ' ', 00H, ' ', 00H, 'R', 00H
	DB	'e', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'n', 00H, ':', 00H, ' '
	DB	00H, '%', 00H, 's', 00H, ' ', 00H, ' ', 00H, '-', 00H, ' ', 00H
	DB	' ', 00H, '<', 00H, ' ', 00H, 'C', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 't', 00H, 'e', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H
	DB	'F', 00H, 'a', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'y'
	DB	00H, '2', 00H, '_', 00H, 'I', 00H, 'm', 00H, 'p', 00H, 'o', 00H
	DB	'r', 00H, 't', 00H, ' ', 00H, '(', 00H, 'F', 00H, 'l', 00H, 'a'
	DB	00H, 'g', 00H, 's', 00H, ',', 00H, ' ', 00H, 'r', 00H, 'i', 00H
	DB	'i', 00H, 'd', 00H, ',', 00H, ' ', 00H, 'p', 00H, 'p', 00H, 'F'
	DB	00H, 'a', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'y', 00H
	DB	')', 00H, ' ', 00H, '>', 00H, 00H, 00H
$SG352490 DB	'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, '_', 00H, 'M', 00H
	DB	'O', 00H, 'D', 00H, 'E', 00H, '_', 00H, 'S', 00H, 'C', 00H, 'A'
	DB	00H, 'L', 00H, 'I', 00H, 'N', 00H, 'G', 00H, '_', 00H, 'C', 00H
	DB	'E', 00H, 'N', 00H, 'T', 00H, 'E', 00H, 'R', 00H, 'E', 00H, 'D'
	DB	00H, 00H, 00H
	ORG $+2
$SG352494 DB	'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, '_', 00H, 'M', 00H
	DB	'O', 00H, 'D', 00H, 'E', 00H, '_', 00H, 'S', 00H, 'C', 00H, 'A'
	DB	00H, 'L', 00H, 'I', 00H, 'N', 00H, 'G', 00H, '_', 00H, 'S', 00H
	DB	'T', 00H, 'R', 00H, 'E', 00H, 'T', 00H, 'C', 00H, 'H', 00H, 'E'
	DB	00H, 'D', 00H, 00H, 00H
$SG352496 DB	'U', 00H, 'N', 00H, 'K', 00H, 'N', 00H, 'O', 00H, 'W', 00H
	DB	'N', 00H, 00H, 00H
$SG352503 DB	'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, '_', 00H, 'M', 00H
	DB	'O', 00H, 'D', 00H, 'E', 00H, '_', 00H, 'S', 00H, 'C', 00H, 'A'
	DB	00H, 'N', 00H, 'L', 00H, 'I', 00H, 'N', 00H, 'E', 00H, '_', 00H
	DB	'O', 00H, 'R', 00H, 'D', 00H, 'E', 00H, 'R', 00H, '_', 00H, 'U'
	DB	00H, 'N', 00H, 'S', 00H, 'P', 00H, 'E', 00H, 'C', 00H, 'I', 00H
	DB	'F', 00H, 'I', 00H, 'E', 00H, 'D', 00H, 00H, 00H
	ORG $+2
$SG352511 DB	'U', 00H, 'N', 00H, 'K', 00H, 'N', 00H, 'O', 00H, 'W', 00H
	DB	'N', 00H, 00H, 00H
$SG357634 DB	'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'D', 00H, '3', 00H
	DB	'D', 00H, '1', 00H, '0', 00H, 'C', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 't', 00H, 'e', 00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H
	DB	'c', 00H, 'e', 00H, 00H, 00H
$SG352505 DB	'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, '_', 00H, 'M', 00H
	DB	'O', 00H, 'D', 00H, 'E', 00H, '_', 00H, 'S', 00H, 'C', 00H, 'A'
	DB	00H, 'N', 00H, 'L', 00H, 'I', 00H, 'N', 00H, 'E', 00H, '_', 00H
	DB	'O', 00H, 'R', 00H, 'D', 00H, 'E', 00H, 'R', 00H, '_', 00H, 'P'
	DB	00H, 'R', 00H, 'O', 00H, 'G', 00H, 'R', 00H, 'E', 00H, 'S', 00H
	DB	'S', 00H, 'I', 00H, 'V', 00H, 'E', 00H, 00H, 00H
	ORG $+2
$SG357637 DB	'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'D', 00H, '3', 00H
	DB	'D', 00H, '1', 00H, '0', 00H, 'C', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 't', 00H, 'e', 00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H
	DB	'c', 00H, 'e', 00H, 00H, 00H
$SG352507 DB	'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, '_', 00H, 'M', 00H
	DB	'O', 00H, 'D', 00H, 'E', 00H, '_', 00H, 'S', 00H, 'C', 00H, 'A'
	DB	00H, 'N', 00H, 'L', 00H, 'I', 00H, 'N', 00H, 'E', 00H, '_', 00H
	DB	'O', 00H, 'R', 00H, 'D', 00H, 'E', 00H, 'R', 00H, '_', 00H, 'U'
	DB	00H, 'P', 00H, 'P', 00H, 'E', 00H, 'R', 00H, '_', 00H, 'F', 00H
	DB	'I', 00H, 'E', 00H, 'L', 00H, 'D', 00H, '_', 00H, 'F', 00H, 'I'
	DB	00H, 'R', 00H, 'S', 00H, 'T', 00H, 00H, 00H
	ORG $+2
$SG357628 DB	'DXGID3D10CreateDevice', 00H
	ORG $+2
$SG352509 DB	'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, '_', 00H, 'M', 00H
	DB	'O', 00H, 'D', 00H, 'E', 00H, '_', 00H, 'S', 00H, 'C', 00H, 'A'
	DB	00H, 'N', 00H, 'L', 00H, 'I', 00H, 'N', 00H, 'E', 00H, '_', 00H
	DB	'O', 00H, 'R', 00H, 'D', 00H, 'E', 00H, 'R', 00H, '_', 00H, 'L'
	DB	00H, 'O', 00H, 'W', 00H, 'E', 00H, 'R', 00H, '_', 00H, 'F', 00H
	DB	'I', 00H, 'E', 00H, 'L', 00H, 'D', 00H, '_', 00H, 'F', 00H, 'I'
	DB	00H, 'R', 00H, 'S', 00H, 'T', 00H, 00H, 00H
	ORG $+2
$SG357635 DB	'U', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 's', 00H, 'y', 00H
	DB	'm', 00H, 'b', 00H, 'o', 00H, 'l', 00H, ' ', 00H, ' ', 00H, '%'
	DB	00H, 's', 00H, ' ', 00H, 'i', 00H, 'n', 00H, ' ', 00H, 'd', 00H
	DB	'x', 00H, 'g', 00H, 'i', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l'
	DB	00H, 00H, 00H
$SG357636 DB	'(', 00H, 'H', 00H, 'M', 00H, 'O', 00H, 'D', 00H, 'U', 00H
	DB	'L', 00H, 'E', 00H, ' ', 00H, 'h', 00H, 'M', 00H, 'o', 00H, 'd'
	DB	00H, 'u', 00H, 'l', 00H, 'e', 00H, ',', 00H, ' ', 00H, 'I', 00H
	DB	'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'F', 00H, 'a', 00H, 'c'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, 'y', 00H, ' ', 00H, '*', 00H
	DB	'p', 00H, 'F', 00H, 'a', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, 'y', 00H, ',', 00H, ' ', 00H, 'I', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, 'A', 00H, 'd', 00H, 'a', 00H, 'p', 00H, 't'
	DB	00H, 'e', 00H, 'r', 00H, ' ', 00H, '*', 00H, 'p', 00H, 'A', 00H
	DB	'd', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'e', 00H, 'r', 00H, ','
	DB	00H, ' ', 00H, 'U', 00H, 'I', 00H, 'N', 00H, 'T', 00H, ' ', 00H
	DB	'F', 00H, 'l', 00H, 'a', 00H, 'g', 00H, 's', 00H, ',', 00H, ' '
	DB	00H, 'v', 00H, 'o', 00H, 'i', 00H, 'd', 00H, ' ', 00H, '*', 00H
	DB	'u', 00H, 'n', 00H, 'k', 00H, 'n', 00H, 'o', 00H, 'w', 00H, 'n'
	DB	00H, ',', 00H, ' ', 00H, 'v', 00H, 'o', 00H, 'i', 00H, 'd', 00H
	DB	' ', 00H, '*', 00H, 'p', 00H, 'p', 00H, 'D', 00H, 'e', 00H, 'v'
	DB	00H, 'i', 00H, 'c', 00H, 'e', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG352518 DB	'D', 00H, 'i', 00H, 's', 00H, 'c', 00H, 'a', 00H, 'r', 00H
	DB	'd', 00H, ' ', 00H, ' ', 00H, '(', 00H, 'B', 00H, 'i', 00H, 't'
	DB	00H, 'B', 00H, 'l', 00H, 't', 00H, ')', 00H, 00H, 00H
$SG357638 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '%', 00H, 's', 00H
	DB	' ', 00H, '%', 00H, 's', 00H, ' ', 00H, '-', 00H, ' ', 00H, '['
	DB	00H, 'C', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, ' ', 00H, 'T', 00H, 'h', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 'd', 00H, ':', 00H, ' ', 00H, '0', 00H, 'x', 00H, '%', 00H
	DB	'0', 00H, '4', 00H, 'x', 00H, ']', 00H, 00H, 00H
$SG352520 DB	'S', 00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, 'i', 00H, 'a', 00H, 'l', 00H, ' ', 00H, ' ', 00H, '('
	DB	00H, 'B', 00H, 'i', 00H, 't', 00H, 'B', 00H, 'l', 00H, 't', 00H
	DB	')', 00H, 00H, 00H
	ORG $+2
$SG352522 DB	'D', 00H, 'i', 00H, 's', 00H, 'c', 00H, 'a', 00H, 'r', 00H
	DB	'd', 00H, ' ', 00H, ' ', 00H, '(', 00H, 'F', 00H, 'l', 00H, 'i'
	DB	00H, 'p', 00H, ')', 00H, 00H, 00H
$SG352524 DB	'S', 00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, 'i', 00H, 'a', 00H, 'l', 00H, ' ', 00H, ' ', 00H, '('
	DB	00H, 'F', 00H, 'l', 00H, 'i', 00H, 'p', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG199949 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'Q', 00H, 'I', 00H, 00H, 00H
	ORG $+2
$SG352526 DB	'U', 00H, 'N', 00H, 'K', 00H, 'N', 00H, 'O', 00H, 'W', 00H
	DB	'N', 00H, 00H, 00H
$SG352532 DB	00H, 00H
	ORG $+2
$SG352534 DB	'N', 00H, 'o', 00H, 'n', 00H, '-', 00H, 'P', 00H, 'r', 00H
	DB	'e', 00H, ' ', 00H, 'R', 00H, 'o', 00H, 't', 00H, 'a', 00H, 't'
	DB	00H, 'e', 00H, 'd', 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG352536 DB	'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'w', 00H, ' ', 00H
	DB	'F', 00H, 'u', 00H, 'l', 00H, 'l', 00H, 's', 00H, 'c', 00H, 'r'
	DB	00H, 'e', 00H, 'e', 00H, 'n', 00H, ' ', 00H, 'M', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, ' ', 00H, 'S', 00H, 'w', 00H, 'i', 00H, 't'
	DB	00H, 'c', 00H, 'h', 00H, 0aH, 00H, 00H, 00H
$SG352538 DB	'G', 00H, 'D', 00H, 'I', 00H, ' ', 00H, 'C', 00H, 'o', 00H
	DB	'm', 00H, 'p', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'b', 00H, 'l'
	DB	00H, 'e', 00H, 0aH, 00H, 00H, 00H
$SG357660 DB	'DXGID3D10CreateLayeredDevice', 00H
	ORG $+3
$SG352544 DB	'L', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'n', 00H, 'c', 00H
	DB	'y', 00H, ' ', 00H, 'W', 00H, 'a', 00H, 'i', 00H, 't', 00H, 'a'
	DB	00H, 'b', 00H, 'l', 00H, 'e', 00H, 0aH, 00H, 00H, 00H
$SG352540 DB	'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, '_', 00H, 'S', 00H
	DB	'W', 00H, 'A', 00H, 'P', 00H, '_', 00H, 'C', 00H, 'H', 00H, 'A'
	DB	00H, 'I', 00H, 'N', 00H, '_', 00H, 'F', 00H, 'L', 00H, 'A', 00H
	DB	'G', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'S', 00H, 'T', 00H, 'R'
	DB	00H, 'I', 00H, 'C', 00H, 'T', 00H, 'E', 00H, 'D', 00H, '_', 00H
	DB	'C', 00H, 'O', 00H, 'N', 00H, 'T', 00H, 'E', 00H, 'N', 00H, 'T'
	DB	00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG357666 DB	'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'D', 00H, '3', 00H
	DB	'D', 00H, '1', 00H, '0', 00H, 'C', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 't', 00H, 'e', 00H, 'L', 00H, 'a', 00H, 'y', 00H, 'e', 00H
	DB	'r', 00H, 'e', 00H, 'd', 00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i'
	DB	00H, 'c', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG352542 DB	'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, '_', 00H, 'S', 00H
	DB	'W', 00H, 'A', 00H, 'P', 00H, '_', 00H, 'C', 00H, 'H', 00H, 'A'
	DB	00H, 'I', 00H, 'N', 00H, '_', 00H, 'F', 00H, 'L', 00H, 'A', 00H
	DB	'G', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'S', 00H, 'T', 00H, 'R'
	DB	00H, 'I', 00H, 'C', 00H, 'T', 00H, '_', 00H, 'S', 00H, 'H', 00H
	DB	'A', 00H, 'R', 00H, 'E', 00H, 'D', 00H, '_', 00H, 'R', 00H, 'E'
	DB	00H, 'S', 00H, 'O', 00H, 'U', 00H, 'R', 00H, 'C', 00H, 'E', 00H
	DB	'_', 00H, 'D', 00H, 'R', 00H, 'I', 00H, 'V', 00H, 'E', 00H, 'R'
	DB	00H, 0aH, 00H, 00H, 00H
$SG357669 DB	'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'D', 00H, '3', 00H
	DB	'D', 00H, '1', 00H, '0', 00H, 'C', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 't', 00H, 'e', 00H, 'L', 00H, 'a', 00H, 'y', 00H, 'e', 00H
	DB	'r', 00H, 'e', 00H, 'd', 00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i'
	DB	00H, 'c', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG352546 DB	'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, '_', 00H, 'S', 00H
	DB	'W', 00H, 'A', 00H, 'P', 00H, '_', 00H, 'C', 00H, 'H', 00H, 'A'
	DB	00H, 'I', 00H, 'N', 00H, '_', 00H, 'F', 00H, 'L', 00H, 'A', 00H
	DB	'G', 00H, '_', 00H, 'F', 00H, 'O', 00H, 'R', 00H, 'E', 00H, 'G'
	DB	00H, 'R', 00H, 'O', 00H, 'U', 00H, 'N', 00H, 'D', 00H, '_', 00H
	DB	'L', 00H, 'A', 00H, 'Y', 00H, 'E', 00H, 'R', 00H, 0aH, 00H, 00H
	DB	00H
	ORG $+2
$SG357667 DB	'U', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 's', 00H, 'y', 00H
	DB	'm', 00H, 'b', 00H, 'o', 00H, 'l', 00H, ' ', 00H, ' ', 00H, '%'
	DB	00H, 's', 00H, ' ', 00H, 'i', 00H, 'n', 00H, ' ', 00H, 'd', 00H
	DB	'x', 00H, 'g', 00H, 'i', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l'
	DB	00H, 00H, 00H
$SG357668 DB	'(', 00H, 'U', 00H, 'N', 00H, 'K', 00H, 'N', 00H, 'O', 00H
	DB	'W', 00H, 'N', 00H, '5', 00H, ' ', 00H, 'U', 00H, 'n', 00H, 'k'
	DB	00H, 'n', 00H, 'o', 00H, 'w', 00H, 'n', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG352548 DB	'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, '_', 00H, 'S', 00H
	DB	'W', 00H, 'A', 00H, 'P', 00H, '_', 00H, 'C', 00H, 'H', 00H, 'A'
	DB	00H, 'I', 00H, 'N', 00H, '_', 00H, 'F', 00H, 'L', 00H, 'A', 00H
	DB	'G', 00H, '_', 00H, 'Y', 00H, 'U', 00H, 'V', 00H, '_', 00H, 'V'
	DB	00H, 'I', 00H, 'D', 00H, 'E', 00H, 'O', 00H, 0aH, 00H, 00H, 00H
$SG357670 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '%', 00H, 's', 00H
	DB	' ', 00H, '%', 00H, 's', 00H, ' ', 00H, '-', 00H, ' ', 00H, '['
	DB	00H, 'C', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, ' ', 00H, 'T', 00H, 'h', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 'd', 00H, ':', 00H, ' ', 00H, '0', 00H, 'x', 00H, '%', 00H
	DB	'0', 00H, '4', 00H, 'x', 00H, ']', 00H, 00H, 00H
$SG357688 DB	'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'D', 00H, '3', 00H
	DB	'D', 00H, '1', 00H, '0', 00H, 'G', 00H, 'e', 00H, 't', 00H, 'L'
	DB	00H, 'a', 00H, 'y', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'd', 00H
	DB	'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 'S'
	DB	00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H
$SG352550 DB	'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, '_', 00H, 'S', 00H
	DB	'W', 00H, 'A', 00H, 'P', 00H, '_', 00H, 'C', 00H, 'H', 00H, 'A'
	DB	00H, 'I', 00H, 'N', 00H, '_', 00H, 'F', 00H, 'L', 00H, 'A', 00H
	DB	'G', 00H, '_', 00H, 'H', 00H, 'W', 00H, '_', 00H, 'P', 00H, 'R'
	DB	00H, 'O', 00H, 'T', 00H, 'E', 00H, 'C', 00H, 'T', 00H, 'E', 00H
	DB	'D', 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG352552 DB	'S', 00H, 'u', 00H, 'p', 00H, 'p', 00H, 'o', 00H, 'r', 00H
	DB	't', 00H, 's', 00H, ' ', 00H, 'T', 00H, 'e', 00H, 'a', 00H, 'r'
	DB	00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'i', 00H, 'n', 00H
	DB	' ', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w'
	DB	00H, 'e', 00H, 'd', 00H, ' ', 00H, 'M', 00H, 'o', 00H, 'd', 00H
	DB	'e', 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG357682 DB	'DXGID3D10GetLayeredDeviceSize', 00H
	ORG $+2
$SG352567 DB	'N', 00H, '/', 00H, 'A', 00H, 00H, 00H
$SG352568 DB	00H, 00H
	ORG $+2
$SG352570 DB	' ', 00H, '9', 00H, '_', 00H, '1', 00H, 00H, 00H
	ORG $+2
$SG357689 DB	'U', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 's', 00H, 'y', 00H
	DB	'm', 00H, 'b', 00H, 'o', 00H, 'l', 00H, ' ', 00H, ' ', 00H, '%'
	DB	00H, 's', 00H, ' ', 00H, 'i', 00H, 'n', 00H, ' ', 00H, 'd', 00H
	DB	'x', 00H, 'g', 00H, 'i', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l'
	DB	00H, 00H, 00H
$SG357690 DB	'(', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H
	DB	' ', 00H, 'v', 00H, 'o', 00H, 'i', 00H, 'd', 00H, ' ', 00H, '*'
	DB	00H, 'p', 00H, 'L', 00H, 'a', 00H, 'y', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, ',', 00H, ' ', 00H, 'U', 00H, 'I', 00H, 'N', 00H, 'T'
	DB	00H, ' ', 00H, 'N', 00H, 'u', 00H, 'm', 00H, 'L', 00H, 'a', 00H
	DB	'y', 00H, 'e', 00H, 'r', 00H, 's', 00H, ')', 00H, 00H, 00H
$SG357691 DB	'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'D', 00H, '3', 00H
	DB	'D', 00H, '1', 00H, '0', 00H, 'G', 00H, 'e', 00H, 't', 00H, 'L'
	DB	00H, 'a', 00H, 'y', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'd', 00H
	DB	'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 'S'
	DB	00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H
$SG357692 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '%', 00H, 's', 00H
	DB	' ', 00H, '%', 00H, 's', 00H, ' ', 00H, '-', 00H, ' ', 00H, '['
	DB	00H, 'C', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, ' ', 00H, 'T', 00H, 'h', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 'd', 00H, ':', 00H, ' ', 00H, '0', 00H, 'x', 00H, '%', 00H
	DB	'0', 00H, '4', 00H, 'x', 00H, ']', 00H, 00H, 00H
$SG352572 DB	' ', 00H, '9', 00H, '_', 00H, '2', 00H, 00H, 00H
	ORG $+2
$SG199996 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'R', 00H, 'e', 00H, 'g', 00H, 'i', 00H, 's'
	DB	00H, 't', 00H, 'r', 00H, 'a', 00H, 'r', 00H, 00H, 00H
$SG352574 DB	' ', 00H, '9', 00H, '_', 00H, '3', 00H, 00H, 00H
	ORG $+2
$SG352576 DB	' ', 00H, '1', 00H, '0', 00H, '_', 00H, '0', 00H, 00H, 00H
$SG352578 DB	' ', 00H, '1', 00H, '0', 00H, '_', 00H, '1', 00H, 00H, 00H
$SG352580 DB	' ', 00H, '1', 00H, '1', 00H, '_', 00H, '0', 00H, 00H, 00H
$SG352582 DB	' ', 00H, '1', 00H, '1', 00H, '_', 00H, '1', 00H, 00H, 00H
$SG357704 DB	'DXGID3D10RegisterLayers', 00H
$SG352584 DB	' ', 00H, '1', 00H, '2', 00H, '_', 00H, '0', 00H, 00H, 00H
$SG352586 DB	' ', 00H, '1', 00H, '2', 00H, '_', 00H, '1', 00H, 00H, 00H
$SG357710 DB	'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'D', 00H, '3', 00H
	DB	'D', 00H, '1', 00H, '0', 00H, 'R', 00H, 'e', 00H, 'g', 00H, 'i'
	DB	00H, 's', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'L', 00H, 'a', 00H
	DB	'y', 00H, 'e', 00H, 'r', 00H, 's', 00H, 00H, 00H
$SG357711 DB	'U', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 's', 00H, 'y', 00H
	DB	'm', 00H, 'b', 00H, 'o', 00H, 'l', 00H, ' ', 00H, ' ', 00H, '%'
	DB	00H, 's', 00H, ' ', 00H, 'i', 00H, 'n', 00H, ' ', 00H, 'd', 00H
	DB	'x', 00H, 'g', 00H, 'i', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l'
	DB	00H, 00H, 00H
$SG357712 DB	'(', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H
	DB	' ', 00H, 'v', 00H, 'o', 00H, 'i', 00H, 'd', 00H, ' ', 00H, '*'
	DB	00H, 'p', 00H, 'L', 00H, 'a', 00H, 'y', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, ',', 00H, ' ', 00H, 'U', 00H, 'I', 00H, 'N', 00H, 'T'
	DB	00H, ' ', 00H, 'N', 00H, 'u', 00H, 'm', 00H, 'L', 00H, 'a', 00H
	DB	'y', 00H, 'e', 00H, 'r', 00H, 's', 00H, ')', 00H, 00H, 00H
$SG357713 DB	'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'D', 00H, '3', 00H
	DB	'D', 00H, '1', 00H, '0', 00H, 'R', 00H, 'e', 00H, 'g', 00H, 'i'
	DB	00H, 's', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'L', 00H, 'a', 00H
	DB	'y', 00H, 'e', 00H, 'r', 00H, 's', 00H, 00H, 00H
$SG200043 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'R', 00H, 'e', 00H, 'f', 00H, 'c', 00H, 'o'
	DB	00H, 'u', 00H, 'n', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG357714 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '%', 00H, 's', 00H
	DB	' ', 00H, '%', 00H, 's', 00H, ' ', 00H, '-', 00H, ' ', 00H, '['
	DB	00H, 'C', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, ' ', 00H, 'T', 00H, 'h', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 'd', 00H, ':', 00H, ' ', 00H, '0', 00H, 'x', 00H, '%', 00H
	DB	'0', 00H, '4', 00H, 'x', 00H, ']', 00H, 00H, 00H
$SG357724 DB	'DXGIDumpJournal', 00H
$SG357728 DB	'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'D', 00H, 'u', 00H
	DB	'm', 00H, 'p', 00H, 'J', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'n'
	DB	00H, 'a', 00H, 'l', 00H, 00H, 00H
$SG370033 DB	'd', 00H, 'x', 00H, 'g', 00H, 'i', 00H, 00H, 00H
	ORG $+2
$SG357729 DB	'U', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 's', 00H, 'y', 00H
	DB	'm', 00H, 'b', 00H, 'o', 00H, 'l', 00H, ' ', 00H, ' ', 00H, '%'
	DB	00H, 's', 00H, ' ', 00H, 'i', 00H, 'n', 00H, ' ', 00H, 'd', 00H
	DB	'x', 00H, 'g', 00H, 'i', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l'
	DB	00H, 00H, 00H
$SG370018 DB	'[', 00H, ' ', 00H, ' ', 00H, 'D', 00H, '3', 00H, 'D', 00H
	DB	' ', 00H, '1', 00H, '1', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, '>', 00H, '>', 00H, ' ', 00H, 'I', 00H, 'm', 00H
	DB	'p', 00H, 'l', 00H, 'i', 00H, 'c', 00H, 'i', 00H, 't', 00H, ' '
	DB	00H, 'I', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'a', 00H
	DB	'l', 00H, 'i', 00H, 'z', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'o'
	DB	00H, 'n', 00H, ' ', 00H, 'T', 00H, 'r', 00H, 'i', 00H, 'g', 00H
	DB	'g', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'd', 00H, ' ', 00H, '<'
	DB	00H, '<', 00H, 00H, 00H
$SG357730 DB	'(', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H
	DB	' ', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'r', 00H, ' ', 00H, '*'
	DB	00H, 's', 00H, 'z', 00H, 'P', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	'T', 00H, 'h', 00H, 'r', 00H, 'o', 00H, 'u', 00H, 'g', 00H, 'h'
	DB	00H, ')', 00H, 00H, 00H
$SG357731 DB	'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'D', 00H, 'u', 00H
	DB	'm', 00H, 'p', 00H, 'J', 00H, 'o', 00H, 'u', 00H, 'r', 00H, 'n'
	DB	00H, 'a', 00H, 'l', 00H, 00H, 00H
$SG357750 DB	'(', 00H, 'D', 00H, 'W', 00H, 'O', 00H, 'R', 00H, 'D', 00H
	DB	' ', 00H, 'd', 00H, 'w', 00H, 'U', 00H, 'n', 00H, 'k', 00H, 'n'
	DB	00H, 'o', 00H, 'w', 00H, 'n', 00H, ')', 00H, 00H, 00H
$SG370020 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, 'I', 00H, 'n', 00H, 's', 00H, 't', 00H
	DB	'a', 00H, 'l', 00H, 'l', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' '
	DB	00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, ' ', 00H, 'H', 00H
	DB	'o', 00H, 'o', 00H, 'k', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG357742 DB	'DXGIReportAdapterConfiguration', 00H
	ORG $+1
$SG354696 DB	'P', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, '1', 00H, 00H, 00H
	ORG $+2
$SG357732 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '%', 00H, 's', 00H
	DB	' ', 00H, '%', 00H, 's', 00H, ' ', 00H, '-', 00H, ' ', 00H, '['
	DB	00H, 'C', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, ' ', 00H, 'T', 00H, 'h', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 'd', 00H, ':', 00H, ' ', 00H, '0', 00H, 'x', 00H, '%', 00H
	DB	'0', 00H, '4', 00H, 'x', 00H, ']', 00H, 00H, 00H
$SG200090 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'w', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H
$SG370027 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'U', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'h', 00H, 'o', 00H, 'o'
	DB	00H, 'k', 00H, ' ', 00H, 'D', 00H, '3', 00H, 'D', 00H, '1', 00H
	DB	'1', 00H, '?', 00H, '!', 00H, ' ', 00H, '(', 00H, '0', 00H, 'x'
	DB	00H, '%', 00H, '0', 00H, '4', 00H, 'x', 00H, ' ', 00H, ':', 00H
	DB	':', 00H, ' ', 00H, '''', 00H, '%', 00H, 's', 00H, '''', 00H, ')'
	DB	00H, 00H, 00H
	ORG $+2
$SG357748 DB	'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'R', 00H, 'e', 00H
	DB	'p', 00H, 'o', 00H, 'r', 00H, 't', 00H, 'A', 00H, 'd', 00H, 'a'
	DB	00H, 'p', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'C', 00H, 'o', 00H
	DB	'n', 00H, 'f', 00H, 'i', 00H, 'g', 00H, 'u', 00H, 'r', 00H, 'a'
	DB	00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG200137 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'r'
	DB	00H, 'o', 00H, 'l', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG357749 DB	'U', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H, 's', 00H, 'y', 00H
	DB	'm', 00H, 'b', 00H, 'o', 00H, 'l', 00H, ' ', 00H, ' ', 00H, '%'
	DB	00H, 's', 00H, ' ', 00H, 'i', 00H, 'n', 00H, ' ', 00H, 'd', 00H
	DB	'x', 00H, 'g', 00H, 'i', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l'
	DB	00H, 00H, 00H
$SG357751 DB	'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'R', 00H, 'e', 00H
	DB	'p', 00H, 'o', 00H, 'r', 00H, 't', 00H, 'A', 00H, 'd', 00H, 'a'
	DB	00H, 'p', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'C', 00H, 'o', 00H
	DB	'n', 00H, 'f', 00H, 'i', 00H, 'g', 00H, 'u', 00H, 'r', 00H, 'a'
	DB	00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG357752 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '%', 00H, 's', 00H
	DB	' ', 00H, '%', 00H, 's', 00H, ' ', 00H, '-', 00H, ' ', 00H, '['
	DB	00H, 'C', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, ' ', 00H, 'T', 00H, 'h', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 'd', 00H, ':', 00H, ' ', 00H, '0', 00H, 'x', 00H, '%', 00H
	DB	'0', 00H, '4', 00H, 'x', 00H, ']', 00H, 00H, 00H
$SG370127 DB	'e', 00H, 'i', 00H, 'd', 00H, '=', 00H, '0', 00H, 'x', 00H
	DB	'%', 00H, 'p', 00H, ',', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'o'
	DB	00H, 'k', 00H, 'i', 00H, 'e', 00H, '=', 00H, '%', 00H, 'u', 00H
	DB	0aH, 00H, 00H, 00H
	ORG $+2
$SG370120 DB	'[', 00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H
	DB	' ', 00H, '1', 00H, '.', 00H, '4', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, '$', 00H, ' ', 00H, 'S', 00H, 'p', 00H
	DB	'a', 00H, 'w', 00H, 'n', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' '
	DB	00H, 'M', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H
	DB	' ', 00H, 'B', 00H, 'u', 00H, 'd', 00H, 'g', 00H, 'e', 00H, 't'
	DB	00H, ' ', 00H, 'C', 00H, 'h', 00H, 'a', 00H, 'n', 00H, 'g', 00H
	DB	'e', 00H, ' ', 00H, 'T', 00H, 'h', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 'd', 00H, '.', 00H, '.', 00H, ':', 00H, ' ', 00H, 00H, 00H
$SG370123 DB	't', 00H, 'i', 00H, 'd', 00H, '=', 00H, '0', 00H, 'x', 00H
	DB	'%', 00H, '0', 00H, '4', 00H, 'x', 00H, 0aH, 00H, 00H, 00H
$SG370128 DB	'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	'!', 00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ')', 00H, 0aH
	DB	00H, 00H, 00H
$SG370124 DB	'[', 00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H
	DB	' ', 00H, '1', 00H, '.', 00H, '4', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, '%', 00H, '%', 00H, ' ', 00H, 'S', 00H
	DB	'e', 00H, 't', 00H, 't', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' '
	DB	00H, 'u', 00H, 'p', 00H, ' ', 00H, 'B', 00H, 'u', 00H, 'd', 00H
	DB	'g', 00H, 'e', 00H, 't', 00H, ' ', 00H, 'C', 00H, 'h', 00H, 'a'
	DB	00H, 'n', 00H, 'g', 00H, 'e', 00H, ' ', 00H, 'N', 00H, 'o', 00H
	DB	't', 00H, 'i', 00H, 'f', 00H, 'i', 00H, 'c', 00H, 'a', 00H, 't'
	DB	00H, 'i', 00H, 'o', 00H, 'n', 00H, '.', 00H, ':', 00H, ' ', 00H
	DB	00H, 00H
	ORG $+2
$SG370129 DB	'f', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	'!', 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG370136 DB	' ', 00H, '(', 00H, 'T', 00H, 'r', 00H, 'i', 00H, 'a', 00H
	DB	'n', 00H, 'g', 00H, 'l', 00H, 'e', 00H, ')', 00H, 0aH, 00H, 00H
	DB	00H
	ORG $+2
$SG370130 DB	'[', 00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H
	DB	' ', 00H, '1', 00H, '.', 00H, '2', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'G', 00H, 'P', 00H, 'U', 00H, ' ', 00H, 'S', 00H, 'c', 00H
	DB	'h', 00H, 'e', 00H, 'd', 00H, 'u', 00H, 'l', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, '.', 00H, '.', 00H, '.', 00H, ':', 00H, ' ', 00H
	DB	'P', 00H, 'r', 00H, 'e', 00H, '-', 00H, 'E', 00H, 'm', 00H, 'p'
	DB	00H, 't', 00H, 'i', 00H, 'v', 00H, 'e', 00H, 00H, 00H
$SG370132 DB	' ', 00H, '(', 00H, 'D', 00H, 'M', 00H, 'A', 00H, ' ', 00H
	DB	'B', 00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, ')'
	DB	00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG370134 DB	' ', 00H, '(', 00H, 'G', 00H, 'r', 00H, 'a', 00H, 'p', 00H
	DB	'h', 00H, 'i', 00H, 'c', 00H, 's', 00H, ' ', 00H, 'P', 00H, 'r'
	DB	00H, 'i', 00H, 'm', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'v', 00H
	DB	'e', 00H, ')', 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG370138 DB	' ', 00H, '(', 00H, 'F', 00H, 'r', 00H, 'a', 00H, 'g', 00H
	DB	'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, ')', 00H, 0aH, 00H, 00H
	DB	00H
	ORG $+2
$SG370140 DB	' ', 00H, '(', 00H, 'I', 00H, 'n', 00H, 's', 00H, 't', 00H
	DB	'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n'
	DB	00H, ')', 00H, 0aH, 00H, 00H, 00H
$SG370142 DB	'U', 00H, 'N', 00H, 'D', 00H, 'E', 00H, 'F', 00H, 'I', 00H
	DB	'N', 00H, 'E', 00H, 'D', 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG370145 DB	0aH, 00H, 00H, 00H
$SG370143 DB	'[', 00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H
	DB	' ', 00H, '1', 00H, '.', 00H, '4', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'L', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 'l', 00H, ' ', 00H
	DB	'M', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, '.'
	DB	00H, '.', 00H, '.', 00H, '.', 00H, '.', 00H, ':', 00H, 00H, 00H
$SG370146 DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 00H, 00H
$SG366050 DB	'd', 00H, 'x', 00H, 'g', 00H, 'i', 00H, '.', 00H, 'd', 00H
	DB	'l', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG370148 DB	0aH, 00H, 00H, 00H
$SG370147 DB	' ', 00H, 'N', 00H, 'o', 00H, 'd', 00H, 'e', 00H, '%', 00H
	DB	'i', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, '(', 00H, 'R', 00H, 'e', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 'v', 00H, 'e', 00H, ':', 00H, ' ', 00H, '%', 00H, '#'
	DB	00H, '5', 00H, 'l', 00H, 'l', 00H, 'u', 00H, ' ', 00H, '/', 00H
	DB	' ', 00H, '%', 00H, '#', 00H, '5', 00H, 'l', 00H, 'l', 00H, 'u'
	DB	00H, ' ', 00H, 'M', 00H, 'i', 00H, 'B', 00H, ' ', 00H, '-', 00H
	DB	' ', 00H, 'B', 00H, 'u', 00H, 'd', 00H, 'g', 00H, 'e', 00H, 't'
	DB	00H, ':', 00H, ' ', 00H, '%', 00H, '#', 00H, '5', 00H, 'l', 00H
	DB	'l', 00H, 'u', 00H, ' ', 00H, '/', 00H, ' ', 00H, '%', 00H, '#'
	DB	00H, '5', 00H, 'l', 00H, 'l', 00H, 'u', 00H, ' ', 00H, 'M', 00H
	DB	'i', 00H, 'B', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG370149 DB	'[', 00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H
	DB	' ', 00H, '1', 00H, '.', 00H, '4', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'N', 00H, 'o', 00H, 'n', 00H, '-', 00H, 'L', 00H, 'o', 00H
	DB	'c', 00H, 'a', 00H, 'l', 00H, ' ', 00H, 'M', 00H, 'e', 00H, 'm'
	DB	00H, 'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, ':', 00H, 00H, 00H
$SG366053 DB	'd', 00H, 'x', 00H, 'g', 00H, 'i', 00H, '.', 00H, 'd', 00H
	DB	'l', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG370151 DB	0aH, 00H, 00H, 00H
$SG366055 DB	'[', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, ' ', 00H
	DB	'H', 00H, 'o', 00H, 'o', 00H, 'k', 00H, 's', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, 'E', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'S', 00H, 't', 00H, 'a'
	DB	00H, 't', 00H, 'i', 00H, 'c', 00H, ' ', 00H, 'I', 00H, 'n', 00H
	DB	'j', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n'
	DB	00H, ' ', 00H, 'A', 00H, 'd', 00H, 'd', 00H, 'r', 00H, 'e', 00H
	DB	's', 00H, 's', 00H, 'e', 00H, 's', 00H, ' ', 00H, 'f', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H
	DB	00H, 00H
	ORG $+2
$SG370152 DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 00H, 00H
$SG366056 DB	'IDXGISwapChain::Present', 00H
$SG370153 DB	' ', 00H, 'N', 00H, 'o', 00H, 'd', 00H, 'e', 00H, '%', 00H
	DB	'i', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, '(', 00H, 'R', 00H, 'e', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 'v', 00H, 'e', 00H, ':', 00H, ' ', 00H, '%', 00H, '#'
	DB	00H, '5', 00H, 'l', 00H, 'l', 00H, 'u', 00H, ' ', 00H, '/', 00H
	DB	' ', 00H, '%', 00H, '#', 00H, '5', 00H, 'l', 00H, 'l', 00H, 'u'
	DB	00H, ' ', 00H, 'M', 00H, 'i', 00H, 'B', 00H, ' ', 00H, '-', 00H
	DB	' ', 00H, 'B', 00H, 'u', 00H, 'd', 00H, 'g', 00H, 'e', 00H, 't'
	DB	00H, ':', 00H, ' ', 00H, '%', 00H, '#', 00H, '5', 00H, 'l', 00H
	DB	'l', 00H, 'u', 00H, ' ', 00H, '/', 00H, ' ', 00H, '%', 00H, '#'
	DB	00H, '5', 00H, 'l', 00H, 'l', 00H, 'u', 00H, ' ', 00H, 'M', 00H
	DB	'i', 00H, 'B', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG366057 DB	'd', 00H, 'x', 00H, 'g', 00H, 'i', 00H, 00H, 00H
	ORG $+2
$SG370154 DB	0aH, 00H, 00H, 00H
$SG366063 DB	'd', 00H, 'x', 00H, 'g', 00H, 'i', 00H, 00H, 00H
	ORG $+2
$SG200184 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'H', 00H, 'o', 00H, 's', 00H, 't', 00H, 'i'
	DB	00H, 'n', 00H, 'g', 00H, 00H, 00H
$SG356859 DB	'C', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'e', 00H
	DB	'S', 00H, 'w', 00H, 'a', 00H, 'p', 00H, 'C', 00H, 'h', 00H, 'a'
	DB	00H, 'i', 00H, 'n', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 00H, 00H
	ORG $+2
$SG357884 DB	'd', 00H, 'x', 00H, 'g', 00H, 'i', 00H, '.', 00H, 'd', 00H
	DB	'l', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG356860 DB	'%', 00H, 's', 00H, ':', 00H, ':', 00H, '%', 00H, 's', 00H
	DB	' ', 00H, '(', 00H, 00H, 00H
	ORG $+2
$SG357885 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'I', 00H, 'm', 00H, 'p', 00H, 'o', 00H, 'r', 00H, 't', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'C', 00H, 'r', 00H, 'e'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, 'D', 00H, 'X', 00H, 'G', 00H
	DB	'I', 00H, 'F', 00H, 'a', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, 'y', 00H, '{', 00H, '1', 00H, '|', 00H, '2', 00H, '}', 00H
	DB	00H, 00H
$SG356861 DB	'%', 00H, 'p', 00H, 'h', 00H, ',', 00H, ' ', 00H, '%', 00H
	DB	'p', 00H, 'h', 00H, ',', 00H, ' ', 00H, '%', 00H, 'p', 00H, 'h'
	DB	00H, 00H, 00H
$SG357886 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H
	DB	'=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '='
	DB	00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H
	DB	'=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '='
	DB	00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H, '=', 00H
	DB	00H, 00H
$SG356862 DB	'%', 00H, 's', 00H, '%', 00H, 's', 00H, ')', 00H, 00H, 00H
$SG356863 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '%', 00H, '-', 00H
	DB	'1', 00H, '0', 00H, '2', 00H, 's', 00H, ' ', 00H, '-', 00H, '-'
	DB	00H, ' ', 00H, '%', 00H, 's', 00H, 00H, 00H
$SG357890 DB	'd', 00H, 'x', 00H, 'g', 00H, 'i', 00H, '.', 00H, 'd', 00H
	DB	'l', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG357891 DB	'CreateDXGIFactory', 00H
	ORG $+2
$SG357893 DB	'CreateDXGIFactory1', 00H
	ORG $+1
$SG357892 DB	'[', 00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H
	DB	' ', 00H, '1', 00H, '.', 00H, '0', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, 'C', 00H, 'r', 00H, 'e', 00H, 'a', 00H
	DB	't', 00H, 'e', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'F'
	DB	00H, 'a', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'y', 00H
	DB	':', 00H, ' ', 00H, ' ', 00H, '%', 00H, 'p', 00H, 'h', 00H, 00H
	DB	00H
	ORG $+2
$SG357894 DB	'[', 00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H
	DB	' ', 00H, '1', 00H, '.', 00H, '1', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, 'C', 00H, 'r', 00H, 'e', 00H, 'a', 00H
	DB	't', 00H, 'e', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'F'
	DB	00H, 'a', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'y', 00H
	DB	'1', 00H, ':', 00H, ' ', 00H, '%', 00H, 'p', 00H, 'h', 00H, 00H
	DB	00H
	ORG $+2
$SG357895 DB	'CreateDXGIFactory2', 00H
	ORG $+1
$SG366090 DB	'I', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'S', 00H
	DB	'w', 00H, 'a', 00H, 'p', 00H, 'C', 00H, 'h', 00H, 'a', 00H, 'i'
	DB	00H, 'n', 00H, ':', 00H, ':', 00H, 'P', 00H, 'r', 00H, 'e', 00H
	DB	's', 00H, 'e', 00H, 'n', 00H, 't', 00H, 00H, 00H
$SG357898 DB	'CreateDXGIFactory', 00H
	ORG $+2
$SG357896 DB	'[', 00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H
	DB	' ', 00H, '1', 00H, '.', 00H, '3', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, 'C', 00H, 'r', 00H, 'e', 00H, 'a', 00H
	DB	't', 00H, 'e', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'F'
	DB	00H, 'a', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'y', 00H
	DB	'2', 00H, ':', 00H, ' ', 00H, '%', 00H, 'p', 00H, 'h', 00H, 00H
	DB	00H
	ORG $+2
$SG357899 DB	'CreateDXGIFactory', 00H
	ORG $+2
$SG357900 DB	'd', 00H, 'x', 00H, 'g', 00H, 'i', 00H, '.', 00H, 'd', 00H
	DB	'l', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG354828 DB	'[', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, ' ', 00H
	DB	'H', 00H, 'o', 00H, 'o', 00H, 'k', 00H, 's', 00H, ']', 00H, ' '
	DB	00H, 'I', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'S', 00H
	DB	'w', 00H, 'a', 00H, 'p', 00H, 'C', 00H, 'h', 00H, 'a', 00H, 'i'
	DB	00H, 'n', 00H, ':', 00H, ':', 00H, 'P', 00H, 'r', 00H, 'e', 00H
	DB	's', 00H, 'e', 00H, 'n', 00H, 't', 00H, ' ', 00H, '(', 00H, '.'
	DB	00H, '.', 00H, '.', 00H, ')', 00H, ' ', 00H, 'f', 00H, 'u', 00H
	DB	'n', 00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ' '
	DB	00H, 'p', 00H, 'r', 00H, 'o', 00H, 'l', 00H, 'o', 00H, 'g', 00H
	DB	' ', 00H, 'a', 00H, 'l', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'e'
	DB	00H, 'd', 00H, ' ', 00H, '(', 00H, 'e', 00H, 'x', 00H, 'p', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'e', 00H, 'd', 00H, ':', 00H, ' '
	DB	00H, '''', 00H, '%', 00H, '0', 00H, '2', 00H, 'x', 00H, '%', 00H
	DB	'0', 00H, '2', 00H, 'x', 00H, '%', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, '%', 00H, '0', 00H, '2', 00H, 'x', 00H, '%', 00H, '0', 00H
	DB	'2', 00H, 'x', 00H, '%', 00H, '0', 00H, '2', 00H, 'x', 00H, '%'
	DB	00H, '0', 00H, '2', 00H, 'x', 00H, '%', 00H, '0', 00H, '2', 00H
	DB	'x', 00H, '%', 00H, '0', 00H, '2', 00H, 'x', 00H, '%', 00H, '0'
	DB	00H, '2', 00H, 'x', 00H, '%', 00H, '0', 00H, '2', 00H, 'x', 00H
	DB	'%', 00H, '0', 00H, '2', 00H, 'x', 00H, '''', 00H, ',', 00H, ' '
	DB	00H, 'b', 00H, 'u', 00H, 't', 00H, ' ', 00H, 'g', 00H, 'o', 00H
	DB	't', 00H, ' ', 00H, '''', 00H, '%', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, '%', 00H, '0', 00H, '2', 00H, 'x', 00H, '%', 00H, '0', 00H
	DB	'2', 00H, 'x', 00H, '%', 00H, '0', 00H, '2', 00H, 'x', 00H, '%'
	DB	00H, '0', 00H, '2', 00H, 'x', 00H, '%', 00H, '0', 00H, '2', 00H
	DB	'x', 00H, '%', 00H, '0', 00H, '2', 00H, 'x', 00H, '%', 00H, '0'
	DB	00H, '2', 00H, 'x', 00H, '%', 00H, '0', 00H, '2', 00H, 'x', 00H
	DB	'%', 00H, '0', 00H, '2', 00H, 'x', 00H, '%', 00H, '0', 00H, '2'
	DB	00H, 'x', 00H, '%', 00H, '0', 00H, '2', 00H, 'x', 00H, '''', 00H
	DB	')', 00H, ';', 00H, ' ', 00H, 'f', 00H, 'a', 00H, 'l', 00H, 'l'
	DB	00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'b', 00H, 'a', 00H
	DB	'c', 00H, 'k', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'v'
	DB	00H, 'f', 00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	' ', 00H, 'o', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'i'
	DB	00H, 'd', 00H, 'e', 00H, '.', 00H, 00H, 00H
	ORG $+2
$SG357902 DB	'CreateDXGIFactory1', 00H
	ORG $+1
$SG211470 DB	'S', 00H, 00H, 00H
$SG357903 DB	'CreateDXGIFactory1', 00H
	ORG $+1
$SG366095 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'A', 00H, 'l', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'e', 00H
	DB	'd', 00H, ' ', 00H, 'v', 00H, 'f', 00H, 't', 00H, 'a', 00H, 'b'
	DB	00H, 'l', 00H, 'e', 00H, ' ', 00H, 'd', 00H, 'e', 00H, 't', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'e', 00H, 'd', 00H, ',', 00H, ' '
	DB	00H, 'r', 00H, 'e', 00H, 'h', 00H, 'o', 00H, 'o', 00H, 'k', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'I', 00H, 'D', 00H, 'X'
	DB	00H, 'G', 00H, 'I', 00H, 'S', 00H, 'w', 00H, 'a', 00H, 'p', 00H
	DB	'C', 00H, 'h', 00H, 'a', 00H, 'i', 00H, 'n', 00H, ':', 00H, ':'
	DB	00H, 'P', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, ' ', 00H, '(', 00H, '.', 00H, '.', 00H, '.', 00H, ')'
	DB	00H, '!', 00H, 00H, 00H
$SG357904 DB	'd', 00H, 'x', 00H, 'g', 00H, 'i', 00H, '.', 00H, 'd', 00H
	DB	'l', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG211472 DB	'M', 00H, 00H, 00H
$SG366098 DB	'I', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'S', 00H
	DB	'w', 00H, 'a', 00H, 'p', 00H, 'C', 00H, 'h', 00H, 'a', 00H, 'i'
	DB	00H, 'n', 00H, ':', 00H, ':', 00H, 'P', 00H, 'r', 00H, 'e', 00H
	DB	's', 00H, 'e', 00H, 'n', 00H, 't', 00H, 00H, 00H
$SG357906 DB	'CreateDXGIFactory2', 00H
	ORG $+1
$SG211474 DB	'D', 00H, 00H, 00H
$SG357907 DB	'CreateDXGIFactory2', 00H
	ORG $+1
$SG357908 DB	'd', 00H, 'x', 00H, 'g', 00H, 'i', 00H, '.', 00H, 'd', 00H
	DB	'l', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG211476 DB	'B', 00H, 00H, 00H
$SG357909 DB	'{', 00H, ' ', 00H, 'H', 00H, 'o', 00H, 'o', 00H, 'k', 00H
	DB	'e', 00H, 'd', 00H, ' ', 00H, '}', 00H, 00H, 00H
	ORG $+2
$SG357910 DB	00H, 00H
	ORG $+2
$SG211478 DB	'V', 00H, 'a', 00H, 'l', 00H, 00H, 00H
$SG357911 DB	'[', 00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H
	DB	' ', 00H, '1', 00H, '.', 00H, '0', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, 'C', 00H, 'r', 00H, 'e', 00H, 'a', 00H
	DB	't', 00H, 'e', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'F'
	DB	00H, 'a', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'y', 00H
	DB	':', 00H, ' ', 00H, ' ', 00H, '%', 00H, 'p', 00H, 'h', 00H, ' '
	DB	00H, ' ', 00H, '%', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG357912 DB	'{', 00H, ' ', 00H, 'H', 00H, 'o', 00H, 'o', 00H, 'k', 00H
	DB	'e', 00H, 'd', 00H, ' ', 00H, '}', 00H, 00H, 00H
	ORG $+2
$SG211480 DB	'F', 00H, 'o', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'R', 00H
	DB	'e', 00H, 'm', 00H, 'o', 00H, 'v', 00H, 'e', 00H, 00H, 00H
$SG370201 DB	'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'M', 00H, 'e', 00H
	DB	'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 'B', 00H, 'u', 00H, 'd'
	DB	00H, 'g', 00H, 'e', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG357913 DB	00H, 00H
	ORG $+2
$SG370202 DB	'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'M', 00H, 'e', 00H
	DB	'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 'B', 00H, 'u', 00H, 'd'
	DB	00H, 'g', 00H, 'e', 00H, 't', 00H, '_', 00H, 'S', 00H, 'h', 00H
	DB	'u', 00H, 't', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n', 00H, 00H
	DB	00H
$SG211482 DB	'N', 00H, 'o', 00H, 'R', 00H, 'e', 00H, 'm', 00H, 'o', 00H
	DB	'v', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG357914 DB	'[', 00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H
	DB	' ', 00H, '1', 00H, '.', 00H, '1', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, 'C', 00H, 'r', 00H, 'e', 00H, 'a', 00H
	DB	't', 00H, 'e', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'F'
	DB	00H, 'a', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'y', 00H
	DB	'1', 00H, ':', 00H, ' ', 00H, '%', 00H, 'p', 00H, 'h', 00H, ' '
	DB	00H, ' ', 00H, '%', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG357915 DB	'{', 00H, ' ', 00H, 'H', 00H, 'o', 00H, 'o', 00H, 'k', 00H
	DB	'e', 00H, 'd', 00H, ' ', 00H, '}', 00H, 00H, 00H
	ORG $+2
$SG357916 DB	00H, 00H
	ORG $+2
$SG211484 DB	'D', 00H, 'e', 00H, 'l', 00H, 'e', 00H, 't', 00H, 'e', 00H
	DB	00H, 00H
	ORG $+2
$SG357922 DB	'PreRenderLimit', 00H
	ORG $+1
$SG357924 DB	'BufferCount', 00H
$SG357917 DB	'[', 00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H
	DB	' ', 00H, '1', 00H, '.', 00H, '3', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, 'C', 00H, 'r', 00H, 'e', 00H, 'a', 00H
	DB	't', 00H, 'e', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'F'
	DB	00H, 'a', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'y', 00H
	DB	'2', 00H, ':', 00H, ' ', 00H, '%', 00H, 'p', 00H, 'h', 00H, ' '
	DB	00H, ' ', 00H, '%', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG357920 DB	'PresentationInterval', 00H
	ORG $+3
$SG366114 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'A', 00H, 'l', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'e', 00H
	DB	'd', 00H, ' ', 00H, 'v', 00H, 'f', 00H, 't', 00H, 'a', 00H, 'b'
	DB	00H, 'l', 00H, 'e', 00H, ' ', 00H, 'd', 00H, 'e', 00H, 't', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'e', 00H, 'd', 00H, ',', 00H, ' '
	DB	00H, 'r', 00H, 'e', 00H, 'h', 00H, 'o', 00H, 'o', 00H, 'k', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'I', 00H, 'D', 00H, 'X'
	DB	00H, 'G', 00H, 'I', 00H, 'S', 00H, 'w', 00H, 'a', 00H, 'p', 00H
	DB	'C', 00H, 'h', 00H, 'a', 00H, 'i', 00H, 'n', 00H, '1', 00H, ':'
	DB	00H, ':', 00H, 'P', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'e', 00H
	DB	'n', 00H, 't', 00H, '1', 00H, ' ', 00H, '(', 00H, '.', 00H, '.'
	DB	00H, '.', 00H, ')', 00H, '!', 00H, 00H, 00H
$SG366117 DB	'I', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'S', 00H
	DB	'w', 00H, 'a', 00H, 'p', 00H, 'C', 00H, 'h', 00H, 'a', 00H, 'i'
	DB	00H, 'n', 00H, '1', 00H, ':', 00H, ':', 00H, 'P', 00H, 'r', 00H
	DB	'e', 00H, 's', 00H, 'e', 00H, 'n', 00H, 't', 00H, '1', 00H, 00H
	DB	00H
$SG370212 DB	'[', 00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H
	DB	' ', 00H, '1', 00H, '.', 00H, '4', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'L', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 'l', 00H, ' ', 00H
	DB	'M', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, '.'
	DB	00H, '.', 00H, '.', 00H, '.', 00H, '.', 00H, ':', 00H, 00H, 00H
$SG357926 DB	'UseFlipDiscard', 00H
	ORG $+1
$SG370215 DB	0aH, 00H, 00H, 00H
$SG200231 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'D', 00H, 'B', 00H, 'C', 00H, 'l', 00H, 'i'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG370216 DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, 00H, 00H
$SG366130 DB	'<', 00H, 'N', 00H, 'O', 00H, 'T', 00H, ' ', 00H, 'I', 00H
	DB	'M', 00H, 'P', 00H, 'L', 00H, 'E', 00H, 'M', 00H, 'E', 00H, 'N'
	DB	00H, 'T', 00H, 'E', 00H, 'D', 00H, '>', 00H, 00H, 00H
$SG370217 DB	' ', 00H, 'N', 00H, 'o', 00H, 'd', 00H, 'e', 00H, '%', 00H
	DB	'i', 00H, ' ', 00H, '(', 00H, 'R', 00H, 'e', 00H, 's', 00H, 'e'
	DB	00H, 'r', 00H, 'v', 00H, 'e', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	'#', 00H, '5', 00H, 'l', 00H, 'l', 00H, 'u', 00H, ' ', 00H, '/'
	DB	00H, ' ', 00H, '%', 00H, '#', 00H, '5', 00H, 'l', 00H, 'l', 00H
	DB	'u', 00H, ' ', 00H, 'M', 00H, 'i', 00H, 'B', 00H, ' ', 00H, '-'
	DB	00H, ' ', 00H, 'B', 00H, 'u', 00H, 'd', 00H, 'g', 00H, 'e', 00H
	DB	't', 00H, ':', 00H, ' ', 00H, '%', 00H, '#', 00H, '5', 00H, 'l'
	DB	00H, 'l', 00H, 'u', 00H, ' ', 00H, '/', 00H, ' ', 00H, '%', 00H
	DB	'#', 00H, '5', 00H, 'l', 00H, 'l', 00H, 'u', 00H, ' ', 00H, 'M'
	DB	00H, 'i', 00H, 'B', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG370229 DB	0aH, 00H, 00H, 00H
$SG370230 DB	'[', 00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H
	DB	' ', 00H, '1', 00H, '.', 00H, '4', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'N', 00H, 'o', 00H, 'n', 00H, '-', 00H, 'L', 00H, 'o', 00H
	DB	'c', 00H, 'a', 00H, 'l', 00H, ' ', 00H, 'M', 00H, 'e', 00H, 'm'
	DB	00H, 'o', 00H, 'r', 00H, 'y', 00H, '.', 00H, ':', 00H, 00H, 00H
$SG370232 DB	0aH, 00H, 00H, 00H
$SG370235 DB	0aH, 00H, 00H, 00H
$SG370233 DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, 00H, 00H
$SG356936 DB	'%', 00H, 's', 00H, ':', 00H, ':', 00H, '%', 00H, 's', 00H
	DB	' ', 00H, '(', 00H, 00H, 00H
	ORG $+2
$SG370234 DB	' ', 00H, 'N', 00H, 'o', 00H, 'd', 00H, 'e', 00H, '%', 00H
	DB	'i', 00H, ' ', 00H, '(', 00H, 'R', 00H, 'e', 00H, 's', 00H, 'e'
	DB	00H, 'r', 00H, 'v', 00H, 'e', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	'#', 00H, '5', 00H, 'l', 00H, 'l', 00H, 'u', 00H, ' ', 00H, '/'
	DB	00H, ' ', 00H, '%', 00H, '#', 00H, '5', 00H, 'l', 00H, 'l', 00H
	DB	'u', 00H, ' ', 00H, 'M', 00H, 'i', 00H, 'B', 00H, ' ', 00H, '-'
	DB	00H, ' ', 00H, 'B', 00H, 'u', 00H, 'd', 00H, 'g', 00H, 'e', 00H
	DB	't', 00H, ':', 00H, ' ', 00H, '%', 00H, '#', 00H, '5', 00H, 'l'
	DB	00H, 'l', 00H, 'u', 00H, ' ', 00H, '/', 00H, ' ', 00H, '%', 00H
	DB	'#', 00H, '5', 00H, 'l', 00H, 'l', 00H, 'u', 00H, ' ', 00H, 'M'
	DB	00H, 'i', 00H, 'B', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG356937 DB	'%', 00H, 'p', 00H, 'h', 00H, ',', 00H, ' ', 00H, '%', 00H
	DB	'p', 00H, 'h', 00H, ',', 00H, ' ', 00H, '%', 00H, 'p', 00H, 'h'
	DB	00H, 00H, 00H
$SG356935 DB	'C', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'e', 00H
	DB	'S', 00H, 'w', 00H, 'a', 00H, 'p', 00H, 'C', 00H, 'h', 00H, 'a'
	DB	00H, 'i', 00H, 'n', 00H, 'F', 00H, 'o', 00H, 'r', 00H, 'C', 00H
	DB	'o', 00H, 'r', 00H, 'e', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd'
	DB	00H, 'o', 00H, 'w', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 00H, 00H
$SG356938 DB	'%', 00H, 's', 00H, '%', 00H, 's', 00H, ')', 00H, 00H, 00H
$SG356939 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '%', 00H, '-', 00H
	DB	'1', 00H, '0', 00H, '2', 00H, 's', 00H, ' ', 00H, '-', 00H, '-'
	DB	00H, ' ', 00H, '%', 00H, 's', 00H, 00H, 00H
$SG370259 DB	'd', 00H, 'x', 00H, 'g', 00H, 'i', 00H, '.', 00H, 'd', 00H
	DB	'l', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG370261 DB	'CreateDXGIFactory', 00H
	ORG $+2
$SG200278 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'D', 00H, 'B', 00H, 'P', 00H, 'r', 00H, 'o'
	DB	00H, 'v', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG370286 DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, 00H, 00H
	ORG $+2
$SG370281 DB	'[', 00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H
	DB	' ', 00H, '1', 00H, '.', 00H, '4', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'S', 00H, 'h', 00H, 'u', 00H, 't', 00H, 't', 00H, 'i', 00H
	DB	'n', 00H, 'g', 00H, ' ', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'n'
	DB	00H, ' ', 00H, 'M', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H
	DB	'y', 00H, ' ', 00H, 'B', 00H, 'u', 00H, 'd', 00H, 'g', 00H, 'e'
	DB	00H, 't', 00H, ' ', 00H, 'C', 00H, 'h', 00H, 'a', 00H, 'n', 00H
	DB	'g', 00H, 'e', 00H, ' ', 00H, 'T', 00H, 'h', 00H, 'r', 00H, 'e'
	DB	00H, 'a', 00H, 'd', 00H, '.', 00H, '.', 00H, '.', 00H, ' ', 00H
	DB	00H, 00H
	ORG $+2
$SG370284 DB	'd', 00H, 'o', 00H, 'n', 00H, 'e', 00H, '!', 00H, 0aH, 00H
	DB	00H, 00H
	ORG $+2
$SG370285 DB	't', 00H, 'i', 00H, 'm', 00H, 'e', 00H, 'd', 00H, ' ', 00H
	DB	'o', 00H, 'u', 00H, 't', 00H, ' ', 00H, '(', 00H, 'k', 00H, 'i'
	DB	00H, 'l', 00H, 'l', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H
	DB	'm', 00H, 'a', 00H, 'n', 00H, 'u', 00H, 'a', 00H, 'l', 00H, 'l'
	DB	00H, 'y', 00H, ')', 00H, '!', 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG370287 DB	'S', 00H, 'h', 00H, 'u', 00H, 't', 00H, 'd', 00H, 'o', 00H
	DB	'w', 00H, 'n', 00H, ' ', 00H, 'S', 00H, 't', 00H, 'a', 00H, 't'
	DB	00H, 'i', 00H, 's', 00H, 't', 00H, 'i', 00H, 'c', 00H, 's', 00H
	DB	':', 00H, 00H, 00H
	ORG $+2
$SG370288 DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, 0aH, 00H, 00H, 00H
$SG370289 DB	' ', 00H, 'M', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H
	DB	'y', 00H, ' ', 00H, 'B', 00H, 'u', 00H, 'd', 00H, 'g', 00H, 'e'
	DB	00H, 't', 00H, ' ', 00H, 'C', 00H, 'h', 00H, 'a', 00H, 'n', 00H
	DB	'g', 00H, 'e', 00H, 'd', 00H, ' ', 00H, '%', 00H, 'l', 00H, 'l'
	DB	00H, 'u', 00H, ' ', 00H, 't', 00H, 'i', 00H, 'm', 00H, 'e', 00H
	DB	's', 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG370293 DB	' ', 00H, 'G', 00H, 'P', 00H, 'U', 00H, '%', 00H, 'i', 00H
	DB	':', 00H, ' ', 00H, 'M', 00H, 'i', 00H, 'n', 00H, ' ', 00H, 'B'
	DB	00H, 'u', 00H, 'd', 00H, 'g', 00H, 'e', 00H, 't', 00H, ':', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, '%', 00H, '0', 00H, '5', 00H, 'l', 00H, 'l', 00H
	DB	'u', 00H, ' ', 00H, 'M', 00H, 'i', 00H, 'B', 00H, 0aH, 00H, 00H
	DB	00H
	ORG $+2
$SG370294 DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, 'M', 00H, 'a', 00H, 'x', 00H, ' ', 00H, 'B', 00H, 'u'
	DB	00H, 'd', 00H, 'g', 00H, 'e', 00H, 't', 00H, ':', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, '%', 00H, '0', 00H, '5', 00H, 'l', 00H, 'l', 00H, 'u', 00H
	DB	' ', 00H, 'M', 00H, 'i', 00H, 'B', 00H, 0aH, 00H, 00H, 00H
$SG370301 DB	0aH, 00H, 00H, 00H
$SG370295 DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, 'M', 00H, 'i', 00H, 'n', 00H, ' ', 00H, 'U', 00H, 's'
	DB	00H, 'a', 00H, 'g', 00H, 'e', 00H, ':', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, '%', 00H, '0', 00H, '5', 00H, 'l', 00H, 'l', 00H, 'u', 00H
	DB	' ', 00H, 'M', 00H, 'i', 00H, 'B', 00H, 0aH, 00H, 00H, 00H
$SG357018 DB	'%', 00H, 's', 00H, ':', 00H, ':', 00H, '%', 00H, 's', 00H
	DB	' ', 00H, '(', 00H, 00H, 00H
	ORG $+2
$SG370296 DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, 'M', 00H, 'a', 00H, 'x', 00H, ' ', 00H, 'U', 00H, 's'
	DB	00H, 'a', 00H, 'g', 00H, 'e', 00H, ':', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, '%', 00H, '0', 00H, '5', 00H, 'l', 00H, 'l', 00H, 'u', 00H
	DB	' ', 00H, 'M', 00H, 'i', 00H, 'B', 00H, 0aH, 00H, 00H, 00H
$SG357019 DB	'%', 00H, 'p', 00H, 'h', 00H, ',', 00H, ' ', 00H, '%', 00H
	DB	'p', 00H, 'h', 00H, ',', 00H, ' ', 00H, '%', 00H, 'p', 00H, 'h'
	DB	00H, 00H, 00H
$SG370297 DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, 0aH, 00H, 00H, 00H
$SG357020 DB	'%', 00H, 's', 00H, '%', 00H, 's', 00H, ')', 00H, 00H, 00H
$SG370298 DB	' ', 00H, 'M', 00H, 'i', 00H, 'n', 00H, 'i', 00H, 'm', 00H
	DB	'u', 00H, 'm', 00H, ' ', 00H, 'O', 00H, 'v', 00H, 'e', 00H, 'r'
	DB	00H, ' ', 00H, 'B', 00H, 'u', 00H, 'd', 00H, 'g', 00H, 'e', 00H
	DB	't', 00H, ':', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, '%', 00H, '0', 00H, '5', 00H, 'l', 00H, 'l', 00H, 'u', 00H
	DB	' ', 00H, 'M', 00H, 'i', 00H, 'B', 00H, 0aH, 00H, 00H, 00H
$SG357021 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '%', 00H, '-', 00H
	DB	'1', 00H, '0', 00H, '2', 00H, 's', 00H, ' ', 00H, '-', 00H, '-'
	DB	00H, ' ', 00H, '%', 00H, 's', 00H, 00H, 00H
$SG370299 DB	' ', 00H, 'M', 00H, 'a', 00H, 'x', 00H, 'i', 00H, 'm', 00H
	DB	'u', 00H, 'm', 00H, ' ', 00H, 'O', 00H, 'v', 00H, 'e', 00H, 'r'
	DB	00H, ' ', 00H, 'B', 00H, 'u', 00H, 'd', 00H, 'g', 00H, 'e', 00H
	DB	't', 00H, ':', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, '%', 00H, '0', 00H, '5', 00H, 'l', 00H, 'l', 00H, 'u', 00H
	DB	' ', 00H, 'M', 00H, 'i', 00H, 'B', 00H, 0aH, 00H, 00H, 00H
$SG366238 DB	'I', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'S', 00H
	DB	'w', 00H, 'a', 00H, 'p', 00H, 'C', 00H, 'h', 00H, 'a', 00H, 'i'
	DB	00H, 'n', 00H, ':', 00H, ':', 00H, 'R', 00H, 'e', 00H, 's', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, 'B', 00H, 'u', 00H, 'f', 00H, 'f'
	DB	00H, 'e', 00H, 'r', 00H, 's', 00H, 00H, 00H
$SG370300 DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, 0aH, 00H, 00H, 00H
$SG200325 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'S', 00H, 'n', 00H, 'a', 00H, 'p', 00H, 'i'
	DB	00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG366239 DB	'I', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'S', 00H
	DB	'w', 00H, 'a', 00H, 'p', 00H, 'C', 00H, 'h', 00H, 'a', 00H, 'i'
	DB	00H, 'n', 00H, ':', 00H, ':', 00H, 'R', 00H, 'e', 00H, 's', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, 'T', 00H, 'a', 00H, 'r', 00H, 'g'
	DB	00H, 'e', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG357017 DB	'C', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'e', 00H
	DB	'S', 00H, 'w', 00H, 'a', 00H, 'p', 00H, 'C', 00H, 'h', 00H, 'a'
	DB	00H, 'i', 00H, 'n', 00H, 'F', 00H, 'o', 00H, 'r', 00H, 'H', 00H
	DB	'w', 00H, 'n', 00H, 'd', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 00H, 00H
$SG366236 DB	'I', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'S', 00H
	DB	'w', 00H, 'a', 00H, 'p', 00H, 'C', 00H, 'h', 00H, 'a', 00H, 'i'
	DB	00H, 'n', 00H, ':', 00H, ':', 00H, 'S', 00H, 'e', 00H, 't', 00H
	DB	'F', 00H, 'u', 00H, 'l', 00H, 'l', 00H, 's', 00H, 'c', 00H, 'r'
	DB	00H, 'e', 00H, 'e', 00H, 'n', 00H, 'S', 00H, 't', 00H, 'a', 00H
	DB	't', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG366237 DB	'I', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'S', 00H
	DB	'w', 00H, 'a', 00H, 'p', 00H, 'C', 00H, 'h', 00H, 'a', 00H, 'i'
	DB	00H, 'n', 00H, ':', 00H, ':', 00H, 'G', 00H, 'e', 00H, 't', 00H
	DB	'F', 00H, 'u', 00H, 'l', 00H, 'l', 00H, 's', 00H, 'c', 00H, 'r'
	DB	00H, 'e', 00H, 'e', 00H, 'n', 00H, 'S', 00H, 't', 00H, 'a', 00H
	DB	't', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG366242 DB	'I', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'O', 00H
	DB	'u', 00H, 't', 00H, 'p', 00H, 'u', 00H, 't', 00H, ':', 00H, ':'
	DB	00H, 'G', 00H, 'e', 00H, 't', 00H, 'D', 00H, 'i', 00H, 's', 00H
	DB	'p', 00H, 'l', 00H, 'a', 00H, 'y', 00H, 'M', 00H, 'o', 00H, 'd'
	DB	00H, 'e', 00H, 'L', 00H, 'i', 00H, 's', 00H, 't', 00H, 00H, 00H
$SG366243 DB	'I', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'O', 00H
	DB	'u', 00H, 't', 00H, 'p', 00H, 'u', 00H, 't', 00H, ':', 00H, ':'
	DB	00H, 'F', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'C', 00H, 'l', 00H
	DB	'o', 00H, 's', 00H, 'e', 00H, 's', 00H, 't', 00H, 'M', 00H, 'a'
	DB	00H, 't', 00H, 'c', 00H, 'h', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	'M', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG366244 DB	'I', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'O', 00H
	DB	'u', 00H, 't', 00H, 'p', 00H, 'u', 00H, 't', 00H, ':', 00H, ':'
	DB	00H, 'W', 00H, 'a', 00H, 'i', 00H, 't', 00H, 'F', 00H, 'o', 00H
	DB	'r', 00H, 'V', 00H, 'B', 00H, 'l', 00H, 'a', 00H, 'n', 00H, 'k'
	DB	00H, 00H, 00H
	ORG $+2
$SG352938 DB	'E', 00H, 'x', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 't', 00H
	DB	'e', 00H, 00H, 00H
$SG352940 DB	'E', 00H, 'x', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 't', 00H
	DB	'e', 00H, ' ', 00H, '+', 00H, ' ', 00H, 'R', 00H, 'e', 00H, 'a'
	DB	00H, 'd', 00H, '-', 00H, 'O', 00H, 'n', 00H, 'l', 00H, 'y', 00H
	DB	00H, 00H
$SG352942 DB	'E', 00H, 'x', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 't', 00H
	DB	'e', 00H, ' ', 00H, '+', 00H, ' ', 00H, 'R', 00H, 'e', 00H, 'a'
	DB	00H, 'd', 00H, '/', 00H, 'W', 00H, 'r', 00H, 'i', 00H, 't', 00H
	DB	'e', 00H, 00H, 00H
	ORG $+2
$SG352944 DB	'E', 00H, 'x', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 't', 00H
	DB	'e', 00H, ' ', 00H, '+', 00H, ' ', 00H, 'R', 00H, 'e', 00H, 'a'
	DB	00H, 'd', 00H, '-', 00H, 'O', 00H, 'n', 00H, 'l', 00H, 'y', 00H
	DB	' ', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'C', 00H, 'o', 00H, 'p'
	DB	00H, 'y', 00H, '-', 00H, 'o', 00H, 'n', 00H, '-', 00H, 'W', 00H
	DB	'r', 00H, 'i', 00H, 't', 00H, 'e', 00H, ')', 00H, 00H, 00H
$SG352946 DB	'N', 00H, 'o', 00H, ' ', 00H, 'A', 00H, 'c', 00H, 'c', 00H
	DB	'e', 00H, 's', 00H, 's', 00H, 00H, 00H
$SG352948 DB	'R', 00H, 'e', 00H, 'a', 00H, 'd', 00H, '-', 00H, 'O', 00H
	DB	'n', 00H, 'l', 00H, 'y', 00H, 00H, 00H
$SG200372 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'N', 00H, 'o', 00H, 't', 00H, 'I', 00H, 'm'
	DB	00H, 'p', 00H, 'l', 00H, 00H, 00H
$SG352950 DB	'R', 00H, 'e', 00H, 'a', 00H, 'd', 00H, '/', 00H, 'W', 00H
	DB	'r', 00H, 'i', 00H, 't', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG352952 DB	' ', 00H, 'R', 00H, 'e', 00H, 'a', 00H, 'd', 00H, '-', 00H
	DB	'O', 00H, 'n', 00H, 'l', 00H, 'y', 00H, ' ', 00H, 'o', 00H, 'r'
	DB	00H, ' ', 00H, 'C', 00H, 'o', 00H, 'p', 00H, 'y', 00H, '-', 00H
	DB	'o', 00H, 'n', 00H, '-', 00H, 'W', 00H, 'r', 00H, 'i', 00H, 't'
	DB	00H, 'e', 00H, 00H, 00H
$SG357051 DB	'%', 00H, 's', 00H, ':', 00H, ':', 00H, '%', 00H, 's', 00H
	DB	' ', 00H, '(', 00H, 00H, 00H
	ORG $+2
$SG357050 DB	'C', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 't', 00H, 'e', 00H
	DB	'S', 00H, 'w', 00H, 'a', 00H, 'p', 00H, 'C', 00H, 'h', 00H, 'a'
	DB	00H, 'i', 00H, 'n', 00H, 'F', 00H, 'o', 00H, 'r', 00H, 'C', 00H
	DB	'o', 00H, 'm', 00H, 'p', 00H, 'o', 00H, 's', 00H, 'i', 00H, 't'
	DB	00H, 'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 00H
	DB	00H
	ORG $+2
$SG352954 DB	'U', 00H, 'N', 00H, 'K', 00H, 'N', 00H, 'O', 00H, 'W', 00H
	DB	'N', 00H, 00H, 00H
$SG357052 DB	'%', 00H, 'p', 00H, 'h', 00H, ',', 00H, ' ', 00H, '%', 00H
	DB	'p', 00H, 'h', 00H, ',', 00H, ' ', 00H, '%', 00H, 'p', 00H, 'h'
	DB	00H, 00H, 00H
$SG357053 DB	'%', 00H, 's', 00H, '%', 00H, 's', 00H, ')', 00H, 00H, 00H
$SG357054 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '%', 00H, '-', 00H
	DB	'1', 00H, '0', 00H, '2', 00H, 's', 00H, ' ', 00H, '-', 00H, '-'
	DB	00H, ' ', 00H, '%', 00H, 's', 00H, 00H, 00H
$SG200466 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'E', 00H, 'x', 00H, 'c', 00H, 'e', 00H, 'p'
	DB	00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H
$SG357055 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '@', 00H, ']', 00H, ' ', 00H, ' ', 00H, 'R', 00H
	DB	'e', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'n', 00H, ':', 00H, ' '
	DB	00H, '%', 00H, 's', 00H, ' ', 00H, ' ', 00H, '-', 00H, ' ', 00H
	DB	' ', 00H, '<', 00H, ' ', 00H, 'C', 00H, 'r', 00H, 'e', 00H, 'a'
	DB	00H, 't', 00H, 'e', 00H, 'S', 00H, 'w', 00H, 'a', 00H, 'p', 00H
	DB	'C', 00H, 'h', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'F', 00H, 'o'
	DB	00H, 'r', 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'o', 00H
	DB	's', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, '_'
	DB	00H, 'O', 00H, 'r', 00H, 'i', 00H, 'g', 00H, 'i', 00H, 'n', 00H
	DB	'a', 00H, 'l', 00H, ' ', 00H, '(', 00H, ' ', 00H, 'T', 00H, 'h'
	DB	00H, 'i', 00H, 's', 00H, ',', 00H, ' ', 00H, 'p', 00H, 'D', 00H
	DB	'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, ',', 00H, ' '
	DB	00H, '&', 00H, 'n', 00H, 'e', 00H, 'w', 00H, '_', 00H, 'd', 00H
	DB	'e', 00H, 's', 00H, 'c', 00H, '1', 00H, ',', 00H, ' ', 00H, 'p'
	DB	00H, 'R', 00H, 'e', 00H, 's', 00H, 't', 00H, 'r', 00H, 'i', 00H
	DB	'c', 00H, 't', 00H, 'T', 00H, 'o', 00H, 'O', 00H, 'u', 00H, 't'
	DB	00H, 'p', 00H, 'u', 00H, 't', 00H, ',', 00H, ' ', 00H, 'p', 00H
	DB	'p', 00H, 'S', 00H, 'w', 00H, 'a', 00H, 'p', 00H, 'C', 00H, 'h'
	DB	00H, 'a', 00H, 'i', 00H, 'n', 00H, ' ', 00H, ')', 00H, ' ', 00H
	DB	'>', 00H, 00H, 00H
$SG352986 DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	'I', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'F', 00H, 'a'
	DB	00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H
	ORG $+2
$SG352989 DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'I', 00H
	DB	'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'F', 00H, 'a', 00H, 'c'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, 'y', 00H, '1', 00H, 00H, 00H
	ORG $+2
$SG352992 DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'I', 00H
	DB	'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'F', 00H, 'a', 00H, 'c'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, 'y', 00H, '2', 00H, 00H, 00H
	ORG $+2
$SG352995 DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'I', 00H
	DB	'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'F', 00H, 'a', 00H, 'c'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, 'y', 00H, '3', 00H, 00H, 00H
	ORG $+2
$SG200419 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'a', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG352998 DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'I', 00H
	DB	'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'F', 00H, 'a', 00H, 'c'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, 'y', 00H, '4', 00H, 00H, 00H
	ORG $+2
$SG353001 DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'I', 00H
	DB	'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'F', 00H, 'a', 00H, 'c'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, 'y', 00H, '5', 00H, 00H, 00H
	ORG $+2
$SG355113 DB	'S', 00H, 'u', 00H, 'c', 00H, 'c', 00H, 'e', 00H, 's', 00H
	DB	's', 00H, 00H, 00H
$SG355114 DB	'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG357107 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '!', 00H, '!', 00H, '!', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, 'A', 00H, 'd', 00H, 'a', 00H, 'p'
	DB	00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'O', 00H, 'v', 00H
	DB	'e', 00H, 'r', 00H, 'r', 00H, 'i', 00H, 'd', 00H, 'e', 00H, ':'
	DB	00H, ' ', 00H, '(', 00H, 'U', 00H, 's', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, ' ', 00H, '''', 00H, '%', 00H, 's', 00H, '''', 00H, ' '
	DB	00H, 'i', 00H, 'n', 00H, 's', 00H, 't', 00H, 'e', 00H, 'a', 00H
	DB	'd', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, '''', 00H, '%'
	DB	00H, 's', 00H, '''', 00H, ')', 00H, ' ', 00H, '!', 00H, '!', 00H
	DB	'!', 00H, 00H, 00H
	ORG $+2
$SG356147 DB	'G', 00H, 'e', 00H, 't', 00H, 'D', 00H, 'i', 00H, 's', 00H
	DB	'p', 00H, 'l', 00H, 'a', 00H, 'y', 00H, 'M', 00H, 'o', 00H, 'd'
	DB	00H, 'e', 00H, 'L', 00H, 'i', 00H, 's', 00H, 't', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, 00H, 00H
$SG356149 DB	'%', 00H, 's', 00H, ':', 00H, ':', 00H, '%', 00H, 's', 00H
	DB	' ', 00H, '(', 00H, 00H, 00H
	ORG $+2
$SG357108 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '!', 00H, '!', 00H, '!', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, 'A', 00H, 'd', 00H, 'a', 00H, 'p'
	DB	00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'O', 00H, 'v', 00H
	DB	'e', 00H, 'r', 00H, 'r', 00H, 'i', 00H, 'd', 00H, 'e', 00H, ':'
	DB	00H, ' ', 00H, '(', 00H, 'T', 00H, 'r', 00H, 'i', 00H, 'e', 00H
	DB	'd', 00H, ' ', 00H, '''', 00H, '%', 00H, 's', 00H, '''', 00H, ' '
	DB	00H, 'i', 00H, 'n', 00H, 's', 00H, 't', 00H, 'e', 00H, 'a', 00H
	DB	'd', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, '''', 00H, '%'
	DB	00H, 's', 00H, '''', 00H, ')', 00H, ' ', 00H, '!', 00H, '!', 00H
	DB	'!', 00H, 00H, 00H
	ORG $+2
$SG356151 DB	'%', 00H, 's', 00H, '%', 00H, 's', 00H, ')', 00H, 00H, 00H
$SG357109 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '!', 00H, '!', 00H, '!', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, 'A', 00H, 'd', 00H, 'a', 00H, 'p'
	DB	00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'O', 00H, 'v', 00H
	DB	'e', 00H, 'r', 00H, 'r', 00H, 'i', 00H, 'd', 00H, 'e', 00H, ' '
	DB	00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	',', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 't', 00H, 'u', 00H, 'r'
	DB	00H, 'n', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, '''', 00H
	DB	'%', 00H, 's', 00H, '''', 00H, ' ', 00H, '!', 00H, '!', 00H, '!'
	DB	00H, 00H, 00H
$SG356152 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '%', 00H, '-', 00H
	DB	'1', 00H, '0', 00H, '2', 00H, 's', 00H, ' ', 00H, '-', 00H, '-'
	DB	00H, ' ', 00H, '%', 00H, 's', 00H, 00H, 00H
$SG357117 DB	' ', 00H, '<', 00H, '>', 00H, ' ', 00H, 'G', 00H, 'e', 00H
	DB	't', 00H, 'D', 00H, 'e', 00H, 's', 00H, 'c', 00H, '2', 00H, '_'
	DB	00H, 'O', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'i', 00H
	DB	'd', 00H, 'e', 00H, ':', 00H, ' ', 00H, 'L', 00H, 'o', 00H, 'o'
	DB	00H, 'k', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'f', 00H
	DB	'o', 00H, 'r', 00H, ' ', 00H, 'm', 00H, 'a', 00H, 't', 00H, 'c'
	DB	00H, 'h', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'N', 00H
	DB	'V', 00H, 'A', 00H, 'P', 00H, 'I', 00H, ' ', 00H, 'G', 00H, 'P'
	DB	00H, 'U', 00H, ' ', 00H, 'f', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'%', 00H, 's', 00H, '.', 00H, '.', 00H, '.', 00H, ':', 00H, ' '
	DB	00H, 00H, 00H
$SG357120 DB	'S', 00H, 'u', 00H, 'c', 00H, 'c', 00H, 'e', 00H, 's', 00H
	DB	's', 00H, '!', 00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ')'
	DB	00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG357121 DB	'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'u', 00H, 'r', 00H
	DB	'e', 00H, '!', 00H, ' ', 00H, '(', 00H, 'N', 00H, 'o', 00H, ' '
	DB	00H, 'M', 00H, 'a', 00H, 't', 00H, 'c', 00H, 'h', 00H, ' ', 00H
	DB	'F', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 'd', 00H, ')', 00H, 0aH
	DB	00H, 00H, 00H
	ORG $+2
$SG200513 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'T', 00H, 'i', 00H, 'm', 00H, 'e', 00H, 00H
	DB	00H
	ORG $+2
$SG357129 DB	' ', 00H, '<', 00H, '>', 00H, ' ', 00H, 'G', 00H, 'e', 00H
	DB	't', 00H, 'D', 00H, 'e', 00H, 's', 00H, 'c', 00H, '1', 00H, '_'
	DB	00H, 'O', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'i', 00H
	DB	'd', 00H, 'e', 00H, ':', 00H, ' ', 00H, 'L', 00H, 'o', 00H, 'o'
	DB	00H, 'k', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'f', 00H
	DB	'o', 00H, 'r', 00H, ' ', 00H, 'm', 00H, 'a', 00H, 't', 00H, 'c'
	DB	00H, 'h', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'N', 00H
	DB	'V', 00H, 'A', 00H, 'P', 00H, 'I', 00H, ' ', 00H, 'G', 00H, 'P'
	DB	00H, 'U', 00H, ' ', 00H, 'f', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'%', 00H, 's', 00H, '.', 00H, '.', 00H, '.', 00H, ':', 00H, ' '
	DB	00H, 00H, 00H
$SG357132 DB	'S', 00H, 'u', 00H, 'c', 00H, 'c', 00H, 'e', 00H, 's', 00H
	DB	's', 00H, '!', 00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ')'
	DB	00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG357133 DB	'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'u', 00H, 'r', 00H
	DB	'e', 00H, '!', 00H, ' ', 00H, '(', 00H, 'N', 00H, 'o', 00H, ' '
	DB	00H, 'M', 00H, 'a', 00H, 't', 00H, 'c', 00H, 'h', 00H, ' ', 00H
	DB	'F', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 'd', 00H, ')', 00H, 0aH
	DB	00H, 00H, 00H
	ORG $+2
$SG353092 DB	'I', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'A', 00H
	DB	'd', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'e', 00H, 'r', 00H, 00H
	DB	00H
	ORG $+2
$SG355115 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '*', 00H, '*', 00H, '*', 00H, ' ', 00H, 'I', 00H, 'D', 00H
	DB	'X', 00H, 'G', 00H, 'I', 00H, 'S', 00H, 'w', 00H, 'a', 00H, 'p'
	DB	00H, 'C', 00H, 'h', 00H, 'a', 00H, 'i', 00H, 'n', 00H, ':', 00H
	DB	':', 00H, 'P', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'e', 00H, 'n'
	DB	00H, 't', 00H, ' ', 00H, '(', 00H, '.', 00H, '.', 00H, '.', 00H
	DB	')', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 't', 00H, 'u', 00H, 'r'
	DB	00H, 'n', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'n', 00H, 'o', 00H
	DB	'n', 00H, '-', 00H, 'S', 00H, '_', 00H, 'O', 00H, 'K', 00H, ' '
	DB	00H, '(', 00H, '%', 00H, 's', 00H, ' ', 00H, ':', 00H, ':', 00H
	DB	' ', 00H, '%', 00H, 's', 00H, ')', 00H, 00H, 00H
$SG355118 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '(', 00H, '*', 00H, ')', 00H, ' ', 00H, '>', 00H, '>', 00H
	DB	' ', 00H, 'R', 00H, 'e', 00H, 'a', 00H, 's', 00H, 'o', 00H, 'n'
	DB	00H, ' ', 00H, 'F', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'R', 00H
	DB	'e', 00H, 'm', 00H, 'o', 00H, 'v', 00H, 'a', 00H, 'l', 00H, ':'
	DB	00H, ' ', 00H, '%', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG353070 DB	'{', 00H, 'I', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'd', 00H, '-', 00H, 'F', 00H, 'a', 00H, 'c', 00H, 't'
	DB	00H, 'o', 00H, 'r', 00H, 'y', 00H, '-', 00H, 'U', 00H, 'U', 00H
	DB	'I', 00H, 'D', 00H, '}', 00H, 00H, 00H
	ORG $+2
$SG356148 DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, 'I', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'O'
	DB	00H, 'u', 00H, 't', 00H, 'p', 00H, 'u', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG356150 DB	'%', 00H, 'p', 00H, 'h', 00H, ',', 00H, ' ', 00H, '%', 00H
	DB	'i', 00H, ',', 00H, ' ', 00H, '%', 00H, '0', 00H, '2', 00H, 'x'
	DB	00H, ',', 00H, ' ', 00H, 'N', 00H, 'u', 00H, 'm', 00H, 'M', 00H
	DB	'o', 00H, 'd', 00H, 'e', 00H, 's', 00H, '=', 00H, '%', 00H, 'l'
	DB	00H, 'u', 00H, ',', 00H, ' ', 00H, '%', 00H, 'p', 00H, 'h', 00H
	DB	')', 00H, 00H, 00H
$SG357190 DB	'F', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'u', 00H
	DB	't', 00H, '4', 00H, '.', 00H, 'e', 00H, 'x', 00H, 'e', 00H, 00H
	DB	00H
	ORG $+2
$SG357181 DB	' ', 00H, '<', 00H, '>', 00H, ' ', 00H, 'G', 00H, 'e', 00H
	DB	't', 00H, 'D', 00H, 'e', 00H, 's', 00H, 'c', 00H, '_', 00H, 'O'
	DB	00H, 'v', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'i', 00H, 'd', 00H
	DB	'e', 00H, ':', 00H, ' ', 00H, 'L', 00H, 'o', 00H, 'o', 00H, 'k'
	DB	00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'f', 00H, 'o', 00H
	DB	'r', 00H, ' ', 00H, 'm', 00H, 'a', 00H, 't', 00H, 'c', 00H, 'h'
	DB	00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'N', 00H, 'V', 00H
	DB	'A', 00H, 'P', 00H, 'I', 00H, ' ', 00H, 'G', 00H, 'P', 00H, 'U'
	DB	00H, ' ', 00H, 'f', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '%', 00H
	DB	's', 00H, '.', 00H, '.', 00H, '.', 00H, ':', 00H, ' ', 00H, 00H
	DB	00H
	ORG $+2
$SG357184 DB	'S', 00H, 'u', 00H, 'c', 00H, 'c', 00H, 'e', 00H, 's', 00H
	DB	's', 00H, '!', 00H, ' ', 00H, '(', 00H, '%', 00H, 's', 00H, ')'
	DB	00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG357185 DB	'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'u', 00H, 'r', 00H
	DB	'e', 00H, '!', 00H, ' ', 00H, '(', 00H, 'N', 00H, 'o', 00H, ' '
	DB	00H, 'M', 00H, 'a', 00H, 't', 00H, 'c', 00H, 'h', 00H, ' ', 00H
	DB	'F', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 'd', 00H, ')', 00H, 0aH
	DB	00H, 00H, 00H
	ORG $+2
$SG357191 DB	'F', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'u', 00H
	DB	't', 00H, '4', 00H, '.', 00H, 'e', 00H, 'x', 00H, 'e', 00H, 00H
	DB	00H
	ORG $+2
$SG357187 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, 'D', 00H, 'e', 00H, 'd', 00H, 'i', 00H, 'c', 00H, 'a', 00H
	DB	't', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'V', 00H, 'i', 00H, 'd'
	DB	00H, 'e', 00H, 'o', 00H, ':', 00H, ' ', 00H, '%', 00H, 'z', 00H
	DB	'u', 00H, ' ', 00H, 'M', 00H, 'i', 00H, 'B', 00H, ',', 00H, ' '
	DB	00H, 'D', 00H, 'e', 00H, 'd', 00H, 'i', 00H, 'c', 00H, 'a', 00H
	DB	't', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'S', 00H, 'y', 00H, 's'
	DB	00H, 't', 00H, 'e', 00H, 'm', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	'z', 00H, 'u', 00H, ' ', 00H, 'M', 00H, 'i', 00H, 'B', 00H, ','
	DB	00H, ' ', 00H, 'S', 00H, 'h', 00H, 'a', 00H, 'r', 00H, 'e', 00H
	DB	'd', 00H, ' ', 00H, 'S', 00H, 'y', 00H, 's', 00H, 't', 00H, 'e'
	DB	00H, 'm', 00H, ':', 00H, ' ', 00H, '%', 00H, 'z', 00H, 'u', 00H
	DB	' ', 00H, 'M', 00H, 'i', 00H, 'B', 00H, 00H, 00H
	ORG $+2
$SG353095 DB	'I', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'A', 00H
	DB	'd', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'e', 00H, 'r', 00H, '1'
	DB	00H, 00H, 00H
$SG356166 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, '>', 00H
	DB	'>', 00H, ' ', 00H, '%', 00H, 'l', 00H, 'u', 00H, ' ', 00H, 'm'
	DB	00H, 'o', 00H, 'd', 00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H
	DB	'%', 00H, 'l', 00H, 'i', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'm'
	DB	00H, 'o', 00H, 'v', 00H, 'e', 00H, 'd', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG353098 DB	'I', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'A', 00H
	DB	'd', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'e', 00H, 'r', 00H, '2'
	DB	00H, 00H, 00H
$SG353101 DB	'I', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'A', 00H
	DB	'd', 00H, 'a', 00H, 'p', 00H, 't', 00H, 'e', 00H, 'r', 00H, '3'
	DB	00H, 00H, 00H
$SG356196 DB	'%', 00H, 's', 00H, ':', 00H, ':', 00H, '%', 00H, 's', 00H
	DB	' ', 00H, '(', 00H, 00H, 00H
	ORG $+2
$SG356194 DB	'F', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'C', 00H, 'l', 00H
	DB	'o', 00H, 's', 00H, 'e', 00H, 's', 00H, 't', 00H, 'M', 00H, 'a'
	DB	00H, 't', 00H, 'c', 00H, 'h', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	'M', 00H, 'o', 00H, 'd', 00H, 'e', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	00H, 00H
	ORG $+2
$SG356195 DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, 'I', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'O'
	DB	00H, 'u', 00H, 't', 00H, 'p', 00H, 'u', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG356197 DB	'%', 00H, 'l', 00H, 'u', 00H, ',', 00H, ' ', 00H, '%', 00H
	DB	'l', 00H, 'u', 00H, ',', 00H, ' ', 00H, '%', 00H, 'l', 00H, 'u'
	DB	00H, 00H, 00H
$SG356198 DB	'%', 00H, 's', 00H, '%', 00H, 's', 00H, ')', 00H, 00H, 00H
$SG356199 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '%', 00H, '-', 00H
	DB	'1', 00H, '0', 00H, '2', 00H, 's', 00H, ' ', 00H, '-', 00H, '-'
	DB	00H, ' ', 00H, '%', 00H, 's', 00H, 00H, 00H
$SG356201 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, '>', 00H, '>', 00H, ' ', 00H, 'R', 00H, 'e', 00H
	DB	'f', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'h', 00H, ' ', 00H, 'O'
	DB	00H, 'v', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'i', 00H, 'd', 00H
	DB	'e', 00H, ' ', 00H, '(', 00H, 'R', 00H, 'e', 00H, 'q', 00H, 'u'
	DB	00H, 'e', 00H, 's', 00H, 't', 00H, 'e', 00H, 'd', 00H, ':', 00H
	DB	' ', 00H, '%', 00H, 'f', 00H, ',', 00H, ' ', 00H, 'U', 00H, 's'
	DB	00H, 'i', 00H, 'n', 00H, 'g', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	'l', 00H, 'i', 00H, ')', 00H, 00H, 00H
$SG200560 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'C', 00H, 'a', 00H, 'c', 00H, 'h', 00H, 'e'
	DB	00H, 00H, 00H
$SG356203 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, '>', 00H, '>', 00H, ' ', 00H, 'S', 00H, 'c', 00H
	DB	'a', 00H, 'l', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'O'
	DB	00H, 'v', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'i', 00H, 'd', 00H
	DB	'e', 00H, ' ', 00H, '(', 00H, 'R', 00H, 'e', 00H, 'q', 00H, 'u'
	DB	00H, 'e', 00H, 's', 00H, 't', 00H, 'e', 00H, 'd', 00H, ':', 00H
	DB	' ', 00H, '%', 00H, 's', 00H, ',', 00H, ' ', 00H, 'U', 00H, 's'
	DB	00H, 'i', 00H, 'n', 00H, 'g', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	's', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG353137 DB	'{', 00H, 'I', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'd', 00H, '-', 00H, 'A', 00H, 'd', 00H, 'a', 00H, 'p'
	DB	00H, 't', 00H, 'e', 00H, 'r', 00H, '-', 00H, 'U', 00H, 'U', 00H
	DB	'I', 00H, 'D', 00H, '}', 00H, 00H, 00H
	ORG $+2
$SG352119 DB	'C', 00H, 'E', 00H, 'G', 00H, 'U', 00H, 'I', 00H, '.', 00H
	DB	'l', 00H, 'o', 00H, 'g', 00H, 00H, 00H
$SG352120 DB	'logs\CEGUI.log', 00H
	ORG $+1
$SG356217 DB	'W', 00H, 'a', 00H, 'i', 00H, 't', 00H, 'F', 00H, 'o', 00H
	DB	'r', 00H, 'V', 00H, 'B', 00H, 'l', 00H, 'a', 00H, 'n', 00H, 'k'
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, 00H, 00H
	ORG $+2
$SG352121 DB	'l', 00H, 'o', 00H, 'g', 00H, 's', 00H, '\', 00H, 'C', 00H
	DB	'E', 00H, 'G', 00H, 'U', 00H, 'I', 00H, '.', 00H, 'l', 00H, 'o'
	DB	00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG356218 DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, 'I', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, 'O'
	DB	00H, 'u', 00H, 't', 00H, 'p', 00H, 'u', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG352122 DB	'C', 00H, 'E', 00H, 'G', 00H, 'U', 00H, 'I', 00H, '.', 00H
	DB	'l', 00H, 'o', 00H, 'g', 00H, 00H, 00H
$SG356219 DB	'%', 00H, 's', 00H, ':', 00H, ':', 00H, '%', 00H, 's', 00H
	DB	' ', 00H, '(', 00H, 00H, 00H
	ORG $+2
$SG352123 DB	'[Special K] ---- Log File Moved ----', 00H
	ORG $+3
$SG356220 DB	'v', 00H, 'o', 00H, 'i', 00H, 'd', 00H, 00H, 00H
	ORG $+2
$SG356221 DB	'%', 00H, 's', 00H, '%', 00H, 's', 00H, ')', 00H, 00H, 00H
$SG352125 DB	'C', 00H, 'E', 00H, 'G', 00H, 'U', 00H, 'I', 00H, '.', 00H
	DB	'l', 00H, 'o', 00H, 'g', 00H, 00H, 00H
$SG356222 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '%', 00H, '-', 00H
	DB	'1', 00H, '0', 00H, '2', 00H, 's', 00H, ' ', 00H, '-', 00H, '-'
	DB	00H, ' ', 00H, '%', 00H, 's', 00H, 00H, 00H
$SG356249 DB	'S', 00H, 'e', 00H, 't', 00H, 'F', 00H, 'u', 00H, 'l', 00H
	DB	'l', 00H, 's', 00H, 'c', 00H, 'r', 00H, 'e', 00H, 'e', 00H, 'n'
	DB	00H, 'S', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, 00H, 00H
$SG356250 DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'I', 00H, 'D', 00H
	DB	'X', 00H, 'G', 00H, 'I', 00H, 'S', 00H, 'w', 00H, 'a', 00H, 'p'
	DB	00H, 'C', 00H, 'h', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG356251 DB	'%', 00H, 's', 00H, ':', 00H, ':', 00H, '%', 00H, 's', 00H
	DB	' ', 00H, '(', 00H, 00H, 00H
	ORG $+2
$SG356252 DB	'{', 00H, ' ', 00H, 'F', 00H, 'u', 00H, 'l', 00H, 'l', 00H
	DB	's', 00H, 'c', 00H, 'r', 00H, 'e', 00H, 'e', 00H, 'n', 00H, ' '
	DB	00H, '}', 00H, 00H, 00H
	ORG $+2
$SG356253 DB	'{', 00H, ' ', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	'o', 00H, 'w', 00H, 'e', 00H, 'd', 00H, ' ', 00H, '}', 00H, 00H
	DB	00H
	ORG $+2
$SG356254 DB	'%', 00H, 's', 00H, ',', 00H, ' ', 00H, '%', 00H, 'p', 00H
	DB	'h', 00H, 00H, 00H
$SG356255 DB	'%', 00H, 's', 00H, '%', 00H, 's', 00H, ')', 00H, 00H, 00H
$SG200607 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'S', 00H, 't', 00H, 'e', 00H, 'n', 00H, 'c'
	DB	00H, 'i', 00H, 'l', 00H, 00H, 00H
$SG356256 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '%', 00H, '-', 00H
	DB	'1', 00H, '0', 00H, '2', 00H, 's', 00H, ' ', 00H, '-', 00H, '-'
	DB	00H, ' ', 00H, '%', 00H, 's', 00H, 00H, 00H
$SG356258 DB	'[', 00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H
	DB	' ', 00H, '1', 00H, '.', 00H, '2', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, '>', 00H, '>', 00H, ' ', 00H, 'W', 00H, 'a', 00H
	DB	'i', 00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, ' '
	DB	00H, 'S', 00H, 'w', 00H, 'a', 00H, 'p', 00H, 'C', 00H, 'h', 00H
	DB	'a', 00H, 'i', 00H, 'n', 00H, ' ', 00H, 'I', 00H, 'n', 00H, ' '
	DB	00H, 'U', 00H, 's', 00H, 'e', 00H, ',', 00H, ' ', 00H, 'S', 00H
	DB	'k', 00H, 'i', 00H, 'p', 00H, 'p', 00H, 'i', 00H, 'n', 00H, 'g'
	DB	00H, '.', 00H, '.', 00H, '.', 00H, 00H, 00H
$SG356260 DB	'[', 00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H
	DB	' ', 00H, '1', 00H, '.', 00H, '5', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, '>', 00H, '>', 00H, ' ', 00H, 'T', 00H, 'e', 00H
	DB	'a', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'O'
	DB	00H, 'v', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'i', 00H, 'd', 00H
	DB	'e', 00H, ':', 00H, ' ', 00H, ' ', 00H, 'E', 00H, 'n', 00H, 'a'
	DB	00H, 'b', 00H, 'l', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG356263 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, '>', 00H, '>', 00H, ' ', 00H, 'D', 00H, 'i', 00H
	DB	's', 00H, 'p', 00H, 'l', 00H, 'a', 00H, 'y', 00H, ' ', 00H, 'O'
	DB	00H, 'v', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'i', 00H, 'd', 00H
	DB	'e', 00H, ' ', 00H, '(', 00H, 'R', 00H, 'e', 00H, 'q', 00H, 'u'
	DB	00H, 'e', 00H, 's', 00H, 't', 00H, 'e', 00H, 'd', 00H, ':', 00H
	DB	' ', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w'
	DB	00H, 'e', 00H, 'd', 00H, ',', 00H, ' ', 00H, 'U', 00H, 's', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, ':', 00H, ' ', 00H, 'F', 00H, 'u'
	DB	00H, 'l', 00H, 'l', 00H, 's', 00H, 'c', 00H, 'r', 00H, 'e', 00H
	DB	'e', 00H, 'n', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG356265 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, '>', 00H, '>', 00H, ' ', 00H, 'D', 00H, 'i', 00H
	DB	's', 00H, 'p', 00H, 'l', 00H, 'a', 00H, 'y', 00H, ' ', 00H, 'O'
	DB	00H, 'v', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'i', 00H, 'd', 00H
	DB	'e', 00H, ' ', 00H, '(', 00H, 'R', 00H, 'e', 00H, 'q', 00H, 'u'
	DB	00H, 'e', 00H, 's', 00H, 't', 00H, 'e', 00H, 'd', 00H, ':', 00H
	DB	' ', 00H, 'F', 00H, 'u', 00H, 'l', 00H, 'l', 00H, 's', 00H, 'c'
	DB	00H, 'r', 00H, 'e', 00H, 'e', 00H, 'n', 00H, ',', 00H, ' ', 00H
	DB	'U', 00H, 's', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ':', 00H, ' '
	DB	00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H
	DB	'e', 00H, 'd', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG356268 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, '>', 00H, '>', 00H, ' ', 00H, 'D', 00H, 'i', 00H
	DB	's', 00H, 'p', 00H, 'l', 00H, 'a', 00H, 'y', 00H, ' ', 00H, 'O'
	DB	00H, 'v', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'i', 00H, 'd', 00H
	DB	'e', 00H, ' ', 00H, 'U', 00H, 's', 00H, 'e', 00H, 'r', 00H, ' '
	DB	00H, 'I', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'a', 00H
	DB	't', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'F', 00H, 'u', 00H, 'l'
	DB	00H, 'l', 00H, 'l', 00H, 's', 00H, 'c', 00H, 'r', 00H, 'e', 00H
	DB	'e', 00H, 'n', 00H, ' ', 00H, 'S', 00H, 'w', 00H, 'i', 00H, 't'
	DB	00H, 'c', 00H, 'h', 00H, 00H, 00H
$SG356270 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, '>', 00H, '>', 00H, ' ', 00H, 'D', 00H, 'i', 00H
	DB	's', 00H, 'p', 00H, 'l', 00H, 'a', 00H, 'y', 00H, ' ', 00H, 'O'
	DB	00H, 'v', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'i', 00H, 'd', 00H
	DB	'e', 00H, ' ', 00H, 'U', 00H, 's', 00H, 'e', 00H, 'r', 00H, ' '
	DB	00H, 'I', 00H, 'n', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'a', 00H
	DB	't', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'W', 00H, 'i', 00H, 'n'
	DB	00H, 'd', 00H, 'o', 00H, 'w', 00H, 'e', 00H, 'd', 00H, ' ', 00H
	DB	'S', 00H, 'w', 00H, 'i', 00H, 't', 00H, 'c', 00H, 'h', 00H, 00H
	DB	00H
	ORG $+2
$SG356326 DB	'%', 00H, 's', 00H, ':', 00H, ':', 00H, '%', 00H, 's', 00H
	DB	' ', 00H, '(', 00H, 00H, 00H
	ORG $+2
$SG356271 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '@', 00H, ']', 00H, ' ', 00H, ' ', 00H, 'R', 00H
	DB	'e', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'n', 00H, ':', 00H, ' '
	DB	00H, '%', 00H, 's', 00H, ' ', 00H, ' ', 00H, '-', 00H, ' ', 00H
	DB	' ', 00H, '<', 00H, ' ', 00H, 'S', 00H, 'e', 00H, 't', 00H, 'F'
	DB	00H, 'u', 00H, 'l', 00H, 'l', 00H, 's', 00H, 'c', 00H, 'r', 00H
	DB	'e', 00H, 'e', 00H, 'n', 00H, 'S', 00H, 't', 00H, 'a', 00H, 't'
	DB	00H, 'e', 00H, '_', 00H, 'O', 00H, 'r', 00H, 'i', 00H, 'g', 00H
	DB	'i', 00H, 'n', 00H, 'a', 00H, 'l', 00H, ' ', 00H, '(', 00H, 'T'
	DB	00H, 'h', 00H, 'i', 00H, 's', 00H, ',', 00H, ' ', 00H, 'F', 00H
	DB	'u', 00H, 'l', 00H, 'l', 00H, 's', 00H, 'c', 00H, 'r', 00H, 'e'
	DB	00H, 'e', 00H, 'n', 00H, ',', 00H, ' ', 00H, 'p', 00H, 'T', 00H
	DB	'a', 00H, 'r', 00H, 'g', 00H, 'e', 00H, 't', 00H, ')', 00H, ' '
	DB	00H, '>', 00H, 00H, 00H
	ORG $+2
$SG200654 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'S', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG356324 DB	'R', 00H, 'e', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H
	DB	'B', 00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, 's'
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, 00H, 00H
	ORG $+2
$SG356325 DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'I', 00H, 'D', 00H
	DB	'X', 00H, 'G', 00H, 'I', 00H, 'S', 00H, 'w', 00H, 'a', 00H, 'p'
	DB	00H, 'C', 00H, 'h', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG356327 DB	'%', 00H, 'l', 00H, 'u', 00H, ',', 00H, '%', 00H, 'l', 00H
	DB	'u', 00H, ',', 00H, '%', 00H, 'l', 00H, 'u', 00H, ',', 00H, 'f'
	DB	00H, 'm', 00H, 't', 00H, '=', 00H, '%', 00H, 'l', 00H, 'u', 00H
	DB	',', 00H, '0', 00H, 'x', 00H, '%', 00H, '0', 00H, '8', 00H, 'X'
	DB	00H, 00H, 00H
	ORG $+2
$SG356328 DB	'%', 00H, 's', 00H, '%', 00H, 's', 00H, ')', 00H, 00H, 00H
$SG356329 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '%', 00H, '-', 00H
	DB	'1', 00H, '0', 00H, '2', 00H, 's', 00H, ' ', 00H, '-', 00H, '-'
	DB	00H, ' ', 00H, '%', 00H, 's', 00H, 00H, 00H
$SG352239 DB	'C', 00H, 'E', 00H, 'G', 00H, 'U', 00H, 'I', 00H, '_', 00H
	DB	'P', 00H, 'A', 00H, 'R', 00H, 'E', 00H, 'N', 00H, 'T', 00H, '_'
	DB	00H, 'D', 00H, 'I', 00H, 'R', 00H, 00H, 00H
	ORG $+2
$SG356332 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, '>', 00H, '>', 00H, ' ', 00H, 'B', 00H, 'u', 00H
	DB	'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'C', 00H, 'o'
	DB	00H, 'u', 00H, 'n', 00H, 't', 00H, ' ', 00H, 'O', 00H, 'v', 00H
	DB	'e', 00H, 'r', 00H, 'r', 00H, 'i', 00H, 'd', 00H, 'e', 00H, ':'
	DB	00H, ' ', 00H, '%', 00H, 'l', 00H, 'u', 00H, ' ', 00H, 'b', 00H
	DB	'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, 's', 00H, 00H
	DB	00H
$SG356334 DB	'[', 00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H
	DB	' ', 00H, '1', 00H, '.', 00H, '5', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, '>', 00H, '>', 00H, ' ', 00H, 'T', 00H, 'e', 00H
	DB	'a', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'O'
	DB	00H, 'p', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ':', 00H
	DB	' ', 00H, ' ', 00H, 'E', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l'
	DB	00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG352240 DB	'%ws', 00H
$SG352241 DB	'CEGUI/datafiles', 00H
$SG352242 DB	'/schemes/', 00H
	ORG $+2
$SG352243 DB	'schemes', 00H
$SG352244 DB	'/imagesets/', 00H
$SG352245 DB	'imagesets', 00H
	ORG $+2
$SG352246 DB	'/fonts/', 00H
$SG352248 DB	'/layouts/', 00H
	ORG $+2
$SG356343 DB	'[', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H
	DB	'G', 00H, 'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '@', 00H, ']', 00H, ' ', 00H, ' ', 00H, 'R', 00H
	DB	'e', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'n', 00H, ':', 00H, ' '
	DB	00H, '%', 00H, 's', 00H, ' ', 00H, ' ', 00H, '-', 00H, ' ', 00H
	DB	' ', 00H, '<', 00H, ' ', 00H, 'R', 00H, 'e', 00H, 's', 00H, 'i'
	DB	00H, 'z', 00H, 'e', 00H, 'B', 00H, 'u', 00H, 'f', 00H, 'f', 00H
	DB	'e', 00H, 'r', 00H, 's', 00H, '_', 00H, 'O', 00H, 'r', 00H, 'i'
	DB	00H, 'g', 00H, 'i', 00H, 'n', 00H, 'a', 00H, 'l', 00H, ' ', 00H
	DB	'(', 00H, ' ', 00H, 'T', 00H, 'h', 00H, 'i', 00H, 's', 00H, ','
	DB	00H, ' ', 00H, 'B', 00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H
	DB	'r', 00H, 'C', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H, ','
	DB	00H, ' ', 00H, 'W', 00H, 'i', 00H, 'd', 00H, 't', 00H, 'h', 00H
	DB	',', 00H, ' ', 00H, 'H', 00H, 'e', 00H, 'i', 00H, 'g', 00H, 'h'
	DB	00H, 't', 00H, ',', 00H, ' ', 00H, 'N', 00H, 'e', 00H, 'w', 00H
	DB	'F', 00H, 'o', 00H, 'r', 00H, 'm', 00H, 'a', 00H, 't', 00H, ','
	DB	00H, ' ', 00H, 'S', 00H, 'w', 00H, 'a', 00H, 'p', 00H, 'C', 00H
	DB	'h', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'F', 00H, 'l', 00H, 'a'
	DB	00H, 'g', 00H, 's', 00H, ' ', 00H, ')', 00H, ' ', 00H, '>', 00H
	DB	00H, 00H
$SG352247 DB	'fonts', 00H
	ORG $+2
$SG352249 DB	'layouts', 00H
$SG352250 DB	'/looknfeel/', 00H
$SG352251 DB	'looknfeels', 00H
	ORG $+1
$SG352252 DB	'/lua_scripts/', 00H
	ORG $+2
$SG352253 DB	'lua_scripts', 00H
$SG200701 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'M', 00H, 'a', 00H, 'p', 00H, 00H, 00H
$SG352254 DB	'/xml_schemas/', 00H
	ORG $+2
$SG352255 DB	'schemas', 00H
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	_IsEqualGUID
PUBLIC	_==
PUBLIC	_ReadAcquire
PUBLIC	_HRESULT_FROM_WIN32
PUBLIC	?_InterlockedIncrement@@YAKPCK@Z		; _InterlockedIncrement
PUBLIC	?_InterlockedExchange@@YAKPCKK@Z		; _InterlockedExchange
PUBLIC	?_InterlockedCompareExchange@@YAKPCKKK@Z	; _InterlockedCompareExchange
PUBLIC	_wmemcmp
PUBLIC	_wmemcpy
PUBLIC	_wmemmove
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	?compare@?$char_traits@_W@std@@SAHQB_W0I@Z	; std::char_traits<wchar_t>::compare
PUBLIC	?length@?$char_traits@_W@std@@SAIQB_W@Z		; std::char_traits<wchar_t>::length
PUBLIC	?copy@?$char_traits@_W@std@@SAPA_WQA_WQB_WI@Z	; std::char_traits<wchar_t>::copy
PUBLIC	?move@?$char_traits@_W@std@@SAPA_WQA_WQB_WI@Z	; std::char_traits<wchar_t>::move
PUBLIC	?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z	; std::char_traits<wchar_t>::assign
PUBLIC	?length@?$char_traits@D@std@@SAIQBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADQADQBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADQADQBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	??0_Container_proxy@std@@QAE@XZ			; std::_Container_proxy::_Container_proxy
PUBLIC	??0_Container_base12@std@@QAE@XZ		; std::_Container_base12::_Container_base12
PUBLIC	??1_Container_base12@std@@QAE@XZ		; std::_Container_base12::~_Container_base12
PUBLIC	?_Orphan_all@_Container_base12@std@@QAEXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	?_InterlockedExchange64_INLINE@@YA_JPC_J_J@Z	; _InterlockedExchange64_INLINE
PUBLIC	?_Store_relaxed_8@std@@YAXPC_K_K@Z		; std::_Store_relaxed_8
PUBLIC	?_Store_release_8@std@@YAXPC_K_K@Z		; std::_Store_release_8
PUBLIC	?_Store_seq_cst_8@std@@YAXPC_K_K@Z		; std::_Store_seq_cst_8
PUBLIC	?_Atomic_store_8@std@@YAXPC_K_KW4memory_order@1@@Z ; std::_Atomic_store_8
PUBLIC	??4_Atomic_ullong@std@@QAE_K_K@Z		; std::_Atomic_ullong::operator=
PUBLIC	??4?$atomic@_K@std@@QAE_K_K@Z			; std::atomic<unsigned __int64>::operator=
PUBLIC	?atomic_store_explicit@std@@YAXPAU_Atomic_ullong@1@_KW4memory_order@1@@Z ; std::atomic_store_explicit
PUBLIC	?atomic_store@std@@YAXPAU_Atomic_ullong@1@_K@Z	; std::atomic_store
PUBLIC	?max@?$numeric_limits@I@std@@SAIXZ		; std::numeric_limits<unsigned int>::max
PUBLIC	?quiet_NaN@?$numeric_limits@M@std@@SAMXZ	; std::numeric_limits<float>::quiet_NaN
PUBLIC	?_Allocate@std@@YAPAXII_N@Z			; std::_Allocate
PUBLIC	?_Deallocate@std@@YAXPAXII@Z			; std::_Deallocate
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
PUBLIC	?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
PUBLIC	??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
PUBLIC	?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
PUBLIC	?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
PUBLIC	?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::capacity
PUBLIC	?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	??0?$allocator@_W@std@@QAE@XZ			; std::allocator<wchar_t>::allocator<wchar_t>
PUBLIC	??0?$allocator@_W@std@@QAE@ABV01@@Z		; std::allocator<wchar_t>::allocator<wchar_t>
PUBLIC	?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z	; std::allocator<wchar_t>::deallocate
PUBLIC	?allocate@?$allocator@_W@std@@QAEPA_WI@Z	; std::allocator<wchar_t>::allocate
PUBLIC	?max_size@?$allocator@_W@std@@QBEIXZ		; std::allocator<wchar_t>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ; std::allocator_traits<std::allocator<wchar_t> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAU01@@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
PUBLIC	??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
PUBLIC	?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEPA_WXZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr
PUBLIC	?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr
PUBLIC	??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
PUBLIC	?_Orphan_all@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Orphan_all
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
PUBLIC	?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize
PUBLIC	?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize
PUBLIC	?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myres
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
PUBLIC	??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>
PUBLIC	??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv_contents_with_alloc_always_equal
PUBLIC	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
PUBLIC	??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
PUBLIC	?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
PUBLIC	?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
PUBLIC	?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
PUBLIC	?_Clamp_suffix_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Clamp_suffix_size
PUBLIC	?_Equal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NQB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Equal
PUBLIC	?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
PUBLIC	?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
PUBLIC	?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
PUBLIC	?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NQB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside
PUBLIC	?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
PUBLIC	?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
PUBLIC	?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Check_offset
PUBLIC	?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
PUBLIC	?lock@SK_Thread_CriticalSection@@QAEXXZ		; SK_Thread_CriticalSection::lock
PUBLIC	?unlock@SK_Thread_CriticalSection@@QAEXXZ	; SK_Thread_CriticalSection::unlock
PUBLIC	??0memory_stats_t@@QAE@XZ			; memory_stats_t::memory_stats_t
PUBLIC	??0mem_info_t@@QAE@XZ				; mem_info_t::mem_info_t
PUBLIC	?Startup@DXGI@SK@@YA_NXZ			; SK::DXGI::Startup
PUBLIC	?Shutdown@DXGI@SK@@YA_NXZ			; SK::DXGI::Shutdown
PUBLIC	?StartBudgetThread@DXGI@SK@@YAJPAPAUIDXGIAdapter@@@Z ; SK::DXGI::StartBudgetThread
PUBLIC	?StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ	; SK::DXGI::StartBudgetThread_NoAdapter
PUBLIC	?ShutdownBudgetThread@DXGI@SK@@YAXXZ		; SK::DXGI::ShutdownBudgetThread
PUBLIC	?BudgetThread@DXGI@SK@@YGKPAX@Z			; SK::DXGI::BudgetThread
PUBLIC	?SK_DXGI_DescribeScalingMode@@YAPB_WW4DXGI_MODE_SCALING@@@Z ; SK_DXGI_DescribeScalingMode
PUBLIC	?SK_DXGI_DescribeScanlineOrder@@YAPB_WW4DXGI_MODE_SCANLINE_ORDER@@@Z ; SK_DXGI_DescribeScanlineOrder
PUBLIC	?SK_DXGI_DescribeSwapEffect@@YAPB_WW4DXGI_SWAP_EFFECT@@@Z ; SK_DXGI_DescribeSwapEffect
PUBLIC	?SK_DXGI_DescribeSwapChainFlags@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4DXGI_SWAP_CHAIN_FLAG@@@Z ; SK_DXGI_DescribeSwapChainFlags
PUBLIC	?SK_DXGI_FeatureLevelsToStr@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPBK@Z ; SK_DXGI_FeatureLevelsToStr
PUBLIC	?SK_DXGI_AdapterOverride@@YGXPAPAUIDXGIAdapter@@PAW4D3D_DRIVER_TYPE@@@Z ; SK_DXGI_AdapterOverride
PUBLIC	?SK_GetDXGIFactoryInterfaceVer@@YAHABU_GUID@@@Z	; SK_GetDXGIFactoryInterfaceVer
PUBLIC	?SK_GetDXGIFactoryInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z ; SK_GetDXGIFactoryInterfaceEx
PUBLIC	?SK_GetDXGIFactoryInterfaceVer@@YAHPAUIUnknown@@@Z ; SK_GetDXGIFactoryInterfaceVer
PUBLIC	?SK_GetDXGIFactoryInterface@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUIUnknown@@@Z ; SK_GetDXGIFactoryInterface
PUBLIC	?SK_GetDXGIAdapterInterfaceVer@@YAHABU_GUID@@@Z	; SK_GetDXGIAdapterInterfaceVer
PUBLIC	?SK_GetDXGIAdapterInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z ; SK_GetDXGIAdapterInterfaceEx
PUBLIC	?SK_GetDXGIAdapterInterfaceVer@@YAHPAUIUnknown@@@Z ; SK_GetDXGIAdapterInterfaceVer
PUBLIC	?SK_GetDXGIAdapterInterface@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUIUnknown@@@Z ; SK_GetDXGIAdapterInterface
PUBLIC	?SK_DXGI_BorderCompensation@@YAXAAI0@Z		; SK_DXGI_BorderCompensation
PUBLIC	?WaitForInitDXGI@@YAXXZ				; WaitForInitDXGI
PUBLIC	??0_com_error@@QAE@JPAUIErrorInfo@@_N@Z		; _com_error::_com_error
PUBLIC	??1_com_error@@UAE@XZ				; _com_error::~_com_error
PUBLIC	?WCode@_com_error@@QBEGXZ			; _com_error::WCode
PUBLIC	?ErrorMessage@_com_error@@QBEPB_WXZ		; _com_error::ErrorMessage
PUBLIC	?HRESULTToWCode@_com_error@@SAGJ@Z		; _com_error::HRESULTToWCode
PUBLIC	??_G_com_error@@UAEPAXI@Z			; _com_error::`scalar deleting destructor'
PUBLIC	??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>
PUBLIC	??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>
PUBLIC	??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>
PUBLIC	??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>
PUBLIC	??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>
PUBLIC	??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>
PUBLIC	??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>
PUBLIC	??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>
PUBLIC	??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>
PUBLIC	??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>
PUBLIC	??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>
PUBLIC	?_AtlRaiseException@ATL@@YAXKK@Z		; ATL::_AtlRaiseException
PUBLIC	?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ; ATL::_AtlInitializeCriticalSectionEx
PUBLIC	??0CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::CComCriticalSection
PUBLIC	??1CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::~CComCriticalSection
PUBLIC	?Init@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Init
PUBLIC	?Term@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Term
PUBLIC	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
PUBLIC	??0?$CComPtrBase@UIUnknown@@@ATL@@IAE@PAUIUnknown@@@Z ; ATL::CComPtrBase<IUnknown>::CComPtrBase<IUnknown>
PUBLIC	??1?$CComPtrBase@UIUnknown@@@ATL@@QAE@XZ	; ATL::CComPtrBase<IUnknown>::~CComPtrBase<IUnknown>
PUBLIC	??I?$CComPtrBase@UIUnknown@@@ATL@@QAEPAPAUIUnknown@@XZ ; ATL::CComPtrBase<IUnknown>::operator&
PUBLIC	??0?$CComPtr@UIUnknown@@@ATL@@QAE@PAUIUnknown@@@Z ; ATL::CComPtr<IUnknown>::CComPtr<IUnknown>
PUBLIC	??1?$CComPtr@UIUnknown@@@ATL@@QAE@XZ		; ATL::CComPtr<IUnknown>::~CComPtr<IUnknown>
PUBLIC	??0_ATL_COM_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70
PUBLIC	??1_ATL_COM_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70
PUBLIC	??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
PUBLIC	??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
PUBLIC	?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
PUBLIC	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
PUBLIC	??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
PUBLIC	??0_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
PUBLIC	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
PUBLIC	?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ; ATL::AtlWinModuleInit
PUBLIC	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm
PUBLIC	??0CAtlComModule@ATL@@QAE@XZ			; ATL::CAtlComModule::CAtlComModule
PUBLIC	??1CAtlComModule@ATL@@QAE@XZ			; ATL::CAtlComModule::~CAtlComModule
PUBLIC	?Term@CAtlComModule@ATL@@QAEXXZ			; ATL::CAtlComModule::Term
PUBLIC	??0CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::CAtlWinModule
PUBLIC	??1CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::~CAtlWinModule
PUBLIC	?Term@CAtlWinModule@ATL@@QAEXXZ			; ATL::CAtlWinModule::Term
PUBLIC	?isZero@<unnamed-type-min>@<unnamed-type-res>@<unnamed-type-dxgi>@<unnamed-type-render>@sk_config_t@@QAE_NXZ ; sk_config_t::<unnamed-type-render>::<unnamed-type-dxgi>::<unnamed-type-res>::<unnamed-type-min>::isZero
PUBLIC	?isZero@<unnamed-type-max>@<unnamed-type-res>@<unnamed-type-dxgi>@<unnamed-type-render>@sk_config_t@@QAE_NXZ ; sk_config_t::<unnamed-type-render>::<unnamed-type-dxgi>::<unnamed-type-res>::<unnamed-type-max>::isZero
PUBLIC	?isZero@<unnamed-type-override>@<unnamed-type-res>@<unnamed-type-window>@sk_config_t@@QAE_NXZ ; sk_config_t::<unnamed-type-window>::<unnamed-type-res>::<unnamed-type-override>::isZero
PUBLIC	??1AutoClose@iSK_Logger@@QAE@XZ			; iSK_Logger::AutoClose::~AutoClose
PUBLIC	??0AutoClose@iSK_Logger@@IAE@PAU1@@Z		; iSK_Logger::AutoClose::AutoClose
PUBLIC	?auto_close@iSK_Logger@@QAE?AVAutoClose@1@XZ	; iSK_Logger::auto_close
PUBLIC	??0SK_ScopedBool@@QAE@PAH@Z			; SK_ScopedBool::SK_ScopedBool
PUBLIC	??1SK_ScopedBool@@QAE@XZ			; SK_ScopedBool::~SK_ScopedBool
PUBLIC	?SK_DXGI_UpdateSwapChain@@YAXPAUIDXGISwapChain@@@Z ; SK_DXGI_UpdateSwapChain
PUBLIC	??0?$AllocatedObject@V?$Size@M@CEGUI@@@CEGUI@@QAE@XZ ; CEGUI::AllocatedObject<CEGUI::Size<float> >::AllocatedObject<CEGUI::Size<float> >
PUBLIC	??0?$Size@M@CEGUI@@QAE@MM@Z			; CEGUI::Size<float>::Size<float>
PUBLIC	??8?$Size@M@CEGUI@@QBE_NABV01@@Z		; CEGUI::Size<float>::operator==
PUBLIC	?ImGui_DX11Shutdown@@YAXXZ			; ImGui_DX11Shutdown
PUBLIC	?ImGui_DX11Startup@@YA_NPAUIDXGISwapChain@@@Z	; ImGui_DX11Startup
PUBLIC	??0?$CComPtrBase@UID3D11Device@@@ATL@@IAE@XZ	; ATL::CComPtrBase<ID3D11Device>::CComPtrBase<ID3D11Device>
PUBLIC	??0?$CComPtrBase@UID3D11Device@@@ATL@@IAE@PAUID3D11Device@@@Z ; ATL::CComPtrBase<ID3D11Device>::CComPtrBase<ID3D11Device>
PUBLIC	??1?$CComPtrBase@UID3D11Device@@@ATL@@QAE@XZ	; ATL::CComPtrBase<ID3D11Device>::~CComPtrBase<ID3D11Device>
PUBLIC	??B?$CComPtrBase@UID3D11Device@@@ATL@@QBEPAUID3D11Device@@XZ ; ATL::CComPtrBase<ID3D11Device>::operator ID3D11Device *
PUBLIC	??I?$CComPtrBase@UID3D11Device@@@ATL@@QAEPAPAUID3D11Device@@XZ ; ATL::CComPtrBase<ID3D11Device>::operator&
PUBLIC	??C?$CComPtrBase@UID3D11Device@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UID3D11Device@@@1@XZ ; ATL::CComPtrBase<ID3D11Device>::operator->
PUBLIC	??9?$CComPtrBase@UID3D11Device@@@ATL@@QBE_NPAUID3D11Device@@@Z ; ATL::CComPtrBase<ID3D11Device>::operator!=
PUBLIC	??8?$CComPtrBase@UID3D11Device@@@ATL@@QBE_NPAUID3D11Device@@@Z ; ATL::CComPtrBase<ID3D11Device>::operator==
PUBLIC	??0?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ	; ATL::CComPtr<ID3D11Device>::CComPtr<ID3D11Device>
PUBLIC	??0?$CComPtr@UID3D11Device@@@ATL@@QAE@PAUID3D11Device@@@Z ; ATL::CComPtr<ID3D11Device>::CComPtr<ID3D11Device>
PUBLIC	??1?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ	; ATL::CComPtr<ID3D11Device>::~CComPtr<ID3D11Device>
PUBLIC	??0?$CComPtrBase@UID3D11DeviceContext@@@ATL@@IAE@XZ ; ATL::CComPtrBase<ID3D11DeviceContext>::CComPtrBase<ID3D11DeviceContext>
PUBLIC	??0?$CComPtrBase@UID3D11DeviceContext@@@ATL@@IAE@PAUID3D11DeviceContext@@@Z ; ATL::CComPtrBase<ID3D11DeviceContext>::CComPtrBase<ID3D11DeviceContext>
PUBLIC	??1?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QAE@XZ ; ATL::CComPtrBase<ID3D11DeviceContext>::~CComPtrBase<ID3D11DeviceContext>
PUBLIC	??B?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QBEPAUID3D11DeviceContext@@XZ ; ATL::CComPtrBase<ID3D11DeviceContext>::operator ID3D11DeviceContext *
PUBLIC	??I?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QAEPAPAUID3D11DeviceContext@@XZ ; ATL::CComPtrBase<ID3D11DeviceContext>::operator&
PUBLIC	??C?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UID3D11DeviceContext@@@1@XZ ; ATL::CComPtrBase<ID3D11DeviceContext>::operator->
PUBLIC	??9?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QBE_NPAUID3D11DeviceContext@@@Z ; ATL::CComPtrBase<ID3D11DeviceContext>::operator!=
PUBLIC	??8?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QBE_NPAUID3D11DeviceContext@@@Z ; ATL::CComPtrBase<ID3D11DeviceContext>::operator==
PUBLIC	??0?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@XZ	; ATL::CComPtr<ID3D11DeviceContext>::CComPtr<ID3D11DeviceContext>
PUBLIC	??0?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@PAUID3D11DeviceContext@@@Z ; ATL::CComPtr<ID3D11DeviceContext>::CComPtr<ID3D11DeviceContext>
PUBLIC	??1?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@XZ	; ATL::CComPtr<ID3D11DeviceContext>::~CComPtr<ID3D11DeviceContext>
PUBLIC	??$IID_PPV_ARGS_Helper@UID3D11Device@@@@YAPAPAXPAPAUID3D11Device@@@Z ; IID_PPV_ARGS_Helper<ID3D11Device>
PUBLIC	?SK_CEGUI_RelocateLog@@YAXXZ			; SK_CEGUI_RelocateLog
PUBLIC	?SK_CEGUI_GetSystem@@YAPAVSystem@CEGUI@@XZ	; SK_CEGUI_GetSystem
PUBLIC	?SK_CEGUI_InitBase@@YAXXZ			; SK_CEGUI_InitBase
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?ResetCEGUI_D3D11@@YAXPAUIDXGISwapChain@@@Z	; ResetCEGUI_D3D11
PUBLIC	??0?$CComQIPtr@UID3D11DeviceContext@@$1?_GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z ; ATL::CComQIPtr<ID3D11DeviceContext,&_GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da>::CComQIPtr<ID3D11DeviceContext,&_GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da>
PUBLIC	??1?$CComQIPtr@UID3D11DeviceContext@@$1?_GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da@@3U__s_GUID@@B@ATL@@QAE@XZ ; ATL::CComQIPtr<ID3D11DeviceContext,&_GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da>::~CComQIPtr<ID3D11DeviceContext,&_GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da>
PUBLIC	??0?$CComPtrBase@UID3D11Texture2D@@@ATL@@IAE@PAUID3D11Texture2D@@@Z ; ATL::CComPtrBase<ID3D11Texture2D>::CComPtrBase<ID3D11Texture2D>
PUBLIC	??1?$CComPtrBase@UID3D11Texture2D@@@ATL@@QAE@XZ	; ATL::CComPtrBase<ID3D11Texture2D>::~CComPtrBase<ID3D11Texture2D>
PUBLIC	??B?$CComPtrBase@UID3D11Texture2D@@@ATL@@QBEPAUID3D11Texture2D@@XZ ; ATL::CComPtrBase<ID3D11Texture2D>::operator ID3D11Texture2D *
PUBLIC	??I?$CComPtrBase@UID3D11Texture2D@@@ATL@@QAEPAPAUID3D11Texture2D@@XZ ; ATL::CComPtrBase<ID3D11Texture2D>::operator&
PUBLIC	??C?$CComPtrBase@UID3D11Texture2D@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UID3D11Texture2D@@@1@XZ ; ATL::CComPtrBase<ID3D11Texture2D>::operator->
PUBLIC	??0?$CComPtr@UID3D11Texture2D@@@ATL@@QAE@PAUID3D11Texture2D@@@Z ; ATL::CComPtr<ID3D11Texture2D>::CComPtr<ID3D11Texture2D>
PUBLIC	??1?$CComPtr@UID3D11Texture2D@@@ATL@@QAE@XZ	; ATL::CComPtr<ID3D11Texture2D>::~CComPtr<ID3D11Texture2D>
PUBLIC	??$IID_PPV_ARGS_Helper@UID3D11Texture2D@@@@YAPAPAXPAPAUID3D11Texture2D@@@Z ; IID_PPV_ARGS_Helper<ID3D11Texture2D>
PUBLIC	?HookDXGI@@YGIPAX@Z				; HookDXGI
PUBLIC	?SK_DXGI_BringRenderWindowToTop_THREAD@@YGKPAX@Z ; SK_DXGI_BringRenderWindowToTop_THREAD
PUBLIC	?SK_DXGI_BringRenderWindowToTop@@YGXXZ		; SK_DXGI_BringRenderWindowToTop
PUBLIC	?SKX_D3D11_EnableFullscreen@@YGX_N@Z		; SKX_D3D11_EnableFullscreen
PUBLIC	?SK_DXGI_HookPresent@@YAXPAUIDXGISwapChain@@_N@Z ; SK_DXGI_HookPresent
PUBLIC	?SK_DXGI_SetPreferredAdapter@@YGXH@Z		; SK_DXGI_SetPreferredAdapter
PUBLIC	??0<unnamed-type-device>@dxgi_caps_t@@QAE@XZ	; dxgi_caps_t::<unnamed-type-device>::<unnamed-type-device>
PUBLIC	??0<unnamed-type-present>@dxgi_caps_t@@QAE@XZ	; dxgi_caps_t::<unnamed-type-present>::<unnamed-type-present>
PUBLIC	??0<unnamed-type-swapchain>@dxgi_caps_t@@QAE@XZ	; dxgi_caps_t::<unnamed-type-swapchain>::<unnamed-type-swapchain>
PUBLIC	??0dxgi_caps_t@@QAE@XZ				; dxgi_caps_t::dxgi_caps_t
PUBLIC	?SK_DXGI_SupportsTearing@@YAHXZ			; SK_DXGI_SupportsTearing
PUBLIC	?SK_DescribeVirtualProtectFlags@@YAPB_WK@Z	; SK_DescribeVirtualProtectFlags
PUBLIC	?SK_DXGI_BeginHooking@@YAXXZ			; SK_DXGI_BeginHooking
PUBLIC	??$QueryInterface@UIDXGIFactory5@@@IUnknown@@QAGJPAPAUIDXGIFactory5@@@Z ; IUnknown::QueryInterface<IDXGIFactory5>
PUBLIC	??$QueryInterface@UIDXGIFactory4@@@IUnknown@@QAGJPAPAUIDXGIFactory4@@@Z ; IUnknown::QueryInterface<IDXGIFactory4>
PUBLIC	??$QueryInterface@UIDXGIFactory3@@@IUnknown@@QAGJPAPAUIDXGIFactory3@@@Z ; IUnknown::QueryInterface<IDXGIFactory3>
PUBLIC	??$QueryInterface@UIDXGIFactory2@@@IUnknown@@QAGJPAPAUIDXGIFactory2@@@Z ; IUnknown::QueryInterface<IDXGIFactory2>
PUBLIC	??$QueryInterface@UIDXGIFactory1@@@IUnknown@@QAGJPAPAUIDXGIFactory1@@@Z ; IUnknown::QueryInterface<IDXGIFactory1>
PUBLIC	??$QueryInterface@UIDXGIFactory@@@IUnknown@@QAGJPAPAUIDXGIFactory@@@Z ; IUnknown::QueryInterface<IDXGIFactory>
PUBLIC	?SK_CEGUI_QueueResetD3D11@@YAXXZ		; SK_CEGUI_QueueResetD3D11
PUBLIC	?capture@SK_D3D11_Stateblock_Lite@@QAEXPAUID3D11DeviceContext@@@Z ; SK_D3D11_Stateblock_Lite::capture
PUBLIC	?apply@SK_D3D11_Stateblock_Lite@@QAEXPAUID3D11DeviceContext@@@Z ; SK_D3D11_Stateblock_Lite::apply
PUBLIC	?CreateStateblock@@YAXPAUID3D11DeviceContext@@PAUD3DX11_STATE_BLOCK@@@Z ; CreateStateblock
PUBLIC	?ApplyStateblock@@YAXPAUID3D11DeviceContext@@PAUD3DX11_STATE_BLOCK@@@Z ; ApplyStateblock
PUBLIC	?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z	; SK_CEGUI_DrawD3D11
PUBLIC	??$QueryInterface@UID3D11Device@@@IUnknown@@QAGJPAPAUID3D11Device@@@Z ; IUnknown::QueryInterface<ID3D11Device>
PUBLIC	??0?$CComPtrBase@UID3D11RenderTargetView@@@ATL@@IAE@PAUID3D11RenderTargetView@@@Z ; ATL::CComPtrBase<ID3D11RenderTargetView>::CComPtrBase<ID3D11RenderTargetView>
PUBLIC	??1?$CComPtrBase@UID3D11RenderTargetView@@@ATL@@QAE@XZ ; ATL::CComPtrBase<ID3D11RenderTargetView>::~CComPtrBase<ID3D11RenderTargetView>
PUBLIC	??I?$CComPtrBase@UID3D11RenderTargetView@@@ATL@@QAEPAPAUID3D11RenderTargetView@@XZ ; ATL::CComPtrBase<ID3D11RenderTargetView>::operator&
PUBLIC	??0?$CComPtr@UID3D11RenderTargetView@@@ATL@@QAE@PAUID3D11RenderTargetView@@@Z ; ATL::CComPtr<ID3D11RenderTargetView>::CComPtr<ID3D11RenderTargetView>
PUBLIC	??1?$CComPtr@UID3D11RenderTargetView@@@ATL@@QAE@XZ ; ATL::CComPtr<ID3D11RenderTargetView>::~CComPtr<ID3D11RenderTargetView>
PUBLIC	??0?$CComPtrBase@UID3D11BlendState@@@ATL@@IAE@PAUID3D11BlendState@@@Z ; ATL::CComPtrBase<ID3D11BlendState>::CComPtrBase<ID3D11BlendState>
PUBLIC	??1?$CComPtrBase@UID3D11BlendState@@@ATL@@QAE@XZ ; ATL::CComPtrBase<ID3D11BlendState>::~CComPtrBase<ID3D11BlendState>
PUBLIC	??B?$CComPtrBase@UID3D11BlendState@@@ATL@@QBEPAUID3D11BlendState@@XZ ; ATL::CComPtrBase<ID3D11BlendState>::operator ID3D11BlendState *
PUBLIC	??I?$CComPtrBase@UID3D11BlendState@@@ATL@@QAEPAPAUID3D11BlendState@@XZ ; ATL::CComPtrBase<ID3D11BlendState>::operator&
PUBLIC	??0?$CComPtr@UID3D11BlendState@@@ATL@@QAE@PAUID3D11BlendState@@@Z ; ATL::CComPtr<ID3D11BlendState>::CComPtr<ID3D11BlendState>
PUBLIC	??1?$CComPtr@UID3D11BlendState@@@ATL@@QAE@XZ	; ATL::CComPtr<ID3D11BlendState>::~CComPtr<ID3D11BlendState>
PUBLIC	??0?$CComPtrBase@UID3D11Device1@@@ATL@@IAE@PAUID3D11Device1@@@Z ; ATL::CComPtrBase<ID3D11Device1>::CComPtrBase<ID3D11Device1>
PUBLIC	??1?$CComPtrBase@UID3D11Device1@@@ATL@@QAE@XZ	; ATL::CComPtrBase<ID3D11Device1>::~CComPtrBase<ID3D11Device1>
PUBLIC	??I?$CComPtrBase@UID3D11Device1@@@ATL@@QAEPAPAUID3D11Device1@@XZ ; ATL::CComPtrBase<ID3D11Device1>::operator&
PUBLIC	??C?$CComPtrBase@UID3D11Device1@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UID3D11Device1@@@1@XZ ; ATL::CComPtrBase<ID3D11Device1>::operator->
PUBLIC	??0?$CComPtr@UID3D11Device1@@@ATL@@QAE@PAUID3D11Device1@@@Z ; ATL::CComPtr<ID3D11Device1>::CComPtr<ID3D11Device1>
PUBLIC	??1?$CComPtr@UID3D11Device1@@@ATL@@QAE@XZ	; ATL::CComPtr<ID3D11Device1>::~CComPtr<ID3D11Device1>
PUBLIC	??0?$CComPtrBase@UID3DDeviceContextState@@@ATL@@IAE@PAUID3DDeviceContextState@@@Z ; ATL::CComPtrBase<ID3DDeviceContextState>::CComPtrBase<ID3DDeviceContextState>
PUBLIC	??1?$CComPtrBase@UID3DDeviceContextState@@@ATL@@QAE@XZ ; ATL::CComPtrBase<ID3DDeviceContextState>::~CComPtrBase<ID3DDeviceContextState>
PUBLIC	??I?$CComPtrBase@UID3DDeviceContextState@@@ATL@@QAEPAPAUID3DDeviceContextState@@XZ ; ATL::CComPtrBase<ID3DDeviceContextState>::operator&
PUBLIC	??0?$CComPtr@UID3DDeviceContextState@@@ATL@@QAE@PAUID3DDeviceContextState@@@Z ; ATL::CComPtr<ID3DDeviceContextState>::CComPtr<ID3DDeviceContextState>
PUBLIC	??1?$CComPtr@UID3DDeviceContextState@@@ATL@@QAE@XZ ; ATL::CComPtr<ID3DDeviceContextState>::~CComPtr<ID3DDeviceContextState>
PUBLIC	??0?$CComPtrBase@UID3D11DeviceContext1@@@ATL@@IAE@PAUID3D11DeviceContext1@@@Z ; ATL::CComPtrBase<ID3D11DeviceContext1>::CComPtrBase<ID3D11DeviceContext1>
PUBLIC	??1?$CComPtrBase@UID3D11DeviceContext1@@@ATL@@QAE@XZ ; ATL::CComPtrBase<ID3D11DeviceContext1>::~CComPtrBase<ID3D11DeviceContext1>
PUBLIC	??I?$CComPtrBase@UID3D11DeviceContext1@@@ATL@@QAEPAPAUID3D11DeviceContext1@@XZ ; ATL::CComPtrBase<ID3D11DeviceContext1>::operator&
PUBLIC	??0?$CComPtr@UID3D11DeviceContext1@@@ATL@@QAE@PAUID3D11DeviceContext1@@@Z ; ATL::CComPtr<ID3D11DeviceContext1>::CComPtr<ID3D11DeviceContext1>
PUBLIC	??1?$CComPtr@UID3D11DeviceContext1@@@ATL@@QAE@XZ ; ATL::CComPtr<ID3D11DeviceContext1>::~CComPtr<ID3D11DeviceContext1>
PUBLIC	??$QueryInterface@UID3D11DeviceContext@@@IUnknown@@QAGJPAPAUID3D11DeviceContext@@@Z ; IUnknown::QueryInterface<ID3D11DeviceContext>
PUBLIC	??$QueryInterface@UID3D11DeviceContext1@@@IUnknown@@QAGJPAPAUID3D11DeviceContext1@@@Z ; IUnknown::QueryInterface<ID3D11DeviceContext1>
PUBLIC	??$QueryInterface@UID3D11Device1@@@IUnknown@@QAGJPAPAUID3D11Device1@@@Z ; IUnknown::QueryInterface<ID3D11Device1>
PUBLIC	??R?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@QBEXPAUSK_D3D11_Stateblock_Lite@@@Z ; std::default_delete<SK_D3D11_Stateblock_Lite>::operator()
PUBLIC	?get_deleter@?$_Unique_ptr_base@USK_D3D11_Stateblock_Lite@@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@@std@@QAEAAU?$default_delete@USK_D3D11_Stateblock_Lite@@@2@XZ ; std::_Unique_ptr_base<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> >::get_deleter
PUBLIC	?_Myptr@?$_Unique_ptr_base@USK_D3D11_Stateblock_Lite@@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@@std@@QBEABQAUSK_D3D11_Stateblock_Lite@@XZ ; std::_Unique_ptr_base<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> >::_Myptr
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@PAUSK_D3D11_Stateblock_Lite@@$00@std@@QAEAAU?$default_delete@USK_D3D11_Stateblock_Lite@@@2@XZ ; std::_Compressed_pair<std::default_delete<SK_D3D11_Stateblock_Lite>,SK_D3D11_Stateblock_Lite *,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@PAUSK_D3D11_Stateblock_Lite@@$00@std@@QBEABQAUSK_D3D11_Stateblock_Lite@@XZ ; std::_Compressed_pair<std::default_delete<SK_D3D11_Stateblock_Lite>,SK_D3D11_Stateblock_Lite *,1>::_Get_second
PUBLIC	??0?$unique_ptr@USK_D3D11_Stateblock_Lite@@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@@std@@QAE@PAUSK_D3D11_Stateblock_Lite@@@Z ; std::unique_ptr<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> >::unique_ptr<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> >
PUBLIC	??1?$unique_ptr@USK_D3D11_Stateblock_Lite@@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@@std@@QAE@XZ ; std::unique_ptr<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> >::~unique_ptr<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> >
PUBLIC	??C?$unique_ptr@USK_D3D11_Stateblock_Lite@@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@@std@@QBEPAUSK_D3D11_Stateblock_Lite@@XZ ; std::unique_ptr<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> >::operator->
PUBLIC	?get@?$unique_ptr@USK_D3D11_Stateblock_Lite@@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@@std@@QBEPAUSK_D3D11_Stateblock_Lite@@XZ ; std::unique_ptr<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> >::get
PUBLIC	??0?$CComPtrBase@UIDXGISurface@@@ATL@@IAE@PAUIDXGISurface@@@Z ; ATL::CComPtrBase<IDXGISurface>::CComPtrBase<IDXGISurface>
PUBLIC	??1?$CComPtrBase@UIDXGISurface@@@ATL@@QAE@XZ	; ATL::CComPtrBase<IDXGISurface>::~CComPtrBase<IDXGISurface>
PUBLIC	??B?$CComPtrBase@UIDXGISurface@@@ATL@@QBEPAUIDXGISurface@@XZ ; ATL::CComPtrBase<IDXGISurface>::operator IDXGISurface *
PUBLIC	??I?$CComPtrBase@UIDXGISurface@@@ATL@@QAEPAPAUIDXGISurface@@XZ ; ATL::CComPtrBase<IDXGISurface>::operator&
PUBLIC	??0?$CComPtr@UIDXGISurface@@@ATL@@QAE@PAUIDXGISurface@@@Z ; ATL::CComPtr<IDXGISurface>::CComPtr<IDXGISurface>
PUBLIC	??1?$CComPtr@UIDXGISurface@@@ATL@@QAE@XZ	; ATL::CComPtr<IDXGISurface>::~CComPtr<IDXGISurface>
PUBLIC	??$IID_PPV_ARGS_Helper@UIDXGISurface@@@@YAPAPAXPAPAUIDXGISurface@@@Z ; IID_PPV_ARGS_Helper<IDXGISurface>
PUBLIC	?Present1Callback@@YGJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@Z ; Present1Callback
PUBLIC	??0?$CComPtrBase@UIDXGIDevice@@@ATL@@IAE@PAUIDXGIDevice@@@Z ; ATL::CComPtrBase<IDXGIDevice>::CComPtrBase<IDXGIDevice>
PUBLIC	??1?$CComPtrBase@UIDXGIDevice@@@ATL@@QAE@XZ	; ATL::CComPtrBase<IDXGIDevice>::~CComPtrBase<IDXGIDevice>
PUBLIC	??I?$CComPtrBase@UIDXGIDevice@@@ATL@@QAEPAPAUIDXGIDevice@@XZ ; ATL::CComPtrBase<IDXGIDevice>::operator&
PUBLIC	??C?$CComPtrBase@UIDXGIDevice@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIDXGIDevice@@@1@XZ ; ATL::CComPtrBase<IDXGIDevice>::operator->
PUBLIC	??0?$CComPtr@UIDXGIDevice@@@ATL@@QAE@PAUIDXGIDevice@@@Z ; ATL::CComPtr<IDXGIDevice>::CComPtr<IDXGIDevice>
PUBLIC	??1?$CComPtr@UIDXGIDevice@@@ATL@@QAE@XZ		; ATL::CComPtr<IDXGIDevice>::~CComPtr<IDXGIDevice>
PUBLIC	??0?$CComPtrBase@UIDXGIAdapter@@@ATL@@IAE@PAUIDXGIAdapter@@@Z ; ATL::CComPtrBase<IDXGIAdapter>::CComPtrBase<IDXGIAdapter>
PUBLIC	??1?$CComPtrBase@UIDXGIAdapter@@@ATL@@QAE@XZ	; ATL::CComPtrBase<IDXGIAdapter>::~CComPtrBase<IDXGIAdapter>
PUBLIC	??I?$CComPtrBase@UIDXGIAdapter@@@ATL@@QAEPAPAUIDXGIAdapter@@XZ ; ATL::CComPtrBase<IDXGIAdapter>::operator&
PUBLIC	??C?$CComPtrBase@UIDXGIAdapter@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIDXGIAdapter@@@1@XZ ; ATL::CComPtrBase<IDXGIAdapter>::operator->
PUBLIC	??0?$CComPtr@UIDXGIAdapter@@@ATL@@QAE@PAUIDXGIAdapter@@@Z ; ATL::CComPtr<IDXGIAdapter>::CComPtr<IDXGIAdapter>
PUBLIC	??1?$CComPtr@UIDXGIAdapter@@@ATL@@QAE@XZ	; ATL::CComPtr<IDXGIAdapter>::~CComPtr<IDXGIAdapter>
PUBLIC	??0?$CComPtrBase@UIDXGIFactory@@@ATL@@IAE@PAUIDXGIFactory@@@Z ; ATL::CComPtrBase<IDXGIFactory>::CComPtrBase<IDXGIFactory>
PUBLIC	??1?$CComPtrBase@UIDXGIFactory@@@ATL@@QAE@XZ	; ATL::CComPtrBase<IDXGIFactory>::~CComPtrBase<IDXGIFactory>
PUBLIC	??B?$CComPtrBase@UIDXGIFactory@@@ATL@@QBEPAUIDXGIFactory@@XZ ; ATL::CComPtrBase<IDXGIFactory>::operator IDXGIFactory *
PUBLIC	??I?$CComPtrBase@UIDXGIFactory@@@ATL@@QAEPAPAUIDXGIFactory@@XZ ; ATL::CComPtrBase<IDXGIFactory>::operator&
PUBLIC	??C?$CComPtrBase@UIDXGIFactory@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIDXGIFactory@@@1@XZ ; ATL::CComPtrBase<IDXGIFactory>::operator->
PUBLIC	??0?$CComPtr@UIDXGIFactory@@@ATL@@QAE@PAUIDXGIFactory@@@Z ; ATL::CComPtr<IDXGIFactory>::CComPtr<IDXGIFactory>
PUBLIC	??1?$CComPtr@UIDXGIFactory@@@ATL@@QAE@XZ	; ATL::CComPtr<IDXGIFactory>::~CComPtr<IDXGIFactory>
PUBLIC	??$QueryInterface@UIDXGIDevice@@@IUnknown@@QAGJPAPAUIDXGIDevice@@@Z ; IUnknown::QueryInterface<IDXGIDevice>
PUBLIC	??$IID_PPV_ARGS_Helper@UIDXGIFactory@@@@YAPAPAXPAPAUIDXGIFactory@@@Z ; IID_PPV_ARGS_Helper<IDXGIFactory>
PUBLIC	?SK_DXGI_Present@@YAJPAUIDXGISwapChain@@II@Z	; SK_DXGI_Present
PUBLIC	?PresentCallback@@YGJPAUIDXGISwapChain@@II@Z	; PresentCallback
PUBLIC	??0?$CComPtrBase@UIDXGISwapChain1@@@ATL@@IAE@XZ	; ATL::CComPtrBase<IDXGISwapChain1>::CComPtrBase<IDXGISwapChain1>
PUBLIC	??1?$CComPtrBase@UIDXGISwapChain1@@@ATL@@QAE@XZ	; ATL::CComPtrBase<IDXGISwapChain1>::~CComPtrBase<IDXGISwapChain1>
PUBLIC	??B?$CComPtrBase@UIDXGISwapChain1@@@ATL@@QBEPAUIDXGISwapChain1@@XZ ; ATL::CComPtrBase<IDXGISwapChain1>::operator IDXGISwapChain1 *
PUBLIC	??9?$CComPtrBase@UIDXGISwapChain1@@@ATL@@QBE_NPAUIDXGISwapChain1@@@Z ; ATL::CComPtrBase<IDXGISwapChain1>::operator!=
PUBLIC	??8?$CComPtrBase@UIDXGISwapChain1@@@ATL@@QBE_NPAUIDXGISwapChain1@@@Z ; ATL::CComPtrBase<IDXGISwapChain1>::operator==
PUBLIC	??0?$CComPtr@UIDXGISwapChain1@@@ATL@@QAE@XZ	; ATL::CComPtr<IDXGISwapChain1>::CComPtr<IDXGISwapChain1>
PUBLIC	??1?$CComPtr@UIDXGISwapChain1@@@ATL@@QAE@XZ	; ATL::CComPtr<IDXGISwapChain1>::~CComPtr<IDXGISwapChain1>
PUBLIC	??0?$CComQIPtr@UIDXGISwapChain1@@$1?_GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z ; ATL::CComQIPtr<IDXGISwapChain1,&_GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa>::CComQIPtr<IDXGISwapChain1,&_GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa>
PUBLIC	??1?$CComQIPtr@UIDXGISwapChain1@@$1?_GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa@@3U__s_GUID@@B@ATL@@QAE@XZ ; ATL::CComQIPtr<IDXGISwapChain1,&_GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa>::~CComQIPtr<IDXGISwapChain1,&_GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa>
PUBLIC	??0?$CComPtrBase@UIDXGISwapChain2@@@ATL@@IAE@XZ	; ATL::CComPtrBase<IDXGISwapChain2>::CComPtrBase<IDXGISwapChain2>
PUBLIC	??0?$CComPtrBase@UIDXGISwapChain2@@@ATL@@IAE@PAUIDXGISwapChain2@@@Z ; ATL::CComPtrBase<IDXGISwapChain2>::CComPtrBase<IDXGISwapChain2>
PUBLIC	??1?$CComPtrBase@UIDXGISwapChain2@@@ATL@@QAE@XZ	; ATL::CComPtrBase<IDXGISwapChain2>::~CComPtrBase<IDXGISwapChain2>
PUBLIC	??I?$CComPtrBase@UIDXGISwapChain2@@@ATL@@QAEPAPAUIDXGISwapChain2@@XZ ; ATL::CComPtrBase<IDXGISwapChain2>::operator&
PUBLIC	??C?$CComPtrBase@UIDXGISwapChain2@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIDXGISwapChain2@@@1@XZ ; ATL::CComPtrBase<IDXGISwapChain2>::operator->
PUBLIC	??9?$CComPtrBase@UIDXGISwapChain2@@@ATL@@QBE_NPAUIDXGISwapChain2@@@Z ; ATL::CComPtrBase<IDXGISwapChain2>::operator!=
PUBLIC	??8?$CComPtrBase@UIDXGISwapChain2@@@ATL@@QBE_NPAUIDXGISwapChain2@@@Z ; ATL::CComPtrBase<IDXGISwapChain2>::operator==
PUBLIC	??0?$CComPtr@UIDXGISwapChain2@@@ATL@@QAE@XZ	; ATL::CComPtr<IDXGISwapChain2>::CComPtr<IDXGISwapChain2>
PUBLIC	??0?$CComPtr@UIDXGISwapChain2@@@ATL@@QAE@PAUIDXGISwapChain2@@@Z ; ATL::CComPtr<IDXGISwapChain2>::CComPtr<IDXGISwapChain2>
PUBLIC	??1?$CComPtr@UIDXGISwapChain2@@@ATL@@QAE@XZ	; ATL::CComPtr<IDXGISwapChain2>::~CComPtr<IDXGISwapChain2>
PUBLIC	??0?$CComQIPtr@UIDXGISwapChain2@@$1?_GUID_a8be2ac4_199f_4946_b331_79599fb98de7@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z ; ATL::CComQIPtr<IDXGISwapChain2,&_GUID_a8be2ac4_199f_4946_b331_79599fb98de7>::CComQIPtr<IDXGISwapChain2,&_GUID_a8be2ac4_199f_4946_b331_79599fb98de7>
PUBLIC	??1?$CComQIPtr@UIDXGISwapChain2@@$1?_GUID_a8be2ac4_199f_4946_b331_79599fb98de7@@3U__s_GUID@@B@ATL@@QAE@XZ ; ATL::CComQIPtr<IDXGISwapChain2,&_GUID_a8be2ac4_199f_4946_b331_79599fb98de7>::~CComQIPtr<IDXGISwapChain2,&_GUID_a8be2ac4_199f_4946_b331_79599fb98de7>
PUBLIC	?DXGIOutput_GetDisplayModeList_Override@@YGJPAUIDXGIOutput@@W4DXGI_FORMAT@@IPAIPAUDXGI_MODE_DESC@@@Z ; DXGIOutput_GetDisplayModeList_Override
PUBLIC	?_Kfn@?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@SAABHABH@Z ; std::_Tset_traits<int,std::less<int>,std::allocator<int>,0>::_Kfn
PUBLIC	??0?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAE@XZ ; std::allocator<std::_Tree_node<int,void *> >::allocator<std::_Tree_node<int,void *> >
PUBLIC	??0?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Tree_node<int,void *> >::allocator<std::_Tree_node<int,void *> >
PUBLIC	?deallocate@?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAEXPAU?$_Tree_node@HPAX@2@I@Z ; std::allocator<std::_Tree_node<int,void *> >::deallocate
PUBLIC	?allocate@?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAEPAU?$_Tree_node@HPAX@2@I@Z ; std::allocator<std::_Tree_node<int,void *> >::allocate
PUBLIC	?max_size@?$allocator@U?$_Tree_node@HPAX@std@@@std@@QBEIXZ ; std::allocator<std::_Tree_node<int,void *> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@HPAX@std@@@2@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<int,void *> > >::max_size
PUBLIC	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@SA?AV?$allocator@U?$_Tree_node@HPAX@std@@@2@ABV32@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<int,void *> > >::select_on_container_copy_construction
PUBLIC	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QBE?AU12@U_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::select_on_container_copy_construction
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@$$QAU01@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAEPAU?$_Tree_node@HPAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@HPAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::max_size
PUBLIC	?_Color@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@HPAX@2@@Z ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Color
PUBLIC	?_Isnil@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@HPAX@2@@Z ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Isnil
PUBLIC	?_Left@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@HPAX@2@PAU32@@Z ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Left
PUBLIC	?_Parent@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@HPAX@2@PAU32@@Z ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Parent
PUBLIC	?_Right@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@HPAX@2@PAU32@@Z ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Right
PUBLIC	?_Myval@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@SAAAHPAU?$_Tree_node@HPAX@2@@Z ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Myval
PUBLIC	?_Max@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@SAPAU?$_Tree_node@HPAX@2@PAU32@@Z ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Max
PUBLIC	?_Min@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@SAPAU?$_Tree_node@HPAX@2@PAU32@@Z ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Min
PUBLIC	??0?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@@Z ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >
PUBLIC	?_Construct@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Construct
PUBLIC	??1?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::~_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >
PUBLIC	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@HPAX@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Buyheadnode
PUBLIC	?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@HPAX@2@@Z ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Freeheadnode
PUBLIC	?_Buynode0@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@HPAX@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Buynode0
PUBLIC	?_Freenode0@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@HPAX@2@@Z ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Freenode0
PUBLIC	?_Getcomp@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEAAU?$less@H@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Getcomp
PUBLIC	?_Getcomp@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEABU?$less@H@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Getcomp
PUBLIC	?_Getal@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Getal
PUBLIC	?_Getal@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Getal
PUBLIC	?_Get_data@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Get_data
PUBLIC	?_Get_data@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Get_data
PUBLIC	?_Myhead@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@HPAX@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Myhead
PUBLIC	?_Myhead@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@HPAX@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Myhead
PUBLIC	?_Mysize@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEAAIXZ ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Mysize
PUBLIC	?_Mysize@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEABIXZ ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Mysize
PUBLIC	??R?$less@H@std@@QBE_NABH0@Z			; std::less<int>::operator()
PUBLIC	??0?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tree_simple_types<int> >::_Tree_val<std::_Tree_simple_types<int> >
PUBLIC	?_Color@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAAADPAU?$_Tree_node@HPAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Color
PUBLIC	?_Isnil@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAAADPAU?$_Tree_node@HPAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Isnil
PUBLIC	?_Left@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAAAPAU?$_Tree_node@HPAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Left
PUBLIC	?_Parent@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAAAPAU?$_Tree_node@HPAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Parent
PUBLIC	?_Right@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAAAPAU?$_Tree_node@HPAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Right
PUBLIC	?_Myval@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAAAHPAU?$_Tree_node@HPAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Myval
PUBLIC	?_Max@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAPAU?$_Tree_node@HPAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Max
PUBLIC	?_Min@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAPAU?$_Tree_node@HPAX@2@PAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Min
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>::_Get_second
PUBLIC	?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@$00@std@@QAEAAU?$less@H@2@XZ ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@$00@std@@QBEABU?$less@H@2@XZ ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@XZ ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@XZ ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>,1>::_Get_second
PUBLIC	??0?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >
PUBLIC	??1?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::~_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >
PUBLIC	?begin@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::end
PUBLIC	?size@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::size
PUBLIC	?max_size@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::max_size
PUBLIC	?key_comp@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::key_comp
PUBLIC	?erase@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@V32@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::erase
PUBLIC	?erase@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@V32@0@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::erase
PUBLIC	?clear@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::clear
PUBLIC	?count@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEIABH@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::count
PUBLIC	?equal_range@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@V12@@2@ABH@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::equal_range
PUBLIC	?_Destroy_if_not_nil@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXU_Nil@2@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Destroy_if_not_nil
PUBLIC	?_Erase@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@HPAX@2@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Erase
PUBLIC	?_Lmost@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@HPAX@2@XZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Lmost
PUBLIC	?_Lrotate@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@HPAX@2@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Lrotate
PUBLIC	?_Rmost@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@HPAX@2@XZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Rmost
PUBLIC	?_Root@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@HPAX@2@XZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Root
PUBLIC	?_Rrotate@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@HPAX@2@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Rrotate
PUBLIC	?_Tidy@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Tidy
PUBLIC	?_Kfn@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEABHABH@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Kfn
PUBLIC	?_Key@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEABHPAU?$_Tree_node@HPAX@2@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Key
PUBLIC	??0?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QAE@XZ ; std::set<int,std::less<int>,std::allocator<int> >::set<int,std::less<int>,std::allocator<int> >
PUBLIC	??0?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QAE@ABV01@@Z ; std::set<int,std::less<int>,std::allocator<int> >::set<int,std::less<int>,std::allocator<int> >
PUBLIC	??1?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QAE@XZ ; std::set<int,std::less<int>,std::allocator<int> >::~set<int,std::less<int>,std::allocator<int> >
PUBLIC	??$?RHHV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@@<lambda_fc9a2ce0f8ba827916420a475022bd4b>@@QBE_NW4SK_DXGI_ResType@@AAHHV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@PAUDXGI_MODE_DESC@@@Z ; <lambda_fc9a2ce0f8ba827916420a475022bd4b>::operator()<int,int,std::set<int,std::less<int>,std::allocator<int> > >
PUBLIC	??$?RHIV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@@<lambda_8c641e4ce6091119a877a3a3b6ce9fff>@@QBE_NW4SK_DXGI_ResType@@AAHIV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@PAUDXGI_MODE_DESC@@@Z ; <lambda_8c641e4ce6091119a877a3a3b6ce9fff>::operator()<int,unsigned int,std::set<int,std::less<int>,std::allocator<int> > >
PUBLIC	?DXGIOutput_FindClosestMatchingMode_Override@@YGJPAUIDXGIOutput@@PBUDXGI_MODE_DESC@@PAU2@PAUIUnknown@@@Z ; DXGIOutput_FindClosestMatchingMode_Override
PUBLIC	?DXGIOutput_WaitForVBlank_Override@@YGJPAUIDXGIOutput@@@Z ; DXGIOutput_WaitForVBlank_Override
PUBLIC	?DXGISwap_GetFullscreenState_Override@@YGJPAUIDXGISwapChain@@PAHPAPAUIDXGIOutput@@@Z ; DXGISwap_GetFullscreenState_Override
PUBLIC	?DXGISwap_SetFullscreenState_Override@@YGJPAUIDXGISwapChain@@HPAUIDXGIOutput@@@Z ; DXGISwap_SetFullscreenState_Override
PUBLIC	?DXGISwap_ResizeBuffers_Override@@YGJPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z ; DXGISwap_ResizeBuffers_Override
PUBLIC	??0?$lock_guard@VSK_Thread_CriticalSection@@@std@@QAE@AAVSK_Thread_CriticalSection@@@Z ; std::lock_guard<SK_Thread_CriticalSection>::lock_guard<SK_Thread_CriticalSection>
PUBLIC	??1?$lock_guard@VSK_Thread_CriticalSection@@@std@@QAE@XZ ; std::lock_guard<SK_Thread_CriticalSection>::~lock_guard<SK_Thread_CriticalSection>
PUBLIC	?DXGISwap_ResizeTarget_Override@@YGJPAUIDXGISwapChain@@PBUDXGI_MODE_DESC@@@Z ; DXGISwap_ResizeTarget_Override
PUBLIC	?SK_DXGI_CreateSwapChain_PreInit@@YAXPAUDXGI_SWAP_CHAIN_DESC@@PAUDXGI_SWAP_CHAIN_DESC1@@AAPAUHWND__@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@@Z ; SK_DXGI_CreateSwapChain_PreInit
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
PUBLIC	?SK_DXGI_HookSwapChain@@YAXPAUIDXGISwapChain@@@Z ; SK_DXGI_HookSwapChain
PUBLIC	?SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z ; SK_DXGI_CreateSwapChain_PostInit
PUBLIC	??$QueryInterface@UIDXGISwapChain2@@@IUnknown@@QAGJPAPAUIDXGISwapChain2@@@Z ; IUnknown::QueryInterface<IDXGISwapChain2>
PUBLIC	??0?$CComPtrBase@UIDXGIDevice1@@@ATL@@IAE@PAUIDXGIDevice1@@@Z ; ATL::CComPtrBase<IDXGIDevice1>::CComPtrBase<IDXGIDevice1>
PUBLIC	??1?$CComPtrBase@UIDXGIDevice1@@@ATL@@QAE@XZ	; ATL::CComPtrBase<IDXGIDevice1>::~CComPtrBase<IDXGIDevice1>
PUBLIC	??I?$CComPtrBase@UIDXGIDevice1@@@ATL@@QAEPAPAUIDXGIDevice1@@XZ ; ATL::CComPtrBase<IDXGIDevice1>::operator&
PUBLIC	??C?$CComPtrBase@UIDXGIDevice1@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIDXGIDevice1@@@1@XZ ; ATL::CComPtrBase<IDXGIDevice1>::operator->
PUBLIC	??0?$CComPtr@UIDXGIDevice1@@@ATL@@QAE@PAUIDXGIDevice1@@@Z ; ATL::CComPtr<IDXGIDevice1>::CComPtr<IDXGIDevice1>
PUBLIC	??1?$CComPtr@UIDXGIDevice1@@@ATL@@QAE@XZ	; ATL::CComPtr<IDXGIDevice1>::~CComPtr<IDXGIDevice1>
PUBLIC	??$IID_PPV_ARGS_Helper@UIDXGIDevice1@@@@YAPAPAXPAPAUIDXGIDevice1@@@Z ; IID_PPV_ARGS_Helper<IDXGIDevice1>
PUBLIC	??0?$CComQIPtr@UID3D11Device@@$1?_GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z ; ATL::CComQIPtr<ID3D11Device,&_GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140>::CComQIPtr<ID3D11Device,&_GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140>
PUBLIC	??1?$CComQIPtr@UID3D11Device@@$1?_GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140@@3U__s_GUID@@B@ATL@@QAE@XZ ; ATL::CComQIPtr<ID3D11Device,&_GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140>::~CComQIPtr<ID3D11Device,&_GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140>
PUBLIC	?SK_DXGI_CreateSwapChain1_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC1@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAPAUIDXGISwapChain1@@@Z ; SK_DXGI_CreateSwapChain1_PostInit
PUBLIC	??0?$CComPtrBase@UIDXGISwapChain@@@ATL@@IAE@PAUIDXGISwapChain@@@Z ; ATL::CComPtrBase<IDXGISwapChain>::CComPtrBase<IDXGISwapChain>
PUBLIC	??1?$CComPtrBase@UIDXGISwapChain@@@ATL@@QAE@XZ	; ATL::CComPtrBase<IDXGISwapChain>::~CComPtrBase<IDXGISwapChain>
PUBLIC	??B?$CComPtrBase@UIDXGISwapChain@@@ATL@@QBEPAUIDXGISwapChain@@XZ ; ATL::CComPtrBase<IDXGISwapChain>::operator IDXGISwapChain *
PUBLIC	??I?$CComPtrBase@UIDXGISwapChain@@@ATL@@QAEPAPAUIDXGISwapChain@@XZ ; ATL::CComPtrBase<IDXGISwapChain>::operator&
PUBLIC	??0?$CComPtr@UIDXGISwapChain@@@ATL@@QAE@PAUIDXGISwapChain@@@Z ; ATL::CComPtr<IDXGISwapChain>::CComPtr<IDXGISwapChain>
PUBLIC	??1?$CComPtr@UIDXGISwapChain@@@ATL@@QAE@XZ	; ATL::CComPtr<IDXGISwapChain>::~CComPtr<IDXGISwapChain>
PUBLIC	??0?$CComQIPtr@UIDXGISwapChain@@$1?_GUID_310d36a0_d2e7_4c0a_aa04_6a9d23b8886a@@3U__s_GUID@@B@ATL@@QAE@PAUIDXGISwapChain@@@Z ; ATL::CComQIPtr<IDXGISwapChain,&_GUID_310d36a0_d2e7_4c0a_aa04_6a9d23b8886a>::CComQIPtr<IDXGISwapChain,&_GUID_310d36a0_d2e7_4c0a_aa04_6a9d23b8886a>
PUBLIC	??1?$CComQIPtr@UIDXGISwapChain@@$1?_GUID_310d36a0_d2e7_4c0a_aa04_6a9d23b8886a@@3U__s_GUID@@B@ATL@@QAE@XZ ; ATL::CComQIPtr<IDXGISwapChain,&_GUID_310d36a0_d2e7_4c0a_aa04_6a9d23b8886a>::~CComQIPtr<IDXGISwapChain,&_GUID_310d36a0_d2e7_4c0a_aa04_6a9d23b8886a>
PUBLIC	?DXGIFactory_CreateSwapChain_Override@@YGJPAUIDXGIFactory@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z ; DXGIFactory_CreateSwapChain_Override
PUBLIC	?DXGIFactory2_CreateSwapChainForCoreWindow_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@1PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z ; DXGIFactory2_CreateSwapChainForCoreWindow_Override
PUBLIC	?DXGIFactory2_CreateSwapChainForHwnd_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@PAUHWND__@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z ; DXGIFactory2_CreateSwapChainForHwnd_Override
PUBLIC	?DXGIFactory2_CreateSwapChainForComposition_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z ; DXGIFactory2_CreateSwapChainForComposition_Override
PUBLIC	?CreateDXGIFactory@@YGJABU_GUID@@PAPAX@Z	; CreateDXGIFactory
PUBLIC	?CreateDXGIFactory1@@YGJABU_GUID@@PAPAX@Z	; CreateDXGIFactory1
PUBLIC	??$static_cast_p2p@XUIDXGIFactory@@@@YAPAPAXPAPAUIDXGIFactory@@@Z ; static_cast_p2p<void,IDXGIFactory>
PUBLIC	?GetDesc2_Override@@YGJPAUIDXGIAdapter2@@PAUDXGI_ADAPTER_DESC2@@@Z ; GetDesc2_Override
PUBLIC	?GetDesc1_Override@@YGJPAUIDXGIAdapter1@@PAUDXGI_ADAPTER_DESC1@@@Z ; GetDesc1_Override
PUBLIC	?GetDesc_Override@@YGJPAUIDXGIAdapter@@PAUDXGI_ADAPTER_DESC@@@Z ; GetDesc_Override
PUBLIC	??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QB_W@Z ; std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?EnumAdapters_Common@@YGJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@P6GJ0I1@Z@Z ; EnumAdapters_Common
PUBLIC	??0?$CComPtrBase@UIDXGIAdapter2@@@ATL@@IAE@XZ	; ATL::CComPtrBase<IDXGIAdapter2>::CComPtrBase<IDXGIAdapter2>
PUBLIC	??1?$CComPtrBase@UIDXGIAdapter2@@@ATL@@QAE@XZ	; ATL::CComPtrBase<IDXGIAdapter2>::~CComPtrBase<IDXGIAdapter2>
PUBLIC	??9?$CComPtrBase@UIDXGIAdapter2@@@ATL@@QBE_NPAUIDXGIAdapter2@@@Z ; ATL::CComPtrBase<IDXGIAdapter2>::operator!=
PUBLIC	??8?$CComPtrBase@UIDXGIAdapter2@@@ATL@@QBE_NPAUIDXGIAdapter2@@@Z ; ATL::CComPtrBase<IDXGIAdapter2>::operator==
PUBLIC	??0?$CComPtr@UIDXGIAdapter2@@@ATL@@QAE@XZ	; ATL::CComPtr<IDXGIAdapter2>::CComPtr<IDXGIAdapter2>
PUBLIC	??1?$CComPtr@UIDXGIAdapter2@@@ATL@@QAE@XZ	; ATL::CComPtr<IDXGIAdapter2>::~CComPtr<IDXGIAdapter2>
PUBLIC	??0?$CComQIPtr@UIDXGIAdapter2@@$1?_GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z ; ATL::CComQIPtr<IDXGIAdapter2,&_GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5>::CComQIPtr<IDXGIAdapter2,&_GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5>
PUBLIC	??1?$CComQIPtr@UIDXGIAdapter2@@$1?_GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5@@3U__s_GUID@@B@ATL@@QAE@XZ ; ATL::CComQIPtr<IDXGIAdapter2,&_GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5>::~CComQIPtr<IDXGIAdapter2,&_GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5>
PUBLIC	??0?$CComPtrBase@UIDXGIAdapter1@@@ATL@@IAE@XZ	; ATL::CComPtrBase<IDXGIAdapter1>::CComPtrBase<IDXGIAdapter1>
PUBLIC	??1?$CComPtrBase@UIDXGIAdapter1@@@ATL@@QAE@XZ	; ATL::CComPtrBase<IDXGIAdapter1>::~CComPtrBase<IDXGIAdapter1>
PUBLIC	??B?$CComPtrBase@UIDXGIAdapter1@@@ATL@@QBEPAUIDXGIAdapter1@@XZ ; ATL::CComPtrBase<IDXGIAdapter1>::operator IDXGIAdapter1 *
PUBLIC	??I?$CComPtrBase@UIDXGIAdapter1@@@ATL@@QAEPAPAUIDXGIAdapter1@@XZ ; ATL::CComPtrBase<IDXGIAdapter1>::operator&
PUBLIC	??9?$CComPtrBase@UIDXGIAdapter1@@@ATL@@QBE_NPAUIDXGIAdapter1@@@Z ; ATL::CComPtrBase<IDXGIAdapter1>::operator!=
PUBLIC	??8?$CComPtrBase@UIDXGIAdapter1@@@ATL@@QBE_NPAUIDXGIAdapter1@@@Z ; ATL::CComPtrBase<IDXGIAdapter1>::operator==
PUBLIC	??0?$CComPtr@UIDXGIAdapter1@@@ATL@@QAE@XZ	; ATL::CComPtr<IDXGIAdapter1>::CComPtr<IDXGIAdapter1>
PUBLIC	??1?$CComPtr@UIDXGIAdapter1@@@ATL@@QAE@XZ	; ATL::CComPtr<IDXGIAdapter1>::~CComPtr<IDXGIAdapter1>
PUBLIC	??0?$CComQIPtr@UIDXGIAdapter1@@$1?_GUID_29038f61_3839_4626_91fd_086879011a05@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z ; ATL::CComQIPtr<IDXGIAdapter1,&_GUID_29038f61_3839_4626_91fd_086879011a05>::CComQIPtr<IDXGIAdapter1,&_GUID_29038f61_3839_4626_91fd_086879011a05>
PUBLIC	??1?$CComQIPtr@UIDXGIAdapter1@@$1?_GUID_29038f61_3839_4626_91fd_086879011a05@@3U__s_GUID@@B@ATL@@QAE@XZ ; ATL::CComQIPtr<IDXGIAdapter1,&_GUID_29038f61_3839_4626_91fd_086879011a05>::~CComQIPtr<IDXGIAdapter1,&_GUID_29038f61_3839_4626_91fd_086879011a05>
PUBLIC	?EnumAdapters1_Override@@YGJPAUIDXGIFactory1@@IPAPAUIDXGIAdapter1@@@Z ; EnumAdapters1_Override
PUBLIC	?EnumAdapters_Override@@YGJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@@Z ; EnumAdapters_Override
PUBLIC	?CreateDXGIFactory2@@YGJIABU_GUID@@PAPAX@Z	; CreateDXGIFactory2
PUBLIC	?DXGID3D10CreateDevice@@YGJPAUHINSTANCE__@@PAUIDXGIFactory@@PAUIDXGIAdapter@@IPAX3@Z ; DXGID3D10CreateDevice
PUBLIC	?DXGID3D10CreateLayeredDevice@@YGJUUNKNOWN5@@@Z	; DXGID3D10CreateLayeredDevice
PUBLIC	?DXGID3D10GetLayeredDeviceSize@@YGKPBXI@Z	; DXGID3D10GetLayeredDeviceSize
PUBLIC	?DXGID3D10RegisterLayers@@YGJPBXI@Z		; DXGID3D10RegisterLayers
PUBLIC	?DXGIDumpJournal@@YGXPBD@Z			; DXGIDumpJournal
PUBLIC	?DXGIReportAdapterConfiguration@@YGJK@Z		; DXGIReportAdapterConfiguration
PUBLIC	?ChangeDisplaySettingsA_Detour@@YGJPAU_devicemodeA@@K@Z ; ChangeDisplaySettingsA_Detour
PUBLIC	?SK_HookDXGI@@YGXXZ				; SK_HookDXGI
PUBLIC	??$static_cast_p2p@X$$A6GJABU_GUID@@PAPAX@Z@@YAPAPAXPAP6GJABU_GUID@@PAPAX@Z@Z ; static_cast_p2p<void,long __stdcall(_GUID const &,void * *)>
PUBLIC	??$static_cast_p2p@X$$A6GJIABU_GUID@@PAPAX@Z@@YAPAPAXPAP6GJIABU_GUID@@PAPAX@Z@Z ; static_cast_p2p<void,long __stdcall(unsigned int,_GUID const &,void * *)>
PUBLIC	??0?$allocator@K@std@@QAE@XZ			; std::allocator<unsigned long>::allocator<unsigned long>
PUBLIC	?deallocate@?$allocator@K@std@@QAEXPAKI@Z	; std::allocator<unsigned long>::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<unsigned long> >::_Wrap_alloc<std::allocator<unsigned long> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKI@Z ; std::_Wrap_alloc<std::allocator<unsigned long> >::deallocate
PUBLIC	?deallocate@?$allocator@PAK@std@@QAEXPAPAKI@Z	; std::allocator<unsigned long *>::deallocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAK@std@@@std@@QAEXPAPAKI@Z ; std::_Wrap_alloc<std::allocator<unsigned long *> >::deallocate
PUBLIC	?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QBEII@Z ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Getblock
PUBLIC	??0?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@XZ ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >
PUBLIC	??1?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@XZ ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::~_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >
PUBLIC	?_Alloc_proxy@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Alloc_proxy
PUBLIC	?_Free_proxy@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Free_proxy
PUBLIC	?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Myproxy
PUBLIC	?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Orphan_all
PUBLIC	?_Getal@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal
PUBLIC	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Get_data
PUBLIC	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Get_data
PUBLIC	?_Map@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAPAKXZ ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Map
PUBLIC	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Mapsize
PUBLIC	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Myoff
PUBLIC	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Mysize
PUBLIC	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABIXZ ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Mysize
PUBLIC	??0?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<unsigned long> >::_Deque_val<std::_Deque_simple_types<unsigned long> >
PUBLIC	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<unsigned long> >::_Getblock
PUBLIC	??1?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<unsigned long> >::~_Deque_val<std::_Deque_simple_types<unsigned long> >
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Deque_val<std::_Deque_simple_types<unsigned long> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@$00@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Deque_val<std::_Deque_simple_types<unsigned long> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@$00@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Deque_val<std::_Deque_simple_types<unsigned long> >,1>::_Get_second
PUBLIC	??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Deque_val<std::_Deque_simple_types<unsigned long> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Deque_val<std::_Deque_simple_types<unsigned long> >,1>
PUBLIC	??0?$deque@KV?$allocator@K@std@@@std@@QAE@XZ	; std::deque<unsigned long,std::allocator<unsigned long> >::deque<unsigned long,std::allocator<unsigned long> >
PUBLIC	??1?$deque@KV?$allocator@K@std@@@std@@QAE@XZ	; std::deque<unsigned long,std::allocator<unsigned long> >::~deque<unsigned long,std::allocator<unsigned long> >
PUBLIC	?empty@?$deque@KV?$allocator@K@std@@@std@@QBE_NXZ ; std::deque<unsigned long,std::allocator<unsigned long> >::empty
PUBLIC	?pop_back@?$deque@KV?$allocator@K@std@@@std@@QAEXXZ ; std::deque<unsigned long,std::allocator<unsigned long> >::pop_back
PUBLIC	?_Tidy@?$deque@KV?$allocator@K@std@@@std@@IAEXXZ ; std::deque<unsigned long,std::allocator<unsigned long> >::_Tidy
PUBLIC	??0?$queue@KV?$deque@KV?$allocator@K@std@@@std@@@std@@QAE@XZ ; std::queue<unsigned long,std::deque<unsigned long,std::allocator<unsigned long> > >::queue<unsigned long,std::deque<unsigned long,std::allocator<unsigned long> > >
PUBLIC	??1?$queue@KV?$deque@KV?$allocator@K@std@@@std@@@std@@QAE@XZ ; std::queue<unsigned long,std::deque<unsigned long,std::allocator<unsigned long> > >::~queue<unsigned long,std::deque<unsigned long,std::allocator<unsigned long> > >
PUBLIC	?dxgi_init_callback@@YGXP6GXXZ@Z		; dxgi_init_callback
PUBLIC	?SK_DXGI_PreHook@@YAXXZ				; SK_DXGI_PreHook
PUBLIC	?PresentCallback_Pre@@YGJPAUIDXGISwapChain@@II@Z ; PresentCallback_Pre
PUBLIC	?SK_DXGI_HookPresentBase@@YAXPAUIDXGISwapChain@@_N@Z ; SK_DXGI_HookPresentBase
PUBLIC	?SK_DXGI_HookPresent1@@YAXPAUIDXGISwapChain1@@_N@Z ; SK_DXGI_HookPresent1
PUBLIC	?SK_DXGI_FormatToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4DXGI_FORMAT@@@Z ; SK_DXGI_FormatToString
PUBLIC	??0?$CComPtrBase@UIDXGIOutput@@@ATL@@IAE@PAUIDXGIOutput@@@Z ; ATL::CComPtrBase<IDXGIOutput>::CComPtrBase<IDXGIOutput>
PUBLIC	??1?$CComPtrBase@UIDXGIOutput@@@ATL@@QAE@XZ	; ATL::CComPtrBase<IDXGIOutput>::~CComPtrBase<IDXGIOutput>
PUBLIC	??I?$CComPtrBase@UIDXGIOutput@@@ATL@@QAEPAPAUIDXGIOutput@@XZ ; ATL::CComPtrBase<IDXGIOutput>::operator&
PUBLIC	??9?$CComPtrBase@UIDXGIOutput@@@ATL@@QBE_NPAUIDXGIOutput@@@Z ; ATL::CComPtrBase<IDXGIOutput>::operator!=
PUBLIC	??8?$CComPtrBase@UIDXGIOutput@@@ATL@@QBE_NPAUIDXGIOutput@@@Z ; ATL::CComPtrBase<IDXGIOutput>::operator==
PUBLIC	??0?$CComPtr@UIDXGIOutput@@@ATL@@QAE@PAUIDXGIOutput@@@Z ; ATL::CComPtr<IDXGIOutput>::CComPtr<IDXGIOutput>
PUBLIC	??1?$CComPtr@UIDXGIOutput@@@ATL@@QAE@XZ		; ATL::CComPtr<IDXGIOutput>::~CComPtr<IDXGIOutput>
PUBLIC	?SK_DXGI_HookFactory@@YAXPAUIDXGIFactory@@@Z	; SK_DXGI_HookFactory
PUBLIC	??0?$CComPtrBase@UIDXGIFactory1@@@ATL@@IAE@XZ	; ATL::CComPtrBase<IDXGIFactory1>::CComPtrBase<IDXGIFactory1>
PUBLIC	??1?$CComPtrBase@UIDXGIFactory1@@@ATL@@QAE@XZ	; ATL::CComPtrBase<IDXGIFactory1>::~CComPtrBase<IDXGIFactory1>
PUBLIC	??I?$CComPtrBase@UIDXGIFactory1@@@ATL@@QAEPAPAUIDXGIFactory1@@XZ ; ATL::CComPtrBase<IDXGIFactory1>::operator&
PUBLIC	??9?$CComPtrBase@UIDXGIFactory1@@@ATL@@QBE_NPAUIDXGIFactory1@@@Z ; ATL::CComPtrBase<IDXGIFactory1>::operator!=
PUBLIC	??8?$CComPtrBase@UIDXGIFactory1@@@ATL@@QBE_NPAUIDXGIFactory1@@@Z ; ATL::CComPtrBase<IDXGIFactory1>::operator==
PUBLIC	??0?$CComPtr@UIDXGIFactory1@@@ATL@@QAE@XZ	; ATL::CComPtr<IDXGIFactory1>::CComPtr<IDXGIFactory1>
PUBLIC	??1?$CComPtr@UIDXGIFactory1@@@ATL@@QAE@XZ	; ATL::CComPtr<IDXGIFactory1>::~CComPtr<IDXGIFactory1>
PUBLIC	??0?$CComQIPtr@UIDXGIFactory1@@$1?_GUID_770aae78_f26f_4dba_a829_253c83d1b387@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z ; ATL::CComQIPtr<IDXGIFactory1,&_GUID_770aae78_f26f_4dba_a829_253c83d1b387>::CComQIPtr<IDXGIFactory1,&_GUID_770aae78_f26f_4dba_a829_253c83d1b387>
PUBLIC	??1?$CComQIPtr@UIDXGIFactory1@@$1?_GUID_770aae78_f26f_4dba_a829_253c83d1b387@@3U__s_GUID@@B@ATL@@QAE@XZ ; ATL::CComQIPtr<IDXGIFactory1,&_GUID_770aae78_f26f_4dba_a829_253c83d1b387>::~CComQIPtr<IDXGIFactory1,&_GUID_770aae78_f26f_4dba_a829_253c83d1b387>
PUBLIC	??0?$CComPtrBase@UIDXGIFactory2@@@ATL@@IAE@XZ	; ATL::CComPtrBase<IDXGIFactory2>::CComPtrBase<IDXGIFactory2>
PUBLIC	??1?$CComPtrBase@UIDXGIFactory2@@@ATL@@QAE@XZ	; ATL::CComPtrBase<IDXGIFactory2>::~CComPtrBase<IDXGIFactory2>
PUBLIC	??I?$CComPtrBase@UIDXGIFactory2@@@ATL@@QAEPAPAUIDXGIFactory2@@XZ ; ATL::CComPtrBase<IDXGIFactory2>::operator&
PUBLIC	??9?$CComPtrBase@UIDXGIFactory2@@@ATL@@QBE_NPAUIDXGIFactory2@@@Z ; ATL::CComPtrBase<IDXGIFactory2>::operator!=
PUBLIC	??8?$CComPtrBase@UIDXGIFactory2@@@ATL@@QBE_NPAUIDXGIFactory2@@@Z ; ATL::CComPtrBase<IDXGIFactory2>::operator==
PUBLIC	??0?$CComPtr@UIDXGIFactory2@@@ATL@@QAE@XZ	; ATL::CComPtr<IDXGIFactory2>::CComPtr<IDXGIFactory2>
PUBLIC	??1?$CComPtr@UIDXGIFactory2@@@ATL@@QAE@XZ	; ATL::CComPtr<IDXGIFactory2>::~CComPtr<IDXGIFactory2>
PUBLIC	??0?$CComQIPtr@UIDXGIFactory2@@$1?_GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z ; ATL::CComQIPtr<IDXGIFactory2,&_GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0>::CComQIPtr<IDXGIFactory2,&_GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0>
PUBLIC	??1?$CComQIPtr@UIDXGIFactory2@@$1?_GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0@@3U__s_GUID@@B@ATL@@QAE@XZ ; ATL::CComQIPtr<IDXGIFactory2,&_GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0>::~CComQIPtr<IDXGIFactory2,&_GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0>
PUBLIC	??0?$CComPtrBase@UIDXGIFactory3@@@ATL@@IAE@PAUIDXGIFactory3@@@Z ; ATL::CComPtrBase<IDXGIFactory3>::CComPtrBase<IDXGIFactory3>
PUBLIC	??1?$CComPtrBase@UIDXGIFactory3@@@ATL@@QAE@XZ	; ATL::CComPtrBase<IDXGIFactory3>::~CComPtrBase<IDXGIFactory3>
PUBLIC	??0?$CComPtr@UIDXGIFactory3@@@ATL@@QAE@PAUIDXGIFactory3@@@Z ; ATL::CComPtr<IDXGIFactory3>::CComPtr<IDXGIFactory3>
PUBLIC	??1?$CComPtr@UIDXGIFactory3@@@ATL@@QAE@XZ	; ATL::CComPtr<IDXGIFactory3>::~CComPtr<IDXGIFactory3>
PUBLIC	??0?$CComPtrBase@UIDXGIFactory4@@@ATL@@IAE@PAUIDXGIFactory4@@@Z ; ATL::CComPtrBase<IDXGIFactory4>::CComPtrBase<IDXGIFactory4>
PUBLIC	??1?$CComPtrBase@UIDXGIFactory4@@@ATL@@QAE@XZ	; ATL::CComPtrBase<IDXGIFactory4>::~CComPtrBase<IDXGIFactory4>
PUBLIC	??0?$CComPtr@UIDXGIFactory4@@@ATL@@QAE@PAUIDXGIFactory4@@@Z ; ATL::CComPtr<IDXGIFactory4>::CComPtr<IDXGIFactory4>
PUBLIC	??1?$CComPtr@UIDXGIFactory4@@@ATL@@QAE@XZ	; ATL::CComPtr<IDXGIFactory4>::~CComPtr<IDXGIFactory4>
PUBLIC	??0?$CComPtrBase@UIDXGIFactory5@@@ATL@@IAE@PAUIDXGIFactory5@@@Z ; ATL::CComPtrBase<IDXGIFactory5>::CComPtrBase<IDXGIFactory5>
PUBLIC	??1?$CComPtrBase@UIDXGIFactory5@@@ATL@@QAE@XZ	; ATL::CComPtrBase<IDXGIFactory5>::~CComPtrBase<IDXGIFactory5>
PUBLIC	??0?$CComPtr@UIDXGIFactory5@@@ATL@@QAE@PAUIDXGIFactory5@@@Z ; ATL::CComPtr<IDXGIFactory5>::CComPtr<IDXGIFactory5>
PUBLIC	??1?$CComPtr@UIDXGIFactory5@@@ATL@@QAE@XZ	; ATL::CComPtr<IDXGIFactory5>::~CComPtr<IDXGIFactory5>
PUBLIC	??0budget_thread_params_t@@QAE@XZ		; budget_thread_params_t::budget_thread_params_t
PUBLIC	??$QueryInterface@UIDXGIAdapter3@@@IUnknown@@QAGJPAPAUIDXGIAdapter3@@@Z ; IUnknown::QueryInterface<IDXGIAdapter3>
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> ><std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > > >
PUBLIC	??$?0PAUSK_D3D11_Stateblock_Lite@@@?$_Unique_ptr_base@USK_D3D11_Stateblock_Lite@@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@@std@@QAE@PAUSK_D3D11_Stateblock_Lite@@@Z ; std::_Unique_ptr_base<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> >::_Unique_ptr_base<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> ><SK_D3D11_Stateblock_Lite *>
PUBLIC	??$addressof@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const >
PUBLIC	??$move@AAU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z ; std::move<std::_Wrap_alloc<std::allocator<wchar_t> > &>
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > ><std::_Wrap_alloc<std::allocator<wchar_t> >,void>
PUBLIC	??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &>
PUBLIC	??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ; std::move<std::_Wrap_alloc<std::allocator<char> > &>
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>
PUBLIC	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	??$?0V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@$$QAV?$allocator@U?$_Tree_node@HPAX@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > ><std::allocator<std::_Tree_node<int,void *> > >
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@HPAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::operator++
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::operator--
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@HPAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::_Mynode
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@QAE@PAU?$_Tree_node@HPAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >::operator++
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >::operator++
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >::operator--
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >::operator==
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >::operator!=
PUBLIC	??$?0AAU?$_Wrap_alloc@V?$allocator@K@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAK@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@K@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<unsigned long *> >::_Wrap_alloc<std::allocator<unsigned long *> ><std::_Wrap_alloc<std::allocator<unsigned long> > &>
PUBLIC	??$addressof@PAK@std@@YAPAPAKAAPAK@Z		; std::addressof<unsigned long *>
PUBLIC	??$destroy@PAK@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAPAK@Z ; std::_Wrap_alloc<std::allocator<unsigned long> >::destroy<unsigned long *>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z		; std::addressof<wchar_t *>
PUBLIC	??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@_W@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	?address@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QBEPAU_Container_proxy@2@AAU32@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::address
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	??$?0AAU?$_Wrap_alloc@V?$allocator@K@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@K@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<unsigned long> > &>
PUBLIC	??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Deque_val<std::_Deque_simple_types<unsigned long> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Deque_val<std::_Deque_simple_types<unsigned long> >,1><>
PUBLIC	??$addressof@PAU?$_Tree_node@HPAX@std@@@std@@YAPAPAU?$_Tree_node@HPAX@0@AAPAU10@@Z ; std::addressof<std::_Tree_node<int,void *> *>
PUBLIC	??$destroy@PAU?$_Tree_node@HPAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@HPAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::destroy<std::_Tree_node<int,void *> *>
PUBLIC	??$?0ABU?$less@H@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@H@1@$$QAU_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>,1>::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>,1><std::less<int> const &,std::_Zero_then_variadic_args_t>
PUBLIC	??$addressof@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@H@std@@@0@AAV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<int> > >
PUBLIC	??$_Unfancy@K@std@@YAPAKPAK@Z			; std::_Unfancy<unsigned long>
PUBLIC	??$destroy@K@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAK@Z ; std::_Wrap_alloc<std::allocator<unsigned long> >::destroy<unsigned long>
PUBLIC	??$_Unfancy@_W@std@@YAPA_WPA_W@Z		; std::_Unfancy<wchar_t>
PUBLIC	??$_Min_value@I@std@@YAABIABI0@Z		; std::_Min_value<unsigned int>
PUBLIC	??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
PUBLIC	?pointer_to@?$pointer_traits@PAU_Container_proxy@std@@@std@@SAPAU_Container_proxy@2@AAU32@@Z ; std::pointer_traits<std::_Container_proxy *>::pointer_to
PUBLIC	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$addressof@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@@std@@YAPAV?$_Deque_val@U?$_Deque_simple_types@K@std@@@0@AAV10@@Z ; std::addressof<std::_Deque_val<std::_Deque_simple_types<unsigned long> > >
PUBLIC	??$swap@DX@std@@YAXAAD0@Z			; std::swap<char,void>
PUBLIC	??$addressof@H@std@@YAPAHAAH@Z			; std::addressof<int>
PUBLIC	??$destroy@H@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAEXPAH@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::destroy<int>
PUBLIC	??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
PUBLIC	??$construct@PAU?$_Tree_node@HPAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@HPAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::construct<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * &>
PUBLIC	??$insert@$0A@$0A@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@1@ABH@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::insert<0,0>
PUBLIC	??$forward@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > > >
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@X@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> ><std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,void>
PUBLIC	??$_Copy@U_Copy_tag@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXABV01@U_Copy_tag@01@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Copy<std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Copy_tag>
PUBLIC	??$?0AAPAUSK_D3D11_Stateblock_Lite@@@?$_Compressed_pair@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@PAUSK_D3D11_Stateblock_Lite@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAUSK_D3D11_Stateblock_Lite@@@Z ; std::_Compressed_pair<std::default_delete<SK_D3D11_Stateblock_Lite>,SK_D3D11_Stateblock_Lite *,1>::_Compressed_pair<std::default_delete<SK_D3D11_Stateblock_Lite>,SK_D3D11_Stateblock_Lite *,1><SK_D3D11_Stateblock_Lite * &>
PUBLIC	??$forward@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<wchar_t> > >
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><std::_Wrap_alloc<std::allocator<wchar_t> > >
PUBLIC	??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<char> > >
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >
PUBLIC	??$forward@U_One_then_variadic_args_t@std@@@std@@YA$$QAU_One_then_variadic_args_t@0@AAU10@@Z ; std::forward<std::_One_then_variadic_args_t>
PUBLIC	??$forward@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@YA$$QAV?$allocator@U?$_Tree_node@HPAX@std@@@0@AAV10@@Z ; std::forward<std::allocator<std::_Tree_node<int,void *> > >
PUBLIC	??$forward@AAU?$_Wrap_alloc@V?$allocator@K@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@K@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<unsigned long> > &>
PUBLIC	??$?0K@?$allocator@PAK@std@@QAE@ABV?$allocator@K@1@@Z ; std::allocator<unsigned long *>::allocator<unsigned long *><unsigned long>
PUBLIC	??$destroy@PAK@?$allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@PAPAK@Z ; std::allocator_traits<std::allocator<unsigned long> >::destroy<unsigned long *>
PUBLIC	??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$?0K@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@K@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><unsigned long>
PUBLIC	??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
PUBLIC	??$destroy@PAU?$_Tree_node@HPAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAPAU?$_Tree_node@HPAX@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<int,void *> > >::destroy<std::_Tree_node<int,void *> *>
PUBLIC	??$forward@ABU?$less@H@std@@@std@@YAABU?$less@H@0@ABU10@@Z ; std::forward<std::less<int> const &>
PUBLIC	??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z ; std::forward<std::_Zero_then_variadic_args_t>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1><>
PUBLIC	??$destroy@K@?$allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@PAK@Z ; std::allocator_traits<std::allocator<unsigned long> >::destroy<unsigned long>
PUBLIC	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$move@AAD@std@@YA$$QADAAD@Z			; std::move<char &>
PUBLIC	??$destroy@H@?$allocator_traits@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAH@Z ; std::allocator_traits<std::allocator<std::_Tree_node<int,void *> > >::destroy<int>
PUBLIC	??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z		; std::forward<wchar_t * &>
PUBLIC	??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$forward@AAPAU?$_Tree_node@HPAX@std@@@std@@YAAAPAU?$_Tree_node@HPAX@0@AAPAU10@@Z ; std::forward<std::_Tree_node<int,void *> * &>
PUBLIC	??$construct@PAU?$_Tree_node@HPAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAPAU?$_Tree_node@HPAX@1@AAPAU31@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<int,void *> > >::construct<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * &>
PUBLIC	??$distance@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@@std@@YAHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@0@0@Z ; std::distance<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > >
PUBLIC	??$_Traits_equal@U?$char_traits@_W@std@@@std@@YA_NQB_WI0I@Z ; std::_Traits_equal<std::char_traits<wchar_t> >
PUBLIC	??$_Eqrange@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@V12@@1@ABH@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Eqrange<int>
PUBLIC	??$_Insert_nohint@ABHU_Nil@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@1@_NABHU_Nil@1@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Insert_nohint<int const &,std::_Nil>
PUBLIC	??$?0ABU?$less@H@std@@U_One_then_variadic_args_t@1@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@H@1@$$QAU21@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>,1>::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>,1><std::less<int> const &,std::_One_then_variadic_args_t,std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > > >
PUBLIC	??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@HPAX@1@PAU21@0U_Copy_tag@01@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Copy_nodes<std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Copy_tag>
PUBLIC	??$forward@AAPAUSK_D3D11_Stateblock_Lite@@@std@@YAAAPAUSK_D3D11_Stateblock_Lite@@AAPAU1@@Z ; std::forward<SK_D3D11_Stateblock_Lite * &>
PUBLIC	??$destroy@PAK@?$allocator@K@std@@QAEXPAPAK@Z	; std::allocator<unsigned long>::destroy<unsigned long *>
PUBLIC	??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ; std::allocator<wchar_t>::destroy<wchar_t *>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>
PUBLIC	??$destroy@PAU?$_Tree_node@HPAX@std@@@?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAEXPAPAU?$_Tree_node@HPAX@1@@Z ; std::allocator<std::_Tree_node<int,void *> >::destroy<std::_Tree_node<int,void *> *>
PUBLIC	??$forward@_N@std@@YA$$QA_NAA_N@Z		; std::forward<bool>
PUBLIC	??$destroy@K@?$allocator@K@std@@QAEXPAK@Z	; std::allocator<unsigned long>::destroy<unsigned long>
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$destroy@H@?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAEXPAH@Z ; std::allocator<std::_Tree_node<int,void *> >::destroy<int>
PUBLIC	??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$construct@PAU?$_Tree_node@HPAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAEXPAPAU?$_Tree_node@HPAX@1@AAPAU21@@Z ; std::allocator<std::_Tree_node<int,void *> >::construct<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * &>
PUBLIC	??$_Distance1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@@std@@YAHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@0@0Uinput_iterator_tag@0@@Z ; std::_Distance1<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > >
PUBLIC	??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@0@ABV10@@Z ; std::addressof<std::_Tree_val<std::_Tree_simple_types<int> > const >
PUBLIC	??$?0AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@AAV01@X$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@V12@@std@@QAE@AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@1@0@Z ; std::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > >::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > ><std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > &,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > &,void,0>
PUBLIC	??$forward@ABH@std@@YAABHABH@Z			; std::forward<int const &>
PUBLIC	??$_Insert_at@ABHU_Nil@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@1@_NPAU?$_Tree_node@HPAX@1@ABHU_Nil@1@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Insert_at<int const &,std::_Nil>
PUBLIC	??$?0V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >,bool>::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >,bool><std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >,bool,void,0>
PUBLIC	??$?0AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >,bool>::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >,bool><std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > &,bool,void,0>
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1><std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > > >
PUBLIC	??$_Copy_or_move@HU?$integral_constant@_N$00@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@HPAX@1@AAHU_Copy_tag@01@U?$integral_constant@_N$00@1@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Copy_or_move<int,std::integral_constant<bool,1> >
PUBLIC	??$forward@AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@@std@@YAAAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > &>
PUBLIC	??$_Buynode_if_nil@ABH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@HPAX@1@U_Nil@1@ABH@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Buynode_if_nil<int const &>
PUBLIC	??$forward@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > >
PUBLIC	??$_Buynode@AAH@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@HPAX@1@AAH@Z ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Buynode<int &>
PUBLIC	??$move@AAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@0@AAU10@@Z ; std::move<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > > &>
PUBLIC	??$_Buynode@ABH@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@HPAX@1@ABH@Z ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Buynode<int const &>
PUBLIC	??$forward@AAH@std@@YAAAHAAH@Z			; std::forward<int &>
PUBLIC	??$construct@HAAH@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAEXPAHAAH@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::construct<int,int &>
PUBLIC	??$construct@HABH@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAEXPAHABH@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::construct<int,int const &>
PUBLIC	??$construct@HAAH@?$allocator_traits@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAHAAH@Z ; std::allocator_traits<std::allocator<std::_Tree_node<int,void *> > >::construct<int,int &>
PUBLIC	??$construct@HABH@?$allocator_traits@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAHABH@Z ; std::allocator_traits<std::allocator<std::_Tree_node<int,void *> > >::construct<int,int const &>
PUBLIC	??$construct@HAAH@?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAEXPAHAAH@Z ; std::allocator<std::_Tree_node<int,void *> >::construct<int,int &>
PUBLIC	??$construct@HABH@?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAEXPAHABH@Z ; std::allocator<std::_Tree_node<int,void *> >::construct<int,int const &>
PUBLIC	?mem_stats@@3PAUmemory_stats_t@@A		; mem_stats
PUBLIC	?mem_info@@3PAUmem_info_t@@A			; mem_info
PUBLIC	??_7_com_error@@6B@				; _com_error::`vftable'
PUBLIC	??_C@_1CI@KPMALOMG@?$AAI?$AAD?$AAi?$AAs?$AAp?$AAa?$AAt?$AAc?$AAh?$AA?5?$AAe?$AAr?$AAr?$AAo?$AAr?$AA?5?$AA?$CD?$AA?$CF?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@DOIMBAJG@?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?5?$AAe?$AAr?$AAr?$AAo?$AAr?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AAl?$AAX?$AA?$AA@ ; `string'
PUBLIC	?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A ; ATL::atlTraceGeneral
PUBLIC	?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A ; ATL::atlTraceCOM
PUBLIC	?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A ; ATL::atlTraceQI
PUBLIC	?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A ; ATL::atlTraceRegistrar
PUBLIC	?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A ; ATL::atlTraceRefcount
PUBLIC	?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A ; ATL::atlTraceWindowing
PUBLIC	?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A ; ATL::atlTraceControls
PUBLIC	?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A ; ATL::atlTraceHosting
PUBLIC	?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A ; ATL::atlTraceDBClient
PUBLIC	?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A ; ATL::atlTraceDBProvider
PUBLIC	?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A ; ATL::atlTraceSnapin
PUBLIC	?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A ; ATL::atlTraceNotImpl
PUBLIC	?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A ; ATL::atlTraceAllocation
PUBLIC	?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
PUBLIC	?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A ; ATL::atlTraceTime
PUBLIC	?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A ; ATL::atlTraceCache
PUBLIC	?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A ; ATL::atlTraceStencil
PUBLIC	?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A ; ATL::atlTraceString
PUBLIC	?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A ; ATL::atlTraceMap
PUBLIC	?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A ; ATL::atlTraceUtil
PUBLIC	?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A ; ATL::atlTraceSecurity
PUBLIC	?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A ; ATL::atlTraceSync
PUBLIC	?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A ; ATL::atlTraceISAPI
PUBLIC	?m_bInitFailed@CAtlBaseModule@ATL@@2_NA		; ATL::CAtlBaseModule::m_bInitFailed
PUBLIC	?_AtlComModule@ATL@@3VCAtlComModule@1@A		; ATL::_AtlComModule
PUBLIC	?_AtlWinModule@ATL@@3VCAtlWinModule@1@A		; ATL::_AtlWinModule
PUBLIC	__GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140
PUBLIC	??_R0?AVResourceProvider@CEGUI@@@8		; CEGUI::ResourceProvider `RTTI Type Descriptor'
PUBLIC	??_R0?AVDefaultResourceProvider@CEGUI@@@8	; CEGUI::DefaultResourceProvider `RTTI Type Descriptor'
PUBLIC	__GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da
PUBLIC	__GUID_6f15aaf2_d208_4e89_9ab4_489535d34f9c
PUBLIC	?SK_DXGI_RestrictResMax@@3V<lambda>@@A		; SK_DXGI_RestrictResMax
PUBLIC	?SK_DXGI_RestrictResMin@@3V<lambda>@@A		; SK_DXGI_RestrictResMin
PUBLIC	?dxgi_caps@@3Udxgi_caps_t@@A			; dxgi_caps
PUBLIC	__GUID_7b7166ec_21c7_44ae_b21a_c9ae321ae369
PUBLIC	__GUID_770aae78_f26f_4dba_a829_253c83d1b387
PUBLIC	__GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0
PUBLIC	__GUID_25483823_cd46_4c7d_86ca_47aa95b837bd
PUBLIC	__GUID_1bc6ea02_ef36_464f_bf0c_21ca39e5168a
PUBLIC	__GUID_7632e1f5_ee65_4dca_87fd_84cd75f8838d
PUBLIC	__GUID_2411e7e1_12ac_4ccf_bd14_9798e8534dc0
PUBLIC	__GUID_29038f61_3839_4626_91fd_086879011a05
PUBLIC	__GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5
PUBLIC	__GUID_645967a4_1392_4310_a798_8053ce3e93fd
PUBLIC	__GUID_a04bfb29_08ef_43d6_a49c_a9bdbdcbe686
PUBLIC	__GUID_cafcb56c_6ac3_4889_bf47_9e23bbd260ec
PUBLIC	__GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa
PUBLIC	__GUID_a8be2ac4_199f_4946_b331_79599fb98de7
PUBLIC	??_C@_1BA@EMGLPOHC@?$AAD?$AAi?$AAs?$AAc?$AAa?$AAr?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@MBNPLCBJ@?$AAS?$AAe?$AAq?$AAu?$AAe?$AAn?$AAt?$AAi?$AAa?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@BGMELJBK@?$AA?$DM?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?$DO?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CA@DEGLGFCG@?$AAF?$AAl?$AAi?$AAp?$AA?5?$AAS?$AAe?$AAq?$AAu?$AAe?$AAn?$AAt?$AAi?$AAa?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BK@OJAHAHGF@?$AAF?$AAl?$AAi?$AAp?$AA?5?$AAD?$AAi?$AAs?$AAc?$AAa?$AAr?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@PMICBOA@?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAe?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@EOMFJOKP@?$AAF?$AAu?$AAl?$AAl?$AAs?$AAc?$AAr?$AAe?$AAe?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BI@DELFJJPB@?$AAU?$AAn?$AAs?$AAp?$AAe?$AAc?$AAi?$AAf?$AAi?$AAe?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BI@JFLEIIEG@?$AAP?$AAr?$AAo?$AAg?$AAr?$AAe?$AAs?$AAs?$AAi?$AAv?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CA@MIMOHAAK@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAl?$AAa?$AAc?$AAe?$AAd?$AA?5?$AAE?$AAv?$AAe?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BO@NBKANNIC@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAl?$AAa?$AAc?$AAe?$AAd?$AA?5?$AAO?$AAd?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@NODLAKGH@?$AAC?$AAe?$AAn?$AAt?$AAe?$AAr?$AAe?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@OKCKFGLA@?$AAS?$AAt?$AAr?$AAe?$AAt?$AAc?$AAh?$AAe?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BAE@FEHGBMOO@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AAS?$AAw?$AAa?$AAp?$AAC?$AAh?$AAa?$AAi?$AAn?$AA?3?$AA?5?$AA?$CI?$AA?$CF?$AAl?$AAu?$AAx?$AA?$CF?$AAl@ ; `string'
PUBLIC	??_C@_1HA@INGGDHHB@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAU?$AAs?$AAe?$AAr?$AA?9?$AAR?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AAe?$AAd?$AA?5@ ; `string'
PUBLIC	??_C@_1JG@HCAIICBG@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAD?$AAi?$AAs?$AAp?$AAl?$AAa?$AAy?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd@ ; `string'
PUBLIC	??_C@_1JG@LPALCGFK@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAD?$AAi?$AAs?$AAp?$AAl?$AAa?$AAy?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd@ ; `string'
PUBLIC	??_C@_1JA@NDGFBELE@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA2?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAs?$AAR?$AAG?$AAB?$AA?5?$AA?$CI?$AAB?$AA8?$AAG?$AA8?$AAR?$AA8?$AAA?$AA8?$AA?$CJ@ ; `string'
PUBLIC	??_C@_1JA@CCHCBLHJ@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA2?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAs?$AAR?$AAG?$AAB?$AA?5?$AA?$CI?$AAR?$AA8?$AAG?$AA8?$AAB?$AA8?$AAA?$AA8?$AA?$CJ@ ; `string'
PUBLIC	??_C@_1KK@LPPCBMFA@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA2?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAR?$AAG?$AAB?$AAA?$AA?5?$AA1?$AA0?$AA?3?$AA1?$AA0?$AA?3?$AA1?$AA0?$AA?3?$AA2@ ; `string'
PUBLIC	??_C@_1GI@GAEBCHMN@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AAO?$AAv@ ; `string'
PUBLIC	??_C@_1FC@PILPBEPG@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAT?$AAe?$AAa?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAO?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?3@ ; `string'
PUBLIC	??_C@_1HK@PGANLAKP@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAS?$AAc?$AAa?$AAl?$AAi?$AAn?$AAg?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd@ ; `string'
PUBLIC	??_C@_1HM@EKHBGJHP@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAS?$AAc?$AAa?$AAn?$AAl?$AAi?$AAn?$AAe?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi@ ; `string'
PUBLIC	??_C@_1HM@GOOAFJFG@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAR?$AAe?$AAf?$AAr?$AAe?$AAs?$AAh?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd@ ; `string'
PUBLIC	??_C@_17PBAHFJOA@?$AAY?$AAe?$AAs?$AA?$AA@	; `string'
PUBLIC	??_C@_15BICKNCBF@?$AAN?$AAo?$AA?$AA@		; `string'
PUBLIC	??_C@_19EMFBKLJE@?$AAF?$AAl?$AAi?$AAp?$AA?$AA@	; `string'
PUBLIC	??_C@_1BI@PKCOFIGO@?$AAT?$AAr?$AAa?$AAd?$AAi?$AAt?$AAi?$AAo?$AAn?$AAa?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_1IK@KCJJDMDA@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA2?$AA?5?$AA?$FN?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAU?$AAs?$AAi?$AAn?$AAg?$AA?5?$AA?$CF?$AAs?$AA?5?$AAP?$AAr?$AAe?$AAs?$AAe?$AAn?$AAt@ ; `string'
PUBLIC	?first@?2??SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z@4_NA ; `SK_DXGI_CreateSwapChain_PostInit'::`3'::first
PUBLIC	?first@?M@??SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z@4_NA ; `SK_DXGI_CreateSwapChain_PostInit'::`12'::first
PUBLIC	__GUID_77db970f_6276_48ba_ba28_070143b4392c
PUBLIC	??_C@_1GE@BOIALL@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAS?$AAw?$AAa?$AAp?$AAc?$AAh?$AAa?$AAi?$AAn?$AA?5?$AAF@ ; `string'
PUBLIC	??_C@_1FO@CKMCMFKO@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AAF?$AAr?$AAa?$AAm@ ; `string'
PUBLIC	??_C@_1ME@IOFODDLL@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?$FL?$AA?$EA?$AA?$FN?$AA?5?$AA?5?$AAR?$AAe?$AAt?$AAu?$AAr?$AAn?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AA?5?$AA?9?$AA?5@ ; `string'
PUBLIC	??_C@_1BBK@GBNFCBJD@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?$FL?$AA?$EA?$AA?$FN?$AA?5?$AA?5?$AAR?$AAe?$AAt?$AAu?$AAr?$AAn?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AA?5?$AA?9?$AA?5@ ; `string'
PUBLIC	??_C@_1BCK@OGPEHLJN@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?$FL?$AA?$EA?$AA?$FN?$AA?5?$AA?5?$AAR?$AAe?$AAt?$AAu?$AAr?$AAn?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AA?5?$AA?9?$AA?5@ ; `string'
PUBLIC	?budget_thread@@3Ubudget_thread_params_t@@A	; budget_thread
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	__GUID_bb2c6faa_b5fb_4082_8e6b_388b8cfa90e1
PUBLIC	__GUID_54ec77fa_1377_44e6_8c32_88fd5f44c84c
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R4_com_error@@6B@				; _com_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_com_error@@@8				; _com_error `RTTI Type Descriptor'
PUBLIC	??_R3_com_error@@8				; _com_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_com_error@@8				; _com_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_com_error@@8			; _com_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3c23d70a
PUBLIC	__real@7fc00000
PUBLIC	__xmm@00000001000000060000000200000001
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_abort:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	___std_terminate:PROC
EXTRN	__imp___invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp__memmove:PROC
EXTRN	__imp___wcsicmp:PROC
EXTRN	__imp__DeleteFileW@4:PROC
EXTRN	__imp__GetFileAttributesW@4:PROC
EXTRN	__imp__DecodePointer@4:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__RaiseException@16:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__InitializeCriticalSectionEx@12:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__SetEvent@4:PROC
EXTRN	__imp__ResetEvent@4:PROC
EXTRN	__imp__SleepEx@8:PROC
EXTRN	__imp__WaitForSingleObjectEx@12:PROC
EXTRN	__imp__CreateEventW@16:PROC
EXTRN	__imp__SignalObjectAndWait@16:PROC
EXTRN	__imp__CreateThread@24:PROC
EXTRN	__imp__GetCurrentThread@0:PROC
EXTRN	__imp__GetCurrentThreadId@0:PROC
EXTRN	__imp__TerminateThread@8:PROC
EXTRN	__imp__GetLocalTime@4:PROC
EXTRN	__imp__VirtualProtect@16:PROC
EXTRN	__imp__GetModuleHandleW@4:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__LocalAlloc@8:PROC
EXTRN	__imp__LocalFree@4:PROC
EXTRN	__imp__WaitForMultipleObjects@16:PROC
EXTRN	__imp__FormatMessageW@28:PROC
EXTRN	__imp__lstrcmpW@8:PROC
EXTRN	__imp__lstrcatA@8:PROC
EXTRN	__imp__lstrcatW@8:PROC
EXTRN	__imp__lstrlenW@4:PROC
EXTRN	__imp__LoadLibraryW@4:PROC
EXTRN	__imp__CopyFileExW@24:PROC
EXTRN	__imp__UnregisterClassW@8:PROC
EXTRN	__imp__IsWindow@4:PROC
EXTRN	__imp__BringWindowToTop@4:PROC
EXTRN	__imp__MsgWaitForMultipleObjectsEx@20:PROC
EXTRN	__imp__SetActiveWindow@4:PROC
EXTRN	__imp__SetForegroundWindow@4:PROC
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	__imp__EnumDisplaySettingsW@12:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp___wgetenv:PROC
EXTRN	__imp__wcstombs:PROC
EXTRN	__swprintf:PROC
EXTRN	_swprintf_s:PROC
EXTRN	__snprintf:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	__imp_?_Xout_of_range@std@@YAXPBD@Z:PROC
EXTRN	?WaitForInit@@YAXXZ:PROC			; WaitForInit
EXTRN	?SK_StartupCore@@YG_NPB_WPAX@Z:PROC		; SK_StartupCore
EXTRN	?SK_ShutdownCore@@YG_NPB_W@Z:PROC		; SK_ShutdownCore
EXTRN	?SK_BeginBufferSwap@@YGXXZ:PROC			; SK_BeginBufferSwap
EXTRN	?SK_EndBufferSwap@@YGJJPAUIUnknown@@@Z:PROC	; SK_EndBufferSwap
EXTRN	?SK_DescribeHRESULT@@YGPB_WJ@Z:PROC		; SK_DescribeHRESULT
EXTRN	?SK_GetConfigPath@@YGPB_WXZ:PROC		; SK_GetConfigPath
EXTRN	?SK_GetDLL@@YGPAUHINSTANCE__@@XZ:PROC		; SK_GetDLL
EXTRN	?SK_GetDLLRole@@YG?AW4DLL_ROLE@@XZ:PROC		; SK_GetDLLRole
EXTRN	?SK_IsHostAppSKIM@@YA_NXZ:PROC			; SK_IsHostAppSKIM
EXTRN	?SK_IsInjected@@YG_N_N@Z:PROC			; SK_IsInjected
EXTRN	?SK_Win32_CreateDummyWindow@@YAPAUHWND__@@XZ:PROC ; SK_Win32_CreateDummyWindow
EXTRN	?SK_Win32_CleanupDummyWindow@@YAXXZ:PROC	; SK_Win32_CleanupDummyWindow
EXTRN	__imp__CoUninitialize@0:PROC
EXTRN	__imp__CoInitializeEx@8:PROC
EXTRN	__imp__StringFromIID@8:PROC
EXTRN	__imp__CoTaskMemFree@4:PROC
EXTRN	?SK_LoadPlugIns32@@YAXXZ:PROC			; SK_LoadPlugIns32
EXTRN	?SK_GetHostApp@@YAPB_WXZ:PROC			; SK_GetHostApp
EXTRN	?SK_GetCallerName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAX@Z:PROC ; SK_GetCallerName
EXTRN	?SK_GetModuleName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHINSTANCE__@@@Z:PROC ; SK_GetModuleName
EXTRN	?SK_D3D11_Init@@YA_NXZ:PROC			; SK_D3D11_Init
EXTRN	?SK_D3D11_InitTextures@@YAXXZ:PROC		; SK_D3D11_InitTextures
EXTRN	?SK_D3D11_Shutdown@@YAXXZ:PROC			; SK_D3D11_Shutdown
EXTRN	?SK_D3D11_EnableHooks@@YAXXZ:PROC		; SK_D3D11_EnableHooks
EXTRN	?SK_D3D12_Init@@YA_NXZ:PROC			; SK_D3D12_Init
EXTRN	_NvAPI_D3D_GetObjectHandleForResource:PROC
EXTRN	?SK_D3D11_TexCacheCheckpoint@@YGXXZ:PROC	; SK_D3D11_TexCacheCheckpoint
EXTRN	?SK_D3D11_UpdateRenderStats@@YGXPAUIDXGISwapChain@@@Z:PROC ; SK_D3D11_UpdateRenderStats
EXTRN	?HookD3D11@@YGIPAX@Z:PROC			; HookD3D11
EXTRN	?update@gsync_s@SK_RenderBackend_V2@@QAEXXZ:PROC ; SK_RenderBackend_V2::gsync_s::update
EXTRN	?releaseOwnedResources@SK_RenderBackend_V2@@QAEXXZ:PROC ; SK_RenderBackend_V2::releaseOwnedResources
EXTRN	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ:PROC ; SK_GetCurrentRenderBackend
EXTRN	?SK_BootDXGI@@YAXXZ:PROC			; SK_BootDXGI
EXTRN	?SK_InstallWindowHook@@YAXPAUHWND__@@@Z:PROC	; SK_InstallWindowHook
EXTRN	?SK_SetWindowResX@@YAXJ@Z:PROC			; SK_SetWindowResX
EXTRN	?SK_SetWindowResY@@YAXJ@Z:PROC			; SK_SetWindowResY
EXTRN	??_E_com_error@@UAEPAXI@Z:PROC			; _com_error::`vector deleting destructor'
EXTRN	?CountSLIGPUs@NVAPI@sk@@YAHXZ:PROC		; sk::NVAPI::CountSLIGPUs
EXTRN	?FindGPUByDXGIName@NVAPI@sk@@YAPAUDXGI_ADAPTER_DESC@@PB_W@Z:PROC ; sk::NVAPI::FindGPUByDXGIName
EXTRN	?LogEx@iSK_Logger@@UAAX_NQB_WZZ:PROC		; iSK_Logger::LogEx
EXTRN	?Log@iSK_Logger@@UAAXQB_WZZ:PROC		; iSK_Logger::Log
EXTRN	?Reinstall@CrashHandler@Diagnostics@SK@@YAXXZ:PROC ; SK::Diagnostics::CrashHandler::Reinstall
EXTRN	?SK_SummarizeCaller@@YG?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAX@Z:PROC ; SK_SummarizeCaller
EXTRN	_MH_CreateHook@12:PROC
EXTRN	_MH_EnableHook@4:PROC
EXTRN	_MH_QueueDisableHook@4:PROC
EXTRN	_MH_ApplyQueued@0:PROC
EXTRN	_MH_ApplyQueuedEx@4:PROC
EXTRN	?SK_CreateDLLHook2@@YG?AW4MH_STATUS@@PB_WPBDPAXPAPAX3@Z:PROC ; SK_CreateDLLHook2
EXTRN	?SK_CreateVFTableHookEx@@YG?AW4MH_STATUS@@PB_WPAPAXKPAX1I@Z:PROC ; SK_CreateVFTableHookEx
EXTRN	?SK_CreateVFTableHook2@@YG?AW4MH_STATUS@@PB_WPAPAXKPAX1@Z:PROC ; SK_CreateVFTableHook2
EXTRN	?SK_RemoveHook@@YG?AW4MH_STATUS@@PAX@Z:PROC	; SK_RemoveHook
EXTRN	?SK_GetCommandProcessor@@YGPAUSK_ICommandProcessor@@XZ:PROC ; SK_GetCommandProcessor
EXTRN	?SK_Steam_ClearPopups@@YAXXZ:PROC		; SK_Steam_ClearPopups
EXTRN	?SK_Steam_DrawOSD@@YAXXZ:PROC			; SK_Steam_DrawOSD
EXTRN	?SK_TLS_Bottom@@YGPAUSK_TLS@@XZ:PROC		; SK_TLS_Bottom
EXTRN	?ImGui_ImplDX11_Init@@YA_NPAUIDXGISwapChain@@PAUID3D11Device@@PAUID3D11DeviceContext@@@Z:PROC ; ImGui_ImplDX11_Init
EXTRN	?ImGui_ImplDX11_Shutdown@@YAXXZ:PROC		; ImGui_ImplDX11_Shutdown
EXTRN	?SK_D3D11_EndFrame@@YAXXZ:PROC			; SK_D3D11_EndFrame
EXTRN	__imp_??1String@CEGUI@@QAE@XZ:PROC
EXTRN	__imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z:PROC
EXTRN	__imp_?init@String@CEGUI@@AAEXXZ:PROC
EXTRN	__imp_??HCEGUI@@YA?AVString@0@ABV10@PBE@Z:PROC
EXTRN	__imp_?setDefaultResourceGroup@AnimationManager@CEGUI@@SAXABVString@2@@Z:PROC
EXTRN	__imp_?getDllSingleton@?$Singleton@VLogger@CEGUI@@@CEGUI@@SAAAVLogger@2@XZ:PROC
EXTRN	__imp_?setResourceGroupDirectory@DefaultResourceProvider@CEGUI@@QAEXABVString@2@0@Z:PROC
EXTRN	__imp_?isPropertyPresent@PropertySet@CEGUI@@QBE_NABVString@2@@Z:PROC
EXTRN	__imp_?setProperty@PropertySet@CEGUI@@QAEXABVString@2@0@Z:PROC
EXTRN	__imp_?setDefaultResourceGroup@Font@CEGUI@@SAXABVString@2@@Z:PROC
EXTRN	__imp_?getDllSingleton@?$Singleton@VSystem@CEGUI@@@CEGUI@@SAAAVSystem@2@XZ:PROC
EXTRN	__imp_?getDllSingletonPtr@?$Singleton@VSystem@CEGUI@@@CEGUI@@SAPAVSystem@2@XZ:PROC
EXTRN	__imp_?getDefaultGUIContext@System@CEGUI@@QBEAAVGUIContext@2@XZ:PROC
EXTRN	__imp_?renderAllGUIContexts@System@CEGUI@@QAEXXZ:PROC
EXTRN	__imp_?getResourceProvider@System@CEGUI@@QBEPAVResourceProvider@2@XZ:PROC
EXTRN	__imp_?getDllSingletonPtr@?$Singleton@VFontManager@CEGUI@@@CEGUI@@SAPAVFontManager@2@XZ:PROC
EXTRN	__imp_?createFromFile@?$NamedXMLResourceManager@VFont@CEGUI@@VFont_xmlHandler@2@@CEGUI@@QAEAAVFont@2@ABVString@2@0W4XMLResourceExistsAction@2@@Z:PROC
EXTRN	__imp_?setRootWindow@GUIContext@CEGUI@@QAEXPAVWindow@2@@Z:PROC
EXTRN	__imp_?setImagesetDefaultResourceGroup@ImageManager@CEGUI@@SAXABVString@2@@Z:PROC
EXTRN	__imp_?getDllSingletonPtr@?$Singleton@VSchemeManager@CEGUI@@@CEGUI@@SAPAVSchemeManager@2@XZ:PROC
EXTRN	__imp_?createFromFile@?$NamedXMLResourceManager@VScheme@CEGUI@@VScheme_xmlHandler@2@@CEGUI@@QAEAAVScheme@2@ABVString@2@0W4XMLResourceExistsAction@2@@Z:PROC
EXTRN	__imp_?setDefaultResourceGroup@Scheme@CEGUI@@SAXABVString@2@@Z:PROC
EXTRN	__imp_?setDefaultResourceGroup@ScriptModule@CEGUI@@SAXABVString@2@@Z:PROC
EXTRN	__imp_?getDllSingleton@?$Singleton@VWindowManager@CEGUI@@@CEGUI@@SAAAVWindowManager@2@XZ:PROC
EXTRN	__imp_?createWindow@WindowManager@CEGUI@@QAEPAVWindow@2@ABVString@2@0@Z:PROC
EXTRN	__imp_?loadLayoutFromFile@WindowManager@CEGUI@@QAEPAVWindow@2@ABVString@2@0P6A_NPAV32@AAV42@2PAX@Z3@Z:PROC
EXTRN	__imp_?cleanDeadPool@WindowManager@CEGUI@@QAEXXZ:PROC
EXTRN	__imp_?setDefaultResourceGroup@WindowManager@CEGUI@@SAXABVString@2@@Z:PROC
EXTRN	__imp_?setDefaultResourceGroup@WidgetLookManager@CEGUI@@SAXABVString@2@@Z:PROC
EXTRN	__imp_?bootstrapSystem@Direct3D11Renderer@CEGUI@@SAAAV12@PAUID3D11Device@@PAUID3D11DeviceContext@@H@Z:PROC
EXTRN	__imp_?destroySystem@Direct3D11Renderer@CEGUI@@SAXXZ:PROC
EXTRN	?getInstance@SK_TextOverlayManager@@SAPAV1@XZ:PROC ; SK_TextOverlayManager::getInstance
EXTRN	?resetAllOverlays@SK_TextOverlayManager@@QAEXPAVRenderer@CEGUI@@@Z:PROC ; SK_TextOverlayManager::resetAllOverlays
EXTRN	?drawAllOverlays@SK_TextOverlayManager@@QAEMMM_N@Z:PROC ; SK_TextOverlayManager::drawAllOverlays
EXTRN	?destroyAllOverlays@SK_TextOverlayManager@@QAEXXZ:PROC ; SK_TextOverlayManager::destroyAllOverlays
EXTRN	?getInstance@SK_PopupManager@@SAPAV1@XZ:PROC	; SK_PopupManager::getInstance
EXTRN	?destroyAllPopups@SK_PopupManager@@QAEXXZ:PROC	; SK_PopupManager::destroyAllPopups
EXTRN	?SK_D3D11_ResetTexCache@@YGXXZ:PROC		; SK_D3D11_ResetTexCache
EXTRN	?SK_D3D12_UpdateRenderStats@@YGXPAUIDXGISwapChain@@@Z:PROC ; SK_D3D12_UpdateRenderStats
EXTRN	?SK_ImGui_DrawFrame@@YAKKPAX@Z:PROC		; SK_ImGui_DrawFrame
EXTRN	?PresentCallback@@YGJPAUIDXGISwapChain@@II@Z:PROC ; PresentCallback
EXTRN	??0?$SK_IVarStub@H@@QAE@PAHPAUSK_IVariableListener@@@Z:PROC ; SK_IVarStub<int>::SK_IVarStub<int>
EXTRN	??0?$SK_IVarStub@_N@@QAE@PA_NPAUSK_IVariableListener@@@Z:PROC ; SK_IVarStub<bool>::SK_IVarStub<bool>
EXTRN	?getNamedAddress@SK_Inject_AddressCacheRegistry@@QAEIPB_WPBDW4SK_SYS_CPUArch@@@Z:PROC ; SK_Inject_AddressCacheRegistry::getNamedAddress
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___RTDynamicCast:PROC
EXTRN	__except_handler3:PROC
EXTRN	__ftoul3:PROC
EXTRN	__ultod3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	?budget_mutex@@3PAVSK_Thread_HybridSpinlock@@A:DWORD ; budget_mutex
EXTRN	?backend_dll@@3PAUHINSTANCE__@@A:DWORD		; backend_dll
EXTRN	?__SK_DLL_Ending@@3JC:DWORD			; __SK_DLL_Ending
EXTRN	?nvapi_init@@3HA:DWORD				; nvapi_init
EXTRN	_IID_IDXGIFactory2:BYTE
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?g_pD3D11Dev@@3PAUID3D11Device@@A:DWORD		; g_pD3D11Dev
EXTRN	?SK_D3D11_Textures@@3VSK_D3D11_TexMgr@@A:BYTE	; SK_D3D11_Textures
EXTRN	?request_mode_change@@3W4mode_change_request_e@@A:DWORD ; request_mode_change
EXTRN	?game_window@@3Usk_window_s@@A:BYTE		; game_window
EXTRN	?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A:BYTE	; ATL::_AtlBaseModule
EXTRN	___ImageBase:BYTE
EXTRN	?nv_hardware@NVAPI@sk@@3_NA:BYTE		; sk::NVAPI::nv_hardware
EXTRN	?config@@3Usk_config_t@@A:BYTE			; config
EXTRN	?dll_log@@3UiSK_Logger@@A:BYTE			; dll_log
EXTRN	?budget_log@@3UiSK_Logger@@A:BYTE		; budget_log
EXTRN	?LoadLibraryW_Original@@3P6GPAUHINSTANCE__@@PB_W@ZA:DWORD ; LoadLibraryW_Original
EXTRN	?cs_mmio@@3VSK_Thread_HybridSpinlock@@A:DWORD	; cs_mmio
EXTRN	?SK_DXGI_FullStateCache@@3_NA:BYTE		; SK_DXGI_FullStateCache
EXTRN	?SK_Inject_AddressManager@@3PAVSK_Inject_AddressCacheRegistry@@A:DWORD ; SK_Inject_AddressManager
EXTRN	?pfnD3D11CreateDeviceAndSwapChain@@3PAXA:DWORD	; pfnD3D11CreateDeviceAndSwapChain
EXTRN	?SK_D3D11_need_tex_reset@@3_NA:BYTE		; SK_D3D11_need_tex_reset
EXTRN	__fltused:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
_BSS	SEGMENT
?mem_info@@3PAUmem_info_t@@A DB 0230H DUP (?)		; mem_info
_BSS	ENDS
;	COMDAT ?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A
_BSS	SEGMENT
?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceGeneral
_BSS	ENDS
;	COMDAT ?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A
_BSS	SEGMENT
?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceCOM
_BSS	ENDS
;	COMDAT ?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A
_BSS	SEGMENT
?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceQI
_BSS	ENDS
;	COMDAT ?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A
_BSS	SEGMENT
?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceRegistrar
_BSS	ENDS
;	COMDAT ?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A
_BSS	SEGMENT
?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceRefcount
_BSS	ENDS
;	COMDAT ?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A
_BSS	SEGMENT
?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceWindowing
_BSS	ENDS
;	COMDAT ?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A
_BSS	SEGMENT
?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceControls
_BSS	ENDS
;	COMDAT ?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A
_BSS	SEGMENT
?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceHosting
_BSS	ENDS
;	COMDAT ?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceDBClient
_BSS	ENDS
;	COMDAT ?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceDBProvider
_BSS	ENDS
;	COMDAT ?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSnapin
_BSS	ENDS
;	COMDAT ?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceNotImpl
_BSS	ENDS
;	COMDAT ?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceAllocation
_BSS	ENDS
;	COMDAT ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceException
_BSS	ENDS
;	COMDAT ?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceTime
_BSS	ENDS
;	COMDAT ?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceCache
_BSS	ENDS
;	COMDAT ?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceStencil
_BSS	ENDS
;	COMDAT ?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceString
_BSS	ENDS
;	COMDAT ?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceMap
_BSS	ENDS
;	COMDAT ?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceUtil
_BSS	ENDS
;	COMDAT ?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSecurity
_BSS	ENDS
;	COMDAT ?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSync
_BSS	ENDS
;	COMDAT ?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceISAPI
_BSS	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_BSS	SEGMENT
?m_bInitFailed@CAtlBaseModule@ATL@@2_NA DB 01H DUP (?)	; ATL::CAtlBaseModule::m_bInitFailed
_BSS	ENDS
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT
?_AtlWinModule@ATL@@3VCAtlWinModule@1@A DB 02cH DUP (?)	; ATL::_AtlWinModule
_BSS	ENDS
_BSS	SEGMENT
?SK_DXGI_RestrictResMax@@3V<lambda>@@A DB 01H DUP (?)	; SK_DXGI_RestrictResMax
	ALIGN	4

?SK_DXGI_RestrictResMin@@3V<lambda>@@A DB 01H DUP (?)	; SK_DXGI_RestrictResMin
	ALIGN	4

?dxgi_caps@@3Udxgi_caps_t@@A DB 0cH DUP (?)		; dxgi_caps
_BSS	ENDS
;	COMDAT ?hooked@?1??SK_DXGI_BeginHooking@@YAXXZ@4KC
_BSS	SEGMENT
?hooked@?1??SK_DXGI_BeginHooking@@YAXXZ@4KC DD 01H DUP (?) ; `SK_DXGI_BeginHooking'::`2'::hooked
_BSS	ENDS
;	COMDAT ?logged@?BL@??SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z@4_NA
_BSS	SEGMENT
?logged@?BL@??SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z@4_NA DB 01H DUP (?) ; `SK_CEGUI_DrawD3D11'::`27'::logged
_BSS	ENDS
;	COMDAT ?logged@?CF@??SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z@4_NA
_BSS	SEGMENT
?logged@?CF@??SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z@4_NA DB 01H DUP (?) ; `SK_CEGUI_DrawD3D11'::`37'::logged
_BSS	ENDS
;	COMDAT ?logged@?CM@??SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z@4_NA
_BSS	SEGMENT
?logged@?CM@??SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z@4_NA DB 01H DUP (?) ; `SK_CEGUI_DrawD3D11'::`44'::logged
_BSS	ENDS
;	COMDAT ?logged@?2??Present1Callback@@YGJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@Z@4_NA
_BSS	SEGMENT
?logged@?2??Present1Callback@@YGJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@Z@4_NA DB 01H DUP (?) ; `Present1Callback'::`3'::logged
_BSS	ENDS
;	COMDAT ?nest@?9??SK_DXGI_Present@@YAJPAUIDXGISwapChain@@II@Z@4JC
_BSS	SEGMENT
?nest@?9??SK_DXGI_Present@@YAJPAUIDXGISwapChain@@II@Z@4JC DD 01H DUP (?) ; `SK_DXGI_Present'::`10'::nest
_BSS	ENDS
;	COMDAT ?_default_impl@?1??DXGID3D10CreateDevice@@YGJPAUHINSTANCE__@@PAUIDXGIFactory@@PAUIDXGIAdapter@@IPAX3@Z@4P6GJ012I33@ZA
_BSS	SEGMENT
?_default_impl@?1??DXGID3D10CreateDevice@@YGJPAUHINSTANCE__@@PAUIDXGIFactory@@PAUIDXGIAdapter@@IPAX3@Z@4P6GJ012I33@ZA DD 01H DUP (?) ; `DXGID3D10CreateDevice'::`2'::_default_impl
_BSS	ENDS
;	COMDAT ?_default_impl@?1??DXGID3D10CreateLayeredDevice@@YGJUUNKNOWN5@@@Z@4P6GJ0@ZA
_BSS	SEGMENT
?_default_impl@?1??DXGID3D10CreateLayeredDevice@@YGJUUNKNOWN5@@@Z@4P6GJ0@ZA DD 01H DUP (?) ; `DXGID3D10CreateLayeredDevice'::`2'::_default_impl
_BSS	ENDS
;	COMDAT ?_default_impl@?1??DXGID3D10GetLayeredDeviceSize@@YGKPBXI@Z@4P6GK0I@ZA
_BSS	SEGMENT
?_default_impl@?1??DXGID3D10GetLayeredDeviceSize@@YGKPBXI@Z@4P6GK0I@ZA DD 01H DUP (?) ; `DXGID3D10GetLayeredDeviceSize'::`2'::_default_impl
_BSS	ENDS
;	COMDAT ?_default_impl@?1??DXGID3D10RegisterLayers@@YGJPBXI@Z@4P6GJ0I@ZA
_BSS	SEGMENT
?_default_impl@?1??DXGID3D10RegisterLayers@@YGJPBXI@Z@4P6GJ0I@ZA DD 01H DUP (?) ; `DXGID3D10RegisterLayers'::`2'::_default_impl
_BSS	ENDS
;	COMDAT ?_default_impl@?1??DXGIDumpJournal@@YGXPBD@Z@4P6GX0@ZA
_BSS	SEGMENT
?_default_impl@?1??DXGIDumpJournal@@YGXPBD@Z@4P6GX0@ZA DD 01H DUP (?) ; `DXGIDumpJournal'::`2'::_default_impl
_BSS	ENDS
;	COMDAT ?_default_impl@?1??DXGIReportAdapterConfiguration@@YGJK@Z@4P6GJK@ZA
_BSS	SEGMENT
?_default_impl@?1??DXGIReportAdapterConfiguration@@YGJK@Z@4P6GJK@ZA DD 01H DUP (?) ; `DXGIReportAdapterConfiguration'::`2'::_default_impl
_BSS	ENDS
;	COMDAT ?called@?1??ChangeDisplaySettingsA_Detour@@YGJPAU_devicemodeA@@K@Z@4_NA
_BSS	SEGMENT
?called@?1??ChangeDisplaySettingsA_Detour@@YGJPAU_devicemodeA@@K@Z@4_NA DB 01H DUP (?) ; `ChangeDisplaySettingsA_Detour'::`2'::called
_BSS	ENDS
;	COMDAT ?hooked@?1??SK_HookDXGI@@YGXXZ@4KC
_BSS	SEGMENT
?hooked@?1??SK_HookDXGI@@YGXXZ@4KC DD 01H DUP (?)	; `SK_HookDXGI'::`2'::hooked
_BSS	ENDS
_BSS	SEGMENT
?old_threads@@3V?$queue@KV?$deque@KV?$allocator@K@std@@@std@@@std@@A DB 014H DUP (?) ; old_threads
_BSS	ENDS
;	COMDAT ?__installed_second_hook@?4??SK_DXGI_HookPresentBase@@YAXPAUIDXGISwapChain@@_N@Z@4KC
_BSS	SEGMENT
?__installed_second_hook@?4??SK_DXGI_HookPresentBase@@YAXPAUIDXGISwapChain@@_N@Z@4KC DD 01H DUP (?) ; `SK_DXGI_HookPresentBase'::`5'::__installed_second_hook
_BSS	ENDS
;	COMDAT ?vftable_8@?1??SK_DXGI_HookPresentBase@@YAXPAUIDXGISwapChain@@_N@Z@4PAXA
_BSS	SEGMENT
?vftable_8@?1??SK_DXGI_HookPresentBase@@YAXPAUIDXGISwapChain@@_N@Z@4PAXA DD 01H DUP (?) ; `SK_DXGI_HookPresentBase'::`2'::vftable_8
_BSS	ENDS
;	COMDAT ?vftable_22@?1??SK_DXGI_HookPresent1@@YAXPAUIDXGISwapChain1@@_N@Z@4PAXA
_BSS	SEGMENT
?vftable_22@?1??SK_DXGI_HookPresent1@@YAXPAUIDXGISwapChain1@@_N@Z@4PAXA DD 01H DUP (?) ; `SK_DXGI_HookPresent1'::`2'::vftable_22
_BSS	ENDS
;	COMDAT ?init@?1??SK_DXGI_HookSwapChain@@YAXPAUIDXGISwapChain@@@Z@4KC
_BSS	SEGMENT
?init@?1??SK_DXGI_HookSwapChain@@YAXPAUIDXGISwapChain@@@Z@4KC DD 01H DUP (?) ; `SK_DXGI_HookSwapChain'::`2'::init
_BSS	ENDS
;	COMDAT ?init@?1??SK_DXGI_HookFactory@@YAXPAUIDXGIFactory@@@Z@4KC
_BSS	SEGMENT
?init@?1??SK_DXGI_HookFactory@@YAXPAUIDXGIFactory@@@Z@4KC DD 01H DUP (?) ; `SK_DXGI_HookFactory'::`2'::init
_BSS	ENDS
;	COMDAT ?implicit_init@?7??HookDXGI@@YGIPAX@Z@4KC
_BSS	SEGMENT
?implicit_init@?7??HookDXGI@@YGIPAX@Z@4KC DD 01H DUP (?) ; `HookDXGI'::`8'::implicit_init
_BSS	ENDS
;	COMDAT ?last_budget@?3??BudgetThread@DXGI@SK@@YGKPAX@Z@4_KA
_BSS	SEGMENT
?last_budget@?3??BudgetThread@DXGI@SK@@YGKPAX@Z@4_KA DQ 01H DUP (?) ; `SK::DXGI::BudgetThread'::`4'::last_budget
_BSS	ENDS
;	COMDAT ?$TSS0@?3??BudgetThread@DXGI@SK@@YGKPAX@Z@4HA
_BSS	SEGMENT
?$TSS0@?3??BudgetThread@DXGI@SK@@YGKPAX@Z@4HA DD 01H DUP (?) ; TSS0<`template-parameter-4',SK::DXGI::dgetThread, ?? :: ?? ::HA::GKPAX::Z::GKPAX>
_BSS	ENDS
;	COMDAT ?LastBudget@?CD@??BudgetThread@DXGI@SK@@YGKPAX@Z@4_KA
_BSS	SEGMENT
?LastBudget@?CD@??BudgetThread@DXGI@SK@@YGKPAX@Z@4_KA DQ 01H DUP (?) ; `SK::DXGI::BudgetThread'::`35'::LastBudget
_BSS	ENDS
;	COMDAT ?hDXGI@?1??StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ@4PAUHINSTANCE__@@A
_BSS	SEGMENT
?hDXGI@?1??StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ@4PAUHINSTANCE__@@A DD 01H DUP (?) ; `SK::DXGI::StartBudgetThread_NoAdapter'::`2'::hDXGI
_BSS	ENDS
;	COMDAT ?$TSS0@?1??StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ@4HA
_BSS	SEGMENT
?$TSS0@?1??StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ@4HA DD 01H DUP (?) ; TSS0<`template-parameter-2',SK::DXGI::rtBudgetThread_NoAdapter, ?? :: ?? ::HA::AJXZ::AJXZ>
_BSS	ENDS
;	COMDAT ?CreateDXGIFactory@?4??StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ@4P6GJABU_GUID@@PAPAX@ZA
_BSS	SEGMENT
?CreateDXGIFactory@?4??StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ@4P6GJABU_GUID@@PAPAX@ZA DD 01H DUP (?) ; `SK::DXGI::StartBudgetThread_NoAdapter'::`5'::CreateDXGIFactory
_BSS	ENDS
;	COMDAT ?$TSS1@?4??StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ@4HA
_BSS	SEGMENT
?$TSS1@?4??StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ@4HA DD 01H DUP (?) ; TSS1<`template-parameter-5',SK::DXGI::rtBudgetThread_NoAdapter, ?? :: ?? ::HA::AJXZ::AJXZ>
_BSS	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_AtlComModule$initializer$@ATL@@3P6AXXZA DD FLAT:??__E_AtlComModule@ATL@@YAXXZ ; ATL::_AtlComModule$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __xmm@00000001000000060000000200000001
CONST	SEGMENT
__xmm@00000001000000060000000200000001 DB 01H, 00H, 00H, 00H, 02H, 00H, 00H
	DB	00H, 06H, 00H, 00H, 00H, 01H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __real@7fc00000
CONST	SEGMENT
__real@7fc00000 DD 07fc00000r			; nan
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_com_error@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_com_error@@8 DD FLAT:??_R0?AV_com_error@@@8 ; _com_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_com_error@@8
rdata$r	ENDS
;	COMDAT ??_R2_com_error@@8
rdata$r	SEGMENT
??_R2_com_error@@8 DD FLAT:??_R1A@?0A@EA@_com_error@@8	; _com_error::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_com_error@@8
rdata$r	SEGMENT
??_R3_com_error@@8 DD 00H				; _com_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_com_error@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_com_error@@@8
data$r	SEGMENT
??_R0?AV_com_error@@@8 DD FLAT:??_7type_info@@6B@	; _com_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_com_error@@', 00H
data$r	ENDS
;	COMDAT ??_R4_com_error@@6B@
rdata$r	SEGMENT
??_R4_com_error@@6B@ DD 00H				; _com_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_com_error@@@8
	DD	FLAT:??_R3_com_error@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT __GUID_54ec77fa_1377_44e6_8c32_88fd5f44c84c
CONST	SEGMENT
__GUID_54ec77fa_1377_44e6_8c32_88fd5f44c84c DD 054ec77faH
	DW	01377H
	DW	044e6H
	DB	08cH
	DB	032H
	DB	088H
	DB	0fdH
	DB	05fH
	DB	044H
	DB	0c8H
	DB	04cH
CONST	ENDS
;	COMDAT __GUID_bb2c6faa_b5fb_4082_8e6b_388b8cfa90e1
CONST	SEGMENT
__GUID_bb2c6faa_b5fb_4082_8e6b_388b8cfa90e1 DD 0bb2c6faaH
	DW	0b5fbH
	DW	04082H
	DB	08eH
	DB	06bH
	DB	038H
	DB	08bH
	DB	08cH
	DB	0faH
	DB	090H
	DB	0e1H
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ?szName@?5??DXGIReportAdapterConfiguration@@YGJK@Z@4PBDB
_DATA	SEGMENT
?szName@?5??DXGIReportAdapterConfiguration@@YGJK@Z@4PBDB DD FLAT:$SG357742 ; `DXGIReportAdapterConfiguration'::`6'::szName
_DATA	ENDS
;	COMDAT ?szName@?5??DXGIDumpJournal@@YGXPBD@Z@4PBDB
_DATA	SEGMENT
?szName@?5??DXGIDumpJournal@@YGXPBD@Z@4PBDB DD FLAT:$SG357724 ; `DXGIDumpJournal'::`6'::szName
_DATA	ENDS
;	COMDAT ?szName@?5??DXGID3D10RegisterLayers@@YGJPBXI@Z@4PBDB
_DATA	SEGMENT
?szName@?5??DXGID3D10RegisterLayers@@YGJPBXI@Z@4PBDB DD FLAT:$SG357704 ; `DXGID3D10RegisterLayers'::`6'::szName
_DATA	ENDS
;	COMDAT ?szName@?5??DXGID3D10GetLayeredDeviceSize@@YGKPBXI@Z@4PBDB
_DATA	SEGMENT
?szName@?5??DXGID3D10GetLayeredDeviceSize@@YGKPBXI@Z@4PBDB DD FLAT:$SG357682 ; `DXGID3D10GetLayeredDeviceSize'::`6'::szName
_DATA	ENDS
;	COMDAT ?szName@?5??DXGID3D10CreateLayeredDevice@@YGJUUNKNOWN5@@@Z@4PBDB
_DATA	SEGMENT
?szName@?5??DXGID3D10CreateLayeredDevice@@YGJUUNKNOWN5@@@Z@4PBDB DD FLAT:$SG357660 ; `DXGID3D10CreateLayeredDevice'::`6'::szName
_DATA	ENDS
;	COMDAT ?szName@?5??DXGID3D10CreateDevice@@YGJPAUHINSTANCE__@@PAUIDXGIFactory@@PAUIDXGIAdapter@@IPAX3@Z@4PBDB
_DATA	SEGMENT
?szName@?5??DXGID3D10CreateDevice@@YGJPAUHINSTANCE__@@PAUIDXGIFactory@@PAUIDXGIAdapter@@IPAX3@Z@4PBDB DD FLAT:$SG357628 ; `DXGID3D10CreateDevice'::`6'::szName
_DATA	ENDS
;	COMDAT ??_C@_1BCK@OGPEHLJN@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?$FL?$AA?$EA?$AA?$FN?$AA?5?$AA?5?$AAR?$AAe?$AAt?$AAu?$AAr?$AAn?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AA?5?$AA?9?$AA?5@
CONST	SEGMENT
??_C@_1BCK@OGPEHLJN@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?$FL?$AA?$EA?$AA?$FN?$AA?5?$AA?5?$AAR?$AAe?$AAt?$AAu?$AAr?$AAn?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AA?5?$AA?9?$AA?5@ DB '['
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H
	DB	'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' ', 00H, '['
	DB	00H, '@', 00H, ']', 00H, ' ', 00H, ' ', 00H, 'R', 00H, 'e', 00H
	DB	't', 00H, 'u', 00H, 'r', 00H, 'n', 00H, ':', 00H, ' ', 00H, '%'
	DB	00H, 's', 00H, ' ', 00H, ' ', 00H, '-', 00H, ' ', 00H, ' ', 00H
	DB	'<', 00H, ' ', 00H, 'C', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 't'
	DB	00H, 'e', 00H, 'S', 00H, 'w', 00H, 'a', 00H, 'p', 00H, 'C', 00H
	DB	'h', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'F', 00H, 'o', 00H, 'r'
	DB	00H, 'H', 00H, 'w', 00H, 'n', 00H, 'd', 00H, '_', 00H, 'O', 00H
	DB	'r', 00H, 'i', 00H, 'g', 00H, 'i', 00H, 'n', 00H, 'a', 00H, 'l'
	DB	00H, ' ', 00H, '(', 00H, ' ', 00H, 'T', 00H, 'h', 00H, 'i', 00H
	DB	's', 00H, ',', 00H, ' ', 00H, 'p', 00H, 'D', 00H, 'e', 00H, 'v'
	DB	00H, 'i', 00H, 'c', 00H, 'e', 00H, ',', 00H, ' ', 00H, 'h', 00H
	DB	'W', 00H, 'n', 00H, 'd', 00H, ',', 00H, ' ', 00H, 'p', 00H, 'D'
	DB	00H, 'e', 00H, 's', 00H, 'c', 00H, ',', 00H, ' ', 00H, 'p', 00H
	DB	'F', 00H, 'u', 00H, 'l', 00H, 'l', 00H, 's', 00H, 'c', 00H, 'r'
	DB	00H, 'e', 00H, 'e', 00H, 'n', 00H, 'D', 00H, 'e', 00H, 's', 00H
	DB	'c', 00H, ',', 00H, ' ', 00H, 'p', 00H, 'R', 00H, 'e', 00H, 's'
	DB	00H, 't', 00H, 'r', 00H, 'i', 00H, 'c', 00H, 't', 00H, 'T', 00H
	DB	'o', 00H, 'O', 00H, 'u', 00H, 't', 00H, 'p', 00H, 'u', 00H, 't'
	DB	00H, ',', 00H, ' ', 00H, 'p', 00H, 'p', 00H, 'S', 00H, 'w', 00H
	DB	'a', 00H, 'p', 00H, 'C', 00H, 'h', 00H, 'a', 00H, 'i', 00H, 'n'
	DB	00H, ' ', 00H, ')', 00H, ' ', 00H, '>', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BBK@GBNFCBJD@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?$FL?$AA?$EA?$AA?$FN?$AA?5?$AA?5?$AAR?$AAe?$AAt?$AAu?$AAr?$AAn?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AA?5?$AA?9?$AA?5@
CONST	SEGMENT
??_C@_1BBK@GBNFCBJD@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?$FL?$AA?$EA?$AA?$FN?$AA?5?$AA?5?$AAR?$AAe?$AAt?$AAu?$AAr?$AAn?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AA?5?$AA?9?$AA?5@ DB '['
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H
	DB	'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' ', 00H, '['
	DB	00H, '@', 00H, ']', 00H, ' ', 00H, ' ', 00H, 'R', 00H, 'e', 00H
	DB	't', 00H, 'u', 00H, 'r', 00H, 'n', 00H, ':', 00H, ' ', 00H, '%'
	DB	00H, 's', 00H, ' ', 00H, ' ', 00H, '-', 00H, ' ', 00H, ' ', 00H
	DB	'<', 00H, ' ', 00H, 'C', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 't'
	DB	00H, 'e', 00H, 'S', 00H, 'w', 00H, 'a', 00H, 'p', 00H, 'C', 00H
	DB	'h', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'F', 00H, 'o', 00H, 'r'
	DB	00H, 'C', 00H, 'o', 00H, 'r', 00H, 'e', 00H, 'W', 00H, 'i', 00H
	DB	'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, '_', 00H, 'O', 00H, 'r'
	DB	00H, 'i', 00H, 'g', 00H, 'i', 00H, 'n', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, '(', 00H, ' ', 00H, 'T', 00H, 'h', 00H, 'i', 00H, 's'
	DB	00H, ',', 00H, ' ', 00H, 'p', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, ',', 00H, ' ', 00H, 'p', 00H, 'W'
	DB	00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, ',', 00H
	DB	' ', 00H, 'p', 00H, 'D', 00H, 'e', 00H, 's', 00H, 'c', 00H, ','
	DB	00H, ' ', 00H, 'p', 00H, 'R', 00H, 'e', 00H, 's', 00H, 't', 00H
	DB	'r', 00H, 'i', 00H, 'c', 00H, 't', 00H, 'T', 00H, 'o', 00H, 'O'
	DB	00H, 'u', 00H, 't', 00H, 'p', 00H, 'u', 00H, 't', 00H, ',', 00H
	DB	' ', 00H, 'p', 00H, 'p', 00H, 'S', 00H, 'w', 00H, 'a', 00H, 'p'
	DB	00H, 'C', 00H, 'h', 00H, 'a', 00H, 'i', 00H, 'n', 00H, ' ', 00H
	DB	')', 00H, ' ', 00H, '>', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1ME@IOFODDLL@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?$FL?$AA?$EA?$AA?$FN?$AA?5?$AA?5?$AAR?$AAe?$AAt?$AAu?$AAr?$AAn?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AA?5?$AA?9?$AA?5@
CONST	SEGMENT
??_C@_1ME@IOFODDLL@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?$FL?$AA?$EA?$AA?$FN?$AA?5?$AA?5?$AAR?$AAe?$AAt?$AAu?$AAr?$AAn?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AA?5?$AA?9?$AA?5@ DB '['
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H
	DB	'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' ', 00H, '['
	DB	00H, '@', 00H, ']', 00H, ' ', 00H, ' ', 00H, 'R', 00H, 'e', 00H
	DB	't', 00H, 'u', 00H, 'r', 00H, 'n', 00H, ':', 00H, ' ', 00H, '%'
	DB	00H, 's', 00H, ' ', 00H, ' ', 00H, '-', 00H, ' ', 00H, ' ', 00H
	DB	'<', 00H, ' ', 00H, 'C', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 't'
	DB	00H, 'e', 00H, 'S', 00H, 'w', 00H, 'a', 00H, 'p', 00H, 'C', 00H
	DB	'h', 00H, 'a', 00H, 'i', 00H, 'n', 00H, '_', 00H, 'O', 00H, 'r'
	DB	00H, 'i', 00H, 'g', 00H, 'i', 00H, 'n', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, '(', 00H, 'T', 00H, 'h', 00H, 'i', 00H, 's', 00H, ','
	DB	00H, ' ', 00H, 'p', 00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H
	DB	'c', 00H, 'e', 00H, ',', 00H, ' ', 00H, 'p', 00H, 'D', 00H, 'e'
	DB	00H, 's', 00H, 'c', 00H, ',', 00H, ' ', 00H, 'p', 00H, 'p', 00H
	DB	'S', 00H, 'w', 00H, 'a', 00H, 'p', 00H, 'C', 00H, 'h', 00H, 'a'
	DB	00H, 'i', 00H, 'n', 00H, ')', 00H, ' ', 00H, '>', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FO@CKMCMFKO@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AAF?$AAr?$AAa?$AAm@
CONST	SEGMENT
??_C@_1FO@CKMCMFKO@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AAF?$AAr?$AAa?$AAm@ DB '['
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H
	DB	'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' ', 00H, 'S'
	DB	00H, 'e', 00H, 't', 00H, 't', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	' ', 00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e'
	DB	00H, ' ', 00H, 'F', 00H, 'r', 00H, 'a', 00H, 'm', 00H, 'e', 00H
	DB	' ', 00H, 'L', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'n', 00H, 'c'
	DB	00H, 'y', 00H, ':', 00H, ' ', 00H, '%', 00H, 'l', 00H, 'u', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1GE@BOIALL@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAS?$AAw?$AAa?$AAp?$AAc?$AAh?$AAa?$AAi?$AAn?$AA?5?$AAF@
CONST	SEGMENT
??_C@_1GE@BOIALL@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAS?$AAw?$AAa?$AAp?$AAc?$AAh?$AAa?$AAi?$AAn?$AA?5?$AAF@ DB '['
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H
	DB	'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' ', 00H, 'S'
	DB	00H, 'e', 00H, 't', 00H, 't', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	' ', 00H, 'S', 00H, 'w', 00H, 'a', 00H, 'p', 00H, 'c', 00H, 'h'
	DB	00H, 'a', 00H, 'i', 00H, 'n', 00H, ' ', 00H, 'F', 00H, 'r', 00H
	DB	'a', 00H, 'm', 00H, 'e', 00H, ' ', 00H, 'L', 00H, 'a', 00H, 't'
	DB	00H, 'e', 00H, 'n', 00H, 'c', 00H, 'y', 00H, ':', 00H, ' ', 00H
	DB	'%', 00H, 'l', 00H, 'u', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT __GUID_77db970f_6276_48ba_ba28_070143b4392c
CONST	SEGMENT
__GUID_77db970f_6276_48ba_ba28_070143b4392c DD 077db970fH
	DW	06276H
	DW	048baH
	DB	0baH
	DB	028H
	DB	07H
	DB	01H
	DB	043H
	DB	0b4H
	DB	039H
	DB	02cH
CONST	ENDS
;	COMDAT ?first@?M@??SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z@4_NA
_DATA	SEGMENT
?first@?M@??SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z@4_NA DB 01H ; `SK_DXGI_CreateSwapChain_PostInit'::`12'::first
_DATA	ENDS
;	COMDAT ?first@?2??SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z@4_NA
_DATA	SEGMENT
?first@?2??SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z@4_NA DB 01H ; `SK_DXGI_CreateSwapChain_PostInit'::`3'::first
_DATA	ENDS
;	COMDAT ??_C@_1IK@KCJJDMDA@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA2?$AA?5?$AA?$FN?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAU?$AAs?$AAi?$AAn?$AAg?$AA?5?$AA?$CF?$AAs?$AA?5?$AAP?$AAr?$AAe?$AAs?$AAe?$AAn?$AAt@
CONST	SEGMENT
??_C@_1IK@KCJJDMDA@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA2?$AA?5?$AA?$FN?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAU?$AAs?$AAi?$AAn?$AAg?$AA?5?$AA?$CF?$AAs?$AA?5?$AAP?$AAr?$AAe?$AAs?$AAe?$AAn?$AAt@ DB '['
	DB	00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, ' ', 00H
	DB	'1', 00H, '.', 00H, '2', 00H, ' ', 00H, ']', 00H, ' ', 00H, '>'
	DB	00H, '>', 00H, ' ', 00H, 'U', 00H, 's', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, ' ', 00H, '%', 00H, 's', 00H, ' ', 00H, 'P', 00H, 'r'
	DB	00H, 'e', 00H, 's', 00H, 'e', 00H, 'n', 00H, 't', 00H, 'a', 00H
	DB	't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H, 'M', 00H, 'o'
	DB	00H, 'd', 00H, 'e', 00H, 'l', 00H, ' ', 00H, ' ', 00H, '[', 00H
	DB	'W', 00H, 'a', 00H, 'i', 00H, 't', 00H, 'a', 00H, 'b', 00H, 'l'
	DB	00H, 'e', 00H, ':', 00H, ' ', 00H, '%', 00H, 's', 00H, ' ', 00H
	DB	'-', 00H, ' ', 00H, '%', 00H, 'l', 00H, 'i', 00H, ' ', 00H, 'm'
	DB	00H, 's', 00H, ']', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@PKCOFIGO@?$AAT?$AAr?$AAa?$AAd?$AAi?$AAt?$AAi?$AAo?$AAn?$AAa?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@PKCOFIGO@?$AAT?$AAr?$AAa?$AAd?$AAi?$AAt?$AAi?$AAo?$AAn?$AAa?$AAl?$AA?$AA@ DB 'T'
	DB	00H, 'r', 00H, 'a', 00H, 'd', 00H, 'i', 00H, 't', 00H, 'i', 00H
	DB	'o', 00H, 'n', 00H, 'a', 00H, 'l', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_19EMFBKLJE@?$AAF?$AAl?$AAi?$AAp?$AA?$AA@
CONST	SEGMENT
??_C@_19EMFBKLJE@?$AAF?$AAl?$AAi?$AAp?$AA?$AA@ DB 'F', 00H, 'l', 00H, 'i', 00H
	DB	'p', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_15BICKNCBF@?$AAN?$AAo?$AA?$AA@
CONST	SEGMENT
??_C@_15BICKNCBF@?$AAN?$AAo?$AA?$AA@ DB 'N', 00H, 'o', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_17PBAHFJOA@?$AAY?$AAe?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_17PBAHFJOA@?$AAY?$AAe?$AAs?$AA?$AA@ DB 'Y', 00H, 'e', 00H, 's', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1HM@GOOAFJFG@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAR?$AAe?$AAf?$AAr?$AAe?$AAs?$AAh?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd@
CONST	SEGMENT
??_C@_1HM@GOOAFJFG@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAR?$AAe?$AAf?$AAr?$AAe?$AAs?$AAh?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd@ DB '['
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H
	DB	'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' ', 00H, ' '
	DB	00H, '>', 00H, '>', 00H, ' ', 00H, 'R', 00H, 'e', 00H, 'f', 00H
	DB	'r', 00H, 'e', 00H, 's', 00H, 'h', 00H, ' ', 00H, 'O', 00H, 'v'
	DB	00H, 'e', 00H, 'r', 00H, 'r', 00H, 'i', 00H, 'd', 00H, 'e', 00H
	DB	' ', 00H, '(', 00H, 'R', 00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e'
	DB	00H, 's', 00H, 't', 00H, 'e', 00H, 'd', 00H, ':', 00H, ' ', 00H
	DB	'%', 00H, 'f', 00H, ',', 00H, ' ', 00H, 'U', 00H, 's', 00H, 'i'
	DB	00H, 'n', 00H, 'g', 00H, ':', 00H, ' ', 00H, '%', 00H, 'l', 00H
	DB	'i', 00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1HM@EKHBGJHP@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAS?$AAc?$AAa?$AAn?$AAl?$AAi?$AAn?$AAe?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi@
CONST	SEGMENT
??_C@_1HM@EKHBGJHP@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAS?$AAc?$AAa?$AAn?$AAl?$AAi?$AAn?$AAe?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi@ DB '['
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H
	DB	'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' ', 00H, ' '
	DB	00H, '>', 00H, '>', 00H, ' ', 00H, 'S', 00H, 'c', 00H, 'a', 00H
	DB	'n', 00H, 'l', 00H, 'i', 00H, 'n', 00H, 'e', 00H, ' ', 00H, 'O'
	DB	00H, 'v', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'i', 00H, 'd', 00H
	DB	'e', 00H, ' ', 00H, '(', 00H, 'R', 00H, 'e', 00H, 'q', 00H, 'u'
	DB	00H, 'e', 00H, 's', 00H, 't', 00H, 'e', 00H, 'd', 00H, ':', 00H
	DB	' ', 00H, '%', 00H, 's', 00H, ',', 00H, ' ', 00H, 'U', 00H, 's'
	DB	00H, 'i', 00H, 'n', 00H, 'g', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	's', 00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1HK@PGANLAKP@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAS?$AAc?$AAa?$AAl?$AAi?$AAn?$AAg?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd@
CONST	SEGMENT
??_C@_1HK@PGANLAKP@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAS?$AAc?$AAa?$AAl?$AAi?$AAn?$AAg?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd@ DB '['
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H
	DB	'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' ', 00H, ' '
	DB	00H, '>', 00H, '>', 00H, ' ', 00H, 'S', 00H, 'c', 00H, 'a', 00H
	DB	'l', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'O', 00H, 'v'
	DB	00H, 'e', 00H, 'r', 00H, 'r', 00H, 'i', 00H, 'd', 00H, 'e', 00H
	DB	' ', 00H, '(', 00H, 'R', 00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e'
	DB	00H, 's', 00H, 't', 00H, 'e', 00H, 'd', 00H, ':', 00H, ' ', 00H
	DB	'%', 00H, 's', 00H, ',', 00H, ' ', 00H, 'U', 00H, 's', 00H, 'i'
	DB	00H, 'n', 00H, 'g', 00H, ':', 00H, ' ', 00H, '%', 00H, 's', 00H
	DB	')', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1FC@PILPBEPG@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAT?$AAe?$AAa?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAO?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?3@
CONST	SEGMENT
??_C@_1FC@PILPBEPG@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAT?$AAe?$AAa?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAO?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?3@ DB '['
	DB	00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, ' ', 00H
	DB	'1', 00H, '.', 00H, '5', 00H, ' ', 00H, ']', 00H, ' ', 00H, ' '
	DB	00H, '>', 00H, '>', 00H, ' ', 00H, 'T', 00H, 'e', 00H, 'a', 00H
	DB	'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'O', 00H, 'p'
	DB	00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ':', 00H, ' ', 00H
	DB	' ', 00H, 'E', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1GI@GAEBCHMN@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AAO?$AAv@
CONST	SEGMENT
??_C@_1GI@GAEBCHMN@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AAO?$AAv@ DB '['
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H
	DB	'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' ', 00H, ' '
	DB	00H, '>', 00H, '>', 00H, ' ', 00H, 'B', 00H, 'u', 00H, 'f', 00H
	DB	'f', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'C', 00H, 'o', 00H, 'u'
	DB	00H, 'n', 00H, 't', 00H, ' ', 00H, 'O', 00H, 'v', 00H, 'e', 00H
	DB	'r', 00H, 'r', 00H, 'i', 00H, 'd', 00H, 'e', 00H, ':', 00H, ' '
	DB	00H, '%', 00H, 'l', 00H, 'u', 00H, ' ', 00H, 'b', 00H, 'u', 00H
	DB	'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1KK@LPPCBMFA@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA2?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAR?$AAG?$AAB?$AAA?$AA?5?$AA1?$AA0?$AA?3?$AA1?$AA0?$AA?3?$AA1?$AA0?$AA?3?$AA2@
CONST	SEGMENT
??_C@_1KK@LPPCBMFA@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA2?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAR?$AAG?$AAB?$AAA?$AA?5?$AA1?$AA0?$AA?3?$AA1?$AA0?$AA?3?$AA1?$AA0?$AA?3?$AA2@ DB '['
	DB	00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, ' ', 00H
	DB	'1', 00H, '.', 00H, '2', 00H, ' ', 00H, ']', 00H, ' ', 00H, ' '
	DB	00H, '>', 00H, '>', 00H, ' ', 00H, 'R', 00H, 'G', 00H, 'B', 00H
	DB	'A', 00H, ' ', 00H, '1', 00H, '0', 00H, ':', 00H, '1', 00H, '0'
	DB	00H, ':', 00H, '1', 00H, '0', 00H, ':', 00H, '2', 00H, ' ', 00H
	DB	'O', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'i', 00H, 'd'
	DB	00H, 'e', 00H, ' ', 00H, '(', 00H, 't', 00H, 'o', 00H, ' ', 00H
	DB	'8', 00H, ':', 00H, '8', 00H, ':', 00H, '8', 00H, ':', 00H, '8'
	DB	00H, ')', 00H, ' ', 00H, 'R', 00H, 'e', 00H, 'q', 00H, 'u', 00H
	DB	'i', 00H, 'r', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 't', 00H, 'o'
	DB	00H, ' ', 00H, 'E', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, ' ', 00H, 'F', 00H, 'l', 00H, 'i', 00H, 'p', 00H, ' '
	DB	00H, 'M', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'l', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1JA@CCHCBLHJ@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA2?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAs?$AAR?$AAG?$AAB?$AA?5?$AA?$CI?$AAR?$AA8?$AAG?$AA8?$AAB?$AA8?$AAA?$AA8?$AA?$CJ@
CONST	SEGMENT
??_C@_1JA@CCHCBLHJ@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA2?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAs?$AAR?$AAG?$AAB?$AA?5?$AA?$CI?$AAR?$AA8?$AAG?$AA8?$AAB?$AA8?$AAA?$AA8?$AA?$CJ@ DB '['
	DB	00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, ' ', 00H
	DB	'1', 00H, '.', 00H, '2', 00H, ' ', 00H, ']', 00H, ' ', 00H, ' '
	DB	00H, '>', 00H, '>', 00H, ' ', 00H, 's', 00H, 'R', 00H, 'G', 00H
	DB	'B', 00H, ' ', 00H, '(', 00H, 'R', 00H, '8', 00H, 'G', 00H, '8'
	DB	00H, 'B', 00H, '8', 00H, 'A', 00H, '8', 00H, ')', 00H, ' ', 00H
	DB	'O', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'i', 00H, 'd'
	DB	00H, 'e', 00H, ' ', 00H, 'R', 00H, 'e', 00H, 'q', 00H, 'u', 00H
	DB	'i', 00H, 'r', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 't', 00H, 'o'
	DB	00H, ' ', 00H, 'E', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, ' ', 00H, 'F', 00H, 'l', 00H, 'i', 00H, 'p', 00H, ' '
	DB	00H, 'M', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'l', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1JA@NDGFBELE@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA2?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAs?$AAR?$AAG?$AAB?$AA?5?$AA?$CI?$AAB?$AA8?$AAG?$AA8?$AAR?$AA8?$AAA?$AA8?$AA?$CJ@
CONST	SEGMENT
??_C@_1JA@NDGFBELE@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA2?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAs?$AAR?$AAG?$AAB?$AA?5?$AA?$CI?$AAB?$AA8?$AAG?$AA8?$AAR?$AA8?$AAA?$AA8?$AA?$CJ@ DB '['
	DB	00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H, 'I', 00H, ' ', 00H
	DB	'1', 00H, '.', 00H, '2', 00H, ' ', 00H, ']', 00H, ' ', 00H, ' '
	DB	00H, '>', 00H, '>', 00H, ' ', 00H, 's', 00H, 'R', 00H, 'G', 00H
	DB	'B', 00H, ' ', 00H, '(', 00H, 'B', 00H, '8', 00H, 'G', 00H, '8'
	DB	00H, 'R', 00H, '8', 00H, 'A', 00H, '8', 00H, ')', 00H, ' ', 00H
	DB	'O', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'i', 00H, 'd'
	DB	00H, 'e', 00H, ' ', 00H, 'R', 00H, 'e', 00H, 'q', 00H, 'u', 00H
	DB	'i', 00H, 'r', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 't', 00H, 'o'
	DB	00H, ' ', 00H, 'E', 00H, 'n', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, ' ', 00H, 'F', 00H, 'l', 00H, 'i', 00H, 'p', 00H, ' '
	DB	00H, 'M', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'l', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1JG@LPALCGFK@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAD?$AAi?$AAs?$AAp?$AAl?$AAa?$AAy?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd@
CONST	SEGMENT
??_C@_1JG@LPALCGFK@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAD?$AAi?$AAs?$AAp?$AAl?$AAa?$AAy?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd@ DB '['
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H
	DB	'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' ', 00H, ' '
	DB	00H, '>', 00H, '>', 00H, ' ', 00H, 'D', 00H, 'i', 00H, 's', 00H
	DB	'p', 00H, 'l', 00H, 'a', 00H, 'y', 00H, ' ', 00H, 'O', 00H, 'v'
	DB	00H, 'e', 00H, 'r', 00H, 'r', 00H, 'i', 00H, 'd', 00H, 'e', 00H
	DB	' ', 00H, '(', 00H, 'R', 00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e'
	DB	00H, 's', 00H, 't', 00H, 'e', 00H, 'd', 00H, ':', 00H, ' ', 00H
	DB	'F', 00H, 'u', 00H, 'l', 00H, 'l', 00H, 's', 00H, 'c', 00H, 'r'
	DB	00H, 'e', 00H, 'e', 00H, 'n', 00H, ',', 00H, ' ', 00H, 'U', 00H
	DB	's', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ':', 00H, ' ', 00H, 'W'
	DB	00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'e', 00H
	DB	'd', 00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1JG@HCAIICBG@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAD?$AAi?$AAs?$AAp?$AAl?$AAa?$AAy?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd@
CONST	SEGMENT
??_C@_1JG@HCAIICBG@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAD?$AAi?$AAs?$AAp?$AAl?$AAa?$AAy?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd@ DB '['
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H
	DB	'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' ', 00H, ' '
	DB	00H, '>', 00H, '>', 00H, ' ', 00H, 'D', 00H, 'i', 00H, 's', 00H
	DB	'p', 00H, 'l', 00H, 'a', 00H, 'y', 00H, ' ', 00H, 'O', 00H, 'v'
	DB	00H, 'e', 00H, 'r', 00H, 'r', 00H, 'i', 00H, 'd', 00H, 'e', 00H
	DB	' ', 00H, '(', 00H, 'R', 00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e'
	DB	00H, 's', 00H, 't', 00H, 'e', 00H, 'd', 00H, ':', 00H, ' ', 00H
	DB	'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'e'
	DB	00H, 'd', 00H, ',', 00H, ' ', 00H, 'U', 00H, 's', 00H, 'i', 00H
	DB	'n', 00H, 'g', 00H, ':', 00H, ' ', 00H, 'F', 00H, 'u', 00H, 'l'
	DB	00H, 'l', 00H, 's', 00H, 'c', 00H, 'r', 00H, 'e', 00H, 'e', 00H
	DB	'n', 00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1HA@INGGDHHB@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAU?$AAs?$AAe?$AAr?$AA?9?$AAR?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AAe?$AAd?$AA?5@
CONST	SEGMENT
??_C@_1HA@INGGDHHB@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAU?$AAs?$AAe?$AAr?$AA?9?$AAR?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AAe?$AAd?$AA?5@ DB '['
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H
	DB	'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' ', 00H, ' '
	DB	00H, '>', 00H, '>', 00H, ' ', 00H, 'U', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, '-', 00H, 'R', 00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e'
	DB	00H, 's', 00H, 't', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'M', 00H
	DB	'o', 00H, 'd', 00H, 'e', 00H, ' ', 00H, 'C', 00H, 'h', 00H, 'a'
	DB	00H, 'n', 00H, 'g', 00H, 'e', 00H, ':', 00H, ' ', 00H, 'F', 00H
	DB	'u', 00H, 'l', 00H, 'l', 00H, 's', 00H, 'c', 00H, 'r', 00H, 'e'
	DB	00H, 'e', 00H, 'n', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BAE@FEHGBMOO@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AAS?$AAw?$AAa?$AAp?$AAC?$AAh?$AAa?$AAi?$AAn?$AA?3?$AA?5?$AA?$CI?$AA?$CF?$AAl?$AAu?$AAx?$AA?$CF?$AAl@
CONST	SEGMENT
??_C@_1BAE@FEHGBMOO@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AAS?$AAw?$AAa?$AAp?$AAC?$AAh?$AAa?$AAi?$AAn?$AA?3?$AA?5?$AA?$CI?$AA?$CF?$AAl?$AAu?$AAx?$AA?$CF?$AAl@ DB '['
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, 'D', 00H, 'X', 00H, 'G', 00H
	DB	'I', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ']', 00H, ' ', 00H, ' '
	DB	00H, 'S', 00H, 'w', 00H, 'a', 00H, 'p', 00H, 'C', 00H, 'h', 00H
	DB	'a', 00H, 'i', 00H, 'n', 00H, ':', 00H, ' ', 00H, '(', 00H, '%'
	DB	00H, 'l', 00H, 'u', 00H, 'x', 00H, '%', 00H, 'l', 00H, 'u', 00H
	DB	' ', 00H, '@', 00H, ' ', 00H, '%', 00H, '4', 00H, '.', 00H, '1'
	DB	00H, 'f', 00H, ' ', 00H, 'H', 00H, 'z', 00H, ' ', 00H, '-', 00H
	DB	' ', 00H, 'S', 00H, 'c', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, ':', 00H, ' ', 00H, '%', 00H, 's', 00H, ' ', 00H
	DB	'-', 00H, ' ', 00H, 'S', 00H, 'c', 00H, 'a', 00H, 'n', 00H, 'l'
	DB	00H, 'i', 00H, 'n', 00H, 'e', 00H, 's', 00H, ':', 00H, ' ', 00H
	DB	'%', 00H, 's', 00H, ')', 00H, ' ', 00H, '-', 00H, ' ', 00H, '{'
	DB	00H, '%', 00H, 's', 00H, '}', 00H, ' ', 00H, '[', 00H, '%', 00H
	DB	'l', 00H, 'u', 00H, ' ', 00H, 'B', 00H, 'u', 00H, 'f', 00H, 'f'
	DB	00H, 'e', 00H, 'r', 00H, 's', 00H, ']', 00H, ' ', 00H, ':', 00H
	DB	':', 00H, ' ', 00H, 'F', 00H, 'l', 00H, 'a', 00H, 'g', 00H, 's'
	DB	00H, '=', 00H, '0', 00H, 'x', 00H, '%', 00H, '0', 00H, '4', 00H
	DB	'X', 00H, ',', 00H, ' ', 00H, 'S', 00H, 'w', 00H, 'a', 00H, 'p'
	DB	00H, 'E', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'c', 00H, 't', 00H
	DB	':', 00H, ' ', 00H, '%', 00H, 's', 00H, 0aH, 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@OKCKFGLA@?$AAS?$AAt?$AAr?$AAe?$AAt?$AAc?$AAh?$AAe?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@OKCKFGLA@?$AAS?$AAt?$AAr?$AAe?$AAt?$AAc?$AAh?$AAe?$AAd?$AA?$AA@ DB 'S'
	DB	00H, 't', 00H, 'r', 00H, 'e', 00H, 't', 00H, 'c', 00H, 'h', 00H
	DB	'e', 00H, 'd', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@NODLAKGH@?$AAC?$AAe?$AAn?$AAt?$AAe?$AAr?$AAe?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@NODLAKGH@?$AAC?$AAe?$AAn?$AAt?$AAe?$AAr?$AAe?$AAd?$AA?$AA@ DB 'C'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'e', 00H
	DB	'd', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@NBKANNIC@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAl?$AAa?$AAc?$AAe?$AAd?$AA?5?$AAO?$AAd?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@NBKANNIC@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAl?$AAa?$AAc?$AAe?$AAd?$AA?5?$AAO?$AAd?$AAd?$AA?$AA@ DB 'I'
	DB	00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'l', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'O', 00H, 'd', 00H, 'd'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@MIMOHAAK@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAl?$AAa?$AAc?$AAe?$AAd?$AA?5?$AAE?$AAv?$AAe?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@MIMOHAAK@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAl?$AAa?$AAc?$AAe?$AAd?$AA?5?$AAE?$AAv?$AAe?$AAn?$AA?$AA@ DB 'I'
	DB	00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'l', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'E', 00H, 'v', 00H, 'e'
	DB	00H, 'n', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@JFLEIIEG@?$AAP?$AAr?$AAo?$AAg?$AAr?$AAe?$AAs?$AAs?$AAi?$AAv?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@JFLEIIEG@?$AAP?$AAr?$AAo?$AAg?$AAr?$AAe?$AAs?$AAs?$AAi?$AAv?$AAe?$AA?$AA@ DB 'P'
	DB	00H, 'r', 00H, 'o', 00H, 'g', 00H, 'r', 00H, 'e', 00H, 's', 00H
	DB	's', 00H, 'i', 00H, 'v', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@DELFJJPB@?$AAU?$AAn?$AAs?$AAp?$AAe?$AAc?$AAi?$AAf?$AAi?$AAe?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@DELFJJPB@?$AAU?$AAn?$AAs?$AAp?$AAe?$AAc?$AAi?$AAf?$AAi?$AAe?$AAd?$AA?$AA@ DB 'U'
	DB	00H, 'n', 00H, 's', 00H, 'p', 00H, 'e', 00H, 'c', 00H, 'i', 00H
	DB	'f', 00H, 'i', 00H, 'e', 00H, 'd', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@EOMFJOKP@?$AAF?$AAu?$AAl?$AAl?$AAs?$AAc?$AAr?$AAe?$AAe?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@EOMFJOKP@?$AAF?$AAu?$AAl?$AAl?$AAs?$AAc?$AAr?$AAe?$AAe?$AAn?$AA?$AA@ DB 'F'
	DB	00H, 'u', 00H, 'l', 00H, 'l', 00H, 's', 00H, 'c', 00H, 'r', 00H
	DB	'e', 00H, 'e', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@PMICBOA@?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAe?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@PMICBOA@?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAe?$AAd?$AA?$AA@ DB 'W'
	DB	00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 'e', 00H
	DB	'd', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@OJAHAHGF@?$AAF?$AAl?$AAi?$AAp?$AA?5?$AAD?$AAi?$AAs?$AAc?$AAa?$AAr?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@OJAHAHGF@?$AAF?$AAl?$AAi?$AAp?$AA?5?$AAD?$AAi?$AAs?$AAc?$AAa?$AAr?$AAd?$AA?$AA@ DB 'F'
	DB	00H, 'l', 00H, 'i', 00H, 'p', 00H, ' ', 00H, 'D', 00H, 'i', 00H
	DB	's', 00H, 'c', 00H, 'a', 00H, 'r', 00H, 'd', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@DEGLGFCG@?$AAF?$AAl?$AAi?$AAp?$AA?5?$AAS?$AAe?$AAq?$AAu?$AAe?$AAn?$AAt?$AAi?$AAa?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@DEGLGFCG@?$AAF?$AAl?$AAi?$AAp?$AA?5?$AAS?$AAe?$AAq?$AAu?$AAe?$AAn?$AAt?$AAi?$AAa?$AAl?$AA?$AA@ DB 'F'
	DB	00H, 'l', 00H, 'i', 00H, 'p', 00H, ' ', 00H, 'S', 00H, 'e', 00H
	DB	'q', 00H, 'u', 00H, 'e', 00H, 'n', 00H, 't', 00H, 'i', 00H, 'a'
	DB	00H, 'l', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@BGMELJBK@?$AA?$DM?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?$DO?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@BGMELJBK@?$AA?$DM?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?$DO?$AA?$AA@ DB '<'
	DB	00H, 'U', 00H, 'n', 00H, 'k', 00H, 'n', 00H, 'o', 00H, 'w', 00H
	DB	'n', 00H, '>', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@MBNPLCBJ@?$AAS?$AAe?$AAq?$AAu?$AAe?$AAn?$AAt?$AAi?$AAa?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@MBNPLCBJ@?$AAS?$AAe?$AAq?$AAu?$AAe?$AAn?$AAt?$AAi?$AAa?$AAl?$AA?$AA@ DB 'S'
	DB	00H, 'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, 'n', 00H, 't', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BA@EMGLPOHC@?$AAD?$AAi?$AAs?$AAc?$AAa?$AAr?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1BA@EMGLPOHC@?$AAD?$AAi?$AAs?$AAc?$AAa?$AAr?$AAd?$AA?$AA@ DB 'D', 00H
	DB	'i', 00H, 's', 00H, 'c', 00H, 'a', 00H, 'r', 00H, 'd', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?first@?EB@??DXGISwap_ResizeTarget_Override@@YGJPAUIDXGISwapChain@@PBUDXGI_MODE_DESC@@@Z@4_NA
_DATA	SEGMENT
?first@?EB@??DXGISwap_ResizeTarget_Override@@YGJPAUIDXGISwapChain@@PBUDXGI_MODE_DESC@@@Z@4_NA DB 01H ; `DXGISwap_ResizeTarget_Override'::`65'::first
_DATA	ENDS
;	COMDAT ?first@?DN@??DXGISwap_ResizeTarget_Override@@YGJPAUIDXGISwapChain@@PBUDXGI_MODE_DESC@@@Z@4_NA
_DATA	SEGMENT
?first@?DN@??DXGISwap_ResizeTarget_Override@@YGJPAUIDXGISwapChain@@PBUDXGI_MODE_DESC@@@Z@4_NA DB 01H ; `DXGISwap_ResizeTarget_Override'::`61'::first
_DATA	ENDS
;	COMDAT ?first@?DB@??DXGISwap_ResizeBuffers_Override@@YGJPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z@4_NA
_DATA	SEGMENT
?first@?DB@??DXGISwap_ResizeBuffers_Override@@YGJPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z@4_NA DB 01H ; `DXGISwap_ResizeBuffers_Override'::`49'::first
_DATA	ENDS
;	COMDAT ?first@?CN@??DXGISwap_ResizeBuffers_Override@@YGJPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z@4_NA
_DATA	SEGMENT
?first@?CN@??DXGISwap_ResizeBuffers_Override@@YGJPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z@4_NA DB 01H ; `DXGISwap_ResizeBuffers_Override'::`45'::first
_DATA	ENDS
;	COMDAT __GUID_a8be2ac4_199f_4946_b331_79599fb98de7
CONST	SEGMENT
__GUID_a8be2ac4_199f_4946_b331_79599fb98de7 DD 0a8be2ac4H
	DW	0199fH
	DW	04946H
	DB	0b3H
	DB	031H
	DB	079H
	DB	059H
	DB	09fH
	DB	0b9H
	DB	08dH
	DB	0e7H
CONST	ENDS
;	COMDAT __GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa
CONST	SEGMENT
__GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa DD 0790a45f7H
	DW	0d42H
	DW	04876H
	DB	098H
	DB	03aH
	DB	0aH
	DB	055H
	DB	0cfH
	DB	0e6H
	DB	0f4H
	DB	0aaH
CONST	ENDS
;	COMDAT ?first_frame@?1??PresentCallback@@YGJPAUIDXGISwapChain@@II@Z@4_NA
_DATA	SEGMENT
?first_frame@?1??PresentCallback@@YGJPAUIDXGISwapChain@@II@Z@4_NA DB 01H ; `PresentCallback'::`2'::first_frame
_DATA	ENDS
;	COMDAT ?first_frame@?1??Present1Callback@@YGJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@Z@4_NA
_DATA	SEGMENT
?first_frame@?1??Present1Callback@@YGJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@Z@4_NA DB 01H ; `Present1Callback'::`2'::first_frame
_DATA	ENDS
;	COMDAT __GUID_cafcb56c_6ac3_4889_bf47_9e23bbd260ec
CONST	SEGMENT
__GUID_cafcb56c_6ac3_4889_bf47_9e23bbd260ec DD 0cafcb56cH
	DW	06ac3H
	DW	04889H
	DB	0bfH
	DB	047H
	DB	09eH
	DB	023H
	DB	0bbH
	DB	0d2H
	DB	060H
	DB	0ecH
CONST	ENDS
;	COMDAT __GUID_a04bfb29_08ef_43d6_a49c_a9bdbdcbe686
CONST	SEGMENT
__GUID_a04bfb29_08ef_43d6_a49c_a9bdbdcbe686 DD 0a04bfb29H
	DW	08efH
	DW	043d6H
	DB	0a4H
	DB	09cH
	DB	0a9H
	DB	0bdH
	DB	0bdH
	DB	0cbH
	DB	0e6H
	DB	086H
CONST	ENDS
;	COMDAT __GUID_645967a4_1392_4310_a798_8053ce3e93fd
CONST	SEGMENT
__GUID_645967a4_1392_4310_a798_8053ce3e93fd DD 0645967a4H
	DW	01392H
	DW	04310H
	DB	0a7H
	DB	098H
	DB	080H
	DB	053H
	DB	0ceH
	DB	03eH
	DB	093H
	DB	0fdH
CONST	ENDS
;	COMDAT __GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5
CONST	SEGMENT
__GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5 DD 0aa1ae0aH
	DW	0fa0eH
	DW	04b84H
	DB	086H
	DB	044H
	DB	0e0H
	DB	05fH
	DB	0f8H
	DB	0e5H
	DB	0acH
	DB	0b5H
CONST	ENDS
;	COMDAT __GUID_29038f61_3839_4626_91fd_086879011a05
CONST	SEGMENT
__GUID_29038f61_3839_4626_91fd_086879011a05 DD 029038f61H
	DW	03839H
	DW	04626H
	DB	091H
	DB	0fdH
	DB	08H
	DB	068H
	DB	079H
	DB	01H
	DB	01aH
	DB	05H
CONST	ENDS
;	COMDAT __GUID_2411e7e1_12ac_4ccf_bd14_9798e8534dc0
CONST	SEGMENT
__GUID_2411e7e1_12ac_4ccf_bd14_9798e8534dc0 DD 02411e7e1H
	DW	012acH
	DW	04ccfH
	DB	0bdH
	DB	014H
	DB	097H
	DB	098H
	DB	0e8H
	DB	053H
	DB	04dH
	DB	0c0H
CONST	ENDS
;	COMDAT __GUID_7632e1f5_ee65_4dca_87fd_84cd75f8838d
CONST	SEGMENT
__GUID_7632e1f5_ee65_4dca_87fd_84cd75f8838d DD 07632e1f5H
	DW	0ee65H
	DW	04dcaH
	DB	087H
	DB	0fdH
	DB	084H
	DB	0cdH
	DB	075H
	DB	0f8H
	DB	083H
	DB	08dH
CONST	ENDS
;	COMDAT __GUID_1bc6ea02_ef36_464f_bf0c_21ca39e5168a
CONST	SEGMENT
__GUID_1bc6ea02_ef36_464f_bf0c_21ca39e5168a DD 01bc6ea02H
	DW	0ef36H
	DW	0464fH
	DB	0bfH
	DB	0cH
	DB	021H
	DB	0caH
	DB	039H
	DB	0e5H
	DB	016H
	DB	08aH
CONST	ENDS
;	COMDAT __GUID_25483823_cd46_4c7d_86ca_47aa95b837bd
CONST	SEGMENT
__GUID_25483823_cd46_4c7d_86ca_47aa95b837bd DD 025483823H
	DW	0cd46H
	DW	04c7dH
	DB	086H
	DB	0caH
	DB	047H
	DB	0aaH
	DB	095H
	DB	0b8H
	DB	037H
	DB	0bdH
CONST	ENDS
;	COMDAT __GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0
CONST	SEGMENT
__GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0 DD 050c83a1cH
	DW	0e072H
	DW	04c48H
	DB	087H
	DB	0b0H
	DB	036H
	DB	030H
	DB	0faH
	DB	036H
	DB	0a6H
	DB	0d0H
CONST	ENDS
;	COMDAT __GUID_770aae78_f26f_4dba_a829_253c83d1b387
CONST	SEGMENT
__GUID_770aae78_f26f_4dba_a829_253c83d1b387 DD 0770aae78H
	DW	0f26fH
	DW	04dbaH
	DB	0a8H
	DB	029H
	DB	025H
	DB	03cH
	DB	083H
	DB	0d1H
	DB	0b3H
	DB	087H
CONST	ENDS
;	COMDAT __GUID_7b7166ec_21c7_44ae_b21a_c9ae321ae369
CONST	SEGMENT
__GUID_7b7166ec_21c7_44ae_b21a_c9ae321ae369 DD 07b7166ecH
	DW	021c7H
	DW	044aeH
	DB	0b2H
	DB	01aH
	DB	0c9H
	DB	0aeH
	DB	032H
	DB	01aH
	DB	0e3H
	DB	069H
CONST	ENDS
;	COMDAT __GUID_6f15aaf2_d208_4e89_9ab4_489535d34f9c
CONST	SEGMENT
__GUID_6f15aaf2_d208_4e89_9ab4_489535d34f9c DD 06f15aaf2H
	DW	0d208H
	DW	04e89H
	DB	09aH
	DB	0b4H
	DB	048H
	DB	095H
	DB	035H
	DB	0d3H
	DB	04fH
	DB	09cH
CONST	ENDS
;	COMDAT __GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da
CONST	SEGMENT
__GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da DD 0c0bfa96cH
	DW	0e089H
	DW	044fbH
	DB	08eH
	DB	0afH
	DB	026H
	DB	0f8H
	DB	079H
	DB	061H
	DB	090H
	DB	0daH
CONST	ENDS
;	COMDAT ??_R0?AVDefaultResourceProvider@CEGUI@@@8
data$r	SEGMENT
??_R0?AVDefaultResourceProvider@CEGUI@@@8 DD FLAT:??_7type_info@@6B@ ; CEGUI::DefaultResourceProvider `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDefaultResourceProvider@CEGUI@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVResourceProvider@CEGUI@@@8
data$r	SEGMENT
??_R0?AVResourceProvider@CEGUI@@@8 DD FLAT:??_7type_info@@6B@ ; CEGUI::ResourceProvider `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVResourceProvider@CEGUI@@', 00H
data$r	ENDS
;	COMDAT __GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140
CONST	SEGMENT
__GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140 DD 0db6f6ddbH
	DW	0ac77H
	DW	04e88H
	DB	082H
	DB	053H
	DB	081H
	DB	09dH
	DB	0f9H
	DB	0bbH
	DB	0f1H
	DB	040H
CONST	ENDS
;	COMDAT ?_AtlComModule@ATL@@3VCAtlComModule@1@A
_DATA	SEGMENT
?_AtlComModule@ATL@@3VCAtlComModule@1@A DB 04H DUP (?)
	DD	FLAT:___ImageBase			; ATL::_AtlComModule
	DD	FLAT:___pobjMapEntryFirst+4
	DD	FLAT:___pobjMapEntryLast
_DATA	ENDS
;	COMDAT ??_C@_1CK@DOIMBAJG@?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?5?$AAe?$AAr?$AAr?$AAo?$AAr?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AAl?$AAX?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@DOIMBAJG@?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?5?$AAe?$AAr?$AAr?$AAo?$AAr?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AAl?$AAX?$AA?$AA@ DB 'U'
	DB	00H, 'n', 00H, 'k', 00H, 'n', 00H, 'o', 00H, 'w', 00H, 'n', 00H
	DB	' ', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, ' '
	DB	00H, '0', 00H, 'x', 00H, '%', 00H, '0', 00H, 'l', 00H, 'X', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@KPMALOMG@?$AAI?$AAD?$AAi?$AAs?$AAp?$AAa?$AAt?$AAc?$AAh?$AA?5?$AAe?$AAr?$AAr?$AAo?$AAr?$AA?5?$AA?$CD?$AA?$CF?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@KPMALOMG@?$AAI?$AAD?$AAi?$AAs?$AAp?$AAa?$AAt?$AAc?$AAh?$AA?5?$AAe?$AAr?$AAr?$AAo?$AAr?$AA?5?$AA?$CD?$AA?$CF?$AAd?$AA?$AA@ DB 'I'
	DB	00H, 'D', 00H, 'i', 00H, 's', 00H, 'p', 00H, 'a', 00H, 't', 00H
	DB	'c', 00H, 'h', 00H, ' ', 00H, 'e', 00H, 'r', 00H, 'r', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, '#', 00H, '%', 00H, 'd', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_7_com_error@@6B@
CONST	SEGMENT
??_7_com_error@@6B@ DD FLAT:??_R4_com_error@@6B@	; _com_error::`vftable'
	DD	FLAT:??_E_com_error@@UAEPAXI@Z
CONST	ENDS
_DATA	SEGMENT
?budget_thread@@3Ubudget_thread_params_t@@A DB 08H DUP (?)
	DD	0ffffffffH				; budget_thread
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
?mem_stats@@3PAUmemory_stats_t@@A DQ ffffffffffffffffH	; mem_stats
	DQ	0000000000000000H
	DQ	ffffffffffffffffH
	DQ	0000000000000000H
	DQ	ffffffffffffffffH
	DQ	0000000000000000H
	DQ	ffffffffffffffffH
	DQ	0000000000000000H
	DQ	ffffffffffffffffH
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	ffffffffffffffffH
	DQ	0000000000000000H
	DQ	ffffffffffffffffH
	DQ	0000000000000000H
	DQ	ffffffffffffffffH
	DQ	0000000000000000H
	DQ	ffffffffffffffffH
	DQ	0000000000000000H
	DQ	ffffffffffffffffH
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	ffffffffffffffffH
	DQ	0000000000000000H
	DQ	ffffffffffffffffH
	DQ	0000000000000000H
	DQ	ffffffffffffffffH
	DQ	0000000000000000H
	DQ	ffffffffffffffffH
	DQ	0000000000000000H
	DQ	ffffffffffffffffH
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	ffffffffffffffffH
	DQ	0000000000000000H
	DQ	ffffffffffffffffH
	DQ	0000000000000000H
	DQ	ffffffffffffffffH
	DQ	0000000000000000H
	DQ	ffffffffffffffffH
	DQ	0000000000000000H
	DQ	ffffffffffffffffH
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@HPAX@1@PAU21@0U_Copy_tag@01@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@HPAX@1@PAU21@0U_Copy_tag@01@@Z$0
__unwindtable$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@HPAX@1@PAU21@0U_Copy_tag@01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@HPAX@1@PAU21@0U_Copy_tag@01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@HPAX@1@PAU21@0U_Copy_tag@01@@Z$6
__ehfuncinfo$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@HPAX@1@PAU21@0U_Copy_tag@01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@HPAX@1@PAU21@0U_Copy_tag@01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@HPAX@1@PAU21@0U_Copy_tag@01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Insert_nohint@ABHU_Nil@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@1@_NABHU_Nil@1@@Z$44 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_nohint@ABHU_Nil@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@1@_NABHU_Nil@1@@Z$0
__unwindtable$??$_Insert_nohint@ABHU_Nil@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@1@_NABHU_Nil@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert_nohint@ABHU_Nil@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@1@_NABHU_Nil@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_nohint@ABHU_Nil@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@1@_NABHU_Nil@1@@Z$44
__ehfuncinfo$??$_Insert_nohint@ABHU_Nil@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@1@_NABHU_Nil@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert_nohint@ABHU_Nil@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@1@_NABHU_Nil@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_nohint@ABHU_Nil@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@1@_NABHU_Nil@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z$13 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z$0
__tryblocktable$??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z$13
__unwindtable$??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComPtr@UIDXGIFactory5@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComPtr@UIDXGIFactory4@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComPtr@UIDXGIFactory3@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComQIPtr@UIDXGIFactory2@@$1?_GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0@@3U__s_GUID@@B@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComPtr@UIDXGIFactory2@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComQIPtr@UIDXGIFactory1@@$1?_GUID_770aae78_f26f_4dba_a829_253c83d1b387@@3U__s_GUID@@B@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComPtr@UIDXGIFactory1@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComPtr@UIDXGIOutput@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComQIPtr@UIDXGIAdapter1@@$1?_GUID_29038f61_3839_4626_91fd_086879011a05@@3U__s_GUID@@B@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComPtr@UIDXGIAdapter1@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComQIPtr@UIDXGIAdapter2@@$1?_GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5@@3U__s_GUID@@B@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComPtr@UIDXGIAdapter2@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??R<lambda_e5c15a2c98a421a829fc4b087e72baa7>@@QBEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??R<lambda_e5c15a2c98a421a829fc4b087e72baa7>@@QBEHXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??R<lambda_e5c15a2c98a421a829fc4b087e72baa7>@@QBEHXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??R<lambda_e5c15a2c98a421a829fc4b087e72baa7>@@QBEHXZ$2
	DD	01H
	DD	FLAT:__unwindfunclet$??R<lambda_e5c15a2c98a421a829fc4b087e72baa7>@@QBEHXZ$3
__ehfuncinfo$??R<lambda_e5c15a2c98a421a829fc4b087e72baa7>@@QBEHXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??R<lambda_e5c15a2c98a421a829fc4b087e72baa7>@@QBEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??R<lambda_7769376daad0f42c2f9dc7182375e5d8>@@QBEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??R<lambda_7769376daad0f42c2f9dc7182375e5d8>@@QBEHXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??R<lambda_7769376daad0f42c2f9dc7182375e5d8>@@QBEHXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??R<lambda_7769376daad0f42c2f9dc7182375e5d8>@@QBEHXZ$2
	DD	01H
	DD	FLAT:__unwindfunclet$??R<lambda_7769376daad0f42c2f9dc7182375e5d8>@@QBEHXZ$3
__ehfuncinfo$??R<lambda_7769376daad0f42c2f9dc7182375e5d8>@@QBEHXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??R<lambda_7769376daad0f42c2f9dc7182375e5d8>@@QBEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??R<lambda_49fe4316955e3999d8d7fe725292d871>@@QBEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??R<lambda_49fe4316955e3999d8d7fe725292d871>@@QBEHXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??R<lambda_49fe4316955e3999d8d7fe725292d871>@@QBEHXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$??R<lambda_49fe4316955e3999d8d7fe725292d871>@@QBEHXZ$2
__ehfuncinfo$??R<lambda_49fe4316955e3999d8d7fe725292d871>@@QBEHXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??R<lambda_49fe4316955e3999d8d7fe725292d871>@@QBEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComQIPtr@UIDXGISwapChain@@$1?_GUID_310d36a0_d2e7_4c0a_aa04_6a9d23b8886a@@3U__s_GUID@@B@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComPtr@UIDXGISwapChain@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SK_DXGI_CreateSwapChain1_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC1@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAPAUIDXGISwapChain1@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_DXGI_CreateSwapChain1_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC1@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAPAUIDXGISwapChain1@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SK_DXGI_CreateSwapChain1_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC1@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAPAUIDXGISwapChain1@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?SK_DXGI_CreateSwapChain1_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC1@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAPAUIDXGISwapChain1@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?SK_DXGI_CreateSwapChain1_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC1@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAPAUIDXGISwapChain1@@@Z$3
__ehfuncinfo$?SK_DXGI_CreateSwapChain1_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC1@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAPAUIDXGISwapChain1@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SK_DXGI_CreateSwapChain1_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC1@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAPAUIDXGISwapChain1@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComQIPtr@UID3D11Device@@$1?_GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140@@3U__s_GUID@@B@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComPtr@UIDXGIDevice1@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z$2
__ehfuncinfo$?SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?RHIV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@@<lambda_8c641e4ce6091119a877a3a3b6ce9fff>@@QBE_NW4SK_DXGI_ResType@@AAHIV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@PAUDXGI_MODE_DESC@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?RHIV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@@<lambda_8c641e4ce6091119a877a3a3b6ce9fff>@@QBE_NW4SK_DXGI_ResType@@AAHIV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@PAUDXGI_MODE_DESC@@@Z$0
__ehfuncinfo$??$?RHIV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@@<lambda_8c641e4ce6091119a877a3a3b6ce9fff>@@QBE_NW4SK_DXGI_ResType@@AAHIV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@PAUDXGI_MODE_DESC@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?RHIV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@@<lambda_8c641e4ce6091119a877a3a3b6ce9fff>@@QBE_NW4SK_DXGI_ResType@@AAHIV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@PAUDXGI_MODE_DESC@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?RHHV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@@<lambda_fc9a2ce0f8ba827916420a475022bd4b>@@QBE_NW4SK_DXGI_ResType@@AAHHV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@PAUDXGI_MODE_DESC@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?RHHV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@@<lambda_fc9a2ce0f8ba827916420a475022bd4b>@@QBE_NW4SK_DXGI_ResType@@AAHHV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@PAUDXGI_MODE_DESC@@@Z$0
__ehfuncinfo$??$?RHHV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@@<lambda_fc9a2ce0f8ba827916420a475022bd4b>@@QBE_NW4SK_DXGI_ResType@@AAHHV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@PAUDXGI_MODE_DESC@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?RHHV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@@<lambda_fc9a2ce0f8ba827916420a475022bd4b>@@QBE_NW4SK_DXGI_ResType@@AAHHV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@PAUDXGI_MODE_DESC@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?clear@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComQIPtr@UIDXGISwapChain2@@$1?_GUID_a8be2ac4_199f_4946_b331_79599fb98de7@@3U__s_GUID@@B@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComPtr@UIDXGISwapChain2@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComQIPtr@UIDXGISwapChain1@@$1?_GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa@@3U__s_GUID@@B@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComPtr@UIDXGISwapChain1@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComPtr@UIDXGIFactory@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComPtr@UIDXGIAdapter@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComPtr@UIDXGIDevice@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComPtr@UIDXGISurface@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComPtr@UID3D11DeviceContext1@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComPtr@UID3DDeviceContextState@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComPtr@UID3D11Device1@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComPtr@UID3D11BlendState@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComPtr@UID3D11RenderTargetView@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComPtr@UID3D11Texture2D@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComQIPtr@UID3D11DeviceContext@@$1?_GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da@@3U__s_GUID@@B@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1AutoClose@iSK_Logger@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??__F_AtlComModule@ATL@@YAXXZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??__F_AtlComModule@ATL@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??__F_AtlComModule@ATL@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CAtlComModule@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComPtr@UIUnknown@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?CreateDXGIFactory2@@YGJIABU_GUID@@PAPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateDXGIFactory2@@YGJIABU_GUID@@PAPAX@Z$0
__unwindtable$?EnumAdapters_Override@@YGJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?EnumAdapters_Override@@YGJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@@Z$0
__unwindtable$?EnumAdapters1_Override@@YGJPAUIDXGIFactory1@@IPAPAUIDXGIAdapter1@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?EnumAdapters1_Override@@YGJPAUIDXGIFactory1@@IPAPAUIDXGIAdapter1@@@Z$0
__unwindtable$?CreateDXGIFactory1@@YGJABU_GUID@@PAPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateDXGIFactory1@@YGJABU_GUID@@PAPAX@Z$0
__unwindtable$?CreateDXGIFactory@@YGJABU_GUID@@PAPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateDXGIFactory@@YGJABU_GUID@@PAPAX@Z$0
__unwindtable$?DXGIFactory2_CreateSwapChainForHwnd_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@PAUHWND__@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DXGIFactory2_CreateSwapChainForHwnd_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@PAUHWND__@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z$0
__unwindtable$?DXGIFactory2_CreateSwapChainForCoreWindow_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@1PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DXGIFactory2_CreateSwapChainForCoreWindow_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@1PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z$0
__unwindtable$?DXGIFactory_CreateSwapChain_Override@@YGJPAUIDXGIFactory@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DXGIFactory_CreateSwapChain_Override@@YGJPAUIDXGIFactory@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z$0
__unwindtable$?SK_DXGI_HookSwapChain@@YAXPAUIDXGISwapChain@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_DXGI_HookSwapChain@@YAXPAUIDXGISwapChain@@@Z$0
__unwindtable$?DXGISwap_ResizeTarget_Override@@YGJPAUIDXGISwapChain@@PBUDXGI_MODE_DESC@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DXGISwap_ResizeTarget_Override@@YGJPAUIDXGISwapChain@@PBUDXGI_MODE_DESC@@@Z$0
__unwindtable$?DXGISwap_ResizeBuffers_Override@@YGJPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DXGISwap_ResizeBuffers_Override@@YGJPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z$1
__unwindtable$?ApplyStateblock@@YAXPAUID3D11DeviceContext@@PAUD3DX11_STATE_BLOCK@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ApplyStateblock@@YAXPAUID3D11DeviceContext@@PAUD3DX11_STATE_BLOCK@@@Z$0
__unwindtable$?CreateStateblock@@YAXPAUID3D11DeviceContext@@PAUD3DX11_STATE_BLOCK@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateStateblock@@YAXPAUID3D11DeviceContext@@PAUD3DX11_STATE_BLOCK@@@Z$0
__unwindtable$?SK_DXGI_HookPresent@@YAXPAUIDXGISwapChain@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_DXGI_HookPresent@@YAXPAUIDXGISwapChain@@_N@Z$0
__unwindtable$?SK_GetDXGIAdapterInterfaceVer@@YAHPAUIUnknown@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_GetDXGIAdapterInterfaceVer@@YAHPAUIUnknown@@@Z$0
__unwindtable$?SK_GetDXGIAdapterInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_GetDXGIAdapterInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z$0
__unwindtable$?SK_GetDXGIFactoryInterfaceVer@@YAHPAUIUnknown@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_GetDXGIFactoryInterfaceVer@@YAHPAUIUnknown@@@Z$0
__unwindtable$?SK_GetDXGIFactoryInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_GetDXGIFactoryInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z$0
__unwindtable$?SK_DXGI_FeatureLevelsToStr@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPBK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_DXGI_FeatureLevelsToStr@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPBK@Z$1
__unwindtable$?SK_DXGI_DescribeSwapChainFlags@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4DXGI_SWAP_CHAIN_FLAG@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_DXGI_DescribeSwapChainFlags@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4DXGI_SWAP_CHAIN_FLAG@@@Z$0
__unwindtable$?ShutdownBudgetThread@DXGI@SK@@YAXXZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__unwindtable$?StartBudgetThread@DXGI@SK@@YAJPAPAUIDXGIAdapter@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?StartBudgetThread@DXGI@SK@@YAJPAPAUIDXGIAdapter@@@Z$0
__unwindtable$?SK_DXGI_HookFactory@@YAXPAUIDXGIFactory@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_DXGI_HookFactory@@YAXPAUIDXGIFactory@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SK_DXGI_HookFactory@@YAXPAUIDXGIFactory@@@Z$1
__unwindtable$?DXGIOutput_GetDisplayModeList_Override@@YGJPAUIDXGIOutput@@W4DXGI_FORMAT@@IPAIPAUDXGI_MODE_DESC@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DXGIOutput_GetDisplayModeList_Override@@YGJPAUIDXGIOutput@@W4DXGI_FORMAT@@IPAIPAUDXGI_MODE_DESC@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?DXGIOutput_GetDisplayModeList_Override@@YGJPAUIDXGIOutput@@W4DXGI_FORMAT@@IPAIPAUDXGI_MODE_DESC@@@Z$2
__catchsym$?ResetCEGUI_D3D11@@YAXPAUIDXGISwapChain@@@Z$13 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?ResetCEGUI_D3D11@@YAXPAUIDXGISwapChain@@@Z$0
__catchsym$?SK_CEGUI_InitBase@@YAXXZ$82 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?SK_CEGUI_InitBase@@YAXXZ$0
__unwindtable$?ImGui_DX11Startup@@YA_NPAUIDXGISwapChain@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ImGui_DX11Startup@@YA_NPAUIDXGISwapChain@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ImGui_DX11Startup@@YA_NPAUIDXGISwapChain@@@Z$1
__unwindtable$?SK_DXGI_UpdateSwapChain@@YAXPAUIDXGISwapChain@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_DXGI_UpdateSwapChain@@YAXPAUIDXGISwapChain@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SK_DXGI_UpdateSwapChain@@YAXPAUIDXGISwapChain@@@Z$1
__tryblocktable$?ResetCEGUI_D3D11@@YAXPAUIDXGISwapChain@@@Z DD 03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?ResetCEGUI_D3D11@@YAXPAUIDXGISwapChain@@@Z$13
__tryblocktable$?SK_CEGUI_InitBase@@YAXXZ DD 00H
	DD	033H
	DD	034H
	DD	01H
	DD	FLAT:__catchsym$?SK_CEGUI_InitBase@@YAXXZ$82
__unwindtable$?EnumAdapters_Common@@YGJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@P6GJ0I1@Z@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?EnumAdapters_Common@@YGJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@P6GJ0I1@Z@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?EnumAdapters_Common@@YGJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@P6GJ0I1@Z@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?EnumAdapters_Common@@YGJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@P6GJ0I1@Z@Z$2
__sehtable$?SK_DXGI_Present@@YAJPAUIDXGISwapChain@@II@Z DD 0ffffffffH
	DD	FLAT:$LN24@SK_DXGI_Pr
	DD	FLAT:$LN12@SK_DXGI_Pr
	DD	0ffffffffH
	DD	FLAT:$LN25@SK_DXGI_Pr
	DD	FLAT:$LN16@SK_DXGI_Pr
__unwindtable$?SK_CEGUI_RelocateLog@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_CEGUI_RelocateLog@@YAXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_CEGUI_RelocateLog@@YAXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_CEGUI_RelocateLog@@YAXXZ$2
__unwindtable$?StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ$2
__unwindtable$?SK_HookDXGI@@YGXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_HookDXGI@@YGXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_HookDXGI@@YGXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_HookDXGI@@YGXXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_HookDXGI@@YGXXZ$4
__unwindtable$?Present1Callback@@YGJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Present1Callback@@YGJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Present1Callback@@YGJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Present1Callback@@YGJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?Present1Callback@@YGJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@Z$3
__ehfuncinfo$?SK_DXGI_HookFactory@@YAXPAUIDXGIFactory@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?SK_DXGI_HookFactory@@YAXPAUIDXGIFactory@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SK_HookDXGI@@YGXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SK_HookDXGI@@YGXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?CreateDXGIFactory2@@YGJIABU_GUID@@PAPAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CreateDXGIFactory2@@YGJIABU_GUID@@PAPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?EnumAdapters_Override@@YGJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?EnumAdapters_Override@@YGJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?EnumAdapters1_Override@@YGJPAUIDXGIFactory1@@IPAPAUIDXGIAdapter1@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?EnumAdapters1_Override@@YGJPAUIDXGIFactory1@@IPAPAUIDXGIAdapter1@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?EnumAdapters_Common@@YGJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@P6GJ0I1@Z@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?EnumAdapters_Common@@YGJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@P6GJ0I1@Z@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?CreateDXGIFactory1@@YGJABU_GUID@@PAPAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CreateDXGIFactory1@@YGJABU_GUID@@PAPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?CreateDXGIFactory@@YGJABU_GUID@@PAPAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CreateDXGIFactory@@YGJABU_GUID@@PAPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?DXGIFactory2_CreateSwapChainForComposition_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?DXGIFactory2_CreateSwapChainForComposition_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?DXGIFactory2_CreateSwapChainForHwnd_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@PAUHWND__@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DXGIFactory2_CreateSwapChainForHwnd_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@PAUHWND__@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?DXGIFactory2_CreateSwapChainForCoreWindow_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@1PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DXGIFactory2_CreateSwapChainForCoreWindow_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@1PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?DXGIFactory_CreateSwapChain_Override@@YGJPAUIDXGIFactory@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DXGIFactory_CreateSwapChain_Override@@YGJPAUIDXGIFactory@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SK_DXGI_HookSwapChain@@YAXPAUIDXGISwapChain@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SK_DXGI_HookSwapChain@@YAXPAUIDXGISwapChain@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?DXGISwap_ResizeTarget_Override@@YGJPAUIDXGISwapChain@@PBUDXGI_MODE_DESC@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DXGISwap_ResizeTarget_Override@@YGJPAUIDXGISwapChain@@PBUDXGI_MODE_DESC@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?DXGISwap_ResizeBuffers_Override@@YGJPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DXGISwap_ResizeBuffers_Override@@YGJPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?DXGIOutput_GetDisplayModeList_Override@@YGJPAUIDXGIOutput@@W4DXGI_FORMAT@@IPAIPAUDXGI_MODE_DESC@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?DXGIOutput_GetDisplayModeList_Override@@YGJPAUIDXGIOutput@@W4DXGI_FORMAT@@IPAIPAUDXGI_MODE_DESC@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?PresentCallback@@YGJPAUIDXGISwapChain@@II@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?PresentCallback@@YGJPAUIDXGISwapChain@@II@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?Present1Callback@@YGJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?Present1Callback@@YGJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?ApplyStateblock@@YAXPAUID3D11DeviceContext@@PAUD3DX11_STATE_BLOCK@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ApplyStateblock@@YAXPAUID3D11DeviceContext@@PAUD3DX11_STATE_BLOCK@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?CreateStateblock@@YAXPAUID3D11DeviceContext@@PAUD3DX11_STATE_BLOCK@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CreateStateblock@@YAXPAUID3D11DeviceContext@@PAUD3DX11_STATE_BLOCK@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SK_DXGI_HookPresent@@YAXPAUIDXGISwapChain@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SK_DXGI_HookPresent@@YAXPAUIDXGISwapChain@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?HookDXGI@@YGIPAX@Z DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$?HookDXGI@@YGIPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?ResetCEGUI_D3D11@@YAXPAUIDXGISwapChain@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?ResetCEGUI_D3D11@@YAXPAUIDXGISwapChain@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$?ResetCEGUI_D3D11@@YAXPAUIDXGISwapChain@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SK_CEGUI_InitBase@@YAXXZ DD 019930522H
	DD	035H
	DD	FLAT:__unwindtable$?SK_CEGUI_InitBase@@YAXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?SK_CEGUI_InitBase@@YAXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SK_CEGUI_RelocateLog@@YAXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?SK_CEGUI_RelocateLog@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?ImGui_DX11Startup@@YA_NPAUIDXGISwapChain@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ImGui_DX11Startup@@YA_NPAUIDXGISwapChain@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SK_DXGI_UpdateSwapChain@@YAXPAUIDXGISwapChain@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?SK_DXGI_UpdateSwapChain@@YAXPAUIDXGISwapChain@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SK_GetDXGIAdapterInterfaceVer@@YAHPAUIUnknown@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SK_GetDXGIAdapterInterfaceVer@@YAHPAUIUnknown@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SK_GetDXGIAdapterInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SK_GetDXGIAdapterInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SK_GetDXGIFactoryInterfaceVer@@YAHPAUIUnknown@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SK_GetDXGIFactoryInterfaceVer@@YAHPAUIUnknown@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SK_GetDXGIFactoryInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SK_GetDXGIFactoryInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SK_DXGI_FeatureLevelsToStr@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPBK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SK_DXGI_FeatureLevelsToStr@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPBK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?SK_DXGI_DescribeSwapChainFlags@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4DXGI_SWAP_CHAIN_FLAG@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SK_DXGI_DescribeSwapChainFlags@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4DXGI_SWAP_CHAIN_FLAG@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?ShutdownBudgetThread@DXGI@SK@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ShutdownBudgetThread@DXGI@SK@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?StartBudgetThread@DXGI@SK@@YAJPAPAUIDXGIAdapter@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?StartBudgetThread@DXGI@SK@@YAJPAPAUIDXGIAdapter@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?DXGIFactory2_CreateSwapChainForComposition_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DXGIFactory2_CreateSwapChainForComposition_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?DXGIFactory2_CreateSwapChainForComposition_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z$18
	DD	01H
	DD	FLAT:__unwindfunclet$?DXGIFactory2_CreateSwapChainForComposition_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z$19
	DD	02H
	DD	FLAT:__unwindfunclet$?DXGIFactory2_CreateSwapChainForComposition_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z$20
	DD	02H
	DD	FLAT:__unwindfunclet$?DXGIFactory2_CreateSwapChainForComposition_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z$21
__unwindtable$?ResetCEGUI_D3D11@@YAXPAUIDXGISwapChain@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ResetCEGUI_D3D11@@YAXPAUIDXGISwapChain@@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?ResetCEGUI_D3D11@@YAXPAUIDXGISwapChain@@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?ResetCEGUI_D3D11@@YAXPAUIDXGISwapChain@@@Z$4
	DD	02H
	DD	00H
	DD	02H
	DD	00H
__unwindtable$?PresentCallback@@YGJPAUIDXGISwapChain@@II@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PresentCallback@@YGJPAUIDXGISwapChain@@II@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?PresentCallback@@YGJPAUIDXGISwapChain@@II@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?PresentCallback@@YGJPAUIDXGISwapChain@@II@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?PresentCallback@@YGJPAUIDXGISwapChain@@II@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?PresentCallback@@YGJPAUIDXGISwapChain@@II@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?PresentCallback@@YGJPAUIDXGISwapChain@@II@Z$5
__unwindtable$?HookDXGI@@YGIPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?HookDXGI@@YGIPAX@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?HookDXGI@@YGIPAX@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?HookDXGI@@YGIPAX@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?HookDXGI@@YGIPAX@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?HookDXGI@@YGIPAX@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?HookDXGI@@YGIPAX@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?HookDXGI@@YGIPAX@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?HookDXGI@@YGIPAX@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?HookDXGI@@YGIPAX@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?HookDXGI@@YGIPAX@Z$9
__unwindtable$?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z$10
	DD	0aH
	DD	FLAT:__unwindfunclet$?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z$11
__unwindtable$?SK_CEGUI_InitBase@@YAXXZ DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$2
	DD	01H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$3
	DD	02H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$4
	DD	03H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$5
	DD	02H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$5
	DD	01H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$5
	DD	00H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$5
	DD	07H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$6
	DD	08H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$8
	DD	0aH
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$9
	DD	07H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$10
	DD	0cH
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$11
	DD	07H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$12
	DD	0eH
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$13
	DD	07H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$14
	DD	010H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$15
	DD	07H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$16
	DD	012H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$17
	DD	07H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$18
	DD	014H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$19
	DD	07H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$20
	DD	016H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$21
	DD	07H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$22
	DD	07H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$23
	DD	07H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$24
	DD	07H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$25
	DD	07H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$26
	DD	07H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$27
	DD	07H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$28
	DD	07H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$29
	DD	01fH
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$30
	DD	07H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$31
	DD	021H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$32
	DD	07H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$33
	DD	023H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$34
	DD	07H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$35
	DD	025H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$36
	DD	07H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$37
	DD	027H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$38
	DD	07H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$39
	DD	029H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$40
	DD	07H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$41
	DD	02bH
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$42
	DD	07H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$43
	DD	07H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$44
	DD	02eH
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$45
	DD	07H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$46
	DD	030H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$47
	DD	07H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$48
	DD	032H
	DD	FLAT:__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$49
	DD	0ffffffffH
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z$18 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z$0
__unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z$18
__ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z$18 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z$0
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z$18
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_AtlWinModule$initializer$@ATL@@3P6AXXZA DD FLAT:??__E_AtlWinModule@ATL@@YAXXZ ; ATL::_AtlWinModule$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?old_threads$initializer$@@3P6AXXZA DD FLAT:??__Eold_threads@@YAXXZ ; old_threads$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@HABH@?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAEXPAHABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@HABH@?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAEXPAHABH@Z PROC ; std::allocator<std::_Tree_node<int,void *> >::construct<int,int const &>, COMDAT
; _this$ = ecx

; 839  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 841  : 		}

	pop	ebp
	ret	8
??$construct@HABH@?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAEXPAHABH@Z ENDP ; std::allocator<std::_Tree_node<int,void *> >::construct<int,int const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@HAAH@?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAEXPAHAAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@HAAH@?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAEXPAHAAH@Z PROC ; std::allocator<std::_Tree_node<int,void *> >::construct<int,int &>, COMDAT
; _this$ = ecx

; 839  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 841  : 		}

	pop	ebp
	ret	8
??$construct@HAAH@?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAEXPAHAAH@Z ENDP ; std::allocator<std::_Tree_node<int,void *> >::construct<int,int &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@HABH@?$allocator_traits@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAHABH@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@HABH@?$allocator_traits@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAHABH@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<int,void *> > >::construct<int,int const &>, COMDAT

; 958  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN8@construct:

; 959  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 960  : 		}

	pop	ebp
	ret	0
??$construct@HABH@?$allocator_traits@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAHABH@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<int,void *> > >::construct<int,int const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@HAAH@?$allocator_traits@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAHAAH@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@HAAH@?$allocator_traits@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAHAAH@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<int,void *> > >::construct<int,int &>, COMDAT

; 958  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN8@construct:

; 959  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 960  : 		}

	pop	ebp
	ret	0
??$construct@HAAH@?$allocator_traits@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAHAAH@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<int,void *> > >::construct<int,int &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@HABH@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAEXPAHABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@HABH@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAEXPAHABH@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::construct<int,int const &>, COMDAT
; _this$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 1096 : 		_Mytraits::construct(*this, _Ptr,
; 1097 : 			_STD forward<_Types>(_Args)...);
; 1098 : 		}

	pop	ebp
	ret	8
??$construct@HABH@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAEXPAHABH@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::construct<int,int const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@HAAH@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAEXPAHAAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@HAAH@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAEXPAHAAH@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::construct<int,int &>, COMDAT
; _this$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 1096 : 		_Mytraits::construct(*this, _Ptr,
; 1097 : 			_STD forward<_Types>(_Args)...);
; 1098 : 		}

	pop	ebp
	ret	8
??$construct@HAAH@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAEXPAHAAH@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::construct<int,int &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@AAH@std@@YAAAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAH@std@@YAAAHAAH@Z PROC			; std::forward<int &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@AAH@std@@YAAAHAAH@Z ENDP			; std::forward<int &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??$_Buynode@ABH@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@HPAX@1@ABH@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Buynode@ABH@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@HPAX@1@ABH@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Buynode<int const &>, COMDAT
; _this$ = ecx

; 895  : 		{	// allocate a node with defaults and set links and value

	npad	2
	push	ebp
	mov	ebp, esp

; 896  : 		_Nodeptr _Pnode = _Buynode0();

	call	?_Buynode0@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@HPAX@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Buynode0

; 596  : 		return ((reference)_Pnode->_Myval);

	lea	edx, DWORD PTR [eax+16]

; 897  : 
; 898  : 		this->_Color(_Pnode) = _Red;

	mov	WORD PTR [eax+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edx, edx
	je	SHORT $LN47@Buynode
	mov	ecx, DWORD PTR _<_Val_0>$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], ecx
$LN47@Buynode:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 911  : 		}

	pop	ebp
	ret	4
??$_Buynode@ABH@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@HPAX@1@ABH@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Buynode<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > > &>, COMDAT

; 1350 : 	{	// forward _Arg as movable

	npad	2
	push	ebp
	mov	ebp, esp

; 1351 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1352 : 	}

	pop	ebp
	ret	0
??$move@AAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??$_Buynode@AAH@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@HPAX@1@AAH@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Buynode@AAH@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@HPAX@1@AAH@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Buynode<int &>, COMDAT
; _this$ = ecx

; 895  : 		{	// allocate a node with defaults and set links and value

	npad	2
	push	ebp
	mov	ebp, esp

; 896  : 		_Nodeptr _Pnode = _Buynode0();

	call	?_Buynode0@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@HPAX@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Buynode0

; 596  : 		return ((reference)_Pnode->_Myval);

	lea	edx, DWORD PTR [eax+16]

; 897  : 
; 898  : 		this->_Color(_Pnode) = _Red;

	mov	WORD PTR [eax+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edx, edx
	je	SHORT $LN47@Buynode
	mov	ecx, DWORD PTR _<_Val_0>$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], ecx
$LN47@Buynode:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 911  : 		}

	pop	ebp
	ret	4
??$_Buynode@AAH@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@HPAX@1@AAH@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Buynode<int &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > >, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??$_Buynode_if_nil@ABH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@HPAX@1@U_Nil@1@ABH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val$ = 12						; size = 4
??$_Buynode_if_nil@ABH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@HPAX@1@U_Nil@1@ABH@Z PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Buynode_if_nil<int const &>, COMDAT
; _this$ = ecx

; 1643 : 		{	// node doesn't exist, make it

	npad	2
	push	ebp
	mov	ebp, esp

; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));

	push	DWORD PTR __Val$[ebp]
	call	??$_Buynode@ABH@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@HPAX@1@ABH@Z ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Buynode<int const &>

; 1645 : 		}

	pop	ebp
	ret	8
??$_Buynode_if_nil@ABH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@HPAX@1@U_Nil@1@ABH@Z ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Buynode_if_nil<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@@std@@YAAAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@@std@@YAAAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@@std@@YAAAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??$_Copy_or_move@HU?$integral_constant@_N$00@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@HPAX@1@AAHU_Copy_tag@01@U?$integral_constant@_N$00@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Copy_or_move@HU?$integral_constant@_N$00@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@HPAX@1@AAHU_Copy_tag@01@U?$integral_constant@_N$00@1@@Z PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Copy_or_move<int,std::integral_constant<bool,1> >, COMDAT
; _this$ = ecx

; 1954 : 		{	// copy to new node

	npad	2
	push	ebp
	mov	ebp, esp

; 1955 : 		return (this->_Buynode(_Val));

	push	DWORD PTR __Val$[ebp]
	call	??$_Buynode@AAH@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@HPAX@1@AAH@Z ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Buynode<int &>

; 1956 : 		}

	pop	ebp
	ret	12					; 0000000cH
??$_Copy_or_move@HU?$integral_constant@_N$00@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@HPAX@1@AAHU_Copy_tag@01@U?$integral_constant@_N$00@1@@Z ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Copy_or_move<int,std::integral_constant<bool,1> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1><std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 560  : 		: _Myhead(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 561  : 		_Mysize(0)

	mov	DWORD PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	ret	8
??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1><std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
;	COMDAT ??$?0AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >,bool>::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >,bool><std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > &,bool,void,0>, COMDAT
; _this$ = ecx

; 189  : 		{	// construct from moved values

	npad	2
	push	ebp
	mov	ebp, esp

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[ebp]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+4], al

; 190  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??$?0AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >,bool>::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >,bool><std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > &,bool,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
;	COMDAT ??$?0V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >,bool>::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >,bool><std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >,bool,void,0>, COMDAT
; _this$ = ecx

; 189  : 		{	// construct from moved values

	npad	2
	push	ebp
	mov	ebp, esp

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[ebp]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+4], al

; 190  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??$?0V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >,bool>::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >,bool><std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >,bool,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??$_Insert_at@ABHU_Nil@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@1@_NPAU?$_Tree_node@HPAX@1@ABHU_Nil@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
__Node$ = 24						; size = 1
??$_Insert_at@ABHU_Nil@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@1@_NPAU?$_Tree_node@HPAX@1@ABHU_Nil@1@@Z PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Insert_at<int const &,std::_Nil>, COMDAT
; _this$ = ecx

; 1843 : 		{	// add node with value next to _Wherenode, to left if _Addleft

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 1844 : 		if (max_size() - 1 <= this->_Mysize())

	cmp	DWORD PTR [edi+4], 214748363		; 0ccccccbH
	jb	SHORT $LN5@Insert_at

; 1845 : 			{	// tree would get too big, fail
; 1846 : 			_Destroy_if_not_nil(_Node);
; 1847 : 			_Xlength_error("map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN690@Insert_at:
$LN5@Insert_at:

; 1644 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));

	push	DWORD PTR __Val$[ebp]
	call	??$_Buynode@ABH@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@HPAX@1@ABH@Z ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Buynode<int const &>

; 1848 : 			}
; 1849 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1850 : 			_STD forward<_Valty>(_Val));
; 1851 : 
; 1852 : 		++this->_Mysize();

	inc	DWORD PTR [edi+4]
	mov	ebx, eax

; 1853 : 		_Newnode->_Parent = _Wherenode;

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [ebx+4], ecx

; 1854 : 
; 1855 : 		if (_Wherenode == this->_Myhead())

	mov	eax, DWORD PTR [edi]
	cmp	ecx, eax
	jne	SHORT $LN6@Insert_at

; 1856 : 			{	// first node in tree, just set head values
; 1857 : 			_Root() = _Newnode;

	mov	DWORD PTR [eax+4], ebx

; 581  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [edi]

; 1858 : 			_Lmost() = _Newnode;

	mov	DWORD PTR [eax], ebx

; 1859 : 			_Rmost() = _Newnode;

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN686@Insert_at
$LN6@Insert_at:

; 1860 : 			}
; 1861 : 		else if (_Addleft)

	cmp	BYTE PTR __Addleft$[ebp], 0
	je	SHORT $LN8@Insert_at

; 1862 : 			{	// add to left of _Wherenode
; 1863 : 			this->_Left(_Wherenode) = _Newnode;

	mov	DWORD PTR [ecx], ebx

; 581  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [edi]

; 1864 : 			if (_Wherenode == _Lmost())

	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN11@Insert_at

; 1865 : 				_Lmost() = _Newnode;

	mov	DWORD PTR [eax], ebx

; 1866 : 			}
; 1867 : 		else

	jmp	SHORT $LN11@Insert_at
$LN8@Insert_at:

; 1868 : 			{	// add to right of _Wherenode
; 1869 : 			this->_Right(_Wherenode) = _Newnode;

	mov	DWORD PTR [ecx+8], ebx

; 591  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [edi]

; 1870 : 			if (_Wherenode == _Rmost())

	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN11@Insert_at
$LN686@Insert_at:

; 1871 : 				_Rmost() = _Newnode;

	mov	DWORD PTR [eax+8], ebx
$LN11@Insert_at:

; 1872 : 			}
; 1873 : 
; 1874 : 		for (_Nodeptr _Pnode = _Newnode;
; 1875 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

	mov	eax, DWORD PTR [ebx+4]
	mov	esi, ebx
	cmp	BYTE PTR [eax+12], 0
	jne	$LN3@Insert_at
$LL2@Insert_at:

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [esi+4]

; 581  : 		return ((_Nodepref)_Pnode->_Left);

	mov	edx, DWORD PTR [eax+4]

; 1876 : 			if (this->_Parent(_Pnode)
; 1877 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

	mov	ecx, DWORD PTR [edx]
	cmp	eax, ecx
	jne	SHORT $LN12@Insert_at

; 1878 : 				{	// fixup red-red in left subtree
; 1879 : 				_Wherenode =

	mov	ecx, DWORD PTR [edx+8]

; 1880 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1881 : 				if (this->_Color(_Wherenode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	je	SHORT $LN688@Insert_at

; 1882 : 					{	// parent has two red children, blacken both
; 1883 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1884 : 					this->_Color(_Wherenode) = this->_Black;
; 1885 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1886 : 						= this->_Red;
; 1887 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1888 : 					}
; 1889 : 				else
; 1890 : 					{	// parent has red and black children
; 1891 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN16@Insert_at

; 1892 : 						{	// rotate right child to left
; 1893 : 						_Pnode = this->_Parent(_Pnode);

	mov	esi, eax

; 1894 : 						_Lrotate(_Pnode);

	mov	ecx, edi
	push	esi
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@HPAX@2@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Lrotate
$LN16@Insert_at:

; 1895 : 						}
; 1896 : 					this->_Color(this->_Parent(_Pnode)) =

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+12], 1

; 1897 : 						this->_Black;	// propagate red up
; 1898 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 0

; 1899 : 						this->_Red;
; 1900 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]

; 2128 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

	mov	edx, DWORD PTR [ecx]

; 2129 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx], eax

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx+8]

; 2131 : 		if (!this->_Isnil(this->_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN333@Insert_at

; 2132 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], ecx
$LN333@Insert_at:

; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [edi]

; 2135 : 		if (_Wherenode == _Root())

	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN334@Insert_at

; 2136 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], edx

; 2141 : 
; 2142 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx+8], ecx

; 1901 : 					}
; 1902 : 				}
; 1903 : 			else

	jmp	$LN687@Insert_at
$LN334@Insert_at:

; 591  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [ecx+4]

; 2137 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN336@Insert_at

; 2138 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], edx

; 2141 : 
; 2142 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx+8], ecx

; 1901 : 					}
; 1902 : 				}
; 1903 : 			else

	jmp	$LN687@Insert_at
$LN336@Insert_at:

; 2140 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], edx

; 2141 : 
; 2142 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx+8], ecx

; 1901 : 					}
; 1902 : 				}
; 1903 : 			else

	jmp	SHORT $LN687@Insert_at
$LN12@Insert_at:

; 1904 : 				{	// fixup red-red in right subtree
; 1905 : 				_Wherenode =
; 1906 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1907 : 				if (this->_Color(_Wherenode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	jne	SHORT $LN17@Insert_at
$LN688@Insert_at:

; 1908 : 					{	// parent has two red children, blacken both
; 1909 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

	mov	BYTE PTR [eax+12], 1

; 1910 : 					this->_Color(_Wherenode) = this->_Black;

	mov	BYTE PTR [ecx+12], 1

; 1911 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 0

; 1912 : 						this->_Red;
; 1913 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

	mov	eax, DWORD PTR [esi+4]
	mov	esi, DWORD PTR [eax+4]

; 1914 : 					}
; 1915 : 				else

	jmp	SHORT $LN18@Insert_at
$LN17@Insert_at:

; 1916 : 					{	// parent has red and black children
; 1917 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN19@Insert_at

; 1918 : 						{	// rotate left child to right
; 1919 : 						_Pnode = this->_Parent(_Pnode);

	mov	esi, eax

; 1920 : 						_Rrotate(_Pnode);

	mov	ecx, edi
	push	esi
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@HPAX@2@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Rrotate
$LN19@Insert_at:

; 1921 : 						}
; 1922 : 					this->_Color(this->_Parent(_Pnode)) =

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+12], 1

; 1923 : 						this->_Black;	// propagate red up
; 1924 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 0

; 1925 : 						this->_Red;
; 1926 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]

; 2098 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

	mov	edx, DWORD PTR [ecx+8]

; 2099 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+8], eax

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 2101 : 		if (!this->_Isnil(this->_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN532@Insert_at

; 2102 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], ecx
$LN532@Insert_at:

; 2103 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [edi]

; 2105 : 		if (_Wherenode == _Root())

	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN533@Insert_at

; 2106 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], edx

; 2107 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

	jmp	SHORT $LN536@Insert_at
$LN533@Insert_at:

; 581  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [ecx+4]

; 2107 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN535@Insert_at

; 2108 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], edx

; 2109 : 		else

	jmp	SHORT $LN536@Insert_at
$LN535@Insert_at:

; 2110 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], edx
$LN536@Insert_at:

; 2111 : 
; 2112 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx], ecx
$LN687@Insert_at:

; 2113 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], edx
$LN18@Insert_at:

; 1872 : 			}
; 1873 : 
; 1874 : 		for (_Nodeptr _Pnode = _Newnode;
; 1875 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+12], 0
	je	$LL2@Insert_at
$LN3@Insert_at:

; 1927 : 					}
; 1928 : 				}
; 1929 : 
; 1930 : 		this->_Color(_Root()) = this->_Black;	// root is always black

	mov	eax, DWORD PTR [edi]
	pop	edi
	pop	esi
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 1

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ebx
	pop	ebx

; 1931 : 		return (iterator(_Newnode, _STD addressof(this->_Get_data())));
; 1932 : 		}

	pop	ebp
	ret	20					; 00000014H
$LN689@Insert_at:
??$_Insert_at@ABHU_Nil@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@1@_NPAU?$_Tree_node@HPAX@1@ABHU_Nil@1@@Z ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Insert_at<int const &,std::_Nil>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@ABH@std@@YAABHABH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABH@std@@YAABHABH@Z PROC			; std::forward<int const &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@ABH@std@@YAABHABH@Z ENDP			; std::forward<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
;	COMDAT ??$?0AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@AAV01@X$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@V12@@std@@QAE@AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@1@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@AAV01@X$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@V12@@std@@QAE@AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@1@0@Z PROC ; std::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > >::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > ><std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > &,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > &,void,0>, COMDAT
; _this$ = ecx

; 189  : 		{	// construct from moved values

	npad	2
	push	ebp
	mov	ebp, esp

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax

; 190  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??$?0AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@AAV01@X$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@V12@@std@@QAE@AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@1@0@Z ENDP ; std::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > >::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > ><std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > &,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > &,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@0@ABV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<int> > const >, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@$$CBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@YAPBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<int> > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Distance1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@@std@@YAHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@0@0Uinput_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Distance1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@@std@@YAHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@0@0Uinput_iterator_tag@0@@Z PROC ; std::_Distance1<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > >, COMDAT

; 1094 : 	{	// return distance between iterators; input

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 331  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1095 : 	_Iter_diff_t<_InIt> _Off = 0;

	xor	esi, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 331  : 		return (this->_Ptr == _Right._Ptr);

	cmp	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1096 : 	for (; _First != _Last; ++_First)

	je	SHORT $LN56@Distance1
$LL14@Distance1:

; 1097 : 		++_Off;

	inc	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN49@Distance1

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	edx, DWORD PTR [eax+8]

; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN46@Distance1

; 63   : 			_Ptr = _Mytree::_Min(

	mov	eax, edx

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	edx, DWORD PTR [eax]

; 608  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN26@Distance1
	npad	4
$LL25@Distance1:

; 609  : 			_Pnode = _Left(_Pnode);

	mov	eax, edx

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	edx, DWORD PTR [eax]

; 608  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [edx+13], 0
	je	SHORT $LL25@Distance1

; 65   : 		else

	jmp	SHORT $LN26@Distance1
$LN46@Distance1:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

	mov	edx, DWORD PTR [eax+4]
	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN57@Distance1
$LL9@Distance1:
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN57@Distance1

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, edx
	mov	DWORD PTR __First$[ebp], eax
	mov	edx, DWORD PTR [edx+4]
	cmp	BYTE PTR [edx+13], 0
	je	SHORT $LL9@Distance1
$LN57@Distance1:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

	mov	eax, edx
$LN26@Distance1:
	mov	DWORD PTR __First$[ebp], eax
$LN49@Distance1:

; 331  : 		return (this->_Ptr == _Right._Ptr);

	cmp	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1096 : 	for (; _First != _Last; ++_First)

	jne	SHORT $LL14@Distance1
$LN56@Distance1:

; 1098 : 
; 1099 : 	return (_Off);

	mov	eax, esi
	pop	esi

; 1100 : 	}

	pop	ebp
	ret	0
??$_Distance1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@@std@@YAHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@0@0Uinput_iterator_tag@0@@Z ENDP ; std::_Distance1<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@HPAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAEXPAPAU?$_Tree_node@HPAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@HPAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAEXPAPAU?$_Tree_node@HPAX@1@AAPAU21@@Z PROC ; std::allocator<std::_Tree_node<int,void *> >::construct<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * &>, COMDAT
; _this$ = ecx

; 839  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 841  : 		}

	pop	ebp
	ret	8
??$construct@PAU?$_Tree_node@HPAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAEXPAPAU?$_Tree_node@HPAX@1@AAPAU21@@Z ENDP ; std::allocator<std::_Tree_node<int,void *> >::construct<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 839  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 841  : 		}

	pop	ebp
	ret	8
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z PROC ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>, COMDAT
; _this$ = ecx

; 839  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 841  : 		}

	pop	ebp
	ret	8
??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ENDP ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@H@?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAEXPAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@H@?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAEXPAH@Z PROC ; std::allocator<std::_Tree_node<int,void *> >::destroy<int>, COMDAT
; _this$ = ecx

; 846  : 		_Ptr->~_Uty();
; 847  : 		}

	ret	4
??$destroy@H@?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAEXPAH@Z ENDP ; std::allocator<std::_Tree_node<int,void *> >::destroy<int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z PROC ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT
; _this$ = ecx

; 839  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	edx, DWORD PTR __Ptr$[ebp]
	test	edx, edx
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
$LN3@construct:

; 841  : 		}

	pop	ebp
	ret	8
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ENDP ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@K@?$allocator@K@std@@QAEXPAK@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@K@?$allocator@K@std@@QAEXPAK@Z PROC		; std::allocator<unsigned long>::destroy<unsigned long>, COMDAT
; _this$ = ecx

; 846  : 		_Ptr->~_Uty();
; 847  : 		}

	ret	4
??$destroy@K@?$allocator@K@std@@QAEXPAK@Z ENDP		; std::allocator<unsigned long>::destroy<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@_N@std@@YA$$QA_NAA_N@Z PROC			; std::forward<bool>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@_N@std@@YA$$QA_NAA_N@Z ENDP			; std::forward<bool>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@HPAX@std@@@?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAEXPAPAU?$_Tree_node@HPAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@HPAX@std@@@?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAEXPAPAU?$_Tree_node@HPAX@1@@Z PROC ; std::allocator<std::_Tree_node<int,void *> >::destroy<std::_Tree_node<int,void *> *>, COMDAT
; _this$ = ecx

; 846  : 		_Ptr->~_Uty();
; 847  : 		}

	ret	4
??$destroy@PAU?$_Tree_node@HPAX@std@@@?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAEXPAPAU?$_Tree_node@HPAX@1@@Z ENDP ; std::allocator<std::_Tree_node<int,void *> >::destroy<std::_Tree_node<int,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z PROC ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>, COMDAT
; _this$ = ecx

; 846  : 		_Ptr->~_Uty();
; 847  : 		}

	ret	4
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ENDP ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 846  : 		_Ptr->~_Uty();
; 847  : 		}

	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z PROC	; std::allocator<wchar_t>::destroy<wchar_t *>, COMDAT
; _this$ = ecx

; 846  : 		_Ptr->~_Uty();
; 847  : 		}

	ret	4
??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ENDP	; std::allocator<wchar_t>::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PAK@?$allocator@K@std@@QAEXPAPAK@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAK@?$allocator@K@std@@QAEXPAPAK@Z PROC	; std::allocator<unsigned long>::destroy<unsigned long *>, COMDAT
; _this$ = ecx

; 846  : 		_Ptr->~_Uty();
; 847  : 		}

	ret	4
??$destroy@PAK@?$allocator@K@std@@QAEXPAPAK@Z ENDP	; std::allocator<unsigned long>::destroy<unsigned long *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@AAPAUSK_D3D11_Stateblock_Lite@@@std@@YAAAPAUSK_D3D11_Stateblock_Lite@@AAPAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAUSK_D3D11_Stateblock_Lite@@@std@@YAAAPAUSK_D3D11_Stateblock_Lite@@AAPAU1@@Z PROC ; std::forward<SK_D3D11_Stateblock_Lite * &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@AAPAUSK_D3D11_Stateblock_Lite@@@std@@YAAAPAUSK_D3D11_Stateblock_Lite@@AAPAU1@@Z ENDP ; std::forward<SK_D3D11_Stateblock_Lite * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@HPAX@1@PAU21@0U_Copy_tag@01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Newroot$ = 12						; size = 4
__Wherenode$ = 12					; size = 4
__Movefl$ = 16						; size = 1
??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@HPAX@1@PAU21@0U_Copy_tag@01@@Z PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Copy_nodes<std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Copy_tag>, COMDAT
; _this$ = ecx

; 1975 : 		{	// copy entire subtree, recursively

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@HPAX@1@PAU21@0U_Copy_tag@01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8

; 1976 : 		_Nodeptr _Newroot = this->_Myhead();	// point at nil node
; 1977 : 
; 1978 : 		if (!this->_Isnil(_Rootnode))

	mov	eax, DWORD PTR __Rootnode$[ebp]
	push	ebx
	push	esi
	mov	esi, ecx
	cmp	BYTE PTR [eax+13], 0
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, DWORD PTR [esi]
	mov	DWORD PTR _this$[ebp], esi
	jne	SHORT $LN8@Copy_nodes

; 596  : 		return ((reference)_Pnode->_Myval);

	add	eax, 16					; 00000010H

; 1955 : 		return (this->_Buynode(_Val));

	push	eax
	call	??$_Buynode@AAH@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@HPAX@1@AAH@Z ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Buynode<int &>

; 1979 : 			{	// copy or move a node, then any subtrees
; 1980 : 			typename is_same<key_type, value_type>::type _Is_set;
; 1981 : 			_Nodeptr _Pnode = _Copy_or_move(
; 1982 : 				this->_Myval(_Rootnode), _Movefl, _Is_set);
; 1983 : 			_Pnode->_Parent = _Wherenode;
; 1984 : 			_Pnode->_Color = this->_Color(_Rootnode);

	mov	ecx, DWORD PTR __Rootnode$[ebp]
	mov	ebx, eax
	mov	eax, DWORD PTR __Wherenode$[ebp]

; 1985 : 			if (this->_Isnil(_Newroot))
; 1986 : 				_Newroot = _Pnode;	// memorize new root
; 1987 : 
; 1988 : 			_TRY_BEGIN
; 1989 : 			this->_Left(_Pnode) =

	push	DWORD PTR __Movefl$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	DWORD PTR [ebx+4], eax
	mov	al, BYTE PTR [ecx+12]
	mov	BYTE PTR [ebx+12], al
	cmp	BYTE PTR [edi+13], 0
	push	ebx
	push	DWORD PTR [ecx]
	cmovne	edi, ebx
	mov	ecx, esi
	mov	DWORD PTR __Newroot$[ebp], edi
	call	??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@HPAX@1@PAU21@0U_Copy_tag@01@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Copy_nodes<std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Copy_tag>

; 1990 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1991 : 			this->_Right(_Pnode) =

	push	DWORD PTR __Movefl$[ebp]
	mov	DWORD PTR [ebx], eax
	mov	ecx, esi
	mov	eax, DWORD PTR __Rootnode$[ebp]
	push	ebx
	push	DWORD PTR [eax+8]
	call	??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@HPAX@1@PAU21@0U_Copy_tag@01@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Copy_nodes<std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Copy_tag>
	mov	DWORD PTR [ebx+8], eax
$LN8@Copy_nodes:

; 1996 : 			_CATCH_END
; 1997 : 			}
; 1998 : 
; 1999 : 		return (_Newroot);	// return newly constructed tree
; 2000 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	eax, edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@HPAX@1@PAU21@0U_Copy_tag@01@@Z$0:

; 1992 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1993 : 			_CATCH_ALL
; 1994 : 			_Erase(_Newroot);	// subtree copy failed, bail out

	push	DWORD PTR __Newroot$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@HPAX@2@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Erase

; 1995 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN58@Copy_nodes:
$LN57@Copy_nodes:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@HPAX@1@PAU21@0U_Copy_tag@01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@HPAX@1@PAU21@0U_Copy_tag@01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@HPAX@1@PAU21@0U_Copy_tag@01@@Z ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Copy_nodes<std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Copy_tag>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0ABU?$less@H@std@@U_One_then_variadic_args_t@1@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@H@1@$$QAU21@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
_<_Val2_0>$ = 16					; size = 4
_<_Val2_1>$ = 20					; size = 4
??$?0ABU?$less@H@std@@U_One_then_variadic_args_t@1@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@H@1@$$QAU21@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>,1>::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>,1><std::less<int> const &,std::_One_then_variadic_args_t,std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 560  : 		: _Myhead(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 561  : 		_Mysize(0)

	mov	DWORD PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	ret	16					; 00000010H
??$?0ABU?$less@H@std@@U_One_then_variadic_args_t@1@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@H@1@$$QAU21@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>,1>::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>,1><std::less<int> const &,std::_One_then_variadic_args_t,std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??$_Insert_nohint@ABHU_Nil@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@1@_NABHU_Nil@1@@Z
_TEXT	SEGMENT
_this$1$ = -28						; size = 4
tv489 = -24						; size = 4
__Addleft$2 = -20					; size = 1
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
$T3 = 12						; size = 4
__Where$4 = 12						; size = 4
__Leftish$ = 12						; size = 1
__Val$ = 16						; size = 4
__Newnode$ = 20						; size = 1
??$_Insert_nohint@ABHU_Nil@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@1@_NABHU_Nil@1@@Z PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Insert_nohint<int const &,std::_Nil>, COMDAT
; _this$ = ecx

; 1784 : 		{	// try to insert node, on left if _Leftish

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert_nohint@ABHU_Nil@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@1@_NABHU_Nil@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	mov	ebx, ecx

; 1785 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	push	esi
	push	edi
	mov	edi, DWORD PTR __Val$[ebp]

; 1788 : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	dl, 1

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	ecx, DWORD PTR [ebx]

; 1787 : 		_Nodeptr _Wherenode = this->_Myhead();

	mov	esi, ecx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$1$[ebp], ebx

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	DWORD PTR tv489[ebp], ecx

; 1786 : 		_Nodeptr _Trynode = _Root();

	mov	eax, DWORD PTR [ecx+4]

; 1788 : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	BYTE PTR __Addleft$2[ebp], dl

; 1789 : 
; 1790 : 		while (!this->_Isnil(_Trynode))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN3@Insert_noh
	mov	ecx, DWORD PTR [edi]
	mov	bl, BYTE PTR __Leftish$[ebp]
	npad	4
$LL2@Insert_noh:

; 1791 : 			{	// look for leaf to insert before (_Addleft) or after
; 1792 : 			_Wherenode = _Trynode;

	mov	esi, eax

; 1793 : 			if (_Leftish)

	test	bl, bl
	je	SHORT $LN5@Insert_noh
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 234  : 		return (_Left < _Right);

	cmp	DWORD PTR [eax+16], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1794 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),

	setge	dl

; 1795 : 					this->_Key(_Trynode),
; 1796 : 					this->_Kfn(_Val));	// favor left end
; 1797 : 			else

	jmp	SHORT $LN247@Insert_noh
$LN5@Insert_noh:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 234  : 		return (_Left < _Right);

	cmp	ecx, DWORD PTR [eax+16]
	setl	dl
$LN247@Insert_noh:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1798 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),

	mov	BYTE PTR __Addleft$2[ebp], dl

; 1799 : 					this->_Kfn(_Val),
; 1800 : 					this->_Key(_Trynode));	// favor right end
; 1801 : 			_Trynode = _Addleft ? this->_Left(_Trynode)

	test	dl, dl
	je	SHORT $LN16@Insert_noh
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN17@Insert_noh
$LN16@Insert_noh:
	mov	eax, DWORD PTR [eax+8]
$LN17@Insert_noh:

; 1789 : 
; 1790 : 		while (!this->_Isnil(_Trynode))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@Insert_noh
	mov	ecx, DWORD PTR tv489[ebp]
	mov	ebx, DWORD PTR _this$1$[ebp]
$LN3@Insert_noh:

; 43   : 		: _Ptr(_Pnode)

	mov	eax, esi
	mov	DWORD PTR __Where$4[ebp], eax

; 1802 : 				: this->_Right(_Trynode);
; 1803 : 			}
; 1804 : 
; 1805 : #pragma warning(push)
; 1806 : #pragma warning(disable: 4127)	// conditional expression is constant
; 1807 : 		if (this->_Multi)
; 1808 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1809 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1810 : 		else
; 1811 : 			{	// insert only if unique
; 1812 : 			iterator _Where = iterator(_Wherenode, _STD addressof(this->_Get_data()));
; 1813 : 			if (!_Addleft)

	test	dl, dl
	je	SHORT $LN12@Insert_noh

; 331  : 		return (this->_Ptr == _Right._Ptr);

	cmp	esi, DWORD PTR [ecx]

; 1814 : 				;	// need to test if insert after is okay
; 1815 : 			else if (_Where == begin())

	jne	SHORT $LN11@Insert_noh

; 1816 : 				return (_Pairib(_Insert_at(true, _Wherenode,

	push	DWORD PTR __Newnode$[ebp]
	push	edi
	push	esi
	push	1
$LN248@Insert_noh:
	lea	eax, DWORD PTR $T3[ebp]
	mov	ecx, ebx
	push	eax
	call	??$_Insert_at@ABHU_Nil@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@1@_NPAU?$_Tree_node@HPAX@1@ABHU_Nil@1@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Insert_at<int const &,std::_Nil>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1837 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN11@Insert_noh:

; 306  : 		--static_cast<_Mybase&>(*this);

	lea	ecx, DWORD PTR __Where$4[ebp]
	call	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::operator--
	mov	eax, DWORD PTR __Where$4[ebp]
$LN12@Insert_noh:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 234  : 		return (_Left < _Right);

	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1821 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),

	jge	SHORT $LN13@Insert_noh

; 1822 : 				this->_Key(_Where._Mynode()),
; 1823 : 				this->_Kfn(_Val)))
; 1824 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,

	push	DWORD PTR __Newnode$[ebp]
	push	edi
	push	esi
	push	DWORD PTR __Addleft$2[ebp]
	jmp	SHORT $LN248@Insert_noh
__catch$??$_Insert_nohint@ABHU_Nil@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@1@_NABHU_Nil@1@@Z$0:

; 1830 : 				}
; 1831 : 			}
; 1832 : #pragma warning(pop)
; 1833 : 		_CATCH_ALL
; 1834 : 		_Destroy_if_not_nil(_Newnode);
; 1835 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN249@Insert_noh:
$LN13@Insert_noh:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1837 : 		}

	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1829 : 				return (_Pairib(_Where, false));

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1837 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN246@Insert_noh:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_nohint@ABHU_Nil@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@1@_NABHU_Nil@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Insert_nohint@ABHU_Nil@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@1@_NABHU_Nil@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert_nohint@ABHU_Nil@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@1@_NABHU_Nil@1@@Z ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Insert_nohint<int const &,std::_Nil>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??$_Eqrange@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@V12@@1@ABH@Z
_TEXT	SEGMENT
tv444 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Eqrange@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@V12@@1@ABH@Z PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Eqrange<int>, COMDAT
; _this$ = ecx

; 2004 : 		{	// find leftmost node not less than _Keyval

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx

; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))

	mov	ebx, DWORD PTR __Keyval$[ebp]
	push	edi

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	edi, DWORD PTR [ecx]

; 2006 : 		_Nodeptr _Lonode = this->_Myhead();	// end() if search fails
; 2007 : 		_Nodeptr _Hinode = this->_Myhead();	// end() if search fails

	mov	ecx, edi

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	lea	eax, DWORD PTR [edi+4]
	mov	DWORD PTR tv444[ebp], eax

; 2005 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR [eax]

; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN3@Eqrange
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 234  : 		return (_Left < _Right);

	mov	esi, DWORD PTR [ebx]
$LL2@Eqrange:
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 2010 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

	jge	SHORT $LN6@Eqrange

; 2011 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

	mov	eax, DWORD PTR [eax+8]

; 2012 : 			else

	jmp	SHORT $LN7@Eqrange
$LN6@Eqrange:

; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,

	cmp	BYTE PTR [ecx+13], 0
	je	SHORT $LN8@Eqrange
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 234  : 		return (_Left < _Right);

	cmp	esi, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 2015 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,

	cmovl	ecx, eax
$LN8@Eqrange:

; 2016 : 						this->_Key(_Pnode)))
; 2017 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2018 : 				_Lonode = _Pnode;

	mov	edi, eax

; 2019 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

	mov	eax, DWORD PTR [eax]
$LN7@Eqrange:

; 2008 : 
; 2009 : 		while (!this->_Isnil(_Pnode))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@Eqrange
	pop	esi
$LN3@Eqrange:

; 2020 : 				}
; 2021 : 
; 2022 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()

	cmp	BYTE PTR [ecx+13], 0
	mov	eax, ecx
	cmovne	eax, DWORD PTR tv444[ebp]
	mov	eax, DWORD PTR [eax]

; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN5@Eqrange
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 234  : 		return (_Left < _Right);

	mov	edx, DWORD PTR [ebx]
$LL4@Eqrange:
	cmp	edx, DWORD PTR [eax+16]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 2025 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))

	jge	SHORT $LN9@Eqrange

; 2026 : 				{	// _Pnode greater than _Keyval, remember it
; 2027 : 				_Hinode = _Pnode;

	mov	ecx, eax

; 2028 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

	mov	eax, DWORD PTR [eax]

; 2029 : 				}
; 2030 : 			else

	jmp	SHORT $LN10@Eqrange
$LN9@Eqrange:

; 2031 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

	mov	eax, DWORD PTR [eax+8]
$LN10@Eqrange:

; 2023 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2024 : 		while (!this->_Isnil(_Pnode))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL4@Eqrange
$LN5@Eqrange:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edi
	pop	edi

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	DWORD PTR [eax+4], ecx
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 2036 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$_Eqrange@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@V12@@1@ABH@Z ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Eqrange<int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??$_Traits_equal@U?$char_traits@_W@std@@@std@@YA_NQB_WI0I@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Left_size$ = 12					; size = 4
__Right$ = 16						; size = 4
__Right_size$ = 20					; size = 4
??$_Traits_equal@U?$char_traits@_W@std@@@std@@YA_NQB_WI0I@Z PROC ; std::_Traits_equal<std::char_traits<wchar_t> >, COMDAT

; 24   : 	{	// compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) for equality using _Traits

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

	mov	esi, DWORD PTR __Left_size$[ebp]
	cmp	esi, DWORD PTR __Right_size$[ebp]
	jne	SHORT $LN3@Traits_equ
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 284  : 		return (_CSTD wmemcmp(_First1, _First2, _Count));

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Left$[ebp]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 216  :         for (; 0 < _N; ++_S1, ++_S2, --_N)

	test	esi, esi
	je	SHORT $LN19@Traits_equ
$LL11@Traits_equ:

; 217  :             if (*_S1 != *_S2)

	mov	ax, WORD PTR [edx]
	cmp	ax, WORD PTR [ecx]
	jne	SHORT $LN15@Traits_equ

; 216  :         for (; 0 < _N; ++_S1, ++_S2, --_N)

	add	edx, 2
	add	ecx, 2
	sub	esi, 1
	jne	SHORT $LL11@Traits_equ
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

	mov	al, 1
	pop	esi

; 26   : 	}

	pop	ebp
	ret	0
$LN15@Traits_equ:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 218  :                 return *_S1 < *_S2 ? -1 : 1;

	movzx	eax, WORD PTR [edx]
	cmp	ax, WORD PTR [ecx]
	sbb	eax, eax
	and	eax, -2					; fffffffeH
	add	eax, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

	jne	SHORT $LN3@Traits_equ
$LN19@Traits_equ:
	mov	al, 1
	pop	esi

; 26   : 	}

	pop	ebp
	ret	0
$LN3@Traits_equ:

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

	xor	al, al
	pop	esi

; 26   : 	}

	pop	ebp
	ret	0
??$_Traits_equal@U?$char_traits@_W@std@@@std@@YA_NQB_WI0I@Z ENDP ; std::_Traits_equal<std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$distance@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@@std@@YAHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@0@0@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$distance@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@@std@@YAHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@0@0@Z PROC ; std::distance<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > >, COMDAT

; 1112 : 	{	// return distance between iterators

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 1113 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp]
	call	??$_Distance1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@@std@@YAHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@0@0Uinput_iterator_tag@0@@Z ; std::_Distance1<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > >
	add	esp, 12					; 0000000cH

; 1114 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$distance@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@@std@@YAHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@0@0@Z ENDP ; std::distance<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@HPAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAPAU?$_Tree_node@HPAX@1@AAPAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAU?$_Tree_node@HPAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAPAU?$_Tree_node@HPAX@1@AAPAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<int,void *> > >::construct<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * &>, COMDAT

; 958  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN8@construct:

; 959  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 960  : 		}

	pop	ebp
	ret	0
??$construct@PAU?$_Tree_node@HPAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAPAU?$_Tree_node@HPAX@1@AAPAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<int,void *> > >::construct<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@AAPAU?$_Tree_node@HPAX@std@@@std@@YAAAPAU?$_Tree_node@HPAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAU?$_Tree_node@HPAX@std@@@std@@YAAAPAU?$_Tree_node@HPAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<int,void *> * &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@AAPAU?$_Tree_node@HPAX@std@@@std@@YAAAPAU?$_Tree_node@HPAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<int,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 958  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN8@construct:

; 959  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 960  : 		}

	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>, COMDAT

; 958  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN8@construct:

; 959  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 960  : 		}

	pop	ebp
	ret	0
??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z PROC		; std::forward<wchar_t * &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ENDP		; std::forward<wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@H@?$allocator_traits@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAH@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@H@?$allocator_traits@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAH@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<int,void *> > >::destroy<int>, COMDAT

; 965  : 		_Al.destroy(_Ptr);
; 966  : 		}

	ret	0
??$destroy@H@?$allocator_traits@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAH@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<int,void *> > >::destroy<int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$move@AAD@std@@YA$$QADAAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAD@std@@YA$$QADAAD@Z PROC			; std::move<char &>, COMDAT

; 1350 : 	{	// forward _Arg as movable

	npad	2
	push	ebp
	mov	ebp, esp

; 1351 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1352 : 	}

	pop	ebp
	ret	0
??$move@AAD@std@@YA$$QADAAD@Z ENDP			; std::move<char &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT

; 958  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	edx, DWORD PTR __Ptr$[ebp]
	test	edx, edx
	je	SHORT $LN8@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
$LN8@construct:

; 959  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 960  : 		}

	pop	ebp
	ret	0
??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z PROC ; std::forward<std::_Container_proxy>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ENDP ; std::forward<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@K@?$allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@PAK@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@K@?$allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@PAK@Z PROC ; std::allocator_traits<std::allocator<unsigned long> >::destroy<unsigned long>, COMDAT

; 965  : 		_Al.destroy(_Ptr);
; 966  : 		}

	ret	0
??$destroy@K@?$allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@PAK@Z ENDP ; std::allocator_traits<std::allocator<unsigned long> >::destroy<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 560  : 		: _Myhead(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 304  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 561  : 		_Mysize(0)

	mov	DWORD PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 304  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z PROC ; std::forward<std::_Zero_then_variadic_args_t>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@U_Zero_then_variadic_args_t@std@@@std@@YA$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z ENDP ; std::forward<std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@ABU?$less@H@std@@@std@@YAABU?$less@H@0@ABU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABU?$less@H@std@@@std@@YAABU?$less@H@0@ABU10@@Z PROC ; std::forward<std::less<int> const &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@ABU?$less@H@std@@@std@@YAABU?$less@H@0@ABU10@@Z ENDP ; std::forward<std::less<int> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@HPAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAPAU?$_Tree_node@HPAX@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAU?$_Tree_node@HPAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAPAU?$_Tree_node@HPAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<int,void *> > >::destroy<std::_Tree_node<int,void *> *>, COMDAT

; 965  : 		_Al.destroy(_Ptr);
; 966  : 		}

	ret	0
??$destroy@PAU?$_Tree_node@HPAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAPAU?$_Tree_node@HPAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<int,void *> > >::destroy<std::_Tree_node<int,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>, COMDAT

; 965  : 		_Al.destroy(_Ptr);
; 966  : 		}

	ret	0
??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$?0K@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@K@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0K@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@K@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><unsigned long>, COMDAT
; _this$ = ecx

; 813  : 		}

	mov	eax, ecx
	ret	4
??$?0K@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@K@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 965  : 		_Al.destroy(_Ptr);
; 966  : 		}

	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>, COMDAT

; 965  : 		_Al.destroy(_Ptr);
; 966  : 		}

	ret	0
??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PAK@?$allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@PAPAK@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAK@?$allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@PAPAK@Z PROC ; std::allocator_traits<std::allocator<unsigned long> >::destroy<unsigned long *>, COMDAT

; 965  : 		_Al.destroy(_Ptr);
; 966  : 		}

	ret	0
??$destroy@PAK@?$allocator_traits@V?$allocator@K@std@@@std@@SAXAAV?$allocator@K@1@PAPAK@Z ENDP ; std::allocator_traits<std::allocator<unsigned long> >::destroy<unsigned long *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$?0K@?$allocator@PAK@std@@QAE@ABV?$allocator@K@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0K@?$allocator@PAK@std@@QAE@ABV?$allocator@K@1@@Z PROC ; std::allocator<unsigned long *>::allocator<unsigned long *><unsigned long>, COMDAT
; _this$ = ecx

; 813  : 		}

	mov	eax, ecx
	ret	4
??$?0K@?$allocator@PAK@std@@QAE@ABV?$allocator@K@1@@Z ENDP ; std::allocator<unsigned long *>::allocator<unsigned long *><unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@AAU?$_Wrap_alloc@V?$allocator@K@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@K@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU?$_Wrap_alloc@V?$allocator@K@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@K@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<unsigned long> > &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@AAU?$_Wrap_alloc@V?$allocator@K@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@K@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<unsigned long> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@YA$$QAV?$allocator@U?$_Tree_node@HPAX@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@YA$$QAV?$allocator@U?$_Tree_node@HPAX@std@@@0@AAV10@@Z PROC ; std::forward<std::allocator<std::_Tree_node<int,void *> > >, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@YA$$QAV?$allocator@U?$_Tree_node@HPAX@std@@@0@AAV10@@Z ENDP ; std::forward<std::allocator<std::_Tree_node<int,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@U_One_then_variadic_args_t@std@@@std@@YA$$QAU_One_then_variadic_args_t@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_One_then_variadic_args_t@std@@@std@@YA$$QAU_One_then_variadic_args_t@0@AAU10@@Z PROC ; std::forward<std::_One_then_variadic_args_t>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@U_One_then_variadic_args_t@std@@@std@@YA$$QAU_One_then_variadic_args_t@0@AAU10@@Z ENDP ; std::forward<std::_One_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1596 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	ret	8
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><std::_Wrap_alloc<std::allocator<wchar_t> > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1596 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	ret	8
??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><std::_Wrap_alloc<std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<wchar_t> > >, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0AAPAUSK_D3D11_Stateblock_Lite@@@?$_Compressed_pair@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@PAUSK_D3D11_Stateblock_Lite@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAUSK_D3D11_Stateblock_Lite@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
_<_Val2_0>$ = 12					; size = 4
??$?0AAPAUSK_D3D11_Stateblock_Lite@@@?$_Compressed_pair@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@PAUSK_D3D11_Stateblock_Lite@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAUSK_D3D11_Stateblock_Lite@@@Z PROC ; std::_Compressed_pair<std::default_delete<SK_D3D11_Stateblock_Lite>,SK_D3D11_Stateblock_Lite *,1>::_Compressed_pair<std::default_delete<SK_D3D11_Stateblock_Lite>,SK_D3D11_Stateblock_Lite *,1><SK_D3D11_Stateblock_Lite * &>, COMDAT
; _this$ = ecx

; 303  : 		{	// construct from forwarded values

	npad	2
	push	ebp
	mov	ebp, esp

; 302  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	mov	eax, DWORD PTR _<_Val2_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 304  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??$?0AAPAUSK_D3D11_Stateblock_Lite@@@?$_Compressed_pair@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@PAUSK_D3D11_Stateblock_Lite@@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAUSK_D3D11_Stateblock_Lite@@@Z ENDP ; std::_Compressed_pair<std::default_delete<SK_D3D11_Stateblock_Lite>,SK_D3D11_Stateblock_Lite *,1>::_Compressed_pair<std::default_delete<SK_D3D11_Stateblock_Lite>,SK_D3D11_Stateblock_Lite *,1><SK_D3D11_Stateblock_Lite * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??$_Copy@U_Copy_tag@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXABV01@U_Copy_tag@01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Movefl$ = 12						; size = 1
??$_Copy@U_Copy_tag@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXABV01@U_Copy_tag@01@@Z PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Copy<std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Copy_tag>, COMDAT
; _this$ = ecx

; 1936 : 		{	// copy or move entire tree from _Right

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	edi, DWORD PTR __Right$[ebp]

; 1936 : 		{	// copy or move entire tree from _Right

	mov	ebx, ecx

; 1937 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead(), _Movefl);

	push	DWORD PTR __Movefl$[ebp]

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [edi]
	mov	esi, DWORD PTR [ebx]

; 1937 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead(), _Movefl);

	push	esi
	push	DWORD PTR [eax+4]
	call	??$_Copy_nodes@U_Copy_tag@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@HPAX@1@PAU21@0U_Copy_tag@01@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Copy_nodes<std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Copy_tag>
	mov	DWORD PTR [esi+4], eax

; 1938 : 		this->_Mysize() = _Right.size();

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [ebx+4], eax

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	edx, DWORD PTR [ebx]

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR [edx+4]

; 1939 : 		if (!this->_Isnil(_Root()))

	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN2@Copy

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 608  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN124@Copy
	npad	7
$LL123@Copy:

; 609  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 608  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL123@Copy
$LN124@Copy:

; 1940 : 			{	// nonempty tree, look for new smallest and largest
; 1941 : 			_Lmost() = this->_Min(_Root());

	mov	DWORD PTR [edx], ecx

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	edx, DWORD PTR [ebx]

; 686  : 		return (_Tree_val<_Val_types>::_Max(_Pnode));

	mov	ecx, DWORD PTR [edx+4]

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 601  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN172@Copy
	npad	6
$LL171@Copy:

; 602  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 601  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL171@Copy
$LN172@Copy:
	pop	edi
	pop	esi

; 1942 : 			_Rmost() = this->_Max(_Root());

	mov	DWORD PTR [edx+8], ecx
	pop	ebx

; 1948 : 			}
; 1949 : 		}

	pop	ebp
	ret	8
$LN2@Copy:

; 1943 : 			}
; 1944 : 		else
; 1945 : 			{	// empty tree, just tidy head pointers
; 1946 : 			_Lmost() = this->_Myhead();

	mov	DWORD PTR [edx], edx

; 591  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [ebx]
	pop	edi
	pop	esi
	pop	ebx

; 1947 : 			_Rmost() = this->_Myhead();

	mov	DWORD PTR [eax+8], eax

; 1948 : 			}
; 1949 : 		}

	pop	ebp
	ret	8
??$_Copy@U_Copy_tag@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXABV01@U_Copy_tag@01@@Z ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Copy<std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Copy_tag>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@X@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@X@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> ><std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,void>, COMDAT
; _this$ = ecx

; 707  : 		{	// construct from comparator, allocator

	npad	2
	push	esi
	mov	esi, ecx

; 560  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 561  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 714  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@HPAX@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax

; 708  : 		_Construct();
; 709  : 		}

	mov	eax, esi
	pop	esi
	ret	8
??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@X@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> ><std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > > >, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??$insert@$0A@$0A@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@1@ABH@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$insert@$0A@$0A@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@1@ABH@Z PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::insert<0,0>, COMDAT
; _this$ = ecx

; 1208 : 		{	// try to insert node with value _Val, favoring right side

	npad	2
	push	ebp
	mov	ebp, esp

; 1209 : 		return (_Insert_nohint(false,

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Val$[ebp]
	push	0
	push	DWORD PTR ___$ReturnUdt$[ebp]
	call	??$_Insert_nohint@ABHU_Nil@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@1@_NABHU_Nil@1@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Insert_nohint<int const &,std::_Nil>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1210 : 			_Val, _Nil()));
; 1211 : 		}

	pop	ebp
	ret	8
??$insert@$0A@$0A@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@1@ABH@Z ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::insert<0,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@HPAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@HPAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@HPAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@HPAX@1@AAPAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::construct<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * &>, COMDAT
; _this$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 1096 : 		_Mytraits::construct(*this, _Ptr,
; 1097 : 			_STD forward<_Types>(_Args)...);
; 1098 : 		}

	pop	ebp
	ret	8
??$construct@PAU?$_Tree_node@HPAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@HPAX@1@AAPAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::construct<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z PROC ; std::addressof<std::_Container_proxy>, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ENDP ; std::addressof<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 1096 : 		_Mytraits::construct(*this, _Ptr,
; 1097 : 			_STD forward<_Types>(_Args)...);
; 1098 : 		}

	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>, COMDAT
; _this$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 1096 : 		_Mytraits::construct(*this, _Ptr,
; 1097 : 			_STD forward<_Types>(_Args)...);
; 1098 : 		}

	pop	ebp
	ret	8
??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@H@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAEXPAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@H@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAEXPAH@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::destroy<int>, COMDAT
; _this$ = ecx

; 1103 : 		_Mytraits::destroy(*this, _Ptr);
; 1104 : 		}

	ret	4
??$destroy@H@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAEXPAH@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::destroy<int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@H@std@@YAPAHAAH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@H@std@@YAPAHAAH@Z PROC			; std::addressof<int>, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@H@std@@YAPAHAAH@Z ENDP			; std::addressof<int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
;	COMDAT ??$swap@DX@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@DX@std@@YAXAAD0@Z PROC				; std::swap<char,void>, COMDAT

; 65   : 	{	// exchange values stored at _Left and _Right

	npad	2
	push	ebp
	mov	ebp, esp

; 66   : 	_Ty _Tmp = _STD move(_Left);
; 67   : 	_Left = _STD move(_Right);

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Left$[ebp]
	push	ebx
	mov	al, BYTE PTR [ecx]
	mov	bl, BYTE PTR [edx]
	mov	BYTE PTR [edx], al

; 68   : 	_Right = _STD move(_Tmp);

	mov	BYTE PTR [ecx], bl
	pop	ebx

; 69   : 	}

	pop	ebp
	ret	0
??$swap@DX@std@@YAXAAD0@Z ENDP				; std::swap<char,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@@std@@YAPAV?$_Deque_val@U?$_Deque_simple_types@K@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@@std@@YAPAV?$_Deque_val@U?$_Deque_simple_types@K@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Deque_val<std::_Deque_simple_types<unsigned long> > >, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@@std@@YAPAV?$_Deque_val@U?$_Deque_simple_types@K@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Deque_val<std::_Deque_simple_types<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT
; _this$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	edx, DWORD PTR __Ptr$[ebp]
	test	edx, edx
	je	SHORT $LN13@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
$LN13@construct:

; 1096 : 		_Mytraits::construct(*this, _Ptr,
; 1097 : 			_STD forward<_Types>(_Args)...);
; 1098 : 		}

	pop	ebp
	ret	8
??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z PROC ; std::_Unfancy<std::_Container_proxy>, COMDAT

; 642  : 	{	// do nothing for plain pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 644  : 	}

	pop	ebp
	ret	0
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ENDP ; std::_Unfancy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAU_Container_proxy@std@@@std@@SAPAU_Container_proxy@2@AAU32@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PAU_Container_proxy@std@@@std@@SAPAU_Container_proxy@2@AAU32@@Z PROC ; std::pointer_traits<std::_Container_proxy *>::pointer_to, COMDAT

; 289  : 		{	// convert raw reference to pointer

	npad	2
	push	ebp
	mov	ebp, esp

; 290  : 		return (_STD addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 291  : 		}

	pop	ebp
	ret	0
?pointer_to@?$pointer_traits@PAU_Container_proxy@std@@@std@@SAPAU_Container_proxy@2@AAU32@@Z ENDP ; std::pointer_traits<std::_Container_proxy *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
;	COMDAT ??$_Min_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Min_value@I@std@@YAABIABI0@Z PROC			; std::_Min_value<unsigned int>, COMDAT

; 22   : 	{	// return smaller of _Left and _Right

	npad	2
	push	ebp
	mov	ebp, esp

; 23   : 	return (_Right < _Left ? _Right : _Left);

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	cmovb	eax, edx

; 24   : 	}

	pop	ebp
	ret	0
??$_Min_value@I@std@@YAABIABI0@Z ENDP			; std::_Min_value<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$_Unfancy@_W@std@@YAPA_WPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@_W@std@@YAPA_WPA_W@Z PROC			; std::_Unfancy<wchar_t>, COMDAT

; 642  : 	{	// do nothing for plain pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 644  : 	}

	pop	ebp
	ret	0
??$_Unfancy@_W@std@@YAPA_WPA_W@Z ENDP			; std::_Unfancy<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@K@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAK@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@K@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAK@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned long> >::destroy<unsigned long>, COMDAT
; _this$ = ecx

; 1103 : 		_Mytraits::destroy(*this, _Ptr);
; 1104 : 		}

	ret	4
??$destroy@K@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAK@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned long> >::destroy<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$_Unfancy@K@std@@YAPAKPAK@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@K@std@@YAPAKPAK@Z PROC			; std::_Unfancy<unsigned long>, COMDAT

; 642  : 	{	// do nothing for plain pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 644  : 	}

	pop	ebp
	ret	0
??$_Unfancy@K@std@@YAPAKPAK@Z ENDP			; std::_Unfancy<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@H@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@H@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Tree_val<std::_Tree_simple_types<int> > >, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@YAPAV?$_Tree_val@U?$_Tree_simple_types@H@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Tree_val<std::_Tree_simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0ABU?$less@H@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@H@1@$$QAU_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
_<_Val2_0>$ = 16					; size = 4
??$?0ABU?$less@H@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@H@1@$$QAU_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>,1>::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>,1><std::less<int> const &,std::_Zero_then_variadic_args_t>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 560  : 		: _Myhead(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 561  : 		_Mysize(0)

	mov	DWORD PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	ret	12					; 0000000cH
??$?0ABU?$less@H@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@H@1@$$QAU_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>,1>::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>,1><std::less<int> const &,std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@HPAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@HPAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@HPAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@HPAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::destroy<std::_Tree_node<int,void *> *>, COMDAT
; _this$ = ecx

; 1103 : 		_Mytraits::destroy(*this, _Ptr);
; 1104 : 		}

	ret	4
??$destroy@PAU?$_Tree_node@HPAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@HPAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::destroy<std::_Tree_node<int,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@PAU?$_Tree_node@HPAX@std@@@std@@YAPAPAU?$_Tree_node@HPAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAU?$_Tree_node@HPAX@std@@@std@@YAPAPAU?$_Tree_node@HPAX@0@AAPAU10@@Z PROC ; std::addressof<std::_Tree_node<int,void *> *>, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@PAU?$_Tree_node@HPAX@std@@@std@@YAPAPAU?$_Tree_node@HPAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_Tree_node<int,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Deque_val<std::_Deque_simple_types<unsigned long> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Deque_val<std::_Deque_simple_types<unsigned long> >,1><>, COMDAT
; _this$ = ecx

; 99   : 		: _Myproxy(0)

	mov	DWORD PTR [ecx], 0

; 304  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque

; 752  : 		: _Map(),

	mov	DWORD PTR [ecx+4], 0

; 753  : 		_Mapsize(0),

	mov	DWORD PTR [ecx+8], 0

; 754  : 		_Myoff(0),

	mov	DWORD PTR [ecx+12], 0

; 755  : 		_Mysize(0)

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 304  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Deque_val<std::_Deque_simple_types<unsigned long> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Deque_val<std::_Deque_simple_types<unsigned long> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>, COMDAT
; _this$ = ecx

; 1103 : 		_Mytraits::destroy(*this, _Ptr);
; 1104 : 		}

	ret	4
??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$?0AAU?$_Wrap_alloc@V?$allocator@K@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@K@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0AAU?$_Wrap_alloc@V?$allocator@K@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@K@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<unsigned long> > &>, COMDAT
; _this$ = ecx

; 1054 : 		}

	mov	eax, ecx
	ret	4
??$?0AAU?$_Wrap_alloc@V?$allocator@K@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@K@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<unsigned long> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate, COMDAT
; _this$ = ecx

; 1087 : 		{	// deallocate object at _Ptr, ignore size

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 1088 : 		_Mybase::deallocate(_Ptr, _Count);
; 1089 : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate, COMDAT
; _this$ = ecx

; 1076 : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 1078 : 		}

	pop	ebp

; 1077 : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?address@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QBEPAU_Container_proxy@2@AAU32@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?address@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QBEPAU_Container_proxy@2@AAU32@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::address, COMDAT
; _this$ = ecx

; 1026 : 		{	// return address of mutable _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 1027 : 		return (pointer_traits<pointer>::pointer_to(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 1028 : 		}

	pop	ebp
	ret	4
?address@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QBEPAU_Container_proxy@2@AAU32@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::address
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 827  : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 53   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 536870911				; 1fffffffH
	jbe	SHORT $LN5@allocate

; 58   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 3

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 69   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN9@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@allocate:
$LN9@allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 87   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@allocate:
$LN14@allocate:
	int	3
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::deallocate, COMDAT
; _this$ = ecx

; 822  : 		{	// deallocate object at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 824  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 1103 : 		_Mytraits::destroy(*this, _Ptr);
; 1104 : 		}

	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@_W@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@_W@std@@@0@AAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@_W@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>, COMDAT
; _this$ = ecx

; 1103 : 		_Mytraits::destroy(*this, _Ptr);
; 1104 : 		}

	ret	4
??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z PROC		; std::addressof<wchar_t *>, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z ENDP		; std::addressof<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 304  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1596 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 304  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 304  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1596 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 304  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PAK@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAPAK@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAK@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAPAK@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned long> >::destroy<unsigned long *>, COMDAT
; _this$ = ecx

; 1103 : 		_Mytraits::destroy(*this, _Ptr);
; 1104 : 		}

	ret	4
??$destroy@PAK@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAPAK@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned long> >::destroy<unsigned long *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@PAK@std@@YAPAPAKAAPAK@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAK@std@@YAPAPAKAAPAK@Z PROC		; std::addressof<unsigned long *>, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@PAK@std@@YAPAPAKAAPAK@Z ENDP		; std::addressof<unsigned long *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$?0AAU?$_Wrap_alloc@V?$allocator@K@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAK@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@K@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0AAU?$_Wrap_alloc@V?$allocator@K@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAK@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@K@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned long *> >::_Wrap_alloc<std::allocator<unsigned long *> ><std::_Wrap_alloc<std::allocator<unsigned long> > &>, COMDAT
; _this$ = ecx

; 1054 : 		}

	mov	eax, ecx
	ret	4
??$?0AAU?$_Wrap_alloc@V?$allocator@K@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAK@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@K@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned long *> >::_Wrap_alloc<std::allocator<unsigned long *> ><std::_Wrap_alloc<std::allocator<unsigned long> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >::operator!=, COMDAT
; _this$ = ecx

; 335  : 		{	// test for iterator inequality

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 336  : 		return (!(*this == _Right));
; 337  : 		}

	pop	ebp
	ret	4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >::operator==, COMDAT
; _this$ = ecx

; 320  : 		{	// test for iterator equality

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 321  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 322  : 		if (this->_Getcont() != _Right._Getcont())
; 323  : 			{	// report error
; 324  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 325  : 			}
; 326  : 
; 327  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 328  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 329  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 330  : 
; 331  : 		return (this->_Ptr == _Right._Ptr);
; 332  : 		}

	pop	ebp
	ret	4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >::operator--, COMDAT
; _this$ = ecx

; 283  : 		{	// predecrement

	npad	2
	push	esi
	mov	esi, ecx

; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == nullptr_t{})
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			}
; 290  : 
; 291  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 292  : 		--static_cast<_Mybase&>(*this);
; 293  : 		if (_Ptrsav == this->_Ptr)
; 294  : 			{	// report error
; 295  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 296  : 			}
; 297  : 
; 298  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 299  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != nullptr_t{});
; 300  : 
; 301  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 302  : 		--static_cast<_Mybase&>(*this);
; 303  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 304  : 
; 305  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 306  : 		--static_cast<_Mybase&>(*this);

	call	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::operator--

; 307  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 308  : 
; 309  : 		return (*this);

	mov	eax, esi
	pop	esi

; 310  : 		}

	ret	0
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >::operator++, COMDAT
; _this$ = ecx

; 276  : 		{	// postincrement

	npad	2
	push	ebp
	mov	ebp, esp

; 277  : 		_Myiter _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [esi], edx

; 271  : 		++static_cast<_Mybase&>(*this);

	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::operator++

; 278  : 		++*this;
; 279  : 		return (_Tmp);

	mov	eax, esi
	pop	esi

; 280  : 		}

	pop	ebp
	ret	8
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >::operator++, COMDAT
; _this$ = ecx

; 257  : 		{	// preincrement

	npad	2
	push	esi
	mov	esi, ecx

; 258  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 259  : 		if (this->_Getcont() == 0
; 260  : 			|| this->_Ptr == nullptr_t{}
; 261  : 			|| _Mytree::_Isnil(this->_Ptr))
; 262  : 			{	// report error
; 263  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != nullptr_t{});
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++static_cast<_Mybase&>(*this);

	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::operator++

; 272  : 		return (*this);

	mov	eax, esi
	pop	esi

; 273  : 		}

	ret	0
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@QAE@PAU?$_Tree_node@HPAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@QAE@PAU?$_Tree_node@HPAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >, COMDAT
; _this$ = ecx

; 214  : 		{	// construct with node pointer _Pnode

	npad	2
	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], eax

; 215  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@QAE@PAU?$_Tree_node@HPAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@HPAX@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@HPAX@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 123  : 		return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 124  : 		}

	ret	0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@HPAX@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 84   : 		{	// predecrement

	mov	edx, ecx

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 85   : 		if (_Mytree::_Isnil(_Ptr))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LN4@operator

; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], eax

; 100  : 			}
; 101  : 		return (*this);

	mov	eax, edx

; 102  : 		}

	ret	0
$LN4@operator:

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR [eax]

; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN40@operator

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 601  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN23@operator
$LL22@operator:

; 602  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 601  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL22@operator

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [edx], ecx

; 100  : 			}
; 101  : 		return (*this);

	mov	eax, edx

; 102  : 		}

	ret	0
$LN40@operator:

; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))

	mov	ecx, DWORD PTR [eax+4]
	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN3@operator
	npad	4
$LL2@operator:
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN3@operator

; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree

	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [ecx+4]
	cmp	BYTE PTR [ecx+13], 0
	je	SHORT $LL2@operator
$LN3@operator:

; 96   : 			if (_Mytree::_Isnil(_Ptr))

	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN47@operator
$LN23@operator:

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [edx], ecx
$LN47@operator:

; 100  : 			}
; 101  : 		return (*this);

	mov	eax, edx

; 102  : 		}

	ret	0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 59   : 		{	// preincrement

	mov	edx, ecx

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN41@operator

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR [eax+8]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN34@operator

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 608  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN19@operator
	npad	5
$LL18@operator:

; 609  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 608  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL18@operator
$LN19@operator:

; 63   : 			_Ptr = _Mytree::_Min(

	mov	DWORD PTR [edx], ecx

; 72   : 			}
; 73   : 		return (*this);

	mov	eax, edx

; 74   : 		}

	ret	0
$LN34@operator:

; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN3@operator
$LL2@operator:
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN3@operator

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@operator
$LN3@operator:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR [edx], eax
$LN41@operator:

; 72   : 			}
; 73   : 		return (*this);

	mov	eax, edx

; 74   : 		}

	ret	0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@HPAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@HPAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 44   : 		{	// construct with node pointer _Pnode

	npad	2
	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@HPAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$?0V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@$$QAV?$allocator@U?$_Tree_node@HPAX@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@$$QAV?$allocator@U?$_Tree_node@HPAX@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > ><std::allocator<std::_Tree_node<int,void *> > >, COMDAT
; _this$ = ecx

; 1054 : 		}

	mov	eax, ecx
	ret	4
??$?0V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@$$QAV?$allocator@U?$_Tree_node@HPAX@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > ><std::allocator<std::_Tree_node<int,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 642  : 	{	// do nothing for plain pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 644  : 	}

	pop	ebp
	ret	0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1350 : 	{	// forward _Arg as movable

	npad	2
	push	ebp
	mov	ebp, esp

; 1351 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1352 : 	}

	pop	ebp
	ret	0
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>, COMDAT
; _this$ = ecx

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 1705 : 		}

	mov	eax, ecx

; 1596 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 1705 : 		}

	ret	4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<char> > &>, COMDAT

; 1350 : 	{	// forward _Arg as movable

	npad	2
	push	ebp
	mov	ebp, esp

; 1351 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1352 : 	}

	pop	ebp
	ret	0
??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &>, COMDAT

; 1350 : 	{	// forward _Arg as movable

	npad	2
	push	ebp
	mov	ebp, esp

; 1351 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1352 : 	}

	pop	ebp
	ret	0
??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > ><std::_Wrap_alloc<std::allocator<wchar_t> >,void>, COMDAT
; _this$ = ecx

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 1705 : 		}

	mov	eax, ecx

; 1596 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 1705 : 		}

	ret	4
??$?0U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@X@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > ><std::_Wrap_alloc<std::allocator<wchar_t> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<wchar_t> > &>, COMDAT

; 1350 : 	{	// forward _Arg as movable

	npad	2
	push	ebp
	mov	ebp, esp

; 1351 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1352 : 	}

	pop	ebp
	ret	0
??$move@AAU?$_Wrap_alloc@V?$allocator@_W@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@_W@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<wchar_t> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z PROC ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const >, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z ENDP ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\memory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\memory
;	COMDAT ??$?0PAUSK_D3D11_Stateblock_Lite@@@?$_Unique_ptr_base@USK_D3D11_Stateblock_Lite@@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@@std@@QAE@PAUSK_D3D11_Stateblock_Lite@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$?0PAUSK_D3D11_Stateblock_Lite@@@?$_Unique_ptr_base@USK_D3D11_Stateblock_Lite@@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@@std@@QAE@PAUSK_D3D11_Stateblock_Lite@@@Z PROC ; std::_Unique_ptr_base<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> >::_Unique_ptr_base<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> ><SK_D3D11_Stateblock_Lite *>, COMDAT
; _this$ = ecx

; 1670 : 		{	// construct with compatible pointer

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 302  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\memory

; 1671 : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??$?0PAUSK_D3D11_Stateblock_Lite@@@?$_Unique_ptr_base@USK_D3D11_Stateblock_Lite@@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@@std@@QAE@PAUSK_D3D11_Stateblock_Lite@@@Z ENDP ; std::_Unique_ptr_base<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> >::_Unique_ptr_base<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> ><SK_D3D11_Stateblock_Lite *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T2 = 8							; size = 1
__Right$ = 8						; size = 4
__Al$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> ><std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > > >, COMDAT
; _this$ = ecx

; 1031 : 		{	// construct tree by copying _Right, allocator

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp], esp

; 560  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 561  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 714  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@HPAX@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax

; 1032 : 		_TRY_BEGIN
; 1033 : 		_Copy(_Right, _Copy_tag());

	push	DWORD PTR $T2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	ecx, esi
	push	DWORD PTR __Right$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	call	??$_Copy@U_Copy_tag@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXABV01@U_Copy_tag@01@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Copy<std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Copy_tag>

; 1037 : 		_CATCH_END
; 1038 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z$0:

; 1034 : 		_CATCH_ALL
; 1035 : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Tidy

; 1036 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN53@allocator:
$LN52@allocator:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::~_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >
__ehhandler$??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> ><std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
;	COMDAT ??$QueryInterface@UIDXGIAdapter3@@@IUnknown@@QAGJPAPAUIDXGIAdapter3@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pp$ = 12						; size = 4
??$QueryInterface@UIDXGIAdapter3@@@IUnknown@@QAGJPAPAUIDXGIAdapter3@@@Z PROC ; IUnknown::QueryInterface<IDXGIAdapter3>, COMDAT

; 130  :             {

	npad	2
	push	ebp
	mov	ebp, esp

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	mov	eax, DWORD PTR _this$[ebp]
	push	DWORD PTR _pp$[ebp]
	push	OFFSET __GUID_645967a4_1392_4310_a798_8053ce3e93fd
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx]

; 132  :             }

	pop	ebp
	ret	8
??$QueryInterface@UIDXGIAdapter3@@@IUnknown@@QAGJPAPAUIDXGIAdapter3@@@Z ENDP ; IUnknown::QueryInterface<IDXGIAdapter3>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0budget_thread_params_t@@QAE@XZ
_TEXT	SEGMENT
??0budget_thread_params_t@@QAE@XZ PROC			; budget_thread_params_t::budget_thread_params_t, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], -1
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], -1
	mov	DWORD PTR [ecx+20], -1
	mov	DWORD PTR [ecx+24], 0
	ret	0
??0budget_thread_params_t@@QAE@XZ ENDP			; budget_thread_params_t::budget_thread_params_t
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtr@UIDXGIFactory5@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComPtr@UIDXGIFactory5@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<IDXGIFactory5>::~CComPtr<IDXGIFactory5>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComPtr@UIDXGIFactory5@@@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@CComPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN4@CComPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComPtr@UIDXGIFactory5@@@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComPtr@UIDXGIFactory5@@@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComPtr@UIDXGIFactory5@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<IDXGIFactory5>::~CComPtr<IDXGIFactory5>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UIDXGIFactory5@@@ATL@@QAE@PAUIDXGIFactory5@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtr@UIDXGIFactory5@@@ATL@@QAE@PAUIDXGIFactory5@@@Z PROC ; ATL::CComPtr<IDXGIFactory5>::CComPtr<IDXGIFactory5>, COMDAT
; _this$ = ecx

; 312  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi

; 312  :     {

	mov	esi, ecx

; 162  :         p = lp;

	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN6@CComPtr

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN6@CComPtr:

; 313  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtr@UIDXGIFactory5@@@ATL@@QAE@PAUIDXGIFactory5@@@Z ENDP ; ATL::CComPtr<IDXGIFactory5>::CComPtr<IDXGIFactory5>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UIDXGIFactory5@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UIDXGIFactory5@@@ATL@@QAE@XZ PROC	; ATL::CComPtrBase<IDXGIFactory5>::~CComPtrBase<IDXGIFactory5>, COMDAT
; _this$ = ecx

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN2@CComPtrBas

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@CComPtrBas:

; 178  :     }

	ret	0
??1?$CComPtrBase@UIDXGIFactory5@@@ATL@@QAE@XZ ENDP	; ATL::CComPtrBase<IDXGIFactory5>::~CComPtrBase<IDXGIFactory5>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UIDXGIFactory5@@@ATL@@IAE@PAUIDXGIFactory5@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtrBase@UIDXGIFactory5@@@ATL@@IAE@PAUIDXGIFactory5@@@Z PROC ; ATL::CComPtrBase<IDXGIFactory5>::CComPtrBase<IDXGIFactory5>, COMDAT
; _this$ = ecx

; 160  :     CComPtrBase(_Inout_opt_ T* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp

; 161  :     {
; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN4@CComPtrBas

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN4@CComPtrBas:

; 165  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtrBase@UIDXGIFactory5@@@ATL@@IAE@PAUIDXGIFactory5@@@Z ENDP ; ATL::CComPtrBase<IDXGIFactory5>::CComPtrBase<IDXGIFactory5>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtr@UIDXGIFactory4@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComPtr@UIDXGIFactory4@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<IDXGIFactory4>::~CComPtr<IDXGIFactory4>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComPtr@UIDXGIFactory4@@@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@CComPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN4@CComPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComPtr@UIDXGIFactory4@@@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComPtr@UIDXGIFactory4@@@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComPtr@UIDXGIFactory4@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<IDXGIFactory4>::~CComPtr<IDXGIFactory4>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UIDXGIFactory4@@@ATL@@QAE@PAUIDXGIFactory4@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtr@UIDXGIFactory4@@@ATL@@QAE@PAUIDXGIFactory4@@@Z PROC ; ATL::CComPtr<IDXGIFactory4>::CComPtr<IDXGIFactory4>, COMDAT
; _this$ = ecx

; 312  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi

; 312  :     {

	mov	esi, ecx

; 162  :         p = lp;

	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN6@CComPtr

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN6@CComPtr:

; 313  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtr@UIDXGIFactory4@@@ATL@@QAE@PAUIDXGIFactory4@@@Z ENDP ; ATL::CComPtr<IDXGIFactory4>::CComPtr<IDXGIFactory4>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UIDXGIFactory4@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UIDXGIFactory4@@@ATL@@QAE@XZ PROC	; ATL::CComPtrBase<IDXGIFactory4>::~CComPtrBase<IDXGIFactory4>, COMDAT
; _this$ = ecx

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN2@CComPtrBas

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@CComPtrBas:

; 178  :     }

	ret	0
??1?$CComPtrBase@UIDXGIFactory4@@@ATL@@QAE@XZ ENDP	; ATL::CComPtrBase<IDXGIFactory4>::~CComPtrBase<IDXGIFactory4>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UIDXGIFactory4@@@ATL@@IAE@PAUIDXGIFactory4@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtrBase@UIDXGIFactory4@@@ATL@@IAE@PAUIDXGIFactory4@@@Z PROC ; ATL::CComPtrBase<IDXGIFactory4>::CComPtrBase<IDXGIFactory4>, COMDAT
; _this$ = ecx

; 160  :     CComPtrBase(_Inout_opt_ T* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp

; 161  :     {
; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN4@CComPtrBas

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN4@CComPtrBas:

; 165  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtrBase@UIDXGIFactory4@@@ATL@@IAE@PAUIDXGIFactory4@@@Z ENDP ; ATL::CComPtrBase<IDXGIFactory4>::CComPtrBase<IDXGIFactory4>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtr@UIDXGIFactory3@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComPtr@UIDXGIFactory3@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<IDXGIFactory3>::~CComPtr<IDXGIFactory3>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComPtr@UIDXGIFactory3@@@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@CComPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN4@CComPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComPtr@UIDXGIFactory3@@@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComPtr@UIDXGIFactory3@@@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComPtr@UIDXGIFactory3@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<IDXGIFactory3>::~CComPtr<IDXGIFactory3>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UIDXGIFactory3@@@ATL@@QAE@PAUIDXGIFactory3@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtr@UIDXGIFactory3@@@ATL@@QAE@PAUIDXGIFactory3@@@Z PROC ; ATL::CComPtr<IDXGIFactory3>::CComPtr<IDXGIFactory3>, COMDAT
; _this$ = ecx

; 312  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi

; 312  :     {

	mov	esi, ecx

; 162  :         p = lp;

	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN6@CComPtr

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN6@CComPtr:

; 313  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtr@UIDXGIFactory3@@@ATL@@QAE@PAUIDXGIFactory3@@@Z ENDP ; ATL::CComPtr<IDXGIFactory3>::CComPtr<IDXGIFactory3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UIDXGIFactory3@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UIDXGIFactory3@@@ATL@@QAE@XZ PROC	; ATL::CComPtrBase<IDXGIFactory3>::~CComPtrBase<IDXGIFactory3>, COMDAT
; _this$ = ecx

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN2@CComPtrBas

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@CComPtrBas:

; 178  :     }

	ret	0
??1?$CComPtrBase@UIDXGIFactory3@@@ATL@@QAE@XZ ENDP	; ATL::CComPtrBase<IDXGIFactory3>::~CComPtrBase<IDXGIFactory3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UIDXGIFactory3@@@ATL@@IAE@PAUIDXGIFactory3@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtrBase@UIDXGIFactory3@@@ATL@@IAE@PAUIDXGIFactory3@@@Z PROC ; ATL::CComPtrBase<IDXGIFactory3>::CComPtrBase<IDXGIFactory3>, COMDAT
; _this$ = ecx

; 160  :     CComPtrBase(_Inout_opt_ T* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp

; 161  :     {
; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN4@CComPtrBas

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN4@CComPtrBas:

; 165  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtrBase@UIDXGIFactory3@@@ATL@@IAE@PAUIDXGIFactory3@@@Z ENDP ; ATL::CComPtrBase<IDXGIFactory3>::CComPtrBase<IDXGIFactory3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComQIPtr@UIDXGIFactory2@@$1?_GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0@@3U__s_GUID@@B@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComQIPtr@UIDXGIFactory2@@$1?_GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0@@3U__s_GUID@@B@ATL@@QAE@XZ PROC ; ATL::CComQIPtr<IDXGIFactory2,&_GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0>::~CComQIPtr<IDXGIFactory2,&_GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComQIPtr@UIDXGIFactory2@@$1?_GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0@@3U__s_GUID@@B@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN7@CComQIPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN7@CComQIPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComQIPtr@UIDXGIFactory2@@$1?_GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0@@3U__s_GUID@@B@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComQIPtr@UIDXGIFactory2@@$1?_GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0@@3U__s_GUID@@B@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComQIPtr@UIDXGIFactory2@@$1?_GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0@@3U__s_GUID@@B@ATL@@QAE@XZ ENDP ; ATL::CComQIPtr<IDXGIFactory2,&_GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0>::~CComQIPtr<IDXGIFactory2,&_GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComQIPtr@UIDXGIFactory2@@$1?_GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComQIPtr@UIDXGIFactory2@@$1?_GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z PROC ; ATL::CComQIPtr<IDXGIFactory2,&_GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0>::CComQIPtr<IDXGIFactory2,&_GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0>, COMDAT
; _this$ = ecx

; 621  :     CComQIPtr(_Inout_opt_ IUnknown* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 622  :     {
; 623  :         if (lp != NULL)

	mov	ecx, DWORD PTR _lp$[ebp]

; 158  :         p = NULL;

	mov	DWORD PTR [esi], 0

; 622  :     {
; 623  :         if (lp != NULL)

	test	ecx, ecx
	je	SHORT $LN10@CComQIPtr

; 624  :         {
; 625  :             if (FAILED(lp->QueryInterface(*piid, (void **)&this->p)))

	mov	eax, DWORD PTR [ecx]
	push	esi
	push	OFFSET __GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0
	push	ecx
	call	DWORD PTR [eax]
	test	eax, eax

; 627  :         }
; 628  :     }

	mov	eax, esi
	jns	SHORT $LN3@CComQIPtr

; 626  :                 this->p = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 627  :         }
; 628  :     }

	pop	ebp
	ret	4
$LN10@CComQIPtr:
	mov	eax, esi
$LN3@CComQIPtr:
	pop	esi
	pop	ebp
	ret	4
??0?$CComQIPtr@UIDXGIFactory2@@$1?_GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z ENDP ; ATL::CComQIPtr<IDXGIFactory2,&_GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0>::CComQIPtr<IDXGIFactory2,&_GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtr@UIDXGIFactory2@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComPtr@UIDXGIFactory2@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<IDXGIFactory2>::~CComPtr<IDXGIFactory2>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComPtr@UIDXGIFactory2@@@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@CComPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN4@CComPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComPtr@UIDXGIFactory2@@@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComPtr@UIDXGIFactory2@@@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComPtr@UIDXGIFactory2@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<IDXGIFactory2>::~CComPtr<IDXGIFactory2>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UIDXGIFactory2@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CComPtr@UIDXGIFactory2@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<IDXGIFactory2>::CComPtr<IDXGIFactory2>, COMDAT
; _this$ = ecx

; 158  :         p = NULL;

	mov	DWORD PTR [ecx], 0

; 308  :     {
; 309  :     }

	mov	eax, ecx
	ret	0
??0?$CComPtr@UIDXGIFactory2@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<IDXGIFactory2>::CComPtr<IDXGIFactory2>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??8?$CComPtrBase@UIDXGIFactory2@@@ATL@@QBE_NPAUIDXGIFactory2@@@Z
_TEXT	SEGMENT
_pT$ = 8						; size = 4
??8?$CComPtrBase@UIDXGIFactory2@@@ATL@@QBE_NPAUIDXGIFactory2@@@Z PROC ; ATL::CComPtrBase<IDXGIFactory2>::operator==, COMDAT
; _this$ = ecx

; 213  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR _pT$[ebp]
	sete	al

; 214  :         return p == pT;
; 215  :     }

	pop	ebp
	ret	4
??8?$CComPtrBase@UIDXGIFactory2@@@ATL@@QBE_NPAUIDXGIFactory2@@@Z ENDP ; ATL::CComPtrBase<IDXGIFactory2>::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??9?$CComPtrBase@UIDXGIFactory2@@@ATL@@QBE_NPAUIDXGIFactory2@@@Z
_TEXT	SEGMENT
_pT$ = 8						; size = 4
??9?$CComPtrBase@UIDXGIFactory2@@@ATL@@QBE_NPAUIDXGIFactory2@@@Z PROC ; ATL::CComPtrBase<IDXGIFactory2>::operator!=, COMDAT
; _this$ = ecx

; 209  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR _pT$[ebp]
	setne	al

; 210  :         return !operator==(pT);
; 211  :     }

	pop	ebp
	ret	4
??9?$CComPtrBase@UIDXGIFactory2@@@ATL@@QBE_NPAUIDXGIFactory2@@@Z ENDP ; ATL::CComPtrBase<IDXGIFactory2>::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??I?$CComPtrBase@UIDXGIFactory2@@@ATL@@QAEPAPAUIDXGIFactory2@@XZ
_TEXT	SEGMENT
??I?$CComPtrBase@UIDXGIFactory2@@@ATL@@QAEPAPAUIDXGIFactory2@@XZ PROC ; ATL::CComPtrBase<IDXGIFactory2>::operator&, COMDAT
; _this$ = ecx

; 192  :         ATLASSERT(p==NULL);
; 193  :         return &p;

	mov	eax, ecx

; 194  :     }

	ret	0
??I?$CComPtrBase@UIDXGIFactory2@@@ATL@@QAEPAPAUIDXGIFactory2@@XZ ENDP ; ATL::CComPtrBase<IDXGIFactory2>::operator&
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UIDXGIFactory2@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UIDXGIFactory2@@@ATL@@QAE@XZ PROC	; ATL::CComPtrBase<IDXGIFactory2>::~CComPtrBase<IDXGIFactory2>, COMDAT
; _this$ = ecx

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN2@CComPtrBas

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@CComPtrBas:

; 178  :     }

	ret	0
??1?$CComPtrBase@UIDXGIFactory2@@@ATL@@QAE@XZ ENDP	; ATL::CComPtrBase<IDXGIFactory2>::~CComPtrBase<IDXGIFactory2>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UIDXGIFactory2@@@ATL@@IAE@XZ
_TEXT	SEGMENT
??0?$CComPtrBase@UIDXGIFactory2@@@ATL@@IAE@XZ PROC	; ATL::CComPtrBase<IDXGIFactory2>::CComPtrBase<IDXGIFactory2>, COMDAT
; _this$ = ecx

; 157  :     {
; 158  :         p = NULL;

	mov	DWORD PTR [ecx], 0

; 159  :     }

	mov	eax, ecx
	ret	0
??0?$CComPtrBase@UIDXGIFactory2@@@ATL@@IAE@XZ ENDP	; ATL::CComPtrBase<IDXGIFactory2>::CComPtrBase<IDXGIFactory2>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComQIPtr@UIDXGIFactory1@@$1?_GUID_770aae78_f26f_4dba_a829_253c83d1b387@@3U__s_GUID@@B@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComQIPtr@UIDXGIFactory1@@$1?_GUID_770aae78_f26f_4dba_a829_253c83d1b387@@3U__s_GUID@@B@ATL@@QAE@XZ PROC ; ATL::CComQIPtr<IDXGIFactory1,&_GUID_770aae78_f26f_4dba_a829_253c83d1b387>::~CComQIPtr<IDXGIFactory1,&_GUID_770aae78_f26f_4dba_a829_253c83d1b387>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComQIPtr@UIDXGIFactory1@@$1?_GUID_770aae78_f26f_4dba_a829_253c83d1b387@@3U__s_GUID@@B@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN7@CComQIPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN7@CComQIPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComQIPtr@UIDXGIFactory1@@$1?_GUID_770aae78_f26f_4dba_a829_253c83d1b387@@3U__s_GUID@@B@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComQIPtr@UIDXGIFactory1@@$1?_GUID_770aae78_f26f_4dba_a829_253c83d1b387@@3U__s_GUID@@B@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComQIPtr@UIDXGIFactory1@@$1?_GUID_770aae78_f26f_4dba_a829_253c83d1b387@@3U__s_GUID@@B@ATL@@QAE@XZ ENDP ; ATL::CComQIPtr<IDXGIFactory1,&_GUID_770aae78_f26f_4dba_a829_253c83d1b387>::~CComQIPtr<IDXGIFactory1,&_GUID_770aae78_f26f_4dba_a829_253c83d1b387>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComQIPtr@UIDXGIFactory1@@$1?_GUID_770aae78_f26f_4dba_a829_253c83d1b387@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComQIPtr@UIDXGIFactory1@@$1?_GUID_770aae78_f26f_4dba_a829_253c83d1b387@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z PROC ; ATL::CComQIPtr<IDXGIFactory1,&_GUID_770aae78_f26f_4dba_a829_253c83d1b387>::CComQIPtr<IDXGIFactory1,&_GUID_770aae78_f26f_4dba_a829_253c83d1b387>, COMDAT
; _this$ = ecx

; 621  :     CComQIPtr(_Inout_opt_ IUnknown* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 622  :     {
; 623  :         if (lp != NULL)

	mov	ecx, DWORD PTR _lp$[ebp]

; 158  :         p = NULL;

	mov	DWORD PTR [esi], 0

; 622  :     {
; 623  :         if (lp != NULL)

	test	ecx, ecx
	je	SHORT $LN10@CComQIPtr

; 624  :         {
; 625  :             if (FAILED(lp->QueryInterface(*piid, (void **)&this->p)))

	mov	eax, DWORD PTR [ecx]
	push	esi
	push	OFFSET __GUID_770aae78_f26f_4dba_a829_253c83d1b387
	push	ecx
	call	DWORD PTR [eax]
	test	eax, eax

; 627  :         }
; 628  :     }

	mov	eax, esi
	jns	SHORT $LN3@CComQIPtr

; 626  :                 this->p = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 627  :         }
; 628  :     }

	pop	ebp
	ret	4
$LN10@CComQIPtr:
	mov	eax, esi
$LN3@CComQIPtr:
	pop	esi
	pop	ebp
	ret	4
??0?$CComQIPtr@UIDXGIFactory1@@$1?_GUID_770aae78_f26f_4dba_a829_253c83d1b387@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z ENDP ; ATL::CComQIPtr<IDXGIFactory1,&_GUID_770aae78_f26f_4dba_a829_253c83d1b387>::CComQIPtr<IDXGIFactory1,&_GUID_770aae78_f26f_4dba_a829_253c83d1b387>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtr@UIDXGIFactory1@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComPtr@UIDXGIFactory1@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<IDXGIFactory1>::~CComPtr<IDXGIFactory1>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComPtr@UIDXGIFactory1@@@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@CComPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN4@CComPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComPtr@UIDXGIFactory1@@@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComPtr@UIDXGIFactory1@@@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComPtr@UIDXGIFactory1@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<IDXGIFactory1>::~CComPtr<IDXGIFactory1>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UIDXGIFactory1@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CComPtr@UIDXGIFactory1@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<IDXGIFactory1>::CComPtr<IDXGIFactory1>, COMDAT
; _this$ = ecx

; 158  :         p = NULL;

	mov	DWORD PTR [ecx], 0

; 308  :     {
; 309  :     }

	mov	eax, ecx
	ret	0
??0?$CComPtr@UIDXGIFactory1@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<IDXGIFactory1>::CComPtr<IDXGIFactory1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??8?$CComPtrBase@UIDXGIFactory1@@@ATL@@QBE_NPAUIDXGIFactory1@@@Z
_TEXT	SEGMENT
_pT$ = 8						; size = 4
??8?$CComPtrBase@UIDXGIFactory1@@@ATL@@QBE_NPAUIDXGIFactory1@@@Z PROC ; ATL::CComPtrBase<IDXGIFactory1>::operator==, COMDAT
; _this$ = ecx

; 213  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR _pT$[ebp]
	sete	al

; 214  :         return p == pT;
; 215  :     }

	pop	ebp
	ret	4
??8?$CComPtrBase@UIDXGIFactory1@@@ATL@@QBE_NPAUIDXGIFactory1@@@Z ENDP ; ATL::CComPtrBase<IDXGIFactory1>::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??9?$CComPtrBase@UIDXGIFactory1@@@ATL@@QBE_NPAUIDXGIFactory1@@@Z
_TEXT	SEGMENT
_pT$ = 8						; size = 4
??9?$CComPtrBase@UIDXGIFactory1@@@ATL@@QBE_NPAUIDXGIFactory1@@@Z PROC ; ATL::CComPtrBase<IDXGIFactory1>::operator!=, COMDAT
; _this$ = ecx

; 209  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR _pT$[ebp]
	setne	al

; 210  :         return !operator==(pT);
; 211  :     }

	pop	ebp
	ret	4
??9?$CComPtrBase@UIDXGIFactory1@@@ATL@@QBE_NPAUIDXGIFactory1@@@Z ENDP ; ATL::CComPtrBase<IDXGIFactory1>::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??I?$CComPtrBase@UIDXGIFactory1@@@ATL@@QAEPAPAUIDXGIFactory1@@XZ
_TEXT	SEGMENT
??I?$CComPtrBase@UIDXGIFactory1@@@ATL@@QAEPAPAUIDXGIFactory1@@XZ PROC ; ATL::CComPtrBase<IDXGIFactory1>::operator&, COMDAT
; _this$ = ecx

; 192  :         ATLASSERT(p==NULL);
; 193  :         return &p;

	mov	eax, ecx

; 194  :     }

	ret	0
??I?$CComPtrBase@UIDXGIFactory1@@@ATL@@QAEPAPAUIDXGIFactory1@@XZ ENDP ; ATL::CComPtrBase<IDXGIFactory1>::operator&
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UIDXGIFactory1@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UIDXGIFactory1@@@ATL@@QAE@XZ PROC	; ATL::CComPtrBase<IDXGIFactory1>::~CComPtrBase<IDXGIFactory1>, COMDAT
; _this$ = ecx

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN2@CComPtrBas

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@CComPtrBas:

; 178  :     }

	ret	0
??1?$CComPtrBase@UIDXGIFactory1@@@ATL@@QAE@XZ ENDP	; ATL::CComPtrBase<IDXGIFactory1>::~CComPtrBase<IDXGIFactory1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UIDXGIFactory1@@@ATL@@IAE@XZ
_TEXT	SEGMENT
??0?$CComPtrBase@UIDXGIFactory1@@@ATL@@IAE@XZ PROC	; ATL::CComPtrBase<IDXGIFactory1>::CComPtrBase<IDXGIFactory1>, COMDAT
; _this$ = ecx

; 157  :     {
; 158  :         p = NULL;

	mov	DWORD PTR [ecx], 0

; 159  :     }

	mov	eax, ecx
	ret	0
??0?$CComPtrBase@UIDXGIFactory1@@@ATL@@IAE@XZ ENDP	; ATL::CComPtrBase<IDXGIFactory1>::CComPtrBase<IDXGIFactory1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_pFactory1$ = -20					; size = 4
_pFactory2$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pFactory$ = 8						; size = 4
?SK_DXGI_HookFactory@@YAXPAUIDXGIFactory@@@Z PROC	; SK_DXGI_HookFactory

; 4984 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h

; 9003 :     return (unsigned long) _InterlockedCompareExchange((volatile long*) Destination, (long) Exchange, (long) Comperand);

	mov	ecx, 1
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4984 : {

	push	-1
	push	__ehhandler$?SK_DXGI_HookFactory@@YAXPAUIDXGIFactory@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h

; 9003 :     return (unsigned long) _InterlockedCompareExchange((volatile long*) Destination, (long) Exchange, (long) Comperand);

	mov	edx, OFFSET ?init@?1??SK_DXGI_HookFactory@@YAXPAUIDXGIFactory@@@Z@4KC
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4984 : {

	sub	esp, 8
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h

; 9003 :     return (unsigned long) _InterlockedCompareExchange((volatile long*) Destination, (long) Exchange, (long) Comperand);

	xor	eax, eax
	lock	 cmpxchg DWORD PTR [edx], ecx
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4987 :   if (InterlockedCompareExchange (&init, TRUE, FALSE))

	test	eax, eax
	jne	$LN104@SK_DXGI_Ho

; 4988 :   {
; 4989 :     //WaitForInitDXGI ();
; 4990 :     return;
; 4991 :   }
; 4992 : 
; 4993 :   //int iver = SK_GetDXGIFactoryInterfaceVer (pFactory);
; 4994 : 
; 4995 :   //  0 QueryInterface
; 4996 :   //  1 AddRef
; 4997 :   //  2 Release
; 4998 :   //  3 SetPrivateData
; 4999 :   //  4 SetPrivateDataInterface
; 5000 :   //  5 GetPrivateData
; 5001 :   //  6 GetParent
; 5002 :   //  7 EnumAdapters
; 5003 :   //  8 MakeWindowAssociation
; 5004 :   //  9 GetWindowAssociation
; 5005 :   // 10 CreateSwapChain
; 5006 :   // 11 CreateSoftwareAdapter
; 5007 :   DXGI_VIRTUAL_HOOK ( &pFactory,     10,

	push	esi
	mov	esi, DWORD PTR _pFactory$[ebp]
	push	OFFSET ?CreateSwapChain_Original@@3P6GJPAUIDXGIFactory@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@ZA ; CreateSwapChain_Original
	push	OFFSET ?DXGIFactory_CreateSwapChain_Override@@YGJPAUIDXGIFactory@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z ; DXGIFactory_CreateSwapChain_Override
	push	10					; 0000000aH
	push	DWORD PTR [esi]
	push	OFFSET $SG366710
	call	?SK_CreateVFTableHook2@@YG?AW4MH_STATUS@@PB_WPAPAXKPAX1@Z ; SK_CreateVFTableHook2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 625  :             if (FAILED(lp->QueryInterface(*piid, (void **)&this->p)))

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _pFactory1$[ebp]
	push	ecx
	push	OFFSET __GUID_770aae78_f26f_4dba_a829_253c83d1b387
	push	esi

; 158  :         p = NULL;

	mov	DWORD PTR _pFactory1$[ebp], 0

; 625  :             if (FAILED(lp->QueryInterface(*piid, (void **)&this->p)))

	call	DWORD PTR [eax]
	mov	ecx, DWORD PTR _pFactory1$[ebp]
	xor	edx, edx
	test	eax, eax
	cmovs	ecx, edx
	mov	DWORD PTR _pFactory1$[ebp], ecx
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5013 :   CComQIPtr <IDXGIFactory1> pFactory1 (pFactory);

	mov	DWORD PTR __$EHRec$[ebp+8], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 214  :         return p == pT;

	test	ecx, ecx
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5017 :   if (pFactory1 != nullptr)

	je	SHORT $LN3@SK_DXGI_Ho

; 5018 :   {
; 5019 :     DXGI_VIRTUAL_HOOK ( &pFactory1,     12,

	push	OFFSET ?EnumAdapters1_Original@@3P6GJPAUIDXGIFactory1@@IPAPAUIDXGIAdapter1@@@ZA ; EnumAdapters1_Original
	push	OFFSET ?EnumAdapters1_Override@@YGJPAUIDXGIFactory1@@IPAPAUIDXGIAdapter1@@@Z ; EnumAdapters1_Override
	push	12					; 0000000cH
	push	DWORD PTR [ecx]
	push	OFFSET $SG366713

; 5020 :                         "IDXGIFactory1::EnumAdapters1",
; 5021 :                          EnumAdapters1_Override,
; 5022 :                          EnumAdapters1_Original,
; 5023 :                          EnumAdapters1_pfn );
; 5024 :   }
; 5025 : 
; 5026 :   else

	jmp	SHORT $LN109@SK_DXGI_Ho
$LN3@SK_DXGI_Ho:

; 5027 :   {
; 5028 :     //
; 5029 :     // EnumAdapters actually calls EnumAdapters1 if the interface
; 5030 :     //   implements IDXGIFactory1...
; 5031 :     //
; 5032 :     //  >> Avoid some nasty recursion and only hook EnumAdapters if the
; 5033 :     //       interface version is DXGI 1.0.
; 5034 :     //
; 5035 :     DXGI_VIRTUAL_HOOK ( &pFactory,     7,

	push	OFFSET ?EnumAdapters_Original@@3P6GJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@@ZA ; EnumAdapters_Original
	push	OFFSET ?EnumAdapters_Override@@YGJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@@Z ; EnumAdapters_Override
	push	7
	push	DWORD PTR [esi]
	push	OFFSET $SG366714
$LN109@SK_DXGI_Ho:
	call	?SK_CreateVFTableHook2@@YG?AW4MH_STATUS@@PB_WPAPAXKPAX1@Z ; SK_CreateVFTableHook2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 625  :             if (FAILED(lp->QueryInterface(*piid, (void **)&this->p)))

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _pFactory2$[ebp]
	push	ecx
	push	OFFSET __GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0
	push	esi

; 158  :         p = NULL;

	mov	DWORD PTR _pFactory2$[ebp], 0

; 625  :             if (FAILED(lp->QueryInterface(*piid, (void **)&this->p)))

	call	DWORD PTR [eax]
	mov	ecx, DWORD PTR _pFactory2$[ebp]
	xor	edx, edx
	test	eax, eax
	cmovs	ecx, edx
	mov	DWORD PTR _pFactory2$[ebp], ecx
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5056 :   CComQIPtr <IDXGIFactory2> pFactory2 (pFactory);

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 214  :         return p == pT;

	test	ecx, ecx
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5058 :   if ( pFactory2 != nullptr ||

	jne	SHORT $LN8@SK_DXGI_Ho
	cmp	DWORD PTR ?CreateDXGIFactory2_Import@@3P6GJIABU_GUID@@PAPAX@ZA, ecx ; CreateDXGIFactory2_Import
	je	SHORT $LN7@SK_DXGI_Ho

; 5059 :        CreateDXGIFactory2_Import != nullptr )
; 5060 :   {
; 5061 :     if ( pFactory2 != nullptr ||

	lea	eax, DWORD PTR _pFactory2$[ebp]
	push	eax
	push	OFFSET _IID_IDXGIFactory2
	call	DWORD PTR ?CreateDXGIFactory1_Import@@3P6GJABU_GUID@@PAPAX@ZA ; CreateDXGIFactory1_Import
	mov	ecx, DWORD PTR _pFactory2$[ebp]
	test	eax, eax
	js	SHORT $LN7@SK_DXGI_Ho
$LN8@SK_DXGI_Ho:

; 5062 :          SUCCEEDED (CreateDXGIFactory1_Import (IID_IDXGIFactory2, (void **)&pFactory2)) )
; 5063 :     {
; 5064 :       DXGI_VIRTUAL_HOOK ( &pFactory2,   15,

	push	OFFSET ?CreateSwapChainForHwnd_Original@@3P6GJPAUIDXGIFactory2@@PAUIUnknown@@PAUHWND__@@PBUDXGI_SWAP_CHAIN_DESC1@@PBUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@ZA ; CreateSwapChainForHwnd_Original
	push	OFFSET ?DXGIFactory2_CreateSwapChainForHwnd_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@PAUHWND__@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z ; DXGIFactory2_CreateSwapChainForHwnd_Override
	push	15					; 0000000fH
	push	DWORD PTR [ecx]
	push	OFFSET $SG366719
	call	?SK_CreateVFTableHook2@@YG?AW4MH_STATUS@@PB_WPAPAXKPAX1@Z ; SK_CreateVFTableHook2

; 5065 :                           "IDXGIFactory2::CreateSwapChainForHwnd",
; 5066 :                            DXGIFactory2_CreateSwapChainForHwnd_Override,
; 5067 :                                         CreateSwapChainForHwnd_Original,
; 5068 :                                         CreateSwapChainForHwnd_pfn );
; 5069 : 
; 5070 :       DXGI_VIRTUAL_HOOK ( &pFactory2,   16,

	mov	eax, DWORD PTR _pFactory2$[ebp]
	push	OFFSET ?CreateSwapChainForCoreWindow_Original@@3P6GJPAUIDXGIFactory2@@PAUIUnknown@@1PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@ZA ; CreateSwapChainForCoreWindow_Original
	push	OFFSET ?DXGIFactory2_CreateSwapChainForCoreWindow_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@1PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z ; DXGIFactory2_CreateSwapChainForCoreWindow_Override
	push	16					; 00000010H
	push	DWORD PTR [eax]
	push	OFFSET $SG366720
	call	?SK_CreateVFTableHook2@@YG?AW4MH_STATUS@@PB_WPAPAXKPAX1@Z ; SK_CreateVFTableHook2

; 5071 :                           "IDXGIFactory2::CreateSwapChainForCoreWindow",
; 5072 :                            DXGIFactory2_CreateSwapChainForCoreWindow_Override,
; 5073 :                                         CreateSwapChainForCoreWindow_Original,
; 5074 :                                         CreateSwapChainForCoreWindow_pfn );
; 5075 : 
; 5076 :       DXGI_VIRTUAL_HOOK ( &pFactory2,   24,

	mov	eax, DWORD PTR _pFactory2$[ebp]
	push	OFFSET ?CreateSwapChainForComposition_Original@@3P6GJPAUIDXGIFactory2@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@ZA ; CreateSwapChainForComposition_Original
	push	OFFSET ?DXGIFactory2_CreateSwapChainForComposition_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z ; DXGIFactory2_CreateSwapChainForComposition_Override
	push	24					; 00000018H
	push	DWORD PTR [eax]
	push	OFFSET $SG366721
	call	?SK_CreateVFTableHook2@@YG?AW4MH_STATUS@@PB_WPAPAXKPAX1@Z ; SK_CreateVFTableHook2
	mov	ecx, DWORD PTR _pFactory2$[ebp]
$LN7@SK_DXGI_Ho:

; 5102 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	ecx, ecx
	je	SHORT $LN95@SK_DXGI_Ho

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN95@SK_DXGI_Ho:

; 176  :         if (p)

	mov	eax, DWORD PTR _pFactory1$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5102 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN104@SK_DXGI_Ho

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN104@SK_DXGI_Ho:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5102 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_DXGI_HookFactory@@YAXPAUIDXGIFactory@@@Z$0:
	lea	ecx, DWORD PTR _pFactory1$[ebp]
	jmp	??1?$CComQIPtr@UIDXGIFactory1@@$1?_GUID_770aae78_f26f_4dba_a829_253c83d1b387@@3U__s_GUID@@B@ATL@@QAE@XZ
__unwindfunclet$?SK_DXGI_HookFactory@@YAXPAUIDXGIFactory@@@Z$1:
	lea	ecx, DWORD PTR _pFactory2$[ebp]
	jmp	??1?$CComQIPtr@UIDXGIFactory2@@$1?_GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0@@3U__s_GUID@@B@ATL@@QAE@XZ
__ehhandler$?SK_DXGI_HookFactory@@YAXPAUIDXGIFactory@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?SK_DXGI_HookFactory@@YAXPAUIDXGIFactory@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_DXGI_HookFactory@@YAXPAUIDXGIFactory@@@Z ENDP	; SK_DXGI_HookFactory
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtr@UIDXGIOutput@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComPtr@UIDXGIOutput@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<IDXGIOutput>::~CComPtr<IDXGIOutput>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComPtr@UIDXGIOutput@@@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@CComPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN4@CComPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComPtr@UIDXGIOutput@@@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComPtr@UIDXGIOutput@@@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComPtr@UIDXGIOutput@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<IDXGIOutput>::~CComPtr<IDXGIOutput>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UIDXGIOutput@@@ATL@@QAE@PAUIDXGIOutput@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtr@UIDXGIOutput@@@ATL@@QAE@PAUIDXGIOutput@@@Z PROC ; ATL::CComPtr<IDXGIOutput>::CComPtr<IDXGIOutput>, COMDAT
; _this$ = ecx

; 312  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi

; 312  :     {

	mov	esi, ecx

; 162  :         p = lp;

	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN6@CComPtr

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN6@CComPtr:

; 313  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtr@UIDXGIOutput@@@ATL@@QAE@PAUIDXGIOutput@@@Z ENDP ; ATL::CComPtr<IDXGIOutput>::CComPtr<IDXGIOutput>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??8?$CComPtrBase@UIDXGIOutput@@@ATL@@QBE_NPAUIDXGIOutput@@@Z
_TEXT	SEGMENT
_pT$ = 8						; size = 4
??8?$CComPtrBase@UIDXGIOutput@@@ATL@@QBE_NPAUIDXGIOutput@@@Z PROC ; ATL::CComPtrBase<IDXGIOutput>::operator==, COMDAT
; _this$ = ecx

; 213  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR _pT$[ebp]
	sete	al

; 214  :         return p == pT;
; 215  :     }

	pop	ebp
	ret	4
??8?$CComPtrBase@UIDXGIOutput@@@ATL@@QBE_NPAUIDXGIOutput@@@Z ENDP ; ATL::CComPtrBase<IDXGIOutput>::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??9?$CComPtrBase@UIDXGIOutput@@@ATL@@QBE_NPAUIDXGIOutput@@@Z
_TEXT	SEGMENT
_pT$ = 8						; size = 4
??9?$CComPtrBase@UIDXGIOutput@@@ATL@@QBE_NPAUIDXGIOutput@@@Z PROC ; ATL::CComPtrBase<IDXGIOutput>::operator!=, COMDAT
; _this$ = ecx

; 209  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR _pT$[ebp]
	setne	al

; 210  :         return !operator==(pT);
; 211  :     }

	pop	ebp
	ret	4
??9?$CComPtrBase@UIDXGIOutput@@@ATL@@QBE_NPAUIDXGIOutput@@@Z ENDP ; ATL::CComPtrBase<IDXGIOutput>::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??I?$CComPtrBase@UIDXGIOutput@@@ATL@@QAEPAPAUIDXGIOutput@@XZ
_TEXT	SEGMENT
??I?$CComPtrBase@UIDXGIOutput@@@ATL@@QAEPAPAUIDXGIOutput@@XZ PROC ; ATL::CComPtrBase<IDXGIOutput>::operator&, COMDAT
; _this$ = ecx

; 192  :         ATLASSERT(p==NULL);
; 193  :         return &p;

	mov	eax, ecx

; 194  :     }

	ret	0
??I?$CComPtrBase@UIDXGIOutput@@@ATL@@QAEPAPAUIDXGIOutput@@XZ ENDP ; ATL::CComPtrBase<IDXGIOutput>::operator&
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UIDXGIOutput@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UIDXGIOutput@@@ATL@@QAE@XZ PROC	; ATL::CComPtrBase<IDXGIOutput>::~CComPtrBase<IDXGIOutput>, COMDAT
; _this$ = ecx

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN2@CComPtrBas

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@CComPtrBas:

; 178  :     }

	ret	0
??1?$CComPtrBase@UIDXGIOutput@@@ATL@@QAE@XZ ENDP	; ATL::CComPtrBase<IDXGIOutput>::~CComPtrBase<IDXGIOutput>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UIDXGIOutput@@@ATL@@IAE@PAUIDXGIOutput@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtrBase@UIDXGIOutput@@@ATL@@IAE@PAUIDXGIOutput@@@Z PROC ; ATL::CComPtrBase<IDXGIOutput>::CComPtrBase<IDXGIOutput>, COMDAT
; _this$ = ecx

; 160  :     CComPtrBase(_Inout_opt_ T* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp

; 161  :     {
; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN4@CComPtrBas

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN4@CComPtrBas:

; 165  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtrBase@UIDXGIOutput@@@ATL@@IAE@PAUIDXGIOutput@@@Z ENDP ; ATL::CComPtrBase<IDXGIOutput>::CComPtrBase<IDXGIOutput>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_fmt$ = 12						; size = 4
?SK_DXGI_FormatToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4DXGI_FORMAT@@@Z PROC ; SK_DXGI_FormatToString

; 4924 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	17					; 00000011H
	push	OFFSET $SG366130
	mov	ecx, esi
	mov	DWORD PTR $T1[ebp], 0

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [esi], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4926 :   return L"<NOT IMPLEMENTED>";

	mov	eax, esi
	pop	esi

; 4927 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SK_DXGI_FormatToString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4DXGI_FORMAT@@@Z ENDP ; SK_DXGI_FormatToString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_pSwapChain1$ = 8					; size = 4
_rehook$ = 12						; size = 1
?SK_DXGI_HookPresent1@@YAXPAUIDXGISwapChain1@@_N@Z PROC	; SK_DXGI_HookPresent1

; 4868 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 4869 :   static LPVOID vftable_22 = nullptr;
; 4870 : 
; 4871 :   void** vftable = *(void***)*&pSwapChain1;
; 4872 : 
; 4873 :   if (Present1_Original != nullptr)

	mov	eax, DWORD PTR ?Present1_Original@@3P6GJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@ZA ; Present1_Original
	push	esi
	mov	esi, DWORD PTR _pSwapChain1$[ebp]
	push	edi
	mov	edi, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN9@SK_DXGI_Ho

; 4874 :   {
; 4875 :     //dll_log.Log (L"Rehooking IDXGISwapChain::Present1 (...)");
; 4876 : 
; 4877 :     if (rehook)

	cmp	BYTE PTR _rehook$[ebp], 0
	je	SHORT $LN6@SK_DXGI_Ho

; 4878 :     {
; 4879 :       if (MH_OK == SK_RemoveHook (vftable [22]))

	push	DWORD PTR [edi+88]
	call	?SK_RemoveHook@@YG?AW4MH_STATUS@@PAX@Z	; SK_RemoveHook
	test	eax, eax
	jne	SHORT $LN4@SK_DXGI_Ho
$LN11@SK_DXGI_Ho:

; 4880 :       {
; 4881 :         Present1_Original = nullptr;

	mov	DWORD PTR ?Present1_Original@@3P6GJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@ZA, 0 ; Present1_Original

; 4882 :       }
; 4883 : 
; 4884 :       else

	jmp	SHORT $LN9@SK_DXGI_Ho
$LN4@SK_DXGI_Ho:

; 4885 :       {
; 4886 :         dll_log.Log ( L"[   DXGI   ] Altered vftable detected, rehooking "

	push	OFFSET $SG366114
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8

; 4887 :                       L"IDXGISwapChain1::Present1 (...)!" );
; 4888 :         if (MH_OK == SK_RemoveHook (vftable_22))

	push	DWORD PTR ?vftable_22@?1??SK_DXGI_HookPresent1@@YAXPAUIDXGISwapChain1@@_N@Z@4PAXA
	call	?SK_RemoveHook@@YG?AW4MH_STATUS@@PAX@Z	; SK_RemoveHook
	test	eax, eax
	je	SHORT $LN11@SK_DXGI_Ho

; 4889 :           Present1_Original = nullptr;
; 4890 :       }
; 4891 :     }
; 4892 :   }
; 4893 : 
; 4894 :   if (Present1_Original == nullptr)

	mov	eax, DWORD PTR ?Present1_Original@@3P6GJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@ZA ; Present1_Original
$LN6@SK_DXGI_Ho:
	test	eax, eax
	jne	SHORT $LN7@SK_DXGI_Ho
$LN9@SK_DXGI_Ho:

; 4895 :   {
; 4896 :     DXGI_VIRTUAL_HOOK ( &pSwapChain1, 22,

	push	OFFSET ?Present1_Original@@3P6GJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@ZA ; Present1_Original
	push	OFFSET ?Present1Callback@@YGJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@Z ; Present1Callback
	push	22					; 00000016H
	push	DWORD PTR [esi]
	push	OFFSET $SG366117
	call	?SK_CreateVFTableHook2@@YG?AW4MH_STATUS@@PB_WPAPAXKPAX1@Z ; SK_CreateVFTableHook2

; 4897 :                         "IDXGISwapChain1::Present1",
; 4898 :                          Present1Callback,
; 4899 :                          Present1_Original,
; 4900 :                          Present1SwapChain1_pfn );
; 4901 : 
; 4902 :     vftable_22 = vftable [22];

	mov	eax, DWORD PTR [edi+88]
	mov	DWORD PTR ?vftable_22@?1??SK_DXGI_HookPresent1@@YAXPAUIDXGISwapChain1@@_N@Z@4PAXA, eax
$LN7@SK_DXGI_Ho:
	pop	edi
	pop	esi

; 4903 :   }
; 4904 : }

	pop	ebp
	ret	0
?SK_DXGI_HookPresent1@@YAXPAUIDXGISwapChain1@@_N@Z ENDP	; SK_DXGI_HookPresent1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_pSwapChain$ = 8					; size = 4
_rehook$ = 12						; size = 1
?SK_DXGI_HookPresentBase@@YAXPAUIDXGISwapChain@@_N@Z PROC ; SK_DXGI_HookPresentBase

; 4812 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 4813 :   if (rehook)

	cmp	BYTE PTR _rehook$[ebp], 0
	je	SHORT $LN2@SK_DXGI_Ho
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h

; 9003 :     return (unsigned long) _InterlockedCompareExchange((volatile long*) Destination, (long) Exchange, (long) Comperand);

	mov	ecx, 1
	mov	edx, OFFSET ?__installed_second_hook@?4??SK_DXGI_HookPresentBase@@YAXPAUIDXGISwapChain@@_N@Z@4KC
	xor	eax, eax
	lock	 cmpxchg DWORD PTR [edx], ecx
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4817 :     if (! InterlockedCompareExchange (&__installed_second_hook, TRUE, FALSE))

	test	eax, eax
	jne	SHORT $LN10@SK_DXGI_Ho

; 4818 :     {
; 4819 :       DXGI_INTERCEPT_EX ( &pSwapChain, 8,

	cmp	DWORD PTR ?PresentSwapChain_Original_Pre@@3P6GJPAUIDXGISwapChain@@II@ZA, eax ; PresentSwapChain_Original_Pre
	jne	SHORT $LN4@SK_DXGI_Ho
	mov	eax, DWORD PTR _pSwapChain$[ebp]
	push	1
	push	OFFSET ?PresentSwapChain_Original_Pre@@3P6GJPAUIDXGISwapChain@@II@ZA ; PresentSwapChain_Original_Pre
	push	OFFSET ?PresentCallback_Pre@@YGJPAUIDXGISwapChain@@II@Z ; PresentCallback_Pre
	push	8
	push	DWORD PTR [eax]
	push	OFFSET $SG366090
	call	?SK_CreateVFTableHookEx@@YG?AW4MH_STATUS@@PB_WPAPAXKPAX1I@Z ; SK_CreateVFTableHookEx
$LN4@SK_DXGI_Ho:

; 4820 :                             "IDXGISwapChain::Present",
; 4821 :                             PresentCallback_Pre,
; 4822 :                             PresentSwapChain_Original_Pre,
; 4823 :                             PresentSwapChain_pfn );
; 4824 :       MH_ApplyQueuedEx (1);

	push	1
	call	_MH_ApplyQueuedEx@4

; 4863 :   }
; 4864 : }

	pop	ebp
	ret	0
$LN2@SK_DXGI_Ho:

; 4825 :     }
; 4826 : 
; 4827 :     return;
; 4828 :   }
; 4829 : 
; 4830 :   static LPVOID vftable_8  = nullptr;
; 4831 : 
; 4832 :   void** vftable = *(void***)*&pSwapChain;
; 4833 : 
; 4834 :   if (Present_Original != nullptr)

	cmp	DWORD PTR ?Present_Original@@3P6GJPAUIDXGISwapChain@@II@ZA, 0 ; Present_Original
	mov	ecx, DWORD PTR _pSwapChain$[ebp]
	push	esi
	mov	esi, DWORD PTR [ecx]
	jne	SHORT $LN15@SK_DXGI_Ho

; 4835 :   {
; 4836 :     //dll_log.Log (L"Rehooking IDXGISwapChain::Present (...)");
; 4837 : 
; 4838 :     if (rehook)
; 4839 :     {
; 4840 :       if (MH_OK == SK_RemoveHook (vftable [8]))
; 4841 :         Present_Original = nullptr;
; 4842 :       else {
; 4843 :         dll_log.Log ( L"[   DXGI   ] Altered vftable detected, rehooking "
; 4844 :                       L"IDXGISwapChain::Present (...)!" );
; 4845 :         if (MH_OK == SK_RemoveHook (vftable_8))
; 4846 :           Present_Original = nullptr;
; 4847 :       }
; 4848 :     }
; 4849 :   }
; 4850 : 
; 4851 :   if (Present_Original == nullptr)
; 4852 :   {
; 4853 :     Present_Target = (PresentSwapChain_pfn)vftable [8];

	mov	eax, DWORD PTR [esi+32]

; 4854 : 
; 4855 :     DXGI_VIRTUAL_HOOK ( &pSwapChain, 8,

	push	OFFSET ?Present_Original@@3P6GJPAUIDXGISwapChain@@II@ZA ; Present_Original
	push	OFFSET ?PresentCallback@@YGJPAUIDXGISwapChain@@II@Z ; PresentCallback
	push	8
	mov	DWORD PTR ?Present_Target@@3P6GJPAUIDXGISwapChain@@II@ZA, eax ; Present_Target
	push	DWORD PTR [ecx]
	push	OFFSET $SG366098
	call	?SK_CreateVFTableHook2@@YG?AW4MH_STATUS@@PB_WPAPAXKPAX1@Z ; SK_CreateVFTableHook2

; 4856 :                         "IDXGISwapChain::Present",
; 4857 :                          PresentCallback,
; 4858 :                          Present_Original,
; 4859 :                          PresentSwapChain_pfn );
; 4860 : 
; 4861 :     memcpy (Present_GuardBytes, Present_Target, 16);

	mov	eax, DWORD PTR ?Present_Target@@3P6GJPAUIDXGISwapChain@@II@ZA ; Present_Target
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR ?Present_GuardBytes@@3PAEA, xmm0

; 4862 :     vftable_8 = vftable [8];

	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR ?vftable_8@?1??SK_DXGI_HookPresentBase@@YAXPAUIDXGISwapChain@@_N@Z@4PAXA, eax
$LN15@SK_DXGI_Ho:
	pop	esi
$LN10@SK_DXGI_Ho:

; 4863 :   }
; 4864 : }

	pop	ebp
	ret	0
?SK_DXGI_HookPresentBase@@YAXPAUIDXGISwapChain@@_N@Z ENDP ; SK_DXGI_HookPresentBase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_This$ = 8						; size = 4
_SyncInterval$ = 12					; size = 4
_Flags$ = 16						; size = 4
?PresentCallback_Pre@@YGJPAUIDXGISwapChain@@II@Z PROC	; PresentCallback_Pre

; 4799 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	edi

; 4800 :   SK_GetCurrentRenderBackend ().present_interval = SyncInterval;

	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend

; 4801 : 
; 4802 :   SK_CEGUI_DrawD3D11 (This);

	push	DWORD PTR _This$[ebp]
	mov	edi, DWORD PTR _SyncInterval$[ebp]
	mov	DWORD PTR [eax+64], edi
	call	?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z ; SK_CEGUI_DrawD3D11
	add	esp, 4

; 4803 : 
; 4804 :   return PresentSwapChain_Original_Pre (This, SyncInterval, Flags);

	push	DWORD PTR _Flags$[ebp]
	push	edi
	push	DWORD PTR _This$[ebp]
	call	DWORD PTR ?PresentSwapChain_Original_Pre@@3P6GJPAUIDXGISwapChain@@II@ZA ; PresentSwapChain_Original_Pre
	pop	edi

; 4805 : }

	pop	ebp
	ret	12					; 0000000cH
?PresentCallback_Pre@@YGJPAUIDXGISwapChain@@II@Z ENDP	; PresentCallback_Pre
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
?SK_DXGI_PreHook@@YAXXZ PROC				; SK_DXGI_PreHook

; 4730 :   if (! SK_IsInjected ())

	push	0
	call	?SK_IsInjected@@YG_N_N@Z		; SK_IsInjected
	test	al, al
	je	$LN8@SK_DXGI_Pr

; 4731 :     return;
; 4732 : 
; 4733 :   if (SK_GetDLLRole () != DLL_ROLE::DXGI && (! LoadLibraryW (L"dxgi.dll")))

	call	?SK_GetDLLRole@@YG?AW4DLL_ROLE@@XZ	; SK_GetDLLRole
	cmp	eax, 1
	je	SHORT $LN3@SK_DXGI_Pr
	push	OFFSET $SG366050
	call	DWORD PTR __imp__LoadLibraryW@4
	test	eax, eax
	je	$LN8@SK_DXGI_Pr
$LN3@SK_DXGI_Pr:

; 4734 :     return;
; 4735 : 
; 4736 :   if (! config.injection.global.use_static_addresses)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+724, 0
	je	$LN8@SK_DXGI_Pr

; 4737 :     return;
; 4738 : 
; 4739 :   extern HRESULT
; 4740 :   STDMETHODCALLTYPE PresentCallback (IDXGISwapChain *This,
; 4741 :                                      UINT            SyncInterval,
; 4742 :                                      UINT            Flags);
; 4743 : 
; 4744 :   if (LoadLibraryW (L"dxgi.dll") && Present_Target == nullptr)

	push	OFFSET $SG366053
	call	DWORD PTR __imp__LoadLibraryW@4
	test	eax, eax
	je	$LN8@SK_DXGI_Pr
	cmp	DWORD PTR ?Present_Target@@3P6GJPAUIDXGISwapChain@@II@ZA, 0 ; Present_Target
	jne	$LN8@SK_DXGI_Pr

; 4745 :   {
; 4746 :     SK_LOG0 ((L" Enabling Static Injection Addresses for DXGI"), L"DXGI Hooks");

	cmp	DWORD PTR ?config@@3Usk_config_t@@A+808, 0
	jl	SHORT $LN6@SK_DXGI_Pr
	push	OFFSET $SG366055
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8
$LN6@SK_DXGI_Pr:

; 4747 : 
; 4748 :     Present_Target       = reinterpret_cast <PresentSwapChain_pfn>

	mov	ecx, DWORD PTR ?SK_Inject_AddressManager@@3PAVSK_Inject_AddressCacheRegistry@@A ; SK_Inject_AddressManager
	push	1
	push	OFFSET $SG366056
	push	OFFSET $SG366057
	call	?getNamedAddress@SK_Inject_AddressCacheRegistry@@QAEIPB_WPBDW4SK_SYS_CPUArch@@@Z ; SK_Inject_AddressCacheRegistry::getNamedAddress

; 4749 :        ( SK_Inject_AddressManager->getNamedAddress (L"dxgi", "IDXGISwapChain::Present") );
; 4750 : 
; 4751 :     if (MH_OK == MH_CreateHook (Present_Target, PresentCallback, (LPVOID *)&Present_Original))

	push	OFFSET ?Present_Original@@3P6GJPAUIDXGISwapChain@@II@ZA ; Present_Original
	push	OFFSET ?PresentCallback@@YGJPAUIDXGISwapChain@@II@Z ; PresentCallback
	push	eax
	mov	DWORD PTR ?Present_Target@@3P6GJPAUIDXGISwapChain@@II@ZA, eax ; Present_Target
	call	_MH_CreateHook@12
	test	eax, eax
	jne	SHORT $LN7@SK_DXGI_Pr

; 4752 :     {
; 4753 :                  MH_EnableHook (Present_Target);

	push	DWORD PTR ?Present_Target@@3P6GJPAUIDXGISwapChain@@II@ZA ; Present_Target
	call	_MH_EnableHook@4

; 4754 :       memcpy ( Present_GuardBytes,

	mov	eax, DWORD PTR ?Present_Target@@3P6GJPAUIDXGISwapChain@@II@ZA ; Present_Target
	movups	xmm0, XMMWORD PTR [eax]

; 4755 :                                 Present_Target, 16 );
; 4756 :     }
; 4757 : 
; 4758 :     else
; 4759 :     {
; 4760 :       Present_Target = nullptr; ZeroMemory (Present_GuardBytes, 16); Present_Original = nullptr;

	movups	XMMWORD PTR ?Present_GuardBytes@@3PAEA, xmm0

; 4761 :     }
; 4762 :   }
; 4763 : }

	ret	0
$LN7@SK_DXGI_Pr:
	xorps	xmm0, xmm0

; 4755 :                                 Present_Target, 16 );
; 4756 :     }
; 4757 : 
; 4758 :     else
; 4759 :     {
; 4760 :       Present_Target = nullptr; ZeroMemory (Present_GuardBytes, 16); Present_Original = nullptr;

	mov	DWORD PTR ?Present_Target@@3P6GJPAUIDXGISwapChain@@II@ZA, 0 ; Present_Target
	mov	DWORD PTR ?Present_Original@@3P6GJPAUIDXGISwapChain@@II@ZA, 0 ; Present_Original
	movups	XMMWORD PTR ?Present_GuardBytes@@3PAEA, xmm0
$LN8@SK_DXGI_Pr:

; 4761 :     }
; 4762 :   }
; 4763 : }

	ret	0
?SK_DXGI_PreHook@@YAXXZ ENDP				; SK_DXGI_PreHook
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_finish$ = 8						; size = 4
?dxgi_init_callback@@YGXP6GXXZ@Z PROC			; dxgi_init_callback

; 4710 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 4711 :   if (! SK_IsHostAppSKIM ())

	call	?SK_IsHostAppSKIM@@YA_NXZ		; SK_IsHostAppSKIM
	test	al, al
	jne	SHORT $LN3@dxgi_init_

; 4712 :   {
; 4713 :     SK_BootDXGI ();

	call	?SK_BootDXGI@@YAXXZ			; SK_BootDXGI
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?__dxgi_ready@@3JC	; __dxgi_ready
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4715 :     while (! ReadAcquire (&__dxgi_ready))

	test	eax, eax
	jne	SHORT $LN3@dxgi_init_
	push	esi
	mov	esi, DWORD PTR __imp__MsgWaitForMultipleObjectsEx@20
$LL2@dxgi_init_:

; 4716 :       MsgWaitForMultipleObjectsEx (0, nullptr, 100, QS_ALLINPUT, MWMO_ALERTABLE);

	push	2
	push	1279					; 000004ffH
	push	100					; 00000064H
	push	0
	push	0
	call	esi
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?__dxgi_ready@@3JC	; __dxgi_ready
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4715 :     while (! ReadAcquire (&__dxgi_ready))

	test	eax, eax
	je	SHORT $LL2@dxgi_init_
	pop	esi
$LN3@dxgi_init_:

; 4717 :   }
; 4718 : 
; 4719 :   finish ();

	call	DWORD PTR _finish$[ebp]

; 4720 : }

	pop	ebp
	ret	4
?dxgi_init_callback@@YGXP6GXXZ@Z ENDP			; dxgi_init_callback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
;	COMDAT ??__Fold_threads@@YAXXZ
text$yd	SEGMENT
__Alproxy$1 = -1					; size = 1
??__Fold_threads@@YAXXZ PROC				; `dynamic atexit destructor for 'old_threads'', COMDAT
	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 1244 : 		_Tidy();

	mov	ecx, OFFSET ?old_threads@@3V?$queue@KV?$deque@KV?$allocator@K@std@@@std@@@std@@A
	call	?_Tidy@?$deque@KV?$allocator@K@std@@@std@@IAEXXZ ; std::deque<unsigned long,std::allocator<unsigned long> >::_Tidy

; 862  : 			_Alproxy(_Getal());

	push	OFFSET ?old_threads@@3V?$queue@KV?$deque@KV?$allocator@K@std@@@std@@@std@@A
	lea	ecx, DWORD PTR __Alproxy$1[ebp]
	call	??$?0AAU?$_Wrap_alloc@V?$allocator@K@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@K@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<unsigned long> > &>

; 863  : 		_Orphan_all();

	mov	ecx, OFFSET ?old_threads@@3V?$queue@KV?$deque@KV?$allocator@K@std@@@std@@@std@@A
	call	?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Orphan_all

; 864  : 		_Alproxy.destroy(_Myproxy());

	push	DWORD PTR ?old_threads@@3V?$queue@KV?$deque@KV?$allocator@K@std@@@std@@@std@@A
	lea	ecx, DWORD PTR __Alproxy$1[ebp]
	call	??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
	push	1
	push	DWORD PTR ?old_threads@@3V?$queue@KV?$deque@KV?$allocator@K@std@@@std@@@std@@A
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque

; 866  : 		_Myproxy() = 0;

	mov	DWORD PTR ?old_threads@@3V?$queue@KV?$deque@KV?$allocator@K@std@@@std@@@std@@A, 0

; 814  : 		}

	mov	ecx, OFFSET ?old_threads@@3V?$queue@KV?$deque@KV?$allocator@K@std@@@std@@@std@@A
	call	??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@$00@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??__Fold_threads@@YAXXZ ENDP				; `dynamic atexit destructor for 'old_threads''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
;	COMDAT ??__Eold_threads@@YAXXZ
text$di	SEGMENT
__Alproxy$1 = -1					; size = 1
??__Eold_threads@@YAXXZ PROC				; `dynamic initializer for 'old_threads'', COMDAT

; 4705 : static std::queue <DWORD> old_threads;

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 302  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	mov	ecx, OFFSET ?old_threads@@3V?$queue@KV?$deque@KV?$allocator@K@std@@@std@@@std@@A
	call	??0?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<unsigned long> >::_Wrap_alloc<std::allocator<unsigned long> >
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque

; 853  : 			_Alproxy(_Getal());

	push	OFFSET ?old_threads@@3V?$queue@KV?$deque@KV?$allocator@K@std@@@std@@@std@@A
	lea	ecx, DWORD PTR __Alproxy$1[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 99   : 		: _Myproxy(0)

	mov	DWORD PTR ?old_threads@@3V?$queue@KV?$deque@KV?$allocator@K@std@@@std@@@std@@A, 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque

; 752  : 		: _Map(),

	mov	DWORD PTR ?old_threads@@3V?$queue@KV?$deque@KV?$allocator@K@std@@@std@@@std@@A+4, 0

; 753  : 		_Mapsize(0),

	mov	DWORD PTR ?old_threads@@3V?$queue@KV?$deque@KV?$allocator@K@std@@@std@@@std@@A+8, 0

; 754  : 		_Myoff(0),

	mov	DWORD PTR ?old_threads@@3V?$queue@KV?$deque@KV?$allocator@K@std@@@std@@@std@@A+12, 0

; 755  : 		_Mysize(0)

	mov	DWORD PTR ?old_threads@@3V?$queue@KV?$deque@KV?$allocator@K@std@@@std@@@std@@A+16, 0

; 853  : 			_Alproxy(_Getal());

	call	??$?0AAU?$_Wrap_alloc@V?$allocator@K@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@K@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<unsigned long> > &>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN36@dynamic
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN106@dynamic:
$LN36@dynamic:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque

; 854  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR ?old_threads@@3V?$queue@KV?$deque@KV?$allocator@K@std@@@std@@@std@@A, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque

; 856  : 		_Myproxy()->_Mycont = _STD addressof(_Get_data());

	mov	eax, DWORD PTR ?old_threads@@3V?$queue@KV?$deque@KV?$allocator@K@std@@@std@@@std@@A
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4705 : static std::queue <DWORD> old_threads;

	push	OFFSET ??__Fold_threads@@YAXXZ		; `dynamic atexit destructor for 'old_threads''
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque

; 856  : 		_Myproxy()->_Mycont = _STD addressof(_Get_data());

	mov	DWORD PTR [eax], OFFSET ?old_threads@@3V?$queue@KV?$deque@KV?$allocator@K@std@@@std@@@std@@A
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4705 : static std::queue <DWORD> old_threads;

	call	_atexit
	add	esp, 4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN105@dynamic:
??__Eold_threads@@YAXXZ ENDP				; `dynamic initializer for 'old_threads''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
;	COMDAT ??1?$queue@KV?$deque@KV?$allocator@K@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$queue@KV?$deque@KV?$allocator@K@std@@@std@@@std@@QAE@XZ PROC ; std::queue<unsigned long,std::deque<unsigned long,std::allocator<unsigned long> > >::~queue<unsigned long,std::deque<unsigned long,std::allocator<unsigned long> > >, COMDAT
; _this$ = ecx
	npad	2
	push	esi
	mov	esi, ecx

; 1244 : 		_Tidy();

	call	?_Tidy@?$deque@KV?$allocator@K@std@@@std@@IAEXXZ ; std::deque<unsigned long,std::allocator<unsigned long> >::_Tidy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
	push	1
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque

; 866  : 		_Myproxy() = 0;

	mov	DWORD PTR [esi], 0
	pop	esi
	ret	0
??1?$queue@KV?$deque@KV?$allocator@K@std@@@std@@@std@@QAE@XZ ENDP ; std::queue<unsigned long,std::deque<unsigned long,std::allocator<unsigned long> > >::~queue<unsigned long,std::deque<unsigned long,std::allocator<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\queue
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\queue
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\queue
;	COMDAT ??0?$queue@KV?$deque@KV?$allocator@K@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$queue@KV?$deque@KV?$allocator@K@std@@@std@@@std@@QAE@XZ PROC ; std::queue<unsigned long,std::deque<unsigned long,std::allocator<unsigned long> > >::queue<unsigned long,std::deque<unsigned long,std::allocator<unsigned long> > >, COMDAT
; _this$ = ecx

; 33   : 		{	// construct with empty container

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\queue

; 33   : 		{	// construct with empty container

	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 99   : 		: _Myproxy(0)

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque

; 752  : 		: _Map(),

	mov	DWORD PTR [esi+4], 0

; 753  : 		_Mapsize(0),

	mov	DWORD PTR [esi+8], 0

; 754  : 		_Myoff(0),

	mov	DWORD PTR [esi+12], 0

; 755  : 		_Mysize(0)

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN34@queue
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN103@queue:
$LN34@queue:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque

; 854  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque

; 856  : 		_Myproxy()->_Mycont = _STD addressof(_Get_data());

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\queue

; 34   : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN102@queue:
??0?$queue@KV?$deque@KV?$allocator@K@std@@@std@@@std@@QAE@XZ ENDP ; std::queue<unsigned long,std::deque<unsigned long,std::allocator<unsigned long> > >::queue<unsigned long,std::deque<unsigned long,std::allocator<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
;	COMDAT ?_Tidy@?$deque@KV?$allocator@K@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$deque@KV?$allocator@K@std@@@std@@IAEXXZ PROC	; std::deque<unsigned long,std::allocator<unsigned long> >::_Tidy, COMDAT
; _this$ = ecx

; 1863 : 		{	// free all storage

	npad	2
	push	esi
	mov	esi, ecx

; 1397 : 		return (this->_Mysize() == 0);

	cmp	DWORD PTR [esi+16], 0

; 1864 : 		_Alpty _Almap(this->_Getal());
; 1865 : 		while (!empty())

	je	SHORT $LN3@Tidy
	npad	5
$LL2@Tidy:

; 1535 : 		if (--this->_Mysize() == 0)

	add	DWORD PTR [esi+16], -1
	jne	SHORT $LN29@Tidy

; 1536 : 			this->_Myoff() = 0;

	mov	DWORD PTR [esi+12], 0
$LN29@Tidy:

; 1397 : 		return (this->_Mysize() == 0);

	cmp	DWORD PTR [esi+16], 0

; 1864 : 		_Alpty _Almap(this->_Getal());
; 1865 : 		while (!empty())

	jne	SHORT $LL2@Tidy
$LN3@Tidy:
	push	edi

; 1867 : 		for (size_type _Block = this->_Mapsize(); 0 < _Block; )

	mov	edi, DWORD PTR [esi+8]
	test	edi, edi
	je	SHORT $LN5@Tidy
	npad	5
$LL4@Tidy:

; 1868 : 			{	// free storage for a block and destroy pointer
; 1869 : 			if (this->_Map()[--_Block] != pointer())

	mov	eax, DWORD PTR [esi+4]
	dec	edi
	mov	eax, DWORD PTR [eax+edi*4]
	test	eax, eax
	je	SHORT $LN7@Tidy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@Tidy:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque

; 1867 : 		for (size_type _Block = this->_Mapsize(); 0 < _Block; )

	test	edi, edi
	jne	SHORT $LL4@Tidy
$LN5@Tidy:

; 1870 : 				{	// free block and destroy its pointer
; 1871 : 				this->_Getal().deallocate(this->_Map()[_Block], _DEQUESIZ);
; 1872 : 				this->_Getal().destroy(_STD addressof(this->_Map()[_Block]));
; 1873 : 				}
; 1874 : 			}
; 1875 : 
; 1876 : 		if (this->_Map() != _Mapptr())

	mov	ecx, DWORD PTR [esi+4]
	pop	edi
	test	ecx, ecx
	je	SHORT $LN198@Tidy

; 1877 : 			_Almap.deallocate(this->_Map(),

	mov	eax, DWORD PTR [esi+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN192@Tidy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN232@Tidy:
$LN192@Tidy:

; 99   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 2

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN193@Tidy

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31					; 0000001fH
	je	SHORT $LN194@Tidy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN233@Tidy:
$LN194@Tidy:

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ecx-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ecx
	jb	SHORT $LN195@Tidy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN234@Tidy:
$LN195@Tidy:

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ecx, eax
	cmp	ecx, 4
	jae	SHORT $LN196@Tidy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN235@Tidy:
$LN196@Tidy:

; 126  : 			<= _Ptr_user - _Ptr_container);
; 127  :  #endif /* _DEBUG */
; 128  : 
; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ecx, 35					; 00000023H
	jbe	SHORT $LN197@Tidy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN236@Tidy:
$LN197@Tidy:

; 130  : 			<= _NON_USER_SIZE);
; 131  : 
; 132  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, eax
$LN193@Tidy:

; 140  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN198@Tidy:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque

; 1879 : 		this->_Mapsize() = 0;

	mov	DWORD PTR [esi+8], 0

; 1880 : 		this->_Map() = _Mapptr();

	mov	DWORD PTR [esi+4], 0
	pop	esi

; 1881 : 		}

	ret	0
$LN231@Tidy:
?_Tidy@?$deque@KV?$allocator@K@std@@@std@@IAEXXZ ENDP	; std::deque<unsigned long,std::allocator<unsigned long> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
;	COMDAT ?pop_back@?$deque@KV?$allocator@K@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$deque@KV?$allocator@K@std@@@std@@QAEXXZ PROC ; std::deque<unsigned long,std::allocator<unsigned long> >::pop_back, COMDAT
; _this$ = ecx

; 1514 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1515 : 		if (empty())
; 1516 : 			{
; 1517 : 			_DEBUG_ERROR("deque empty before pop");
; 1518 : 			}
; 1519 : 		else
; 1520 : 			{	// something to erase, do it
; 1521 : 			size_type _Newoff = this->_Myoff() + this->_Mysize() - 1;
; 1522 : 			_Orphan_off(_Newoff);
; 1523 : 			size_type _Block = this->_Getblock(_Newoff);
; 1524 : 			this->_Getal().destroy(
; 1525 : 				_Unfancy(this->_Map()[_Block] + _Newoff % _DEQUESIZ));
; 1526 : 			if (--this->_Mysize() == 0)
; 1527 : 				this->_Myoff() = 0;
; 1528 : 			}
; 1529 : 
; 1530 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1531 : 		size_type _Newoff = this->_Myoff() + this->_Mysize() - 1;
; 1532 : 		size_type _Block = this->_Getblock(_Newoff);
; 1533 : 		this->_Getal().destroy(
; 1534 : 			_Unfancy(this->_Map()[_Block] + _Newoff % _DEQUESIZ));
; 1535 : 		if (--this->_Mysize() == 0)

	add	DWORD PTR [ecx+16], -1
	jne	SHORT $LN2@pop_back

; 1536 : 			this->_Myoff() = 0;

	mov	DWORD PTR [ecx+12], 0
$LN2@pop_back:

; 1537 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1538 : 		}

	ret	0
?pop_back@?$deque@KV?$allocator@K@std@@@std@@QAEXXZ ENDP ; std::deque<unsigned long,std::allocator<unsigned long> >::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
;	COMDAT ?empty@?$deque@KV?$allocator@K@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$deque@KV?$allocator@K@std@@@std@@QBE_NXZ PROC	; std::deque<unsigned long,std::allocator<unsigned long> >::empty, COMDAT
; _this$ = ecx

; 1396 : 		{	// test if sequence is empty

	cmp	DWORD PTR [ecx+16], 0
	sete	al

; 1397 : 		return (this->_Mysize() == 0);
; 1398 : 		}

	ret	0
?empty@?$deque@KV?$allocator@K@std@@@std@@QBE_NXZ ENDP	; std::deque<unsigned long,std::allocator<unsigned long> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
;	COMDAT ??1?$deque@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$deque@KV?$allocator@K@std@@@std@@QAE@XZ PROC	; std::deque<unsigned long,std::allocator<unsigned long> >::~deque<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 1243 : 		{	// destroy the deque

	npad	2
	push	esi
	mov	esi, ecx

; 1244 : 		_Tidy();

	call	?_Tidy@?$deque@KV?$allocator@K@std@@@std@@IAEXXZ ; std::deque<unsigned long,std::allocator<unsigned long> >::_Tidy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
	push	1
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque

; 866  : 		_Myproxy() = 0;

	mov	DWORD PTR [esi], 0
	pop	esi

; 1245 : 		}

	ret	0
??1?$deque@KV?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::deque<unsigned long,std::allocator<unsigned long> >::~deque<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
;	COMDAT ??0?$deque@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$deque@KV?$allocator@K@std@@@std@@QAE@XZ PROC	; std::deque<unsigned long,std::allocator<unsigned long> >::deque<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 989  : 		{	// construct empty deque

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque

; 989  : 		{	// construct empty deque

	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 99   : 		: _Myproxy(0)

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque

; 752  : 		: _Map(),

	mov	DWORD PTR [esi+4], 0

; 753  : 		_Mapsize(0),

	mov	DWORD PTR [esi+8], 0

; 754  : 		_Myoff(0),

	mov	DWORD PTR [esi+12], 0

; 755  : 		_Mysize(0)

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN31@deque
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN99@deque:
$LN31@deque:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque

; 854  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque

; 856  : 		_Myproxy()->_Mycont = _STD addressof(_Get_data());

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax], esi

; 990  : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN98@deque:
??0?$deque@KV?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::deque<unsigned long,std::allocator<unsigned long> >::deque<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Deque_val<std::_Deque_simple_types<unsigned long> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Deque_val<std::_Deque_simple_types<unsigned long> >,1>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Deque_val<std::_Deque_simple_types<unsigned long> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Deque_val<std::_Deque_simple_types<unsigned long> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@$00@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@$00@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Deque_val<std::_Deque_simple_types<unsigned long> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 343  : 		return (_Myval2);

	mov	eax, ecx

; 344  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@$00@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Deque_val<std::_Deque_simple_types<unsigned long> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@$00@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@$00@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Deque_val<std::_Deque_simple_types<unsigned long> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 338  : 		return (_Myval2);

	mov	eax, ecx

; 339  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@$00@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Deque_val<std::_Deque_simple_types<unsigned long> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Deque_val<std::_Deque_simple_types<unsigned long> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 318  : 		return (*this);

	mov	eax, ecx

; 319  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@K@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<unsigned long> >,std::_Deque_val<std::_Deque_simple_types<unsigned long> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@QAE@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<unsigned long> >::~_Deque_val<std::_Deque_simple_types<unsigned long> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@QAE@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<unsigned long> >::~_Deque_val<std::_Deque_simple_types<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
;	COMDAT ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@QBEII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@QBEII@Z PROC ; std::_Deque_val<std::_Deque_simple_types<unsigned long> >::_Getblock, COMDAT
; _this$ = ecx

; 760  : 		{	// determine block from offset

	npad	2
	push	ebp
	mov	ebp, esp

; 761  : 			// NB: _Mapsize and _DEQUESIZ are guaranteed to be powers of 2
; 762  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR __Off$[ebp]
	dec	eax
	shr	ecx, 2
	and	eax, ecx

; 763  : 		}

	pop	ebp
	ret	4
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@QBEII@Z ENDP ; std::_Deque_val<std::_Deque_simple_types<unsigned long> >::_Getblock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
;	COMDAT ??0?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@QAE@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<unsigned long> >::_Deque_val<std::_Deque_simple_types<unsigned long> >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 99   : 		: _Myproxy(0)

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque

; 757  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	ret	0
??0?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@QAE@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<unsigned long> >::_Deque_val<std::_Deque_simple_types<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
;	COMDAT ?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Mysize, COMDAT
; _this$ = ecx

; 951  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 952  : 		}

	ret	0
?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
;	COMDAT ?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Mysize, COMDAT
; _this$ = ecx

; 946  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 947  : 		}

	ret	0
?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
;	COMDAT ?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Myoff, COMDAT
; _this$ = ecx

; 936  : 		return (_Get_data()._Myoff);

	lea	eax, DWORD PTR [ecx+12]

; 937  : 		}

	ret	0
?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Myoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
;	COMDAT ?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Mapsize, COMDAT
; _this$ = ecx

; 926  : 		return (_Get_data()._Mapsize);

	lea	eax, DWORD PTR [ecx+8]

; 927  : 		}

	ret	0
?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Mapsize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
;	COMDAT ?_Map@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAPAKXZ
_TEXT	SEGMENT
?_Map@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAPAKXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Map, COMDAT
; _this$ = ecx

; 916  : 		return (_Get_data()._Map);

	lea	eax, DWORD PTR [ecx+4]

; 917  : 		}

	ret	0
?_Map@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAPAKXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Map
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
;	COMDAT ?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Get_data, COMDAT
; _this$ = ecx

; 911  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 912  : 		}

	ret	0
?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
;	COMDAT ?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Get_data, COMDAT
; _this$ = ecx

; 906  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 907  : 		}

	ret	0
?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@K@std@@@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
;	COMDAT ?_Getal@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal, COMDAT
; _this$ = ecx

; 896  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 897  : 		}

	ret	0
?_Getal@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@K@std@@@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
;	COMDAT ?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 886  : 		_Get_data()._Orphan_all();
; 887  : 		}

	ret	0
?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
;	COMDAT ?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ
_TEXT	SEGMENT
?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Myproxy, COMDAT
; _this$ = ecx

; 876  : 		return (_Get_data()._Myproxy);

	mov	eax, ecx

; 877  : 		}

	ret	0
?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Myproxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
;	COMDAT ?_Free_proxy@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Free_proxy@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 860  : 		{	// destroy proxy

	npad	2
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
	push	1
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque

; 866  : 		_Myproxy() = 0;

	mov	DWORD PTR [esi], 0
	pop	esi

; 867  : 		}

	ret	0
?_Free_proxy@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
;	COMDAT ?_Alloc_proxy@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Alloc_proxy@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 851  : 		{	// construct proxy

	npad	2
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque

; 851  : 		{	// construct proxy

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN20@Alloc_prox
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN86@Alloc_prox:
$LN20@Alloc_prox:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque

; 854  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque

; 856  : 		_Myproxy()->_Mycont = _STD addressof(_Get_data());

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax], esi
	pop	esi

; 857  : 		}

	ret	0
$LN85@Alloc_prox:
?_Alloc_proxy@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
;	COMDAT ??1?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::~_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >, COMDAT
; _this$ = ecx

; 812  : 		{	// destroy proxy

	npad	2
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
	push	1
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque

; 866  : 		_Myproxy() = 0;

	mov	DWORD PTR [esi], 0
	pop	esi

; 813  : 		_Free_proxy();
; 814  : 		}

	ret	0
??1?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::~_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
;	COMDAT ??0?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >, COMDAT
; _this$ = ecx

; 798  : 		{	// default construct allocator

	npad	2
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 99   : 		: _Myproxy(0)

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque

; 752  : 		: _Map(),

	mov	DWORD PTR [esi+4], 0

; 753  : 		_Mapsize(0),

	mov	DWORD PTR [esi+8], 0

; 754  : 		_Myoff(0),

	mov	DWORD PTR [esi+12], 0

; 755  : 		_Mysize(0)

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN28@Deque_allo
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN95@Deque_allo:
$LN28@Deque_allo:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque

; 854  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque

; 856  : 		_Myproxy()->_Mycont = _STD addressof(_Get_data());

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax], esi

; 799  : 		_Alloc_proxy();
; 800  : 		}

	mov	eax, esi
	pop	esi
	ret	0
$LN94@Deque_allo:
??0?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\deque
;	COMDAT ?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QBEII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QBEII@Z PROC ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Getblock, COMDAT
; _this$ = ecx

; 792  : 		{	// determine block from offset

	npad	2
	push	ebp
	mov	ebp, esp

; 762  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR __Off$[ebp]
	dec	eax
	shr	ecx, 2
	and	eax, ecx

; 793  : 		return (_Get_data()._Getblock(_Off));
; 794  : 		}

	pop	ebp
	ret	4
?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@KV?$allocator@K@std@@@std@@@std@@QBEII@Z ENDP ; std::_Deque_alloc<std::_Deque_base_types<unsigned long,std::allocator<unsigned long> > >::_Getblock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAK@std@@@std@@QAEXPAPAKI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAK@std@@@std@@QAEXPAPAKI@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned long *> >::deallocate, COMDAT
; _this$ = ecx

; 1087 : 		{	// deallocate object at _Ptr, ignore size

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 1088 : 		_Mybase::deallocate(_Ptr, _Count);
; 1089 : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@PAK@std@@@std@@QAEXPAPAKI@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned long *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAK@std@@QAEXPAPAKI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAK@std@@QAEXPAPAKI@Z PROC	; std::allocator<unsigned long *>::deallocate, COMDAT
; _this$ = ecx

; 822  : 		{	// deallocate object at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 824  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@PAK@std@@QAEXPAPAKI@Z ENDP	; std::allocator<unsigned long *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKI@Z PROC ; std::_Wrap_alloc<std::allocator<unsigned long> >::deallocate, COMDAT
; _this$ = ecx

; 1087 : 		{	// deallocate object at _Ptr, ignore size

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 1088 : 		_Mybase::deallocate(_Ptr, _Count);
; 1089 : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAEXPAKI@Z ENDP ; std::_Wrap_alloc<std::allocator<unsigned long> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<unsigned long> >::_Wrap_alloc<std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 1038 : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<unsigned long> >::_Wrap_alloc<std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$allocator@K@std@@QAEXPAKI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@K@std@@QAEXPAKI@Z PROC		; std::allocator<unsigned long>::deallocate, COMDAT
; _this$ = ecx

; 822  : 		{	// deallocate object at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 824  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@K@std@@QAEXPAKI@Z ENDP		; std::allocator<unsigned long>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@K@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@K@std@@QAE@XZ PROC			; std::allocator<unsigned long>::allocator<unsigned long>, COMDAT
; _this$ = ecx

; 803  : 		{	// construct default allocator (do nothing)
; 804  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@K@std@@QAE@XZ ENDP			; std::allocator<unsigned long>::allocator<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ??$static_cast_p2p@X$$A6GJIABU_GUID@@PAPAX@Z@@YAPAPAXPAP6GJIABU_GUID@@PAPAX@Z@Z
_TEXT	SEGMENT
_p2p$ = 8						; size = 4
??$static_cast_p2p@X$$A6GJIABU_GUID@@PAPAX@Z@@YAPAPAXPAP6GJIABU_GUID@@PAPAX@Z@Z PROC ; static_cast_p2p<void,long __stdcall(unsigned int,_GUID const &,void * *)>, COMDAT

; 50   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 51   :       return static_cast <T **> (

	mov	eax, DWORD PTR _p2p$[ebp]

; 52   :                static_cast <T*>   ( p2p )
; 53   :                                 );
; 54   :     };

	pop	ebp
	ret	0
??$static_cast_p2p@X$$A6GJIABU_GUID@@PAPAX@Z@@YAPAPAXPAP6GJIABU_GUID@@PAPAX@Z@Z ENDP ; static_cast_p2p<void,long __stdcall(unsigned int,_GUID const &,void * *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ??$static_cast_p2p@X$$A6GJABU_GUID@@PAPAX@Z@@YAPAPAXPAP6GJABU_GUID@@PAPAX@Z@Z
_TEXT	SEGMENT
_p2p$ = 8						; size = 4
??$static_cast_p2p@X$$A6GJABU_GUID@@PAPAX@Z@@YAPAPAXPAP6GJABU_GUID@@PAPAX@Z@Z PROC ; static_cast_p2p<void,long __stdcall(_GUID const &,void * *)>, COMDAT

; 50   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 51   :       return static_cast <T **> (

	mov	eax, DWORD PTR _p2p$[ebp]

; 52   :                static_cast <T*>   ( p2p )
; 53   :                                 );
; 54   :     };

	pop	ebp
	ret	0
??$static_cast_p2p@X$$A6GJABU_GUID@@PAPAX@Z@@YAPAPAXPAP6GJABU_GUID@@PAPAX@Z@Z ENDP ; static_cast_p2p<void,long __stdcall(_GUID const &,void * *)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
$T2 = -40						; size = 24
$T3 = -16						; size = 4
$T4 = -16						; size = 4
$T5 = -16						; size = 4
$T6 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?SK_HookDXGI@@YGXXZ PROC				; SK_HookDXGI

; 4604 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h

; 9003 :     return (unsigned long) _InterlockedCompareExchange((volatile long*) Destination, (long) Exchange, (long) Comperand);

	mov	ecx, 1
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4604 : {

	push	-1
	push	__ehhandler$?SK_HookDXGI@@YGXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h

; 9003 :     return (unsigned long) _InterlockedCompareExchange((volatile long*) Destination, (long) Exchange, (long) Comperand);

	mov	edx, OFFSET ?hooked@?1??SK_HookDXGI@@YGXXZ@4KC
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4604 : {

	sub	esp, 28					; 0000001cH
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h

; 9003 :     return (unsigned long) _InterlockedCompareExchange((volatile long*) Destination, (long) Exchange, (long) Comperand);

	xor	eax, eax
	lock	 cmpxchg DWORD PTR [edx], ecx
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4607 :   if (InterlockedCompareExchange (&hooked, TRUE, FALSE))

	test	eax, eax
	jne	$LN3@SK_HookDXG

; 4608 :     return;
; 4609 : 
; 4610 : #ifdef _WIN64
; 4611 :   if (! config.apis.dxgi.d3d11.hook)
; 4612 :     config.apis.dxgi.d3d12.hook = false;
; 4613 : #endif
; 4614 : 
; 4615 :   if (! config.apis.dxgi.d3d11.hook)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+789, al
	je	$LN3@SK_HookDXG

; 4616 :     return;
; 4617 : 
; 4618 :   HMODULE hBackend = 
; 4619 :     (SK_GetDLLRole () & DLL_ROLE::DXGI) ? backend_dll :

	push	ebx
	push	esi
	push	edi
	call	?SK_GetDLLRole@@YG?AW4DLL_ROLE@@XZ	; SK_GetDLLRole
	test	al, 1
	je	SHORT $LN13@SK_HookDXG
	mov	edi, DWORD PTR ?backend_dll@@3PAUHINSTANCE__@@A ; backend_dll
	jmp	SHORT $LN14@SK_HookDXG
$LN13@SK_HookDXG:
	push	OFFSET $SG357884
	call	DWORD PTR __imp__GetModuleHandleW@4
	mov	edi, eax
$LN14@SK_HookDXG:

; 4620 :                                             GetModuleHandle (L"dxgi.dll");
; 4621 : 
; 4622 : 
; 4623 :   dll_log.Log (L"[   DXGI   ] Importing CreateDXGIFactory{1|2}");

	push	OFFSET $SG357885
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 4624 :   dll_log.Log (L"[   DXGI   ] ================================");

	push	OFFSET $SG357886
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 4627 :   if (! _wcsicmp (SK_GetModuleName (SK_GetDLL ()).c_str (), L"dxgi.dll"))

	call	?SK_GetDLL@@YGPAUHINSTANCE__@@XZ	; SK_GetDLL
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?SK_GetModuleName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUHINSTANCE__@@@Z ; SK_GetModuleName
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN43@SK_HookDXG
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN43@SK_HookDXG:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4627 :   if (! _wcsicmp (SK_GetModuleName (SK_GetDLL ()).c_str (), L"dxgi.dll"))

	push	OFFSET $SG357890
	push	eax
	call	DWORD PTR __imp___wcsicmp
	add	esp, 8
	test	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T2[ebp+20]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4627 :   if (! _wcsicmp (SK_GetModuleName (SK_GetDLL ()).c_str (), L"dxgi.dll"))

	sete	bl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN53@SK_HookDXG

; 3609 : 			{
; 3610 : 			pointer _Ptr = _My_data._Bx._Ptr;
; 3611 : 			auto& _Al = this->_Getal();
; 3612 : 			_Al.destroy(_STD addressof(_My_data._Bx._Ptr));
; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
	push	eax
	push	DWORD PTR $T2[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN53@SK_HookDXG:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4629 :     dll_log.Log (L"[ DXGI 1.0 ]   CreateDXGIFactory:  %ph",

	mov	esi, DWORD PTR __imp__GetProcAddress@8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR $T2[ebp+16], 0

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T2[ebp+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR $T2[ebp], ax
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4627 :   if (! _wcsicmp (SK_GetModuleName (SK_GetDLL ()).c_str (), L"dxgi.dll"))

	test	bl, bl
	je	SHORT $LN6@SK_HookDXG

; 4629 :     dll_log.Log (L"[ DXGI 1.0 ]   CreateDXGIFactory:  %ph",

	push	OFFSET $SG357891
	push	edi
	call	esi
	push	eax
	push	OFFSET $SG357892
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	mov	DWORD PTR ?CreateDXGIFactory_Import@@3P6GJABU_GUID@@PAPAX@ZA, eax ; CreateDXGIFactory_Import
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH

; 4630 :       (CreateDXGIFactory_Import =  \
; 4631 :         (CreateDXGIFactory_pfn)GetProcAddress (hBackend, "CreateDXGIFactory")));
; 4632 :     dll_log.Log (L"[ DXGI 1.1 ]   CreateDXGIFactory1: %ph",

	push	OFFSET $SG357893
	push	edi
	call	esi
	push	eax
	push	OFFSET $SG357894
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	mov	DWORD PTR ?CreateDXGIFactory1_Import@@3P6GJABU_GUID@@PAPAX@ZA, eax ; CreateDXGIFactory1_Import
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH

; 4633 :       (CreateDXGIFactory1_Import = \
; 4634 :         (CreateDXGIFactory1_pfn)GetProcAddress (hBackend, "CreateDXGIFactory1")));
; 4635 :     dll_log.Log (L"[ DXGI 1.3 ]   CreateDXGIFactory2: %ph",

	push	OFFSET $SG357895
	push	edi
	call	esi
	push	eax
	push	OFFSET $SG357896
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	mov	DWORD PTR ?CreateDXGIFactory2_Import@@3P6GJIABU_GUID@@PAPAX@ZA, eax ; CreateDXGIFactory2_Import
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH

; 4636 :       (CreateDXGIFactory2_Import = \
; 4637 :         (CreateDXGIFactory2_pfn)GetProcAddress (hBackend, "CreateDXGIFactory2")));
; 4638 :   }
; 4639 : 
; 4640 :   else

	jmp	$LN7@SK_HookDXG
$LN6@SK_HookDXG:

; 4641 :   {
; 4642 :     if (GetProcAddress (hBackend, "CreateDXGIFactory"))

	push	OFFSET $SG357898
	push	edi
	call	esi
	test	eax, eax
	je	SHORT $LN8@SK_HookDXG

; 4643 :     {
; 4644 :       SK_CreateDLLHook2 (      L"dxgi.dll",

	push	0
	push	OFFSET ?CreateDXGIFactory_Import@@3P6GJABU_GUID@@PAPAX@ZA ; CreateDXGIFactory_Import
	push	OFFSET ?CreateDXGIFactory@@YGJABU_GUID@@PAPAX@Z ; CreateDXGIFactory
	push	OFFSET $SG357899
	push	OFFSET $SG357900
	call	?SK_CreateDLLHook2@@YG?AW4MH_STATUS@@PB_WPBDPAXPAPAX3@Z ; SK_CreateDLLHook2
$LN8@SK_HookDXG:

; 4645 :                                 "CreateDXGIFactory",
; 4646 :                                  CreateDXGIFactory,
; 4647 :         static_cast_p2p <void> (&CreateDXGIFactory_Import) );
; 4648 :     }
; 4649 : 
; 4650 :     if (GetProcAddress (hBackend, "CreateDXGIFactory1"))

	push	OFFSET $SG357902
	push	edi
	call	esi
	test	eax, eax
	je	SHORT $LN9@SK_HookDXG

; 4651 :     {
; 4652 :       SK_CreateDLLHook2 (      L"dxgi.dll",

	push	0
	push	OFFSET ?CreateDXGIFactory1_Import@@3P6GJABU_GUID@@PAPAX@ZA ; CreateDXGIFactory1_Import
	push	OFFSET ?CreateDXGIFactory1@@YGJABU_GUID@@PAPAX@Z ; CreateDXGIFactory1
	push	OFFSET $SG357903
	push	OFFSET $SG357904
	call	?SK_CreateDLLHook2@@YG?AW4MH_STATUS@@PB_WPBDPAXPAPAX3@Z ; SK_CreateDLLHook2
$LN9@SK_HookDXG:

; 4653 :                                 "CreateDXGIFactory1",
; 4654 :                                  CreateDXGIFactory1,
; 4655 :         static_cast_p2p <void> (&CreateDXGIFactory1_Import) );
; 4656 :     }
; 4657 : 
; 4658 :     if (GetProcAddress (hBackend, "CreateDXGIFactory2"))

	push	OFFSET $SG357906
	push	edi
	call	esi
	test	eax, eax
	je	SHORT $LN10@SK_HookDXG

; 4659 :     {
; 4660 :       SK_CreateDLLHook2 (      L"dxgi.dll",

	push	0
	push	OFFSET ?CreateDXGIFactory2_Import@@3P6GJIABU_GUID@@PAPAX@ZA ; CreateDXGIFactory2_Import
	push	OFFSET ?CreateDXGIFactory2@@YGJIABU_GUID@@PAPAX@Z ; CreateDXGIFactory2
	push	OFFSET $SG357907
	push	OFFSET $SG357908
	call	?SK_CreateDLLHook2@@YG?AW4MH_STATUS@@PB_WPBDPAXPAPAX3@Z ; SK_CreateDLLHook2
$LN10@SK_HookDXG:

; 4661 :                                 "CreateDXGIFactory2",
; 4662 :                                  CreateDXGIFactory2,
; 4663 :         static_cast_p2p <void> (&CreateDXGIFactory2_Import) );
; 4664 :     }
; 4665 : 
; 4666 :     dll_log.Log (L"[ DXGI 1.0 ]   CreateDXGIFactory:  %ph  %s",

	mov	eax, DWORD PTR ?CreateDXGIFactory_Import@@3P6GJABU_GUID@@PAPAX@ZA ; CreateDXGIFactory_Import
	mov	edx, OFFSET $SG357910
	test	eax, eax
	mov	ecx, OFFSET $SG357909
	cmove	ecx, edx
	push	ecx
	push	eax
	push	OFFSET $SG357911
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 4667 :       (CreateDXGIFactory_Import),
; 4668 :         (CreateDXGIFactory_Import ? L"{ Hooked }" : L"" ) );
; 4669 :     dll_log.Log (L"[ DXGI 1.1 ]   CreateDXGIFactory1: %ph  %s",

	mov	eax, DWORD PTR ?CreateDXGIFactory1_Import@@3P6GJABU_GUID@@PAPAX@ZA ; CreateDXGIFactory1_Import
	mov	edx, OFFSET $SG357913
	test	eax, eax
	mov	ecx, OFFSET $SG357912
	cmove	ecx, edx
	push	ecx
	push	eax
	push	OFFSET $SG357914
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 4670 :       (CreateDXGIFactory1_Import),
; 4671 :         (CreateDXGIFactory1_Import ? L"{ Hooked }" : L"" ) );
; 4672 :     dll_log.Log (L"[ DXGI 1.3 ]   CreateDXGIFactory2: %ph  %s",

	mov	eax, DWORD PTR ?CreateDXGIFactory2_Import@@3P6GJIABU_GUID@@PAPAX@ZA ; CreateDXGIFactory2_Import
	mov	edx, OFFSET $SG357916
	test	eax, eax
	mov	ecx, OFFSET $SG357915
	cmove	ecx, edx
	push	ecx
	push	eax
	push	OFFSET $SG357917
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 48					; 00000030H
$LN7@SK_HookDXG:

; 4673 :       (CreateDXGIFactory2_Import),
; 4674 :         (CreateDXGIFactory2_Import ? L"{ Hooked }" : L"" ) );
; 4675 :   }
; 4676 : 
; 4677 :   if (CreateDXGIFactory1_Import != nullptr)

	cmp	DWORD PTR ?CreateDXGIFactory1_Import@@3P6GJABU_GUID@@PAPAX@ZA, 0 ; CreateDXGIFactory1_Import
	je	SHORT $LN11@SK_HookDXG

; 4678 :   {
; 4679 :     SK_DXGI_use_factory1 = true;

	mov	BYTE PTR ?SK_DXGI_use_factory1@@3_NA, 1	; SK_DXGI_use_factory1

; 4680 :     SK_DXGI_factory_init = true;

	mov	BYTE PTR ?SK_DXGI_factory_init@@3_NA, 1	; SK_DXGI_factory_init
$LN11@SK_HookDXG:

; 4681 :   }
; 4682 : 
; 4683 :   SK_D3D11_InitTextures ();

	call	?SK_D3D11_InitTextures@@YAXXZ		; SK_D3D11_InitTextures

; 4684 :   SK_D3D11_Init         ();

	call	?SK_D3D11_Init@@YA_NXZ			; SK_D3D11_Init

; 4685 :   SK_D3D12_Init         ();

	call	?SK_D3D12_Init@@YA_NXZ			; SK_D3D12_Init

; 4686 : 
; 4687 :   SK_ICommandProcessor* pCommandProc =
; 4688 :     SK_GetCommandProcessor ();

	call	?SK_GetCommandProcessor@@YGPAUSK_ICommandProcessor@@XZ ; SK_GetCommandProcessor

; 4689 : 
; 4690 :   pCommandProc->AddVariable ( "PresentationInterval",

	push	20					; 00000014H
	mov	esi, eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN15@SK_HookDXG
	push	0
	push	OFFSET ?config@@3Usk_config_t@@A+404
	mov	ecx, eax
	call	??0?$SK_IVarStub@H@@QAE@PAHPAUSK_IVariableListener@@@Z ; SK_IVarStub<int>::SK_IVarStub<int>
	mov	ecx, eax
	jmp	SHORT $LN16@SK_HookDXG
$LN15@SK_HookDXG:
	xor	ecx, ecx
$LN16@SK_HookDXG:
	mov	eax, DWORD PTR [esi]
	push	ecx
	push	OFFSET $SG357920
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	DWORD PTR [eax+20]

; 4691 :           new SK_IVarStub <int> (&config.render.framerate.present_interval));
; 4692 :   pCommandProc->AddVariable ( "PreRenderLimit",

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	eax, eax
	je	SHORT $LN17@SK_HookDXG
	push	0
	push	OFFSET ?config@@3Usk_config_t@@A+400
	mov	ecx, eax
	call	??0?$SK_IVarStub@H@@QAE@PAHPAUSK_IVariableListener@@@Z ; SK_IVarStub<int>::SK_IVarStub<int>
	mov	ecx, eax
	jmp	SHORT $LN18@SK_HookDXG
$LN17@SK_HookDXG:
	xor	ecx, ecx
$LN18@SK_HookDXG:
	mov	eax, DWORD PTR [esi]
	push	ecx
	push	OFFSET $SG357922
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	DWORD PTR [eax+20]

; 4693 :           new SK_IVarStub <int> (&config.render.framerate.pre_render_limit));
; 4694 :   pCommandProc->AddVariable ( "BufferCount",

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	test	eax, eax
	je	SHORT $LN19@SK_HookDXG
	push	0
	push	OFFSET ?config@@3Usk_config_t@@A+408
	mov	ecx, eax
	call	??0?$SK_IVarStub@H@@QAE@PAHPAUSK_IVariableListener@@@Z ; SK_IVarStub<int>::SK_IVarStub<int>
	mov	ecx, eax
	jmp	SHORT $LN20@SK_HookDXG
$LN19@SK_HookDXG:
	xor	ecx, ecx
$LN20@SK_HookDXG:
	mov	eax, DWORD PTR [esi]
	push	ecx
	push	OFFSET $SG357924
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	DWORD PTR [eax+20]

; 4695 :           new SK_IVarStub <int> (&config.render.framerate.buffer_count));
; 4696 :   pCommandProc->AddVariable ( "UseFlipDiscard",

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	test	eax, eax
	je	SHORT $LN21@SK_HookDXG
	push	0
	push	OFFSET ?config@@3Usk_config_t@@A+416
	mov	ecx, eax
	call	??0?$SK_IVarStub@_N@@QAE@PA_NPAUSK_IVariableListener@@@Z ; SK_IVarStub<bool>::SK_IVarStub<bool>
	mov	ecx, eax
	jmp	SHORT $LN22@SK_HookDXG
$LN21@SK_HookDXG:
	xor	ecx, ecx
$LN22@SK_HookDXG:
	mov	eax, DWORD PTR [esi]
	push	ecx
	push	OFFSET $SG357926
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	DWORD PTR [eax+20]

; 4697 :           new SK_IVarStub <bool> (&config.render.framerate.flip_discard));
; 4698 : 
; 4699 :   SK_DXGI_BeginHooking ();

	call	?SK_DXGI_BeginHooking@@YAXXZ		; SK_DXGI_BeginHooking
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?__dxgi_ready@@3JC	; __dxgi_ready
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4701 :   while (! ReadAcquire (&__dxgi_ready))

	test	eax, eax
	jne	SHORT $LN92@SK_HookDXG
	mov	esi, DWORD PTR __imp__SleepEx@8
$LL2@SK_HookDXG:

; 4702 :     SleepEx (100UL, TRUE);

	push	1
	push	100					; 00000064H
	call	esi
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?__dxgi_ready@@3JC	; __dxgi_ready
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4701 :   while (! ReadAcquire (&__dxgi_ready))

	test	eax, eax
	je	SHORT $LL2@SK_HookDXG
$LN92@SK_HookDXG:
	pop	edi
	pop	esi
	pop	ebx
$LN3@SK_HookDXG:

; 4703 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_HookDXGI@@YGXXZ$1:
	push	20					; 00000014H
	mov	eax, DWORD PTR $T6[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?SK_HookDXGI@@YGXXZ$2:
	push	20					; 00000014H
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?SK_HookDXGI@@YGXXZ$3:
	push	20					; 00000014H
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?SK_HookDXGI@@YGXXZ$4:
	push	20					; 00000014H
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?SK_HookDXGI@@YGXXZ:
	mov	eax, OFFSET __ehfuncinfo$?SK_HookDXGI@@YGXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_HookDXGI@@YGXXZ ENDP				; SK_HookDXGI
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_dev_mode$ = -220					; size = 220
_lpDevMode$ = 8						; size = 4
_dwFlags$ = 12						; size = 4
?ChangeDisplaySettingsA_Detour@@YGJPAU_devicemodeA@@K@Z PROC ; ChangeDisplaySettingsA_Detour

; 4577 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH

; 4578 :   static bool called = false;
; 4579 : 
; 4580 :   DEVMODEW dev_mode;
; 4581 :   dev_mode.dmSize = sizeof (DEVMODEW);

	mov	eax, 220				; 000000dcH
	mov	WORD PTR _dev_mode$[ebp+68], ax

; 4582 : 
; 4583 :   EnumDisplaySettings (nullptr, 0, &dev_mode);

	lea	eax, DWORD PTR _dev_mode$[ebp]
	push	eax
	push	0
	push	0
	call	DWORD PTR __imp__EnumDisplaySettingsW@12

; 4584 : 
; 4585 :   if (dwFlags != CDS_TEST)

	cmp	DWORD PTR _dwFlags$[ebp], 2
	je	SHORT $LN2@ChangeDisp

; 4586 :   {
; 4587 :     if (called)

	cmp	BYTE PTR ?called@?1??ChangeDisplaySettingsA_Detour@@YGJPAU_devicemodeA@@K@Z@4_NA, 0
	je	SHORT $LN4@ChangeDisp

; 4588 :       ChangeDisplaySettingsA_Original (nullptr, CDS_RESET);

	push	1073741824				; 40000000H
	push	0
	call	DWORD PTR ?ChangeDisplaySettingsA_Original@@3P6GJPAU_devicemodeA@@K@ZA ; ChangeDisplaySettingsA_Original
$LN4@ChangeDisp:

; 4589 : 
; 4590 :     called = true;
; 4591 : 
; 4592 :     return ChangeDisplaySettingsA_Original (lpDevMode, CDS_FULLSCREEN);

	push	4

; 4593 :   }
; 4594 : 
; 4595 :   else
; 4596 :     return ChangeDisplaySettingsA_Original (lpDevMode, dwFlags);

	push	DWORD PTR _lpDevMode$[ebp]
	mov	BYTE PTR ?called@?1??ChangeDisplaySettingsA_Detour@@YGJPAU_devicemodeA@@K@Z@4_NA, 1
	call	DWORD PTR ?ChangeDisplaySettingsA_Original@@3P6GJPAU_devicemodeA@@K@ZA ; ChangeDisplaySettingsA_Original

; 4597 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN2@ChangeDisp:

; 4593 :   }
; 4594 : 
; 4595 :   else
; 4596 :     return ChangeDisplaySettingsA_Original (lpDevMode, dwFlags);

	push	2
	push	DWORD PTR _lpDevMode$[ebp]
	call	DWORD PTR ?ChangeDisplaySettingsA_Original@@3P6GJPAU_devicemodeA@@K@ZA ; ChangeDisplaySettingsA_Original

; 4597 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ChangeDisplaySettingsA_Detour@@YGJPAU_devicemodeA@@K@Z ENDP ; ChangeDisplaySettingsA_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_dwUnknown$ = 8						; size = 4
?DXGIReportAdapterConfiguration@@YGJK@Z PROC		; DXGIReportAdapterConfiguration

; 4560 :                    (dwUnknown) );

	npad	2
	push	ebp
	mov	ebp, esp

; 4558 : DXGI_STUB (HRESULT, DXGIReportAdapterConfiguration,

	call	?WaitForInitDXGI@@YAXXZ			; WaitForInitDXGI
	call	?WaitForInit@@YAXXZ			; WaitForInit
	cmp	DWORD PTR ?_default_impl@?1??DXGIReportAdapterConfiguration@@YGJK@Z@4P6GJK@ZA, 0
	jne	SHORT $LN3@DXGIReport
	push	DWORD PTR ?szName@?5??DXGIReportAdapterConfiguration@@YGJK@Z@4PBDB
	push	DWORD PTR ?backend_dll@@3PAUHINSTANCE__@@A ; backend_dll
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR ?_default_impl@?1??DXGIReportAdapterConfiguration@@YGJK@Z@4P6GJK@ZA, eax
	test	eax, eax
	jne	SHORT $LN3@DXGIReport
	push	OFFSET $SG357748
	push	OFFSET $SG357749
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
	mov	eax, -2147467263			; 80004001H
	pop	ebp
	ret	4
$LN3@DXGIReport:
	call	DWORD PTR __imp__GetCurrentThreadId@0
	push	eax
	push	OFFSET $SG357750
	push	OFFSET $SG357751
	push	OFFSET $SG357752
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 20					; 00000014H
	pop	ebp
	jmp	DWORD PTR ?_default_impl@?1??DXGIReportAdapterConfiguration@@YGJK@Z@4P6GJK@ZA
?DXGIReportAdapterConfiguration@@YGJK@Z ENDP		; DXGIReportAdapterConfiguration
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_szPassThrough$ = 8					; size = 4
?DXGIDumpJournal@@YGXPBD@Z PROC				; DXGIDumpJournal

; 4557 :                          (szPassThrough) );

	npad	2
	push	ebp
	mov	ebp, esp

; 4555 : DXGI_STUB_ (             DXGIDumpJournal,

	call	?WaitForInitDXGI@@YAXXZ			; WaitForInitDXGI
	call	?WaitForInit@@YAXXZ			; WaitForInit
	cmp	DWORD PTR ?_default_impl@?1??DXGIDumpJournal@@YGXPBD@Z@4P6GX0@ZA, 0
	jne	SHORT $LN3@DXGIDumpJo
	push	DWORD PTR ?szName@?5??DXGIDumpJournal@@YGXPBD@Z@4PBDB
	push	DWORD PTR ?backend_dll@@3PAUHINSTANCE__@@A ; backend_dll
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR ?_default_impl@?1??DXGIDumpJournal@@YGXPBD@Z@4P6GX0@ZA, eax
	test	eax, eax
	jne	SHORT $LN3@DXGIDumpJo
	push	OFFSET $SG357728
	push	OFFSET $SG357729
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
	pop	ebp
	ret	4
$LN3@DXGIDumpJo:
	call	DWORD PTR __imp__GetCurrentThreadId@0
	push	eax
	push	OFFSET $SG357730
	push	OFFSET $SG357731
	push	OFFSET $SG357732
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 20					; 00000014H
	pop	ebp
	jmp	DWORD PTR ?_default_impl@?1??DXGIDumpJournal@@YGXPBD@Z@4P6GX0@ZA
?DXGIDumpJournal@@YGXPBD@Z ENDP				; DXGIDumpJournal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_pLayers$ = 8						; size = 4
_NumLayers$ = 12					; size = 4
?DXGID3D10RegisterLayers@@YGJPBXI@Z PROC		; DXGID3D10RegisterLayers

; 4553 :   (pLayers, NumLayers))

	npad	2
	push	ebp
	mov	ebp, esp

; 4551 : DXGI_STUB (HRESULT, DXGID3D10RegisterLayers,

	call	?WaitForInitDXGI@@YAXXZ			; WaitForInitDXGI
	call	?WaitForInit@@YAXXZ			; WaitForInit
	cmp	DWORD PTR ?_default_impl@?1??DXGID3D10RegisterLayers@@YGJPBXI@Z@4P6GJ0I@ZA, 0
	jne	SHORT $LN3@DXGID3D10R
	push	DWORD PTR ?szName@?5??DXGID3D10RegisterLayers@@YGJPBXI@Z@4PBDB
	push	DWORD PTR ?backend_dll@@3PAUHINSTANCE__@@A ; backend_dll
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR ?_default_impl@?1??DXGID3D10RegisterLayers@@YGJPBXI@Z@4P6GJ0I@ZA, eax
	test	eax, eax
	jne	SHORT $LN3@DXGID3D10R
	push	OFFSET $SG357710
	push	OFFSET $SG357711
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
	mov	eax, -2147467263			; 80004001H
	pop	ebp
	ret	8
$LN3@DXGID3D10R:
	call	DWORD PTR __imp__GetCurrentThreadId@0
	push	eax
	push	OFFSET $SG357712
	push	OFFSET $SG357713
	push	OFFSET $SG357714
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 20					; 00000014H
	pop	ebp
	jmp	DWORD PTR ?_default_impl@?1??DXGID3D10RegisterLayers@@YGJPBXI@Z@4P6GJ0I@ZA
?DXGID3D10RegisterLayers@@YGJPBXI@Z ENDP		; DXGID3D10RegisterLayers
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_pLayers$ = 8						; size = 4
_NumLayers$ = 12					; size = 4
?DXGID3D10GetLayeredDeviceSize@@YGKPBXI@Z PROC		; DXGID3D10GetLayeredDeviceSize

; 4549 :   (pLayers, NumLayers))

	npad	2
	push	ebp
	mov	ebp, esp

; 4547 : DXGI_STUB (SIZE_T, DXGID3D10GetLayeredDeviceSize,

	call	?WaitForInitDXGI@@YAXXZ			; WaitForInitDXGI
	call	?WaitForInit@@YAXXZ			; WaitForInit
	cmp	DWORD PTR ?_default_impl@?1??DXGID3D10GetLayeredDeviceSize@@YGKPBXI@Z@4P6GK0I@ZA, 0
	jne	SHORT $LN3@DXGID3D10G
	push	DWORD PTR ?szName@?5??DXGID3D10GetLayeredDeviceSize@@YGKPBXI@Z@4PBDB
	push	DWORD PTR ?backend_dll@@3PAUHINSTANCE__@@A ; backend_dll
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR ?_default_impl@?1??DXGID3D10GetLayeredDeviceSize@@YGKPBXI@Z@4P6GK0I@ZA, eax
	test	eax, eax
	jne	SHORT $LN3@DXGID3D10G
	push	OFFSET $SG357688
	push	OFFSET $SG357689
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
	mov	eax, -2147467263			; 80004001H
	pop	ebp
	ret	8
$LN3@DXGID3D10G:
	call	DWORD PTR __imp__GetCurrentThreadId@0
	push	eax
	push	OFFSET $SG357690
	push	OFFSET $SG357691
	push	OFFSET $SG357692
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 20					; 00000014H
	pop	ebp
	jmp	DWORD PTR ?_default_impl@?1??DXGID3D10GetLayeredDeviceSize@@YGKPBXI@Z@4P6GK0I@ZA
?DXGID3D10GetLayeredDeviceSize@@YGKPBXI@Z ENDP		; DXGID3D10GetLayeredDeviceSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_Unknown$ = 8						; size = 20
?DXGID3D10CreateLayeredDevice@@YGJUUNKNOWN5@@@Z PROC	; DXGID3D10CreateLayeredDevice

; 4545 :   (Unknown))

	npad	2
	push	ebp
	mov	ebp, esp

; 4543 : DXGI_STUB (HRESULT, DXGID3D10CreateLayeredDevice,

	call	?WaitForInitDXGI@@YAXXZ			; WaitForInitDXGI
	call	?WaitForInit@@YAXXZ			; WaitForInit
	cmp	DWORD PTR ?_default_impl@?1??DXGID3D10CreateLayeredDevice@@YGJUUNKNOWN5@@@Z@4P6GJ0@ZA, 0
	jne	SHORT $LN3@DXGID3D10C
	push	DWORD PTR ?szName@?5??DXGID3D10CreateLayeredDevice@@YGJUUNKNOWN5@@@Z@4PBDB
	push	DWORD PTR ?backend_dll@@3PAUHINSTANCE__@@A ; backend_dll
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR ?_default_impl@?1??DXGID3D10CreateLayeredDevice@@YGJUUNKNOWN5@@@Z@4P6GJ0@ZA, eax
	test	eax, eax
	jne	SHORT $LN3@DXGID3D10C
	push	OFFSET $SG357666
	push	OFFSET $SG357667
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
	mov	eax, -2147467263			; 80004001H
	pop	ebp
	ret	20					; 00000014H
$LN3@DXGID3D10C:
	call	DWORD PTR __imp__GetCurrentThreadId@0
	push	eax
	push	OFFSET $SG357668
	push	OFFSET $SG357669
	push	OFFSET $SG357670
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	movups	xmm0, XMMWORD PTR _Unknown$[ebp]
	mov	eax, DWORD PTR _Unknown$[ebp+16]
	mov	ecx, esp
	movups	XMMWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+16], eax
	call	DWORD PTR ?_default_impl@?1??DXGID3D10CreateLayeredDevice@@YGJUUNKNOWN5@@@Z@4P6GJ0@ZA
	pop	ebp
	ret	20					; 00000014H
?DXGID3D10CreateLayeredDevice@@YGJUUNKNOWN5@@@Z ENDP	; DXGID3D10CreateLayeredDevice
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_hModule$ = 8						; size = 4
_pFactory$ = 12						; size = 4
_pAdapter$ = 16						; size = 4
_Flags$ = 20						; size = 4
_unknown$ = 24						; size = 4
_ppDevice$ = 28						; size = 4
?DXGID3D10CreateDevice@@YGJPAUHINSTANCE__@@PAUIDXGIFactory@@PAUIDXGIAdapter@@IPAX3@Z PROC ; DXGID3D10CreateDevice

; 4537 :   (hModule, pFactory, pAdapter, Flags, unknown, ppDevice));

	npad	2
	push	ebp
	mov	ebp, esp

; 4534 : DXGI_STUB (HRESULT, DXGID3D10CreateDevice,

	call	?WaitForInitDXGI@@YAXXZ			; WaitForInitDXGI
	call	?WaitForInit@@YAXXZ			; WaitForInit
	cmp	DWORD PTR ?_default_impl@?1??DXGID3D10CreateDevice@@YGJPAUHINSTANCE__@@PAUIDXGIFactory@@PAUIDXGIAdapter@@IPAX3@Z@4P6GJ012I33@ZA, 0
	jne	SHORT $LN3@DXGID3D10C
	push	DWORD PTR ?szName@?5??DXGID3D10CreateDevice@@YGJPAUHINSTANCE__@@PAUIDXGIFactory@@PAUIDXGIAdapter@@IPAX3@Z@4PBDB
	push	DWORD PTR ?backend_dll@@3PAUHINSTANCE__@@A ; backend_dll
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR ?_default_impl@?1??DXGID3D10CreateDevice@@YGJPAUHINSTANCE__@@PAUIDXGIFactory@@PAUIDXGIAdapter@@IPAX3@Z@4P6GJ012I33@ZA, eax
	test	eax, eax
	jne	SHORT $LN3@DXGID3D10C
	push	OFFSET $SG357634
	push	OFFSET $SG357635
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
	mov	eax, -2147467263			; 80004001H
	pop	ebp
	ret	24					; 00000018H
$LN3@DXGID3D10C:
	call	DWORD PTR __imp__GetCurrentThreadId@0
	push	eax
	push	OFFSET $SG357636
	push	OFFSET $SG357637
	push	OFFSET $SG357638
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 20					; 00000014H
	pop	ebp
	jmp	DWORD PTR ?_default_impl@?1??DXGID3D10CreateDevice@@YGJPAUHINSTANCE__@@PAUIDXGIFactory@@PAUIDXGIAdapter@@IPAX3@Z@4P6GJ012I33@ZA
?DXGID3D10CreateDevice@@YGJPAUHINSTANCE__@@PAUIDXGIFactory@@PAUIDXGIAdapter@@IPAX3@Z ENDP ; DXGID3D10CreateDevice
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
$T2 = -60						; size = 24
_iname$ = -36						; size = 24
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_Flags$ = 8						; size = 4
_riid$ = 12						; size = 4
_ppFactory$ = 16					; size = 4
?CreateDXGIFactory2@@YGJIABU_GUID@@PAPAX@Z PROC		; CreateDXGIFactory2

; 4505 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CreateDXGIFactory2@@YGJIABU_GUID@@PAPAX@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi

; 4506 :   SK_DXGI_use_factory1 = true;
; 4507 : 
; 4508 :   std::wstring iname = SK_GetDXGIFactoryInterfaceEx  (riid);

	mov	edi, DWORD PTR _riid$[ebp]
	lea	eax, DWORD PTR _iname$[ebp]
	push	edi
	push	eax
	mov	BYTE PTR ?SK_DXGI_use_factory1@@3_NA, 1	; SK_DXGI_use_factory1
	call	?SK_GetDXGIFactoryInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z ; SK_GetDXGIFactoryInterfaceEx

; 4513 :   DXGI_LOG_CALL_3 ( L"                    CreateDXGIFactory2       ", L"0x%04X, %s, %ph",

	push	8192					; 00002000H
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??_U@YAPAXI@Z				; operator new[]
	mov	esi, eax
	add	esp, 12					; 0000000cH
	test	esi, esi
	je	SHORT $LN6@CreateDXGI
	push	8192					; 00002000H
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN7@CreateDXGI
$LN6@CreateDXGI:
	xor	esi, esi
$LN7@CreateDXGI:
	push	ebx
	lea	ebx, DWORD PTR [esi+2048]
	test	esi, esi
	je	$LN2@CreateDXGI
	push	OFFSET $SG357598
	push	OFFSET $SG357599
	push	esi
	call	__swprintf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR _iname$[ebp+20], 8

; 1621 : 		return (_Large_string_engaged()

	lea	eax, DWORD PTR _iname$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4513 :   DXGI_LOG_CALL_3 ( L"                    CreateDXGIFactory2       ", L"0x%04X, %s, %ph",

	push	DWORD PTR _ppFactory$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	cmovae	eax, DWORD PTR _iname$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4513 :   DXGI_LOG_CALL_3 ( L"                    CreateDXGIFactory2       ", L"0x%04X, %s, %ph",

	push	eax
	push	DWORD PTR _Flags$[ebp]
	push	OFFSET $SG357600
	push	ebx
	call	__swprintf
	push	ebx
	push	esi
	lea	eax, DWORD PTR [ebx+2048]
	push	OFFSET $SG357601
	push	eax
	call	__swprintf
	mov	eax, DWORD PTR __$ReturnAddr$[ebp]
	add	esp, 48					; 00000030H
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?SK_SummarizeCaller@@YG?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAX@Z ; SK_SummarizeCaller
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN43@CreateDXGI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN43@CreateDXGI:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4513 :   DXGI_LOG_CALL_3 ( L"                    CreateDXGIFactory2       ", L"0x%04X, %s, %ph",

	push	eax
	lea	eax, DWORD PTR [ebx+2048]
	push	eax
	push	OFFSET $SG357602
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T2[ebp+20]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4513 :   DXGI_LOG_CALL_3 ( L"                    CreateDXGIFactory2       ", L"0x%04X, %s, %ph",

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN53@CreateDXGI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T2[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN53@CreateDXGI:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4513 :   DXGI_LOG_CALL_3 ( L"                    CreateDXGIFactory2       ", L"0x%04X, %s, %ph",

	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@CreateDXGI:
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	esi, DWORD PTR ?SK_D3D11_init_tid@@3JC	; SK_D3D11_init_tid
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4516 :   if ( ReadAcquire (&SK_D3D11_init_tid)  != static_cast <LONG> (GetCurrentThreadId ()) &&

	mov	ebx, DWORD PTR __imp__GetCurrentThreadId@0
	call	ebx
	cmp	esi, eax
	je	SHORT $LN3@CreateDXGI
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	esi, DWORD PTR ?SK_D3D11_ansel_tid@@3JC	; SK_D3D11_ansel_tid
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4516 :   if ( ReadAcquire (&SK_D3D11_init_tid)  != static_cast <LONG> (GetCurrentThreadId ()) &&

	call	ebx
	cmp	esi, eax
	je	SHORT $LN3@CreateDXGI

; 4517 :        ReadAcquire (&SK_D3D11_ansel_tid) != static_cast <LONG> (GetCurrentThreadId ()) )
; 4518 :     WaitForInitDXGI ();

	call	?WaitForInitDXGI@@YAXXZ			; WaitForInitDXGI
$LN3@CreateDXGI:

; 4519 : 
; 4520 :   SK_DXGI_factory_init = true;
; 4521 : 
; 4522 :   // Windows 7 does not have this function -- wrap it with CreateDXGIFactory1
; 4523 :   if (CreateDXGIFactory2_Import == nullptr)

	mov	eax, DWORD PTR ?CreateDXGIFactory2_Import@@3P6GJIABU_GUID@@PAPAX@ZA ; CreateDXGIFactory2_Import
	mov	BYTE PTR ?SK_DXGI_factory_init@@3_NA, 1	; SK_DXGI_factory_init
	pop	ebx
	test	eax, eax
	jne	SHORT $LN4@CreateDXGI

; 4524 :   {
; 4525 :     dll_log.Log (L"[   DXGI   ]  >> Falling back to CreateDXGIFactory1 on Vista/7...");

	push	OFFSET $SG357605
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 4526 :     return CreateDXGIFactory1 (riid, ppFactory);

	mov	ecx, DWORD PTR _ppFactory$[ebp]
	add	esp, 8
	push	ecx
	push	edi
	call	?CreateDXGIFactory1@@YGJABU_GUID@@PAPAX@Z ; CreateDXGIFactory1
	mov	esi, eax
	jmp	SHORT $LN10@CreateDXGI
$LN4@CreateDXGI:

; 4527 :   }
; 4528 : 
; 4529 :   HRESULT    ret;
; 4530 :   DXGI_CALL (ret, CreateDXGIFactory2_Import (Flags, riid, ppFactory));

	mov	ecx, DWORD PTR _ppFactory$[ebp]
	push	ecx
	push	edi
	push	DWORD PTR _Flags$[ebp]
	call	eax
	mov	esi, eax
	push	esi
	call	?SK_DescribeHRESULT@@YGPB_WJ@Z		; SK_DescribeHRESULT
	push	eax
	push	OFFSET $SG357607
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
$LN10@CreateDXGI:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR _iname$[ebp+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN113@CreateDXGI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR _iname$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN113@CreateDXGI:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4532 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?CreateDXGIFactory2@@YGJIABU_GUID@@PAPAX@Z$0:
	lea	ecx, DWORD PTR _iname$[ebp]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__ehhandler$?CreateDXGIFactory2@@YGJIABU_GUID@@PAPAX@Z:
	mov	eax, OFFSET __ehfuncinfo$?CreateDXGIFactory2@@YGJIABU_GUID@@PAPAX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CreateDXGIFactory2@@YGJIABU_GUID@@PAPAX@Z ENDP		; CreateDXGIFactory2
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
$T2 = -60						; size = 24
_iname$ = -36						; size = 24
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_wszFullyFormatted$1$ = 8				; size = 4
_This$ = 8						; size = 4
_Adapter$ = 12						; size = 4
_ppAdapter$ = 16					; size = 4
?EnumAdapters_Override@@YGJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@@Z PROC ; EnumAdapters_Override

; 4395 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?EnumAdapters_Override@@YGJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 48					; 00000030H
	push	ebx

; 4396 :   std::wstring iname = SK_GetDXGIFactoryInterface    (This);

	mov	ebx, DWORD PTR _This$[ebp]
	lea	eax, DWORD PTR _iname$[ebp]
	push	esi
	push	edi
	push	ebx
	push	eax
	call	?SK_GetDXGIFactoryInterface@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUIUnknown@@@Z ; SK_GetDXGIFactoryInterface

; 4398 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"EnumAdapters         ",

	push	8192					; 00002000H
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??_U@YAPAXI@Z				; operator new[]
	mov	esi, eax
	add	esp, 12					; 0000000cH
	test	esi, esi
	je	SHORT $LN5@EnumAdapte
	push	8192					; 00002000H
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN6@EnumAdapte
$LN5@EnumAdapte:
	xor	esi, esi
$LN6@EnumAdapte:
	mov	edi, DWORD PTR _ppAdapter$[ebp]
	test	esi, esi
	je	$LN2@EnumAdapte
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR _iname$[ebp+20], 8

; 1621 : 		return (_Large_string_engaged()

	lea	eax, DWORD PTR _iname$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4398 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"EnumAdapters         ",

	push	OFFSET $SG357507
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	cmovae	eax, DWORD PTR _iname$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4398 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"EnumAdapters         ",

	push	eax
	push	OFFSET $SG357508
	push	esi
	call	__swprintf
	mov	eax, DWORD PTR _Adapter$[ebp]
	push	edi
	push	eax
	push	ebx
	lea	eax, DWORD PTR [esi+2048]
	push	OFFSET $SG357509
	push	eax
	call	__swprintf
	lea	eax, DWORD PTR [esi+2048]
	push	eax
	push	esi
	lea	ecx, DWORD PTR [eax+2048]
	push	OFFSET $SG357510
	push	ecx
	mov	DWORD PTR _wszFullyFormatted$1$[ebp], ecx
	call	__swprintf
	mov	eax, DWORD PTR __$ReturnAddr$[ebp]
	add	esp, 52					; 00000034H
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?SK_SummarizeCaller@@YG?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAX@Z ; SK_SummarizeCaller
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN42@EnumAdapte
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN42@EnumAdapte:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4398 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"EnumAdapters         ",

	push	eax
	push	DWORD PTR _wszFullyFormatted$1$[ebp]
	push	OFFSET $SG357511
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T2[ebp+20]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4398 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"EnumAdapters         ",

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN52@EnumAdapte
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T2[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN52@EnumAdapte:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4398 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"EnumAdapters         ",

	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@EnumAdapte:

; 4399 :                        L"%ph, %u, %ph",
; 4400 :                          This, Adapter, ppAdapter );
; 4401 : 
; 4402 :   HRESULT ret;
; 4403 :   DXGI_CALL (ret, EnumAdapters_Original (This, Adapter, ppAdapter));

	push	edi
	push	DWORD PTR _Adapter$[ebp]
	push	ebx
	call	DWORD PTR ?EnumAdapters_Original@@3P6GJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@@ZA ; EnumAdapters_Original
	mov	esi, eax
	push	esi
	call	?SK_DescribeHRESULT@@YGPB_WJ@Z		; SK_DescribeHRESULT
	push	eax
	push	OFFSET $SG357512
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH

; 4404 : 
; 4405 : #if 0
; 4406 :   // For games that try to enumerate all adapters until the API returns failure,
; 4407 :   //   only override valid adapters...
; 4408 :   if ( SUCCEEDED (ret) &&
; 4409 :        SK_DXGI_preferred_adapter != -1 &&
; 4410 :        SK_DXGI_preferred_adapter != Adapter )
; 4411 :   {
; 4412 :     IDXGIAdapter* pAdapter = nullptr;
; 4413 : 
; 4414 :     if (SUCCEEDED (EnumAdapters_Original (This, SK_DXGI_preferred_adapter, &pAdapter)))
; 4415 :     {
; 4416 :       dll_log.Log ( L"[   DXGI   ] (Reported values reflect user override: DXGI Adapter %lu -> %lu)",
; 4417 :                       Adapter, SK_DXGI_preferred_adapter );
; 4418 :       Adapter = SK_DXGI_preferred_adapter;
; 4419 : 
; 4420 :       if (pAdapter != nullptr)
; 4421 :         pAdapter->Release ();
; 4422 :     }
; 4423 : 
; 4424 :     ret = EnumAdapters_Original (This, Adapter, ppAdapter);
; 4425 :   }
; 4426 : #endif
; 4427 : 
; 4428 :   if (SUCCEEDED (ret) && ppAdapter != nullptr && (*ppAdapter) != nullptr)

	test	esi, esi
	js	SHORT $LN3@EnumAdapte
	test	edi, edi
	je	SHORT $LN3@EnumAdapte
	cmp	DWORD PTR [edi], 0
	je	SHORT $LN3@EnumAdapte

; 4429 :   {
; 4430 :     return EnumAdapters_Common ( This, Adapter, ppAdapter,

	push	DWORD PTR ?EnumAdapters_Original@@3P6GJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@@ZA ; EnumAdapters_Original
	mov	eax, DWORD PTR _Adapter$[ebp]
	push	edi
	push	eax
	push	ebx
	call	?EnumAdapters_Common@@YGJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@P6GJ0I1@Z@Z ; EnumAdapters_Common
	mov	esi, eax
$LN3@EnumAdapte:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR _iname$[ebp+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN108@EnumAdapte
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR _iname$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN108@EnumAdapte:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4435 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?EnumAdapters_Override@@YGJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@@Z$0:
	lea	ecx, DWORD PTR _iname$[ebp]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__ehhandler$?EnumAdapters_Override@@YGJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?EnumAdapters_Override@@YGJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?EnumAdapters_Override@@YGJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@@Z ENDP ; EnumAdapters_Override
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
$T2 = -60						; size = 24
_iname$ = -36						; size = 24
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_wszFullyFormatted$1$ = 8				; size = 4
_This$ = 8						; size = 4
_Adapter$ = 12						; size = 4
_ppAdapter$ = 16					; size = 4
?EnumAdapters1_Override@@YGJPAUIDXGIFactory1@@IPAPAUIDXGIAdapter1@@@Z PROC ; EnumAdapters1_Override

; 4351 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?EnumAdapters1_Override@@YGJPAUIDXGIFactory1@@IPAPAUIDXGIAdapter1@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 48					; 00000030H
	push	ebx

; 4352 :   std::wstring iname = SK_GetDXGIFactoryInterface    (This);

	mov	ebx, DWORD PTR _This$[ebp]
	lea	eax, DWORD PTR _iname$[ebp]
	push	esi
	push	edi
	push	ebx
	push	eax
	call	?SK_GetDXGIFactoryInterface@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUIUnknown@@@Z ; SK_GetDXGIFactoryInterface

; 4354 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"EnumAdapters1         ",

	push	8192					; 00002000H
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??_U@YAPAXI@Z				; operator new[]
	mov	esi, eax
	add	esp, 12					; 0000000cH
	test	esi, esi
	je	SHORT $LN5@EnumAdapte
	push	8192					; 00002000H
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN6@EnumAdapte
$LN5@EnumAdapte:
	xor	esi, esi
$LN6@EnumAdapte:
	mov	edi, DWORD PTR _ppAdapter$[ebp]
	test	esi, esi
	je	$LN2@EnumAdapte
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR _iname$[ebp+20], 8

; 1621 : 		return (_Large_string_engaged()

	lea	eax, DWORD PTR _iname$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4354 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"EnumAdapters1         ",

	push	OFFSET $SG357478
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	cmovae	eax, DWORD PTR _iname$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4354 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"EnumAdapters1         ",

	push	eax
	push	OFFSET $SG357479
	push	esi
	call	__swprintf
	mov	eax, DWORD PTR _Adapter$[ebp]
	push	edi
	push	eax
	push	ebx
	lea	eax, DWORD PTR [esi+2048]
	push	OFFSET $SG357480
	push	eax
	call	__swprintf
	lea	eax, DWORD PTR [esi+2048]
	push	eax
	push	esi
	lea	ecx, DWORD PTR [eax+2048]
	push	OFFSET $SG357481
	push	ecx
	mov	DWORD PTR _wszFullyFormatted$1$[ebp], ecx
	call	__swprintf
	mov	eax, DWORD PTR __$ReturnAddr$[ebp]
	add	esp, 52					; 00000034H
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?SK_SummarizeCaller@@YG?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAX@Z ; SK_SummarizeCaller
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN42@EnumAdapte
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN42@EnumAdapte:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4354 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"EnumAdapters1         ",

	push	eax
	push	DWORD PTR _wszFullyFormatted$1$[ebp]
	push	OFFSET $SG357482
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T2[ebp+20]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4354 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"EnumAdapters1         ",

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN52@EnumAdapte
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T2[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN52@EnumAdapte:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4354 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"EnumAdapters1         ",

	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@EnumAdapte:

; 4355 :                        L"%ph, %u, %ph",
; 4356 :                          This, Adapter, ppAdapter );
; 4357 : 
; 4358 :   HRESULT ret;
; 4359 :   DXGI_CALL (ret, EnumAdapters1_Original (This,Adapter,ppAdapter));

	push	edi
	push	DWORD PTR _Adapter$[ebp]
	push	ebx
	call	DWORD PTR ?EnumAdapters1_Original@@3P6GJPAUIDXGIFactory1@@IPAPAUIDXGIAdapter1@@@ZA ; EnumAdapters1_Original
	mov	esi, eax
	push	esi
	call	?SK_DescribeHRESULT@@YGPB_WJ@Z		; SK_DescribeHRESULT
	push	eax
	push	OFFSET $SG357483
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH

; 4360 : 
; 4361 : #if 0
; 4362 :   // For games that try to enumerate all adapters until the API returns failure,
; 4363 :   //   only override valid adapters...
; 4364 :   if ( SUCCEEDED (ret) &&
; 4365 :        SK_DXGI_preferred_adapter != -1 &&
; 4366 :        SK_DXGI_preferred_adapter != Adapter )
; 4367 :   {
; 4368 :     IDXGIAdapter1* pAdapter1 = nullptr;
; 4369 : 
; 4370 :     if (SUCCEEDED (EnumAdapters1_Original (This, SK_DXGI_preferred_adapter, &pAdapter1))) {
; 4371 :       dll_log.Log ( L"[   DXGI   ] (Reported values reflect user override: DXGI Adapter %lu -> %lu)",
; 4372 :                       Adapter, SK_DXGI_preferred_adapter );
; 4373 :       Adapter = SK_DXGI_preferred_adapter;
; 4374 : 
; 4375 :       if (pAdapter1 != nullptr)
; 4376 :         pAdapter1->Release ();
; 4377 :     }
; 4378 : 
; 4379 :     ret = EnumAdapters1_Original (This, Adapter, ppAdapter);
; 4380 :   }
; 4381 : #endif
; 4382 : 
; 4383 :   if (SUCCEEDED (ret) && ppAdapter != nullptr && (*ppAdapter) != nullptr) {

	test	esi, esi
	js	SHORT $LN3@EnumAdapte
	test	edi, edi
	je	SHORT $LN3@EnumAdapte
	cmp	DWORD PTR [edi], 0
	je	SHORT $LN3@EnumAdapte

; 4384 :     return EnumAdapters_Common (This, Adapter, reinterpret_cast <IDXGIAdapter **>  (ppAdapter),

	push	DWORD PTR ?EnumAdapters1_Original@@3P6GJPAUIDXGIFactory1@@IPAPAUIDXGIAdapter1@@@ZA ; EnumAdapters1_Original
	mov	eax, DWORD PTR _Adapter$[ebp]
	push	edi
	push	eax
	push	ebx
	call	?EnumAdapters_Common@@YGJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@P6GJ0I1@Z@Z ; EnumAdapters_Common
	mov	esi, eax
$LN3@EnumAdapte:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR _iname$[ebp+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN108@EnumAdapte
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR _iname$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN108@EnumAdapte:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4389 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?EnumAdapters1_Override@@YGJPAUIDXGIFactory1@@IPAPAUIDXGIAdapter1@@@Z$0:
	lea	ecx, DWORD PTR _iname$[ebp]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__ehhandler$?EnumAdapters1_Override@@YGJPAUIDXGIFactory1@@IPAPAUIDXGIAdapter1@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?EnumAdapters1_Override@@YGJPAUIDXGIFactory1@@IPAPAUIDXGIAdapter1@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?EnumAdapters1_Override@@YGJPAUIDXGIFactory1@@IPAPAUIDXGIAdapter1@@@Z ENDP ; EnumAdapters1_Override
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComQIPtr@UIDXGIAdapter1@@$1?_GUID_29038f61_3839_4626_91fd_086879011a05@@3U__s_GUID@@B@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComQIPtr@UIDXGIAdapter1@@$1?_GUID_29038f61_3839_4626_91fd_086879011a05@@3U__s_GUID@@B@ATL@@QAE@XZ PROC ; ATL::CComQIPtr<IDXGIAdapter1,&_GUID_29038f61_3839_4626_91fd_086879011a05>::~CComQIPtr<IDXGIAdapter1,&_GUID_29038f61_3839_4626_91fd_086879011a05>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComQIPtr@UIDXGIAdapter1@@$1?_GUID_29038f61_3839_4626_91fd_086879011a05@@3U__s_GUID@@B@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN7@CComQIPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN7@CComQIPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComQIPtr@UIDXGIAdapter1@@$1?_GUID_29038f61_3839_4626_91fd_086879011a05@@3U__s_GUID@@B@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComQIPtr@UIDXGIAdapter1@@$1?_GUID_29038f61_3839_4626_91fd_086879011a05@@3U__s_GUID@@B@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComQIPtr@UIDXGIAdapter1@@$1?_GUID_29038f61_3839_4626_91fd_086879011a05@@3U__s_GUID@@B@ATL@@QAE@XZ ENDP ; ATL::CComQIPtr<IDXGIAdapter1,&_GUID_29038f61_3839_4626_91fd_086879011a05>::~CComQIPtr<IDXGIAdapter1,&_GUID_29038f61_3839_4626_91fd_086879011a05>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComQIPtr@UIDXGIAdapter1@@$1?_GUID_29038f61_3839_4626_91fd_086879011a05@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComQIPtr@UIDXGIAdapter1@@$1?_GUID_29038f61_3839_4626_91fd_086879011a05@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z PROC ; ATL::CComQIPtr<IDXGIAdapter1,&_GUID_29038f61_3839_4626_91fd_086879011a05>::CComQIPtr<IDXGIAdapter1,&_GUID_29038f61_3839_4626_91fd_086879011a05>, COMDAT
; _this$ = ecx

; 621  :     CComQIPtr(_Inout_opt_ IUnknown* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 622  :     {
; 623  :         if (lp != NULL)

	mov	ecx, DWORD PTR _lp$[ebp]

; 158  :         p = NULL;

	mov	DWORD PTR [esi], 0

; 622  :     {
; 623  :         if (lp != NULL)

	test	ecx, ecx
	je	SHORT $LN10@CComQIPtr

; 624  :         {
; 625  :             if (FAILED(lp->QueryInterface(*piid, (void **)&this->p)))

	mov	eax, DWORD PTR [ecx]
	push	esi
	push	OFFSET __GUID_29038f61_3839_4626_91fd_086879011a05
	push	ecx
	call	DWORD PTR [eax]
	test	eax, eax

; 627  :         }
; 628  :     }

	mov	eax, esi
	jns	SHORT $LN3@CComQIPtr

; 626  :                 this->p = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 627  :         }
; 628  :     }

	pop	ebp
	ret	4
$LN10@CComQIPtr:
	mov	eax, esi
$LN3@CComQIPtr:
	pop	esi
	pop	ebp
	ret	4
??0?$CComQIPtr@UIDXGIAdapter1@@$1?_GUID_29038f61_3839_4626_91fd_086879011a05@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z ENDP ; ATL::CComQIPtr<IDXGIAdapter1,&_GUID_29038f61_3839_4626_91fd_086879011a05>::CComQIPtr<IDXGIAdapter1,&_GUID_29038f61_3839_4626_91fd_086879011a05>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtr@UIDXGIAdapter1@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComPtr@UIDXGIAdapter1@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<IDXGIAdapter1>::~CComPtr<IDXGIAdapter1>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComPtr@UIDXGIAdapter1@@@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@CComPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN4@CComPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComPtr@UIDXGIAdapter1@@@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComPtr@UIDXGIAdapter1@@@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComPtr@UIDXGIAdapter1@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<IDXGIAdapter1>::~CComPtr<IDXGIAdapter1>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UIDXGIAdapter1@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CComPtr@UIDXGIAdapter1@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<IDXGIAdapter1>::CComPtr<IDXGIAdapter1>, COMDAT
; _this$ = ecx

; 158  :         p = NULL;

	mov	DWORD PTR [ecx], 0

; 308  :     {
; 309  :     }

	mov	eax, ecx
	ret	0
??0?$CComPtr@UIDXGIAdapter1@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<IDXGIAdapter1>::CComPtr<IDXGIAdapter1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??8?$CComPtrBase@UIDXGIAdapter1@@@ATL@@QBE_NPAUIDXGIAdapter1@@@Z
_TEXT	SEGMENT
_pT$ = 8						; size = 4
??8?$CComPtrBase@UIDXGIAdapter1@@@ATL@@QBE_NPAUIDXGIAdapter1@@@Z PROC ; ATL::CComPtrBase<IDXGIAdapter1>::operator==, COMDAT
; _this$ = ecx

; 213  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR _pT$[ebp]
	sete	al

; 214  :         return p == pT;
; 215  :     }

	pop	ebp
	ret	4
??8?$CComPtrBase@UIDXGIAdapter1@@@ATL@@QBE_NPAUIDXGIAdapter1@@@Z ENDP ; ATL::CComPtrBase<IDXGIAdapter1>::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??9?$CComPtrBase@UIDXGIAdapter1@@@ATL@@QBE_NPAUIDXGIAdapter1@@@Z
_TEXT	SEGMENT
_pT$ = 8						; size = 4
??9?$CComPtrBase@UIDXGIAdapter1@@@ATL@@QBE_NPAUIDXGIAdapter1@@@Z PROC ; ATL::CComPtrBase<IDXGIAdapter1>::operator!=, COMDAT
; _this$ = ecx

; 209  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR _pT$[ebp]
	setne	al

; 210  :         return !operator==(pT);
; 211  :     }

	pop	ebp
	ret	4
??9?$CComPtrBase@UIDXGIAdapter1@@@ATL@@QBE_NPAUIDXGIAdapter1@@@Z ENDP ; ATL::CComPtrBase<IDXGIAdapter1>::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??I?$CComPtrBase@UIDXGIAdapter1@@@ATL@@QAEPAPAUIDXGIAdapter1@@XZ
_TEXT	SEGMENT
??I?$CComPtrBase@UIDXGIAdapter1@@@ATL@@QAEPAPAUIDXGIAdapter1@@XZ PROC ; ATL::CComPtrBase<IDXGIAdapter1>::operator&, COMDAT
; _this$ = ecx

; 192  :         ATLASSERT(p==NULL);
; 193  :         return &p;

	mov	eax, ecx

; 194  :     }

	ret	0
??I?$CComPtrBase@UIDXGIAdapter1@@@ATL@@QAEPAPAUIDXGIAdapter1@@XZ ENDP ; ATL::CComPtrBase<IDXGIAdapter1>::operator&
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??B?$CComPtrBase@UIDXGIAdapter1@@@ATL@@QBEPAUIDXGIAdapter1@@XZ
_TEXT	SEGMENT
??B?$CComPtrBase@UIDXGIAdapter1@@@ATL@@QBEPAUIDXGIAdapter1@@XZ PROC ; ATL::CComPtrBase<IDXGIAdapter1>::operator IDXGIAdapter1 *, COMDAT
; _this$ = ecx

; 181  :         return p;

	mov	eax, DWORD PTR [ecx]

; 182  :     }

	ret	0
??B?$CComPtrBase@UIDXGIAdapter1@@@ATL@@QBEPAUIDXGIAdapter1@@XZ ENDP ; ATL::CComPtrBase<IDXGIAdapter1>::operator IDXGIAdapter1 *
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UIDXGIAdapter1@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UIDXGIAdapter1@@@ATL@@QAE@XZ PROC	; ATL::CComPtrBase<IDXGIAdapter1>::~CComPtrBase<IDXGIAdapter1>, COMDAT
; _this$ = ecx

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN2@CComPtrBas

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@CComPtrBas:

; 178  :     }

	ret	0
??1?$CComPtrBase@UIDXGIAdapter1@@@ATL@@QAE@XZ ENDP	; ATL::CComPtrBase<IDXGIAdapter1>::~CComPtrBase<IDXGIAdapter1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UIDXGIAdapter1@@@ATL@@IAE@XZ
_TEXT	SEGMENT
??0?$CComPtrBase@UIDXGIAdapter1@@@ATL@@IAE@XZ PROC	; ATL::CComPtrBase<IDXGIAdapter1>::CComPtrBase<IDXGIAdapter1>, COMDAT
; _this$ = ecx

; 157  :     {
; 158  :         p = NULL;

	mov	DWORD PTR [ecx], 0

; 159  :     }

	mov	eax, ecx
	ret	0
??0?$CComPtrBase@UIDXGIAdapter1@@@ATL@@IAE@XZ ENDP	; ATL::CComPtrBase<IDXGIAdapter1>::CComPtrBase<IDXGIAdapter1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComQIPtr@UIDXGIAdapter2@@$1?_GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5@@3U__s_GUID@@B@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComQIPtr@UIDXGIAdapter2@@$1?_GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5@@3U__s_GUID@@B@ATL@@QAE@XZ PROC ; ATL::CComQIPtr<IDXGIAdapter2,&_GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5>::~CComQIPtr<IDXGIAdapter2,&_GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComQIPtr@UIDXGIAdapter2@@$1?_GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5@@3U__s_GUID@@B@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN7@CComQIPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN7@CComQIPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComQIPtr@UIDXGIAdapter2@@$1?_GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5@@3U__s_GUID@@B@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComQIPtr@UIDXGIAdapter2@@$1?_GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5@@3U__s_GUID@@B@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComQIPtr@UIDXGIAdapter2@@$1?_GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5@@3U__s_GUID@@B@ATL@@QAE@XZ ENDP ; ATL::CComQIPtr<IDXGIAdapter2,&_GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5>::~CComQIPtr<IDXGIAdapter2,&_GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComQIPtr@UIDXGIAdapter2@@$1?_GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComQIPtr@UIDXGIAdapter2@@$1?_GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z PROC ; ATL::CComQIPtr<IDXGIAdapter2,&_GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5>::CComQIPtr<IDXGIAdapter2,&_GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5>, COMDAT
; _this$ = ecx

; 621  :     CComQIPtr(_Inout_opt_ IUnknown* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 622  :     {
; 623  :         if (lp != NULL)

	mov	ecx, DWORD PTR _lp$[ebp]

; 158  :         p = NULL;

	mov	DWORD PTR [esi], 0

; 622  :     {
; 623  :         if (lp != NULL)

	test	ecx, ecx
	je	SHORT $LN10@CComQIPtr

; 624  :         {
; 625  :             if (FAILED(lp->QueryInterface(*piid, (void **)&this->p)))

	mov	eax, DWORD PTR [ecx]
	push	esi
	push	OFFSET __GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5
	push	ecx
	call	DWORD PTR [eax]
	test	eax, eax

; 627  :         }
; 628  :     }

	mov	eax, esi
	jns	SHORT $LN3@CComQIPtr

; 626  :                 this->p = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 627  :         }
; 628  :     }

	pop	ebp
	ret	4
$LN10@CComQIPtr:
	mov	eax, esi
$LN3@CComQIPtr:
	pop	esi
	pop	ebp
	ret	4
??0?$CComQIPtr@UIDXGIAdapter2@@$1?_GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z ENDP ; ATL::CComQIPtr<IDXGIAdapter2,&_GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5>::CComQIPtr<IDXGIAdapter2,&_GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtr@UIDXGIAdapter2@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComPtr@UIDXGIAdapter2@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<IDXGIAdapter2>::~CComPtr<IDXGIAdapter2>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComPtr@UIDXGIAdapter2@@@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@CComPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN4@CComPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComPtr@UIDXGIAdapter2@@@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComPtr@UIDXGIAdapter2@@@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComPtr@UIDXGIAdapter2@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<IDXGIAdapter2>::~CComPtr<IDXGIAdapter2>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UIDXGIAdapter2@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CComPtr@UIDXGIAdapter2@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<IDXGIAdapter2>::CComPtr<IDXGIAdapter2>, COMDAT
; _this$ = ecx

; 158  :         p = NULL;

	mov	DWORD PTR [ecx], 0

; 308  :     {
; 309  :     }

	mov	eax, ecx
	ret	0
??0?$CComPtr@UIDXGIAdapter2@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<IDXGIAdapter2>::CComPtr<IDXGIAdapter2>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??8?$CComPtrBase@UIDXGIAdapter2@@@ATL@@QBE_NPAUIDXGIAdapter2@@@Z
_TEXT	SEGMENT
_pT$ = 8						; size = 4
??8?$CComPtrBase@UIDXGIAdapter2@@@ATL@@QBE_NPAUIDXGIAdapter2@@@Z PROC ; ATL::CComPtrBase<IDXGIAdapter2>::operator==, COMDAT
; _this$ = ecx

; 213  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR _pT$[ebp]
	sete	al

; 214  :         return p == pT;
; 215  :     }

	pop	ebp
	ret	4
??8?$CComPtrBase@UIDXGIAdapter2@@@ATL@@QBE_NPAUIDXGIAdapter2@@@Z ENDP ; ATL::CComPtrBase<IDXGIAdapter2>::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??9?$CComPtrBase@UIDXGIAdapter2@@@ATL@@QBE_NPAUIDXGIAdapter2@@@Z
_TEXT	SEGMENT
_pT$ = 8						; size = 4
??9?$CComPtrBase@UIDXGIAdapter2@@@ATL@@QBE_NPAUIDXGIAdapter2@@@Z PROC ; ATL::CComPtrBase<IDXGIAdapter2>::operator!=, COMDAT
; _this$ = ecx

; 209  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR _pT$[ebp]
	setne	al

; 210  :         return !operator==(pT);
; 211  :     }

	pop	ebp
	ret	4
??9?$CComPtrBase@UIDXGIAdapter2@@@ATL@@QBE_NPAUIDXGIAdapter2@@@Z ENDP ; ATL::CComPtrBase<IDXGIAdapter2>::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UIDXGIAdapter2@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UIDXGIAdapter2@@@ATL@@QAE@XZ PROC	; ATL::CComPtrBase<IDXGIAdapter2>::~CComPtrBase<IDXGIAdapter2>, COMDAT
; _this$ = ecx

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN2@CComPtrBas

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@CComPtrBas:

; 178  :     }

	ret	0
??1?$CComPtrBase@UIDXGIAdapter2@@@ATL@@QAE@XZ ENDP	; ATL::CComPtrBase<IDXGIAdapter2>::~CComPtrBase<IDXGIAdapter2>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UIDXGIAdapter2@@@ATL@@IAE@XZ
_TEXT	SEGMENT
??0?$CComPtrBase@UIDXGIAdapter2@@@ATL@@IAE@XZ PROC	; ATL::CComPtrBase<IDXGIAdapter2>::CComPtrBase<IDXGIAdapter2>, COMDAT
; _this$ = ecx

; 157  :     {
; 158  :         p = NULL;

	mov	DWORD PTR [ecx], 0

; 159  :     }

	mov	eax, ecx
	ret	0
??0?$CComPtrBase@UIDXGIAdapter2@@@ATL@@IAE@XZ ENDP	; ATL::CComPtrBase<IDXGIAdapter2>::CComPtrBase<IDXGIAdapter2>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_desc1$2 = -604						; size = 296
_desc$ = -308						; size = 292
_pAdapter1$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_This$ = 8						; size = 4
_Adapter$ = 12						; size = 4
_pAdapter1$3 = 16					; size = 4
_pAdapter2$4 = 16					; size = 4
_ppAdapter$ = 16					; size = 4
_pFunc$ = 20						; size = 4
?EnumAdapters_Common@@YGJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@P6GJ0I1@Z@Z PROC ; EnumAdapters_Common

; 4243 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?EnumAdapters_Common@@YGJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@P6GJ0I1@Z@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 592				; 00000250H
	push	esi

; 4244 :   int iver = SK_GetDXGIAdapterInterfaceVer (*ppAdapter);

	mov	esi, DWORD PTR _ppAdapter$[ebp]
	push	edi
	push	DWORD PTR [esi]
	call	?SK_GetDXGIAdapterInterfaceVer@@YAHPAUIUnknown@@@Z ; SK_GetDXGIAdapterInterfaceVer

; 4245 : 
; 4246 :   DXGI_ADAPTER_DESC desc = { };

	push	292					; 00000124H
	mov	edi, eax
	lea	eax, DWORD PTR _desc$[ebp]
	push	0
	push	eax
	call	_memset
	add	esp, 16					; 00000010H

; 4247 : 
; 4248 :   switch (iver)

	sub	edi, 0
	je	$LN66@EnumAdapte
	sub	edi, 1
	je	SHORT $LN43@EnumAdapte

; 4249 :   {
; 4250 :     default:
; 4251 :     case 2:
; 4252 :     {
; 4253 :       if (! GetDesc2_Original)

	cmp	DWORD PTR ?GetDesc2_Original@@3P6GJPAUIDXGIAdapter2@@PAUDXGI_ADAPTER_DESC2@@@ZA, 0 ; GetDesc2_Original
	jne	SHORT $LN43@EnumAdapte

; 4255 :         CComQIPtr <IDXGIAdapter2> pAdapter2 (*ppAdapter);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 158  :         p = NULL;

	xor	ecx, ecx
	mov	DWORD PTR _pAdapter2$4[ebp], ecx

; 623  :         if (lp != NULL)

	test	edx, edx
	je	SHORT $LN26@EnumAdapte

; 624  :         {
; 625  :             if (FAILED(lp->QueryInterface(*piid, (void **)&this->p)))

	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR _pAdapter2$4[ebp]
	push	ecx
	push	OFFSET __GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5
	push	edx
	call	DWORD PTR [eax]
	mov	ecx, DWORD PTR _pAdapter2$4[ebp]
	xor	edx, edx
	test	eax, eax
	cmovs	ecx, edx
	mov	DWORD PTR _pAdapter2$4[ebp], ecx
$LN26@EnumAdapte:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4255 :         CComQIPtr <IDXGIAdapter2> pAdapter2 (*ppAdapter);

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 214  :         return p == pT;

	test	ecx, ecx
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4257 :         if (pAdapter2 != nullptr)

	je	SHORT $LN6@EnumAdapte

; 4258 :         {
; 4259 :           DXGI_VIRTUAL_HOOK (ppAdapter, 11, "(*pAdapter2)->GetDesc2",

	mov	eax, DWORD PTR [esi]
	push	OFFSET ?GetDesc2_Original@@3P6GJPAUIDXGIAdapter2@@PAUDXGI_ADAPTER_DESC2@@@ZA ; GetDesc2_Original
	push	OFFSET ?GetDesc2_Override@@YGJPAUIDXGIAdapter2@@PAUDXGI_ADAPTER_DESC2@@@Z ; GetDesc2_Override
	push	11					; 0000000bH
	push	DWORD PTR [eax]
	push	OFFSET $SG357425
	call	?SK_CreateVFTableHook2@@YG?AW4MH_STATUS@@PB_WPAPAXKPAX1@Z ; SK_CreateVFTableHook2
	mov	ecx, DWORD PTR _pAdapter2$4[ebp]
$LN6@EnumAdapte:

; 4260 :             GetDesc2_Override, GetDesc2_Original, GetDesc2_pfn);
; 4261 :         }
; 4262 :       }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	ecx, ecx
	je	SHORT $LN43@EnumAdapte

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN43@EnumAdapte:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4267 :       if (! GetDesc1_Original)

	cmp	DWORD PTR ?GetDesc1_Original@@3P6GJPAUIDXGIAdapter1@@PAUDXGI_ADAPTER_DESC1@@@ZA, 0 ; GetDesc1_Original
	jne	SHORT $LN66@EnumAdapte

; 4269 :         CComQIPtr <IDXGIAdapter1> pAdapter1 (*ppAdapter);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 158  :         p = NULL;

	xor	ecx, ecx
	mov	DWORD PTR _pAdapter1$3[ebp], ecx

; 623  :         if (lp != NULL)

	test	edx, edx
	je	SHORT $LN47@EnumAdapte

; 624  :         {
; 625  :             if (FAILED(lp->QueryInterface(*piid, (void **)&this->p)))

	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR _pAdapter1$3[ebp]
	push	ecx
	push	OFFSET __GUID_29038f61_3839_4626_91fd_086879011a05
	push	edx
	call	DWORD PTR [eax]
	mov	ecx, DWORD PTR _pAdapter1$3[ebp]
	xor	edx, edx
	test	eax, eax
	cmovs	ecx, edx
	mov	DWORD PTR _pAdapter1$3[ebp], ecx
$LN47@EnumAdapte:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4269 :         CComQIPtr <IDXGIAdapter1> pAdapter1 (*ppAdapter);

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 214  :         return p == pT;

	test	ecx, ecx
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4271 :         if (pAdapter1 != nullptr)

	je	SHORT $LN9@EnumAdapte

; 4272 :         {
; 4273 :           DXGI_VIRTUAL_HOOK (&pAdapter1, 10, "(*pAdapter1)->GetDesc1",

	push	OFFSET ?GetDesc1_Original@@3P6GJPAUIDXGIAdapter1@@PAUDXGI_ADAPTER_DESC1@@@ZA ; GetDesc1_Original
	push	OFFSET ?GetDesc1_Override@@YGJPAUIDXGIAdapter1@@PAUDXGI_ADAPTER_DESC1@@@Z ; GetDesc1_Override
	push	10					; 0000000aH
	push	DWORD PTR [ecx]
	push	OFFSET $SG357429
	call	?SK_CreateVFTableHook2@@YG?AW4MH_STATUS@@PB_WPAPAXKPAX1@Z ; SK_CreateVFTableHook2
	mov	ecx, DWORD PTR _pAdapter1$3[ebp]
$LN9@EnumAdapte:

; 4274 :             GetDesc1_Override, GetDesc1_Original, GetDesc1_pfn);
; 4275 :         }
; 4276 :       }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	ecx, ecx
	je	SHORT $LN66@EnumAdapte

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN66@EnumAdapte:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4281 :       if (! GetDesc_Original)

	mov	eax, DWORD PTR ?GetDesc_Original@@3P6GJPAUIDXGIAdapter@@PAUDXGI_ADAPTER_DESC@@@ZA ; GetDesc_Original
	test	eax, eax
	jne	SHORT $LN91@EnumAdapte

; 4282 :       {
; 4283 :         DXGI_VIRTUAL_HOOK (ppAdapter, 8, "(*ppAdapter)->GetDesc",

	mov	eax, DWORD PTR [esi]
	push	OFFSET ?GetDesc_Original@@3P6GJPAUIDXGIAdapter@@PAUDXGI_ADAPTER_DESC@@@ZA ; GetDesc_Original
	push	OFFSET ?GetDesc_Override@@YGJPAUIDXGIAdapter@@PAUDXGI_ADAPTER_DESC@@@Z ; GetDesc_Override
	push	8
	push	DWORD PTR [eax]
	push	OFFSET $SG357432
	call	?SK_CreateVFTableHook2@@YG?AW4MH_STATUS@@PB_WPAPAXKPAX1@Z ; SK_CreateVFTableHook2

; 4284 :           GetDesc_Override, GetDesc_Original, GetDesc_pfn);
; 4285 :       }
; 4286 : 
; 4287 :       if (GetDesc_Original)

	mov	eax, DWORD PTR ?GetDesc_Original@@3P6GJPAUIDXGIAdapter@@PAUDXGI_ADAPTER_DESC@@@ZA ; GetDesc_Original
	test	eax, eax
	je	SHORT $LN12@EnumAdapte
$LN91@EnumAdapte:

; 4288 :         GetDesc_Original (*ppAdapter, &desc);

	lea	ecx, DWORD PTR _desc$[ebp]
	push	ecx
	push	DWORD PTR [esi]
	call	eax
$LN12@EnumAdapte:

; 4289 :     }
; 4290 :   }
; 4291 : 
; 4292 :   // Logic to skip Intel and Microsoft adapters and return only AMD / NV
; 4293 :   if (! lstrlenW (desc.Description))

	lea	eax, DWORD PTR _desc$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrlenW@4
	test	eax, eax
	jne	SHORT $LN13@EnumAdapte

; 4294 :     dll_log.LogEx (false, L" >> Assertion filed: Zero-length adapter name!\n");

	push	OFFSET $SG357435
	push	eax
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	add	esp, 12					; 0000000cH
$LN13@EnumAdapte:

; 4295 : 
; 4296 : #ifdef SKIP_INTEL
; 4297 :   if ((desc.VendorId == Microsoft || desc.VendorId == Intel) && Adapter == 0) {
; 4298 : #else
; 4299 :   if (false)
; 4300 :   {
; 4301 : #endif
; 4302 :     // We need to release the reference we were just handed before
; 4303 :     //   skipping it.
; 4304 :     (*ppAdapter)->Release ();
; 4305 : 
; 4306 :     dll_log.LogEx (false,
; 4307 :       L"[   DXGI   ] >> (Host Application Tried To Enum Intel or Microsoft Adapter "
; 4308 :       L"as Adapter 0) -- Skipping Adapter '%s' <<\n", desc.Description);
; 4309 : 
; 4310 :     return (pFunc (This, Adapter + 1, ppAdapter));
; 4311 :   }
; 4312 : 
; 4313 :   dll_log.LogEx (true, L"[   DXGI   ]  @ Returned Adapter %lu: '%32s' (LUID: %08X:%08X)",

	push	DWORD PTR _desc$[ebp+284]
	lea	eax, DWORD PTR _desc$[ebp]
	push	DWORD PTR _desc$[ebp+288]
	push	eax
	push	DWORD PTR _Adapter$[ebp]
	push	OFFSET $SG357438
	push	1
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx

; 4322 :   CComQIPtr <IDXGIAdapter1> pAdapter1 (*ppAdapter);

	mov	ecx, DWORD PTR [esi]
	add	esp, 28					; 0000001cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 158  :         p = NULL;

	xor	esi, esi
	mov	DWORD PTR _pAdapter1$[ebp], esi

; 623  :         if (lp != NULL)

	test	ecx, ecx
	je	SHORT $LN70@EnumAdapte

; 624  :         {
; 625  :             if (FAILED(lp->QueryInterface(*piid, (void **)&this->p)))

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR _pAdapter1$[ebp]
	push	edx
	push	OFFSET __GUID_29038f61_3839_4626_91fd_086879011a05
	push	ecx
	call	DWORD PTR [eax]
	mov	esi, DWORD PTR _pAdapter1$[ebp]
	xor	ecx, ecx
	test	eax, eax
	cmovs	esi, ecx
	mov	DWORD PTR _pAdapter1$[ebp], esi
$LN70@EnumAdapte:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4322 :   CComQIPtr <IDXGIAdapter1> pAdapter1 (*ppAdapter);

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 214  :         return p == pT;

	test	esi, esi
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4324 :   if (pAdapter1 != nullptr)

	je	SHORT $LN19@EnumAdapte

; 4325 :   {
; 4326 :     DXGI_ADAPTER_DESC1 desc1 = { };

	push	296					; 00000128H
	lea	eax, DWORD PTR _desc1$2[ebp]
	push	0
	push	eax
	call	_memset

; 4327 : 
; 4328 :     if (            GetDesc1_Original != nullptr &&

	mov	eax, DWORD PTR ?GetDesc1_Original@@3P6GJPAUIDXGIAdapter1@@PAUDXGI_ADAPTER_DESC1@@@ZA ; GetDesc1_Original
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN19@EnumAdapte
	lea	ecx, DWORD PTR _desc1$2[ebp]
	push	ecx
	push	esi
	call	eax
	test	eax, eax
	js	SHORT $LN19@EnumAdapte

; 4329 :          SUCCEEDED (GetDesc1_Original (pAdapter1, &desc1)) )
; 4330 :     {
; 4331 : #define DXGI_ADAPTER_FLAG_REMOTE   0x1
; 4332 : #define DXGI_ADAPTER_FLAG_SOFTWARE 0x2
; 4333 :       if (desc1.Flags & DXGI_ADAPTER_FLAG_SOFTWARE)

	test	BYTE PTR _desc1$2[ebp+292], 2
	je	SHORT $LN17@EnumAdapte

; 4334 :         dll_log.LogEx (false, L" <Software>");

	push	OFFSET $SG357443

; 4335 :       else

	jmp	SHORT $LN94@EnumAdapte
$LN17@EnumAdapte:

; 4336 :         dll_log.LogEx (false, L" <Hardware>");

	push	OFFSET $SG357444
$LN94@EnumAdapte:
	push	0
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	add	esp, 12					; 0000000cH

; 4337 :       if (desc1.Flags & DXGI_ADAPTER_FLAG_REMOTE)

	test	BYTE PTR _desc1$2[ebp+292], 1
	je	SHORT $LN19@EnumAdapte

; 4338 :         dll_log.LogEx (false, L" [Remote]");

	push	OFFSET $SG357446
	push	0
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	add	esp, 12					; 0000000cH
$LN19@EnumAdapte:

; 4342 :   dll_log.LogEx (false, L"\n");

	push	OFFSET $SG357447
	push	0
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	mov	eax, DWORD PTR _pAdapter1$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4342 :   dll_log.LogEx (false, L"\n");

	add	esp, 12					; 0000000cH

; 4343 : 
; 4344 :   return S_OK;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN92@EnumAdapte

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN92@EnumAdapte:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4345 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	xor	eax, eax
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?EnumAdapters_Common@@YGJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@P6GJ0I1@Z@Z$0:
	lea	ecx, DWORD PTR _pAdapter2$4[ebp]
	jmp	??1?$CComQIPtr@UIDXGIAdapter2@@$1?_GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5@@3U__s_GUID@@B@ATL@@QAE@XZ
__unwindfunclet$?EnumAdapters_Common@@YGJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@P6GJ0I1@Z@Z$1:
	lea	ecx, DWORD PTR _pAdapter1$3[ebp]
	jmp	??1?$CComQIPtr@UIDXGIAdapter1@@$1?_GUID_29038f61_3839_4626_91fd_086879011a05@@3U__s_GUID@@B@ATL@@QAE@XZ
__unwindfunclet$?EnumAdapters_Common@@YGJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@P6GJ0I1@Z@Z$2:
	lea	ecx, DWORD PTR _pAdapter1$[ebp]
	jmp	??1?$CComQIPtr@UIDXGIAdapter1@@$1?_GUID_29038f61_3839_4626_91fd_086879011a05@@3U__s_GUID@@B@ATL@@QAE@XZ
__ehhandler$?EnumAdapters_Common@@YGJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@P6GJ0I1@Z@Z:
	mov	eax, OFFSET __ehfuncinfo$?EnumAdapters_Common@@YGJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@P6GJ0I1@Z@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?EnumAdapters_Common@@YGJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@P6GJ0I1@Z@Z ENDP ; EnumAdapters_Common
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QB_W@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QB_W@Z PROC ; std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 3843 : 	{	// test for string vs. NTCTS equality

	npad	2
	push	ebp
	mov	ebp, esp

; 3844 : 	return (_Left._Equal(_Right));

	push	DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Left$[ebp]
	call	?_Equal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NQB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Equal

; 3845 : 	}

	pop	ebp
	ret	0
??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QB_W@Z ENDP ; std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
$T1 = -28						; size = 24
$T2 = -4						; size = 4
__$ReturnAddr$ = 4					; size = 4
_This$ = 8						; size = 4
_ret$1$ = 12						; size = 4
_pDesc$ = 12						; size = 4
?GetDesc_Override@@YGJPAUIDXGIAdapter@@PAUDXGI_ADAPTER_DESC@@@Z PROC ; GetDesc_Override

; 4186 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi

; 4187 : #if 0
; 4188 :   std::wstring iname = SK_GetDXGIAdapterInterface (This);
; 4189 : 
; 4190 :   DXGI_LOG_CALL_I2 (iname.c_str (), L"GetDesc",L"%ph, %ph", This, pDesc);
; 4191 : 
; 4192 :   HRESULT    ret;
; 4193 :   DXGI_CALL (ret, GetDesc_Original (This, pDesc));
; 4194 : #else
; 4195 :   HRESULT ret = GetDesc_Original (This, pDesc);

	mov	esi, DWORD PTR _pDesc$[ebp]
	push	edi
	push	esi
	push	DWORD PTR _This$[ebp]
	mov	DWORD PTR $T2[ebp], 0
	call	DWORD PTR ?GetDesc_Original@@3P6GJPAUIDXGIAdapter@@PAUDXGI_ADAPTER_DESC@@@ZA ; GetDesc_Original

; 4196 : #endif
; 4197 : 
; 4198 :   //// OVERRIDE VRAM NUMBER
; 4199 :   if (nvapi_init && sk::NVAPI::CountSLIGPUs () > 0)

	cmp	DWORD PTR ?nvapi_init@@3HA, 0		; nvapi_init
	mov	edi, eax
	mov	DWORD PTR _ret$1$[ebp], edi
	je	SHORT $LN4@GetDesc_Ov
	call	?CountSLIGPUs@NVAPI@sk@@YAHXZ		; sk::NVAPI::CountSLIGPUs
	test	eax, eax
	jle	SHORT $LN4@GetDesc_Ov

; 4200 :   {
; 4201 :     dll_log.LogEx ( true,

	push	esi
	push	OFFSET $SG357181
	push	1
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx

; 4202 :       L" <> GetDesc_Override: Looking for matching NVAPI GPU for %s...: ",
; 4203 :       pDesc->Description );
; 4204 : 
; 4205 :     DXGI_ADAPTER_DESC* match =
; 4206 :       sk::NVAPI::FindGPUByDXGIName (pDesc->Description);

	push	esi
	call	?FindGPUByDXGIName@NVAPI@sk@@YAPAUDXGI_ADAPTER_DESC@@PB_W@Z ; sk::NVAPI::FindGPUByDXGIName
	mov	edi, eax
	add	esp, 20					; 00000014H

; 4207 : 
; 4208 :     if (match != nullptr)

	test	edi, edi
	je	SHORT $LN3@GetDesc_Ov

; 4209 :     {
; 4210 :       dll_log.LogEx (false, L"Success! (%s)\n", match->Description);

	push	edi
	push	OFFSET $SG357184
	push	0
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx

; 4211 :       pDesc->DedicatedVideoMemory = match->DedicatedVideoMemory;

	mov	eax, DWORD PTR [edi+272]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+272], eax

; 4212 :     }
; 4213 : 
; 4214 :     else

	jmp	SHORT $LN46@GetDesc_Ov
$LN3@GetDesc_Ov:

; 4215 :     {
; 4216 :       dll_log.LogEx (false, L"Failure! (No Match Found)\n");

	push	OFFSET $SG357185
	push	0
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	add	esp, 12					; 0000000cH
$LN46@GetDesc_Ov:
	mov	edi, DWORD PTR _ret$1$[ebp]
$LN4@GetDesc_Ov:

; 4217 :     }
; 4218 :   }
; 4219 : 
; 4220 :   if (config.system.log_level >= 1)

	cmp	DWORD PTR ?config@@3Usk_config_t@@A+808, 1
	jl	SHORT $LN5@GetDesc_Ov

; 4221 :   {
; 4222 :     dll_log.Log ( L"[   DXGI   ] Dedicated Video: %zu MiB, Dedicated System: %zu MiB, "

	mov	eax, DWORD PTR [esi+280]
	shr	eax, 20					; 00000014H
	push	eax
	mov	eax, DWORD PTR [esi+276]
	shr	eax, 20					; 00000014H
	push	eax
	mov	eax, DWORD PTR [esi+272]
	shr	eax, 20					; 00000014H
	push	eax
	push	OFFSET $SG357187
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 20					; 00000014H
$LN5@GetDesc_Ov:

; 4229 :   if ( (! lstrcmpW (SK_GetHostApp (),   L"Fallout4.exe") ) &&

	push	ebx
	push	OFFSET $SG357190
	call	?SK_GetHostApp@@YAPB_WXZ		; SK_GetHostApp
	push	eax
	call	DWORD PTR __imp__lstrcmpW@8
	test	eax, eax
	jne	SHORT $LN8@GetDesc_Ov
	mov	eax, DWORD PTR __$ReturnAddr$[ebp]
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?SK_GetCallerName@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAX@Z ; SK_GetCallerName
	add	esp, 8
	mov	DWORD PTR $T2[ebp], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3844 : 	return (_Left._Equal(_Right));

	mov	ecx, eax
	push	OFFSET $SG357191
	call	?_Equal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NQB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Equal
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4229 :   if ( (! lstrcmpW (SK_GetHostApp (),   L"Fallout4.exe") ) &&

	test	al, al
	je	SHORT $LN8@GetDesc_Ov
	mov	bl, 1
	jmp	SHORT $LN9@GetDesc_Ov
$LN8@GetDesc_Ov:
	xor	bl, bl
$LN9@GetDesc_Ov:
	test	BYTE PTR $T2[ebp], 1
	je	SHORT $LN19@GetDesc_Ov
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T1[ebp+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN19@GetDesc_Ov
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T1[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN19@GetDesc_Ov:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4229 :   if ( (! lstrcmpW (SK_GetHostApp (),   L"Fallout4.exe") ) &&

	test	bl, bl
	pop	ebx
	je	SHORT $LN45@GetDesc_Ov

; 4230 :                  SK_GetCallerName () == L"Fallout4.exe"  )
; 4231 :   {
; 4232 :     pDesc->DedicatedVideoMemory = pDesc->SharedSystemMemory;

	mov	eax, DWORD PTR [esi+280]
	mov	DWORD PTR [esi+272], eax
$LN45@GetDesc_Ov:

; 4233 :   }
; 4234 : 
; 4235 :   return ret;

	mov	eax, edi
	pop	edi
	pop	esi

; 4236 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetDesc_Override@@YGJPAUIDXGIAdapter@@PAUDXGI_ADAPTER_DESC@@@Z ENDP ; GetDesc_Override
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_This$ = 8						; size = 4
_pDesc$ = 12						; size = 4
?GetDesc1_Override@@YGJPAUIDXGIAdapter1@@PAUDXGI_ADAPTER_DESC1@@@Z PROC ; GetDesc1_Override

; 4148 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 4149 : #if 0
; 4150 :   std::wstring iname = SK_GetDXGIAdapterInterface (This);
; 4151 : 
; 4152 :   DXGI_LOG_CALL_I2 (iname.c_str (), L"GetDesc1", L"%ph, %ph", This, pDesc);
; 4153 : 
; 4154 :   HRESULT    ret;
; 4155 :   DXGI_CALL (ret, GetDesc1_Original (This, pDesc));
; 4156 : #else
; 4157 :   HRESULT ret = GetDesc1_Original (This, pDesc);

	mov	edi, DWORD PTR _pDesc$[ebp]
	push	edi
	push	DWORD PTR _This$[ebp]
	call	DWORD PTR ?GetDesc1_Original@@3P6GJPAUIDXGIAdapter1@@PAUDXGI_ADAPTER_DESC1@@@ZA ; GetDesc1_Original

; 4158 : #endif
; 4159 : 
; 4160 :   //// OVERRIDE VRAM NUMBER
; 4161 :   if (nvapi_init && sk::NVAPI::CountSLIGPUs () > 0)

	cmp	DWORD PTR ?nvapi_init@@3HA, 0		; nvapi_init
	mov	esi, eax
	je	SHORT $LN4@GetDesc1_O
	call	?CountSLIGPUs@NVAPI@sk@@YAHXZ		; sk::NVAPI::CountSLIGPUs
	test	eax, eax
	jle	SHORT $LN7@GetDesc1_O

; 4162 :   {
; 4163 :     dll_log.LogEx ( true,

	push	ebx
	push	edi
	push	OFFSET $SG357129
	push	1
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx

; 4164 :       L" <> GetDesc1_Override: Looking for matching NVAPI GPU for %s...: ",
; 4165 :       pDesc->Description );
; 4166 : 
; 4167 :     DXGI_ADAPTER_DESC* match =
; 4168 :       sk::NVAPI::FindGPUByDXGIName (pDesc->Description);

	push	edi
	call	?FindGPUByDXGIName@NVAPI@sk@@YAPAUDXGI_ADAPTER_DESC@@PB_W@Z ; sk::NVAPI::FindGPUByDXGIName
	mov	ebx, eax
	add	esp, 20					; 00000014H

; 4169 : 
; 4170 :     if (match != nullptr)

	test	ebx, ebx
	je	SHORT $LN3@GetDesc1_O

; 4171 :     {
; 4172 :       dll_log.LogEx (false, L"Success! (%s)\n", match->Description);

	push	ebx
	push	OFFSET $SG357132
	push	0
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx

; 4173 :       pDesc->DedicatedVideoMemory = match->DedicatedVideoMemory;

	mov	eax, DWORD PTR [ebx+272]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [edi+272], eax

; 4178 :   }
; 4179 : 
; 4180 :   return ret;

	mov	eax, esi
	pop	ebx
	pop	edi
	pop	esi

; 4181 : }

	pop	ebp
	ret	8
$LN3@GetDesc1_O:

; 4174 :     }
; 4175 : 
; 4176 :     else
; 4177 :       dll_log.LogEx (false, L"Failure! (No Match Found)\n");

	push	OFFSET $SG357133
	push	0
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	add	esp, 12					; 0000000cH
	pop	ebx
$LN7@GetDesc1_O:

; 4178 :   }
; 4179 : 
; 4180 :   return ret;

	mov	eax, esi
$LN4@GetDesc1_O:
	pop	edi
	pop	esi

; 4181 : }

	pop	ebp
	ret	8
?GetDesc1_Override@@YGJPAUIDXGIAdapter1@@PAUDXGI_ADAPTER_DESC1@@@Z ENDP ; GetDesc1_Override
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_This$ = 8						; size = 4
_pDesc$ = 12						; size = 4
?GetDesc2_Override@@YGJPAUIDXGIAdapter2@@PAUDXGI_ADAPTER_DESC2@@@Z PROC ; GetDesc2_Override

; 4111 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 4112 : #if 0
; 4113 :   std::wstring iname = SK_GetDXGIAdapterInterface (This);
; 4114 : 
; 4115 :   DXGI_LOG_CALL_I2 (iname.c_str (), L"GetDesc2", L"%ph, %ph", This, pDesc);
; 4116 : 
; 4117 :   HRESULT    ret;
; 4118 :   DXGI_CALL (ret, GetDesc2_Original (This, pDesc));
; 4119 : #else
; 4120 :   HRESULT ret = GetDesc2_Original (This, pDesc);

	mov	edi, DWORD PTR _pDesc$[ebp]
	push	edi
	push	DWORD PTR _This$[ebp]
	call	DWORD PTR ?GetDesc2_Original@@3P6GJPAUIDXGIAdapter2@@PAUDXGI_ADAPTER_DESC2@@@ZA ; GetDesc2_Original

; 4121 : #endif
; 4122 : 
; 4123 :   //// OVERRIDE VRAM NUMBER
; 4124 :   if (nvapi_init && sk::NVAPI::CountSLIGPUs () > 0)

	cmp	DWORD PTR ?nvapi_init@@3HA, 0		; nvapi_init
	mov	esi, eax
	je	SHORT $LN4@GetDesc2_O
	call	?CountSLIGPUs@NVAPI@sk@@YAHXZ		; sk::NVAPI::CountSLIGPUs
	test	eax, eax
	jle	SHORT $LN7@GetDesc2_O

; 4125 :   {
; 4126 :     dll_log.LogEx ( true,

	push	ebx
	push	edi
	push	OFFSET $SG357117
	push	1
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx

; 4127 :       L" <> GetDesc2_Override: Looking for matching NVAPI GPU for %s...: ",
; 4128 :       pDesc->Description );
; 4129 : 
; 4130 :     DXGI_ADAPTER_DESC* match =
; 4131 :       sk::NVAPI::FindGPUByDXGIName (pDesc->Description);

	push	edi
	call	?FindGPUByDXGIName@NVAPI@sk@@YAPAUDXGI_ADAPTER_DESC@@PB_W@Z ; sk::NVAPI::FindGPUByDXGIName
	mov	ebx, eax
	add	esp, 20					; 00000014H

; 4132 : 
; 4133 :     if (match != nullptr)

	test	ebx, ebx
	je	SHORT $LN3@GetDesc2_O

; 4134 :     {
; 4135 :       dll_log.LogEx (false, L"Success! (%s)\n", match->Description);

	push	ebx
	push	OFFSET $SG357120
	push	0
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx

; 4136 :       pDesc->DedicatedVideoMemory = match->DedicatedVideoMemory;

	mov	eax, DWORD PTR [ebx+272]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [edi+272], eax

; 4140 :   }
; 4141 : 
; 4142 :   return ret;

	mov	eax, esi
	pop	ebx
	pop	edi
	pop	esi

; 4143 : }

	pop	ebp
	ret	8
$LN3@GetDesc2_O:

; 4137 :     }
; 4138 :     else
; 4139 :       dll_log.LogEx (false, L"Failure! (No Match Found)\n");

	push	OFFSET $SG357121
	push	0
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	add	esp, 12					; 0000000cH
	pop	ebx
$LN7@GetDesc2_O:

; 4140 :   }
; 4141 : 
; 4142 :   return ret;

	mov	eax, esi
$LN4@GetDesc2_O:
	pop	edi
	pop	esi

; 4143 : }

	pop	ebp
	ret	8
?GetDesc2_Override@@YGJPAUIDXGIAdapter2@@PAUDXGI_ADAPTER_DESC2@@@Z ENDP ; GetDesc2_Override
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ??$static_cast_p2p@XUIDXGIFactory@@@@YAPAPAXPAPAUIDXGIFactory@@@Z
_TEXT	SEGMENT
_p2p$ = 8						; size = 4
??$static_cast_p2p@XUIDXGIFactory@@@@YAPAPAXPAPAUIDXGIFactory@@@Z PROC ; static_cast_p2p<void,IDXGIFactory>, COMDAT

; 50   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 51   :       return static_cast <T **> (

	mov	eax, DWORD PTR _p2p$[ebp]

; 52   :                static_cast <T*>   ( p2p )
; 53   :                                 );
; 54   :     };

	pop	ebp
	ret	0
??$static_cast_p2p@XUIDXGIFactory@@@@YAPAPAXPAPAUIDXGIFactory@@@Z ENDP ; static_cast_p2p<void,IDXGIFactory>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
$T2 = -60						; size = 24
_iname$ = -36						; size = 24
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_riid$ = 8						; size = 4
_ppFactory$ = 12					; size = 4
?CreateDXGIFactory1@@YGJABU_GUID@@PAPAX@Z PROC		; CreateDXGIFactory1

; 4468 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?CreateDXGIFactory1@@YGJABU_GUID@@PAPAX@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 48					; 00000030H

; 4469 :   // For DXGI compliance, do not mix-and-match
; 4470 :   if ((! SK_DXGI_use_factory1) && (SK_DXGI_factory_init))

	cmp	BYTE PTR ?SK_DXGI_use_factory1@@3_NA, 0	; SK_DXGI_use_factory1
	jne	SHORT $LN2@CreateDXGI
	cmp	BYTE PTR ?SK_DXGI_factory_init@@3_NA, 0	; SK_DXGI_factory_init
	je	SHORT $LN2@CreateDXGI

; 4471 :     return CreateDXGIFactory (riid, ppFactory);

	push	DWORD PTR _ppFactory$[ebp]
	push	DWORD PTR _riid$[ebp]
	call	?CreateDXGIFactory@@YGJABU_GUID@@PAPAX@Z ; CreateDXGIFactory

; 4499 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN2@CreateDXGI:
	push	esi
	push	edi

; 4472 : 
; 4473 :   SK_DXGI_use_factory1 = true;
; 4474 : 
; 4475 :   std::wstring iname = SK_GetDXGIFactoryInterfaceEx  (riid);

	mov	edi, DWORD PTR _riid$[ebp]
	lea	eax, DWORD PTR _iname$[ebp]
	push	edi
	push	eax
	mov	BYTE PTR ?SK_DXGI_use_factory1@@3_NA, 1	; SK_DXGI_use_factory1
	call	?SK_GetDXGIFactoryInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z ; SK_GetDXGIFactoryInterfaceEx

; 4480 :   DXGI_LOG_CALL_2 ( L"                    CreateDXGIFactory1       ", L"%s, %ph",

	push	8192					; 00002000H
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??_U@YAPAXI@Z				; operator new[]
	mov	esi, eax
	add	esp, 12					; 0000000cH
	test	esi, esi
	je	SHORT $LN7@CreateDXGI
	push	8192					; 00002000H
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN8@CreateDXGI
$LN7@CreateDXGI:
	xor	esi, esi
$LN8@CreateDXGI:
	push	ebx
	lea	ebx, DWORD PTR [esi+2048]
	test	esi, esi
	je	$LN3@CreateDXGI
	push	OFFSET $SG357566
	push	OFFSET $SG357567
	push	esi
	call	__swprintf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR _iname$[ebp+20], 8

; 1621 : 		return (_Large_string_engaged()

	lea	eax, DWORD PTR _iname$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4480 :   DXGI_LOG_CALL_2 ( L"                    CreateDXGIFactory1       ", L"%s, %ph",

	push	DWORD PTR _ppFactory$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	cmovae	eax, DWORD PTR _iname$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4480 :   DXGI_LOG_CALL_2 ( L"                    CreateDXGIFactory1       ", L"%s, %ph",

	push	eax
	push	OFFSET $SG357568
	push	ebx
	call	__swprintf
	push	ebx
	push	esi
	lea	eax, DWORD PTR [ebx+2048]
	push	OFFSET $SG357569
	push	eax
	call	__swprintf
	mov	eax, DWORD PTR __$ReturnAddr$[ebp]
	add	esp, 44					; 0000002cH
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?SK_SummarizeCaller@@YG?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAX@Z ; SK_SummarizeCaller
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN44@CreateDXGI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN44@CreateDXGI:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4480 :   DXGI_LOG_CALL_2 ( L"                    CreateDXGIFactory1       ", L"%s, %ph",

	push	eax
	lea	eax, DWORD PTR [ebx+2048]
	push	eax
	push	OFFSET $SG357570
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T2[ebp+20]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4480 :   DXGI_LOG_CALL_2 ( L"                    CreateDXGIFactory1       ", L"%s, %ph",

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN54@CreateDXGI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T2[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN54@CreateDXGI:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4480 :   DXGI_LOG_CALL_2 ( L"                    CreateDXGIFactory1       ", L"%s, %ph",

	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN3@CreateDXGI:
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	esi, DWORD PTR ?SK_D3D11_init_tid@@3JC	; SK_D3D11_init_tid
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4483 :   if ( ReadAcquire (&SK_D3D11_init_tid)  != static_cast <LONG> (GetCurrentThreadId ()) &&

	mov	ebx, DWORD PTR __imp__GetCurrentThreadId@0
	call	ebx
	cmp	esi, eax
	je	SHORT $LN4@CreateDXGI
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	esi, DWORD PTR ?SK_D3D11_ansel_tid@@3JC	; SK_D3D11_ansel_tid
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4483 :   if ( ReadAcquire (&SK_D3D11_init_tid)  != static_cast <LONG> (GetCurrentThreadId ()) &&

	call	ebx
	cmp	esi, eax
	je	SHORT $LN4@CreateDXGI

; 4484 :        ReadAcquire (&SK_D3D11_ansel_tid) != static_cast <LONG> (GetCurrentThreadId ()) )
; 4485 :     WaitForInitDXGI ();

	call	?WaitForInitDXGI@@YAXXZ			; WaitForInitDXGI
$LN4@CreateDXGI:

; 4486 : 
; 4487 :   SK_DXGI_factory_init = true;
; 4488 : 
; 4489 :   // Windows Vista does not have this function -- wrap it with CreateDXGIFactory
; 4490 :   if (CreateDXGIFactory1_Import == nullptr)

	mov	eax, DWORD PTR ?CreateDXGIFactory1_Import@@3P6GJABU_GUID@@PAPAX@ZA ; CreateDXGIFactory1_Import
	mov	BYTE PTR ?SK_DXGI_factory_init@@3_NA, 1	; SK_DXGI_factory_init
	pop	ebx
	test	eax, eax
	jne	SHORT $LN5@CreateDXGI

; 4491 :   {
; 4492 :     dll_log.Log (L"[   DXGI   ]  >> Falling back to CreateDXGIFactory on Vista...");

	push	OFFSET $SG357573
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 4493 :     return CreateDXGIFactory (riid, ppFactory);

	mov	ecx, DWORD PTR _ppFactory$[ebp]
	add	esp, 8
	push	ecx
	push	edi
	call	?CreateDXGIFactory@@YGJABU_GUID@@PAPAX@Z ; CreateDXGIFactory
	mov	esi, eax
	jmp	SHORT $LN11@CreateDXGI
$LN5@CreateDXGI:

; 4494 :   }
; 4495 : 
; 4496 :   HRESULT    ret;
; 4497 :   DXGI_CALL (ret, CreateDXGIFactory1_Import (riid, ppFactory));

	mov	ecx, DWORD PTR _ppFactory$[ebp]
	push	ecx
	push	edi
	call	eax
	mov	esi, eax
	push	esi
	call	?SK_DescribeHRESULT@@YGPB_WJ@Z		; SK_DescribeHRESULT
	push	eax
	push	OFFSET $SG357575
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
$LN11@CreateDXGI:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR _iname$[ebp+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN88@CreateDXGI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR _iname$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN88@CreateDXGI:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4499 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?CreateDXGIFactory1@@YGJABU_GUID@@PAPAX@Z$0:
	lea	ecx, DWORD PTR _iname$[ebp]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__ehhandler$?CreateDXGIFactory1@@YGJABU_GUID@@PAPAX@Z:
	mov	eax, OFFSET __ehfuncinfo$?CreateDXGIFactory1@@YGJABU_GUID@@PAPAX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CreateDXGIFactory1@@YGJABU_GUID@@PAPAX@Z ENDP		; CreateDXGIFactory1
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
$T2 = -60						; size = 24
_iname$ = -36						; size = 24
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_riid$ = 8						; size = 4
_ppFactory$ = 12					; size = 4
?CreateDXGIFactory@@YGJABU_GUID@@PAPAX@Z PROC		; CreateDXGIFactory

; 4440 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?CreateDXGIFactory@@YGJABU_GUID@@PAPAX@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 48					; 00000030H

; 4441 :   // For DXGI compliance, do not mix-and-match
; 4442 :   if (SK_DXGI_use_factory1)

	cmp	BYTE PTR ?SK_DXGI_use_factory1@@3_NA, 0	; SK_DXGI_use_factory1
	je	SHORT $LN2@CreateDXGI

; 4443 :     return CreateDXGIFactory1 (riid, ppFactory);

	push	DWORD PTR _ppFactory$[ebp]
	push	DWORD PTR _riid$[ebp]
	call	?CreateDXGIFactory1@@YGJABU_GUID@@PAPAX@Z ; CreateDXGIFactory1

; 4463 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN2@CreateDXGI:
	push	esi

; 4444 : 
; 4445 :   std::wstring iname = SK_GetDXGIFactoryInterfaceEx  (riid);

	push	DWORD PTR _riid$[ebp]
	lea	eax, DWORD PTR _iname$[ebp]
	push	eax
	call	?SK_GetDXGIFactoryInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z ; SK_GetDXGIFactoryInterfaceEx

; 4450 :   DXGI_LOG_CALL_2 ( L"                    CreateDXGIFactory        ", L"%s, %ph",

	push	8192					; 00002000H
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??_U@YAPAXI@Z				; operator new[]
	mov	esi, eax
	add	esp, 12					; 0000000cH
	test	esi, esi
	je	SHORT $LN6@CreateDXGI
	push	8192					; 00002000H
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN7@CreateDXGI
$LN6@CreateDXGI:
	xor	esi, esi
$LN7@CreateDXGI:
	push	edi
	lea	edi, DWORD PTR [esi+2048]
	test	esi, esi
	je	$LN3@CreateDXGI
	push	OFFSET $SG357537
	push	OFFSET $SG357538
	push	esi
	call	__swprintf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR _iname$[ebp+20], 8

; 1621 : 		return (_Large_string_engaged()

	lea	eax, DWORD PTR _iname$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4450 :   DXGI_LOG_CALL_2 ( L"                    CreateDXGIFactory        ", L"%s, %ph",

	push	DWORD PTR _ppFactory$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	cmovae	eax, DWORD PTR _iname$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4450 :   DXGI_LOG_CALL_2 ( L"                    CreateDXGIFactory        ", L"%s, %ph",

	push	eax
	push	OFFSET $SG357539
	push	edi
	call	__swprintf
	push	edi
	push	esi
	lea	eax, DWORD PTR [edi+2048]
	push	OFFSET $SG357540
	push	eax
	call	__swprintf
	mov	eax, DWORD PTR __$ReturnAddr$[ebp]
	add	esp, 44					; 0000002cH
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?SK_SummarizeCaller@@YG?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAX@Z ; SK_SummarizeCaller
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN42@CreateDXGI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN42@CreateDXGI:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4450 :   DXGI_LOG_CALL_2 ( L"                    CreateDXGIFactory        ", L"%s, %ph",

	push	eax
	lea	eax, DWORD PTR [edi+2048]
	push	eax
	push	OFFSET $SG357541
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T2[ebp+20]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4450 :   DXGI_LOG_CALL_2 ( L"                    CreateDXGIFactory        ", L"%s, %ph",

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN52@CreateDXGI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T2[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN52@CreateDXGI:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4450 :   DXGI_LOG_CALL_2 ( L"                    CreateDXGIFactory        ", L"%s, %ph",

	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN3@CreateDXGI:
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	esi, DWORD PTR ?SK_D3D11_init_tid@@3JC	; SK_D3D11_init_tid
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4453 :   if ( ReadAcquire (&SK_D3D11_init_tid)  != static_cast <LONG> (GetCurrentThreadId ()) &&

	mov	edi, DWORD PTR __imp__GetCurrentThreadId@0
	call	edi
	cmp	esi, eax
	je	SHORT $LN4@CreateDXGI
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	esi, DWORD PTR ?SK_D3D11_ansel_tid@@3JC	; SK_D3D11_ansel_tid
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4453 :   if ( ReadAcquire (&SK_D3D11_init_tid)  != static_cast <LONG> (GetCurrentThreadId ()) &&

	call	edi
	cmp	esi, eax
	je	SHORT $LN4@CreateDXGI

; 4454 :        ReadAcquire (&SK_D3D11_ansel_tid) != static_cast <LONG> (GetCurrentThreadId ()) )
; 4455 :     WaitForInitDXGI ();

	call	?WaitForInitDXGI@@YAXXZ			; WaitForInitDXGI
$LN4@CreateDXGI:

; 4460 :   DXGI_CALL (ret, CreateDXGIFactory_Import (riid, ppFactory));

	push	DWORD PTR _ppFactory$[ebp]
	mov	BYTE PTR ?SK_DXGI_factory_init@@3_NA, 1	; SK_DXGI_factory_init
	push	DWORD PTR _riid$[ebp]
	call	DWORD PTR ?CreateDXGIFactory_Import@@3P6GJABU_GUID@@PAPAX@ZA ; CreateDXGIFactory_Import
	mov	esi, eax
	push	esi
	call	?SK_DescribeHRESULT@@YGPB_WJ@Z		; SK_DescribeHRESULT
	push	eax
	push	OFFSET $SG357543
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR _iname$[ebp+20]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4460 :   DXGI_CALL (ret, CreateDXGIFactory_Import (riid, ppFactory));

	add	esp, 12					; 0000000cH
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN86@CreateDXGI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR _iname$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN86@CreateDXGI:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4463 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?CreateDXGIFactory@@YGJABU_GUID@@PAPAX@Z$0:
	lea	ecx, DWORD PTR _iname$[ebp]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__ehhandler$?CreateDXGIFactory@@YGJABU_GUID@@PAPAX@Z:
	mov	eax, OFFSET __ehfuncinfo$?CreateDXGIFactory@@YGJABU_GUID@@PAPAX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CreateDXGIFactory@@YGJABU_GUID@@PAPAX@Z ENDP		; CreateDXGIFactory
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_new_fullscreen_desc$ = -252				; size = 20
$T2 = -232						; size = 24
_stub_desc$3 = -208					; size = 60
_iname$ = -148						; size = 24
_client$4 = -124					; size = 16
_new_desc1$ = -108					; size = 48
_stub_desc$3$ = -60					; size = 4
_pSwapChain$5 = -60					; size = 4
_stub_desc$7$ = -56					; size = 4
_stub_desc$6$ = -52					; size = 4
_stub_desc$13$ = -48					; size = 4
tv2056 = -44						; size = 4
_pSwapChain2$6 = -40					; size = 4
_pDev$7 = -36						; size = 4
_stub_desc$10$ = -32					; size = 4
_stub_desc$8$ = -28					; size = 4
_stub_desc$5$ = -24					; size = 4
tv2057 = -20						; size = 4
_pDevice1$8 = -20					; size = 4
_stub_desc$12$ = -16					; size = 4
tv1959 = -16						; size = 4
tv1957 = -16						; size = 4
tv1955 = -16						; size = 4
$T9 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_This$ = 8						; size = 4
_pDevice$ = 12						; size = 4
tv2032 = 15						; size = 1
_stub_desc$2$ = 16					; size = 4
_ret$1$ = 16						; size = 4
_pDesc$ = 16						; size = 4
_pRestrictToOutput$ = 20				; size = 4
_max_latency$1$ = 24					; size = 4
_desc$2$ = 24						; size = 4
_ppSwapChain$ = 24					; size = 4
?DXGIFactory2_CreateSwapChainForComposition_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z PROC ; DXGIFactory2_CreateSwapChainForComposition_Override

; 3953 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DXGIFactory2_CreateSwapChainForComposition_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 240				; 000000f0H
	push	esi

; 3954 :   std::wstring iname = SK_GetDXGIFactoryInterface (This);

	push	DWORD PTR _This$[ebp]
	lea	eax, DWORD PTR _iname$[ebp]
	push	eax
	call	?SK_GetDXGIFactoryInterface@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUIUnknown@@@Z ; SK_GetDXGIFactoryInterface

; 3957 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"CreateSwapChainForComposition         ",

	push	8192					; 00002000H
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??_U@YAPAXI@Z				; operator new[]
	mov	esi, eax
	add	esp, 12					; 0000000cH
	test	esi, esi
	je	SHORT $LN5@DXGIFactor
	push	8192					; 00002000H
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN6@DXGIFactor
$LN5@DXGIFactor:
	xor	esi, esi
$LN6@DXGIFactor:
	push	edi
	lea	edi, DWORD PTR [esi+2048]
	test	esi, esi
	je	$LN2@DXGIFactor
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR _iname$[ebp+20], 8

; 1621 : 		return (_Large_string_engaged()

	lea	eax, DWORD PTR _iname$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3957 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"CreateSwapChainForComposition         ",

	push	OFFSET $SG357050
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	cmovae	eax, DWORD PTR _iname$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3957 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"CreateSwapChainForComposition         ",

	push	eax
	push	OFFSET $SG357051
	push	esi
	call	__swprintf
	push	DWORD PTR _ppSwapChain$[ebp]
	push	DWORD PTR _pDesc$[ebp]
	push	DWORD PTR _pDevice$[ebp]
	push	OFFSET $SG357052
	push	edi
	call	__swprintf
	push	edi
	push	esi
	lea	eax, DWORD PTR [edi+2048]
	push	OFFSET $SG357053
	push	eax
	call	__swprintf
	mov	eax, DWORD PTR __$ReturnAddr$[ebp]
	add	esp, 52					; 00000034H
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?SK_SummarizeCaller@@YG?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAX@Z ; SK_SummarizeCaller
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN41@DXGIFactor
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN41@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3957 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"CreateSwapChainForComposition         ",

	push	eax
	lea	eax, DWORD PTR [edi+2048]
	push	eax
	push	OFFSET $SG357054
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T2[ebp+20]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3957 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"CreateSwapChainForComposition         ",

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN51@DXGIFactor

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
	push	eax
	push	DWORD PTR $T2[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN51@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3957 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"CreateSwapChainForComposition         ",

	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@DXGIFactor:

; 3958 :                        L"%ph, %ph, %ph",
; 3959 :                          pDevice, pDesc, ppSwapChain );
; 3960 : 
; 3961 :   HRESULT ret = E_FAIL;
; 3962 : 
; 3963 :   assert (pDesc != nullptr);
; 3964 : 
; 3965 :   DXGI_SWAP_CHAIN_DESC1           new_desc1           = *pDesc;

	mov	eax, DWORD PTR _pDesc$[ebp]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR _new_desc1$[ebp], xmm0
	movups	xmm0, XMMWORD PTR [eax+16]
	movups	XMMWORD PTR _new_desc1$[ebp+16], xmm0
	movups	xmm0, XMMWORD PTR [eax+32]
	movups	XMMWORD PTR _new_desc1$[ebp+32], xmm0
	xorps	xmm0, xmm0

; 3966 :   DXGI_SWAP_CHAIN_FULLSCREEN_DESC new_fullscreen_desc = {    };

	movups	XMMWORD PTR _new_fullscreen_desc$[ebp], xmm0

; 3295 :   WaitForInit ();

	call	?WaitForInitDXGI@@YAXXZ			; WaitForInitDXGI
	call	?WaitForInit@@YAXXZ			; WaitForInit

; 3296 : 
; 3297 :   DXGI_SWAP_CHAIN_DESC stub_desc  = {   }; // Stores common attributes between DESC and DESC1

	push	60					; 0000003cH
	lea	eax, DWORD PTR _stub_desc$3[ebp]
	push	0
	push	eax
	call	_memset

; 3298 :   bool                 translated = false;
; 3299 : 
; 3300 :   if (pDesc1 != nullptr)
; 3301 :   {
; 3302 :     if (pDesc == nullptr)
; 3303 :     {
; 3304 :       pDesc = &stub_desc;
; 3305 : 
; 3306 :       stub_desc.BufferCount                        = pDesc1->BufferCount;
; 3307 :       stub_desc.BufferUsage                        = pDesc1->BufferUsage;
; 3308 :       stub_desc.Flags                              = pDesc1->Flags;
; 3309 :       stub_desc.SwapEffect                         = pDesc1->SwapEffect;
; 3310 :       stub_desc.SampleDesc.Count                   = pDesc1->SampleDesc.Count;

	mov	ecx, DWORD PTR _new_desc1$[ebp+16]
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _new_desc1$[ebp+28]
	mov	esi, DWORD PTR _new_desc1$[ebp+44]

; 3311 :       stub_desc.SampleDesc.Quality                 = pDesc1->SampleDesc.Quality;
; 3312 :       stub_desc.BufferDesc.Format                  = pDesc1->Format;
; 3313 :       stub_desc.BufferDesc.Height                  = pDesc1->Height;

	mov	edi, DWORD PTR _new_desc1$[ebp+4]
	mov	DWORD PTR _stub_desc$6$[ebp], ecx
	mov	ecx, DWORD PTR _new_desc1$[ebp+20]
	mov	DWORD PTR _stub_desc$2$[ebp], eax
	mov	eax, DWORD PTR _new_desc1$[ebp+24]
	mov	DWORD PTR _stub_desc$7$[ebp], ecx
	mov	ecx, DWORD PTR _new_desc1$[ebp+8]
	mov	DWORD PTR _stub_desc$3$[ebp], eax
	mov	eax, DWORD PTR _new_desc1$[ebp+36]
	mov	DWORD PTR _stub_desc$8$[ebp], ecx

; 3314 :       stub_desc.BufferDesc.Width                   = pDesc1->Width;

	mov	ecx, DWORD PTR _new_desc1$[ebp]
	mov	DWORD PTR _stub_desc$5$[ebp], eax
	mov	DWORD PTR _stub_desc$10$[ebp], ecx

; 3338 :     dll_log.LogEx ( true,

	test	eax, eax
	jne	SHORT $LN127@DXGIFactor
	mov	edx, OFFSET ??_C@_1BA@EMGLPOHC@?$AAD?$AAi?$AAs?$AAc?$AAa?$AAr?$AAd?$AA?$AA@
	jmp	SHORT $LN122@DXGIFactor
$LN127@DXGIFactor:
	cmp	eax, 1
	jne	SHORT $LN125@DXGIFactor
	mov	edx, OFFSET ??_C@_1BG@MBNPLCBJ@?$AAS?$AAe?$AAq?$AAu?$AAe?$AAn?$AAt?$AAi?$AAa?$AAl?$AA?$AA@
	jmp	SHORT $LN122@DXGIFactor
$LN125@DXGIFactor:
	cmp	eax, 2
	jne	SHORT $LN123@DXGIFactor
	mov	edx, OFFSET ??_C@_1BE@BGMELJBK@?$AA?$DM?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?$DO?$AA?$AA@
	jmp	SHORT $LN122@DXGIFactor
$LN123@DXGIFactor:
	cmp	eax, 3
	jne	SHORT $LN121@DXGIFactor
	mov	edx, OFFSET ??_C@_1CA@DEGLGFCG@?$AAF?$AAl?$AAi?$AAp?$AA?5?$AAS?$AAe?$AAq?$AAu?$AAe?$AAn?$AAt?$AAi?$AAa?$AAl?$AA?$AA@
	jmp	SHORT $LN122@DXGIFactor
$LN121@DXGIFactor:
	cmp	eax, 4
	mov	DWORD PTR tv1955[ebp], OFFSET ??_C@_1BE@BGMELJBK@?$AA?$DM?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?$DO?$AA?$AA@
	mov	edx, OFFSET ??_C@_1BK@OJAHAHGF@?$AAF?$AAl?$AAi?$AAp?$AA?5?$AAD?$AAi?$AAs?$AAc?$AAa?$AAr?$AAd?$AA?$AA@
	cmovne	edx, DWORD PTR tv1955[ebp]
$LN122@DXGIFactor:
	mov	eax, DWORD PTR _stub_desc$3[ebp+20]
	test	eax, eax
	jne	SHORT $LN131@DXGIFactor
	mov	DWORD PTR tv2057[ebp], OFFSET ??_C@_1BI@DELFJJPB@?$AAU?$AAn?$AAs?$AAp?$AAe?$AAc?$AAi?$AAf?$AAi?$AAe?$AAd?$AA?$AA@
	jmp	SHORT $LN130@DXGIFactor
$LN131@DXGIFactor:
	cmp	eax, 1
	jne	SHORT $LN129@DXGIFactor
	mov	DWORD PTR tv2057[ebp], OFFSET ??_C@_1BI@JFLEIIEG@?$AAP?$AAr?$AAo?$AAg?$AAr?$AAe?$AAs?$AAs?$AAi?$AAv?$AAe?$AA?$AA@
	jmp	SHORT $LN130@DXGIFactor
$LN129@DXGIFactor:
	cmp	DWORD PTR _stub_desc$3[ebp+20], 2
	mov	eax, OFFSET ??_C@_1CA@MIMOHAAK@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAl?$AAa?$AAc?$AAe?$AAd?$AA?5?$AAE?$AAv?$AAe?$AAn?$AA?$AA@
	mov	DWORD PTR tv1957[ebp], OFFSET ??_C@_1BO@NBKANNIC@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAl?$AAa?$AAc?$AAe?$AAd?$AA?5?$AAO?$AAd?$AAd?$AA?$AA@
	cmovne	eax, DWORD PTR tv1957[ebp]
	mov	DWORD PTR tv2057[ebp], eax
$LN130@DXGIFactor:
	cmp	DWORD PTR _stub_desc$3[ebp+24], 0
	jne	SHORT $LN133@DXGIFactor
	mov	DWORD PTR tv2056[ebp], OFFSET ??_C@_1BI@DELFJJPB@?$AAU?$AAn?$AAs?$AAp?$AAe?$AAc?$AAi?$AAf?$AAi?$AAe?$AAd?$AA?$AA@
	jmp	SHORT $LN134@DXGIFactor
$LN133@DXGIFactor:
	cmp	DWORD PTR _stub_desc$3[ebp+24], 1
	mov	eax, OFFSET ??_C@_1BC@NODLAKGH@?$AAC?$AAe?$AAn?$AAt?$AAe?$AAr?$AAe?$AAd?$AA?$AA@
	mov	DWORD PTR tv1959[ebp], OFFSET ??_C@_1BE@OKCKFGLA@?$AAS?$AAt?$AAr?$AAe?$AAt?$AAc?$AAh?$AAe?$AAd?$AA?$AA@
	cmovne	eax, DWORD PTR tv1959[ebp]
	mov	DWORD PTR tv2056[ebp], eax
$LN134@DXGIFactor:
	mov	eax, DWORD PTR _stub_desc$3[ebp+12]
	test	eax, eax
	mov	DWORD PTR _stub_desc$12$[ebp], eax
	mov	eax, DWORD PTR _stub_desc$3[ebp+8]
	mov	DWORD PTR _stub_desc$13$[ebp], eax
	je	SHORT $LN135@DXGIFactor
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	eax, DWORD PTR _stub_desc$3[ebp+12]
	cvtpd2ps xmm1, xmm0
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	divss	xmm1, xmm0
	jmp	SHORT $LN144@DXGIFactor
$LN135@DXGIFactor:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits

; 1119 : 		return (__builtin_nanf("0"));

	movss	xmm1, DWORD PTR __real@7fc00000
$LN144@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3338 :     dll_log.LogEx ( true,

	push	edx
	mov	edx, DWORD PTR _stub_desc$2$[ebp]
	push	esi
	push	edx
	push	OFFSET ??_C@_1BC@PMICBOA@?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAe?$AAd?$AA?$AA@
	push	DWORD PTR tv2057[ebp]
	cvtps2pd xmm0, xmm1
	push	DWORD PTR tv2056[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	edi
	push	ecx
	push	OFFSET ??_C@_1BAE@FEHGBMOO@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AAS?$AAw?$AAa?$AAp?$AAC?$AAh?$AAa?$AAi?$AAn?$AA?3?$AA?5?$AA?$CI?$AA?$CF?$AAl?$AAu?$AAx?$AA?$CF?$AAl@
	push	1
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	add	esp, 52					; 00000034H

; 3339 :       L"[   DXGI   ]  SwapChain: (%lux%lu @ %4.1f Hz - Scaling: %s - Scanlines: %s) - {%s}"
; 3340 :       L" [%lu Buffers] :: Flags=0x%04X, SwapEffect: %s\n",
; 3341 :       pDesc->BufferDesc.Width,
; 3342 :       pDesc->BufferDesc.Height,
; 3343 :       pDesc->BufferDesc.RefreshRate.Denominator != 0 ?
; 3344 :         static_cast <float> (pDesc->BufferDesc.RefreshRate.Numerator) /
; 3345 :         static_cast <float> (pDesc->BufferDesc.RefreshRate.Denominator) :
; 3346 :           std::numeric_limits <float>::quiet_NaN (),
; 3347 :       pDesc->BufferDesc.Scaling == DXGI_MODE_SCALING_UNSPECIFIED ?
; 3348 :         L"Unspecified" :
; 3349 :         pDesc->BufferDesc.Scaling == DXGI_MODE_SCALING_CENTERED ?
; 3350 :           L"Centered" :
; 3351 :           L"Stretched",
; 3352 :       pDesc->BufferDesc.ScanlineOrdering == DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED ?
; 3353 :         L"Unspecified" :
; 3354 :         pDesc->BufferDesc.ScanlineOrdering == DXGI_MODE_SCANLINE_ORDER_PROGRESSIVE ?
; 3355 :           L"Progressive" :
; 3356 :           pDesc->BufferDesc.ScanlineOrdering == DXGI_MODE_SCANLINE_ORDER_UPPER_FIELD_FIRST ?
; 3357 :             L"Interlaced Even" :
; 3358 :             L"Interlaced Odd",
; 3359 :       pDesc->Windowed ? L"Windowed" : L"Fullscreen",
; 3360 :       pDesc->BufferCount,
; 3361 :       pDesc->Flags,
; 3362 :       pDesc->SwapEffect         == 0 ?
; 3363 :         L"Discard" :
; 3364 :         pDesc->SwapEffect       == 1 ?
; 3365 :           L"Sequential" :
; 3366 :           pDesc->SwapEffect     == 2 ?
; 3367 :             L"<Unknown>" :
; 3368 :             pDesc->SwapEffect   == 3 ?
; 3369 :               L"Flip Sequential" :
; 3370 :               pDesc->SwapEffect == 4 ?
; 3371 :                 L"Flip Discard" :
; 3372 :                 L"<Unknown>" );
; 3373 : 
; 3374 :     // Set things up to make the swap chain Alt+Enter friendly
; 3375 :     if (bAlwaysAllowFullscreen && pDesc->Windowed)

	cmp	BYTE PTR ?bAlwaysAllowFullscreen@@3_NA, 0 ; bAlwaysAllowFullscreen
	je	SHORT $LN85@DXGIFactor

; 3376 :     {
; 3377 :       pDesc->Flags                             |= DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

	or	esi, 2

; 3378 :       pDesc->Windowed                           = true;
; 3379 :       pDesc->BufferDesc.RefreshRate.Denominator = 0;

	xor	eax, eax
	mov	DWORD PTR _stub_desc$12$[ebp], eax

; 3380 :       pDesc->BufferDesc.RefreshRate.Numerator   = 0;

	mov	DWORD PTR _stub_desc$13$[ebp], eax
$LN85@DXGIFactor:

; 3381 :     }
; 3382 : 
; 3383 :     if (pDesc->Windowed && config.window.borderless && (! config.window.fullscreen))

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+728, 0
	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+760
	mov	edx, DWORD PTR ?config@@3Usk_config_t@@A+756
	je	SHORT $LN87@DXGIFactor
	cmp	BYTE PTR ?config@@3Usk_config_t@@A+754, 0
	jne	SHORT $LN87@DXGIFactor
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 425  :         bool isZero (void) { return x == 0 && y == 0; };

	test	edx, edx
	jne	SHORT $LN148@DXGIFactor
	test	eax, eax
	je	SHORT $LN89@DXGIFactor
$LN148@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3387 :         pDesc->BufferDesc.Width  = config.window.res.override.x;

	mov	ecx, edx

; 3388 :         pDesc->BufferDesc.Height = config.window.res.override.y;

	mov	edi, eax
	mov	DWORD PTR _stub_desc$10$[ebp], ecx
$LN87@DXGIFactor:
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 425  :         bool isZero (void) { return x == 0 && y == 0; };

	test	edx, edx
	jne	SHORT $LN152@DXGIFactor
	test	eax, eax
	je	SHORT $LN89@DXGIFactor
$LN152@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3403 :       pDesc->BufferDesc.Width  = config.window.res.override.x;

	mov	ecx, edx

; 3404 :       pDesc->BufferDesc.Height = config.window.res.override.y;

	mov	edi, eax
	mov	DWORD PTR _stub_desc$10$[ebp], ecx
$LN89@DXGIFactor:

; 3405 :     }
; 3406 : 
; 3407 : 
; 3408 :     if (config.render.dxgi.safe_fullscreen)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+488, 0
	je	SHORT $LN90@DXGIFactor

; 3409 :       pDesc->Flags |= DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

	or	esi, 2
$LN90@DXGIFactor:

; 3410 : 
; 3411 :     if (request_mode_change == mode_change_request_e::Fullscreen)

	cmp	DWORD PTR ?request_mode_change@@3W4mode_change_request_e@@A, 1 ; request_mode_change
	jne	SHORT $LN323@DXGIFactor

; 3412 :     {
; 3413 :       dll_log.Log ( L"[   DXGI   ]  >> User-Requested Mode Change: Fullscreen" );

	push	OFFSET ??_C@_1HA@INGGDHHB@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAU?$AAs?$AAe?$AAr?$AA?9?$AAR?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AAe?$AAd?$AA?5@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8

; 3414 :       pDesc->Windowed = FALSE;

	xor	eax, eax

; 3415 :       pDesc->Flags   |= DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

	or	esi, 2
	jmp	SHORT $LN91@DXGIFactor
$LN323@DXGIFactor:
	mov	eax, 1
$LN91@DXGIFactor:

; 3416 :     }
; 3417 : 
; 3418 :     if (config.display.force_fullscreen && pDesc->Windowed)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+500, 0
	je	SHORT $LN92@DXGIFactor
	test	eax, eax
	je	SHORT $LN92@DXGIFactor

; 3419 :     {
; 3420 :       dll_log.Log ( L"[   DXGI   ]  >> Display Override "

	push	OFFSET ??_C@_1JG@HCAIICBG@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAD?$AAi?$AAs?$AAp?$AAl?$AAa?$AAy?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8

; 3421 :                     L"(Requested: Windowed, Using: Fullscreen)" );
; 3422 :       pDesc->Flags   |= DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

	or	esi, 2

; 3423 :       pDesc->Windowed = FALSE;

	jmp	SHORT $LN94@DXGIFactor
$LN92@DXGIFactor:

; 3424 :     }
; 3425 : 
; 3426 :     else if (config.display.force_windowed)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+501, 0
	je	SHORT $LN94@DXGIFactor

; 3427 :     {
; 3428 :       dll_log.Log ( L"[   DXGI   ]  >> Display Override "

	push	OFFSET ??_C@_1JG@LPALCGFK@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAD?$AAi?$AAs?$AAp?$AAl?$AAa?$AAy?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8
$LN94@DXGIFactor:

; 3429 :                     L"(Requested: Fullscreen, Using: Windowed)" );
; 3430 :       pDesc->Windowed = TRUE;
; 3431 :     }
; 3432 : 
; 3433 : #ifdef _WIN64
; 3434 :     if (! bFlipMode)
; 3435 :       bFlipMode =
; 3436 :         ( dxgi_caps.present.flip_sequential && (
; 3437 :           ( ! lstrcmpW (SK_GetHostApp (), L"Fallout4.exe")) ||
; 3438 :             SK_DS3_UseFlipMode ()        ) );
; 3439 : 
; 3440 :     if (! lstrcmpW (SK_GetHostApp (), L"Fallout4.exe"))
; 3441 :     {
; 3442 :       if (bFlipMode)
; 3443 :           bFlipMode = (! SK_FO4_IsFullscreen ()) && SK_FO4_UseFlipMode ();
; 3444 :     }
; 3445 : 
; 3446 :     else
; 3447 : #endif
; 3448 :     {
; 3449 :       // If forcing flip-model, then force multisampling off
; 3450 :       if (config.render.framerate.flip_discard)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+416, 0
	je	SHORT $LN318@DXGIFactor

; 3451 :       {
; 3452 :         bFlipMode = dxgi_caps.present.flip_sequential;

	mov	al, BYTE PTR ?dxgi_caps@@3Udxgi_caps_t@@A+2
	mov	BYTE PTR ?bFlipMode@@3_NA, al		; bFlipMode

; 3453 :         pDesc->SampleDesc.Count = 1; pDesc->SampleDesc.Quality = 0;
; 3454 : 
; 3455 :         // Format overrides must be performed in certain cases (sRGB / 10:10:10:2)
; 3456 :         switch (pDesc->BufferDesc.Format)

	mov	eax, DWORD PTR _stub_desc$8$[ebp]
	add	eax, -23				; ffffffe9H
	mov	DWORD PTR _stub_desc$6$[ebp], 1
	mov	DWORD PTR _stub_desc$7$[ebp], 0
	cmp	eax, 68					; 00000044H
	ja	SHORT $LN318@DXGIFactor
	movzx	eax, BYTE PTR $LN316@DXGIFactor[eax]
	jmp	DWORD PTR $LN329@DXGIFactor[eax*4]
$LN96@DXGIFactor:

; 3457 :         {
; 3458 :           case DXGI_FORMAT_B8G8R8A8_UNORM_SRGB:
; 3459 :             pDesc->BufferDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;

	mov	DWORD PTR _stub_desc$8$[ebp], 87	; 00000057H

; 3460 :             dll_log.Log ( L"[ DXGI 1.2 ]  >> sRGB (B8G8R8A8) Override Required to Enable Flip Model" );

	push	OFFSET ??_C@_1JA@NDGFBELE@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA2?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAs?$AAR?$AAG?$AAB?$AA?5?$AA?$CI?$AAB?$AA8?$AAG?$AA8?$AAR?$AA8?$AAA?$AA8?$AA?$CJ@

; 3461 :             break;

	jmp	SHORT $LN325@DXGIFactor
$LN97@DXGIFactor:

; 3462 :           case DXGI_FORMAT_R8G8B8A8_UNORM_SRGB:
; 3463 :             pDesc->BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
; 3464 :             dll_log.Log ( L"[ DXGI 1.2 ]  >> sRGB (R8G8B8A8) Override Required to Enable Flip Model" );

	push	OFFSET ??_C@_1JA@CCHCBLHJ@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA2?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAs?$AAR?$AAG?$AAB?$AA?5?$AA?$CI?$AAR?$AA8?$AAG?$AA8?$AAB?$AA8?$AAA?$AA8?$AA?$CJ@

; 3465 :             break;

	jmp	SHORT $LN326@DXGIFactor
$LN98@DXGIFactor:

; 3469 :             dll_log.Log ( L"[ DXGI 1.2 ]  >> RGBA 10:10:10:2 Override (to 8:8:8:8) Required to Enable Flip Model" );

	push	OFFSET ??_C@_1KK@LPPCBMFA@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA2?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAR?$AAG?$AAB?$AAA?$AA?5?$AA1?$AA0?$AA?3?$AA1?$AA0?$AA?3?$AA1?$AA0?$AA?3?$AA2@
$LN326@DXGIFactor:

; 3466 :           case DXGI_FORMAT_R10G10B10A2_UNORM:
; 3467 :           case DXGI_FORMAT_R10G10B10A2_TYPELESS:
; 3468 :             pDesc->BufferDesc.Format =  DXGI_FORMAT_R8G8B8A8_UNORM;

	mov	DWORD PTR _stub_desc$8$[ebp], 28	; 0000001cH
$LN325@DXGIFactor:

; 3469 :             dll_log.Log ( L"[ DXGI 1.2 ]  >> RGBA 10:10:10:2 Override (to 8:8:8:8) Required to Enable Flip Model" );

	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8
$LN318@DXGIFactor:

; 3470 :             break;
; 3471 :         }
; 3472 :       }
; 3473 :     }
; 3474 : 
; 3475 :     if (       config.render.framerate.buffer_count != -1                  &&
; 3476 :          (UINT)config.render.framerate.buffer_count !=  pDesc->BufferCount &&

	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+408
	cmp	ecx, -1
	je	SHORT $LN99@DXGIFactor
	mov	eax, DWORD PTR _stub_desc$2$[ebp]
	cmp	ecx, eax
	je	SHORT $LN99@DXGIFactor
	test	eax, eax
	je	SHORT $LN99@DXGIFactor

; 3477 :          pDesc->BufferCount                         !=  0 )
; 3478 :     {
; 3479 :       pDesc->BufferCount = config.render.framerate.buffer_count;

	mov	eax, ecx

; 3480 :       dll_log.Log (L"[   DXGI   ]  >> Buffer Count Override: %lu buffers", pDesc->BufferCount);

	push	eax
	push	OFFSET ??_C@_1GI@GAEBCHMN@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AAO?$AAv@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	mov	DWORD PTR _stub_desc$2$[ebp], eax
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+408
	add	esp, 12					; 0000000cH
$LN99@DXGIFactor:

; 3481 :     }
; 3482 : 
; 3483 :     if ( config.render.framerate.flip_discard && dxgi_caps.swapchain.allow_tearing )

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+416, 0
	je	SHORT $LN100@DXGIFactor
	cmp	DWORD PTR ?dxgi_caps@@3Udxgi_caps_t@@A+8, 0
	je	SHORT $LN100@DXGIFactor

; 3484 :     {
; 3485 :       pDesc->Flags |= DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING;
; 3486 :       dll_log.Log ( L"[ DXGI 1.5 ]  >> Tearing Option:  Enable" );

	push	OFFSET ??_C@_1FC@PILPBEPG@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAT?$AAe?$AAa?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAO?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?3@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	or	esi, 2048				; 00000800H
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+408
	add	esp, 8
$LN100@DXGIFactor:

; 3487 :       pDesc->Windowed = TRUE;
; 3488 :     }
; 3489 : 
; 3490 :     if ( config.render.dxgi.scaling_mode != -1 &&

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+472
	cmp	eax, -1
	je	SHORT $LN101@DXGIFactor
	cmp	DWORD PTR _stub_desc$3[ebp+24], eax
	je	SHORT $LN101@DXGIFactor

; 3491 :           pDesc->BufferDesc.Scaling      !=
; 3492 :             (DXGI_MODE_SCALING)config.render.dxgi.scaling_mode )
; 3493 :     {
; 3494 :       dll_log.Log ( L"[   DXGI   ]  >> Scaling Override "

	push	eax
	call	?SK_DXGI_DescribeScalingMode@@YAPB_WW4DXGI_MODE_SCALING@@@Z ; SK_DXGI_DescribeScalingMode
	add	esp, 4
	push	eax
	push	DWORD PTR _stub_desc$3[ebp+24]
	call	?SK_DXGI_DescribeScalingMode@@YAPB_WW4DXGI_MODE_SCALING@@@Z ; SK_DXGI_DescribeScalingMode
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_1HK@PGANLAKP@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAS?$AAc?$AAa?$AAl?$AAi?$AAn?$AAg?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+408
	add	esp, 16					; 00000010H
$LN101@DXGIFactor:

; 3495 :                     L"(Requested: %s, Using: %s)",
; 3496 :                       SK_DXGI_DescribeScalingMode (
; 3497 :                         pDesc->BufferDesc.Scaling
; 3498 :                       ),
; 3499 :                         SK_DXGI_DescribeScalingMode (
; 3500 :                           (DXGI_MODE_SCALING)config.render.dxgi.scaling_mode
; 3501 :                         )
; 3502 :                   );
; 3503 : 
; 3504 :       pDesc->BufferDesc.Scaling =
; 3505 :         (DXGI_MODE_SCALING)config.render.dxgi.scaling_mode;
; 3506 :     }
; 3507 : 
; 3508 :     if ( config.render.dxgi.scanline_order != -1 &&

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+476
	cmp	eax, -1
	je	SHORT $LN102@DXGIFactor
	cmp	DWORD PTR _stub_desc$3[ebp+20], eax
	je	SHORT $LN102@DXGIFactor

; 3509 :           pDesc->BufferDesc.ScanlineOrdering      !=
; 3510 :             (DXGI_MODE_SCANLINE_ORDER)config.render.dxgi.scanline_order )
; 3511 :     {
; 3512 :       dll_log.Log ( L"[   DXGI   ]  >> Scanline Override "

	push	eax
	call	?SK_DXGI_DescribeScanlineOrder@@YAPB_WW4DXGI_MODE_SCANLINE_ORDER@@@Z ; SK_DXGI_DescribeScanlineOrder
	add	esp, 4
	push	eax
	push	DWORD PTR _stub_desc$3[ebp+20]
	call	?SK_DXGI_DescribeScanlineOrder@@YAPB_WW4DXGI_MODE_SCANLINE_ORDER@@@Z ; SK_DXGI_DescribeScanlineOrder
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_1HM@EKHBGJHP@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAS?$AAc?$AAa?$AAn?$AAl?$AAi?$AAn?$AAe?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+408
	add	esp, 16					; 00000010H
$LN102@DXGIFactor:

; 3513 :                     L"(Requested: %s, Using: %s)",
; 3514 :                       SK_DXGI_DescribeScanlineOrder (
; 3515 :                         pDesc->BufferDesc.ScanlineOrdering
; 3516 :                       ),
; 3517 :                         SK_DXGI_DescribeScanlineOrder (
; 3518 :                           (DXGI_MODE_SCANLINE_ORDER)config.render.dxgi.scanline_order
; 3519 :                         )
; 3520 :                   );
; 3521 : 
; 3522 :       pDesc->BufferDesc.ScanlineOrdering =
; 3523 :         (DXGI_MODE_SCANLINE_ORDER)config.render.dxgi.scanline_order;
; 3524 :     }
; 3525 : 
; 3526 :     if ( config.render.framerate.refresh_rate != -1 &&

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+424
	cmp	eax, -1
	je	SHORT $LN103@DXGIFactor
	mov	edx, DWORD PTR _stub_desc$13$[ebp]
	cmp	edx, eax
	je	SHORT $LN103@DXGIFactor

; 3527 :          pDesc->BufferDesc.RefreshRate.Numerator != (UINT)config.render.framerate.refresh_rate )
; 3528 :     {
; 3529 :       dll_log.Log ( L"[   DXGI   ]  >> Refresh Override "

	mov	ecx, DWORD PTR _stub_desc$12$[ebp]
	test	ecx, ecx
	je	SHORT $LN137@DXGIFactor
	movd	xmm0, edx
	cvtdq2pd xmm0, xmm0
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	cvtpd2ps xmm1, xmm0
	movd	xmm0, ecx
	cvtdq2pd xmm0, xmm0
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	cvtpd2ps xmm0, xmm0
	divss	xmm1, xmm0
	jmp	SHORT $LN155@DXGIFactor
$LN137@DXGIFactor:
	movss	xmm1, DWORD PTR __real@7fc00000
$LN155@DXGIFactor:
	push	eax
	cvtps2pd xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_1HM@GOOAFJFG@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAR?$AAe?$AAf?$AAr?$AAe?$AAs?$AAh?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+408
	add	esp, 20					; 00000014H
$LN103@DXGIFactor:

; 3530 :                     L"(Requested: %f, Using: %li)",
; 3531 :                  pDesc->BufferDesc.RefreshRate.Denominator != 0 ?
; 3532 :          static_cast <float> (pDesc->BufferDesc.RefreshRate.Numerator) /
; 3533 :          static_cast <float> (pDesc->BufferDesc.RefreshRate.Denominator) :
; 3534 :                      std::numeric_limits <float>::quiet_NaN (),
; 3535 :                         config.render.framerate.refresh_rate
; 3536 :                   );
; 3537 : 
; 3538 :       pDesc->BufferDesc.RefreshRate.Numerator   = config.render.framerate.refresh_rate;
; 3539 :       pDesc->BufferDesc.RefreshRate.Denominator = 1;
; 3540 :     }
; 3541 : 
; 3542 :     bWait = bFlipMode && dxgi_caps.present.waitable;

	cmp	BYTE PTR ?bFlipMode@@3_NA, 0		; bFlipMode
	je	SHORT $LN141@DXGIFactor
	cmp	BYTE PTR ?dxgi_caps@@3Udxgi_caps_t@@A+4, 0
	je	SHORT $LN141@DXGIFactor

; 3543 : 
; 3544 :     // We cannot change the swapchain parameters if this is used...
; 3545 :     bWait = bWait && config.render.framerate.swapchain_wait > 0;

	cmp	DWORD PTR ?config@@3Usk_config_t@@A+420, 0
	jle	SHORT $LN141@DXGIFactor
	mov	dl, 1
	jmp	SHORT $LN327@DXGIFactor
$LN141@DXGIFactor:
	xor	dl, dl
$LN327@DXGIFactor:

; 3546 : 
; 3547 : #ifdef _WIN64
; 3548 :     if (! lstrcmpW (SK_GetHostApp (), L"DarkSoulsIII.exe"))
; 3549 :     {
; 3550 :       if (SK_DS3_IsBorderless ())
; 3551 :         pDesc->Flags &= ~DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
; 3552 :     }
; 3553 : #endif
; 3554 : 
; 3555 :     if (bFlipMode)

	cmp	BYTE PTR ?bFlipMode@@3_NA, 0		; bFlipMode
	mov	BYTE PTR ?bWait@@3_NA, dl		; bWait
	je	SHORT $LN104@DXGIFactor

; 3556 :     {
; 3557 :       if (bWait)

	test	dl, dl
	je	SHORT $LN106@DXGIFactor

; 3558 :         pDesc->Flags |= DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT;

	or	esi, 64					; 00000040H
$LN106@DXGIFactor:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 3743 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	ecx, 3
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3561 :       config.render.framerate.buffer_count =

	mov	DWORD PTR $T9[ebp], 3
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 3743 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	ecx, DWORD PTR $T9[ebp]
	mov	eax, OFFSET ?config@@3Usk_config_t@@A+408
	cmovle	eax, ecx
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3564 :       if (config.render.framerate.flip_discard &&

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+416, 0
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR ?config@@3Usk_config_t@@A+408, ecx
	je	SHORT $LN107@DXGIFactor
	cmp	BYTE PTR ?dxgi_caps@@3Udxgi_caps_t@@A+3, 0
	je	SHORT $LN107@DXGIFactor

; 3565 :           dxgi_caps.present.flip_discard)
; 3566 :         pDesc->SwapEffect  = DXGI_SWAP_EFFECT_FLIP_DISCARD;

	mov	eax, 4
	mov	DWORD PTR _stub_desc$5$[ebp], eax

; 3567 :       else

	jmp	SHORT $LN109@DXGIFactor
$LN107@DXGIFactor:

; 3568 :         pDesc->SwapEffect  = DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL;

	mov	DWORD PTR _stub_desc$5$[ebp], 3
	jmp	SHORT $LN109@DXGIFactor
$LN104@DXGIFactor:

; 3569 :     }
; 3570 : 
; 3571 :     else if ( pDesc->SwapEffect != DXGI_SWAP_EFFECT_FLIP_DISCARD &&

	mov	eax, DWORD PTR _stub_desc$5$[ebp]
	cmp	eax, 4
	je	SHORT $LN109@DXGIFactor
	cmp	eax, 3
	je	SHORT $LN109@DXGIFactor

; 3572 :               pDesc->SwapEffect != DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL )
; 3573 :     {
; 3574 :       // Resort to triple-buffering if flip mode is not available
; 3575 :       if (config.render.framerate.buffer_count > 3)

	mov	eax, 3

; 3576 :         config.render.framerate.buffer_count = 3;
; 3577 : 
; 3578 :       pDesc->SwapEffect = DXGI_SWAP_EFFECT_DISCARD;

	mov	DWORD PTR _stub_desc$5$[ebp], 0
	cmp	ecx, eax
	cmovg	ecx, eax
	mov	DWORD PTR ?config@@3Usk_config_t@@A+408, ecx
$LN109@DXGIFactor:

; 3579 :     }
; 3580 : 
; 3581 :     if (config.render.framerate.buffer_count > 0)

	mov	eax, DWORD PTR _stub_desc$2$[ebp]
	test	ecx, ecx
	cmovg	eax, ecx

; 3582 :       pDesc->BufferCount = config.render.framerate.buffer_count;
; 3583 : 
; 3584 :     // We cannot switch modes on a waitable swapchain
; 3585 :     if (bFlipMode && bWait)

	cmp	BYTE PTR ?bFlipMode@@3_NA, 0		; bFlipMode
	mov	DWORD PTR _stub_desc$2$[ebp], eax
	je	SHORT $LN112@DXGIFactor
	test	dl, dl
	je	SHORT $LN112@DXGIFactor

; 3586 :     {
; 3587 :       pDesc->Flags |=  DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT;
; 3588 :       pDesc->Flags &= ~DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

	and	esi, -3					; fffffffdH
	or	esi, 64					; 00000040H
$LN112@DXGIFactor:

; 3592 :   dll_log.Log ( L"[ DXGI 1.2 ] >> Using %s Presentation Model  [Waitable: %s - %li ms]",

	xor	eax, eax
	mov	ecx, OFFSET ??_C@_15BICKNCBF@?$AAN?$AAo?$AA?$AA@
	test	dl, dl
	cmovne	eax, DWORD PTR ?config@@3Usk_config_t@@A+420
	push	eax
	mov	eax, OFFSET ??_C@_17PBAHFJOA@?$AAY?$AAe?$AAs?$AA?$AA@
	cmove	eax, ecx
	cmp	BYTE PTR ?bFlipMode@@3_NA, 0		; bFlipMode
	push	eax
	mov	ecx, OFFSET ??_C@_1BI@PKCOFIGO@?$AAT?$AAr?$AAa?$AAd?$AAi?$AAt?$AAi?$AAo?$AAn?$AAa?$AAl?$AA?$AA@
	mov	eax, OFFSET ??_C@_19EMFBKLJE@?$AAF?$AAl?$AAi?$AAp?$AA?$AA@
	cmove	eax, ecx
	push	eax
	push	OFFSET ??_C@_1IK@KCJJDMDA@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA2?$AA?5?$AA?$FN?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAU?$AAs?$AAi?$AAn?$AAg?$AA?5?$AA?$CF?$AAs?$AA?5?$AAP?$AAr?$AAe?$AAs?$AAe?$AAn?$AAt@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 251  :           bool isZero (void) { return x == 0 && y == 0; };

	mov	edx, DWORD PTR ?config@@3Usk_config_t@@A+460
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3592 :   dll_log.Log ( L"[ DXGI 1.2 ] >> Using %s Presentation Model  [Waitable: %s - %li ms]",

	add	esp, 20					; 00000014H
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 251  :           bool isZero (void) { return x == 0 && y == 0; };

	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+464
	test	edx, edx
	jne	SHORT $LN162@DXGIFactor
	test	ecx, ecx
	je	SHORT $LN321@DXGIFactor
$LN162@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3598 :   if ((! config.render.dxgi.res.max.isZero ()) && pDesc->BufferDesc.Width > config.render.dxgi.res.max.x)

	mov	eax, DWORD PTR _stub_desc$10$[ebp]
	cmp	eax, edx
	cmova	eax, edx
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 251  :           bool isZero (void) { return x == 0 && y == 0; };

	test	edx, edx
	jne	SHORT $LN166@DXGIFactor
	test	ecx, ecx
	je	SHORT $LN114@DXGIFactor
$LN166@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3600 :   if ((! config.render.dxgi.res.max.isZero ()) && pDesc->BufferDesc.Height > config.render.dxgi.res.max.y)

	cmp	edi, ecx
	cmova	edi, ecx
	jmp	SHORT $LN114@DXGIFactor
$LN321@DXGIFactor:
	mov	eax, DWORD PTR _stub_desc$10$[ebp]
$LN114@DXGIFactor:
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 246  :           bool isZero (void) { return x == 0 && y == 0; };

	mov	edx, DWORD PTR ?config@@3Usk_config_t@@A+452
	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+456
	test	edx, edx
	jne	SHORT $LN170@DXGIFactor
	test	ecx, ecx
	jne	SHORT $LN174@DXGIFactor
	jmp	SHORT $LN313@DXGIFactor
$LN170@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3603 :   if ((! config.render.dxgi.res.min.isZero ()) && pDesc->BufferDesc.Width < config.render.dxgi.res.min.x)

	cmp	eax, edx
	cmovb	eax, edx
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 246  :           bool isZero (void) { return x == 0 && y == 0; };

	test	edx, edx
	jne	SHORT $LN174@DXGIFactor
	test	ecx, ecx
	je	SHORT $LN313@DXGIFactor
$LN174@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3605 :   if ((! config.render.dxgi.res.min.isZero ()) && pDesc->BufferDesc.Height < config.render.dxgi.res.min.y)

	cmp	edi, ecx
	cmovb	edi, ecx
$LN313@DXGIFactor:

; 3606 :     pDesc->BufferDesc.Height = config.render.dxgi.res.min.y;
; 3607 : 
; 3608 : 
; 3609 :   if (translated)
; 3610 :   {
; 3611 :     pDesc1->BufferCount                        = pDesc->BufferCount;
; 3612 :     pDesc1->BufferUsage                        = pDesc->BufferUsage;

	mov	ecx, DWORD PTR _stub_desc$3$[ebp]
	mov	edx, DWORD PTR _stub_desc$2$[ebp]

; 3618 :     pDesc1->Height                             = pDesc->BufferDesc.Height;

	mov	DWORD PTR _new_desc1$[ebp+4], edi

; 3967 : 
; 3968 :   HWND hWnd = nullptr;
; 3969 :   SK_DXGI_CreateSwapChain_PreInit (nullptr, &new_desc1, hWnd, nullptr);
; 3970 : 
; 3971 : 
; 3972 :   DXGI_CALL (ret, CreateSwapChainForComposition_Original ( This, pDevice, &new_desc1,

	mov	edi, DWORD PTR _ppSwapChain$[ebp]
	push	edi
	push	DWORD PTR _pRestrictToOutput$[ebp]

; 3612 :     pDesc1->BufferUsage                        = pDesc->BufferUsage;

	mov	DWORD PTR _new_desc1$[ebp+24], ecx

; 3613 :     pDesc1->Flags                              = pDesc->Flags;
; 3614 :     pDesc1->SwapEffect                         = pDesc->SwapEffect;

	mov	ecx, DWORD PTR _stub_desc$5$[ebp]

; 3619 :     pDesc1->Width                              = pDesc->BufferDesc.Width;

	mov	DWORD PTR _new_desc1$[ebp], eax

; 3967 : 
; 3968 :   HWND hWnd = nullptr;
; 3969 :   SK_DXGI_CreateSwapChain_PreInit (nullptr, &new_desc1, hWnd, nullptr);
; 3970 : 
; 3971 : 
; 3972 :   DXGI_CALL (ret, CreateSwapChainForComposition_Original ( This, pDevice, &new_desc1,

	lea	eax, DWORD PTR _new_desc1$[ebp]

; 3614 :     pDesc1->SwapEffect                         = pDesc->SwapEffect;

	mov	DWORD PTR _new_desc1$[ebp+36], ecx

; 3615 :     pDesc1->SampleDesc.Count                   = pDesc->SampleDesc.Count;

	mov	ecx, DWORD PTR _stub_desc$6$[ebp]

; 3967 : 
; 3968 :   HWND hWnd = nullptr;
; 3969 :   SK_DXGI_CreateSwapChain_PreInit (nullptr, &new_desc1, hWnd, nullptr);
; 3970 : 
; 3971 : 
; 3972 :   DXGI_CALL (ret, CreateSwapChainForComposition_Original ( This, pDevice, &new_desc1,

	push	eax
	push	DWORD PTR _pDevice$[ebp]

; 3615 :     pDesc1->SampleDesc.Count                   = pDesc->SampleDesc.Count;

	mov	DWORD PTR _new_desc1$[ebp+16], ecx

; 3616 :     pDesc1->SampleDesc.Quality                 = pDesc->SampleDesc.Quality;

	mov	ecx, DWORD PTR _stub_desc$7$[ebp]

; 3967 : 
; 3968 :   HWND hWnd = nullptr;
; 3969 :   SK_DXGI_CreateSwapChain_PreInit (nullptr, &new_desc1, hWnd, nullptr);
; 3970 : 
; 3971 : 
; 3972 :   DXGI_CALL (ret, CreateSwapChainForComposition_Original ( This, pDevice, &new_desc1,

	push	DWORD PTR _This$[ebp]

; 3616 :     pDesc1->SampleDesc.Quality                 = pDesc->SampleDesc.Quality;

	mov	DWORD PTR _new_desc1$[ebp+20], ecx

; 3617 :     pDesc1->Format                             = pDesc->BufferDesc.Format;

	mov	ecx, DWORD PTR _stub_desc$8$[ebp]
	mov	DWORD PTR _new_desc1$[ebp+28], edx
	mov	DWORD PTR _new_desc1$[ebp+44], esi
	mov	DWORD PTR _new_desc1$[ebp+8], ecx

; 3967 : 
; 3968 :   HWND hWnd = nullptr;
; 3969 :   SK_DXGI_CreateSwapChain_PreInit (nullptr, &new_desc1, hWnd, nullptr);
; 3970 : 
; 3971 : 
; 3972 :   DXGI_CALL (ret, CreateSwapChainForComposition_Original ( This, pDevice, &new_desc1,

	call	DWORD PTR ?CreateSwapChainForComposition_Original@@3P6GJPAUIDXGIFactory2@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@ZA ; CreateSwapChainForComposition_Original
	mov	esi, eax
	push	esi
	mov	DWORD PTR _ret$1$[ebp], esi
	call	?SK_DescribeHRESULT@@YGPB_WJ@Z		; SK_DescribeHRESULT
	push	eax
	push	OFFSET $SG357055
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH

; 3973 :                                                              pRestrictToOutput, ppSwapChain ));
; 3974 : 
; 3975 :   if ( SUCCEEDED (ret)         &&
; 3976 :        ppSwapChain  != nullptr &&

	test	esi, esi
	js	$LN267@DXGIFactor
	test	edi, edi
	je	$LN267@DXGIFactor
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	$LN322@DXGIFactor

; 3730 :   desc.BufferDesc.Height  = pDesc1->Height;

	mov	eax, DWORD PTR _new_desc1$[ebp+4]
	mov	edi, DWORD PTR _new_desc1$[ebp]
	mov	DWORD PTR _desc$2$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [esi]
	push	esi
	mov	DWORD PTR _pSwapChain$5[ebp], esi
	call	DWORD PTR [eax+4]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3647 :   SK_RunOnce (SK_CEGUI_QueueResetD3D11 ());

	cmp	BYTE PTR ?first@?2??SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z@4_NA, 0 ; `SK_DXGI_CreateSwapChain_PostInit'::`3'::first

; 3748 :   CComQIPtr <IDXGISwapChain> pSwapChain ((*ppSwapChain1));

	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 3647 :   SK_RunOnce (SK_CEGUI_QueueResetD3D11 ());

	je	SHORT $LN190@DXGIFactor
	call	?SK_CEGUI_QueueResetD3D11@@YAXXZ	; SK_CEGUI_QueueResetD3D11
	mov	BYTE PTR ?first@?2??SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z@4_NA, 0 ; `SK_DXGI_CreateSwapChain_PostInit'::`3'::first
$LN190@DXGIFactor:

; 3648 : 
; 3649 :   if (pDesc->BufferDesc.Width != 0)

	test	edi, edi
	je	SHORT $LN191@DXGIFactor

; 3650 :   {
; 3651 :     SK_SetWindowResX (pDesc->BufferDesc.Width);

	push	edi
	call	?SK_SetWindowResX@@YAXJ@Z		; SK_SetWindowResX

; 3652 :     SK_SetWindowResY (pDesc->BufferDesc.Height);

	push	DWORD PTR _desc$2$[ebp]

; 3653 :   }
; 3654 : 
; 3655 :   else

	jmp	SHORT $LN328@DXGIFactor
$LN191@DXGIFactor:

; 3656 :   {
; 3657 :     RECT client;
; 3658 : 
; 3659 :     GetClientRect    (game_window.hWnd, &client);

	lea	eax, DWORD PTR _client$4[ebp]
	push	eax
	push	DWORD PTR ?game_window@@3Usk_window_s@@A+4
	call	DWORD PTR __imp__GetClientRect@8

; 3660 :     SK_SetWindowResX (client.right  - client.left);

	mov	eax, DWORD PTR _client$4[ebp+8]
	sub	eax, DWORD PTR _client$4[ebp]
	push	eax
	call	?SK_SetWindowResX@@YAXJ@Z		; SK_SetWindowResX

; 3661 :     SK_SetWindowResY (client.bottom - client.top);

	mov	eax, DWORD PTR _client$4[ebp+12]
	sub	eax, DWORD PTR _client$4[ebp+4]
	push	eax
$LN328@DXGIFactor:
	call	?SK_SetWindowResY@@YAXJ@Z		; SK_SetWindowResY
	add	esp, 8

; 3662 :   }
; 3663 : 
; 3664 :   SK_RunOnce (SK_DXGI_HookSwapChain (*ppSwapChain));

	cmp	BYTE PTR ?first@?M@??SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z@4_NA, 0 ; `SK_DXGI_CreateSwapChain_PostInit'::`12'::first
	je	SHORT $LN193@DXGIFactor
	push	esi
	call	?SK_DXGI_HookSwapChain@@YAXPAUIDXGISwapChain@@@Z ; SK_DXGI_HookSwapChain
	add	esp, 4
	mov	BYTE PTR ?first@?M@??SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z@4_NA, 0 ; `SK_DXGI_CreateSwapChain_PostInit'::`12'::first
$LN193@DXGIFactor:

; 3665 : 
; 3666 :   //if (bFlipMode || bWait)
; 3667 :     //DXGISwap_ResizeBuffers_Override (*ppSwapChain, config.render.framerate.buffer_count,
; 3668 :     //pDesc->BufferDesc.Width, pDesc->BufferDesc.Height, pDesc->BufferDesc.Format, pDesc->Flags);
; 3669 : 
; 3670 :   const uint32_t max_latency = config.render.framerate.pre_render_limit;

	mov	edi, DWORD PTR ?config@@3Usk_config_t@@A+400
	mov	DWORD PTR _max_latency$1$[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pSwapChain2$6[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3674 :   if ( bFlipMode && bWait &&

	cmp	BYTE PTR ?bFlipMode@@3_NA, 0		; bFlipMode
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	je	SHORT $LN319@DXGIFactor
	cmp	BYTE PTR ?bWait@@3_NA, 0		; bWait
	je	SHORT $LN319@DXGIFactor
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _pSwapChain2$6[ebp]
	push	ecx
	push	OFFSET __GUID_a8be2ac4_199f_4946_b331_79599fb98de7
	push	esi
	call	DWORD PTR [eax]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3674 :   if ( bFlipMode && bWait &&

	test	eax, eax
	js	SHORT $LN319@DXGIFactor

; 3675 :        SUCCEEDED ( (*ppSwapChain)->QueryInterface <IDXGISwapChain2> (&pSwapChain2) )
; 3676 :       )
; 3677 :   {
; 3678 :     if (max_latency < 16)

	cmp	edi, 16					; 00000010H
	jae	SHORT $LN195@DXGIFactor

; 3679 :     {
; 3680 :       dll_log.Log (L"[   DXGI   ] Setting Swapchain Frame Latency: %lu", max_latency);

	push	edi
	push	OFFSET ??_C@_1GE@BOIALL@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAS?$AAw?$AAa?$AAp?$AAc?$AAh?$AAa?$AAi?$AAn?$AA?5?$AAF@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 3681 :       pSwapChain2->SetMaximumFrameLatency (max_latency);

	mov	eax, DWORD PTR _pSwapChain2$6[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	push	edi
	push	eax
	call	DWORD PTR [ecx+124]
$LN195@DXGIFactor:

; 3682 :     }
; 3683 : 
; 3684 :     HANDLE hWait =
; 3685 :       pSwapChain2->GetFrameLatencyWaitableObject ();

	mov	eax, DWORD PTR _pSwapChain2$6[ebp]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+132]

; 3686 : 
; 3687 :     WaitForSingleObjectEx ( hWait,

	push	1
	push	500					; 000001f4H
	push	eax
	call	DWORD PTR __imp__WaitForSingleObjectEx@12
$LN319@DXGIFactor:

; 3688 :                               500,//config.render.framerate.swapchain_wait,
; 3689 :                                 TRUE );
; 3690 :   }
; 3691 : 
; 3692 :   {
; 3693 :     if (max_latency != -1)

	cmp	edi, -1
	je	SHORT $LN320@DXGIFactor
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pDevice1$8[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3697 :       if (SUCCEEDED ( (*ppSwapChain)->GetDevice (

	mov	edi, DWORD PTR [esi]
	lea	eax, DWORD PTR _pDevice1$8[ebp]
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	call	??$IID_PPV_ARGS_Helper@UIDXGIDevice1@@@@YAPAPAXPAPAUIDXGIDevice1@@@Z ; IID_PPV_ARGS_Helper<IDXGIDevice1>
	add	esp, 4
	push	eax
	push	OFFSET __GUID_77db970f_6276_48ba_ba28_070143b4392c
	push	esi
	call	DWORD PTR [edi+28]
	test	eax, eax
	js	SHORT $LN197@DXGIFactor

; 3698 :                          IID_PPV_ARGS (&pDevice1)
; 3699 :                       )
; 3700 :                     )
; 3701 :          )
; 3702 :       {
; 3703 :         dll_log.Log (L"[   DXGI   ] Setting Device Frame Latency: %lu", max_latency);

	mov	edi, DWORD PTR _max_latency$1$[ebp]
	push	edi
	push	OFFSET ??_C@_1FO@CKMCMFKO@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AAF?$AAr?$AAa?$AAm@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 3704 :         pDevice1->SetMaximumFrameLatency (max_latency);

	mov	eax, DWORD PTR _pDevice1$8[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	push	edi
	push	eax
	call	DWORD PTR [ecx+48]
$LN197@DXGIFactor:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	mov	eax, DWORD PTR _pDevice1$8[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3706 :     }

	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN320@DXGIFactor

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN320@DXGIFactor:

; 623  :         if (lp != NULL)

	mov	edx, DWORD PTR _pDevice$[ebp]

; 158  :         p = NULL;

	xor	ecx, ecx
	mov	DWORD PTR _pDev$7[ebp], ecx

; 623  :         if (lp != NULL)

	test	edx, edx
	je	SHORT $LN233@DXGIFactor

; 624  :         {
; 625  :             if (FAILED(lp->QueryInterface(*piid, (void **)&this->p)))

	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR _pDev$7[ebp]
	push	ecx
	push	OFFSET __GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140
	push	edx
	call	DWORD PTR [eax]
	mov	ecx, DWORD PTR _pDev$7[ebp]
	xor	edx, edx
	test	eax, eax
	cmovs	ecx, edx
	mov	DWORD PTR _pDev$7[ebp], ecx
$LN233@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3709 :   CComQIPtr <ID3D11Device> pDev (pDevice);

	mov	BYTE PTR __$EHRec$[ebp+8], 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 214  :         return p == pT;

	test	ecx, ecx
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3711 :   if (pDev != nullptr)

	je	SHORT $LN198@DXGIFactor

; 3712 :   {
; 3713 :     g_pD3D11Dev = pDev;
; 3714 : 
; 3715 :     SK_GetCurrentRenderBackend ().fullscreen_exclusive = (! pDesc->Windowed);

	xor	eax, eax
	mov	DWORD PTR ?g_pD3D11Dev@@3PAUID3D11Device@@A, ecx ; g_pD3D11Dev
	sete	BYTE PTR tv2032[ebp]
	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend
	mov	cl, BYTE PTR tv2032[ebp]
	mov	BYTE PTR [eax+48], cl
	mov	ecx, DWORD PTR _pDev$7[ebp]
$LN198@DXGIFactor:

; 3717 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	ecx, ecx
	je	SHORT $LN252@DXGIFactor

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN252@DXGIFactor:

; 176  :         if (p)

	mov	eax, DWORD PTR _pSwapChain2$6[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3717 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN258@DXGIFactor

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN258@DXGIFactor:
	mov	eax, DWORD PTR [esi]
	push	esi
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3750 :   return SK_DXGI_CreateSwapChain_PostInit ( pDevice, &desc, &pSwapChain );

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 177  :             p->Release();

	call	DWORD PTR [eax+8]
$LN322@DXGIFactor:
	mov	esi, DWORD PTR _ret$1$[ebp]
$LN267@DXGIFactor:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR _iname$[ebp+20]
	pop	edi
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN317@DXGIFactor
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR _iname$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN317@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3983 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN329@DXGIFactor:
	DD	$LN98@DXGIFactor
	DD	$LN97@DXGIFactor
	DD	$LN96@DXGIFactor
	DD	$LN318@DXGIFactor
$LN316@DXGIFactor:
	DB	0
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?DXGIFactory2_CreateSwapChainForComposition_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z$0:
	lea	ecx, DWORD PTR _iname$[ebp]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?DXGIFactory2_CreateSwapChainForComposition_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z$18:
	lea	ecx, DWORD PTR _pSwapChain$5[ebp]
	jmp	??1?$CComQIPtr@UIDXGISwapChain@@$1?_GUID_310d36a0_d2e7_4c0a_aa04_6a9d23b8886a@@3U__s_GUID@@B@ATL@@QAE@XZ
__unwindfunclet$?DXGIFactory2_CreateSwapChainForComposition_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z$19:
	lea	ecx, DWORD PTR _pSwapChain2$6[ebp]
	jmp	??1?$CComPtr@UIDXGISwapChain2@@@ATL@@QAE@XZ
__unwindfunclet$?DXGIFactory2_CreateSwapChainForComposition_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z$20:
	lea	ecx, DWORD PTR _pDevice1$8[ebp]
	jmp	??1?$CComPtr@UIDXGIDevice1@@@ATL@@QAE@XZ
__unwindfunclet$?DXGIFactory2_CreateSwapChainForComposition_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z$21:
	lea	ecx, DWORD PTR _pDev$7[ebp]
	jmp	??1?$CComQIPtr@UID3D11Device@@$1?_GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140@@3U__s_GUID@@B@ATL@@QAE@XZ
__ehhandler$?DXGIFactory2_CreateSwapChainForComposition_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?DXGIFactory2_CreateSwapChainForComposition_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DXGIFactory2_CreateSwapChainForComposition_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z ENDP ; DXGIFactory2_CreateSwapChainForComposition_Override
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
;	COMDAT ??0<lambda_e5c15a2c98a421a829fc4b087e72baa7>@@QAE@AAJAAPAUIDXGIFactory2@@AAPAUIUnknown@@AAPAUHWND__@@AAPBUDXGI_SWAP_CHAIN_DESC1@@AAPAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@AAPAUIDXGIOutput@@AAPAPAUIDXGISwapChain1@@AAU4@AAU5@@Z
_TEXT	SEGMENT
_<ret>$ = 8						; size = 4
_<This>$ = 12						; size = 4
_<pDevice>$ = 16					; size = 4
_<hWnd>$ = 20						; size = 4
_<pDesc>$ = 24						; size = 4
_<pFullscreenDesc>$ = 28				; size = 4
_<pRestrictToOutput>$ = 32				; size = 4
_<ppSwapChain>$ = 36					; size = 4
_<new_desc1>$ = 40					; size = 4
_<new_fullscreen_desc>$ = 44				; size = 4
??0<lambda_e5c15a2c98a421a829fc4b087e72baa7>@@QAE@AAJAAPAUIDXGIFactory2@@AAPAUIUnknown@@AAPAUHWND__@@AAPBUDXGI_SWAP_CHAIN_DESC1@@AAPAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@AAPAUIDXGIOutput@@AAPAPAUIDXGISwapChain1@@AAU4@AAU5@@Z PROC ; <lambda_e5c15a2c98a421a829fc4b087e72baa7>::<lambda_e5c15a2c98a421a829fc4b087e72baa7>, COMDAT
; _this$ = ecx

; 3930 :       };

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _<ret>$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _<This>$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR _<pDevice>$[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _<hWnd>$[ebp]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR _<pDesc>$[ebp]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR _<pFullscreenDesc>$[ebp]
	mov	DWORD PTR [ecx+20], eax
	mov	eax, DWORD PTR _<pRestrictToOutput>$[ebp]
	mov	DWORD PTR [ecx+24], eax
	mov	eax, DWORD PTR _<ppSwapChain>$[ebp]
	mov	DWORD PTR [ecx+28], eax
	mov	eax, DWORD PTR _<new_desc1>$[ebp]
	mov	DWORD PTR [ecx+32], eax
	mov	eax, DWORD PTR _<new_fullscreen_desc>$[ebp]
	mov	DWORD PTR [ecx+36], eax
	mov	eax, ecx
	pop	ebp
	ret	40					; 00000028H
??0<lambda_e5c15a2c98a421a829fc4b087e72baa7>@@QAE@AAJAAPAUIDXGIFactory2@@AAPAUIUnknown@@AAPAUHWND__@@AAPBUDXGI_SWAP_CHAIN_DESC1@@AAPAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@AAPAUIDXGIOutput@@AAPAPAUIDXGISwapChain1@@AAU4@AAU5@@Z ENDP ; <lambda_e5c15a2c98a421a829fc4b087e72baa7>::<lambda_e5c15a2c98a421a829fc4b087e72baa7>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
;	COMDAT ??R<lambda_e5c15a2c98a421a829fc4b087e72baa7>@@QBEHXZ
_TEXT	SEGMENT
_desc$2 = -112						; size = 60
_client$3 = -52						; size = 16
_pSwapChain$4 = -36					; size = 4
_pDevice$1$ = -32					; size = 4
_desc$3$ = -28						; size = 4
_desc$2$ = -24						; size = 4
_pDevice1$5 = -24					; size = 4
_pSwapChain2$6 = -20					; size = 4
_pDev$7 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??R<lambda_e5c15a2c98a421a829fc4b087e72baa7>@@QBEHXZ PROC ; <lambda_e5c15a2c98a421a829fc4b087e72baa7>::operator(), COMDAT
; _this$ = ecx

; 3916 :       {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??R<lambda_e5c15a2c98a421a829fc4b087e72baa7>@@QBEHXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 100				; 00000064H
	push	esi
	mov	esi, ecx

; 3917 :         DXGI_CALL ( ret, CreateSwapChainForHwnd_Original ( This, pDevice, hWnd, pDesc, pFullscreenDesc,

	mov	eax, DWORD PTR [esi+28]
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+24]
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+20]
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+16]
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+12]
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+8]
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+4]
	push	DWORD PTR [eax]
	call	DWORD PTR ?CreateSwapChainForHwnd_Original@@3P6GJPAUIDXGIFactory2@@PAUIUnknown@@PAUHWND__@@PBUDXGI_SWAP_CHAIN_DESC1@@PBUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@ZA ; CreateSwapChainForHwnd_Original
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [eax]
	call	?SK_DescribeHRESULT@@YGPB_WJ@Z		; SK_DescribeHRESULT
	push	eax
	push	OFFSET ??_C@_1BCK@OGPEHLJN@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?$FL?$AA?$EA?$AA?$FN?$AA?5?$AA?5?$AAR?$AAe?$AAt?$AAu?$AAr?$AAn?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AA?5?$AA?9?$AA?5@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 3918 :                                                              pRestrictToOutput, ppSwapChain ) );
; 3919 : 
; 3920 :         if ( SUCCEEDED (ret)         &&
; 3921 :              ppSwapChain  != nullptr &&

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [eax], 0
	jl	$LN2@operator
	mov	eax, DWORD PTR [esi+28]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	$LN2@operator
	cmp	DWORD PTR [edx], 0
	je	$LN2@operator

; 3922 :            (*ppSwapChain) != nullptr )
; 3923 :         {
; 3924 :           SK_DXGI_CreateSwapChain1_PostInit (pDevice, &new_desc1, &new_fullscreen_desc, ppSwapChain);

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+32]
	push	ebx
	mov	ebx, DWORD PTR [esi+36]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _pDevice$1$[ebp], eax

; 3730 :   desc.BufferDesc.Height  = pDesc1->Height;

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _desc$2$[ebp], eax
	push	edi

; 3718 : 
; 3719 : __forceinline
; 3720 : void
; 3721 : SK_DXGI_CreateSwapChain1_PostInit ( _In_     IUnknown                         *pDevice,
; 3722 :                                     _In_     DXGI_SWAP_CHAIN_DESC1            *pDesc1,
; 3723 :                                     _In_opt_ DXGI_SWAP_CHAIN_FULLSCREEN_DESC  *pFullscreenDesc,
; 3724 :                                     _In_     IDXGISwapChain1                 **ppSwapChain1 )
; 3725 : {
; 3726 :   // ONLY AS COMPLETE AS NEEDED, if new code is added to PostInit, this will probably need changing.
; 3727 :   DXGI_SWAP_CHAIN_DESC desc;
; 3728 : 
; 3729 :   desc.BufferDesc.Width   = pDesc1->Width;

	mov	edi, DWORD PTR [ecx]

; 3731 : 
; 3732 :   desc.BufferDesc.Format  = pDesc1->Format;
; 3733 :   //desc.BufferDesc.Scaling = pDesc1->Scaling;
; 3734 : 
; 3735 :   desc.BufferCount        = pDesc1->BufferCount;
; 3736 :   desc.BufferUsage        = pDesc1->BufferUsage;
; 3737 :   desc.Flags              = pDesc1->Flags;
; 3738 :   desc.SampleDesc         = pDesc1->SampleDesc;
; 3739 :   desc.SwapEffect         = pDesc1->SwapEffect;
; 3740 : 
; 3741 :   if (pFullscreenDesc)

	test	ebx, ebx
	je	SHORT $LN97@operator

; 3743 :     desc.Windowed                    = pFullscreenDesc->Windowed;

	mov	eax, DWORD PTR [ebx+16]
	jmp	SHORT $LN101@operator
$LN97@operator:
	mov	eax, DWORD PTR _desc$2[ebp+48]
$LN101@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	esi, DWORD PTR [edx]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3743 :     desc.Windowed                    = pFullscreenDesc->Windowed;

	mov	DWORD PTR _desc$3$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pSwapChain$4[ebp], esi

; 163  :         if (p != NULL)

	test	esi, esi
	je	SHORT $LN13@operator

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [esi]
	push	esi
	call	DWORD PTR [eax+4]
$LN13@operator:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3647 :   SK_RunOnce (SK_CEGUI_QueueResetD3D11 ());

	cmp	BYTE PTR ?first@?2??SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z@4_NA, 0 ; `SK_DXGI_CreateSwapChain_PostInit'::`3'::first

; 3748 :   CComQIPtr <IDXGISwapChain> pSwapChain ((*ppSwapChain1));

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3647 :   SK_RunOnce (SK_CEGUI_QueueResetD3D11 ());

	je	SHORT $LN18@operator
	call	?SK_CEGUI_QueueResetD3D11@@YAXXZ	; SK_CEGUI_QueueResetD3D11
	mov	BYTE PTR ?first@?2??SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z@4_NA, 0 ; `SK_DXGI_CreateSwapChain_PostInit'::`3'::first
$LN18@operator:

; 3648 : 
; 3649 :   if (pDesc->BufferDesc.Width != 0)

	test	edi, edi
	je	SHORT $LN19@operator

; 3650 :   {
; 3651 :     SK_SetWindowResX (pDesc->BufferDesc.Width);

	push	edi
	call	?SK_SetWindowResX@@YAXJ@Z		; SK_SetWindowResX

; 3652 :     SK_SetWindowResY (pDesc->BufferDesc.Height);

	push	DWORD PTR _desc$2$[ebp]

; 3653 :   }
; 3654 : 
; 3655 :   else

	jmp	SHORT $LN102@operator
$LN19@operator:

; 3656 :   {
; 3657 :     RECT client;
; 3658 : 
; 3659 :     GetClientRect    (game_window.hWnd, &client);

	lea	eax, DWORD PTR _client$3[ebp]
	push	eax
	push	DWORD PTR ?game_window@@3Usk_window_s@@A+4
	call	DWORD PTR __imp__GetClientRect@8

; 3660 :     SK_SetWindowResX (client.right  - client.left);

	mov	eax, DWORD PTR _client$3[ebp+8]
	sub	eax, DWORD PTR _client$3[ebp]
	push	eax
	call	?SK_SetWindowResX@@YAXJ@Z		; SK_SetWindowResX

; 3661 :     SK_SetWindowResY (client.bottom - client.top);

	mov	eax, DWORD PTR _client$3[ebp+12]
	sub	eax, DWORD PTR _client$3[ebp+4]
	push	eax
$LN102@operator:
	call	?SK_SetWindowResY@@YAXJ@Z		; SK_SetWindowResY
	add	esp, 8

; 3662 :   }
; 3663 : 
; 3664 :   SK_RunOnce (SK_DXGI_HookSwapChain (*ppSwapChain));

	cmp	BYTE PTR ?first@?M@??SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z@4_NA, 0 ; `SK_DXGI_CreateSwapChain_PostInit'::`12'::first
	je	SHORT $LN21@operator
	push	esi
	call	?SK_DXGI_HookSwapChain@@YAXPAUIDXGISwapChain@@@Z ; SK_DXGI_HookSwapChain
	add	esp, 4
	mov	BYTE PTR ?first@?M@??SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z@4_NA, 0 ; `SK_DXGI_CreateSwapChain_PostInit'::`12'::first
$LN21@operator:

; 3665 : 
; 3666 :   //if (bFlipMode || bWait)
; 3667 :     //DXGISwap_ResizeBuffers_Override (*ppSwapChain, config.render.framerate.buffer_count,
; 3668 :     //pDesc->BufferDesc.Width, pDesc->BufferDesc.Height, pDesc->BufferDesc.Format, pDesc->Flags);
; 3669 : 
; 3670 :   const uint32_t max_latency = config.render.framerate.pre_render_limit;

	mov	ebx, DWORD PTR ?config@@3Usk_config_t@@A+400
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pSwapChain2$6[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3674 :   if ( bFlipMode && bWait &&

	cmp	BYTE PTR ?bFlipMode@@3_NA, 0		; bFlipMode
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	je	SHORT $LN98@operator
	cmp	BYTE PTR ?bWait@@3_NA, 0		; bWait
	je	SHORT $LN98@operator
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _pSwapChain2$6[ebp]
	push	ecx
	push	OFFSET __GUID_a8be2ac4_199f_4946_b331_79599fb98de7
	push	esi
	call	DWORD PTR [eax]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3674 :   if ( bFlipMode && bWait &&

	test	eax, eax
	js	SHORT $LN98@operator

; 3675 :        SUCCEEDED ( (*ppSwapChain)->QueryInterface <IDXGISwapChain2> (&pSwapChain2) )
; 3676 :       )
; 3677 :   {
; 3678 :     if (max_latency < 16)

	cmp	ebx, 16					; 00000010H
	jae	SHORT $LN23@operator

; 3679 :     {
; 3680 :       dll_log.Log (L"[   DXGI   ] Setting Swapchain Frame Latency: %lu", max_latency);

	push	ebx
	push	OFFSET ??_C@_1GE@BOIALL@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAS?$AAw?$AAa?$AAp?$AAc?$AAh?$AAa?$AAi?$AAn?$AA?5?$AAF@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 3681 :       pSwapChain2->SetMaximumFrameLatency (max_latency);

	mov	eax, DWORD PTR _pSwapChain2$6[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	push	ebx
	push	eax
	call	DWORD PTR [ecx+124]
$LN23@operator:

; 3682 :     }
; 3683 : 
; 3684 :     HANDLE hWait =
; 3685 :       pSwapChain2->GetFrameLatencyWaitableObject ();

	mov	eax, DWORD PTR _pSwapChain2$6[ebp]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+132]

; 3686 : 
; 3687 :     WaitForSingleObjectEx ( hWait,

	push	1
	push	500					; 000001f4H
	push	eax
	call	DWORD PTR __imp__WaitForSingleObjectEx@12
$LN98@operator:

; 3688 :                               500,//config.render.framerate.swapchain_wait,
; 3689 :                                 TRUE );
; 3690 :   }
; 3691 : 
; 3692 :   {
; 3693 :     if (max_latency != -1)

	cmp	ebx, -1
	je	SHORT $LN99@operator
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pDevice1$5[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3697 :       if (SUCCEEDED ( (*ppSwapChain)->GetDevice (

	mov	edi, DWORD PTR [esi]
	lea	eax, DWORD PTR _pDevice1$5[ebp]
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??$IID_PPV_ARGS_Helper@UIDXGIDevice1@@@@YAPAPAXPAPAUIDXGIDevice1@@@Z ; IID_PPV_ARGS_Helper<IDXGIDevice1>
	add	esp, 4
	push	eax
	push	OFFSET __GUID_77db970f_6276_48ba_ba28_070143b4392c
	push	esi
	call	DWORD PTR [edi+28]
	test	eax, eax
	js	SHORT $LN25@operator

; 3698 :                          IID_PPV_ARGS (&pDevice1)
; 3699 :                       )
; 3700 :                     )
; 3701 :          )
; 3702 :       {
; 3703 :         dll_log.Log (L"[   DXGI   ] Setting Device Frame Latency: %lu", max_latency);

	push	ebx
	push	OFFSET ??_C@_1FO@CKMCMFKO@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AAF?$AAr?$AAa?$AAm@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 3704 :         pDevice1->SetMaximumFrameLatency (max_latency);

	mov	eax, DWORD PTR _pDevice1$5[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	push	ebx
	push	eax
	call	DWORD PTR [ecx+48]
$LN25@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	mov	eax, DWORD PTR _pDevice1$5[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3706 :     }

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN99@operator

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN99@operator:

; 623  :         if (lp != NULL)

	mov	edx, DWORD PTR _pDevice$1$[ebp]

; 158  :         p = NULL;

	xor	ecx, ecx
	mov	DWORD PTR _pDev$7[ebp], ecx

; 623  :         if (lp != NULL)

	test	edx, edx
	je	SHORT $LN61@operator

; 624  :         {
; 625  :             if (FAILED(lp->QueryInterface(*piid, (void **)&this->p)))

	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR _pDev$7[ebp]
	push	ecx
	push	OFFSET __GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140
	push	edx
	call	DWORD PTR [eax]
	mov	ecx, DWORD PTR _pDev$7[ebp]
	xor	edx, edx
	test	eax, eax
	cmovs	ecx, edx
	mov	DWORD PTR _pDev$7[ebp], ecx
$LN61@operator:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3709 :   CComQIPtr <ID3D11Device> pDev (pDevice);

	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 214  :         return p == pT;

	test	ecx, ecx
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3711 :   if (pDev != nullptr)

	je	SHORT $LN26@operator

; 3712 :   {
; 3713 :     g_pD3D11Dev = pDev;
; 3714 : 
; 3715 :     SK_GetCurrentRenderBackend ().fullscreen_exclusive = (! pDesc->Windowed);

	cmp	DWORD PTR _desc$3$[ebp], 0
	mov	DWORD PTR ?g_pD3D11Dev@@3PAUID3D11Device@@A, ecx ; g_pD3D11Dev
	sete	bl
	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend
	mov	BYTE PTR [eax+48], bl
	mov	ecx, DWORD PTR _pDev$7[ebp]
$LN26@operator:

; 3717 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	pop	edi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	ecx, ecx
	je	SHORT $LN80@operator

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN80@operator:

; 176  :         if (p)

	mov	eax, DWORD PTR _pSwapChain2$6[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3717 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN86@operator

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN86@operator:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3750 :   return SK_DXGI_CreateSwapChain_PostInit ( pDevice, &desc, &pSwapChain );

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	esi, esi
	je	SHORT $LN95@operator

; 177  :             p->Release();

	mov	eax, DWORD PTR [esi]
	push	esi
	call	DWORD PTR [eax+8]
$LN95@operator:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3926 :           return TRUE;

	mov	eax, 1
	pop	esi

; 3927 :         }
; 3928 : 
; 3929 :         return FALSE;
; 3930 :       };

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@operator:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	xor	eax, eax
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??R<lambda_e5c15a2c98a421a829fc4b087e72baa7>@@QBEHXZ$0:
	lea	ecx, DWORD PTR _pSwapChain$4[ebp]
	jmp	??1?$CComQIPtr@UIDXGISwapChain@@$1?_GUID_310d36a0_d2e7_4c0a_aa04_6a9d23b8886a@@3U__s_GUID@@B@ATL@@QAE@XZ
__unwindfunclet$??R<lambda_e5c15a2c98a421a829fc4b087e72baa7>@@QBEHXZ$1:
	lea	ecx, DWORD PTR _pSwapChain2$6[ebp]
	jmp	??1?$CComPtr@UIDXGISwapChain2@@@ATL@@QAE@XZ
__unwindfunclet$??R<lambda_e5c15a2c98a421a829fc4b087e72baa7>@@QBEHXZ$2:
	lea	ecx, DWORD PTR _pDevice1$5[ebp]
	jmp	??1?$CComPtr@UIDXGIDevice1@@@ATL@@QAE@XZ
__unwindfunclet$??R<lambda_e5c15a2c98a421a829fc4b087e72baa7>@@QBEHXZ$3:
	lea	ecx, DWORD PTR _pDev$7[ebp]
	jmp	??1?$CComQIPtr@UID3D11Device@@$1?_GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140@@3U__s_GUID@@B@ATL@@QAE@XZ
__ehhandler$??R<lambda_e5c15a2c98a421a829fc4b087e72baa7>@@QBEHXZ:
	mov	eax, OFFSET __ehfuncinfo$??R<lambda_e5c15a2c98a421a829fc4b087e72baa7>@@QBEHXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??R<lambda_e5c15a2c98a421a829fc4b087e72baa7>@@QBEHXZ ENDP ; <lambda_e5c15a2c98a421a829fc4b087e72baa7>::operator()
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
$T2 = -280						; size = 24
$T3 = -256						; size = 20
$T4 = -236						; size = 20
_iname$ = -216						; size = 24
_CreateSwapChain_Lambchop$ = -192			; size = 40
_new_desc1$ = -152					; size = 48
_ret$ = -104						; size = 4
_orig_fullscreen_desc$1$ = -100				; size = 4
_orig_desc1$1$ = -96					; size = 4
_stub_desc$11$ = -92					; size = 4
_stub_desc$3$ = -88					; size = 4
_new_fullscreen_desc$ = -84				; size = 20
_stub_desc$7$ = -64					; size = 4
_stub_desc$6$ = -60					; size = 4
tv1575 = -56						; size = 4
_stub_desc$10$ = -52					; size = 4
_stub_desc$14$ = -48					; size = 4
_stub_desc$8$ = -44					; size = 4
tv1574 = -40						; size = 4
tv1501 = -40						; size = 4
tv1499 = -40						; size = 4
_stub_desc$16$ = -36					; size = 4
_stub_desc$15$ = -32					; size = 4
_stub_desc$13$ = -28					; size = 4
_stub_desc$5$ = -24					; size = 4
_stub_desc$2$ = -20					; size = 4
_stub_desc$12$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_This$ = 8						; size = 4
_pDevice$ = 12						; size = 4
_hWnd$ = 16						; size = 4
_pDesc$ = 20						; size = 4
_pFullscreenDesc$ = 24					; size = 4
_pRestrictToOutput$ = 28				; size = 4
_ppSwapChain$ = 32					; size = 4
?DXGIFactory2_CreateSwapChainForHwnd_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@PAUHWND__@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z PROC ; DXGIFactory2_CreateSwapChainForHwnd_Override

; 3888 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DXGIFactory2_CreateSwapChainForHwnd_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@PAUHWND__@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 268				; 0000010cH
	push	esi

; 3889 :   std::wstring iname = SK_GetDXGIFactoryInterface (This);

	push	DWORD PTR _This$[ebp]
	lea	eax, DWORD PTR _iname$[ebp]
	push	eax
	call	?SK_GetDXGIFactoryInterface@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUIUnknown@@@Z ; SK_GetDXGIFactoryInterface

; 3892 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"CreateSwapChainForHwnd         ",

	push	8192					; 00002000H
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??_U@YAPAXI@Z				; operator new[]
	mov	esi, eax
	add	esp, 12					; 0000000cH
	test	esi, esi
	je	SHORT $LN5@DXGIFactor
	push	8192					; 00002000H
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN6@DXGIFactor
$LN5@DXGIFactor:
	xor	esi, esi
$LN6@DXGIFactor:
	push	edi
	lea	edi, DWORD PTR [esi+2048]
	test	esi, esi
	je	$LN2@DXGIFactor
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR _iname$[ebp+20], 8

; 1621 : 		return (_Large_string_engaged()

	lea	eax, DWORD PTR _iname$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3892 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"CreateSwapChainForHwnd         ",

	push	OFFSET $SG357017
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	cmovae	eax, DWORD PTR _iname$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3892 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"CreateSwapChainForHwnd         ",

	push	eax
	push	OFFSET $SG357018
	push	esi
	call	__swprintf
	push	DWORD PTR _ppSwapChain$[ebp]
	push	DWORD PTR _pDesc$[ebp]
	push	DWORD PTR _pDevice$[ebp]
	push	OFFSET $SG357019
	push	edi
	call	__swprintf
	push	edi
	push	esi
	lea	eax, DWORD PTR [edi+2048]
	push	OFFSET $SG357020
	push	eax
	call	__swprintf
	mov	eax, DWORD PTR __$ReturnAddr$[ebp]
	add	esp, 52					; 00000034H
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?SK_SummarizeCaller@@YG?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAX@Z ; SK_SummarizeCaller
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN43@DXGIFactor
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN43@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3892 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"CreateSwapChainForHwnd         ",

	push	eax
	lea	eax, DWORD PTR [edi+2048]
	push	eax
	push	OFFSET $SG357021
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T2[ebp+20]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3892 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"CreateSwapChainForHwnd         ",

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN53@DXGIFactor
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T2[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN53@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3892 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"CreateSwapChainForHwnd         ",

	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@DXGIFactor:

; 3893 :                        L"%ph, %ph, %ph",
; 3894 :                          pDevice, pDesc, ppSwapChain );
; 3895 : 
; 3896 :   HRESULT ret;
; 3897 : 
; 3898 :   assert (pDesc != nullptr);
; 3899 : 
; 3900 :   auto                            orig_desc1           = pDesc;

	mov	eax, DWORD PTR _pDesc$[ebp]

; 3901 :   auto                            orig_fullscreen_desc = pFullscreenDesc;

	mov	ecx, DWORD PTR _pFullscreenDesc$[ebp]
	mov	DWORD PTR _orig_desc1$1$[ebp], eax
	mov	DWORD PTR _orig_fullscreen_desc$1$[ebp], ecx

; 3902 : 
; 3903 :   DXGI_SWAP_CHAIN_DESC1           new_desc1           = *pDesc;

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR _new_desc1$[ebp], xmm0
	movups	xmm0, XMMWORD PTR [eax+16]
	movups	XMMWORD PTR _new_desc1$[ebp+16], xmm0
	movups	xmm0, XMMWORD PTR [eax+32]
	movups	XMMWORD PTR _new_desc1$[ebp+32], xmm0

; 3904 :   DXGI_SWAP_CHAIN_FULLSCREEN_DESC new_fullscreen_desc =
; 3905 :     pFullscreenDesc ? *pFullscreenDesc :

	test	ecx, ecx
	je	SHORT $LN7@DXGIFactor
	movups	xmm0, XMMWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR $T4[ebp+16], eax
	lea	eax, DWORD PTR $T4[ebp]
	movups	XMMWORD PTR $T4[ebp], xmm0
	jmp	SHORT $LN8@DXGIFactor
$LN7@DXGIFactor:
	xorps	xmm0, xmm0
	mov	DWORD PTR $T3[ebp+16], 0
	movups	XMMWORD PTR $T3[ebp], xmm0
	lea	eax, DWORD PTR $T3[ebp]
$LN8@DXGIFactor:
	movups	xmm0, XMMWORD PTR [eax]
	mov	eax, DWORD PTR [eax+16]

; 3906 :                        DXGI_SWAP_CHAIN_FULLSCREEN_DESC { };
; 3907 : 
; 3908 :   pDesc           = &new_desc1;
; 3909 :   pFullscreenDesc = orig_fullscreen_desc ? &new_fullscreen_desc : nullptr;

	xor	edx, edx
	mov	DWORD PTR _new_fullscreen_desc$[ebp+16], eax
	test	ecx, ecx
	lea	eax, DWORD PTR _new_desc1$[ebp]
	mov	DWORD PTR _pDesc$[ebp], eax
	lea	eax, DWORD PTR _new_fullscreen_desc$[ebp]
	cmove	eax, edx
	movups	XMMWORD PTR _new_fullscreen_desc$[ebp], xmm0
	mov	DWORD PTR _pFullscreenDesc$[ebp], eax

; 3295 :   WaitForInit ();

	call	?WaitForInitDXGI@@YAXXZ			; WaitForInitDXGI
	call	?WaitForInit@@YAXXZ			; WaitForInit

; 3296 : 
; 3297 :   DXGI_SWAP_CHAIN_DESC stub_desc  = {   }; // Stores common attributes between DESC and DESC1
; 3298 :   bool                 translated = false;
; 3299 : 
; 3300 :   if (pDesc1 != nullptr)
; 3301 :   {
; 3302 :     if (pDesc == nullptr)
; 3303 :     {
; 3304 :       pDesc = &stub_desc;
; 3305 : 
; 3306 :       stub_desc.BufferCount                        = pDesc1->BufferCount;

	mov	eax, DWORD PTR _new_desc1$[ebp+28]

; 3307 :       stub_desc.BufferUsage                        = pDesc1->BufferUsage;
; 3308 :       stub_desc.Flags                              = pDesc1->Flags;
; 3309 :       stub_desc.SwapEffect                         = pDesc1->SwapEffect;

	mov	edx, DWORD PTR _new_desc1$[ebp+36]

; 3310 :       stub_desc.SampleDesc.Count                   = pDesc1->SampleDesc.Count;
; 3311 :       stub_desc.SampleDesc.Quality                 = pDesc1->SampleDesc.Quality;
; 3312 :       stub_desc.BufferDesc.Format                  = pDesc1->Format;
; 3313 :       stub_desc.BufferDesc.Height                  = pDesc1->Height;
; 3314 :       stub_desc.BufferDesc.Width                   = pDesc1->Width;

	mov	ecx, DWORD PTR _new_desc1$[ebp]
	mov	esi, DWORD PTR _new_desc1$[ebp+44]
	mov	edi, DWORD PTR _new_desc1$[ebp+4]
	mov	DWORD PTR _stub_desc$2$[ebp], eax
	mov	eax, DWORD PTR _new_desc1$[ebp+24]
	mov	DWORD PTR _stub_desc$3$[ebp], eax
	mov	eax, DWORD PTR _new_desc1$[ebp+16]
	mov	DWORD PTR _stub_desc$6$[ebp], eax
	mov	eax, DWORD PTR _new_desc1$[ebp+20]
	mov	DWORD PTR _stub_desc$7$[ebp], eax
	mov	eax, DWORD PTR _new_desc1$[ebp+8]
	mov	DWORD PTR _stub_desc$8$[ebp], eax

; 3315 :       stub_desc.OutputWindow                       = hWnd;

	mov	eax, DWORD PTR _hWnd$[ebp]
	mov	DWORD PTR _stub_desc$11$[ebp], eax

; 3316 : 
; 3317 :       if (pFullscreenDesc != nullptr)
; 3318 :       {
; 3319 :         stub_desc.Windowed                           = pFullscreenDesc->Windowed;

	mov	eax, DWORD PTR _new_fullscreen_desc$[ebp+16]
	mov	DWORD PTR _stub_desc$12$[ebp], eax

; 3320 :         stub_desc.BufferDesc.RefreshRate.Denominator = pFullscreenDesc->RefreshRate.Denominator;

	mov	eax, DWORD PTR _new_fullscreen_desc$[ebp+4]
	mov	DWORD PTR _stub_desc$13$[ebp], eax

; 3321 :         stub_desc.BufferDesc.RefreshRate.Numerator   = pFullscreenDesc->RefreshRate.Numerator;

	mov	eax, DWORD PTR _new_fullscreen_desc$[ebp]
	mov	DWORD PTR _stub_desc$14$[ebp], eax

; 3322 :         stub_desc.BufferDesc.Scaling                 = pFullscreenDesc->Scaling;

	mov	eax, DWORD PTR _new_fullscreen_desc$[ebp+12]
	mov	DWORD PTR _stub_desc$15$[ebp], eax

; 3323 :         stub_desc.BufferDesc.ScanlineOrdering        = pFullscreenDesc->ScanlineOrdering;

	mov	eax, DWORD PTR _new_fullscreen_desc$[ebp+8]
	mov	DWORD PTR _stub_desc$5$[ebp], edx
	mov	DWORD PTR _stub_desc$10$[ebp], ecx
	mov	DWORD PTR _stub_desc$16$[ebp], eax

; 3338 :     dll_log.LogEx ( true,

	test	edx, edx
	jne	SHORT $LN129@DXGIFactor
	mov	edx, OFFSET ??_C@_1BA@EMGLPOHC@?$AAD?$AAi?$AAs?$AAc?$AAa?$AAr?$AAd?$AA?$AA@
	jmp	SHORT $LN124@DXGIFactor
$LN129@DXGIFactor:
	cmp	edx, 1
	jne	SHORT $LN127@DXGIFactor
	mov	edx, OFFSET ??_C@_1BG@MBNPLCBJ@?$AAS?$AAe?$AAq?$AAu?$AAe?$AAn?$AAt?$AAi?$AAa?$AAl?$AA?$AA@
	jmp	SHORT $LN124@DXGIFactor
$LN127@DXGIFactor:
	cmp	edx, 2
	jne	SHORT $LN125@DXGIFactor
	mov	edx, OFFSET ??_C@_1BE@BGMELJBK@?$AA?$DM?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?$DO?$AA?$AA@
	jmp	SHORT $LN124@DXGIFactor
$LN125@DXGIFactor:
	cmp	edx, 3
	jne	SHORT $LN123@DXGIFactor
	mov	edx, OFFSET ??_C@_1CA@DEGLGFCG@?$AAF?$AAl?$AAi?$AAp?$AA?5?$AAS?$AAe?$AAq?$AAu?$AAe?$AAn?$AAt?$AAi?$AAa?$AAl?$AA?$AA@
	jmp	SHORT $LN124@DXGIFactor
$LN123@DXGIFactor:
	cmp	DWORD PTR _stub_desc$5$[ebp], 4
	mov	eax, OFFSET ??_C@_1BE@BGMELJBK@?$AA?$DM?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?$DO?$AA?$AA@
	mov	edx, OFFSET ??_C@_1BK@OJAHAHGF@?$AAF?$AAl?$AAi?$AAp?$AA?5?$AAD?$AAi?$AAs?$AAc?$AAa?$AAr?$AAd?$AA?$AA@
	cmovne	edx, eax
	mov	eax, DWORD PTR _stub_desc$16$[ebp]
$LN124@DXGIFactor:
	test	eax, eax
	jne	SHORT $LN133@DXGIFactor
	mov	DWORD PTR tv1575[ebp], OFFSET ??_C@_1BI@DELFJJPB@?$AAU?$AAn?$AAs?$AAp?$AAe?$AAc?$AAi?$AAf?$AAi?$AAe?$AAd?$AA?$AA@
	jmp	SHORT $LN132@DXGIFactor
$LN133@DXGIFactor:
	cmp	eax, 1
	jne	SHORT $LN131@DXGIFactor
	mov	DWORD PTR tv1575[ebp], OFFSET ??_C@_1BI@JFLEIIEG@?$AAP?$AAr?$AAo?$AAg?$AAr?$AAe?$AAs?$AAs?$AAi?$AAv?$AAe?$AA?$AA@
	jmp	SHORT $LN132@DXGIFactor
$LN131@DXGIFactor:
	cmp	DWORD PTR _stub_desc$16$[ebp], 2
	mov	eax, OFFSET ??_C@_1CA@MIMOHAAK@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAl?$AAa?$AAc?$AAe?$AAd?$AA?5?$AAE?$AAv?$AAe?$AAn?$AA?$AA@
	mov	DWORD PTR tv1499[ebp], OFFSET ??_C@_1BO@NBKANNIC@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAl?$AAa?$AAc?$AAe?$AAd?$AA?5?$AAO?$AAd?$AAd?$AA?$AA@
	cmovne	eax, DWORD PTR tv1499[ebp]
	mov	DWORD PTR tv1575[ebp], eax
$LN132@DXGIFactor:
	cmp	DWORD PTR _stub_desc$15$[ebp], 0
	jne	SHORT $LN135@DXGIFactor
	mov	DWORD PTR tv1574[ebp], OFFSET ??_C@_1BI@DELFJJPB@?$AAU?$AAn?$AAs?$AAp?$AAe?$AAc?$AAi?$AAf?$AAi?$AAe?$AAd?$AA?$AA@
	jmp	SHORT $LN136@DXGIFactor
$LN135@DXGIFactor:
	cmp	DWORD PTR _stub_desc$15$[ebp], 1
	mov	eax, OFFSET ??_C@_1BC@NODLAKGH@?$AAC?$AAe?$AAn?$AAt?$AAe?$AAr?$AAe?$AAd?$AA?$AA@
	mov	DWORD PTR tv1501[ebp], OFFSET ??_C@_1BE@OKCKFGLA@?$AAS?$AAt?$AAr?$AAe?$AAt?$AAc?$AAh?$AAe?$AAd?$AA?$AA@
	cmovne	eax, DWORD PTR tv1501[ebp]
	mov	DWORD PTR tv1574[ebp], eax
$LN136@DXGIFactor:
	cmp	DWORD PTR _stub_desc$13$[ebp], 0
	je	SHORT $LN137@DXGIFactor
	mov	eax, DWORD PTR _stub_desc$14$[ebp]
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	eax, DWORD PTR _stub_desc$13$[ebp]
	cvtpd2ps xmm1, xmm0
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	divss	xmm1, xmm0
	jmp	SHORT $LN146@DXGIFactor
$LN137@DXGIFactor:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits

; 1119 : 		return (__builtin_nanf("0"));

	movss	xmm1, DWORD PTR __real@7fc00000
$LN146@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3338 :     dll_log.LogEx ( true,

	mov	eax, DWORD PTR _stub_desc$2$[ebp]
	cmp	DWORD PTR _stub_desc$12$[ebp], 0
	push	edx
	push	esi
	push	eax
	mov	edx, OFFSET ??_C@_1BG@EOMFJOKP@?$AAF?$AAu?$AAl?$AAl?$AAs?$AAc?$AAr?$AAe?$AAe?$AAn?$AA?$AA@
	mov	eax, OFFSET ??_C@_1BC@PMICBOA@?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAe?$AAd?$AA?$AA@
	cmove	eax, edx
	push	eax
	push	DWORD PTR tv1575[ebp]
	cvtps2pd xmm0, xmm1
	push	DWORD PTR tv1574[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	edi
	push	ecx
	push	OFFSET ??_C@_1BAE@FEHGBMOO@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AAS?$AAw?$AAa?$AAp?$AAC?$AAh?$AAa?$AAi?$AAn?$AA?3?$AA?5?$AA?$CI?$AA?$CF?$AAl?$AAu?$AAx?$AA?$CF?$AAl@
	push	1
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx

; 3339 :       L"[   DXGI   ]  SwapChain: (%lux%lu @ %4.1f Hz - Scaling: %s - Scanlines: %s) - {%s}"
; 3340 :       L" [%lu Buffers] :: Flags=0x%04X, SwapEffect: %s\n",
; 3341 :       pDesc->BufferDesc.Width,
; 3342 :       pDesc->BufferDesc.Height,
; 3343 :       pDesc->BufferDesc.RefreshRate.Denominator != 0 ?
; 3344 :         static_cast <float> (pDesc->BufferDesc.RefreshRate.Numerator) /
; 3345 :         static_cast <float> (pDesc->BufferDesc.RefreshRate.Denominator) :
; 3346 :           std::numeric_limits <float>::quiet_NaN (),
; 3347 :       pDesc->BufferDesc.Scaling == DXGI_MODE_SCALING_UNSPECIFIED ?
; 3348 :         L"Unspecified" :
; 3349 :         pDesc->BufferDesc.Scaling == DXGI_MODE_SCALING_CENTERED ?
; 3350 :           L"Centered" :
; 3351 :           L"Stretched",
; 3352 :       pDesc->BufferDesc.ScanlineOrdering == DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED ?
; 3353 :         L"Unspecified" :
; 3354 :         pDesc->BufferDesc.ScanlineOrdering == DXGI_MODE_SCANLINE_ORDER_PROGRESSIVE ?
; 3355 :           L"Progressive" :
; 3356 :           pDesc->BufferDesc.ScanlineOrdering == DXGI_MODE_SCANLINE_ORDER_UPPER_FIELD_FIRST ?
; 3357 :             L"Interlaced Even" :
; 3358 :             L"Interlaced Odd",
; 3359 :       pDesc->Windowed ? L"Windowed" : L"Fullscreen",
; 3360 :       pDesc->BufferCount,
; 3361 :       pDesc->Flags,
; 3362 :       pDesc->SwapEffect         == 0 ?
; 3363 :         L"Discard" :
; 3364 :         pDesc->SwapEffect       == 1 ?
; 3365 :           L"Sequential" :
; 3366 :           pDesc->SwapEffect     == 2 ?
; 3367 :             L"<Unknown>" :
; 3368 :             pDesc->SwapEffect   == 3 ?
; 3369 :               L"Flip Sequential" :
; 3370 :               pDesc->SwapEffect == 4 ?
; 3371 :                 L"Flip Discard" :
; 3372 :                 L"<Unknown>" );
; 3373 : 
; 3374 :     // Set things up to make the swap chain Alt+Enter friendly
; 3375 :     if (bAlwaysAllowFullscreen && pDesc->Windowed)

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+760
	add	esp, 52					; 00000034H
	cmp	BYTE PTR ?bAlwaysAllowFullscreen@@3_NA, 0 ; bAlwaysAllowFullscreen
	mov	edx, DWORD PTR ?config@@3Usk_config_t@@A+756
	je	SHORT $LN87@DXGIFactor
	cmp	DWORD PTR _stub_desc$12$[ebp], 0
	je	SHORT $LN89@DXGIFactor

; 3376 :     {
; 3377 :       pDesc->Flags                             |= DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

	or	esi, 2

; 3378 :       pDesc->Windowed                           = true;

	mov	DWORD PTR _stub_desc$12$[ebp], 1

; 3379 :       pDesc->BufferDesc.RefreshRate.Denominator = 0;

	mov	DWORD PTR _stub_desc$13$[ebp], 0

; 3380 :       pDesc->BufferDesc.RefreshRate.Numerator   = 0;

	mov	DWORD PTR _stub_desc$14$[ebp], 0

; 3381 :     }
; 3382 : 
; 3383 :     if (pDesc->Windowed && config.window.borderless && (! config.window.fullscreen))

	jmp	SHORT $LN226@DXGIFactor
$LN87@DXGIFactor:
	cmp	DWORD PTR _stub_desc$12$[ebp], 0
	je	SHORT $LN89@DXGIFactor
$LN226@DXGIFactor:
	cmp	BYTE PTR ?config@@3Usk_config_t@@A+728, 0
	je	SHORT $LN89@DXGIFactor
	cmp	BYTE PTR ?config@@3Usk_config_t@@A+754, 0
	jne	SHORT $LN89@DXGIFactor
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 425  :         bool isZero (void) { return x == 0 && y == 0; };

	test	edx, edx
	jne	SHORT $LN150@DXGIFactor
	test	eax, eax
	je	SHORT $LN91@DXGIFactor
$LN150@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3387 :         pDesc->BufferDesc.Width  = config.window.res.override.x;

	mov	ecx, edx

; 3388 :         pDesc->BufferDesc.Height = config.window.res.override.y;

	mov	edi, eax
	mov	DWORD PTR _stub_desc$10$[ebp], ecx
$LN89@DXGIFactor:
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 425  :         bool isZero (void) { return x == 0 && y == 0; };

	test	edx, edx
	jne	SHORT $LN154@DXGIFactor
	test	eax, eax
	je	SHORT $LN91@DXGIFactor
$LN154@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3403 :       pDesc->BufferDesc.Width  = config.window.res.override.x;

	mov	ecx, edx

; 3404 :       pDesc->BufferDesc.Height = config.window.res.override.y;

	mov	edi, eax
	mov	DWORD PTR _stub_desc$10$[ebp], ecx
$LN91@DXGIFactor:

; 3405 :     }
; 3406 : 
; 3407 : 
; 3408 :     if (config.render.dxgi.safe_fullscreen)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+488, 0
	je	SHORT $LN92@DXGIFactor

; 3409 :       pDesc->Flags |= DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

	or	esi, 2
$LN92@DXGIFactor:

; 3410 : 
; 3411 :     if (request_mode_change == mode_change_request_e::Fullscreen)

	cmp	DWORD PTR ?request_mode_change@@3W4mode_change_request_e@@A, 1 ; request_mode_change
	jne	SHORT $LN232@DXGIFactor

; 3412 :     {
; 3413 :       dll_log.Log ( L"[   DXGI   ]  >> User-Requested Mode Change: Fullscreen" );

	push	OFFSET ??_C@_1HA@INGGDHHB@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAU?$AAs?$AAe?$AAr?$AA?9?$AAR?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AAe?$AAd?$AA?5@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 3414 :       pDesc->Windowed = FALSE;

	xor	eax, eax
	add	esp, 8
	mov	DWORD PTR _stub_desc$12$[ebp], eax

; 3415 :       pDesc->Flags   |= DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

	or	esi, 2
	jmp	SHORT $LN93@DXGIFactor
$LN232@DXGIFactor:
	mov	eax, DWORD PTR _stub_desc$12$[ebp]
$LN93@DXGIFactor:

; 3416 :     }
; 3417 : 
; 3418 :     if (config.display.force_fullscreen && pDesc->Windowed)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+500, 0
	je	SHORT $LN94@DXGIFactor
	test	eax, eax
	je	SHORT $LN94@DXGIFactor

; 3419 :     {
; 3420 :       dll_log.Log ( L"[   DXGI   ]  >> Display Override "

	push	OFFSET ??_C@_1JG@HCAIICBG@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAD?$AAi?$AAs?$AAp?$AAl?$AAa?$AAy?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8

; 3421 :                     L"(Requested: Windowed, Using: Fullscreen)" );
; 3422 :       pDesc->Flags   |= DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
; 3423 :       pDesc->Windowed = FALSE;

	mov	DWORD PTR _stub_desc$12$[ebp], 0
	or	esi, 2
	jmp	SHORT $LN96@DXGIFactor
$LN94@DXGIFactor:

; 3424 :     }
; 3425 : 
; 3426 :     else if (config.display.force_windowed)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+501, 0
	je	SHORT $LN96@DXGIFactor

; 3427 :     {
; 3428 :       dll_log.Log ( L"[   DXGI   ]  >> Display Override "

	push	OFFSET ??_C@_1JG@LPALCGFK@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAD?$AAi?$AAs?$AAp?$AAl?$AAa?$AAy?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8

; 3429 :                     L"(Requested: Fullscreen, Using: Windowed)" );
; 3430 :       pDesc->Windowed = TRUE;

	mov	DWORD PTR _stub_desc$12$[ebp], 1
$LN96@DXGIFactor:

; 3431 :     }
; 3432 : 
; 3433 : #ifdef _WIN64
; 3434 :     if (! bFlipMode)
; 3435 :       bFlipMode =
; 3436 :         ( dxgi_caps.present.flip_sequential && (
; 3437 :           ( ! lstrcmpW (SK_GetHostApp (), L"Fallout4.exe")) ||
; 3438 :             SK_DS3_UseFlipMode ()        ) );
; 3439 : 
; 3440 :     if (! lstrcmpW (SK_GetHostApp (), L"Fallout4.exe"))
; 3441 :     {
; 3442 :       if (bFlipMode)
; 3443 :           bFlipMode = (! SK_FO4_IsFullscreen ()) && SK_FO4_UseFlipMode ();
; 3444 :     }
; 3445 : 
; 3446 :     else
; 3447 : #endif
; 3448 :     {
; 3449 :       // If forcing flip-model, then force multisampling off
; 3450 :       if (config.render.framerate.flip_discard)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+416, 0
	je	SHORT $LN230@DXGIFactor

; 3451 :       {
; 3452 :         bFlipMode = dxgi_caps.present.flip_sequential;

	mov	al, BYTE PTR ?dxgi_caps@@3Udxgi_caps_t@@A+2
	mov	BYTE PTR ?bFlipMode@@3_NA, al		; bFlipMode

; 3453 :         pDesc->SampleDesc.Count = 1; pDesc->SampleDesc.Quality = 0;
; 3454 : 
; 3455 :         // Format overrides must be performed in certain cases (sRGB / 10:10:10:2)
; 3456 :         switch (pDesc->BufferDesc.Format)

	mov	eax, DWORD PTR _stub_desc$8$[ebp]
	add	eax, -23				; ffffffe9H
	mov	DWORD PTR _stub_desc$6$[ebp], 1
	mov	DWORD PTR _stub_desc$7$[ebp], 0
	cmp	eax, 68					; 00000044H
	ja	SHORT $LN230@DXGIFactor
	movzx	eax, BYTE PTR $LN228@DXGIFactor[eax]
	jmp	DWORD PTR $LN237@DXGIFactor[eax*4]
$LN98@DXGIFactor:

; 3457 :         {
; 3458 :           case DXGI_FORMAT_B8G8R8A8_UNORM_SRGB:
; 3459 :             pDesc->BufferDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;

	mov	DWORD PTR _stub_desc$8$[ebp], 87	; 00000057H

; 3460 :             dll_log.Log ( L"[ DXGI 1.2 ]  >> sRGB (B8G8R8A8) Override Required to Enable Flip Model" );

	push	OFFSET ??_C@_1JA@NDGFBELE@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA2?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAs?$AAR?$AAG?$AAB?$AA?5?$AA?$CI?$AAB?$AA8?$AAG?$AA8?$AAR?$AA8?$AAA?$AA8?$AA?$CJ@

; 3461 :             break;

	jmp	SHORT $LN234@DXGIFactor
$LN99@DXGIFactor:

; 3462 :           case DXGI_FORMAT_R8G8B8A8_UNORM_SRGB:
; 3463 :             pDesc->BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
; 3464 :             dll_log.Log ( L"[ DXGI 1.2 ]  >> sRGB (R8G8B8A8) Override Required to Enable Flip Model" );

	push	OFFSET ??_C@_1JA@CCHCBLHJ@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA2?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAs?$AAR?$AAG?$AAB?$AA?5?$AA?$CI?$AAR?$AA8?$AAG?$AA8?$AAB?$AA8?$AAA?$AA8?$AA?$CJ@

; 3465 :             break;

	jmp	SHORT $LN235@DXGIFactor
$LN100@DXGIFactor:

; 3469 :             dll_log.Log ( L"[ DXGI 1.2 ]  >> RGBA 10:10:10:2 Override (to 8:8:8:8) Required to Enable Flip Model" );

	push	OFFSET ??_C@_1KK@LPPCBMFA@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA2?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAR?$AAG?$AAB?$AAA?$AA?5?$AA1?$AA0?$AA?3?$AA1?$AA0?$AA?3?$AA1?$AA0?$AA?3?$AA2@
$LN235@DXGIFactor:

; 3466 :           case DXGI_FORMAT_R10G10B10A2_UNORM:
; 3467 :           case DXGI_FORMAT_R10G10B10A2_TYPELESS:
; 3468 :             pDesc->BufferDesc.Format =  DXGI_FORMAT_R8G8B8A8_UNORM;

	mov	DWORD PTR _stub_desc$8$[ebp], 28	; 0000001cH
$LN234@DXGIFactor:

; 3469 :             dll_log.Log ( L"[ DXGI 1.2 ]  >> RGBA 10:10:10:2 Override (to 8:8:8:8) Required to Enable Flip Model" );

	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8
$LN230@DXGIFactor:

; 3470 :             break;
; 3471 :         }
; 3472 :       }
; 3473 :     }
; 3474 : 
; 3475 :     if (       config.render.framerate.buffer_count != -1                  &&
; 3476 :          (UINT)config.render.framerate.buffer_count !=  pDesc->BufferCount &&

	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+408
	cmp	ecx, -1
	je	SHORT $LN101@DXGIFactor
	mov	eax, DWORD PTR _stub_desc$2$[ebp]
	cmp	ecx, eax
	je	SHORT $LN101@DXGIFactor
	test	eax, eax
	je	SHORT $LN101@DXGIFactor

; 3477 :          pDesc->BufferCount                         !=  0 )
; 3478 :     {
; 3479 :       pDesc->BufferCount = config.render.framerate.buffer_count;

	mov	eax, ecx

; 3480 :       dll_log.Log (L"[   DXGI   ]  >> Buffer Count Override: %lu buffers", pDesc->BufferCount);

	push	eax
	push	OFFSET ??_C@_1GI@GAEBCHMN@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AAO?$AAv@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	mov	DWORD PTR _stub_desc$2$[ebp], eax
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+408
	add	esp, 12					; 0000000cH
$LN101@DXGIFactor:

; 3481 :     }
; 3482 : 
; 3483 :     if ( config.render.framerate.flip_discard && dxgi_caps.swapchain.allow_tearing )

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+416, 0
	je	SHORT $LN102@DXGIFactor
	cmp	DWORD PTR ?dxgi_caps@@3Udxgi_caps_t@@A+8, 0
	je	SHORT $LN102@DXGIFactor

; 3484 :     {
; 3485 :       pDesc->Flags |= DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING;
; 3486 :       dll_log.Log ( L"[ DXGI 1.5 ]  >> Tearing Option:  Enable" );

	push	OFFSET ??_C@_1FC@PILPBEPG@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAT?$AAe?$AAa?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAO?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?3@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	or	esi, 2048				; 00000800H
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 3487 :       pDesc->Windowed = TRUE;

	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+408
	add	esp, 8
	mov	DWORD PTR _stub_desc$12$[ebp], 1
$LN102@DXGIFactor:

; 3488 :     }
; 3489 : 
; 3490 :     if ( config.render.dxgi.scaling_mode != -1 &&

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+472
	cmp	eax, -1
	je	SHORT $LN103@DXGIFactor
	cmp	DWORD PTR _stub_desc$15$[ebp], eax
	je	SHORT $LN103@DXGIFactor

; 3491 :           pDesc->BufferDesc.Scaling      !=
; 3492 :             (DXGI_MODE_SCALING)config.render.dxgi.scaling_mode )
; 3493 :     {
; 3494 :       dll_log.Log ( L"[   DXGI   ]  >> Scaling Override "

	push	eax
	call	?SK_DXGI_DescribeScalingMode@@YAPB_WW4DXGI_MODE_SCALING@@@Z ; SK_DXGI_DescribeScalingMode
	add	esp, 4
	push	eax
	push	DWORD PTR _stub_desc$15$[ebp]
	call	?SK_DXGI_DescribeScalingMode@@YAPB_WW4DXGI_MODE_SCALING@@@Z ; SK_DXGI_DescribeScalingMode
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_1HK@PGANLAKP@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAS?$AAc?$AAa?$AAl?$AAi?$AAn?$AAg?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 3495 :                     L"(Requested: %s, Using: %s)",
; 3496 :                       SK_DXGI_DescribeScalingMode (
; 3497 :                         pDesc->BufferDesc.Scaling
; 3498 :                       ),
; 3499 :                         SK_DXGI_DescribeScalingMode (
; 3500 :                           (DXGI_MODE_SCALING)config.render.dxgi.scaling_mode
; 3501 :                         )
; 3502 :                   );
; 3503 : 
; 3504 :       pDesc->BufferDesc.Scaling =

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+472
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+408
	mov	DWORD PTR _stub_desc$15$[ebp], eax
$LN103@DXGIFactor:

; 3505 :         (DXGI_MODE_SCALING)config.render.dxgi.scaling_mode;
; 3506 :     }
; 3507 : 
; 3508 :     if ( config.render.dxgi.scanline_order != -1 &&

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+476
	cmp	eax, -1
	je	SHORT $LN104@DXGIFactor
	cmp	DWORD PTR _stub_desc$16$[ebp], eax
	je	SHORT $LN104@DXGIFactor

; 3509 :           pDesc->BufferDesc.ScanlineOrdering      !=
; 3510 :             (DXGI_MODE_SCANLINE_ORDER)config.render.dxgi.scanline_order )
; 3511 :     {
; 3512 :       dll_log.Log ( L"[   DXGI   ]  >> Scanline Override "

	push	eax
	call	?SK_DXGI_DescribeScanlineOrder@@YAPB_WW4DXGI_MODE_SCANLINE_ORDER@@@Z ; SK_DXGI_DescribeScanlineOrder
	add	esp, 4
	push	eax
	push	DWORD PTR _stub_desc$16$[ebp]
	call	?SK_DXGI_DescribeScanlineOrder@@YAPB_WW4DXGI_MODE_SCANLINE_ORDER@@@Z ; SK_DXGI_DescribeScanlineOrder
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_1HM@EKHBGJHP@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAS?$AAc?$AAa?$AAn?$AAl?$AAi?$AAn?$AAe?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 3513 :                     L"(Requested: %s, Using: %s)",
; 3514 :                       SK_DXGI_DescribeScanlineOrder (
; 3515 :                         pDesc->BufferDesc.ScanlineOrdering
; 3516 :                       ),
; 3517 :                         SK_DXGI_DescribeScanlineOrder (
; 3518 :                           (DXGI_MODE_SCANLINE_ORDER)config.render.dxgi.scanline_order
; 3519 :                         )
; 3520 :                   );
; 3521 : 
; 3522 :       pDesc->BufferDesc.ScanlineOrdering =

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+476
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+408
	mov	DWORD PTR _stub_desc$16$[ebp], eax
$LN104@DXGIFactor:

; 3523 :         (DXGI_MODE_SCANLINE_ORDER)config.render.dxgi.scanline_order;
; 3524 :     }
; 3525 : 
; 3526 :     if ( config.render.framerate.refresh_rate != -1 &&

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+424
	cmp	eax, -1
	je	SHORT $LN105@DXGIFactor
	mov	edx, DWORD PTR _stub_desc$14$[ebp]
	cmp	edx, eax
	je	SHORT $LN105@DXGIFactor

; 3527 :          pDesc->BufferDesc.RefreshRate.Numerator != (UINT)config.render.framerate.refresh_rate )
; 3528 :     {
; 3529 :       dll_log.Log ( L"[   DXGI   ]  >> Refresh Override "

	mov	ecx, DWORD PTR _stub_desc$13$[ebp]
	test	ecx, ecx
	je	SHORT $LN139@DXGIFactor
	movd	xmm0, edx
	cvtdq2pd xmm0, xmm0
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	cvtpd2ps xmm1, xmm0
	movd	xmm0, ecx
	cvtdq2pd xmm0, xmm0
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	cvtpd2ps xmm0, xmm0
	divss	xmm1, xmm0
	jmp	SHORT $LN157@DXGIFactor
$LN139@DXGIFactor:
	movss	xmm1, DWORD PTR __real@7fc00000
$LN157@DXGIFactor:
	push	eax
	cvtps2pd xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_1HM@GOOAFJFG@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAR?$AAe?$AAf?$AAr?$AAe?$AAs?$AAh?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 3530 :                     L"(Requested: %f, Using: %li)",
; 3531 :                  pDesc->BufferDesc.RefreshRate.Denominator != 0 ?
; 3532 :          static_cast <float> (pDesc->BufferDesc.RefreshRate.Numerator) /
; 3533 :          static_cast <float> (pDesc->BufferDesc.RefreshRate.Denominator) :
; 3534 :                      std::numeric_limits <float>::quiet_NaN (),
; 3535 :                         config.render.framerate.refresh_rate
; 3536 :                   );
; 3537 : 
; 3538 :       pDesc->BufferDesc.RefreshRate.Numerator   = config.render.framerate.refresh_rate;

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+424
	add	esp, 20					; 00000014H

; 3539 :       pDesc->BufferDesc.RefreshRate.Denominator = 1;

	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+408
	mov	DWORD PTR _stub_desc$14$[ebp], eax
	mov	DWORD PTR _stub_desc$13$[ebp], 1
$LN105@DXGIFactor:

; 3540 :     }
; 3541 : 
; 3542 :     bWait = bFlipMode && dxgi_caps.present.waitable;

	cmp	BYTE PTR ?bFlipMode@@3_NA, 0		; bFlipMode
	je	SHORT $LN143@DXGIFactor
	cmp	BYTE PTR ?dxgi_caps@@3Udxgi_caps_t@@A+4, 0
	je	SHORT $LN143@DXGIFactor

; 3543 : 
; 3544 :     // We cannot change the swapchain parameters if this is used...
; 3545 :     bWait = bWait && config.render.framerate.swapchain_wait > 0;

	cmp	DWORD PTR ?config@@3Usk_config_t@@A+420, 0
	jle	SHORT $LN143@DXGIFactor
	mov	dl, 1
	jmp	SHORT $LN236@DXGIFactor
$LN143@DXGIFactor:
	xor	dl, dl
$LN236@DXGIFactor:

; 3546 : 
; 3547 : #ifdef _WIN64
; 3548 :     if (! lstrcmpW (SK_GetHostApp (), L"DarkSoulsIII.exe"))
; 3549 :     {
; 3550 :       if (SK_DS3_IsBorderless ())
; 3551 :         pDesc->Flags &= ~DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
; 3552 :     }
; 3553 : #endif
; 3554 : 
; 3555 :     if (bFlipMode)

	cmp	BYTE PTR ?bFlipMode@@3_NA, 0		; bFlipMode
	mov	BYTE PTR ?bWait@@3_NA, dl		; bWait
	je	SHORT $LN106@DXGIFactor

; 3556 :     {
; 3557 :       if (bWait)

	test	dl, dl
	je	SHORT $LN108@DXGIFactor

; 3558 :         pDesc->Flags |= DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT;

	or	esi, 64					; 00000040H
$LN108@DXGIFactor:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 3743 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, 3
	cmp	ecx, eax
	cmovg	eax, ecx
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3564 :       if (config.render.framerate.flip_discard &&

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+416, 0
	mov	ecx, eax
	mov	DWORD PTR ?config@@3Usk_config_t@@A+408, ecx
	je	SHORT $LN109@DXGIFactor
	cmp	BYTE PTR ?dxgi_caps@@3Udxgi_caps_t@@A+3, 0
	je	SHORT $LN109@DXGIFactor

; 3565 :           dxgi_caps.present.flip_discard)
; 3566 :         pDesc->SwapEffect  = DXGI_SWAP_EFFECT_FLIP_DISCARD;

	mov	eax, 4
	mov	DWORD PTR _stub_desc$5$[ebp], eax

; 3567 :       else

	jmp	SHORT $LN111@DXGIFactor
$LN109@DXGIFactor:

; 3568 :         pDesc->SwapEffect  = DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL;

	mov	DWORD PTR _stub_desc$5$[ebp], 3
	jmp	SHORT $LN111@DXGIFactor
$LN106@DXGIFactor:

; 3569 :     }
; 3570 : 
; 3571 :     else if ( pDesc->SwapEffect != DXGI_SWAP_EFFECT_FLIP_DISCARD &&

	mov	eax, DWORD PTR _stub_desc$5$[ebp]
	cmp	eax, 4
	je	SHORT $LN111@DXGIFactor
	cmp	eax, 3
	je	SHORT $LN111@DXGIFactor

; 3572 :               pDesc->SwapEffect != DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL )
; 3573 :     {
; 3574 :       // Resort to triple-buffering if flip mode is not available
; 3575 :       if (config.render.framerate.buffer_count > 3)

	mov	eax, 3

; 3576 :         config.render.framerate.buffer_count = 3;
; 3577 : 
; 3578 :       pDesc->SwapEffect = DXGI_SWAP_EFFECT_DISCARD;

	mov	DWORD PTR _stub_desc$5$[ebp], 0
	cmp	ecx, eax
	cmovg	ecx, eax
	mov	DWORD PTR ?config@@3Usk_config_t@@A+408, ecx
$LN111@DXGIFactor:

; 3579 :     }
; 3580 : 
; 3581 :     if (config.render.framerate.buffer_count > 0)

	mov	eax, DWORD PTR _stub_desc$2$[ebp]
	test	ecx, ecx
	cmovg	eax, ecx

; 3582 :       pDesc->BufferCount = config.render.framerate.buffer_count;
; 3583 : 
; 3584 :     // We cannot switch modes on a waitable swapchain
; 3585 :     if (bFlipMode && bWait)

	cmp	BYTE PTR ?bFlipMode@@3_NA, 0		; bFlipMode
	mov	DWORD PTR _stub_desc$2$[ebp], eax
	je	SHORT $LN114@DXGIFactor
	test	dl, dl
	je	SHORT $LN114@DXGIFactor

; 3586 :     {
; 3587 :       pDesc->Flags |=  DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT;
; 3588 :       pDesc->Flags &= ~DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

	and	esi, -3					; fffffffdH
	or	esi, 64					; 00000040H
$LN114@DXGIFactor:

; 3592 :   dll_log.Log ( L"[ DXGI 1.2 ] >> Using %s Presentation Model  [Waitable: %s - %li ms]",

	xor	eax, eax
	mov	ecx, OFFSET ??_C@_15BICKNCBF@?$AAN?$AAo?$AA?$AA@
	test	dl, dl
	cmovne	eax, DWORD PTR ?config@@3Usk_config_t@@A+420
	push	eax
	mov	eax, OFFSET ??_C@_17PBAHFJOA@?$AAY?$AAe?$AAs?$AA?$AA@
	cmove	eax, ecx
	cmp	BYTE PTR ?bFlipMode@@3_NA, 0		; bFlipMode
	push	eax
	mov	ecx, OFFSET ??_C@_1BI@PKCOFIGO@?$AAT?$AAr?$AAa?$AAd?$AAi?$AAt?$AAi?$AAo?$AAn?$AAa?$AAl?$AA?$AA@
	mov	eax, OFFSET ??_C@_19EMFBKLJE@?$AAF?$AAl?$AAi?$AAp?$AA?$AA@
	cmove	eax, ecx
	push	eax
	push	OFFSET ??_C@_1IK@KCJJDMDA@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA2?$AA?5?$AA?$FN?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAU?$AAs?$AAi?$AAn?$AAg?$AA?5?$AA?$CF?$AAs?$AA?5?$AAP?$AAr?$AAe?$AAs?$AAe?$AAn?$AAt@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 251  :           bool isZero (void) { return x == 0 && y == 0; };

	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+460
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3592 :   dll_log.Log ( L"[ DXGI 1.2 ] >> Using %s Presentation Model  [Waitable: %s - %li ms]",

	add	esp, 20					; 00000014H
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 251  :           bool isZero (void) { return x == 0 && y == 0; };

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+464
	test	ecx, ecx
	jne	SHORT $LN164@DXGIFactor
	test	eax, eax
	je	SHORT $LN231@DXGIFactor
$LN164@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3598 :   if ((! config.render.dxgi.res.max.isZero ()) && pDesc->BufferDesc.Width > config.render.dxgi.res.max.x)

	mov	edx, DWORD PTR _stub_desc$10$[ebp]
	cmp	edx, ecx
	cmova	edx, ecx
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 251  :           bool isZero (void) { return x == 0 && y == 0; };

	test	ecx, ecx
	jne	SHORT $LN168@DXGIFactor
	test	eax, eax
	je	SHORT $LN116@DXGIFactor
$LN168@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3600 :   if ((! config.render.dxgi.res.max.isZero ()) && pDesc->BufferDesc.Height > config.render.dxgi.res.max.y)

	cmp	edi, eax
	cmova	edi, eax
	jmp	SHORT $LN116@DXGIFactor
$LN231@DXGIFactor:
	mov	edx, DWORD PTR _stub_desc$10$[ebp]
$LN116@DXGIFactor:
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 246  :           bool isZero (void) { return x == 0 && y == 0; };

	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+452
	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+456
	test	ecx, ecx
	jne	SHORT $LN172@DXGIFactor
	test	eax, eax
	jne	SHORT $LN176@DXGIFactor
	jmp	SHORT $LN224@DXGIFactor
$LN172@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3603 :   if ((! config.render.dxgi.res.min.isZero ()) && pDesc->BufferDesc.Width < config.render.dxgi.res.min.x)

	cmp	edx, ecx
	cmovb	edx, ecx
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 246  :           bool isZero (void) { return x == 0 && y == 0; };

	test	ecx, ecx
	jne	SHORT $LN176@DXGIFactor
	test	eax, eax
	je	SHORT $LN224@DXGIFactor
$LN176@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3605 :   if ((! config.render.dxgi.res.min.isZero ()) && pDesc->BufferDesc.Height < config.render.dxgi.res.min.y)

	cmp	edi, eax
	cmovb	edi, eax
$LN224@DXGIFactor:

; 3606 :     pDesc->BufferDesc.Height = config.render.dxgi.res.min.y;
; 3607 : 
; 3608 : 
; 3609 :   if (translated)
; 3610 :   {
; 3611 :     pDesc1->BufferCount                        = pDesc->BufferCount;

	mov	eax, DWORD PTR _stub_desc$2$[ebp]

; 3931 : 
; 3932 : 
; 3933 :   if (! CreateSwapChain_Lambchop ())

	lea	ecx, DWORD PTR _CreateSwapChain_Lambchop$[ebp]

; 3611 :     pDesc1->BufferCount                        = pDesc->BufferCount;

	mov	DWORD PTR _new_desc1$[ebp+28], eax

; 3612 :     pDesc1->BufferUsage                        = pDesc->BufferUsage;

	mov	eax, DWORD PTR _stub_desc$3$[ebp]
	mov	DWORD PTR _new_desc1$[ebp+24], eax

; 3614 :     pDesc1->SwapEffect                         = pDesc->SwapEffect;

	mov	eax, DWORD PTR _stub_desc$5$[ebp]
	mov	DWORD PTR _new_desc1$[ebp+36], eax

; 3615 :     pDesc1->SampleDesc.Count                   = pDesc->SampleDesc.Count;

	mov	eax, DWORD PTR _stub_desc$6$[ebp]
	mov	DWORD PTR _new_desc1$[ebp+16], eax

; 3616 :     pDesc1->SampleDesc.Quality                 = pDesc->SampleDesc.Quality;

	mov	eax, DWORD PTR _stub_desc$7$[ebp]
	mov	DWORD PTR _new_desc1$[ebp+20], eax

; 3617 :     pDesc1->Format                             = pDesc->BufferDesc.Format;

	mov	eax, DWORD PTR _stub_desc$8$[ebp]
	mov	DWORD PTR _new_desc1$[ebp+8], eax

; 3620 : 
; 3621 :     hWnd                                       = pDesc->OutputWindow;

	mov	eax, DWORD PTR _stub_desc$11$[ebp]
	mov	DWORD PTR _hWnd$[ebp], eax

; 3622 : 
; 3623 :     if (pFullscreenDesc != nullptr)
; 3624 :     {
; 3625 :       pFullscreenDesc->Windowed                = pDesc->Windowed;

	mov	eax, DWORD PTR _stub_desc$12$[ebp]
	mov	DWORD PTR _new_fullscreen_desc$[ebp+16], eax

; 3626 :       pFullscreenDesc->RefreshRate.Denominator = pDesc->BufferDesc.RefreshRate.Denominator;

	mov	eax, DWORD PTR _stub_desc$13$[ebp]
	mov	DWORD PTR _new_fullscreen_desc$[ebp+4], eax

; 3627 :       pFullscreenDesc->RefreshRate.Numerator   = pDesc->BufferDesc.RefreshRate.Numerator;

	mov	eax, DWORD PTR _stub_desc$14$[ebp]
	mov	DWORD PTR _new_fullscreen_desc$[ebp], eax

; 3628 :       pFullscreenDesc->Scaling                 = pDesc->BufferDesc.Scaling;

	mov	eax, DWORD PTR _stub_desc$15$[ebp]
	mov	DWORD PTR _new_fullscreen_desc$[ebp+12], eax

; 3629 :       pFullscreenDesc->ScanlineOrdering        = pDesc->BufferDesc.ScanlineOrdering;

	mov	eax, DWORD PTR _stub_desc$16$[ebp]
	mov	DWORD PTR _new_fullscreen_desc$[ebp+8], eax

; 3930 :       };

	lea	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR _CreateSwapChain_Lambchop$[ebp], eax
	lea	eax, DWORD PTR _This$[ebp]
	mov	DWORD PTR _CreateSwapChain_Lambchop$[ebp+4], eax
	lea	eax, DWORD PTR _pDevice$[ebp]
	mov	DWORD PTR _CreateSwapChain_Lambchop$[ebp+8], eax
	lea	eax, DWORD PTR _hWnd$[ebp]
	mov	DWORD PTR _CreateSwapChain_Lambchop$[ebp+12], eax
	lea	eax, DWORD PTR _pDesc$[ebp]
	mov	DWORD PTR _CreateSwapChain_Lambchop$[ebp+16], eax
	lea	eax, DWORD PTR _pFullscreenDesc$[ebp]
	mov	DWORD PTR _CreateSwapChain_Lambchop$[ebp+20], eax
	lea	eax, DWORD PTR _pRestrictToOutput$[ebp]
	mov	DWORD PTR _CreateSwapChain_Lambchop$[ebp+24], eax
	lea	eax, DWORD PTR _ppSwapChain$[ebp]
	mov	DWORD PTR _CreateSwapChain_Lambchop$[ebp+28], eax
	lea	eax, DWORD PTR _new_desc1$[ebp]
	mov	DWORD PTR _CreateSwapChain_Lambchop$[ebp+32], eax
	lea	eax, DWORD PTR _new_fullscreen_desc$[ebp]

; 3613 :     pDesc1->Flags                              = pDesc->Flags;

	mov	DWORD PTR _new_desc1$[ebp+44], esi

; 3618 :     pDesc1->Height                             = pDesc->BufferDesc.Height;

	mov	DWORD PTR _new_desc1$[ebp+4], edi

; 3619 :     pDesc1->Width                              = pDesc->BufferDesc.Width;

	mov	DWORD PTR _new_desc1$[ebp], edx

; 3930 :       };

	mov	DWORD PTR _CreateSwapChain_Lambchop$[ebp+36], eax

; 3931 : 
; 3932 : 
; 3933 :   if (! CreateSwapChain_Lambchop ())

	call	??R<lambda_e5c15a2c98a421a829fc4b087e72baa7>@@QBEHXZ ; <lambda_e5c15a2c98a421a829fc4b087e72baa7>::operator()
	pop	edi
	test	eax, eax
	jne	SHORT $LN3@DXGIFactor

; 3934 :   {
; 3935 :     // Fallback-on-Fail
; 3936 :     pDesc           = orig_desc1;

	mov	eax, DWORD PTR _orig_desc1$1$[ebp]

; 3937 :     pFullscreenDesc = orig_fullscreen_desc;
; 3938 : 
; 3939 :     CreateSwapChain_Lambchop ();

	lea	ecx, DWORD PTR _CreateSwapChain_Lambchop$[ebp]
	mov	DWORD PTR _pDesc$[ebp], eax
	mov	eax, DWORD PTR _orig_fullscreen_desc$1$[ebp]
	mov	DWORD PTR _pFullscreenDesc$[ebp], eax
	call	??R<lambda_e5c15a2c98a421a829fc4b087e72baa7>@@QBEHXZ ; <lambda_e5c15a2c98a421a829fc4b087e72baa7>::operator()
$LN3@DXGIFactor:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	ecx, DWORD PTR _iname$[ebp+20]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3943 :   return ret;

	mov	esi, DWORD PTR _ret$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	ecx, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN229@DXGIFactor
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	ecx
	push	DWORD PTR _iname$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN229@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3944 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
	npad	1
$LN237@DXGIFactor:
	DD	$LN100@DXGIFactor
	DD	$LN99@DXGIFactor
	DD	$LN98@DXGIFactor
	DD	$LN230@DXGIFactor
$LN228@DXGIFactor:
	DB	0
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?DXGIFactory2_CreateSwapChainForHwnd_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@PAUHWND__@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z$0:
	lea	ecx, DWORD PTR _iname$[ebp]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__ehhandler$?DXGIFactory2_CreateSwapChainForHwnd_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@PAUHWND__@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?DXGIFactory2_CreateSwapChainForHwnd_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@PAUHWND__@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DXGIFactory2_CreateSwapChainForHwnd_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@PAUHWND__@@PBUDXGI_SWAP_CHAIN_DESC1@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z ENDP ; DXGIFactory2_CreateSwapChainForHwnd_Override
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
;	COMDAT ??0<lambda_7769376daad0f42c2f9dc7182375e5d8>@@QAE@AAJAAPAUIDXGIFactory2@@AAPAUIUnknown@@2AAPBUDXGI_SWAP_CHAIN_DESC1@@AAPAUIDXGIOutput@@AAPAPAUIDXGISwapChain1@@AAU3@@Z
_TEXT	SEGMENT
_<ret>$ = 8						; size = 4
_<This>$ = 12						; size = 4
_<pDevice>$ = 16					; size = 4
_<pWindow>$ = 20					; size = 4
_<pDesc>$ = 24						; size = 4
_<pRestrictToOutput>$ = 28				; size = 4
_<ppSwapChain>$ = 32					; size = 4
_<new_desc1>$ = 36					; size = 4
??0<lambda_7769376daad0f42c2f9dc7182375e5d8>@@QAE@AAJAAPAUIDXGIFactory2@@AAPAUIUnknown@@2AAPBUDXGI_SWAP_CHAIN_DESC1@@AAPAUIDXGIOutput@@AAPAPAUIDXGISwapChain1@@AAU3@@Z PROC ; <lambda_7769376daad0f42c2f9dc7182375e5d8>::<lambda_7769376daad0f42c2f9dc7182375e5d8>, COMDAT
; _this$ = ecx

; 3864 :       };

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _<ret>$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _<This>$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR _<pDevice>$[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _<pWindow>$[ebp]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR _<pDesc>$[ebp]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR _<pRestrictToOutput>$[ebp]
	mov	DWORD PTR [ecx+20], eax
	mov	eax, DWORD PTR _<ppSwapChain>$[ebp]
	mov	DWORD PTR [ecx+24], eax
	mov	eax, DWORD PTR _<new_desc1>$[ebp]
	mov	DWORD PTR [ecx+28], eax
	mov	eax, ecx
	pop	ebp
	ret	32					; 00000020H
??0<lambda_7769376daad0f42c2f9dc7182375e5d8>@@QAE@AAJAAPAUIDXGIFactory2@@AAPAUIUnknown@@2AAPBUDXGI_SWAP_CHAIN_DESC1@@AAPAUIDXGIOutput@@AAPAPAUIDXGISwapChain1@@AAU3@@Z ENDP ; <lambda_7769376daad0f42c2f9dc7182375e5d8>::<lambda_7769376daad0f42c2f9dc7182375e5d8>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
;	COMDAT ??R<lambda_7769376daad0f42c2f9dc7182375e5d8>@@QBEHXZ
_TEXT	SEGMENT
_desc$2 = -108						; size = 60
_client$3 = -48						; size = 16
_pSwapChain$4 = -32					; size = 4
_pDevice$1$ = -28					; size = 4
_pDevice1$5 = -24					; size = 4
_pSwapChain2$6 = -20					; size = 4
_pDev$7 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??R<lambda_7769376daad0f42c2f9dc7182375e5d8>@@QBEHXZ PROC ; <lambda_7769376daad0f42c2f9dc7182375e5d8>::operator(), COMDAT
; _this$ = ecx

; 3845 :       {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??R<lambda_7769376daad0f42c2f9dc7182375e5d8>@@QBEHXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 96					; 00000060H
	push	esi
	mov	esi, ecx

; 3846 :         DXGI_CALL( ret, CreateSwapChainForCoreWindow_Original (

	mov	eax, DWORD PTR [esi+24]
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+20]
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+16]
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+12]
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+8]
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+4]
	push	DWORD PTR [eax]
	call	DWORD PTR ?CreateSwapChainForCoreWindow_Original@@3P6GJPAUIDXGIFactory2@@PAUIUnknown@@1PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@ZA ; CreateSwapChainForCoreWindow_Original
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [eax]
	call	?SK_DescribeHRESULT@@YGPB_WJ@Z		; SK_DescribeHRESULT
	push	eax
	push	OFFSET ??_C@_1BBK@GBNFCBJD@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?$FL?$AA?$EA?$AA?$FN?$AA?5?$AA?5?$AAR?$AAe?$AAt?$AAu?$AAr?$AAn?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AA?5?$AA?9?$AA?5@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 3847 :                           This,
; 3848 :                             pDevice,
; 3849 :                               pWindow,
; 3850 :                                 pDesc,
; 3851 :                                   pRestrictToOutput,
; 3852 :                                     ppSwapChain ) );
; 3853 :       
; 3854 :         if ( SUCCEEDED (ret)         &&
; 3855 :              ppSwapChain  != nullptr &&

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [eax], 0
	jl	$LN2@operator
	mov	eax, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	$LN2@operator
	cmp	DWORD PTR [edx], 0
	je	$LN2@operator

; 3858 :           SK_DXGI_CreateSwapChain1_PostInit (pDevice, &new_desc1, nullptr, ppSwapChain);

	mov	ecx, DWORD PTR [esi+28]
	mov	eax, DWORD PTR [esi+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR _pSwapChain$4[ebp], esi
	push	ebx
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3858 :           SK_DXGI_CreateSwapChain1_PostInit (pDevice, &new_desc1, nullptr, ppSwapChain);

	mov	eax, DWORD PTR [eax]

; 3730 :   desc.BufferDesc.Height  = pDesc1->Height;

	mov	ebx, DWORD PTR [ecx+4]

; 3858 :           SK_DXGI_CreateSwapChain1_PostInit (pDevice, &new_desc1, nullptr, ppSwapChain);

	mov	DWORD PTR _pDevice$1$[ebp], eax
	push	edi

; 3729 :   desc.BufferDesc.Width   = pDesc1->Width;

	mov	edi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 163  :         if (p != NULL)

	test	esi, esi
	je	SHORT $LN13@operator

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [esi]
	push	esi
	call	DWORD PTR [eax+4]
$LN13@operator:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3647 :   SK_RunOnce (SK_CEGUI_QueueResetD3D11 ());

	cmp	BYTE PTR ?first@?2??SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z@4_NA, 0 ; `SK_DXGI_CreateSwapChain_PostInit'::`3'::first

; 3748 :   CComQIPtr <IDXGISwapChain> pSwapChain ((*ppSwapChain1));

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3647 :   SK_RunOnce (SK_CEGUI_QueueResetD3D11 ());

	je	SHORT $LN18@operator
	call	?SK_CEGUI_QueueResetD3D11@@YAXXZ	; SK_CEGUI_QueueResetD3D11
	mov	BYTE PTR ?first@?2??SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z@4_NA, 0 ; `SK_DXGI_CreateSwapChain_PostInit'::`3'::first
$LN18@operator:

; 3648 : 
; 3649 :   if (pDesc->BufferDesc.Width != 0)

	test	edi, edi
	je	SHORT $LN19@operator

; 3650 :   {
; 3651 :     SK_SetWindowResX (pDesc->BufferDesc.Width);

	push	edi
	call	?SK_SetWindowResX@@YAXJ@Z		; SK_SetWindowResX

; 3652 :     SK_SetWindowResY (pDesc->BufferDesc.Height);

	push	ebx

; 3653 :   }
; 3654 : 
; 3655 :   else

	jmp	SHORT $LN100@operator
$LN19@operator:

; 3656 :   {
; 3657 :     RECT client;
; 3658 : 
; 3659 :     GetClientRect    (game_window.hWnd, &client);

	lea	eax, DWORD PTR _client$3[ebp]
	push	eax
	push	DWORD PTR ?game_window@@3Usk_window_s@@A+4
	call	DWORD PTR __imp__GetClientRect@8

; 3660 :     SK_SetWindowResX (client.right  - client.left);

	mov	eax, DWORD PTR _client$3[ebp+8]
	sub	eax, DWORD PTR _client$3[ebp]
	push	eax
	call	?SK_SetWindowResX@@YAXJ@Z		; SK_SetWindowResX

; 3661 :     SK_SetWindowResY (client.bottom - client.top);

	mov	eax, DWORD PTR _client$3[ebp+12]
	sub	eax, DWORD PTR _client$3[ebp+4]
	push	eax
$LN100@operator:
	call	?SK_SetWindowResY@@YAXJ@Z		; SK_SetWindowResY
	add	esp, 8

; 3662 :   }
; 3663 : 
; 3664 :   SK_RunOnce (SK_DXGI_HookSwapChain (*ppSwapChain));

	cmp	BYTE PTR ?first@?M@??SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z@4_NA, 0 ; `SK_DXGI_CreateSwapChain_PostInit'::`12'::first
	je	SHORT $LN21@operator
	push	esi
	call	?SK_DXGI_HookSwapChain@@YAXPAUIDXGISwapChain@@@Z ; SK_DXGI_HookSwapChain
	add	esp, 4
	mov	BYTE PTR ?first@?M@??SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z@4_NA, 0 ; `SK_DXGI_CreateSwapChain_PostInit'::`12'::first
$LN21@operator:

; 3665 : 
; 3666 :   //if (bFlipMode || bWait)
; 3667 :     //DXGISwap_ResizeBuffers_Override (*ppSwapChain, config.render.framerate.buffer_count,
; 3668 :     //pDesc->BufferDesc.Width, pDesc->BufferDesc.Height, pDesc->BufferDesc.Format, pDesc->Flags);
; 3669 : 
; 3670 :   const uint32_t max_latency = config.render.framerate.pre_render_limit;

	mov	ebx, DWORD PTR ?config@@3Usk_config_t@@A+400
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pSwapChain2$6[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3674 :   if ( bFlipMode && bWait &&

	cmp	BYTE PTR ?bFlipMode@@3_NA, 0		; bFlipMode
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	je	SHORT $LN97@operator
	cmp	BYTE PTR ?bWait@@3_NA, 0		; bWait
	je	SHORT $LN97@operator
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _pSwapChain2$6[ebp]
	push	ecx
	push	OFFSET __GUID_a8be2ac4_199f_4946_b331_79599fb98de7
	push	esi
	call	DWORD PTR [eax]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3674 :   if ( bFlipMode && bWait &&

	test	eax, eax
	js	SHORT $LN97@operator

; 3675 :        SUCCEEDED ( (*ppSwapChain)->QueryInterface <IDXGISwapChain2> (&pSwapChain2) )
; 3676 :       )
; 3677 :   {
; 3678 :     if (max_latency < 16)

	cmp	ebx, 16					; 00000010H
	jae	SHORT $LN23@operator

; 3679 :     {
; 3680 :       dll_log.Log (L"[   DXGI   ] Setting Swapchain Frame Latency: %lu", max_latency);

	push	ebx
	push	OFFSET ??_C@_1GE@BOIALL@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAS?$AAw?$AAa?$AAp?$AAc?$AAh?$AAa?$AAi?$AAn?$AA?5?$AAF@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 3681 :       pSwapChain2->SetMaximumFrameLatency (max_latency);

	mov	eax, DWORD PTR _pSwapChain2$6[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	push	ebx
	push	eax
	call	DWORD PTR [ecx+124]
$LN23@operator:

; 3682 :     }
; 3683 : 
; 3684 :     HANDLE hWait =
; 3685 :       pSwapChain2->GetFrameLatencyWaitableObject ();

	mov	eax, DWORD PTR _pSwapChain2$6[ebp]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+132]

; 3686 : 
; 3687 :     WaitForSingleObjectEx ( hWait,

	push	1
	push	500					; 000001f4H
	push	eax
	call	DWORD PTR __imp__WaitForSingleObjectEx@12
$LN97@operator:

; 3688 :                               500,//config.render.framerate.swapchain_wait,
; 3689 :                                 TRUE );
; 3690 :   }
; 3691 : 
; 3692 :   {
; 3693 :     if (max_latency != -1)

	cmp	ebx, -1
	je	SHORT $LN98@operator
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pDevice1$5[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3697 :       if (SUCCEEDED ( (*ppSwapChain)->GetDevice (

	mov	edi, DWORD PTR [esi]
	lea	eax, DWORD PTR _pDevice1$5[ebp]
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??$IID_PPV_ARGS_Helper@UIDXGIDevice1@@@@YAPAPAXPAPAUIDXGIDevice1@@@Z ; IID_PPV_ARGS_Helper<IDXGIDevice1>
	add	esp, 4
	push	eax
	push	OFFSET __GUID_77db970f_6276_48ba_ba28_070143b4392c
	push	esi
	call	DWORD PTR [edi+28]
	test	eax, eax
	js	SHORT $LN25@operator

; 3698 :                          IID_PPV_ARGS (&pDevice1)
; 3699 :                       )
; 3700 :                     )
; 3701 :          )
; 3702 :       {
; 3703 :         dll_log.Log (L"[   DXGI   ] Setting Device Frame Latency: %lu", max_latency);

	push	ebx
	push	OFFSET ??_C@_1FO@CKMCMFKO@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AAF?$AAr?$AAa?$AAm@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 3704 :         pDevice1->SetMaximumFrameLatency (max_latency);

	mov	eax, DWORD PTR _pDevice1$5[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	push	ebx
	push	eax
	call	DWORD PTR [ecx+48]
$LN25@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	mov	eax, DWORD PTR _pDevice1$5[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3706 :     }

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN98@operator

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN98@operator:

; 623  :         if (lp != NULL)

	mov	edx, DWORD PTR _pDevice$1$[ebp]

; 158  :         p = NULL;

	xor	ecx, ecx
	mov	DWORD PTR _pDev$7[ebp], ecx

; 623  :         if (lp != NULL)

	test	edx, edx
	je	SHORT $LN61@operator

; 624  :         {
; 625  :             if (FAILED(lp->QueryInterface(*piid, (void **)&this->p)))

	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR _pDev$7[ebp]
	push	ecx
	push	OFFSET __GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140
	push	edx
	call	DWORD PTR [eax]
	mov	ecx, DWORD PTR _pDev$7[ebp]
	xor	edx, edx
	test	eax, eax
	cmovs	ecx, edx
	mov	DWORD PTR _pDev$7[ebp], ecx
$LN61@operator:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3709 :   CComQIPtr <ID3D11Device> pDev (pDevice);

	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 214  :         return p == pT;

	test	ecx, ecx
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3711 :   if (pDev != nullptr)

	je	SHORT $LN26@operator

; 3712 :   {
; 3713 :     g_pD3D11Dev = pDev;
; 3714 : 
; 3715 :     SK_GetCurrentRenderBackend ().fullscreen_exclusive = (! pDesc->Windowed);

	cmp	DWORD PTR _desc$2[ebp+48], 0
	mov	DWORD PTR ?g_pD3D11Dev@@3PAUID3D11Device@@A, ecx ; g_pD3D11Dev
	sete	bl
	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend
	mov	BYTE PTR [eax+48], bl
	mov	ecx, DWORD PTR _pDev$7[ebp]
$LN26@operator:

; 3717 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	pop	edi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	ecx, ecx
	je	SHORT $LN80@operator

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN80@operator:

; 176  :         if (p)

	mov	eax, DWORD PTR _pSwapChain2$6[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3717 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN86@operator

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN86@operator:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3750 :   return SK_DXGI_CreateSwapChain_PostInit ( pDevice, &desc, &pSwapChain );

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	esi, esi
	je	SHORT $LN95@operator

; 177  :             p->Release();

	mov	eax, DWORD PTR [esi]
	push	esi
	call	DWORD PTR [eax+8]
$LN95@operator:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3860 :           return TRUE;

	mov	eax, 1
	pop	esi

; 3861 :         }
; 3862 : 
; 3863 :         return FALSE;
; 3864 :       };

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@operator:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	xor	eax, eax
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??R<lambda_7769376daad0f42c2f9dc7182375e5d8>@@QBEHXZ$0:
	lea	ecx, DWORD PTR _pSwapChain$4[ebp]
	jmp	??1?$CComQIPtr@UIDXGISwapChain@@$1?_GUID_310d36a0_d2e7_4c0a_aa04_6a9d23b8886a@@3U__s_GUID@@B@ATL@@QAE@XZ
__unwindfunclet$??R<lambda_7769376daad0f42c2f9dc7182375e5d8>@@QBEHXZ$1:
	lea	ecx, DWORD PTR _pSwapChain2$6[ebp]
	jmp	??1?$CComPtr@UIDXGISwapChain2@@@ATL@@QAE@XZ
__unwindfunclet$??R<lambda_7769376daad0f42c2f9dc7182375e5d8>@@QBEHXZ$2:
	lea	ecx, DWORD PTR _pDevice1$5[ebp]
	jmp	??1?$CComPtr@UIDXGIDevice1@@@ATL@@QAE@XZ
__unwindfunclet$??R<lambda_7769376daad0f42c2f9dc7182375e5d8>@@QBEHXZ$3:
	lea	ecx, DWORD PTR _pDev$7[ebp]
	jmp	??1?$CComQIPtr@UID3D11Device@@$1?_GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140@@3U__s_GUID@@B@ATL@@QAE@XZ
__ehhandler$??R<lambda_7769376daad0f42c2f9dc7182375e5d8>@@QBEHXZ:
	mov	eax, OFFSET __ehfuncinfo$??R<lambda_7769376daad0f42c2f9dc7182375e5d8>@@QBEHXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??R<lambda_7769376daad0f42c2f9dc7182375e5d8>@@QBEHXZ ENDP ; <lambda_7769376daad0f42c2f9dc7182375e5d8>::operator()
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
$T2 = -396						; size = 48
$T3 = -348						; size = 48
$T4 = -300						; size = 48
$T5 = -252						; size = 24
_stub_desc$6 = -228					; size = 60
_iname$ = -168						; size = 24
_CreateSwapChain_Lambchop$ = -144			; size = 32
_new_desc1$ = -112					; size = 48
_orig_desc$1$ = -64					; size = 4
_stub_desc$3$ = -60					; size = 4
_ret$ = -56						; size = 4
_stub_desc$7$ = -52					; size = 4
_stub_desc$6$ = -48					; size = 4
_stub_desc$13$ = -44					; size = 4
tv1481 = -40						; size = 4
tv1482 = -36						; size = 4
_stub_desc$10$ = -32					; size = 4
_stub_desc$8$ = -28					; size = 4
_stub_desc$5$ = -24					; size = 4
_stub_desc$2$ = -20					; size = 4
_stub_desc$12$ = -16					; size = 4
tv1411 = -16						; size = 4
tv1409 = -16						; size = 4
tv1407 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_This$ = 8						; size = 4
_pDevice$ = 12						; size = 4
_pWindow$ = 16						; size = 4
_pDesc$ = 20						; size = 4
_pRestrictToOutput$ = 24				; size = 4
_ppSwapChain$ = 28					; size = 4
?DXGIFactory2_CreateSwapChainForCoreWindow_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@1PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z PROC ; DXGIFactory2_CreateSwapChainForCoreWindow_Override

; 3820 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DXGIFactory2_CreateSwapChainForCoreWindow_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@1PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 384				; 00000180H
	push	esi

; 3821 :   std::wstring iname = SK_GetDXGIFactoryInterface (This);

	push	DWORD PTR _This$[ebp]
	lea	eax, DWORD PTR _iname$[ebp]
	push	eax
	call	?SK_GetDXGIFactoryInterface@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUIUnknown@@@Z ; SK_GetDXGIFactoryInterface

; 3824 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"CreateSwapChainForCoreWindow         ",

	push	8192					; 00002000H
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??_U@YAPAXI@Z				; operator new[]
	mov	esi, eax
	add	esp, 12					; 0000000cH
	test	esi, esi
	je	SHORT $LN6@DXGIFactor
	push	8192					; 00002000H
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN7@DXGIFactor
$LN6@DXGIFactor:
	xor	esi, esi
$LN7@DXGIFactor:
	push	edi
	lea	edi, DWORD PTR [esi+2048]
	test	esi, esi
	je	$LN2@DXGIFactor
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR _iname$[ebp+20], 8

; 1621 : 		return (_Large_string_engaged()

	lea	eax, DWORD PTR _iname$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3824 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"CreateSwapChainForCoreWindow         ",

	push	OFFSET $SG356935
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	cmovae	eax, DWORD PTR _iname$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3824 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"CreateSwapChainForCoreWindow         ",

	push	eax
	push	OFFSET $SG356936
	push	esi
	call	__swprintf
	push	DWORD PTR _ppSwapChain$[ebp]
	push	DWORD PTR _pDesc$[ebp]
	push	DWORD PTR _pDevice$[ebp]
	push	OFFSET $SG356937
	push	edi
	call	__swprintf
	push	edi
	push	esi
	lea	eax, DWORD PTR [edi+2048]
	push	OFFSET $SG356938
	push	eax
	call	__swprintf
	mov	eax, DWORD PTR __$ReturnAddr$[ebp]
	add	esp, 52					; 00000034H
	push	eax
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	?SK_SummarizeCaller@@YG?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAX@Z ; SK_SummarizeCaller
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN44@DXGIFactor
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN44@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3824 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"CreateSwapChainForCoreWindow         ",

	push	eax
	lea	eax, DWORD PTR [edi+2048]
	push	eax
	push	OFFSET $SG356939
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T5[ebp+20]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3824 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"CreateSwapChainForCoreWindow         ",

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN54@DXGIFactor
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T5[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN54@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3824 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"CreateSwapChainForCoreWindow         ",

	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@DXGIFactor:

; 3825 :                        L"%ph, %ph, %ph",
; 3826 :                          pDevice, pDesc, ppSwapChain );
; 3827 : 
; 3828 :   HRESULT ret = E_FAIL;
; 3829 : 
; 3830 :   auto                   orig_desc = pDesc;

	mov	eax, DWORD PTR _pDesc$[ebp]
	mov	DWORD PTR _ret$[ebp], -2147467259	; 80004005H
	mov	DWORD PTR _orig_desc$1$[ebp], eax

; 3831 :   DXGI_SWAP_CHAIN_DESC1  new_desc1 =
; 3832 :     pDesc != nullptr ?

	test	eax, eax
	je	SHORT $LN8@DXGIFactor
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR $T4[ebp], xmm0
	movups	xmm0, XMMWORD PTR [eax+16]
	movups	XMMWORD PTR $T4[ebp+16], xmm0
	movups	xmm0, XMMWORD PTR [eax+32]
	lea	eax, DWORD PTR $T4[ebp]
	movups	XMMWORD PTR $T4[ebp+32], xmm0
	jmp	SHORT $LN9@DXGIFactor
$LN8@DXGIFactor:
	push	48					; 00000030H
	lea	eax, DWORD PTR $T3[ebp]
	push	0
	push	eax
	call	_memset
	movups	xmm0, XMMWORD PTR $T3[ebp]
	add	esp, 12					; 0000000cH
	lea	eax, DWORD PTR $T2[ebp]
	movups	XMMWORD PTR $T2[ebp], xmm0
	movups	xmm0, XMMWORD PTR $T3[ebp+16]
	movups	XMMWORD PTR $T2[ebp+16], xmm0
	movups	xmm0, XMMWORD PTR $T3[ebp+32]
	movups	XMMWORD PTR $T2[ebp+32], xmm0
$LN9@DXGIFactor:
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR _new_desc1$[ebp], xmm0
	movups	xmm0, XMMWORD PTR [eax+16]
	movups	XMMWORD PTR _new_desc1$[ebp+16], xmm0
	movups	xmm0, XMMWORD PTR [eax+32]
	movups	XMMWORD PTR _new_desc1$[ebp+32], xmm0

; 3295 :   WaitForInit ();

	call	?WaitForInitDXGI@@YAXXZ			; WaitForInitDXGI
	call	?WaitForInit@@YAXXZ			; WaitForInit

; 3296 : 
; 3297 :   DXGI_SWAP_CHAIN_DESC stub_desc  = {   }; // Stores common attributes between DESC and DESC1

	push	60					; 0000003cH
	lea	eax, DWORD PTR _stub_desc$6[ebp]
	push	0
	push	eax
	call	_memset

; 3298 :   bool                 translated = false;
; 3299 : 
; 3300 :   if (pDesc1 != nullptr)
; 3301 :   {
; 3302 :     if (pDesc == nullptr)
; 3303 :     {
; 3304 :       pDesc = &stub_desc;
; 3305 : 
; 3306 :       stub_desc.BufferCount                        = pDesc1->BufferCount;
; 3307 :       stub_desc.BufferUsage                        = pDesc1->BufferUsage;
; 3308 :       stub_desc.Flags                              = pDesc1->Flags;
; 3309 :       stub_desc.SwapEffect                         = pDesc1->SwapEffect;
; 3310 :       stub_desc.SampleDesc.Count                   = pDesc1->SampleDesc.Count;

	mov	ecx, DWORD PTR _new_desc1$[ebp+16]
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _new_desc1$[ebp+28]
	mov	esi, DWORD PTR _new_desc1$[ebp+44]

; 3311 :       stub_desc.SampleDesc.Quality                 = pDesc1->SampleDesc.Quality;
; 3312 :       stub_desc.BufferDesc.Format                  = pDesc1->Format;
; 3313 :       stub_desc.BufferDesc.Height                  = pDesc1->Height;

	mov	edi, DWORD PTR _new_desc1$[ebp+4]
	mov	DWORD PTR _stub_desc$6$[ebp], ecx
	mov	ecx, DWORD PTR _new_desc1$[ebp+20]
	mov	DWORD PTR _stub_desc$2$[ebp], eax
	mov	eax, DWORD PTR _new_desc1$[ebp+24]
	mov	DWORD PTR _stub_desc$7$[ebp], ecx
	mov	ecx, DWORD PTR _new_desc1$[ebp+8]
	mov	DWORD PTR _stub_desc$3$[ebp], eax
	mov	eax, DWORD PTR _new_desc1$[ebp+36]
	mov	DWORD PTR _stub_desc$8$[ebp], ecx

; 3314 :       stub_desc.BufferDesc.Width                   = pDesc1->Width;

	mov	ecx, DWORD PTR _new_desc1$[ebp]
	mov	DWORD PTR _stub_desc$5$[ebp], eax
	mov	DWORD PTR _stub_desc$10$[ebp], ecx

; 3338 :     dll_log.LogEx ( true,

	test	eax, eax
	jne	SHORT $LN130@DXGIFactor
	mov	edx, OFFSET ??_C@_1BA@EMGLPOHC@?$AAD?$AAi?$AAs?$AAc?$AAa?$AAr?$AAd?$AA?$AA@
	jmp	SHORT $LN125@DXGIFactor
$LN130@DXGIFactor:
	cmp	eax, 1
	jne	SHORT $LN128@DXGIFactor
	mov	edx, OFFSET ??_C@_1BG@MBNPLCBJ@?$AAS?$AAe?$AAq?$AAu?$AAe?$AAn?$AAt?$AAi?$AAa?$AAl?$AA?$AA@
	jmp	SHORT $LN125@DXGIFactor
$LN128@DXGIFactor:
	cmp	eax, 2
	jne	SHORT $LN126@DXGIFactor
	mov	edx, OFFSET ??_C@_1BE@BGMELJBK@?$AA?$DM?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?$DO?$AA?$AA@
	jmp	SHORT $LN125@DXGIFactor
$LN126@DXGIFactor:
	cmp	eax, 3
	jne	SHORT $LN124@DXGIFactor
	mov	edx, OFFSET ??_C@_1CA@DEGLGFCG@?$AAF?$AAl?$AAi?$AAp?$AA?5?$AAS?$AAe?$AAq?$AAu?$AAe?$AAn?$AAt?$AAi?$AAa?$AAl?$AA?$AA@
	jmp	SHORT $LN125@DXGIFactor
$LN124@DXGIFactor:
	cmp	eax, 4
	mov	DWORD PTR tv1407[ebp], OFFSET ??_C@_1BE@BGMELJBK@?$AA?$DM?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?$DO?$AA?$AA@
	mov	edx, OFFSET ??_C@_1BK@OJAHAHGF@?$AAF?$AAl?$AAi?$AAp?$AA?5?$AAD?$AAi?$AAs?$AAc?$AAa?$AAr?$AAd?$AA?$AA@
	cmovne	edx, DWORD PTR tv1407[ebp]
$LN125@DXGIFactor:
	mov	eax, DWORD PTR _stub_desc$6[ebp+20]
	test	eax, eax
	jne	SHORT $LN134@DXGIFactor
	mov	DWORD PTR tv1482[ebp], OFFSET ??_C@_1BI@DELFJJPB@?$AAU?$AAn?$AAs?$AAp?$AAe?$AAc?$AAi?$AAf?$AAi?$AAe?$AAd?$AA?$AA@
	jmp	SHORT $LN133@DXGIFactor
$LN134@DXGIFactor:
	cmp	eax, 1
	jne	SHORT $LN132@DXGIFactor
	mov	DWORD PTR tv1482[ebp], OFFSET ??_C@_1BI@JFLEIIEG@?$AAP?$AAr?$AAo?$AAg?$AAr?$AAe?$AAs?$AAs?$AAi?$AAv?$AAe?$AA?$AA@
	jmp	SHORT $LN133@DXGIFactor
$LN132@DXGIFactor:
	cmp	DWORD PTR _stub_desc$6[ebp+20], 2
	mov	eax, OFFSET ??_C@_1CA@MIMOHAAK@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAl?$AAa?$AAc?$AAe?$AAd?$AA?5?$AAE?$AAv?$AAe?$AAn?$AA?$AA@
	mov	DWORD PTR tv1409[ebp], OFFSET ??_C@_1BO@NBKANNIC@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAl?$AAa?$AAc?$AAe?$AAd?$AA?5?$AAO?$AAd?$AAd?$AA?$AA@
	cmovne	eax, DWORD PTR tv1409[ebp]
	mov	DWORD PTR tv1482[ebp], eax
$LN133@DXGIFactor:
	cmp	DWORD PTR _stub_desc$6[ebp+24], 0
	jne	SHORT $LN136@DXGIFactor
	mov	DWORD PTR tv1481[ebp], OFFSET ??_C@_1BI@DELFJJPB@?$AAU?$AAn?$AAs?$AAp?$AAe?$AAc?$AAi?$AAf?$AAi?$AAe?$AAd?$AA?$AA@
	jmp	SHORT $LN137@DXGIFactor
$LN136@DXGIFactor:
	cmp	DWORD PTR _stub_desc$6[ebp+24], 1
	mov	eax, OFFSET ??_C@_1BC@NODLAKGH@?$AAC?$AAe?$AAn?$AAt?$AAe?$AAr?$AAe?$AAd?$AA?$AA@
	mov	DWORD PTR tv1411[ebp], OFFSET ??_C@_1BE@OKCKFGLA@?$AAS?$AAt?$AAr?$AAe?$AAt?$AAc?$AAh?$AAe?$AAd?$AA?$AA@
	cmovne	eax, DWORD PTR tv1411[ebp]
	mov	DWORD PTR tv1481[ebp], eax
$LN137@DXGIFactor:
	mov	eax, DWORD PTR _stub_desc$6[ebp+12]
	test	eax, eax
	mov	DWORD PTR _stub_desc$12$[ebp], eax
	mov	eax, DWORD PTR _stub_desc$6[ebp+8]
	mov	DWORD PTR _stub_desc$13$[ebp], eax
	je	SHORT $LN138@DXGIFactor
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	eax, DWORD PTR _stub_desc$6[ebp+12]
	cvtpd2ps xmm1, xmm0
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	divss	xmm1, xmm0
	jmp	SHORT $LN147@DXGIFactor
$LN138@DXGIFactor:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits

; 1119 : 		return (__builtin_nanf("0"));

	movss	xmm1, DWORD PTR __real@7fc00000
$LN147@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3338 :     dll_log.LogEx ( true,

	push	edx
	mov	edx, DWORD PTR _stub_desc$2$[ebp]
	push	esi
	push	edx
	push	OFFSET ??_C@_1BC@PMICBOA@?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAe?$AAd?$AA?$AA@
	push	DWORD PTR tv1482[ebp]
	cvtps2pd xmm0, xmm1
	push	DWORD PTR tv1481[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	edi
	push	ecx
	push	OFFSET ??_C@_1BAE@FEHGBMOO@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AAS?$AAw?$AAa?$AAp?$AAC?$AAh?$AAa?$AAi?$AAn?$AA?3?$AA?5?$AA?$CI?$AA?$CF?$AAl?$AAu?$AAx?$AA?$CF?$AAl@
	push	1
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	add	esp, 52					; 00000034H

; 3339 :       L"[   DXGI   ]  SwapChain: (%lux%lu @ %4.1f Hz - Scaling: %s - Scanlines: %s) - {%s}"
; 3340 :       L" [%lu Buffers] :: Flags=0x%04X, SwapEffect: %s\n",
; 3341 :       pDesc->BufferDesc.Width,
; 3342 :       pDesc->BufferDesc.Height,
; 3343 :       pDesc->BufferDesc.RefreshRate.Denominator != 0 ?
; 3344 :         static_cast <float> (pDesc->BufferDesc.RefreshRate.Numerator) /
; 3345 :         static_cast <float> (pDesc->BufferDesc.RefreshRate.Denominator) :
; 3346 :           std::numeric_limits <float>::quiet_NaN (),
; 3347 :       pDesc->BufferDesc.Scaling == DXGI_MODE_SCALING_UNSPECIFIED ?
; 3348 :         L"Unspecified" :
; 3349 :         pDesc->BufferDesc.Scaling == DXGI_MODE_SCALING_CENTERED ?
; 3350 :           L"Centered" :
; 3351 :           L"Stretched",
; 3352 :       pDesc->BufferDesc.ScanlineOrdering == DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED ?
; 3353 :         L"Unspecified" :
; 3354 :         pDesc->BufferDesc.ScanlineOrdering == DXGI_MODE_SCANLINE_ORDER_PROGRESSIVE ?
; 3355 :           L"Progressive" :
; 3356 :           pDesc->BufferDesc.ScanlineOrdering == DXGI_MODE_SCANLINE_ORDER_UPPER_FIELD_FIRST ?
; 3357 :             L"Interlaced Even" :
; 3358 :             L"Interlaced Odd",
; 3359 :       pDesc->Windowed ? L"Windowed" : L"Fullscreen",
; 3360 :       pDesc->BufferCount,
; 3361 :       pDesc->Flags,
; 3362 :       pDesc->SwapEffect         == 0 ?
; 3363 :         L"Discard" :
; 3364 :         pDesc->SwapEffect       == 1 ?
; 3365 :           L"Sequential" :
; 3366 :           pDesc->SwapEffect     == 2 ?
; 3367 :             L"<Unknown>" :
; 3368 :             pDesc->SwapEffect   == 3 ?
; 3369 :               L"Flip Sequential" :
; 3370 :               pDesc->SwapEffect == 4 ?
; 3371 :                 L"Flip Discard" :
; 3372 :                 L"<Unknown>" );
; 3373 : 
; 3374 :     // Set things up to make the swap chain Alt+Enter friendly
; 3375 :     if (bAlwaysAllowFullscreen && pDesc->Windowed)

	cmp	BYTE PTR ?bAlwaysAllowFullscreen@@3_NA, 0 ; bAlwaysAllowFullscreen
	je	SHORT $LN88@DXGIFactor

; 3376 :     {
; 3377 :       pDesc->Flags                             |= DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

	or	esi, 2

; 3378 :       pDesc->Windowed                           = true;
; 3379 :       pDesc->BufferDesc.RefreshRate.Denominator = 0;

	xor	eax, eax
	mov	DWORD PTR _stub_desc$12$[ebp], eax

; 3380 :       pDesc->BufferDesc.RefreshRate.Numerator   = 0;

	mov	DWORD PTR _stub_desc$13$[ebp], eax
$LN88@DXGIFactor:

; 3381 :     }
; 3382 : 
; 3383 :     if (pDesc->Windowed && config.window.borderless && (! config.window.fullscreen))

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+728, 0
	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+760
	mov	edx, DWORD PTR ?config@@3Usk_config_t@@A+756
	je	SHORT $LN90@DXGIFactor
	cmp	BYTE PTR ?config@@3Usk_config_t@@A+754, 0
	jne	SHORT $LN90@DXGIFactor
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 425  :         bool isZero (void) { return x == 0 && y == 0; };

	test	edx, edx
	jne	SHORT $LN151@DXGIFactor
	test	eax, eax
	je	SHORT $LN92@DXGIFactor
$LN151@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3387 :         pDesc->BufferDesc.Width  = config.window.res.override.x;

	mov	ecx, edx

; 3388 :         pDesc->BufferDesc.Height = config.window.res.override.y;

	mov	edi, eax
	mov	DWORD PTR _stub_desc$10$[ebp], ecx
$LN90@DXGIFactor:
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 425  :         bool isZero (void) { return x == 0 && y == 0; };

	test	edx, edx
	jne	SHORT $LN155@DXGIFactor
	test	eax, eax
	je	SHORT $LN92@DXGIFactor
$LN155@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3403 :       pDesc->BufferDesc.Width  = config.window.res.override.x;

	mov	ecx, edx

; 3404 :       pDesc->BufferDesc.Height = config.window.res.override.y;

	mov	edi, eax
	mov	DWORD PTR _stub_desc$10$[ebp], ecx
$LN92@DXGIFactor:

; 3405 :     }
; 3406 : 
; 3407 : 
; 3408 :     if (config.render.dxgi.safe_fullscreen)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+488, 0
	je	SHORT $LN93@DXGIFactor

; 3409 :       pDesc->Flags |= DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

	or	esi, 2
$LN93@DXGIFactor:

; 3410 : 
; 3411 :     if (request_mode_change == mode_change_request_e::Fullscreen)

	cmp	DWORD PTR ?request_mode_change@@3W4mode_change_request_e@@A, 1 ; request_mode_change
	jne	SHORT $LN232@DXGIFactor

; 3412 :     {
; 3413 :       dll_log.Log ( L"[   DXGI   ]  >> User-Requested Mode Change: Fullscreen" );

	push	OFFSET ??_C@_1HA@INGGDHHB@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAU?$AAs?$AAe?$AAr?$AA?9?$AAR?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AAe?$AAd?$AA?5@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8

; 3414 :       pDesc->Windowed = FALSE;

	xor	eax, eax

; 3415 :       pDesc->Flags   |= DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

	or	esi, 2
	jmp	SHORT $LN94@DXGIFactor
$LN232@DXGIFactor:
	mov	eax, 1
$LN94@DXGIFactor:

; 3416 :     }
; 3417 : 
; 3418 :     if (config.display.force_fullscreen && pDesc->Windowed)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+500, 0
	je	SHORT $LN95@DXGIFactor
	test	eax, eax
	je	SHORT $LN95@DXGIFactor

; 3419 :     {
; 3420 :       dll_log.Log ( L"[   DXGI   ]  >> Display Override "

	push	OFFSET ??_C@_1JG@HCAIICBG@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAD?$AAi?$AAs?$AAp?$AAl?$AAa?$AAy?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8

; 3421 :                     L"(Requested: Windowed, Using: Fullscreen)" );
; 3422 :       pDesc->Flags   |= DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

	or	esi, 2

; 3423 :       pDesc->Windowed = FALSE;

	jmp	SHORT $LN97@DXGIFactor
$LN95@DXGIFactor:

; 3424 :     }
; 3425 : 
; 3426 :     else if (config.display.force_windowed)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+501, 0
	je	SHORT $LN97@DXGIFactor

; 3427 :     {
; 3428 :       dll_log.Log ( L"[   DXGI   ]  >> Display Override "

	push	OFFSET ??_C@_1JG@LPALCGFK@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAD?$AAi?$AAs?$AAp?$AAl?$AAa?$AAy?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8
$LN97@DXGIFactor:

; 3429 :                     L"(Requested: Fullscreen, Using: Windowed)" );
; 3430 :       pDesc->Windowed = TRUE;
; 3431 :     }
; 3432 : 
; 3433 : #ifdef _WIN64
; 3434 :     if (! bFlipMode)
; 3435 :       bFlipMode =
; 3436 :         ( dxgi_caps.present.flip_sequential && (
; 3437 :           ( ! lstrcmpW (SK_GetHostApp (), L"Fallout4.exe")) ||
; 3438 :             SK_DS3_UseFlipMode ()        ) );
; 3439 : 
; 3440 :     if (! lstrcmpW (SK_GetHostApp (), L"Fallout4.exe"))
; 3441 :     {
; 3442 :       if (bFlipMode)
; 3443 :           bFlipMode = (! SK_FO4_IsFullscreen ()) && SK_FO4_UseFlipMode ();
; 3444 :     }
; 3445 : 
; 3446 :     else
; 3447 : #endif
; 3448 :     {
; 3449 :       // If forcing flip-model, then force multisampling off
; 3450 :       if (config.render.framerate.flip_discard)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+416, 0
	je	SHORT $LN230@DXGIFactor

; 3451 :       {
; 3452 :         bFlipMode = dxgi_caps.present.flip_sequential;

	mov	al, BYTE PTR ?dxgi_caps@@3Udxgi_caps_t@@A+2
	mov	BYTE PTR ?bFlipMode@@3_NA, al		; bFlipMode

; 3453 :         pDesc->SampleDesc.Count = 1; pDesc->SampleDesc.Quality = 0;
; 3454 : 
; 3455 :         // Format overrides must be performed in certain cases (sRGB / 10:10:10:2)
; 3456 :         switch (pDesc->BufferDesc.Format)

	mov	eax, DWORD PTR _stub_desc$8$[ebp]
	add	eax, -23				; ffffffe9H
	mov	DWORD PTR _stub_desc$6$[ebp], 1
	mov	DWORD PTR _stub_desc$7$[ebp], 0
	cmp	eax, 68					; 00000044H
	ja	SHORT $LN230@DXGIFactor
	movzx	eax, BYTE PTR $LN228@DXGIFactor[eax]
	jmp	DWORD PTR $LN237@DXGIFactor[eax*4]
$LN99@DXGIFactor:

; 3457 :         {
; 3458 :           case DXGI_FORMAT_B8G8R8A8_UNORM_SRGB:
; 3459 :             pDesc->BufferDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;

	mov	DWORD PTR _stub_desc$8$[ebp], 87	; 00000057H

; 3460 :             dll_log.Log ( L"[ DXGI 1.2 ]  >> sRGB (B8G8R8A8) Override Required to Enable Flip Model" );

	push	OFFSET ??_C@_1JA@NDGFBELE@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA2?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAs?$AAR?$AAG?$AAB?$AA?5?$AA?$CI?$AAB?$AA8?$AAG?$AA8?$AAR?$AA8?$AAA?$AA8?$AA?$CJ@

; 3461 :             break;

	jmp	SHORT $LN234@DXGIFactor
$LN100@DXGIFactor:

; 3462 :           case DXGI_FORMAT_R8G8B8A8_UNORM_SRGB:
; 3463 :             pDesc->BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
; 3464 :             dll_log.Log ( L"[ DXGI 1.2 ]  >> sRGB (R8G8B8A8) Override Required to Enable Flip Model" );

	push	OFFSET ??_C@_1JA@CCHCBLHJ@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA2?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAs?$AAR?$AAG?$AAB?$AA?5?$AA?$CI?$AAR?$AA8?$AAG?$AA8?$AAB?$AA8?$AAA?$AA8?$AA?$CJ@

; 3465 :             break;

	jmp	SHORT $LN235@DXGIFactor
$LN101@DXGIFactor:

; 3469 :             dll_log.Log ( L"[ DXGI 1.2 ]  >> RGBA 10:10:10:2 Override (to 8:8:8:8) Required to Enable Flip Model" );

	push	OFFSET ??_C@_1KK@LPPCBMFA@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA2?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAR?$AAG?$AAB?$AAA?$AA?5?$AA1?$AA0?$AA?3?$AA1?$AA0?$AA?3?$AA1?$AA0?$AA?3?$AA2@
$LN235@DXGIFactor:

; 3466 :           case DXGI_FORMAT_R10G10B10A2_UNORM:
; 3467 :           case DXGI_FORMAT_R10G10B10A2_TYPELESS:
; 3468 :             pDesc->BufferDesc.Format =  DXGI_FORMAT_R8G8B8A8_UNORM;

	mov	DWORD PTR _stub_desc$8$[ebp], 28	; 0000001cH
$LN234@DXGIFactor:

; 3469 :             dll_log.Log ( L"[ DXGI 1.2 ]  >> RGBA 10:10:10:2 Override (to 8:8:8:8) Required to Enable Flip Model" );

	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8
$LN230@DXGIFactor:

; 3470 :             break;
; 3471 :         }
; 3472 :       }
; 3473 :     }
; 3474 : 
; 3475 :     if (       config.render.framerate.buffer_count != -1                  &&
; 3476 :          (UINT)config.render.framerate.buffer_count !=  pDesc->BufferCount &&

	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+408
	cmp	ecx, -1
	je	SHORT $LN102@DXGIFactor
	mov	eax, DWORD PTR _stub_desc$2$[ebp]
	cmp	ecx, eax
	je	SHORT $LN102@DXGIFactor
	test	eax, eax
	je	SHORT $LN102@DXGIFactor

; 3477 :          pDesc->BufferCount                         !=  0 )
; 3478 :     {
; 3479 :       pDesc->BufferCount = config.render.framerate.buffer_count;

	mov	eax, ecx

; 3480 :       dll_log.Log (L"[   DXGI   ]  >> Buffer Count Override: %lu buffers", pDesc->BufferCount);

	push	eax
	push	OFFSET ??_C@_1GI@GAEBCHMN@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AAO?$AAv@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	mov	DWORD PTR _stub_desc$2$[ebp], eax
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+408
	add	esp, 12					; 0000000cH
$LN102@DXGIFactor:

; 3481 :     }
; 3482 : 
; 3483 :     if ( config.render.framerate.flip_discard && dxgi_caps.swapchain.allow_tearing )

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+416, 0
	je	SHORT $LN103@DXGIFactor
	cmp	DWORD PTR ?dxgi_caps@@3Udxgi_caps_t@@A+8, 0
	je	SHORT $LN103@DXGIFactor

; 3484 :     {
; 3485 :       pDesc->Flags |= DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING;
; 3486 :       dll_log.Log ( L"[ DXGI 1.5 ]  >> Tearing Option:  Enable" );

	push	OFFSET ??_C@_1FC@PILPBEPG@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAT?$AAe?$AAa?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAO?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?3@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	or	esi, 2048				; 00000800H
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+408
	add	esp, 8
$LN103@DXGIFactor:

; 3487 :       pDesc->Windowed = TRUE;
; 3488 :     }
; 3489 : 
; 3490 :     if ( config.render.dxgi.scaling_mode != -1 &&

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+472
	cmp	eax, -1
	je	SHORT $LN104@DXGIFactor
	cmp	DWORD PTR _stub_desc$6[ebp+24], eax
	je	SHORT $LN104@DXGIFactor

; 3491 :           pDesc->BufferDesc.Scaling      !=
; 3492 :             (DXGI_MODE_SCALING)config.render.dxgi.scaling_mode )
; 3493 :     {
; 3494 :       dll_log.Log ( L"[   DXGI   ]  >> Scaling Override "

	push	eax
	call	?SK_DXGI_DescribeScalingMode@@YAPB_WW4DXGI_MODE_SCALING@@@Z ; SK_DXGI_DescribeScalingMode
	add	esp, 4
	push	eax
	push	DWORD PTR _stub_desc$6[ebp+24]
	call	?SK_DXGI_DescribeScalingMode@@YAPB_WW4DXGI_MODE_SCALING@@@Z ; SK_DXGI_DescribeScalingMode
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_1HK@PGANLAKP@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAS?$AAc?$AAa?$AAl?$AAi?$AAn?$AAg?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+408
	add	esp, 16					; 00000010H
$LN104@DXGIFactor:

; 3495 :                     L"(Requested: %s, Using: %s)",
; 3496 :                       SK_DXGI_DescribeScalingMode (
; 3497 :                         pDesc->BufferDesc.Scaling
; 3498 :                       ),
; 3499 :                         SK_DXGI_DescribeScalingMode (
; 3500 :                           (DXGI_MODE_SCALING)config.render.dxgi.scaling_mode
; 3501 :                         )
; 3502 :                   );
; 3503 : 
; 3504 :       pDesc->BufferDesc.Scaling =
; 3505 :         (DXGI_MODE_SCALING)config.render.dxgi.scaling_mode;
; 3506 :     }
; 3507 : 
; 3508 :     if ( config.render.dxgi.scanline_order != -1 &&

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+476
	cmp	eax, -1
	je	SHORT $LN105@DXGIFactor
	cmp	DWORD PTR _stub_desc$6[ebp+20], eax
	je	SHORT $LN105@DXGIFactor

; 3509 :           pDesc->BufferDesc.ScanlineOrdering      !=
; 3510 :             (DXGI_MODE_SCANLINE_ORDER)config.render.dxgi.scanline_order )
; 3511 :     {
; 3512 :       dll_log.Log ( L"[   DXGI   ]  >> Scanline Override "

	push	eax
	call	?SK_DXGI_DescribeScanlineOrder@@YAPB_WW4DXGI_MODE_SCANLINE_ORDER@@@Z ; SK_DXGI_DescribeScanlineOrder
	add	esp, 4
	push	eax
	push	DWORD PTR _stub_desc$6[ebp+20]
	call	?SK_DXGI_DescribeScanlineOrder@@YAPB_WW4DXGI_MODE_SCANLINE_ORDER@@@Z ; SK_DXGI_DescribeScanlineOrder
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_1HM@EKHBGJHP@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAS?$AAc?$AAa?$AAn?$AAl?$AAi?$AAn?$AAe?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+408
	add	esp, 16					; 00000010H
$LN105@DXGIFactor:

; 3513 :                     L"(Requested: %s, Using: %s)",
; 3514 :                       SK_DXGI_DescribeScanlineOrder (
; 3515 :                         pDesc->BufferDesc.ScanlineOrdering
; 3516 :                       ),
; 3517 :                         SK_DXGI_DescribeScanlineOrder (
; 3518 :                           (DXGI_MODE_SCANLINE_ORDER)config.render.dxgi.scanline_order
; 3519 :                         )
; 3520 :                   );
; 3521 : 
; 3522 :       pDesc->BufferDesc.ScanlineOrdering =
; 3523 :         (DXGI_MODE_SCANLINE_ORDER)config.render.dxgi.scanline_order;
; 3524 :     }
; 3525 : 
; 3526 :     if ( config.render.framerate.refresh_rate != -1 &&

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+424
	cmp	eax, -1
	je	SHORT $LN106@DXGIFactor
	mov	edx, DWORD PTR _stub_desc$13$[ebp]
	cmp	edx, eax
	je	SHORT $LN106@DXGIFactor

; 3527 :          pDesc->BufferDesc.RefreshRate.Numerator != (UINT)config.render.framerate.refresh_rate )
; 3528 :     {
; 3529 :       dll_log.Log ( L"[   DXGI   ]  >> Refresh Override "

	mov	ecx, DWORD PTR _stub_desc$12$[ebp]
	test	ecx, ecx
	je	SHORT $LN140@DXGIFactor
	movd	xmm0, edx
	cvtdq2pd xmm0, xmm0
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	cvtpd2ps xmm1, xmm0
	movd	xmm0, ecx
	cvtdq2pd xmm0, xmm0
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	cvtpd2ps xmm0, xmm0
	divss	xmm1, xmm0
	jmp	SHORT $LN158@DXGIFactor
$LN140@DXGIFactor:
	movss	xmm1, DWORD PTR __real@7fc00000
$LN158@DXGIFactor:
	push	eax
	cvtps2pd xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_1HM@GOOAFJFG@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAR?$AAe?$AAf?$AAr?$AAe?$AAs?$AAh?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+408
	add	esp, 20					; 00000014H
$LN106@DXGIFactor:

; 3530 :                     L"(Requested: %f, Using: %li)",
; 3531 :                  pDesc->BufferDesc.RefreshRate.Denominator != 0 ?
; 3532 :          static_cast <float> (pDesc->BufferDesc.RefreshRate.Numerator) /
; 3533 :          static_cast <float> (pDesc->BufferDesc.RefreshRate.Denominator) :
; 3534 :                      std::numeric_limits <float>::quiet_NaN (),
; 3535 :                         config.render.framerate.refresh_rate
; 3536 :                   );
; 3537 : 
; 3538 :       pDesc->BufferDesc.RefreshRate.Numerator   = config.render.framerate.refresh_rate;
; 3539 :       pDesc->BufferDesc.RefreshRate.Denominator = 1;
; 3540 :     }
; 3541 : 
; 3542 :     bWait = bFlipMode && dxgi_caps.present.waitable;

	cmp	BYTE PTR ?bFlipMode@@3_NA, 0		; bFlipMode
	je	SHORT $LN144@DXGIFactor
	cmp	BYTE PTR ?dxgi_caps@@3Udxgi_caps_t@@A+4, 0
	je	SHORT $LN144@DXGIFactor

; 3543 : 
; 3544 :     // We cannot change the swapchain parameters if this is used...
; 3545 :     bWait = bWait && config.render.framerate.swapchain_wait > 0;

	cmp	DWORD PTR ?config@@3Usk_config_t@@A+420, 0
	jle	SHORT $LN144@DXGIFactor
	mov	dl, 1
	jmp	SHORT $LN236@DXGIFactor
$LN144@DXGIFactor:
	xor	dl, dl
$LN236@DXGIFactor:

; 3546 : 
; 3547 : #ifdef _WIN64
; 3548 :     if (! lstrcmpW (SK_GetHostApp (), L"DarkSoulsIII.exe"))
; 3549 :     {
; 3550 :       if (SK_DS3_IsBorderless ())
; 3551 :         pDesc->Flags &= ~DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
; 3552 :     }
; 3553 : #endif
; 3554 : 
; 3555 :     if (bFlipMode)

	cmp	BYTE PTR ?bFlipMode@@3_NA, 0		; bFlipMode
	mov	BYTE PTR ?bWait@@3_NA, dl		; bWait
	je	SHORT $LN107@DXGIFactor

; 3556 :     {
; 3557 :       if (bWait)

	test	dl, dl
	je	SHORT $LN109@DXGIFactor

; 3558 :         pDesc->Flags |= DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT;

	or	esi, 64					; 00000040H
$LN109@DXGIFactor:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 3743 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, 3
	cmp	ecx, eax
	cmovg	eax, ecx
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3564 :       if (config.render.framerate.flip_discard &&

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+416, 0
	mov	ecx, eax
	mov	DWORD PTR ?config@@3Usk_config_t@@A+408, ecx
	je	SHORT $LN110@DXGIFactor
	cmp	BYTE PTR ?dxgi_caps@@3Udxgi_caps_t@@A+3, 0
	je	SHORT $LN110@DXGIFactor

; 3565 :           dxgi_caps.present.flip_discard)
; 3566 :         pDesc->SwapEffect  = DXGI_SWAP_EFFECT_FLIP_DISCARD;

	mov	eax, 4
	mov	DWORD PTR _stub_desc$5$[ebp], eax

; 3567 :       else

	jmp	SHORT $LN112@DXGIFactor
$LN110@DXGIFactor:

; 3568 :         pDesc->SwapEffect  = DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL;

	mov	DWORD PTR _stub_desc$5$[ebp], 3
	jmp	SHORT $LN112@DXGIFactor
$LN107@DXGIFactor:

; 3569 :     }
; 3570 : 
; 3571 :     else if ( pDesc->SwapEffect != DXGI_SWAP_EFFECT_FLIP_DISCARD &&

	mov	eax, DWORD PTR _stub_desc$5$[ebp]
	cmp	eax, 4
	je	SHORT $LN112@DXGIFactor
	cmp	eax, 3
	je	SHORT $LN112@DXGIFactor

; 3572 :               pDesc->SwapEffect != DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL )
; 3573 :     {
; 3574 :       // Resort to triple-buffering if flip mode is not available
; 3575 :       if (config.render.framerate.buffer_count > 3)

	mov	eax, 3

; 3576 :         config.render.framerate.buffer_count = 3;
; 3577 : 
; 3578 :       pDesc->SwapEffect = DXGI_SWAP_EFFECT_DISCARD;

	mov	DWORD PTR _stub_desc$5$[ebp], 0
	cmp	ecx, eax
	cmovg	ecx, eax
	mov	DWORD PTR ?config@@3Usk_config_t@@A+408, ecx
$LN112@DXGIFactor:

; 3579 :     }
; 3580 : 
; 3581 :     if (config.render.framerate.buffer_count > 0)

	mov	eax, DWORD PTR _stub_desc$2$[ebp]
	test	ecx, ecx
	cmovg	eax, ecx

; 3582 :       pDesc->BufferCount = config.render.framerate.buffer_count;
; 3583 : 
; 3584 :     // We cannot switch modes on a waitable swapchain
; 3585 :     if (bFlipMode && bWait)

	cmp	BYTE PTR ?bFlipMode@@3_NA, 0		; bFlipMode
	mov	DWORD PTR _stub_desc$2$[ebp], eax
	je	SHORT $LN115@DXGIFactor
	test	dl, dl
	je	SHORT $LN115@DXGIFactor

; 3586 :     {
; 3587 :       pDesc->Flags |=  DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT;
; 3588 :       pDesc->Flags &= ~DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

	and	esi, -3					; fffffffdH
	or	esi, 64					; 00000040H
$LN115@DXGIFactor:

; 3592 :   dll_log.Log ( L"[ DXGI 1.2 ] >> Using %s Presentation Model  [Waitable: %s - %li ms]",

	xor	eax, eax
	mov	ecx, OFFSET ??_C@_15BICKNCBF@?$AAN?$AAo?$AA?$AA@
	test	dl, dl
	cmovne	eax, DWORD PTR ?config@@3Usk_config_t@@A+420
	push	eax
	mov	eax, OFFSET ??_C@_17PBAHFJOA@?$AAY?$AAe?$AAs?$AA?$AA@
	cmove	eax, ecx
	cmp	BYTE PTR ?bFlipMode@@3_NA, 0		; bFlipMode
	push	eax
	mov	ecx, OFFSET ??_C@_1BI@PKCOFIGO@?$AAT?$AAr?$AAa?$AAd?$AAi?$AAt?$AAi?$AAo?$AAn?$AAa?$AAl?$AA?$AA@
	mov	eax, OFFSET ??_C@_19EMFBKLJE@?$AAF?$AAl?$AAi?$AAp?$AA?$AA@
	cmove	eax, ecx
	push	eax
	push	OFFSET ??_C@_1IK@KCJJDMDA@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA2?$AA?5?$AA?$FN?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAU?$AAs?$AAi?$AAn?$AAg?$AA?5?$AA?$CF?$AAs?$AA?5?$AAP?$AAr?$AAe?$AAs?$AAe?$AAn?$AAt@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 251  :           bool isZero (void) { return x == 0 && y == 0; };

	mov	edx, DWORD PTR ?config@@3Usk_config_t@@A+460
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3592 :   dll_log.Log ( L"[ DXGI 1.2 ] >> Using %s Presentation Model  [Waitable: %s - %li ms]",

	add	esp, 20					; 00000014H
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 251  :           bool isZero (void) { return x == 0 && y == 0; };

	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+464
	test	edx, edx
	jne	SHORT $LN165@DXGIFactor
	test	ecx, ecx
	je	SHORT $LN231@DXGIFactor
$LN165@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3598 :   if ((! config.render.dxgi.res.max.isZero ()) && pDesc->BufferDesc.Width > config.render.dxgi.res.max.x)

	mov	eax, DWORD PTR _stub_desc$10$[ebp]
	cmp	eax, edx
	cmova	eax, edx
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 251  :           bool isZero (void) { return x == 0 && y == 0; };

	test	edx, edx
	jne	SHORT $LN169@DXGIFactor
	test	ecx, ecx
	je	SHORT $LN117@DXGIFactor
$LN169@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3600 :   if ((! config.render.dxgi.res.max.isZero ()) && pDesc->BufferDesc.Height > config.render.dxgi.res.max.y)

	cmp	edi, ecx
	cmova	edi, ecx
	jmp	SHORT $LN117@DXGIFactor
$LN231@DXGIFactor:
	mov	eax, DWORD PTR _stub_desc$10$[ebp]
$LN117@DXGIFactor:
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 246  :           bool isZero (void) { return x == 0 && y == 0; };

	mov	edx, DWORD PTR ?config@@3Usk_config_t@@A+452
	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+456
	test	edx, edx
	jne	SHORT $LN173@DXGIFactor
	test	ecx, ecx
	jne	SHORT $LN177@DXGIFactor
	jmp	SHORT $LN225@DXGIFactor
$LN173@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3603 :   if ((! config.render.dxgi.res.min.isZero ()) && pDesc->BufferDesc.Width < config.render.dxgi.res.min.x)

	cmp	eax, edx
	cmovb	eax, edx
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 246  :           bool isZero (void) { return x == 0 && y == 0; };

	test	edx, edx
	jne	SHORT $LN177@DXGIFactor
	test	ecx, ecx
	je	SHORT $LN225@DXGIFactor
$LN177@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3605 :   if ((! config.render.dxgi.res.min.isZero ()) && pDesc->BufferDesc.Height < config.render.dxgi.res.min.y)

	cmp	edi, ecx
	cmovb	edi, ecx
$LN225@DXGIFactor:

; 3612 :     pDesc1->BufferUsage                        = pDesc->BufferUsage;

	mov	ecx, DWORD PTR _stub_desc$3$[ebp]
	mov	DWORD PTR _new_desc1$[ebp+24], ecx

; 3614 :     pDesc1->SwapEffect                         = pDesc->SwapEffect;

	mov	ecx, DWORD PTR _stub_desc$5$[ebp]
	mov	DWORD PTR _new_desc1$[ebp+36], ecx

; 3615 :     pDesc1->SampleDesc.Count                   = pDesc->SampleDesc.Count;

	mov	ecx, DWORD PTR _stub_desc$6$[ebp]

; 3619 :     pDesc1->Width                              = pDesc->BufferDesc.Width;

	mov	DWORD PTR _new_desc1$[ebp], eax

; 3833 :       *pDesc :
; 3834 :         DXGI_SWAP_CHAIN_DESC1 { };
; 3835 : 
; 3836 :   HWND hWnd = nullptr;
; 3837 :   SK_DXGI_CreateSwapChain_PreInit (nullptr, &new_desc1, hWnd, nullptr);
; 3838 : 
; 3839 : 
; 3840 :   if (pDesc != nullptr) pDesc = &new_desc1;

	mov	eax, DWORD PTR _pDesc$[ebp]
	test	eax, eax

; 3615 :     pDesc1->SampleDesc.Count                   = pDesc->SampleDesc.Count;

	mov	DWORD PTR _new_desc1$[ebp+16], ecx

; 3616 :     pDesc1->SampleDesc.Quality                 = pDesc->SampleDesc.Quality;

	mov	ecx, DWORD PTR _stub_desc$7$[ebp]
	mov	edx, DWORD PTR _stub_desc$2$[ebp]
	mov	DWORD PTR _new_desc1$[ebp+20], ecx

; 3617 :     pDesc1->Format                             = pDesc->BufferDesc.Format;

	mov	ecx, DWORD PTR _stub_desc$8$[ebp]
	mov	DWORD PTR _new_desc1$[ebp+8], ecx

; 3833 :       *pDesc :
; 3834 :         DXGI_SWAP_CHAIN_DESC1 { };
; 3835 : 
; 3836 :   HWND hWnd = nullptr;
; 3837 :   SK_DXGI_CreateSwapChain_PreInit (nullptr, &new_desc1, hWnd, nullptr);
; 3838 : 
; 3839 : 
; 3840 :   if (pDesc != nullptr) pDesc = &new_desc1;

	lea	ecx, DWORD PTR _new_desc1$[ebp]
	cmove	ecx, eax

; 3611 :     pDesc1->BufferCount                        = pDesc->BufferCount;

	mov	DWORD PTR _new_desc1$[ebp+28], edx

; 3864 :       };

	lea	eax, DWORD PTR _ret$[ebp]

; 3833 :       *pDesc :
; 3834 :         DXGI_SWAP_CHAIN_DESC1 { };
; 3835 : 
; 3836 :   HWND hWnd = nullptr;
; 3837 :   SK_DXGI_CreateSwapChain_PreInit (nullptr, &new_desc1, hWnd, nullptr);
; 3838 : 
; 3839 : 
; 3840 :   if (pDesc != nullptr) pDesc = &new_desc1;

	mov	DWORD PTR _pDesc$[ebp], ecx

; 3864 :       };

	mov	DWORD PTR _CreateSwapChain_Lambchop$[ebp], eax

; 3865 : 
; 3866 : 
; 3867 :   if (! CreateSwapChain_Lambchop ())

	lea	ecx, DWORD PTR _CreateSwapChain_Lambchop$[ebp]

; 3864 :       };

	lea	eax, DWORD PTR _This$[ebp]

; 3613 :     pDesc1->Flags                              = pDesc->Flags;

	mov	DWORD PTR _new_desc1$[ebp+44], esi

; 3864 :       };

	mov	DWORD PTR _CreateSwapChain_Lambchop$[ebp+4], eax
	lea	eax, DWORD PTR _pDevice$[ebp]
	mov	DWORD PTR _CreateSwapChain_Lambchop$[ebp+8], eax
	lea	eax, DWORD PTR _pWindow$[ebp]
	mov	DWORD PTR _CreateSwapChain_Lambchop$[ebp+12], eax
	lea	eax, DWORD PTR _pDesc$[ebp]
	mov	DWORD PTR _CreateSwapChain_Lambchop$[ebp+16], eax
	lea	eax, DWORD PTR _pRestrictToOutput$[ebp]
	mov	DWORD PTR _CreateSwapChain_Lambchop$[ebp+20], eax
	lea	eax, DWORD PTR _ppSwapChain$[ebp]
	mov	DWORD PTR _CreateSwapChain_Lambchop$[ebp+24], eax
	lea	eax, DWORD PTR _new_desc1$[ebp]

; 3618 :     pDesc1->Height                             = pDesc->BufferDesc.Height;

	mov	DWORD PTR _new_desc1$[ebp+4], edi

; 3864 :       };

	mov	DWORD PTR _CreateSwapChain_Lambchop$[ebp+28], eax

; 3865 : 
; 3866 : 
; 3867 :   if (! CreateSwapChain_Lambchop ())

	call	??R<lambda_7769376daad0f42c2f9dc7182375e5d8>@@QBEHXZ ; <lambda_7769376daad0f42c2f9dc7182375e5d8>::operator()
	pop	edi
	test	eax, eax
	jne	SHORT $LN4@DXGIFactor

; 3868 :   {
; 3869 :     // Fallback-on-Fail
; 3870 :     pDesc = orig_desc;

	mov	eax, DWORD PTR _orig_desc$1$[ebp]

; 3871 : 
; 3872 :     CreateSwapChain_Lambchop ();

	lea	ecx, DWORD PTR _CreateSwapChain_Lambchop$[ebp]
	mov	DWORD PTR _pDesc$[ebp], eax
	call	??R<lambda_7769376daad0f42c2f9dc7182375e5d8>@@QBEHXZ ; <lambda_7769376daad0f42c2f9dc7182375e5d8>::operator()
$LN4@DXGIFactor:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	ecx, DWORD PTR _iname$[ebp+20]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3876 :   return ret;

	mov	esi, DWORD PTR _ret$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	ecx, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN229@DXGIFactor
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	ecx
	push	DWORD PTR _iname$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN229@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3877 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$LN237@DXGIFactor:
	DD	$LN101@DXGIFactor
	DD	$LN100@DXGIFactor
	DD	$LN99@DXGIFactor
	DD	$LN230@DXGIFactor
$LN228@DXGIFactor:
	DB	0
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?DXGIFactory2_CreateSwapChainForCoreWindow_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@1PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z$0:
	lea	ecx, DWORD PTR _iname$[ebp]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__ehhandler$?DXGIFactory2_CreateSwapChainForCoreWindow_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@1PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?DXGIFactory2_CreateSwapChainForCoreWindow_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@1PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DXGIFactory2_CreateSwapChainForCoreWindow_Override@@YGJPAUIDXGIFactory2@@PAUIUnknown@@1PBUDXGI_SWAP_CHAIN_DESC1@@PAUIDXGIOutput@@PAPAUIDXGISwapChain1@@@Z ENDP ; DXGIFactory2_CreateSwapChainForCoreWindow_Override
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
;	COMDAT ??0<lambda_49fe4316955e3999d8d7fe725292d871>@@QAE@AAJAAPAUIDXGIFactory@@AAPAUIUnknown@@AAPBUDXGI_SWAP_CHAIN_DESC@@AAPAPAUIDXGISwapChain@@AAU3@@Z
_TEXT	SEGMENT
_<ret>$ = 8						; size = 4
_<This>$ = 12						; size = 4
_<pDevice>$ = 16					; size = 4
_<pDesc>$ = 20						; size = 4
_<ppSwapChain>$ = 24					; size = 4
_<new_desc>$ = 28					; size = 4
??0<lambda_49fe4316955e3999d8d7fe725292d871>@@QAE@AAJAAPAUIDXGIFactory@@AAPAUIUnknown@@AAPBUDXGI_SWAP_CHAIN_DESC@@AAPAPAUIDXGISwapChain@@AAU3@@Z PROC ; <lambda_49fe4316955e3999d8d7fe725292d871>::<lambda_49fe4316955e3999d8d7fe725292d871>, COMDAT
; _this$ = ecx

; 3796 :       };

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _<ret>$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _<This>$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR _<pDevice>$[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _<pDesc>$[ebp]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR _<ppSwapChain>$[ebp]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR _<new_desc>$[ebp]
	mov	DWORD PTR [ecx+20], eax
	mov	eax, ecx
	pop	ebp
	ret	24					; 00000018H
??0<lambda_49fe4316955e3999d8d7fe725292d871>@@QAE@AAJAAPAUIDXGIFactory@@AAPAUIUnknown@@AAPBUDXGI_SWAP_CHAIN_DESC@@AAPAPAUIDXGISwapChain@@AAU3@@Z ENDP ; <lambda_49fe4316955e3999d8d7fe725292d871>::<lambda_49fe4316955e3999d8d7fe725292d871>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
;	COMDAT ??R<lambda_49fe4316955e3999d8d7fe725292d871>@@QBEHXZ
_TEXT	SEGMENT
_client$2 = -48						; size = 16
_pDesc$1$ = -32						; size = 4
_pDevice$1$ = -28					; size = 4
_pDevice1$3 = -24					; size = 4
_pSwapChain2$4 = -20					; size = 4
_pDev$5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??R<lambda_49fe4316955e3999d8d7fe725292d871>@@QBEHXZ PROC ; <lambda_49fe4316955e3999d8d7fe725292d871>::operator(), COMDAT
; _this$ = ecx

; 3783 :       {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??R<lambda_49fe4316955e3999d8d7fe725292d871>@@QBEHXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	esi
	push	edi
	mov	edi, ecx

; 3784 :         DXGI_CALL (ret, CreateSwapChain_Original (This, pDevice, pDesc, ppSwapChain));

	mov	eax, DWORD PTR [edi+16]
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi+12]
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi+8]
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR [edi+4]
	push	DWORD PTR [eax]
	call	DWORD PTR ?CreateSwapChain_Original@@3P6GJPAUIDXGIFactory@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@ZA ; CreateSwapChain_Original
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edi]
	push	DWORD PTR [eax]
	call	?SK_DescribeHRESULT@@YGPB_WJ@Z		; SK_DescribeHRESULT
	push	eax
	push	OFFSET ??_C@_1ME@IOFODDLL@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?$FL?$AA?$EA?$AA?$FN?$AA?5?$AA?5?$AAR?$AAe?$AAt?$AAu?$AAr?$AAn?$AA?3?$AA?5?$AA?$CF?$AAs?$AA?5?$AA?5?$AA?9?$AA?5@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 3785 :       
; 3786 :         if ( SUCCEEDED (ret)         &&
; 3787 :              ppSwapChain  != nullptr &&

	mov	eax, DWORD PTR [edi]
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR [eax], 0
	jl	$LN2@operator
	mov	eax, DWORD PTR [edi+16]
	mov	esi, DWORD PTR [eax]
	test	esi, esi
	je	$LN2@operator
	cmp	DWORD PTR [esi], 0
	je	$LN2@operator

; 3647 :   SK_RunOnce (SK_CEGUI_QueueResetD3D11 ());

	cmp	BYTE PTR ?first@?2??SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z@4_NA, 0 ; `SK_DXGI_CreateSwapChain_PostInit'::`3'::first

; 3788 :            (*ppSwapChain) != nullptr )
; 3789 :         {
; 3790 :           SK_DXGI_CreateSwapChain_PostInit (pDevice, &new_desc, ppSwapChain);

	mov	eax, DWORD PTR [edi+8]
	push	ebx
	mov	ebx, DWORD PTR [edi+20]
	mov	DWORD PTR _pDesc$1$[ebp], ebx
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _pDevice$1$[ebp], eax

; 3647 :   SK_RunOnce (SK_CEGUI_QueueResetD3D11 ());

	je	SHORT $LN5@operator
	call	?SK_CEGUI_QueueResetD3D11@@YAXXZ	; SK_CEGUI_QueueResetD3D11
	mov	BYTE PTR ?first@?2??SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z@4_NA, 0 ; `SK_DXGI_CreateSwapChain_PostInit'::`3'::first
$LN5@operator:

; 3648 : 
; 3649 :   if (pDesc->BufferDesc.Width != 0)

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN6@operator

; 3650 :   {
; 3651 :     SK_SetWindowResX (pDesc->BufferDesc.Width);

	push	eax
	call	?SK_SetWindowResX@@YAXJ@Z		; SK_SetWindowResX

; 3652 :     SK_SetWindowResY (pDesc->BufferDesc.Height);

	push	DWORD PTR [ebx+4]

; 3653 :   }
; 3654 : 
; 3655 :   else

	jmp	SHORT $LN78@operator
$LN6@operator:

; 3656 :   {
; 3657 :     RECT client;
; 3658 : 
; 3659 :     GetClientRect    (game_window.hWnd, &client);

	lea	eax, DWORD PTR _client$2[ebp]
	push	eax
	push	DWORD PTR ?game_window@@3Usk_window_s@@A+4
	call	DWORD PTR __imp__GetClientRect@8

; 3660 :     SK_SetWindowResX (client.right  - client.left);

	mov	eax, DWORD PTR _client$2[ebp+8]
	sub	eax, DWORD PTR _client$2[ebp]
	push	eax
	call	?SK_SetWindowResX@@YAXJ@Z		; SK_SetWindowResX

; 3661 :     SK_SetWindowResY (client.bottom - client.top);

	mov	eax, DWORD PTR _client$2[ebp+12]
	sub	eax, DWORD PTR _client$2[ebp+4]
	push	eax
$LN78@operator:
	call	?SK_SetWindowResY@@YAXJ@Z		; SK_SetWindowResY
	add	esp, 8

; 3662 :   }
; 3663 : 
; 3664 :   SK_RunOnce (SK_DXGI_HookSwapChain (*ppSwapChain));

	cmp	BYTE PTR ?first@?M@??SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z@4_NA, 0 ; `SK_DXGI_CreateSwapChain_PostInit'::`12'::first
	je	SHORT $LN8@operator
	push	DWORD PTR [esi]
	call	?SK_DXGI_HookSwapChain@@YAXPAUIDXGISwapChain@@@Z ; SK_DXGI_HookSwapChain
	add	esp, 4
	mov	BYTE PTR ?first@?M@??SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z@4_NA, 0 ; `SK_DXGI_CreateSwapChain_PostInit'::`12'::first
$LN8@operator:

; 3665 : 
; 3666 :   //if (bFlipMode || bWait)
; 3667 :     //DXGISwap_ResizeBuffers_Override (*ppSwapChain, config.render.framerate.buffer_count,
; 3668 :     //pDesc->BufferDesc.Width, pDesc->BufferDesc.Height, pDesc->BufferDesc.Format, pDesc->Flags);
; 3669 : 
; 3670 :   const uint32_t max_latency = config.render.framerate.pre_render_limit;

	mov	ebx, DWORD PTR ?config@@3Usk_config_t@@A+400
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pSwapChain2$4[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3674 :   if ( bFlipMode && bWait &&

	cmp	BYTE PTR ?bFlipMode@@3_NA, 0		; bFlipMode
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	je	SHORT $LN75@operator
	cmp	BYTE PTR ?bWait@@3_NA, 0		; bWait
	je	SHORT $LN75@operator
	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	lea	edx, DWORD PTR _pSwapChain2$4[ebp]
	push	edx
	push	OFFSET __GUID_a8be2ac4_199f_4946_b331_79599fb98de7
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3674 :   if ( bFlipMode && bWait &&

	test	eax, eax
	js	SHORT $LN75@operator

; 3675 :        SUCCEEDED ( (*ppSwapChain)->QueryInterface <IDXGISwapChain2> (&pSwapChain2) )
; 3676 :       )
; 3677 :   {
; 3678 :     if (max_latency < 16)

	cmp	ebx, 16					; 00000010H
	jae	SHORT $LN10@operator

; 3679 :     {
; 3680 :       dll_log.Log (L"[   DXGI   ] Setting Swapchain Frame Latency: %lu", max_latency);

	push	ebx
	push	OFFSET ??_C@_1GE@BOIALL@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAS?$AAw?$AAa?$AAp?$AAc?$AAh?$AAa?$AAi?$AAn?$AA?5?$AAF@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 3681 :       pSwapChain2->SetMaximumFrameLatency (max_latency);

	mov	eax, DWORD PTR _pSwapChain2$4[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	push	ebx
	push	eax
	call	DWORD PTR [ecx+124]
$LN10@operator:

; 3682 :     }
; 3683 : 
; 3684 :     HANDLE hWait =
; 3685 :       pSwapChain2->GetFrameLatencyWaitableObject ();

	mov	eax, DWORD PTR _pSwapChain2$4[ebp]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+132]

; 3686 : 
; 3687 :     WaitForSingleObjectEx ( hWait,

	push	1
	push	500					; 000001f4H
	push	eax
	call	DWORD PTR __imp__WaitForSingleObjectEx@12
$LN75@operator:

; 3688 :                               500,//config.render.framerate.swapchain_wait,
; 3689 :                                 TRUE );
; 3690 :   }
; 3691 : 
; 3692 :   {
; 3693 :     if (max_latency != -1)

	cmp	ebx, -1
	je	SHORT $LN76@operator
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pDevice1$3[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3697 :       if (SUCCEEDED ( (*ppSwapChain)->GetDevice (

	mov	esi, DWORD PTR [esi]
	lea	eax, DWORD PTR _pDevice1$3[ebp]
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edi, DWORD PTR [esi]
	call	??$IID_PPV_ARGS_Helper@UIDXGIDevice1@@@@YAPAPAXPAPAUIDXGIDevice1@@@Z ; IID_PPV_ARGS_Helper<IDXGIDevice1>
	add	esp, 4
	push	eax
	push	OFFSET __GUID_77db970f_6276_48ba_ba28_070143b4392c
	push	esi
	call	DWORD PTR [edi+28]
	test	eax, eax
	js	SHORT $LN12@operator

; 3698 :                          IID_PPV_ARGS (&pDevice1)
; 3699 :                       )
; 3700 :                     )
; 3701 :          )
; 3702 :       {
; 3703 :         dll_log.Log (L"[   DXGI   ] Setting Device Frame Latency: %lu", max_latency);

	push	ebx
	push	OFFSET ??_C@_1FO@CKMCMFKO@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AAF?$AAr?$AAa?$AAm@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 3704 :         pDevice1->SetMaximumFrameLatency (max_latency);

	mov	eax, DWORD PTR _pDevice1$3[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	push	ebx
	push	eax
	call	DWORD PTR [ecx+48]
$LN12@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	mov	eax, DWORD PTR _pDevice1$3[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3706 :     }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN76@operator

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN76@operator:

; 623  :         if (lp != NULL)

	mov	edx, DWORD PTR _pDevice$1$[ebp]

; 158  :         p = NULL;

	xor	ecx, ecx
	mov	DWORD PTR _pDev$5[ebp], ecx

; 623  :         if (lp != NULL)

	test	edx, edx
	je	SHORT $LN48@operator

; 624  :         {
; 625  :             if (FAILED(lp->QueryInterface(*piid, (void **)&this->p)))

	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR _pDev$5[ebp]
	push	ecx
	push	OFFSET __GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140
	push	edx
	call	DWORD PTR [eax]
	mov	ecx, DWORD PTR _pDev$5[ebp]
	xor	edx, edx
	test	eax, eax
	cmovs	ecx, edx
	mov	DWORD PTR _pDev$5[ebp], ecx
$LN48@operator:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3709 :   CComQIPtr <ID3D11Device> pDev (pDevice);

	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 214  :         return p == pT;

	test	ecx, ecx
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3711 :   if (pDev != nullptr)

	je	SHORT $LN13@operator

; 3712 :   {
; 3713 :     g_pD3D11Dev = pDev;
; 3714 : 
; 3715 :     SK_GetCurrentRenderBackend ().fullscreen_exclusive = (! pDesc->Windowed);

	mov	eax, DWORD PTR _pDesc$1$[ebp]
	mov	DWORD PTR ?g_pD3D11Dev@@3PAUID3D11Device@@A, ecx ; g_pD3D11Dev
	cmp	DWORD PTR [eax+48], 0
	sete	bl
	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend
	mov	BYTE PTR [eax+48], bl
	mov	ecx, DWORD PTR _pDev$5[ebp]
$LN13@operator:

; 3717 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	ecx, ecx
	je	SHORT $LN67@operator

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN67@operator:

; 176  :         if (p)

	mov	eax, DWORD PTR _pSwapChain2$4[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3717 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN73@operator

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN73@operator:
	pop	edi
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3792 :           return TRUE;

	mov	eax, 1
	pop	esi

; 3793 :         }
; 3794 : 
; 3795 :         return FALSE;
; 3796 :       };

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@operator:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	xor	eax, eax
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??R<lambda_49fe4316955e3999d8d7fe725292d871>@@QBEHXZ$0:
	lea	ecx, DWORD PTR _pSwapChain2$4[ebp]
	jmp	??1?$CComPtr@UIDXGISwapChain2@@@ATL@@QAE@XZ
__unwindfunclet$??R<lambda_49fe4316955e3999d8d7fe725292d871>@@QBEHXZ$1:
	lea	ecx, DWORD PTR _pDevice1$3[ebp]
	jmp	??1?$CComPtr@UIDXGIDevice1@@@ATL@@QAE@XZ
__unwindfunclet$??R<lambda_49fe4316955e3999d8d7fe725292d871>@@QBEHXZ$2:
	lea	ecx, DWORD PTR _pDev$5[ebp]
	jmp	??1?$CComQIPtr@UID3D11Device@@$1?_GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140@@3U__s_GUID@@B@ATL@@QAE@XZ
__ehhandler$??R<lambda_49fe4316955e3999d8d7fe725292d871>@@QBEHXZ:
	mov	eax, OFFSET __ehfuncinfo$??R<lambda_49fe4316955e3999d8d7fe725292d871>@@QBEHXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??R<lambda_49fe4316955e3999d8d7fe725292d871>@@QBEHXZ ENDP ; <lambda_49fe4316955e3999d8d7fe725292d871>::operator()
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
$T2 = -332						; size = 60
$T3 = -272						; size = 60
$T4 = -212						; size = 60
$T5 = -152						; size = 24
_iname$ = -128						; size = 24
_CreateSwapChain_Lambchop$ = -104			; size = 24
_ret$ = -80						; size = 4
tv1435 = -76						; size = 4
_new_desc$ = -72					; size = 60
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_This$ = 8						; size = 4
_pDevice$ = 12						; size = 4
_pDesc$ = 16						; size = 4
_ppSwapChain$ = 20					; size = 4
?DXGIFactory_CreateSwapChain_Override@@YGJPAUIDXGIFactory@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z PROC ; DXGIFactory_CreateSwapChain_Override

; 3759 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DXGIFactory_CreateSwapChain_Override@@YGJPAUIDXGIFactory@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 320				; 00000140H
	push	esi

; 3760 :   std::wstring iname = SK_GetDXGIFactoryInterface (This);

	push	DWORD PTR _This$[ebp]
	lea	eax, DWORD PTR _iname$[ebp]
	push	eax
	call	?SK_GetDXGIFactoryInterface@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUIUnknown@@@Z ; SK_GetDXGIFactoryInterface

; 3762 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"CreateSwapChain         ",

	push	8192					; 00002000H
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??_U@YAPAXI@Z				; operator new[]
	mov	esi, eax
	add	esp, 12					; 0000000cH
	test	esi, esi
	je	SHORT $LN6@DXGIFactor
	push	8192					; 00002000H
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN7@DXGIFactor
$LN6@DXGIFactor:
	xor	esi, esi
$LN7@DXGIFactor:
	push	edi
	lea	edi, DWORD PTR [esi+2048]
	test	esi, esi
	je	$LN2@DXGIFactor
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR _iname$[ebp+20], 8

; 1621 : 		return (_Large_string_engaged()

	lea	eax, DWORD PTR _iname$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3762 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"CreateSwapChain         ",

	push	OFFSET $SG356859
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	cmovae	eax, DWORD PTR _iname$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3762 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"CreateSwapChain         ",

	push	eax
	push	OFFSET $SG356860
	push	esi
	call	__swprintf
	push	DWORD PTR _ppSwapChain$[ebp]
	push	DWORD PTR _pDesc$[ebp]
	push	DWORD PTR _pDevice$[ebp]
	push	OFFSET $SG356861
	push	edi
	call	__swprintf
	push	edi
	push	esi
	lea	eax, DWORD PTR [edi+2048]
	push	OFFSET $SG356862
	push	eax
	call	__swprintf
	mov	eax, DWORD PTR __$ReturnAddr$[ebp]
	add	esp, 52					; 00000034H
	push	eax
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	?SK_SummarizeCaller@@YG?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAX@Z ; SK_SummarizeCaller
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN44@DXGIFactor
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN44@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3762 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"CreateSwapChain         ",

	push	eax
	lea	eax, DWORD PTR [edi+2048]
	push	eax
	push	OFFSET $SG356863
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T5[ebp+20]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3762 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"CreateSwapChain         ",

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN54@DXGIFactor
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T5[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN54@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3762 :   DXGI_LOG_CALL_I3 ( iname.c_str (), L"CreateSwapChain         ",

	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@DXGIFactor:

; 3763 :                        L"%ph, %ph, %ph",
; 3764 :                          pDevice, pDesc, ppSwapChain );
; 3765 : 
; 3766 :   auto                 orig_desc = pDesc;

	mov	esi, DWORD PTR _pDesc$[ebp]

; 3767 :   DXGI_SWAP_CHAIN_DESC new_desc  =
; 3768 :     pDesc != nullptr ?

	test	esi, esi
	je	SHORT $LN8@DXGIFactor
	movups	xmm0, XMMWORD PTR [esi]
	mov	eax, DWORD PTR [esi+56]
	mov	DWORD PTR $T4[ebp+56], eax
	lea	eax, DWORD PTR $T4[ebp]
	movups	XMMWORD PTR $T4[ebp], xmm0
	movups	xmm0, XMMWORD PTR [esi+16]
	movups	XMMWORD PTR $T4[ebp+16], xmm0
	movups	xmm0, XMMWORD PTR [esi+32]
	movups	XMMWORD PTR $T4[ebp+32], xmm0
	movq	xmm0, QWORD PTR [esi+48]
	movq	QWORD PTR $T4[ebp+48], xmm0
	jmp	SHORT $LN9@DXGIFactor
$LN8@DXGIFactor:
	push	60					; 0000003cH
	lea	eax, DWORD PTR $T3[ebp]
	push	0
	push	eax
	call	_memset
	movups	xmm0, XMMWORD PTR $T3[ebp]
	mov	eax, DWORD PTR $T3[ebp+56]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR $T2[ebp+56], eax
	lea	eax, DWORD PTR $T2[ebp]
	movups	XMMWORD PTR $T2[ebp], xmm0
	movups	xmm0, XMMWORD PTR $T3[ebp+16]
	movups	XMMWORD PTR $T2[ebp+16], xmm0
	movups	xmm0, XMMWORD PTR $T3[ebp+32]
	movups	XMMWORD PTR $T2[ebp+32], xmm0
	movq	xmm0, QWORD PTR $T3[ebp+48]
	movq	QWORD PTR $T2[ebp+48], xmm0
$LN9@DXGIFactor:
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR _new_desc$[ebp], xmm0
	movups	xmm0, XMMWORD PTR [eax+16]
	movups	XMMWORD PTR _new_desc$[ebp+16], xmm0
	movups	xmm0, XMMWORD PTR [eax+32]
	movups	XMMWORD PTR _new_desc$[ebp+32], xmm0
	movq	xmm0, QWORD PTR [eax+48]
	mov	eax, DWORD PTR [eax+56]
	movq	QWORD PTR _new_desc$[ebp+48], xmm0
	mov	DWORD PTR _new_desc$[ebp+56], eax

; 3769 :       *pDesc :
; 3770 :         DXGI_SWAP_CHAIN_DESC { };
; 3771 : 
; 3772 :   if (pDesc != nullptr)

	test	esi, esi
	je	$LN3@DXGIFactor

; 3295 :   WaitForInit ();

	call	?WaitForInitDXGI@@YAXXZ			; WaitForInitDXGI
	call	?WaitForInit@@YAXXZ			; WaitForInit

; 3338 :     dll_log.LogEx ( true,

	mov	eax, DWORD PTR _new_desc$[ebp+52]
	test	eax, eax
	jne	SHORT $LN130@DXGIFactor
	mov	ecx, OFFSET ??_C@_1BA@EMGLPOHC@?$AAD?$AAi?$AAs?$AAc?$AAa?$AAr?$AAd?$AA?$AA@
	jmp	SHORT $LN125@DXGIFactor
$LN130@DXGIFactor:
	cmp	eax, 1
	jne	SHORT $LN128@DXGIFactor
	mov	ecx, OFFSET ??_C@_1BG@MBNPLCBJ@?$AAS?$AAe?$AAq?$AAu?$AAe?$AAn?$AAt?$AAi?$AAa?$AAl?$AA?$AA@
	jmp	SHORT $LN125@DXGIFactor
$LN128@DXGIFactor:
	cmp	eax, 2
	jne	SHORT $LN126@DXGIFactor
	mov	ecx, OFFSET ??_C@_1BE@BGMELJBK@?$AA?$DM?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?$DO?$AA?$AA@
	jmp	SHORT $LN125@DXGIFactor
$LN126@DXGIFactor:
	cmp	eax, 3
	jne	SHORT $LN124@DXGIFactor
	mov	ecx, OFFSET ??_C@_1CA@DEGLGFCG@?$AAF?$AAl?$AAi?$AAp?$AA?5?$AAS?$AAe?$AAq?$AAu?$AAe?$AAn?$AAt?$AAi?$AAa?$AAl?$AA?$AA@
	jmp	SHORT $LN125@DXGIFactor
$LN124@DXGIFactor:
	cmp	eax, 4
	mov	ecx, OFFSET ??_C@_1BK@OJAHAHGF@?$AAF?$AAl?$AAi?$AAp?$AA?5?$AAD?$AAi?$AAs?$AAc?$AAa?$AAr?$AAd?$AA?$AA@
	mov	edx, OFFSET ??_C@_1BE@BGMELJBK@?$AA?$DM?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?$DO?$AA?$AA@
	cmovne	ecx, edx
$LN125@DXGIFactor:
	mov	eax, DWORD PTR _new_desc$[ebp+20]
	test	eax, eax
	jne	SHORT $LN134@DXGIFactor
	mov	edx, OFFSET ??_C@_1BI@DELFJJPB@?$AAU?$AAn?$AAs?$AAp?$AAe?$AAc?$AAi?$AAf?$AAi?$AAe?$AAd?$AA?$AA@
	jmp	SHORT $LN133@DXGIFactor
$LN134@DXGIFactor:
	cmp	eax, 1
	jne	SHORT $LN132@DXGIFactor
	mov	edx, OFFSET ??_C@_1BI@JFLEIIEG@?$AAP?$AAr?$AAo?$AAg?$AAr?$AAe?$AAs?$AAs?$AAi?$AAv?$AAe?$AA?$AA@
	jmp	SHORT $LN133@DXGIFactor
$LN132@DXGIFactor:
	cmp	eax, 2
	mov	edx, OFFSET ??_C@_1CA@MIMOHAAK@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAl?$AAa?$AAc?$AAe?$AAd?$AA?5?$AAE?$AAv?$AAe?$AAn?$AA?$AA@
	mov	edi, OFFSET ??_C@_1BO@NBKANNIC@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAl?$AAa?$AAc?$AAe?$AAd?$AA?5?$AAO?$AAd?$AAd?$AA?$AA@
	cmovne	edx, edi
$LN133@DXGIFactor:
	mov	eax, DWORD PTR _new_desc$[ebp+24]
	test	eax, eax
	jne	SHORT $LN136@DXGIFactor
	mov	edi, OFFSET ??_C@_1BI@DELFJJPB@?$AAU?$AAn?$AAs?$AAp?$AAe?$AAc?$AAi?$AAf?$AAi?$AAe?$AAd?$AA?$AA@
	jmp	SHORT $LN137@DXGIFactor
$LN136@DXGIFactor:
	cmp	eax, 1
	mov	DWORD PTR tv1435[ebp], OFFSET ??_C@_1BE@OKCKFGLA@?$AAS?$AAt?$AAr?$AAe?$AAt?$AAc?$AAh?$AAe?$AAd?$AA?$AA@
	mov	edi, OFFSET ??_C@_1BC@NODLAKGH@?$AAC?$AAe?$AAn?$AAt?$AAe?$AAr?$AAe?$AAd?$AA?$AA@
	cmovne	edi, DWORD PTR tv1435[ebp]
$LN137@DXGIFactor:
	cmp	DWORD PTR _new_desc$[ebp+12], 0
	je	SHORT $LN138@DXGIFactor
	mov	eax, DWORD PTR _new_desc$[ebp+8]
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	eax, DWORD PTR _new_desc$[ebp+12]
	cvtpd2ps xmm1, xmm0
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	divss	xmm1, xmm0
	jmp	SHORT $LN147@DXGIFactor
$LN138@DXGIFactor:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits

; 1119 : 		return (__builtin_nanf("0"));

	movss	xmm1, DWORD PTR __real@7fc00000
$LN147@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3338 :     dll_log.LogEx ( true,

	cmp	DWORD PTR _new_desc$[ebp+48], 0
	mov	eax, OFFSET ??_C@_1BC@PMICBOA@?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAe?$AAd?$AA?$AA@
	push	ecx
	push	DWORD PTR _new_desc$[ebp+56]
	mov	ecx, OFFSET ??_C@_1BG@EOMFJOKP@?$AAF?$AAu?$AAl?$AAl?$AAs?$AAc?$AAr?$AAe?$AAe?$AAn?$AA?$AA@
	push	DWORD PTR _new_desc$[ebp+40]
	cmove	eax, ecx
	push	eax
	push	edx
	push	edi
	sub	esp, 8
	cvtps2pd xmm0, xmm1
	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR _new_desc$[ebp+4]
	push	DWORD PTR _new_desc$[ebp]
	push	OFFSET ??_C@_1BAE@FEHGBMOO@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AAS?$AAw?$AAa?$AAp?$AAC?$AAh?$AAa?$AAi?$AAn?$AA?3?$AA?5?$AA?$CI?$AA?$CF?$AAl?$AAu?$AAx?$AA?$CF?$AAl@
	push	1
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx

; 3339 :       L"[   DXGI   ]  SwapChain: (%lux%lu @ %4.1f Hz - Scaling: %s - Scanlines: %s) - {%s}"
; 3340 :       L" [%lu Buffers] :: Flags=0x%04X, SwapEffect: %s\n",
; 3341 :       pDesc->BufferDesc.Width,
; 3342 :       pDesc->BufferDesc.Height,
; 3343 :       pDesc->BufferDesc.RefreshRate.Denominator != 0 ?
; 3344 :         static_cast <float> (pDesc->BufferDesc.RefreshRate.Numerator) /
; 3345 :         static_cast <float> (pDesc->BufferDesc.RefreshRate.Denominator) :
; 3346 :           std::numeric_limits <float>::quiet_NaN (),
; 3347 :       pDesc->BufferDesc.Scaling == DXGI_MODE_SCALING_UNSPECIFIED ?
; 3348 :         L"Unspecified" :
; 3349 :         pDesc->BufferDesc.Scaling == DXGI_MODE_SCALING_CENTERED ?
; 3350 :           L"Centered" :
; 3351 :           L"Stretched",
; 3352 :       pDesc->BufferDesc.ScanlineOrdering == DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED ?
; 3353 :         L"Unspecified" :
; 3354 :         pDesc->BufferDesc.ScanlineOrdering == DXGI_MODE_SCANLINE_ORDER_PROGRESSIVE ?
; 3355 :           L"Progressive" :
; 3356 :           pDesc->BufferDesc.ScanlineOrdering == DXGI_MODE_SCANLINE_ORDER_UPPER_FIELD_FIRST ?
; 3357 :             L"Interlaced Even" :
; 3358 :             L"Interlaced Odd",
; 3359 :       pDesc->Windowed ? L"Windowed" : L"Fullscreen",
; 3360 :       pDesc->BufferCount,
; 3361 :       pDesc->Flags,
; 3362 :       pDesc->SwapEffect         == 0 ?
; 3363 :         L"Discard" :
; 3364 :         pDesc->SwapEffect       == 1 ?
; 3365 :           L"Sequential" :
; 3366 :           pDesc->SwapEffect     == 2 ?
; 3367 :             L"<Unknown>" :
; 3368 :             pDesc->SwapEffect   == 3 ?
; 3369 :               L"Flip Sequential" :
; 3370 :               pDesc->SwapEffect == 4 ?
; 3371 :                 L"Flip Discard" :
; 3372 :                 L"<Unknown>" );
; 3373 : 
; 3374 :     // Set things up to make the swap chain Alt+Enter friendly
; 3375 :     if (bAlwaysAllowFullscreen && pDesc->Windowed)

	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+760
	add	esp, 52					; 00000034H
	cmp	BYTE PTR ?bAlwaysAllowFullscreen@@3_NA, 0 ; bAlwaysAllowFullscreen
	mov	edx, DWORD PTR ?config@@3Usk_config_t@@A+756
	mov	eax, DWORD PTR _new_desc$[ebp+48]
	je	SHORT $LN88@DXGIFactor
	test	eax, eax
	je	SHORT $LN228@DXGIFactor

; 3376 :     {
; 3377 :       pDesc->Flags                             |= DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

	or	DWORD PTR _new_desc$[ebp+56], 2

; 3378 :       pDesc->Windowed                           = true;

	mov	eax, 1
	mov	DWORD PTR _new_desc$[ebp+48], eax

; 3379 :       pDesc->BufferDesc.RefreshRate.Denominator = 0;

	mov	DWORD PTR _new_desc$[ebp+12], 0

; 3380 :       pDesc->BufferDesc.RefreshRate.Numerator   = 0;

	mov	DWORD PTR _new_desc$[ebp+8], 0

; 3381 :     }
; 3382 : 
; 3383 :     if (pDesc->Windowed && config.window.borderless && (! config.window.fullscreen))

	jmp	SHORT $LN224@DXGIFactor
$LN88@DXGIFactor:
	test	eax, eax
	je	SHORT $LN228@DXGIFactor
$LN224@DXGIFactor:
	cmp	BYTE PTR ?config@@3Usk_config_t@@A+728, 0
	je	SHORT $LN228@DXGIFactor
	cmp	BYTE PTR ?config@@3Usk_config_t@@A+754, 0
	jne	SHORT $LN228@DXGIFactor
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 425  :         bool isZero (void) { return x == 0 && y == 0; };

	test	edx, edx
	jne	SHORT $LN151@DXGIFactor
	test	ecx, ecx
	je	SHORT $LN92@DXGIFactor
$LN151@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3387 :         pDesc->BufferDesc.Width  = config.window.res.override.x;

	mov	DWORD PTR _new_desc$[ebp], edx

; 3388 :         pDesc->BufferDesc.Height = config.window.res.override.y;

	mov	DWORD PTR _new_desc$[ebp+4], ecx
$LN228@DXGIFactor:
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 425  :         bool isZero (void) { return x == 0 && y == 0; };

	test	edx, edx
	jne	SHORT $LN155@DXGIFactor
	test	ecx, ecx
	je	SHORT $LN92@DXGIFactor
$LN155@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3403 :       pDesc->BufferDesc.Width  = config.window.res.override.x;

	mov	DWORD PTR _new_desc$[ebp], edx

; 3404 :       pDesc->BufferDesc.Height = config.window.res.override.y;

	mov	DWORD PTR _new_desc$[ebp+4], ecx
$LN92@DXGIFactor:

; 3405 :     }
; 3406 : 
; 3407 : 
; 3408 :     if (config.render.dxgi.safe_fullscreen)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+488, 0
	je	SHORT $LN93@DXGIFactor

; 3409 :       pDesc->Flags |= DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

	or	DWORD PTR _new_desc$[ebp+56], 2
$LN93@DXGIFactor:

; 3410 : 
; 3411 :     if (request_mode_change == mode_change_request_e::Fullscreen)

	cmp	DWORD PTR ?request_mode_change@@3W4mode_change_request_e@@A, 1 ; request_mode_change
	jne	SHORT $LN94@DXGIFactor

; 3412 :     {
; 3413 :       dll_log.Log ( L"[   DXGI   ]  >> User-Requested Mode Change: Fullscreen" );

	push	OFFSET ??_C@_1HA@INGGDHHB@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAU?$AAs?$AAe?$AAr?$AA?9?$AAR?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AAe?$AAd?$AA?5@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 3414 :       pDesc->Windowed = FALSE;

	xor	eax, eax
	add	esp, 8

; 3415 :       pDesc->Flags   |= DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

	or	DWORD PTR _new_desc$[ebp+56], 2
	mov	DWORD PTR _new_desc$[ebp+48], eax
$LN94@DXGIFactor:

; 3416 :     }
; 3417 : 
; 3418 :     if (config.display.force_fullscreen && pDesc->Windowed)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+500, 0
	je	SHORT $LN95@DXGIFactor
	test	eax, eax
	je	SHORT $LN95@DXGIFactor

; 3419 :     {
; 3420 :       dll_log.Log ( L"[   DXGI   ]  >> Display Override "

	push	OFFSET ??_C@_1JG@HCAIICBG@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAD?$AAi?$AAs?$AAp?$AAl?$AAa?$AAy?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8

; 3421 :                     L"(Requested: Windowed, Using: Fullscreen)" );
; 3422 :       pDesc->Flags   |= DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
; 3423 :       pDesc->Windowed = FALSE;

	mov	DWORD PTR _new_desc$[ebp+48], 0
	or	DWORD PTR _new_desc$[ebp+56], 2
	jmp	SHORT $LN97@DXGIFactor
$LN95@DXGIFactor:

; 3424 :     }
; 3425 : 
; 3426 :     else if (config.display.force_windowed)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+501, 0
	je	SHORT $LN97@DXGIFactor

; 3427 :     {
; 3428 :       dll_log.Log ( L"[   DXGI   ]  >> Display Override "

	push	OFFSET ??_C@_1JG@LPALCGFK@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAD?$AAi?$AAs?$AAp?$AAl?$AAa?$AAy?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8

; 3429 :                     L"(Requested: Fullscreen, Using: Windowed)" );
; 3430 :       pDesc->Windowed = TRUE;

	mov	DWORD PTR _new_desc$[ebp+48], 1
$LN97@DXGIFactor:

; 3431 :     }
; 3432 : 
; 3433 : #ifdef _WIN64
; 3434 :     if (! bFlipMode)
; 3435 :       bFlipMode =
; 3436 :         ( dxgi_caps.present.flip_sequential && (
; 3437 :           ( ! lstrcmpW (SK_GetHostApp (), L"Fallout4.exe")) ||
; 3438 :             SK_DS3_UseFlipMode ()        ) );
; 3439 : 
; 3440 :     if (! lstrcmpW (SK_GetHostApp (), L"Fallout4.exe"))
; 3441 :     {
; 3442 :       if (bFlipMode)
; 3443 :           bFlipMode = (! SK_FO4_IsFullscreen ()) && SK_FO4_UseFlipMode ();
; 3444 :     }
; 3445 : 
; 3446 :     else
; 3447 : #endif
; 3448 :     {
; 3449 :       // If forcing flip-model, then force multisampling off
; 3450 :       if (config.render.framerate.flip_discard)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+416, 0
	je	SHORT $LN229@DXGIFactor

; 3451 :       {
; 3452 :         bFlipMode = dxgi_caps.present.flip_sequential;

	mov	al, BYTE PTR ?dxgi_caps@@3Udxgi_caps_t@@A+2
	mov	BYTE PTR ?bFlipMode@@3_NA, al		; bFlipMode

; 3453 :         pDesc->SampleDesc.Count = 1; pDesc->SampleDesc.Quality = 0;
; 3454 : 
; 3455 :         // Format overrides must be performed in certain cases (sRGB / 10:10:10:2)
; 3456 :         switch (pDesc->BufferDesc.Format)

	mov	eax, DWORD PTR _new_desc$[ebp+16]
	add	eax, -23				; ffffffe9H
	mov	DWORD PTR _new_desc$[ebp+28], 1
	mov	DWORD PTR _new_desc$[ebp+32], 0
	cmp	eax, 68					; 00000044H
	ja	SHORT $LN229@DXGIFactor
	movzx	eax, BYTE PTR $LN226@DXGIFactor[eax]
	jmp	DWORD PTR $LN237@DXGIFactor[eax*4]
$LN99@DXGIFactor:

; 3457 :         {
; 3458 :           case DXGI_FORMAT_B8G8R8A8_UNORM_SRGB:
; 3459 :             pDesc->BufferDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;

	mov	DWORD PTR _new_desc$[ebp+16], 87	; 00000057H

; 3460 :             dll_log.Log ( L"[ DXGI 1.2 ]  >> sRGB (B8G8R8A8) Override Required to Enable Flip Model" );

	push	OFFSET ??_C@_1JA@NDGFBELE@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA2?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAs?$AAR?$AAG?$AAB?$AA?5?$AA?$CI?$AAB?$AA8?$AAG?$AA8?$AAR?$AA8?$AAA?$AA8?$AA?$CJ@

; 3461 :             break;

	jmp	SHORT $LN234@DXGIFactor
$LN100@DXGIFactor:

; 3462 :           case DXGI_FORMAT_R8G8B8A8_UNORM_SRGB:
; 3463 :             pDesc->BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
; 3464 :             dll_log.Log ( L"[ DXGI 1.2 ]  >> sRGB (R8G8B8A8) Override Required to Enable Flip Model" );

	push	OFFSET ??_C@_1JA@CCHCBLHJ@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA2?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAs?$AAR?$AAG?$AAB?$AA?5?$AA?$CI?$AAR?$AA8?$AAG?$AA8?$AAB?$AA8?$AAA?$AA8?$AA?$CJ@

; 3465 :             break;

	jmp	SHORT $LN235@DXGIFactor
$LN101@DXGIFactor:

; 3469 :             dll_log.Log ( L"[ DXGI 1.2 ]  >> RGBA 10:10:10:2 Override (to 8:8:8:8) Required to Enable Flip Model" );

	push	OFFSET ??_C@_1KK@LPPCBMFA@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA2?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAR?$AAG?$AAB?$AAA?$AA?5?$AA1?$AA0?$AA?3?$AA1?$AA0?$AA?3?$AA1?$AA0?$AA?3?$AA2@
$LN235@DXGIFactor:

; 3466 :           case DXGI_FORMAT_R10G10B10A2_UNORM:
; 3467 :           case DXGI_FORMAT_R10G10B10A2_TYPELESS:
; 3468 :             pDesc->BufferDesc.Format =  DXGI_FORMAT_R8G8B8A8_UNORM;

	mov	DWORD PTR _new_desc$[ebp+16], 28	; 0000001cH
$LN234@DXGIFactor:

; 3469 :             dll_log.Log ( L"[ DXGI 1.2 ]  >> RGBA 10:10:10:2 Override (to 8:8:8:8) Required to Enable Flip Model" );

	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8
$LN229@DXGIFactor:

; 3470 :             break;
; 3471 :         }
; 3472 :       }
; 3473 :     }
; 3474 : 
; 3475 :     if (       config.render.framerate.buffer_count != -1                  &&
; 3476 :          (UINT)config.render.framerate.buffer_count !=  pDesc->BufferCount &&

	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+408
	cmp	ecx, -1
	je	SHORT $LN230@DXGIFactor
	mov	eax, DWORD PTR _new_desc$[ebp+40]
	cmp	ecx, eax
	je	SHORT $LN230@DXGIFactor
	test	eax, eax
	je	SHORT $LN230@DXGIFactor

; 3477 :          pDesc->BufferCount                         !=  0 )
; 3478 :     {
; 3479 :       pDesc->BufferCount = config.render.framerate.buffer_count;
; 3480 :       dll_log.Log (L"[   DXGI   ]  >> Buffer Count Override: %lu buffers", pDesc->BufferCount);

	push	ecx
	push	OFFSET ??_C@_1GI@GAEBCHMN@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AAO?$AAv@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	mov	DWORD PTR _new_desc$[ebp+40], ecx
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+408
	add	esp, 12					; 0000000cH
$LN230@DXGIFactor:

; 3481 :     }
; 3482 : 
; 3483 :     if ( config.render.framerate.flip_discard && dxgi_caps.swapchain.allow_tearing )

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+416, 0
	je	SHORT $LN103@DXGIFactor
	cmp	DWORD PTR ?dxgi_caps@@3Udxgi_caps_t@@A+8, 0
	je	SHORT $LN103@DXGIFactor

; 3484 :     {
; 3485 :       pDesc->Flags |= DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING;

	or	DWORD PTR _new_desc$[ebp+56], 2048	; 00000800H

; 3486 :       dll_log.Log ( L"[ DXGI 1.5 ]  >> Tearing Option:  Enable" );

	push	OFFSET ??_C@_1FC@PILPBEPG@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAT?$AAe?$AAa?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAO?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?3@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 3487 :       pDesc->Windowed = TRUE;

	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+408
	add	esp, 8
	mov	DWORD PTR _new_desc$[ebp+48], 1
$LN103@DXGIFactor:

; 3488 :     }
; 3489 : 
; 3490 :     if ( config.render.dxgi.scaling_mode != -1 &&

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+472
	cmp	eax, -1
	je	SHORT $LN104@DXGIFactor
	mov	edi, DWORD PTR _new_desc$[ebp+24]
	cmp	edi, eax
	je	SHORT $LN104@DXGIFactor

; 3491 :           pDesc->BufferDesc.Scaling      !=
; 3492 :             (DXGI_MODE_SCALING)config.render.dxgi.scaling_mode )
; 3493 :     {
; 3494 :       dll_log.Log ( L"[   DXGI   ]  >> Scaling Override "

	push	eax
	call	?SK_DXGI_DescribeScalingMode@@YAPB_WW4DXGI_MODE_SCALING@@@Z ; SK_DXGI_DescribeScalingMode
	add	esp, 4
	push	eax
	push	edi
	call	?SK_DXGI_DescribeScalingMode@@YAPB_WW4DXGI_MODE_SCALING@@@Z ; SK_DXGI_DescribeScalingMode
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_1HK@PGANLAKP@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAS?$AAc?$AAa?$AAl?$AAi?$AAn?$AAg?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 3495 :                     L"(Requested: %s, Using: %s)",
; 3496 :                       SK_DXGI_DescribeScalingMode (
; 3497 :                         pDesc->BufferDesc.Scaling
; 3498 :                       ),
; 3499 :                         SK_DXGI_DescribeScalingMode (
; 3500 :                           (DXGI_MODE_SCALING)config.render.dxgi.scaling_mode
; 3501 :                         )
; 3502 :                   );
; 3503 : 
; 3504 :       pDesc->BufferDesc.Scaling =

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+472
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+408
	mov	DWORD PTR _new_desc$[ebp+24], eax
$LN104@DXGIFactor:

; 3505 :         (DXGI_MODE_SCALING)config.render.dxgi.scaling_mode;
; 3506 :     }
; 3507 : 
; 3508 :     if ( config.render.dxgi.scanline_order != -1 &&

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+476
	cmp	eax, -1
	je	SHORT $LN105@DXGIFactor
	mov	edi, DWORD PTR _new_desc$[ebp+20]
	cmp	edi, eax
	je	SHORT $LN105@DXGIFactor

; 3509 :           pDesc->BufferDesc.ScanlineOrdering      !=
; 3510 :             (DXGI_MODE_SCANLINE_ORDER)config.render.dxgi.scanline_order )
; 3511 :     {
; 3512 :       dll_log.Log ( L"[   DXGI   ]  >> Scanline Override "

	push	eax
	call	?SK_DXGI_DescribeScanlineOrder@@YAPB_WW4DXGI_MODE_SCANLINE_ORDER@@@Z ; SK_DXGI_DescribeScanlineOrder
	add	esp, 4
	push	eax
	push	edi
	call	?SK_DXGI_DescribeScanlineOrder@@YAPB_WW4DXGI_MODE_SCANLINE_ORDER@@@Z ; SK_DXGI_DescribeScanlineOrder
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_1HM@EKHBGJHP@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAS?$AAc?$AAa?$AAn?$AAl?$AAi?$AAn?$AAe?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 3513 :                     L"(Requested: %s, Using: %s)",
; 3514 :                       SK_DXGI_DescribeScanlineOrder (
; 3515 :                         pDesc->BufferDesc.ScanlineOrdering
; 3516 :                       ),
; 3517 :                         SK_DXGI_DescribeScanlineOrder (
; 3518 :                           (DXGI_MODE_SCANLINE_ORDER)config.render.dxgi.scanline_order
; 3519 :                         )
; 3520 :                   );
; 3521 : 
; 3522 :       pDesc->BufferDesc.ScanlineOrdering =

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+476
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+408
	mov	DWORD PTR _new_desc$[ebp+20], eax
$LN105@DXGIFactor:

; 3523 :         (DXGI_MODE_SCANLINE_ORDER)config.render.dxgi.scanline_order;
; 3524 :     }
; 3525 : 
; 3526 :     if ( config.render.framerate.refresh_rate != -1 &&

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+424
	cmp	eax, -1
	je	SHORT $LN106@DXGIFactor
	mov	edx, DWORD PTR _new_desc$[ebp+8]
	cmp	edx, eax
	je	SHORT $LN106@DXGIFactor

; 3527 :          pDesc->BufferDesc.RefreshRate.Numerator != (UINT)config.render.framerate.refresh_rate )
; 3528 :     {
; 3529 :       dll_log.Log ( L"[   DXGI   ]  >> Refresh Override "

	mov	ecx, DWORD PTR _new_desc$[ebp+12]
	test	ecx, ecx
	je	SHORT $LN140@DXGIFactor
	movd	xmm0, edx
	cvtdq2pd xmm0, xmm0
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	cvtpd2ps xmm1, xmm0
	movd	xmm0, ecx
	cvtdq2pd xmm0, xmm0
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	cvtpd2ps xmm0, xmm0
	divss	xmm1, xmm0
	jmp	SHORT $LN158@DXGIFactor
$LN140@DXGIFactor:
	movss	xmm1, DWORD PTR __real@7fc00000
$LN158@DXGIFactor:
	push	eax
	cvtps2pd xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_1HM@GOOAFJFG@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAR?$AAe?$AAf?$AAr?$AAe?$AAs?$AAh?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 3530 :                     L"(Requested: %f, Using: %li)",
; 3531 :                  pDesc->BufferDesc.RefreshRate.Denominator != 0 ?
; 3532 :          static_cast <float> (pDesc->BufferDesc.RefreshRate.Numerator) /
; 3533 :          static_cast <float> (pDesc->BufferDesc.RefreshRate.Denominator) :
; 3534 :                      std::numeric_limits <float>::quiet_NaN (),
; 3535 :                         config.render.framerate.refresh_rate
; 3536 :                   );
; 3537 : 
; 3538 :       pDesc->BufferDesc.RefreshRate.Numerator   = config.render.framerate.refresh_rate;

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+424
	add	esp, 20					; 00000014H

; 3539 :       pDesc->BufferDesc.RefreshRate.Denominator = 1;

	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+408
	mov	DWORD PTR _new_desc$[ebp+8], eax
	mov	DWORD PTR _new_desc$[ebp+12], 1
$LN106@DXGIFactor:

; 3540 :     }
; 3541 : 
; 3542 :     bWait = bFlipMode && dxgi_caps.present.waitable;

	cmp	BYTE PTR ?bFlipMode@@3_NA, 0		; bFlipMode
	mov	edi, DWORD PTR ?config@@3Usk_config_t@@A+420
	je	SHORT $LN144@DXGIFactor
	cmp	BYTE PTR ?dxgi_caps@@3Udxgi_caps_t@@A+4, 0
	je	SHORT $LN144@DXGIFactor

; 3543 : 
; 3544 :     // We cannot change the swapchain parameters if this is used...
; 3545 :     bWait = bWait && config.render.framerate.swapchain_wait > 0;

	test	edi, edi
	jle	SHORT $LN144@DXGIFactor
	mov	dl, 1
	jmp	SHORT $LN236@DXGIFactor
$LN144@DXGIFactor:
	xor	dl, dl
$LN236@DXGIFactor:

; 3546 : 
; 3547 : #ifdef _WIN64
; 3548 :     if (! lstrcmpW (SK_GetHostApp (), L"DarkSoulsIII.exe"))
; 3549 :     {
; 3550 :       if (SK_DS3_IsBorderless ())
; 3551 :         pDesc->Flags &= ~DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
; 3552 :     }
; 3553 : #endif
; 3554 : 
; 3555 :     if (bFlipMode)

	cmp	BYTE PTR ?bFlipMode@@3_NA, 0		; bFlipMode
	mov	BYTE PTR ?bWait@@3_NA, dl		; bWait
	je	SHORT $LN107@DXGIFactor

; 3556 :     {
; 3557 :       if (bWait)

	test	dl, dl
	je	SHORT $LN109@DXGIFactor

; 3558 :         pDesc->Flags |= DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT;

	or	DWORD PTR _new_desc$[ebp+56], 64	; 00000040H
$LN109@DXGIFactor:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 3743 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, 3
	cmp	ecx, eax
	cmovg	eax, ecx
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3564 :       if (config.render.framerate.flip_discard &&

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+416, 0
	mov	ecx, eax
	mov	DWORD PTR ?config@@3Usk_config_t@@A+408, ecx
	je	SHORT $LN110@DXGIFactor
	cmp	BYTE PTR ?dxgi_caps@@3Udxgi_caps_t@@A+3, 0
	je	SHORT $LN110@DXGIFactor

; 3565 :           dxgi_caps.present.flip_discard)
; 3566 :         pDesc->SwapEffect  = DXGI_SWAP_EFFECT_FLIP_DISCARD;

	mov	DWORD PTR _new_desc$[ebp+52], 4

; 3567 :       else

	jmp	SHORT $LN112@DXGIFactor
$LN110@DXGIFactor:

; 3568 :         pDesc->SwapEffect  = DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL;

	mov	DWORD PTR _new_desc$[ebp+52], 3
	jmp	SHORT $LN112@DXGIFactor
$LN107@DXGIFactor:

; 3569 :     }
; 3570 : 
; 3571 :     else if ( pDesc->SwapEffect != DXGI_SWAP_EFFECT_FLIP_DISCARD &&

	mov	eax, DWORD PTR _new_desc$[ebp+52]
	cmp	eax, 4
	je	SHORT $LN112@DXGIFactor
	cmp	eax, 3
	je	SHORT $LN112@DXGIFactor

; 3572 :               pDesc->SwapEffect != DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL )
; 3573 :     {
; 3574 :       // Resort to triple-buffering if flip mode is not available
; 3575 :       if (config.render.framerate.buffer_count > 3)

	mov	eax, 3

; 3576 :         config.render.framerate.buffer_count = 3;
; 3577 : 
; 3578 :       pDesc->SwapEffect = DXGI_SWAP_EFFECT_DISCARD;

	mov	DWORD PTR _new_desc$[ebp+52], 0
	cmp	ecx, eax
	cmovg	ecx, eax
	mov	DWORD PTR ?config@@3Usk_config_t@@A+408, ecx
$LN112@DXGIFactor:

; 3579 :     }
; 3580 : 
; 3581 :     if (config.render.framerate.buffer_count > 0)

	mov	eax, DWORD PTR _new_desc$[ebp+40]
	test	ecx, ecx
	cmovg	eax, ecx

; 3582 :       pDesc->BufferCount = config.render.framerate.buffer_count;
; 3583 : 
; 3584 :     // We cannot switch modes on a waitable swapchain
; 3585 :     if (bFlipMode && bWait)

	cmp	BYTE PTR ?bFlipMode@@3_NA, 0		; bFlipMode
	mov	DWORD PTR _new_desc$[ebp+40], eax
	je	SHORT $LN115@DXGIFactor
	test	dl, dl
	je	SHORT $LN115@DXGIFactor

; 3586 :     {
; 3587 :       pDesc->Flags |=  DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT;
; 3588 :       pDesc->Flags &= ~DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

	mov	eax, DWORD PTR _new_desc$[ebp+56]
	and	eax, -3					; fffffffdH
	or	eax, 64					; 00000040H
	mov	DWORD PTR _new_desc$[ebp+56], eax
$LN115@DXGIFactor:

; 3592 :   dll_log.Log ( L"[ DXGI 1.2 ] >> Using %s Presentation Model  [Waitable: %s - %li ms]",

	xor	eax, eax
	mov	ecx, OFFSET ??_C@_15BICKNCBF@?$AAN?$AAo?$AA?$AA@
	test	dl, dl
	cmovne	eax, edi
	push	eax
	mov	eax, OFFSET ??_C@_17PBAHFJOA@?$AAY?$AAe?$AAs?$AA?$AA@
	cmove	eax, ecx
	cmp	BYTE PTR ?bFlipMode@@3_NA, 0		; bFlipMode
	push	eax
	mov	ecx, OFFSET ??_C@_1BI@PKCOFIGO@?$AAT?$AAr?$AAa?$AAd?$AAi?$AAt?$AAi?$AAo?$AAn?$AAa?$AAl?$AA?$AA@
	mov	eax, OFFSET ??_C@_19EMFBKLJE@?$AAF?$AAl?$AAi?$AAp?$AA?$AA@
	cmove	eax, ecx
	push	eax
	push	OFFSET ??_C@_1IK@KCJJDMDA@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA2?$AA?5?$AA?$FN?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAU?$AAs?$AAi?$AAn?$AAg?$AA?5?$AA?$CF?$AAs?$AA?5?$AAP?$AAr?$AAe?$AAs?$AAe?$AAn?$AAt@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 251  :           bool isZero (void) { return x == 0 && y == 0; };

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+460
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3592 :   dll_log.Log ( L"[ DXGI 1.2 ] >> Using %s Presentation Model  [Waitable: %s - %li ms]",

	add	esp, 20					; 00000014H
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 251  :           bool isZero (void) { return x == 0 && y == 0; };

	mov	edx, DWORD PTR ?config@@3Usk_config_t@@A+464
	test	eax, eax
	jne	SHORT $LN165@DXGIFactor
	test	edx, edx
	jne	SHORT $LN165@DXGIFactor
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3600 :   if ((! config.render.dxgi.res.max.isZero ()) && pDesc->BufferDesc.Height > config.render.dxgi.res.max.y)

	mov	eax, DWORD PTR _new_desc$[ebp+4]
	mov	ecx, DWORD PTR _new_desc$[ebp]
	jmp	SHORT $LN117@DXGIFactor
$LN165@DXGIFactor:

; 3593 :                  bFlipMode ? L"Flip" : L"Traditional",
; 3594 :                    bWait ? L"Yes" : L"No",
; 3595 :                      bWait ? config.render.framerate.swapchain_wait : 0 );
; 3596 : 
; 3597 : 
; 3598 :   if ((! config.render.dxgi.res.max.isZero ()) && pDesc->BufferDesc.Width > config.render.dxgi.res.max.x)

	mov	ecx, DWORD PTR _new_desc$[ebp]
	cmp	ecx, eax
	cmova	ecx, eax
	mov	DWORD PTR _new_desc$[ebp], ecx
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 251  :           bool isZero (void) { return x == 0 && y == 0; };

	test	eax, eax
	jne	SHORT $LN169@DXGIFactor
	test	edx, edx
	jne	SHORT $LN169@DXGIFactor
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3600 :   if ((! config.render.dxgi.res.max.isZero ()) && pDesc->BufferDesc.Height > config.render.dxgi.res.max.y)

	mov	eax, DWORD PTR _new_desc$[ebp+4]
	jmp	SHORT $LN117@DXGIFactor
$LN169@DXGIFactor:
	mov	eax, DWORD PTR _new_desc$[ebp+4]
	cmp	eax, edx
	cmova	eax, edx
	mov	DWORD PTR _new_desc$[ebp+4], eax
$LN117@DXGIFactor:
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 246  :           bool isZero (void) { return x == 0 && y == 0; };

	mov	edi, DWORD PTR ?config@@3Usk_config_t@@A+452
	mov	edx, DWORD PTR ?config@@3Usk_config_t@@A+456
	test	edi, edi
	jne	SHORT $LN173@DXGIFactor
	test	edx, edx
	jne	SHORT $LN177@DXGIFactor
	jmp	SHORT $LN122@DXGIFactor
$LN173@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3603 :   if ((! config.render.dxgi.res.min.isZero ()) && pDesc->BufferDesc.Width < config.render.dxgi.res.min.x)

	cmp	ecx, edi
	cmovb	ecx, edi
	mov	DWORD PTR _new_desc$[ebp], ecx
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 246  :           bool isZero (void) { return x == 0 && y == 0; };

	test	edi, edi
	jne	SHORT $LN177@DXGIFactor
	test	edx, edx
	je	SHORT $LN122@DXGIFactor
$LN177@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3605 :   if ((! config.render.dxgi.res.min.isZero ()) && pDesc->BufferDesc.Height < config.render.dxgi.res.min.y)

	cmp	eax, edx
	cmovb	eax, edx
	mov	DWORD PTR _new_desc$[ebp+4], eax
$LN122@DXGIFactor:

; 3773 :   {
; 3774 :     SK_DXGI_CreateSwapChain_PreInit (&new_desc, nullptr, new_desc.OutputWindow, nullptr);
; 3775 :     pDesc = &new_desc;

	lea	eax, DWORD PTR _new_desc$[ebp]
	mov	DWORD PTR _pDesc$[ebp], eax
$LN3@DXGIFactor:

; 3796 :       };

	lea	eax, DWORD PTR _ret$[ebp]
	mov	DWORD PTR _CreateSwapChain_Lambchop$[ebp], eax

; 3797 : 
; 3798 : 
; 3799 :   if (! CreateSwapChain_Lambchop ())

	lea	ecx, DWORD PTR _CreateSwapChain_Lambchop$[ebp]

; 3796 :       };

	lea	eax, DWORD PTR _This$[ebp]
	mov	DWORD PTR _CreateSwapChain_Lambchop$[ebp+4], eax
	lea	eax, DWORD PTR _pDevice$[ebp]
	mov	DWORD PTR _CreateSwapChain_Lambchop$[ebp+8], eax
	lea	eax, DWORD PTR _pDesc$[ebp]
	mov	DWORD PTR _CreateSwapChain_Lambchop$[ebp+12], eax
	lea	eax, DWORD PTR _ppSwapChain$[ebp]
	mov	DWORD PTR _CreateSwapChain_Lambchop$[ebp+16], eax
	lea	eax, DWORD PTR _new_desc$[ebp]
	mov	DWORD PTR _CreateSwapChain_Lambchop$[ebp+20], eax

; 3797 : 
; 3798 : 
; 3799 :   if (! CreateSwapChain_Lambchop ())

	call	??R<lambda_49fe4316955e3999d8d7fe725292d871>@@QBEHXZ ; <lambda_49fe4316955e3999d8d7fe725292d871>::operator()
	pop	edi
	test	eax, eax
	jne	SHORT $LN4@DXGIFactor

; 3800 :   {
; 3801 :     // Fallback-on-Fail
; 3802 :     pDesc = orig_desc;
; 3803 : 
; 3804 :     CreateSwapChain_Lambchop ();

	lea	ecx, DWORD PTR _CreateSwapChain_Lambchop$[ebp]
	mov	DWORD PTR _pDesc$[ebp], esi
	call	??R<lambda_49fe4316955e3999d8d7fe725292d871>@@QBEHXZ ; <lambda_49fe4316955e3999d8d7fe725292d871>::operator()
$LN4@DXGIFactor:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	ecx, DWORD PTR _iname$[ebp+20]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3808 :   return ret;

	mov	esi, DWORD PTR _ret$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	ecx, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN227@DXGIFactor
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	ecx
	push	DWORD PTR _iname$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN227@DXGIFactor:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3809 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	3
$LN237@DXGIFactor:
	DD	$LN101@DXGIFactor
	DD	$LN100@DXGIFactor
	DD	$LN99@DXGIFactor
	DD	$LN229@DXGIFactor
$LN226@DXGIFactor:
	DB	0
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?DXGIFactory_CreateSwapChain_Override@@YGJPAUIDXGIFactory@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z$0:
	lea	ecx, DWORD PTR _iname$[ebp]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__ehhandler$?DXGIFactory_CreateSwapChain_Override@@YGJPAUIDXGIFactory@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?DXGIFactory_CreateSwapChain_Override@@YGJPAUIDXGIFactory@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DXGIFactory_CreateSwapChain_Override@@YGJPAUIDXGIFactory@@PAUIUnknown@@PBUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z ENDP ; DXGIFactory_CreateSwapChain_Override
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComQIPtr@UIDXGISwapChain@@$1?_GUID_310d36a0_d2e7_4c0a_aa04_6a9d23b8886a@@3U__s_GUID@@B@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComQIPtr@UIDXGISwapChain@@$1?_GUID_310d36a0_d2e7_4c0a_aa04_6a9d23b8886a@@3U__s_GUID@@B@ATL@@QAE@XZ PROC ; ATL::CComQIPtr<IDXGISwapChain,&_GUID_310d36a0_d2e7_4c0a_aa04_6a9d23b8886a>::~CComQIPtr<IDXGISwapChain,&_GUID_310d36a0_d2e7_4c0a_aa04_6a9d23b8886a>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComQIPtr@UIDXGISwapChain@@$1?_GUID_310d36a0_d2e7_4c0a_aa04_6a9d23b8886a@@3U__s_GUID@@B@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN7@CComQIPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN7@CComQIPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComQIPtr@UIDXGISwapChain@@$1?_GUID_310d36a0_d2e7_4c0a_aa04_6a9d23b8886a@@3U__s_GUID@@B@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComQIPtr@UIDXGISwapChain@@$1?_GUID_310d36a0_d2e7_4c0a_aa04_6a9d23b8886a@@3U__s_GUID@@B@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComQIPtr@UIDXGISwapChain@@$1?_GUID_310d36a0_d2e7_4c0a_aa04_6a9d23b8886a@@3U__s_GUID@@B@ATL@@QAE@XZ ENDP ; ATL::CComQIPtr<IDXGISwapChain,&_GUID_310d36a0_d2e7_4c0a_aa04_6a9d23b8886a>::~CComQIPtr<IDXGISwapChain,&_GUID_310d36a0_d2e7_4c0a_aa04_6a9d23b8886a>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComQIPtr@UIDXGISwapChain@@$1?_GUID_310d36a0_d2e7_4c0a_aa04_6a9d23b8886a@@3U__s_GUID@@B@ATL@@QAE@PAUIDXGISwapChain@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComQIPtr@UIDXGISwapChain@@$1?_GUID_310d36a0_d2e7_4c0a_aa04_6a9d23b8886a@@3U__s_GUID@@B@ATL@@QAE@PAUIDXGISwapChain@@@Z PROC ; ATL::CComQIPtr<IDXGISwapChain,&_GUID_310d36a0_d2e7_4c0a_aa04_6a9d23b8886a>::CComQIPtr<IDXGISwapChain,&_GUID_310d36a0_d2e7_4c0a_aa04_6a9d23b8886a>, COMDAT
; _this$ = ecx

; 615  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi

; 615  :     {

	mov	esi, ecx

; 162  :         p = lp;

	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN8@CComQIPtr

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN8@CComQIPtr:

; 616  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComQIPtr@UIDXGISwapChain@@$1?_GUID_310d36a0_d2e7_4c0a_aa04_6a9d23b8886a@@3U__s_GUID@@B@ATL@@QAE@PAUIDXGISwapChain@@@Z ENDP ; ATL::CComQIPtr<IDXGISwapChain,&_GUID_310d36a0_d2e7_4c0a_aa04_6a9d23b8886a>::CComQIPtr<IDXGISwapChain,&_GUID_310d36a0_d2e7_4c0a_aa04_6a9d23b8886a>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtr@UIDXGISwapChain@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComPtr@UIDXGISwapChain@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<IDXGISwapChain>::~CComPtr<IDXGISwapChain>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComPtr@UIDXGISwapChain@@@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@CComPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN4@CComPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComPtr@UIDXGISwapChain@@@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComPtr@UIDXGISwapChain@@@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComPtr@UIDXGISwapChain@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<IDXGISwapChain>::~CComPtr<IDXGISwapChain>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UIDXGISwapChain@@@ATL@@QAE@PAUIDXGISwapChain@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtr@UIDXGISwapChain@@@ATL@@QAE@PAUIDXGISwapChain@@@Z PROC ; ATL::CComPtr<IDXGISwapChain>::CComPtr<IDXGISwapChain>, COMDAT
; _this$ = ecx

; 312  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi

; 312  :     {

	mov	esi, ecx

; 162  :         p = lp;

	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN6@CComPtr

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN6@CComPtr:

; 313  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtr@UIDXGISwapChain@@@ATL@@QAE@PAUIDXGISwapChain@@@Z ENDP ; ATL::CComPtr<IDXGISwapChain>::CComPtr<IDXGISwapChain>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??I?$CComPtrBase@UIDXGISwapChain@@@ATL@@QAEPAPAUIDXGISwapChain@@XZ
_TEXT	SEGMENT
??I?$CComPtrBase@UIDXGISwapChain@@@ATL@@QAEPAPAUIDXGISwapChain@@XZ PROC ; ATL::CComPtrBase<IDXGISwapChain>::operator&, COMDAT
; _this$ = ecx

; 192  :         ATLASSERT(p==NULL);
; 193  :         return &p;

	mov	eax, ecx

; 194  :     }

	ret	0
??I?$CComPtrBase@UIDXGISwapChain@@@ATL@@QAEPAPAUIDXGISwapChain@@XZ ENDP ; ATL::CComPtrBase<IDXGISwapChain>::operator&
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??B?$CComPtrBase@UIDXGISwapChain@@@ATL@@QBEPAUIDXGISwapChain@@XZ
_TEXT	SEGMENT
??B?$CComPtrBase@UIDXGISwapChain@@@ATL@@QBEPAUIDXGISwapChain@@XZ PROC ; ATL::CComPtrBase<IDXGISwapChain>::operator IDXGISwapChain *, COMDAT
; _this$ = ecx

; 181  :         return p;

	mov	eax, DWORD PTR [ecx]

; 182  :     }

	ret	0
??B?$CComPtrBase@UIDXGISwapChain@@@ATL@@QBEPAUIDXGISwapChain@@XZ ENDP ; ATL::CComPtrBase<IDXGISwapChain>::operator IDXGISwapChain *
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UIDXGISwapChain@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UIDXGISwapChain@@@ATL@@QAE@XZ PROC	; ATL::CComPtrBase<IDXGISwapChain>::~CComPtrBase<IDXGISwapChain>, COMDAT
; _this$ = ecx

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN2@CComPtrBas

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@CComPtrBas:

; 178  :     }

	ret	0
??1?$CComPtrBase@UIDXGISwapChain@@@ATL@@QAE@XZ ENDP	; ATL::CComPtrBase<IDXGISwapChain>::~CComPtrBase<IDXGISwapChain>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UIDXGISwapChain@@@ATL@@IAE@PAUIDXGISwapChain@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtrBase@UIDXGISwapChain@@@ATL@@IAE@PAUIDXGISwapChain@@@Z PROC ; ATL::CComPtrBase<IDXGISwapChain>::CComPtrBase<IDXGISwapChain>, COMDAT
; _this$ = ecx

; 160  :     CComPtrBase(_Inout_opt_ T* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp

; 161  :     {
; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN4@CComPtrBas

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN4@CComPtrBas:

; 165  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtrBase@UIDXGISwapChain@@@ATL@@IAE@PAUIDXGISwapChain@@@Z ENDP ; ATL::CComPtrBase<IDXGISwapChain>::CComPtrBase<IDXGISwapChain>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
;	COMDAT ?SK_DXGI_CreateSwapChain1_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC1@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAPAUIDXGISwapChain1@@@Z
_TEXT	SEGMENT
_desc$ = -96						; size = 60
_client$2 = -36						; size = 16
_pSwapChain$ = -20					; size = 4
_desc$3$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pDevice$ = 8						; size = 4
_pDev$3 = 12						; size = 4
_pDesc1$ = 12						; size = 4
_pSwapChain2$4 = 16					; size = 4
_pFullscreenDesc$ = 16					; size = 4
_pDevice1$5 = 20					; size = 4
_ppSwapChain1$ = 20					; size = 4
?SK_DXGI_CreateSwapChain1_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC1@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAPAUIDXGISwapChain1@@@Z PROC ; SK_DXGI_CreateSwapChain1_PostInit, COMDAT

; 3725 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?SK_DXGI_CreateSwapChain1_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC1@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAPAUIDXGISwapChain1@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 84					; 00000054H

; 3726 :   // ONLY AS COMPLETE AS NEEDED, if new code is added to PostInit, this will probably need changing.
; 3727 :   DXGI_SWAP_CHAIN_DESC desc;
; 3728 : 
; 3729 :   desc.BufferDesc.Width   = pDesc1->Width;

	mov	eax, DWORD PTR _pDesc1$[ebp]
	push	ebx

; 3730 :   desc.BufferDesc.Height  = pDesc1->Height;

	mov	ebx, DWORD PTR [eax+4]
	push	esi
	push	edi
	mov	edi, DWORD PTR [eax]

; 3731 : 
; 3732 :   desc.BufferDesc.Format  = pDesc1->Format;
; 3733 :   //desc.BufferDesc.Scaling = pDesc1->Scaling;
; 3734 : 
; 3735 :   desc.BufferCount        = pDesc1->BufferCount;
; 3736 :   desc.BufferUsage        = pDesc1->BufferUsage;
; 3737 :   desc.Flags              = pDesc1->Flags;
; 3738 :   desc.SampleDesc         = pDesc1->SampleDesc;
; 3739 :   desc.SwapEffect         = pDesc1->SwapEffect;
; 3740 : 
; 3741 :   if (pFullscreenDesc)

	mov	eax, DWORD PTR _pFullscreenDesc$[ebp]
	test	eax, eax
	je	SHORT $LN94@SK_DXGI_Cr

; 3743 :     desc.Windowed                    = pFullscreenDesc->Windowed;

	mov	eax, DWORD PTR [eax+16]
	jmp	SHORT $LN98@SK_DXGI_Cr
$LN94@SK_DXGI_Cr:
	mov	eax, DWORD PTR _desc$[ebp+48]
$LN98@SK_DXGI_Cr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	esi, DWORD PTR _ppSwapChain1$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3743 :     desc.Windowed                    = pFullscreenDesc->Windowed;

	mov	DWORD PTR _desc$3$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	esi, DWORD PTR [esi]
	mov	DWORD PTR _pSwapChain$[ebp], esi

; 163  :         if (p != NULL)

	test	esi, esi
	je	SHORT $LN10@SK_DXGI_Cr

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [esi]
	push	esi
	call	DWORD PTR [eax+4]
$LN10@SK_DXGI_Cr:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3647 :   SK_RunOnce (SK_CEGUI_QueueResetD3D11 ());

	cmp	BYTE PTR ?first@?2??SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z@4_NA, 0 ; `SK_DXGI_CreateSwapChain_PostInit'::`3'::first

; 3744 :     desc.BufferDesc.RefreshRate      = pFullscreenDesc->RefreshRate;
; 3745 :     desc.BufferDesc.ScanlineOrdering = pFullscreenDesc->ScanlineOrdering;
; 3746 :   }
; 3747 : 
; 3748 :   CComQIPtr <IDXGISwapChain> pSwapChain ((*ppSwapChain1));

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3647 :   SK_RunOnce (SK_CEGUI_QueueResetD3D11 ());

	je	SHORT $LN15@SK_DXGI_Cr
	call	?SK_CEGUI_QueueResetD3D11@@YAXXZ	; SK_CEGUI_QueueResetD3D11
	mov	BYTE PTR ?first@?2??SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z@4_NA, 0 ; `SK_DXGI_CreateSwapChain_PostInit'::`3'::first
$LN15@SK_DXGI_Cr:

; 3648 : 
; 3649 :   if (pDesc->BufferDesc.Width != 0)

	test	edi, edi
	je	SHORT $LN16@SK_DXGI_Cr

; 3650 :   {
; 3651 :     SK_SetWindowResX (pDesc->BufferDesc.Width);

	push	edi
	call	?SK_SetWindowResX@@YAXJ@Z		; SK_SetWindowResX

; 3652 :     SK_SetWindowResY (pDesc->BufferDesc.Height);

	push	ebx

; 3653 :   }
; 3654 : 
; 3655 :   else

	jmp	SHORT $LN99@SK_DXGI_Cr
$LN16@SK_DXGI_Cr:

; 3656 :   {
; 3657 :     RECT client;
; 3658 : 
; 3659 :     GetClientRect    (game_window.hWnd, &client);

	lea	eax, DWORD PTR _client$2[ebp]
	push	eax
	push	DWORD PTR ?game_window@@3Usk_window_s@@A+4
	call	DWORD PTR __imp__GetClientRect@8

; 3660 :     SK_SetWindowResX (client.right  - client.left);

	mov	eax, DWORD PTR _client$2[ebp+8]
	sub	eax, DWORD PTR _client$2[ebp]
	push	eax
	call	?SK_SetWindowResX@@YAXJ@Z		; SK_SetWindowResX

; 3661 :     SK_SetWindowResY (client.bottom - client.top);

	mov	eax, DWORD PTR _client$2[ebp+12]
	sub	eax, DWORD PTR _client$2[ebp+4]
	push	eax
$LN99@SK_DXGI_Cr:
	call	?SK_SetWindowResY@@YAXJ@Z		; SK_SetWindowResY
	add	esp, 8

; 3662 :   }
; 3663 : 
; 3664 :   SK_RunOnce (SK_DXGI_HookSwapChain (*ppSwapChain));

	cmp	BYTE PTR ?first@?M@??SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z@4_NA, 0 ; `SK_DXGI_CreateSwapChain_PostInit'::`12'::first
	je	SHORT $LN18@SK_DXGI_Cr
	push	esi
	call	?SK_DXGI_HookSwapChain@@YAXPAUIDXGISwapChain@@@Z ; SK_DXGI_HookSwapChain
	add	esp, 4
	mov	BYTE PTR ?first@?M@??SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z@4_NA, 0 ; `SK_DXGI_CreateSwapChain_PostInit'::`12'::first
$LN18@SK_DXGI_Cr:

; 3665 : 
; 3666 :   //if (bFlipMode || bWait)
; 3667 :     //DXGISwap_ResizeBuffers_Override (*ppSwapChain, config.render.framerate.buffer_count,
; 3668 :     //pDesc->BufferDesc.Width, pDesc->BufferDesc.Height, pDesc->BufferDesc.Format, pDesc->Flags);
; 3669 : 
; 3670 :   const uint32_t max_latency = config.render.framerate.pre_render_limit;

	mov	ebx, DWORD PTR ?config@@3Usk_config_t@@A+400
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pSwapChain2$4[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3674 :   if ( bFlipMode && bWait &&

	cmp	BYTE PTR ?bFlipMode@@3_NA, 0		; bFlipMode
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	je	SHORT $LN95@SK_DXGI_Cr
	cmp	BYTE PTR ?bWait@@3_NA, 0		; bWait
	je	SHORT $LN95@SK_DXGI_Cr
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _pSwapChain2$4[ebp]
	push	ecx
	push	OFFSET __GUID_a8be2ac4_199f_4946_b331_79599fb98de7
	push	esi
	call	DWORD PTR [eax]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3674 :   if ( bFlipMode && bWait &&

	test	eax, eax
	js	SHORT $LN95@SK_DXGI_Cr

; 3675 :        SUCCEEDED ( (*ppSwapChain)->QueryInterface <IDXGISwapChain2> (&pSwapChain2) )
; 3676 :       )
; 3677 :   {
; 3678 :     if (max_latency < 16)

	cmp	ebx, 16					; 00000010H
	jae	SHORT $LN20@SK_DXGI_Cr

; 3679 :     {
; 3680 :       dll_log.Log (L"[   DXGI   ] Setting Swapchain Frame Latency: %lu", max_latency);

	push	ebx
	push	OFFSET ??_C@_1GE@BOIALL@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAS?$AAw?$AAa?$AAp?$AAc?$AAh?$AAa?$AAi?$AAn?$AA?5?$AAF@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 3681 :       pSwapChain2->SetMaximumFrameLatency (max_latency);

	mov	eax, DWORD PTR _pSwapChain2$4[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	push	ebx
	push	eax
	call	DWORD PTR [ecx+124]
$LN20@SK_DXGI_Cr:

; 3682 :     }
; 3683 : 
; 3684 :     HANDLE hWait =
; 3685 :       pSwapChain2->GetFrameLatencyWaitableObject ();

	mov	eax, DWORD PTR _pSwapChain2$4[ebp]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+132]

; 3686 : 
; 3687 :     WaitForSingleObjectEx ( hWait,

	push	1
	push	500					; 000001f4H
	push	eax
	call	DWORD PTR __imp__WaitForSingleObjectEx@12
$LN95@SK_DXGI_Cr:

; 3688 :                               500,//config.render.framerate.swapchain_wait,
; 3689 :                                 TRUE );
; 3690 :   }
; 3691 : 
; 3692 :   {
; 3693 :     if (max_latency != -1)

	cmp	ebx, -1
	je	SHORT $LN96@SK_DXGI_Cr
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pDevice1$5[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3697 :       if (SUCCEEDED ( (*ppSwapChain)->GetDevice (

	mov	edi, DWORD PTR [esi]
	lea	eax, DWORD PTR _pDevice1$5[ebp]
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??$IID_PPV_ARGS_Helper@UIDXGIDevice1@@@@YAPAPAXPAPAUIDXGIDevice1@@@Z ; IID_PPV_ARGS_Helper<IDXGIDevice1>
	add	esp, 4
	push	eax
	push	OFFSET __GUID_77db970f_6276_48ba_ba28_070143b4392c
	push	esi
	call	DWORD PTR [edi+28]
	test	eax, eax
	js	SHORT $LN22@SK_DXGI_Cr

; 3698 :                          IID_PPV_ARGS (&pDevice1)
; 3699 :                       )
; 3700 :                     )
; 3701 :          )
; 3702 :       {
; 3703 :         dll_log.Log (L"[   DXGI   ] Setting Device Frame Latency: %lu", max_latency);

	push	ebx
	push	OFFSET ??_C@_1FO@CKMCMFKO@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AAF?$AAr?$AAa?$AAm@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 3704 :         pDevice1->SetMaximumFrameLatency (max_latency);

	mov	eax, DWORD PTR _pDevice1$5[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	push	ebx
	push	eax
	call	DWORD PTR [ecx+48]
$LN22@SK_DXGI_Cr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	mov	eax, DWORD PTR _pDevice1$5[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3706 :     }

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN96@SK_DXGI_Cr

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN96@SK_DXGI_Cr:

; 623  :         if (lp != NULL)

	mov	edx, DWORD PTR _pDevice$[ebp]

; 158  :         p = NULL;

	xor	ecx, ecx
	mov	DWORD PTR _pDev$3[ebp], ecx

; 623  :         if (lp != NULL)

	test	edx, edx
	je	SHORT $LN58@SK_DXGI_Cr

; 624  :         {
; 625  :             if (FAILED(lp->QueryInterface(*piid, (void **)&this->p)))

	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR _pDev$3[ebp]
	push	ecx
	push	OFFSET __GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140
	push	edx
	call	DWORD PTR [eax]
	mov	ecx, DWORD PTR _pDev$3[ebp]
	xor	edx, edx
	test	eax, eax
	cmovs	ecx, edx
	mov	DWORD PTR _pDev$3[ebp], ecx
$LN58@SK_DXGI_Cr:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3709 :   CComQIPtr <ID3D11Device> pDev (pDevice);

	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 214  :         return p == pT;

	test	ecx, ecx
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3711 :   if (pDev != nullptr)

	je	SHORT $LN23@SK_DXGI_Cr

; 3712 :   {
; 3713 :     g_pD3D11Dev = pDev;
; 3714 : 
; 3715 :     SK_GetCurrentRenderBackend ().fullscreen_exclusive = (! pDesc->Windowed);

	cmp	DWORD PTR _desc$3$[ebp], 0
	mov	DWORD PTR ?g_pD3D11Dev@@3PAUID3D11Device@@A, ecx ; g_pD3D11Dev
	sete	bl
	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend
	mov	BYTE PTR [eax+48], bl
	mov	ecx, DWORD PTR _pDev$3[ebp]
$LN23@SK_DXGI_Cr:

; 3717 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	ecx, ecx
	je	SHORT $LN77@SK_DXGI_Cr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN77@SK_DXGI_Cr:

; 176  :         if (p)

	mov	eax, DWORD PTR _pSwapChain2$4[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3717 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN83@SK_DXGI_Cr

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN83@SK_DXGI_Cr:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3750 :   return SK_DXGI_CreateSwapChain_PostInit ( pDevice, &desc, &pSwapChain );

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	esi, esi
	je	SHORT $LN92@SK_DXGI_Cr

; 177  :             p->Release();

	mov	eax, DWORD PTR [esi]
	push	esi
	call	DWORD PTR [eax+8]
$LN92@SK_DXGI_Cr:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3751 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SK_DXGI_CreateSwapChain1_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC1@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAPAUIDXGISwapChain1@@@Z$0:
	lea	ecx, DWORD PTR _pSwapChain$[ebp]
	jmp	??1?$CComQIPtr@UIDXGISwapChain@@$1?_GUID_310d36a0_d2e7_4c0a_aa04_6a9d23b8886a@@3U__s_GUID@@B@ATL@@QAE@XZ
__unwindfunclet$?SK_DXGI_CreateSwapChain1_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC1@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAPAUIDXGISwapChain1@@@Z$1:
	lea	ecx, DWORD PTR _pSwapChain2$4[ebp]
	jmp	??1?$CComPtr@UIDXGISwapChain2@@@ATL@@QAE@XZ
__unwindfunclet$?SK_DXGI_CreateSwapChain1_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC1@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAPAUIDXGISwapChain1@@@Z$2:
	lea	ecx, DWORD PTR _pDevice1$5[ebp]
	jmp	??1?$CComPtr@UIDXGIDevice1@@@ATL@@QAE@XZ
__unwindfunclet$?SK_DXGI_CreateSwapChain1_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC1@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAPAUIDXGISwapChain1@@@Z$3:
	lea	ecx, DWORD PTR _pDev$3[ebp]
	jmp	??1?$CComQIPtr@UID3D11Device@@$1?_GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140@@3U__s_GUID@@B@ATL@@QAE@XZ
__ehhandler$?SK_DXGI_CreateSwapChain1_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC1@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAPAUIDXGISwapChain1@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?SK_DXGI_CreateSwapChain1_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC1@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAPAUIDXGISwapChain1@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_DXGI_CreateSwapChain1_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC1@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@PAPAUIDXGISwapChain1@@@Z ENDP ; SK_DXGI_CreateSwapChain1_PostInit
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComQIPtr@UID3D11Device@@$1?_GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140@@3U__s_GUID@@B@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComQIPtr@UID3D11Device@@$1?_GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140@@3U__s_GUID@@B@ATL@@QAE@XZ PROC ; ATL::CComQIPtr<ID3D11Device,&_GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140>::~CComQIPtr<ID3D11Device,&_GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComQIPtr@UID3D11Device@@$1?_GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140@@3U__s_GUID@@B@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN7@CComQIPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN7@CComQIPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComQIPtr@UID3D11Device@@$1?_GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140@@3U__s_GUID@@B@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComQIPtr@UID3D11Device@@$1?_GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140@@3U__s_GUID@@B@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComQIPtr@UID3D11Device@@$1?_GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140@@3U__s_GUID@@B@ATL@@QAE@XZ ENDP ; ATL::CComQIPtr<ID3D11Device,&_GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140>::~CComQIPtr<ID3D11Device,&_GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComQIPtr@UID3D11Device@@$1?_GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComQIPtr@UID3D11Device@@$1?_GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z PROC ; ATL::CComQIPtr<ID3D11Device,&_GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140>::CComQIPtr<ID3D11Device,&_GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140>, COMDAT
; _this$ = ecx

; 621  :     CComQIPtr(_Inout_opt_ IUnknown* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 622  :     {
; 623  :         if (lp != NULL)

	mov	ecx, DWORD PTR _lp$[ebp]

; 158  :         p = NULL;

	mov	DWORD PTR [esi], 0

; 622  :     {
; 623  :         if (lp != NULL)

	test	ecx, ecx
	je	SHORT $LN10@CComQIPtr

; 624  :         {
; 625  :             if (FAILED(lp->QueryInterface(*piid, (void **)&this->p)))

	mov	eax, DWORD PTR [ecx]
	push	esi
	push	OFFSET __GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140
	push	ecx
	call	DWORD PTR [eax]
	test	eax, eax

; 627  :         }
; 628  :     }

	mov	eax, esi
	jns	SHORT $LN3@CComQIPtr

; 626  :                 this->p = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 627  :         }
; 628  :     }

	pop	ebp
	ret	4
$LN10@CComQIPtr:
	mov	eax, esi
$LN3@CComQIPtr:
	pop	esi
	pop	ebp
	ret	4
??0?$CComQIPtr@UID3D11Device@@$1?_GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z ENDP ; ATL::CComQIPtr<ID3D11Device,&_GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140>::CComQIPtr<ID3D11Device,&_GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\combaseapi.h
;	COMDAT ??$IID_PPV_ARGS_Helper@UIDXGIDevice1@@@@YAPAPAXPAPAUIDXGIDevice1@@@Z
_TEXT	SEGMENT
_pp$ = 8						; size = 4
??$IID_PPV_ARGS_Helper@UIDXGIDevice1@@@@YAPAPAXPAPAUIDXGIDevice1@@@Z PROC ; IID_PPV_ARGS_Helper<IDXGIDevice1>, COMDAT

; 227  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 228  : #pragma prefast(suppress: 6269, "Tool issue with unused static_cast")
; 229  :         static_cast<IUnknown*>(*pp);    // make sure everyone derives from IUnknown
; 230  :         return reinterpret_cast<void**>(pp);

	mov	eax, DWORD PTR _pp$[ebp]

; 231  :     }    

	pop	ebp
	ret	0
??$IID_PPV_ARGS_Helper@UIDXGIDevice1@@@@YAPAPAXPAPAUIDXGIDevice1@@@Z ENDP ; IID_PPV_ARGS_Helper<IDXGIDevice1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtr@UIDXGIDevice1@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComPtr@UIDXGIDevice1@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<IDXGIDevice1>::~CComPtr<IDXGIDevice1>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComPtr@UIDXGIDevice1@@@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@CComPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN4@CComPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComPtr@UIDXGIDevice1@@@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComPtr@UIDXGIDevice1@@@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComPtr@UIDXGIDevice1@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<IDXGIDevice1>::~CComPtr<IDXGIDevice1>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UIDXGIDevice1@@@ATL@@QAE@PAUIDXGIDevice1@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtr@UIDXGIDevice1@@@ATL@@QAE@PAUIDXGIDevice1@@@Z PROC ; ATL::CComPtr<IDXGIDevice1>::CComPtr<IDXGIDevice1>, COMDAT
; _this$ = ecx

; 312  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi

; 312  :     {

	mov	esi, ecx

; 162  :         p = lp;

	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN6@CComPtr

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN6@CComPtr:

; 313  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtr@UIDXGIDevice1@@@ATL@@QAE@PAUIDXGIDevice1@@@Z ENDP ; ATL::CComPtr<IDXGIDevice1>::CComPtr<IDXGIDevice1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??C?$CComPtrBase@UIDXGIDevice1@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIDXGIDevice1@@@1@XZ
_TEXT	SEGMENT
??C?$CComPtrBase@UIDXGIDevice1@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIDXGIDevice1@@@1@XZ PROC ; ATL::CComPtrBase<IDXGIDevice1>::operator->, COMDAT
; _this$ = ecx

; 197  :         ATLASSERT(p!=NULL);
; 198  :         return (_NoAddRefReleaseOnCComPtr<T>*)p;

	mov	eax, DWORD PTR [ecx]

; 199  :     }

	ret	0
??C?$CComPtrBase@UIDXGIDevice1@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIDXGIDevice1@@@1@XZ ENDP ; ATL::CComPtrBase<IDXGIDevice1>::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??I?$CComPtrBase@UIDXGIDevice1@@@ATL@@QAEPAPAUIDXGIDevice1@@XZ
_TEXT	SEGMENT
??I?$CComPtrBase@UIDXGIDevice1@@@ATL@@QAEPAPAUIDXGIDevice1@@XZ PROC ; ATL::CComPtrBase<IDXGIDevice1>::operator&, COMDAT
; _this$ = ecx

; 192  :         ATLASSERT(p==NULL);
; 193  :         return &p;

	mov	eax, ecx

; 194  :     }

	ret	0
??I?$CComPtrBase@UIDXGIDevice1@@@ATL@@QAEPAPAUIDXGIDevice1@@XZ ENDP ; ATL::CComPtrBase<IDXGIDevice1>::operator&
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UIDXGIDevice1@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UIDXGIDevice1@@@ATL@@QAE@XZ PROC	; ATL::CComPtrBase<IDXGIDevice1>::~CComPtrBase<IDXGIDevice1>, COMDAT
; _this$ = ecx

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN2@CComPtrBas

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@CComPtrBas:

; 178  :     }

	ret	0
??1?$CComPtrBase@UIDXGIDevice1@@@ATL@@QAE@XZ ENDP	; ATL::CComPtrBase<IDXGIDevice1>::~CComPtrBase<IDXGIDevice1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UIDXGIDevice1@@@ATL@@IAE@PAUIDXGIDevice1@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtrBase@UIDXGIDevice1@@@ATL@@IAE@PAUIDXGIDevice1@@@Z PROC ; ATL::CComPtrBase<IDXGIDevice1>::CComPtrBase<IDXGIDevice1>, COMDAT
; _this$ = ecx

; 160  :     CComPtrBase(_Inout_opt_ T* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp

; 161  :     {
; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN4@CComPtrBas

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN4@CComPtrBas:

; 165  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtrBase@UIDXGIDevice1@@@ATL@@IAE@PAUIDXGIDevice1@@@Z ENDP ; ATL::CComPtrBase<IDXGIDevice1>::CComPtrBase<IDXGIDevice1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
;	COMDAT ??$QueryInterface@UIDXGISwapChain2@@@IUnknown@@QAGJPAPAUIDXGISwapChain2@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pp$ = 12						; size = 4
??$QueryInterface@UIDXGISwapChain2@@@IUnknown@@QAGJPAPAUIDXGISwapChain2@@@Z PROC ; IUnknown::QueryInterface<IDXGISwapChain2>, COMDAT

; 130  :             {

	npad	2
	push	ebp
	mov	ebp, esp

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	mov	eax, DWORD PTR _this$[ebp]
	push	DWORD PTR _pp$[ebp]
	push	OFFSET __GUID_a8be2ac4_199f_4946_b331_79599fb98de7
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx]

; 132  :             }

	pop	ebp
	ret	8
??$QueryInterface@UIDXGISwapChain2@@@IUnknown@@QAGJPAPAUIDXGISwapChain2@@@Z ENDP ; IUnknown::QueryInterface<IDXGISwapChain2>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
;	COMDAT ?SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z
_TEXT	SEGMENT
_client$2 = -40						; size = 16
_pDevice1$3 = -24					; size = 4
_pSwapChain2$ = -20					; size = 4
_pDev$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pDevice$ = 8						; size = 4
_pDesc$ = 12						; size = 4
_ppSwapChain$ = 16					; size = 4
?SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z PROC ; SK_DXGI_CreateSwapChain_PostInit, COMDAT

; 3646 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH

; 3647 :   SK_RunOnce (SK_CEGUI_QueueResetD3D11 ());

	cmp	BYTE PTR ?first@?2??SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z@4_NA, 0 ; `SK_DXGI_CreateSwapChain_PostInit'::`3'::first
	je	SHORT $LN2@SK_DXGI_Cr
	call	?SK_CEGUI_QueueResetD3D11@@YAXXZ	; SK_CEGUI_QueueResetD3D11
	mov	BYTE PTR ?first@?2??SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z@4_NA, 0 ; `SK_DXGI_CreateSwapChain_PostInit'::`3'::first
$LN2@SK_DXGI_Cr:

; 3648 : 
; 3649 :   if (pDesc->BufferDesc.Width != 0)

	push	ebx
	push	esi
	mov	esi, DWORD PTR _pDesc$[ebp]
	push	edi
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN3@SK_DXGI_Cr

; 3650 :   {
; 3651 :     SK_SetWindowResX (pDesc->BufferDesc.Width);

	push	eax
	call	?SK_SetWindowResX@@YAXJ@Z		; SK_SetWindowResX

; 3652 :     SK_SetWindowResY (pDesc->BufferDesc.Height);

	push	DWORD PTR [esi+4]

; 3653 :   }
; 3654 : 
; 3655 :   else

	jmp	SHORT $LN76@SK_DXGI_Cr
$LN3@SK_DXGI_Cr:

; 3656 :   {
; 3657 :     RECT client;
; 3658 : 
; 3659 :     GetClientRect    (game_window.hWnd, &client);

	lea	eax, DWORD PTR _client$2[ebp]
	push	eax
	push	DWORD PTR ?game_window@@3Usk_window_s@@A+4
	call	DWORD PTR __imp__GetClientRect@8

; 3660 :     SK_SetWindowResX (client.right  - client.left);

	mov	eax, DWORD PTR _client$2[ebp+8]
	sub	eax, DWORD PTR _client$2[ebp]
	push	eax
	call	?SK_SetWindowResX@@YAXJ@Z		; SK_SetWindowResX

; 3661 :     SK_SetWindowResY (client.bottom - client.top);

	mov	eax, DWORD PTR _client$2[ebp+12]
	sub	eax, DWORD PTR _client$2[ebp+4]
	push	eax
$LN76@SK_DXGI_Cr:
	call	?SK_SetWindowResY@@YAXJ@Z		; SK_SetWindowResY

; 3662 :   }
; 3663 : 
; 3664 :   SK_RunOnce (SK_DXGI_HookSwapChain (*ppSwapChain));

	mov	edi, DWORD PTR _ppSwapChain$[ebp]
	add	esp, 8
	cmp	BYTE PTR ?first@?M@??SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z@4_NA, 0 ; `SK_DXGI_CreateSwapChain_PostInit'::`12'::first
	je	SHORT $LN5@SK_DXGI_Cr
	push	DWORD PTR [edi]
	call	?SK_DXGI_HookSwapChain@@YAXPAUIDXGISwapChain@@@Z ; SK_DXGI_HookSwapChain
	add	esp, 4
	mov	BYTE PTR ?first@?M@??SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z@4_NA, 0 ; `SK_DXGI_CreateSwapChain_PostInit'::`12'::first
$LN5@SK_DXGI_Cr:

; 3665 : 
; 3666 :   //if (bFlipMode || bWait)
; 3667 :     //DXGISwap_ResizeBuffers_Override (*ppSwapChain, config.render.framerate.buffer_count,
; 3668 :     //pDesc->BufferDesc.Width, pDesc->BufferDesc.Height, pDesc->BufferDesc.Format, pDesc->Flags);
; 3669 : 
; 3670 :   const uint32_t max_latency = config.render.framerate.pre_render_limit;

	mov	ebx, DWORD PTR ?config@@3Usk_config_t@@A+400
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pSwapChain2$[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3674 :   if ( bFlipMode && bWait &&

	cmp	BYTE PTR ?bFlipMode@@3_NA, 0		; bFlipMode
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	je	SHORT $LN72@SK_DXGI_Cr
	cmp	BYTE PTR ?bWait@@3_NA, 0		; bWait
	je	SHORT $LN72@SK_DXGI_Cr
	mov	eax, DWORD PTR [edi]
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	lea	edx, DWORD PTR _pSwapChain2$[ebp]
	push	edx
	push	OFFSET __GUID_a8be2ac4_199f_4946_b331_79599fb98de7
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3674 :   if ( bFlipMode && bWait &&

	test	eax, eax
	js	SHORT $LN72@SK_DXGI_Cr

; 3675 :        SUCCEEDED ( (*ppSwapChain)->QueryInterface <IDXGISwapChain2> (&pSwapChain2) )
; 3676 :       )
; 3677 :   {
; 3678 :     if (max_latency < 16)

	cmp	ebx, 16					; 00000010H
	jae	SHORT $LN7@SK_DXGI_Cr

; 3679 :     {
; 3680 :       dll_log.Log (L"[   DXGI   ] Setting Swapchain Frame Latency: %lu", max_latency);

	push	ebx
	push	OFFSET ??_C@_1GE@BOIALL@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAS?$AAw?$AAa?$AAp?$AAc?$AAh?$AAa?$AAi?$AAn?$AA?5?$AAF@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 3681 :       pSwapChain2->SetMaximumFrameLatency (max_latency);

	mov	eax, DWORD PTR _pSwapChain2$[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	push	ebx
	push	eax
	call	DWORD PTR [ecx+124]
$LN7@SK_DXGI_Cr:

; 3682 :     }
; 3683 : 
; 3684 :     HANDLE hWait =
; 3685 :       pSwapChain2->GetFrameLatencyWaitableObject ();

	mov	eax, DWORD PTR _pSwapChain2$[ebp]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+132]

; 3686 : 
; 3687 :     WaitForSingleObjectEx ( hWait,

	push	1
	push	500					; 000001f4H
	push	eax
	call	DWORD PTR __imp__WaitForSingleObjectEx@12
$LN72@SK_DXGI_Cr:

; 3688 :                               500,//config.render.framerate.swapchain_wait,
; 3689 :                                 TRUE );
; 3690 :   }
; 3691 : 
; 3692 :   {
; 3693 :     if (max_latency != -1)

	cmp	ebx, -1
	je	SHORT $LN73@SK_DXGI_Cr
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pDevice1$3[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3697 :       if (SUCCEEDED ( (*ppSwapChain)->GetDevice (

	mov	esi, DWORD PTR [edi]
	lea	eax, DWORD PTR _pDevice1$3[ebp]
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edi, DWORD PTR [esi]
	call	??$IID_PPV_ARGS_Helper@UIDXGIDevice1@@@@YAPAPAXPAPAUIDXGIDevice1@@@Z ; IID_PPV_ARGS_Helper<IDXGIDevice1>
	add	esp, 4
	push	eax
	push	OFFSET __GUID_77db970f_6276_48ba_ba28_070143b4392c
	push	esi
	call	DWORD PTR [edi+28]
	test	eax, eax
	js	SHORT $LN9@SK_DXGI_Cr

; 3698 :                          IID_PPV_ARGS (&pDevice1)
; 3699 :                       )
; 3700 :                     )
; 3701 :          )
; 3702 :       {
; 3703 :         dll_log.Log (L"[   DXGI   ] Setting Device Frame Latency: %lu", max_latency);

	push	ebx
	push	OFFSET ??_C@_1FO@CKMCMFKO@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AAS?$AAe?$AAt?$AAt?$AAi?$AAn?$AAg?$AA?5?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?5?$AAF?$AAr?$AAa?$AAm@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 3704 :         pDevice1->SetMaximumFrameLatency (max_latency);

	mov	eax, DWORD PTR _pDevice1$3[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	push	ebx
	push	eax
	call	DWORD PTR [ecx+48]
$LN9@SK_DXGI_Cr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	mov	eax, DWORD PTR _pDevice1$3[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3706 :     }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN74@SK_DXGI_Cr

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN74@SK_DXGI_Cr:
	mov	esi, DWORD PTR _pDesc$[ebp]
$LN73@SK_DXGI_Cr:

; 623  :         if (lp != NULL)

	mov	edx, DWORD PTR _pDevice$[ebp]

; 158  :         p = NULL;

	xor	ecx, ecx
	mov	DWORD PTR _pDev$[ebp], ecx

; 623  :         if (lp != NULL)

	test	edx, edx
	je	SHORT $LN45@SK_DXGI_Cr

; 624  :         {
; 625  :             if (FAILED(lp->QueryInterface(*piid, (void **)&this->p)))

	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR _pDev$[ebp]
	push	ecx
	push	OFFSET __GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140
	push	edx
	call	DWORD PTR [eax]
	mov	ecx, DWORD PTR _pDev$[ebp]
	xor	edx, edx
	test	eax, eax
	cmovs	ecx, edx
	mov	DWORD PTR _pDev$[ebp], ecx
$LN45@SK_DXGI_Cr:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3709 :   CComQIPtr <ID3D11Device> pDev (pDevice);

	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 214  :         return p == pT;

	test	ecx, ecx
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3711 :   if (pDev != nullptr)

	je	SHORT $LN10@SK_DXGI_Cr

; 3712 :   {
; 3713 :     g_pD3D11Dev = pDev;

	mov	DWORD PTR ?g_pD3D11Dev@@3PAUID3D11Device@@A, ecx ; g_pD3D11Dev

; 3714 : 
; 3715 :     SK_GetCurrentRenderBackend ().fullscreen_exclusive = (! pDesc->Windowed);

	cmp	DWORD PTR [esi+48], 0
	sete	bl
	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend
	mov	BYTE PTR [eax+48], bl
	mov	ecx, DWORD PTR _pDev$[ebp]
$LN10@SK_DXGI_Cr:

; 3717 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	ecx, ecx
	je	SHORT $LN64@SK_DXGI_Cr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN64@SK_DXGI_Cr:

; 176  :         if (p)

	mov	eax, DWORD PTR _pSwapChain2$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3717 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN70@SK_DXGI_Cr

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN70@SK_DXGI_Cr:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3717 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z$0:
	lea	ecx, DWORD PTR _pSwapChain2$[ebp]
	jmp	??1?$CComPtr@UIDXGISwapChain2@@@ATL@@QAE@XZ
__unwindfunclet$?SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z$1:
	lea	ecx, DWORD PTR _pDevice1$3[ebp]
	jmp	??1?$CComPtr@UIDXGIDevice1@@@ATL@@QAE@XZ
__unwindfunclet$?SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z$2:
	lea	ecx, DWORD PTR _pDev$[ebp]
	jmp	??1?$CComQIPtr@UID3D11Device@@$1?_GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140@@3U__s_GUID@@B@ATL@@QAE@XZ
__ehhandler$?SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_DXGI_CreateSwapChain_PostInit@@YAXPAUIUnknown@@PAUDXGI_SWAP_CHAIN_DESC@@PAPAUIDXGISwapChain@@@Z ENDP ; SK_DXGI_CreateSwapChain_PostInit
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_pOutput$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pSwapChain$ = 8					; size = 4
?SK_DXGI_HookSwapChain@@YAXPAUIDXGISwapChain@@@Z PROC	; SK_DXGI_HookSwapChain

; 4931 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SK_DXGI_HookSwapChain@@YAXPAUIDXGISwapChain@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h

; 9003 :     return (unsigned long) _InterlockedCompareExchange((volatile long*) Destination, (long) Exchange, (long) Comperand);

	mov	ecx, 1
	mov	edx, OFFSET ?init@?1??SK_DXGI_HookSwapChain@@YAXPAUIDXGISwapChain@@@Z@4KC
	xor	eax, eax
	lock	 cmpxchg DWORD PTR [edx], ecx
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4934 :   if (InterlockedCompareExchange (&init, TRUE, FALSE))

	test	eax, eax
	jne	$LN30@SK_DXGI_Ho

; 4935 :     return;
; 4936 : 
; 4937 :   DXGI_VIRTUAL_HOOK ( &pSwapChain, 10, "IDXGISwapChain::SetFullscreenState",

	push	esi
	mov	esi, DWORD PTR _pSwapChain$[ebp]
	push	OFFSET ?SetFullscreenState_Original@@3P6GJPAUIDXGISwapChain@@HPAUIDXGIOutput@@@ZA ; SetFullscreenState_Original
	push	OFFSET ?DXGISwap_SetFullscreenState_Override@@YGJPAUIDXGISwapChain@@HPAUIDXGIOutput@@@Z ; DXGISwap_SetFullscreenState_Override
	push	10					; 0000000aH
	push	DWORD PTR [esi]
	push	OFFSET $SG366236
	call	?SK_CreateVFTableHook2@@YG?AW4MH_STATUS@@PB_WPAPAXKPAX1@Z ; SK_CreateVFTableHook2

; 4938 :                             DXGISwap_SetFullscreenState_Override,
; 4939 :                                      SetFullscreenState_Original,
; 4940 :                                        SetFullscreenState_pfn );
; 4941 : 
; 4942 :   DXGI_VIRTUAL_HOOK ( &pSwapChain, 11, "IDXGISwapChain::GetFullscreenState",

	push	OFFSET ?GetFullscreenState_Original@@3P6GJPAUIDXGISwapChain@@PAHPAPAUIDXGIOutput@@@ZA ; GetFullscreenState_Original
	push	OFFSET ?DXGISwap_GetFullscreenState_Override@@YGJPAUIDXGISwapChain@@PAHPAPAUIDXGIOutput@@@Z ; DXGISwap_GetFullscreenState_Override
	push	11					; 0000000bH
	push	DWORD PTR [esi]
	push	OFFSET $SG366237
	call	?SK_CreateVFTableHook2@@YG?AW4MH_STATUS@@PB_WPAPAXKPAX1@Z ; SK_CreateVFTableHook2

; 4943 :                             DXGISwap_GetFullscreenState_Override,
; 4944 :                                      GetFullscreenState_Original,
; 4945 :                                        GetFullscreenState_pfn );
; 4946 : 
; 4947 :   DXGI_VIRTUAL_HOOK ( &pSwapChain, 13, "IDXGISwapChain::ResizeBuffers",

	push	OFFSET ?ResizeBuffers_Original@@3P6GJPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@ZA ; ResizeBuffers_Original
	push	OFFSET ?DXGISwap_ResizeBuffers_Override@@YGJPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z ; DXGISwap_ResizeBuffers_Override
	push	13					; 0000000dH
	push	DWORD PTR [esi]
	push	OFFSET $SG366238
	call	?SK_CreateVFTableHook2@@YG?AW4MH_STATUS@@PB_WPAPAXKPAX1@Z ; SK_CreateVFTableHook2

; 4948 :                            DXGISwap_ResizeBuffers_Override,
; 4949 :                                     ResizeBuffers_Original,
; 4950 :                                       ResizeBuffers_pfn );
; 4951 : 
; 4952 :   DXGI_VIRTUAL_HOOK ( &pSwapChain, 14, "IDXGISwapChain::ResizeTarget",

	push	OFFSET ?ResizeTarget_Original@@3P6GJPAUIDXGISwapChain@@PBUDXGI_MODE_DESC@@@ZA ; ResizeTarget_Original
	push	OFFSET ?DXGISwap_ResizeTarget_Override@@YGJPAUIDXGISwapChain@@PBUDXGI_MODE_DESC@@@Z ; DXGISwap_ResizeTarget_Override
	push	14					; 0000000eH
	push	DWORD PTR [esi]
	push	OFFSET $SG366239
	call	?SK_CreateVFTableHook2@@YG?AW4MH_STATUS@@PB_WPAPAXKPAX1@Z ; SK_CreateVFTableHook2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pOutput$[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4959 :   if (SUCCEEDED (pSwapChain->GetContainingOutput (&pOutput)))

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _pOutput$[ebp]
	push	ecx
	push	esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	DWORD PTR [eax+60]
	test	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 214  :         return p == pT;

	mov	eax, DWORD PTR _pOutput$[ebp]
	pop	esi
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4959 :   if (SUCCEEDED (pSwapChain->GetContainingOutput (&pOutput)))

	js	SHORT $LN4@SK_DXGI_Ho
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 214  :         return p == pT;

	test	eax, eax
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4961 :     if (pOutput != nullptr)

	je	SHORT $LN4@SK_DXGI_Ho

; 4962 :     {
; 4963 :       DXGI_VIRTUAL_HOOK ( &pOutput, 8, "IDXGIOutput::GetDisplayModeList",

	push	OFFSET ?GetDisplayModeList_Original@@3P6GJPAUIDXGIOutput@@W4DXGI_FORMAT@@IPAIPAUDXGI_MODE_DESC@@@ZA ; GetDisplayModeList_Original
	push	OFFSET ?DXGIOutput_GetDisplayModeList_Override@@YGJPAUIDXGIOutput@@W4DXGI_FORMAT@@IPAIPAUDXGI_MODE_DESC@@@Z ; DXGIOutput_GetDisplayModeList_Override
	push	8
	push	DWORD PTR [eax]
	push	OFFSET $SG366242
	call	?SK_CreateVFTableHook2@@YG?AW4MH_STATUS@@PB_WPAPAXKPAX1@Z ; SK_CreateVFTableHook2

; 4964 :                                 DXGIOutput_GetDisplayModeList_Override,
; 4965 :                                            GetDisplayModeList_Original,
; 4966 :                                            GetDisplayModeList_pfn );
; 4967 : 
; 4968 :       DXGI_VIRTUAL_HOOK ( &pOutput, 9, "IDXGIOutput::FindClosestMatchingMode",

	mov	eax, DWORD PTR _pOutput$[ebp]
	push	OFFSET ?FindClosestMatchingMode_Original@@3P6GJPAUIDXGIOutput@@PBUDXGI_MODE_DESC@@PAU2@PAUIUnknown@@@ZA ; FindClosestMatchingMode_Original
	push	OFFSET ?DXGIOutput_FindClosestMatchingMode_Override@@YGJPAUIDXGIOutput@@PBUDXGI_MODE_DESC@@PAU2@PAUIUnknown@@@Z ; DXGIOutput_FindClosestMatchingMode_Override
	push	9
	push	DWORD PTR [eax]
	push	OFFSET $SG366243
	call	?SK_CreateVFTableHook2@@YG?AW4MH_STATUS@@PB_WPAPAXKPAX1@Z ; SK_CreateVFTableHook2

; 4969 :                                 DXGIOutput_FindClosestMatchingMode_Override,
; 4970 :                                            FindClosestMatchingMode_Original,
; 4971 :                                            FindClosestMatchingMode_pfn );
; 4972 : 
; 4973 :       DXGI_VIRTUAL_HOOK ( &pOutput, 10, "IDXGIOutput::WaitForVBlank",

	mov	eax, DWORD PTR _pOutput$[ebp]
	push	OFFSET ?WaitForVBlank_Original@@3P6GJPAUIDXGIOutput@@@ZA ; WaitForVBlank_Original
	push	OFFSET ?DXGIOutput_WaitForVBlank_Override@@YGJPAUIDXGIOutput@@@Z ; DXGIOutput_WaitForVBlank_Override
	push	10					; 0000000aH
	push	DWORD PTR [eax]
	push	OFFSET $SG366244
	call	?SK_CreateVFTableHook2@@YG?AW4MH_STATUS@@PB_WPAPAXKPAX1@Z ; SK_CreateVFTableHook2
	mov	eax, DWORD PTR _pOutput$[ebp]
$LN4@SK_DXGI_Ho:

; 4979 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN30@SK_DXGI_Ho

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN30@SK_DXGI_Ho:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4979 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_DXGI_HookSwapChain@@YAXPAUIDXGISwapChain@@@Z$0:
	lea	ecx, DWORD PTR _pOutput$[ebp]
	jmp	??1?$CComPtr@UIDXGIOutput@@@ATL@@QAE@XZ
__ehhandler$?SK_DXGI_HookSwapChain@@YAXPAUIDXGISwapChain@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?SK_DXGI_HookSwapChain@@YAXPAUIDXGISwapChain@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_DXGI_HookSwapChain@@YAXPAUIDXGISwapChain@@@Z ENDP	; SK_DXGI_HookSwapChain
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3742 : 	{	// return larger of _Left and _Right

	npad	2
	push	ebp
	mov	ebp, esp

; 3743 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	cmovl	eax, ecx

; 3744 : 	}

	pop	ebp
	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
;	COMDAT ?SK_DXGI_CreateSwapChain_PreInit@@YAXPAUDXGI_SWAP_CHAIN_DESC@@PAUDXGI_SWAP_CHAIN_DESC1@@AAPAUHWND__@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@@Z
_TEXT	SEGMENT
_stub_desc$ = -64					; size = 60
_translated$1$ = -1					; size = 1
tv971 = 8						; size = 4
tv868 = 8						; size = 4
tv866 = 8						; size = 4
_pDesc$ = 8						; size = 4
_pDesc1$ = 12						; size = 4
_hWnd$ = 16						; size = 4
_pFullscreenDesc$ = 20					; size = 4
?SK_DXGI_CreateSwapChain_PreInit@@YAXPAUDXGI_SWAP_CHAIN_DESC@@PAUDXGI_SWAP_CHAIN_DESC1@@AAPAUHWND__@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@@Z PROC ; SK_DXGI_CreateSwapChain_PreInit, COMDAT

; 3294 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 3295 :   WaitForInit ();

	call	?WaitForInitDXGI@@YAXXZ			; WaitForInitDXGI
	call	?WaitForInit@@YAXXZ			; WaitForInit

; 3296 : 
; 3297 :   DXGI_SWAP_CHAIN_DESC stub_desc  = {   }; // Stores common attributes between DESC and DESC1

	push	60					; 0000003cH
	lea	eax, DWORD PTR _stub_desc$[ebp]
	push	0
	push	eax
	call	_memset

; 3298 :   bool                 translated = false;
; 3299 : 
; 3300 :   if (pDesc1 != nullptr)

	mov	edi, DWORD PTR _pDesc1$[ebp]
	add	esp, 12					; 0000000cH
	mov	ebx, DWORD PTR _pFullscreenDesc$[ebp]

; 3301 :   {
; 3302 :     if (pDesc == nullptr)

	mov	esi, DWORD PTR _pDesc$[ebp]
	mov	BYTE PTR _translated$1$[ebp], 0
	test	edi, edi
	je	SHORT $LN5@SK_DXGI_Cr
	test	esi, esi
	jne	SHORT $LN100@SK_DXGI_Cr

; 3303 :     {
; 3304 :       pDesc = &stub_desc;
; 3305 : 
; 3306 :       stub_desc.BufferCount                        = pDesc1->BufferCount;

	mov	eax, DWORD PTR [edi+28]
	lea	esi, DWORD PTR _stub_desc$[ebp]
	mov	DWORD PTR _stub_desc$[ebp+40], eax

; 3307 :       stub_desc.BufferUsage                        = pDesc1->BufferUsage;

	mov	eax, DWORD PTR [edi+24]
	mov	DWORD PTR _stub_desc$[ebp+36], eax

; 3308 :       stub_desc.Flags                              = pDesc1->Flags;

	mov	eax, DWORD PTR [edi+44]
	mov	DWORD PTR _stub_desc$[ebp+56], eax

; 3309 :       stub_desc.SwapEffect                         = pDesc1->SwapEffect;

	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR _stub_desc$[ebp+52], eax

; 3310 :       stub_desc.SampleDesc.Count                   = pDesc1->SampleDesc.Count;

	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR _stub_desc$[ebp+28], eax

; 3311 :       stub_desc.SampleDesc.Quality                 = pDesc1->SampleDesc.Quality;

	mov	eax, DWORD PTR [edi+20]
	mov	DWORD PTR _stub_desc$[ebp+32], eax

; 3312 :       stub_desc.BufferDesc.Format                  = pDesc1->Format;

	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR _stub_desc$[ebp+16], eax

; 3313 :       stub_desc.BufferDesc.Height                  = pDesc1->Height;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR _stub_desc$[ebp+4], eax

; 3314 :       stub_desc.BufferDesc.Width                   = pDesc1->Width;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR _stub_desc$[ebp], eax

; 3315 :       stub_desc.OutputWindow                       = hWnd;

	mov	eax, DWORD PTR _hWnd$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _stub_desc$[ebp+44], eax

; 3316 : 
; 3317 :       if (pFullscreenDesc != nullptr)

	test	ebx, ebx
	je	SHORT $LN6@SK_DXGI_Cr

; 3318 :       {
; 3319 :         stub_desc.Windowed                           = pFullscreenDesc->Windowed;

	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR _stub_desc$[ebp+48], eax

; 3320 :         stub_desc.BufferDesc.RefreshRate.Denominator = pFullscreenDesc->RefreshRate.Denominator;

	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR _stub_desc$[ebp+12], eax

; 3321 :         stub_desc.BufferDesc.RefreshRate.Numerator   = pFullscreenDesc->RefreshRate.Numerator;

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR _stub_desc$[ebp+8], eax

; 3322 :         stub_desc.BufferDesc.Scaling                 = pFullscreenDesc->Scaling;

	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR _stub_desc$[ebp+24], eax

; 3323 :         stub_desc.BufferDesc.ScanlineOrdering        = pFullscreenDesc->ScanlineOrdering;

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR _stub_desc$[ebp+20], eax

; 3329 :       }
; 3330 : 
; 3331 :       // Need to take this stuff and put it back in the appropriate structures before returning :)
; 3332 :       translated = true;

	mov	BYTE PTR _translated$1$[ebp], 1

; 3333 :     }
; 3334 :   }
; 3335 : 
; 3336 :   if (pDesc != nullptr)

	jmp	SHORT $LN100@SK_DXGI_Cr
$LN6@SK_DXGI_Cr:

; 3324 :       }
; 3325 : 
; 3326 :       else
; 3327 :       {
; 3328 :         stub_desc.Windowed = TRUE;

	mov	DWORD PTR _stub_desc$[ebp+48], 1

; 3329 :       }
; 3330 : 
; 3331 :       // Need to take this stuff and put it back in the appropriate structures before returning :)
; 3332 :       translated = true;

	mov	BYTE PTR _translated$1$[ebp], 1

; 3333 :     }
; 3334 :   }
; 3335 : 
; 3336 :   if (pDesc != nullptr)

	jmp	SHORT $LN100@SK_DXGI_Cr
$LN5@SK_DXGI_Cr:
	test	esi, esi
	je	$LN117@SK_DXGI_Cr
$LN100@SK_DXGI_Cr:

; 3338 :     dll_log.LogEx ( true,

	mov	eax, DWORD PTR [esi+52]
	test	eax, eax
	jne	SHORT $LN51@SK_DXGI_Cr
	mov	ecx, OFFSET ??_C@_1BA@EMGLPOHC@?$AAD?$AAi?$AAs?$AAc?$AAa?$AAr?$AAd?$AA?$AA@
	jmp	SHORT $LN46@SK_DXGI_Cr
$LN51@SK_DXGI_Cr:
	cmp	eax, 1
	jne	SHORT $LN49@SK_DXGI_Cr
	mov	ecx, OFFSET ??_C@_1BG@MBNPLCBJ@?$AAS?$AAe?$AAq?$AAu?$AAe?$AAn?$AAt?$AAi?$AAa?$AAl?$AA?$AA@
	jmp	SHORT $LN46@SK_DXGI_Cr
$LN49@SK_DXGI_Cr:
	cmp	eax, 2
	jne	SHORT $LN47@SK_DXGI_Cr
	mov	ecx, OFFSET ??_C@_1BE@BGMELJBK@?$AA?$DM?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?$DO?$AA?$AA@
	jmp	SHORT $LN46@SK_DXGI_Cr
$LN47@SK_DXGI_Cr:
	cmp	eax, 3
	jne	SHORT $LN45@SK_DXGI_Cr
	mov	ecx, OFFSET ??_C@_1CA@DEGLGFCG@?$AAF?$AAl?$AAi?$AAp?$AA?5?$AAS?$AAe?$AAq?$AAu?$AAe?$AAn?$AAt?$AAi?$AAa?$AAl?$AA?$AA@
	jmp	SHORT $LN46@SK_DXGI_Cr
$LN45@SK_DXGI_Cr:
	cmp	eax, 4
	mov	ecx, OFFSET ??_C@_1BK@OJAHAHGF@?$AAF?$AAl?$AAi?$AAp?$AA?5?$AAD?$AAi?$AAs?$AAc?$AAa?$AAr?$AAd?$AA?$AA@
	mov	edx, OFFSET ??_C@_1BE@BGMELJBK@?$AA?$DM?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?$DO?$AA?$AA@
	cmovne	ecx, edx
$LN46@SK_DXGI_Cr:
	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	jne	SHORT $LN55@SK_DXGI_Cr
	mov	edx, OFFSET ??_C@_1BI@DELFJJPB@?$AAU?$AAn?$AAs?$AAp?$AAe?$AAc?$AAi?$AAf?$AAi?$AAe?$AAd?$AA?$AA@
	jmp	SHORT $LN54@SK_DXGI_Cr
$LN55@SK_DXGI_Cr:
	cmp	eax, 1
	jne	SHORT $LN53@SK_DXGI_Cr
	mov	edx, OFFSET ??_C@_1BI@JFLEIIEG@?$AAP?$AAr?$AAo?$AAg?$AAr?$AAe?$AAs?$AAs?$AAi?$AAv?$AAe?$AA?$AA@
	jmp	SHORT $LN54@SK_DXGI_Cr
$LN53@SK_DXGI_Cr:
	cmp	eax, 2
	mov	DWORD PTR tv866[ebp], OFFSET ??_C@_1BO@NBKANNIC@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAl?$AAa?$AAc?$AAe?$AAd?$AA?5?$AAO?$AAd?$AAd?$AA?$AA@
	mov	edx, OFFSET ??_C@_1CA@MIMOHAAK@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAl?$AAa?$AAc?$AAe?$AAd?$AA?5?$AAE?$AAv?$AAe?$AAn?$AA?$AA@
	cmovne	edx, DWORD PTR tv866[ebp]
$LN54@SK_DXGI_Cr:
	cmp	DWORD PTR [esi+24], 0
	jne	SHORT $LN57@SK_DXGI_Cr
	mov	DWORD PTR tv971[ebp], OFFSET ??_C@_1BI@DELFJJPB@?$AAU?$AAn?$AAs?$AAp?$AAe?$AAc?$AAi?$AAf?$AAi?$AAe?$AAd?$AA?$AA@
	jmp	SHORT $LN58@SK_DXGI_Cr
$LN57@SK_DXGI_Cr:
	cmp	DWORD PTR [esi+24], 1
	mov	eax, OFFSET ??_C@_1BC@NODLAKGH@?$AAC?$AAe?$AAn?$AAt?$AAe?$AAr?$AAe?$AAd?$AA?$AA@
	mov	DWORD PTR tv868[ebp], OFFSET ??_C@_1BE@OKCKFGLA@?$AAS?$AAt?$AAr?$AAe?$AAt?$AAc?$AAh?$AAe?$AAd?$AA?$AA@
	cmovne	eax, DWORD PTR tv868[ebp]
	mov	DWORD PTR tv971[ebp], eax
$LN58@SK_DXGI_Cr:
	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN59@SK_DXGI_Cr
	mov	eax, DWORD PTR [esi+8]
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	eax, DWORD PTR [esi+12]
	cvtpd2ps xmm1, xmm0
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	divss	xmm1, xmm0
	jmp	SHORT $LN68@SK_DXGI_Cr
$LN59@SK_DXGI_Cr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits

; 1119 : 		return (__builtin_nanf("0"));

	movss	xmm1, DWORD PTR __real@7fc00000
$LN68@SK_DXGI_Cr:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3338 :     dll_log.LogEx ( true,

	cmp	DWORD PTR [esi+48], 0
	mov	eax, OFFSET ??_C@_1BC@PMICBOA@?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAe?$AAd?$AA?$AA@
	push	ecx
	push	DWORD PTR [esi+56]
	mov	ecx, OFFSET ??_C@_1BG@EOMFJOKP@?$AAF?$AAu?$AAl?$AAl?$AAs?$AAc?$AAr?$AAe?$AAe?$AAn?$AA?$AA@
	push	DWORD PTR [esi+40]
	cmove	eax, ecx
	push	eax
	push	edx
	push	DWORD PTR tv971[ebp]
	cvtps2pd xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi]
	push	OFFSET ??_C@_1BAE@FEHGBMOO@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AAS?$AAw?$AAa?$AAp?$AAC?$AAh?$AAa?$AAi?$AAn?$AA?3?$AA?5?$AA?$CI?$AA?$CF?$AAl?$AAu?$AAx?$AA?$CF?$AAl@
	push	1
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	add	esp, 52					; 00000034H

; 3339 :       L"[   DXGI   ]  SwapChain: (%lux%lu @ %4.1f Hz - Scaling: %s - Scanlines: %s) - {%s}"
; 3340 :       L" [%lu Buffers] :: Flags=0x%04X, SwapEffect: %s\n",
; 3341 :       pDesc->BufferDesc.Width,
; 3342 :       pDesc->BufferDesc.Height,
; 3343 :       pDesc->BufferDesc.RefreshRate.Denominator != 0 ?
; 3344 :         static_cast <float> (pDesc->BufferDesc.RefreshRate.Numerator) /
; 3345 :         static_cast <float> (pDesc->BufferDesc.RefreshRate.Denominator) :
; 3346 :           std::numeric_limits <float>::quiet_NaN (),
; 3347 :       pDesc->BufferDesc.Scaling == DXGI_MODE_SCALING_UNSPECIFIED ?
; 3348 :         L"Unspecified" :
; 3349 :         pDesc->BufferDesc.Scaling == DXGI_MODE_SCALING_CENTERED ?
; 3350 :           L"Centered" :
; 3351 :           L"Stretched",
; 3352 :       pDesc->BufferDesc.ScanlineOrdering == DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED ?
; 3353 :         L"Unspecified" :
; 3354 :         pDesc->BufferDesc.ScanlineOrdering == DXGI_MODE_SCANLINE_ORDER_PROGRESSIVE ?
; 3355 :           L"Progressive" :
; 3356 :           pDesc->BufferDesc.ScanlineOrdering == DXGI_MODE_SCANLINE_ORDER_UPPER_FIELD_FIRST ?
; 3357 :             L"Interlaced Even" :
; 3358 :             L"Interlaced Odd",
; 3359 :       pDesc->Windowed ? L"Windowed" : L"Fullscreen",
; 3360 :       pDesc->BufferCount,
; 3361 :       pDesc->Flags,
; 3362 :       pDesc->SwapEffect         == 0 ?
; 3363 :         L"Discard" :
; 3364 :         pDesc->SwapEffect       == 1 ?
; 3365 :           L"Sequential" :
; 3366 :           pDesc->SwapEffect     == 2 ?
; 3367 :             L"<Unknown>" :
; 3368 :             pDesc->SwapEffect   == 3 ?
; 3369 :               L"Flip Sequential" :
; 3370 :               pDesc->SwapEffect == 4 ?
; 3371 :                 L"Flip Discard" :
; 3372 :                 L"<Unknown>" );
; 3373 : 
; 3374 :     // Set things up to make the swap chain Alt+Enter friendly
; 3375 :     if (bAlwaysAllowFullscreen && pDesc->Windowed)

	cmp	BYTE PTR ?bAlwaysAllowFullscreen@@3_NA, 0 ; bAlwaysAllowFullscreen
	je	SHORT $LN9@SK_DXGI_Cr
	cmp	DWORD PTR [esi+48], 0
	je	SHORT $LN11@SK_DXGI_Cr

; 3376 :     {
; 3377 :       pDesc->Flags                             |= DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

	or	DWORD PTR [esi+56], 2

; 3378 :       pDesc->Windowed                           = true;

	mov	DWORD PTR [esi+48], 1

; 3379 :       pDesc->BufferDesc.RefreshRate.Denominator = 0;

	mov	DWORD PTR [esi+12], 0

; 3380 :       pDesc->BufferDesc.RefreshRate.Numerator   = 0;

	mov	DWORD PTR [esi+8], 0
$LN9@SK_DXGI_Cr:

; 3381 :     }
; 3382 : 
; 3383 :     if (pDesc->Windowed && config.window.borderless && (! config.window.fullscreen))

	cmp	DWORD PTR [esi+48], 0
	je	SHORT $LN11@SK_DXGI_Cr
	cmp	BYTE PTR ?config@@3Usk_config_t@@A+728, 0
	je	SHORT $LN11@SK_DXGI_Cr
	cmp	BYTE PTR ?config@@3Usk_config_t@@A+754, 0
	jne	SHORT $LN11@SK_DXGI_Cr
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 425  :         bool isZero (void) { return x == 0 && y == 0; };

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+756
	test	eax, eax
	jne	SHORT $LN72@SK_DXGI_Cr
	cmp	DWORD PTR ?config@@3Usk_config_t@@A+760, eax
	je	SHORT $LN13@SK_DXGI_Cr
$LN72@SK_DXGI_Cr:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3387 :         pDesc->BufferDesc.Width  = config.window.res.override.x;

	mov	DWORD PTR [esi], eax

; 3388 :         pDesc->BufferDesc.Height = config.window.res.override.y;

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+760
	mov	DWORD PTR [esi+4], eax
$LN11@SK_DXGI_Cr:
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 425  :         bool isZero (void) { return x == 0 && y == 0; };

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+756
	test	eax, eax
	jne	SHORT $LN76@SK_DXGI_Cr
	cmp	DWORD PTR ?config@@3Usk_config_t@@A+760, eax
	je	SHORT $LN13@SK_DXGI_Cr
$LN76@SK_DXGI_Cr:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3403 :       pDesc->BufferDesc.Width  = config.window.res.override.x;

	mov	DWORD PTR [esi], eax

; 3404 :       pDesc->BufferDesc.Height = config.window.res.override.y;

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+760
	mov	DWORD PTR [esi+4], eax
$LN13@SK_DXGI_Cr:

; 3405 :     }
; 3406 : 
; 3407 : 
; 3408 :     if (config.render.dxgi.safe_fullscreen)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+488, 0
	je	SHORT $LN14@SK_DXGI_Cr

; 3409 :       pDesc->Flags |= DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

	or	DWORD PTR [esi+56], 2
$LN14@SK_DXGI_Cr:

; 3410 : 
; 3411 :     if (request_mode_change == mode_change_request_e::Fullscreen)

	cmp	DWORD PTR ?request_mode_change@@3W4mode_change_request_e@@A, 1 ; request_mode_change
	jne	SHORT $LN15@SK_DXGI_Cr

; 3412 :     {
; 3413 :       dll_log.Log ( L"[   DXGI   ]  >> User-Requested Mode Change: Fullscreen" );

	push	OFFSET ??_C@_1HA@INGGDHHB@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAU?$AAs?$AAe?$AAr?$AA?9?$AAR?$AAe?$AAq?$AAu?$AAe?$AAs?$AAt?$AAe?$AAd?$AA?5@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8

; 3414 :       pDesc->Windowed = FALSE;

	mov	DWORD PTR [esi+48], 0

; 3415 :       pDesc->Flags   |= DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

	or	DWORD PTR [esi+56], 2
$LN15@SK_DXGI_Cr:

; 3416 :     }
; 3417 : 
; 3418 :     if (config.display.force_fullscreen && pDesc->Windowed)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+500, 0
	je	SHORT $LN16@SK_DXGI_Cr
	cmp	DWORD PTR [esi+48], 0
	je	SHORT $LN16@SK_DXGI_Cr

; 3419 :     {
; 3420 :       dll_log.Log ( L"[   DXGI   ]  >> Display Override "

	push	OFFSET ??_C@_1JG@HCAIICBG@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAD?$AAi?$AAs?$AAp?$AAl?$AAa?$AAy?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8

; 3421 :                     L"(Requested: Windowed, Using: Fullscreen)" );
; 3422 :       pDesc->Flags   |= DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
; 3423 :       pDesc->Windowed = FALSE;

	mov	DWORD PTR [esi+48], 0
	or	DWORD PTR [esi+56], 2
	jmp	SHORT $LN18@SK_DXGI_Cr
$LN16@SK_DXGI_Cr:

; 3424 :     }
; 3425 : 
; 3426 :     else if (config.display.force_windowed)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+501, 0
	je	SHORT $LN18@SK_DXGI_Cr

; 3427 :     {
; 3428 :       dll_log.Log ( L"[   DXGI   ]  >> Display Override "

	push	OFFSET ??_C@_1JG@LPALCGFK@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAD?$AAi?$AAs?$AAp?$AAl?$AAa?$AAy?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8

; 3429 :                     L"(Requested: Fullscreen, Using: Windowed)" );
; 3430 :       pDesc->Windowed = TRUE;

	mov	DWORD PTR [esi+48], 1
$LN18@SK_DXGI_Cr:

; 3431 :     }
; 3432 : 
; 3433 : #ifdef _WIN64
; 3434 :     if (! bFlipMode)
; 3435 :       bFlipMode =
; 3436 :         ( dxgi_caps.present.flip_sequential && (
; 3437 :           ( ! lstrcmpW (SK_GetHostApp (), L"Fallout4.exe")) ||
; 3438 :             SK_DS3_UseFlipMode ()        ) );
; 3439 : 
; 3440 :     if (! lstrcmpW (SK_GetHostApp (), L"Fallout4.exe"))
; 3441 :     {
; 3442 :       if (bFlipMode)
; 3443 :           bFlipMode = (! SK_FO4_IsFullscreen ()) && SK_FO4_UseFlipMode ();
; 3444 :     }
; 3445 : 
; 3446 :     else
; 3447 : #endif
; 3448 :     {
; 3449 :       // If forcing flip-model, then force multisampling off
; 3450 :       if (config.render.framerate.flip_discard)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+416, 0
	je	SHORT $LN116@SK_DXGI_Cr

; 3451 :       {
; 3452 :         bFlipMode = dxgi_caps.present.flip_sequential;

	mov	al, BYTE PTR ?dxgi_caps@@3Udxgi_caps_t@@A+2
	mov	BYTE PTR ?bFlipMode@@3_NA, al		; bFlipMode

; 3453 :         pDesc->SampleDesc.Count = 1; pDesc->SampleDesc.Quality = 0;
; 3454 : 
; 3455 :         // Format overrides must be performed in certain cases (sRGB / 10:10:10:2)
; 3456 :         switch (pDesc->BufferDesc.Format)

	mov	eax, DWORD PTR [esi+16]
	add	eax, -23				; ffffffe9H
	mov	DWORD PTR [esi+28], 1
	mov	DWORD PTR [esi+32], 0
	cmp	eax, 68					; 00000044H
	ja	SHORT $LN116@SK_DXGI_Cr
	movzx	eax, BYTE PTR $LN115@SK_DXGI_Cr[eax]
	jmp	DWORD PTR $LN125@SK_DXGI_Cr[eax*4]
$LN20@SK_DXGI_Cr:

; 3457 :         {
; 3458 :           case DXGI_FORMAT_B8G8R8A8_UNORM_SRGB:
; 3459 :             pDesc->BufferDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;

	mov	DWORD PTR [esi+16], 87			; 00000057H

; 3460 :             dll_log.Log ( L"[ DXGI 1.2 ]  >> sRGB (B8G8R8A8) Override Required to Enable Flip Model" );

	push	OFFSET ??_C@_1JA@NDGFBELE@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA2?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAs?$AAR?$AAG?$AAB?$AA?5?$AA?$CI?$AAB?$AA8?$AAG?$AA8?$AAR?$AA8?$AAA?$AA8?$AA?$CJ@

; 3461 :             break;

	jmp	SHORT $LN120@SK_DXGI_Cr
$LN21@SK_DXGI_Cr:

; 3462 :           case DXGI_FORMAT_R8G8B8A8_UNORM_SRGB:
; 3463 :             pDesc->BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
; 3464 :             dll_log.Log ( L"[ DXGI 1.2 ]  >> sRGB (R8G8B8A8) Override Required to Enable Flip Model" );

	push	OFFSET ??_C@_1JA@CCHCBLHJ@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA2?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAs?$AAR?$AAG?$AAB?$AA?5?$AA?$CI?$AAR?$AA8?$AAG?$AA8?$AAB?$AA8?$AAA?$AA8?$AA?$CJ@

; 3465 :             break;

	jmp	SHORT $LN121@SK_DXGI_Cr
$LN22@SK_DXGI_Cr:

; 3469 :             dll_log.Log ( L"[ DXGI 1.2 ]  >> RGBA 10:10:10:2 Override (to 8:8:8:8) Required to Enable Flip Model" );

	push	OFFSET ??_C@_1KK@LPPCBMFA@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA2?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAR?$AAG?$AAB?$AAA?$AA?5?$AA1?$AA0?$AA?3?$AA1?$AA0?$AA?3?$AA1?$AA0?$AA?3?$AA2@
$LN121@SK_DXGI_Cr:

; 3466 :           case DXGI_FORMAT_R10G10B10A2_UNORM:
; 3467 :           case DXGI_FORMAT_R10G10B10A2_TYPELESS:
; 3468 :             pDesc->BufferDesc.Format =  DXGI_FORMAT_R8G8B8A8_UNORM;

	mov	DWORD PTR [esi+16], 28			; 0000001cH
$LN120@SK_DXGI_Cr:

; 3469 :             dll_log.Log ( L"[ DXGI 1.2 ]  >> RGBA 10:10:10:2 Override (to 8:8:8:8) Required to Enable Flip Model" );

	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8
$LN116@SK_DXGI_Cr:

; 3470 :             break;
; 3471 :         }
; 3472 :       }
; 3473 :     }
; 3474 : 
; 3475 :     if (       config.render.framerate.buffer_count != -1                  &&
; 3476 :          (UINT)config.render.framerate.buffer_count !=  pDesc->BufferCount &&

	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+408
	cmp	ecx, -1
	je	SHORT $LN23@SK_DXGI_Cr
	mov	eax, DWORD PTR [esi+40]
	cmp	ecx, eax
	je	SHORT $LN23@SK_DXGI_Cr
	test	eax, eax
	je	SHORT $LN23@SK_DXGI_Cr

; 3477 :          pDesc->BufferCount                         !=  0 )
; 3478 :     {
; 3479 :       pDesc->BufferCount = config.render.framerate.buffer_count;
; 3480 :       dll_log.Log (L"[   DXGI   ]  >> Buffer Count Override: %lu buffers", pDesc->BufferCount);

	push	ecx
	push	OFFSET ??_C@_1GI@GAEBCHMN@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAB?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AAO?$AAv@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	mov	DWORD PTR [esi+40], ecx
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
$LN23@SK_DXGI_Cr:

; 3481 :     }
; 3482 : 
; 3483 :     if ( config.render.framerate.flip_discard && dxgi_caps.swapchain.allow_tearing )

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+416, 0
	je	SHORT $LN24@SK_DXGI_Cr
	cmp	DWORD PTR ?dxgi_caps@@3Udxgi_caps_t@@A+8, 0
	je	SHORT $LN24@SK_DXGI_Cr

; 3484 :     {
; 3485 :       pDesc->Flags |= DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING;

	or	DWORD PTR [esi+56], 2048		; 00000800H

; 3486 :       dll_log.Log ( L"[ DXGI 1.5 ]  >> Tearing Option:  Enable" );

	push	OFFSET ??_C@_1FC@PILPBEPG@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAT?$AAe?$AAa?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAO?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?3@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8

; 3487 :       pDesc->Windowed = TRUE;

	mov	DWORD PTR [esi+48], 1
$LN24@SK_DXGI_Cr:

; 3488 :     }
; 3489 : 
; 3490 :     if ( config.render.dxgi.scaling_mode != -1 &&

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+472
	cmp	eax, -1
	je	SHORT $LN25@SK_DXGI_Cr
	cmp	DWORD PTR [esi+24], eax
	je	SHORT $LN25@SK_DXGI_Cr

; 3491 :           pDesc->BufferDesc.Scaling      !=
; 3492 :             (DXGI_MODE_SCALING)config.render.dxgi.scaling_mode )
; 3493 :     {
; 3494 :       dll_log.Log ( L"[   DXGI   ]  >> Scaling Override "

	push	eax
	call	?SK_DXGI_DescribeScalingMode@@YAPB_WW4DXGI_MODE_SCALING@@@Z ; SK_DXGI_DescribeScalingMode
	add	esp, 4
	push	eax
	push	DWORD PTR [esi+24]
	call	?SK_DXGI_DescribeScalingMode@@YAPB_WW4DXGI_MODE_SCALING@@@Z ; SK_DXGI_DescribeScalingMode
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_1HK@PGANLAKP@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAS?$AAc?$AAa?$AAl?$AAi?$AAn?$AAg?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 3495 :                     L"(Requested: %s, Using: %s)",
; 3496 :                       SK_DXGI_DescribeScalingMode (
; 3497 :                         pDesc->BufferDesc.Scaling
; 3498 :                       ),
; 3499 :                         SK_DXGI_DescribeScalingMode (
; 3500 :                           (DXGI_MODE_SCALING)config.render.dxgi.scaling_mode
; 3501 :                         )
; 3502 :                   );
; 3503 : 
; 3504 :       pDesc->BufferDesc.Scaling =

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+472
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+24], eax
$LN25@SK_DXGI_Cr:

; 3505 :         (DXGI_MODE_SCALING)config.render.dxgi.scaling_mode;
; 3506 :     }
; 3507 : 
; 3508 :     if ( config.render.dxgi.scanline_order != -1 &&

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+476
	cmp	eax, -1
	je	SHORT $LN26@SK_DXGI_Cr
	cmp	DWORD PTR [esi+20], eax
	je	SHORT $LN26@SK_DXGI_Cr

; 3509 :           pDesc->BufferDesc.ScanlineOrdering      !=
; 3510 :             (DXGI_MODE_SCANLINE_ORDER)config.render.dxgi.scanline_order )
; 3511 :     {
; 3512 :       dll_log.Log ( L"[   DXGI   ]  >> Scanline Override "

	push	eax
	call	?SK_DXGI_DescribeScanlineOrder@@YAPB_WW4DXGI_MODE_SCANLINE_ORDER@@@Z ; SK_DXGI_DescribeScanlineOrder
	add	esp, 4
	push	eax
	push	DWORD PTR [esi+20]
	call	?SK_DXGI_DescribeScanlineOrder@@YAPB_WW4DXGI_MODE_SCANLINE_ORDER@@@Z ; SK_DXGI_DescribeScanlineOrder
	add	esp, 4
	push	eax
	push	OFFSET ??_C@_1HM@EKHBGJHP@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAS?$AAc?$AAa?$AAn?$AAl?$AAi?$AAn?$AAe?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 3513 :                     L"(Requested: %s, Using: %s)",
; 3514 :                       SK_DXGI_DescribeScanlineOrder (
; 3515 :                         pDesc->BufferDesc.ScanlineOrdering
; 3516 :                       ),
; 3517 :                         SK_DXGI_DescribeScanlineOrder (
; 3518 :                           (DXGI_MODE_SCANLINE_ORDER)config.render.dxgi.scanline_order
; 3519 :                         )
; 3520 :                   );
; 3521 : 
; 3522 :       pDesc->BufferDesc.ScanlineOrdering =

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+476
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+20], eax
$LN26@SK_DXGI_Cr:

; 3523 :         (DXGI_MODE_SCANLINE_ORDER)config.render.dxgi.scanline_order;
; 3524 :     }
; 3525 : 
; 3526 :     if ( config.render.framerate.refresh_rate != -1 &&

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+424
	cmp	eax, -1
	je	SHORT $LN27@SK_DXGI_Cr
	mov	ecx, DWORD PTR [esi+8]
	cmp	ecx, eax
	je	SHORT $LN27@SK_DXGI_Cr

; 3527 :          pDesc->BufferDesc.RefreshRate.Numerator != (UINT)config.render.framerate.refresh_rate )
; 3528 :     {
; 3529 :       dll_log.Log ( L"[   DXGI   ]  >> Refresh Override "

	mov	edx, DWORD PTR [esi+12]
	test	edx, edx
	je	SHORT $LN61@SK_DXGI_Cr
	movd	xmm0, ecx
	cvtdq2pd xmm0, xmm0
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	cvtpd2ps xmm1, xmm0
	movd	xmm0, edx
	cvtdq2pd xmm0, xmm0
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	cvtpd2ps xmm0, xmm0
	divss	xmm1, xmm0
	jmp	SHORT $LN79@SK_DXGI_Cr
$LN61@SK_DXGI_Cr:
	movss	xmm1, DWORD PTR __real@7fc00000
$LN79@SK_DXGI_Cr:
	push	eax
	cvtps2pd xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_1HM@GOOAFJFG@?$AA?$FL?$AA?5?$AA?5?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA?5?$AA?5?$AA?$FN?$AA?5?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAR?$AAe?$AAf?$AAr?$AAe?$AAs?$AAh?$AA?5?$AAO?$AAv?$AAe?$AAr?$AAr?$AAi?$AAd@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 3530 :                     L"(Requested: %f, Using: %li)",
; 3531 :                  pDesc->BufferDesc.RefreshRate.Denominator != 0 ?
; 3532 :          static_cast <float> (pDesc->BufferDesc.RefreshRate.Numerator) /
; 3533 :          static_cast <float> (pDesc->BufferDesc.RefreshRate.Denominator) :
; 3534 :                      std::numeric_limits <float>::quiet_NaN (),
; 3535 :                         config.render.framerate.refresh_rate
; 3536 :                   );
; 3537 : 
; 3538 :       pDesc->BufferDesc.RefreshRate.Numerator   = config.render.framerate.refresh_rate;

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+424
	add	esp, 20					; 00000014H
	mov	DWORD PTR [esi+8], eax

; 3539 :       pDesc->BufferDesc.RefreshRate.Denominator = 1;

	mov	DWORD PTR [esi+12], 1
$LN27@SK_DXGI_Cr:

; 3540 :     }
; 3541 : 
; 3542 :     bWait = bFlipMode && dxgi_caps.present.waitable;

	cmp	BYTE PTR ?bFlipMode@@3_NA, 0		; bFlipMode
	je	SHORT $LN65@SK_DXGI_Cr
	cmp	BYTE PTR ?dxgi_caps@@3Udxgi_caps_t@@A+4, 0
	je	SHORT $LN65@SK_DXGI_Cr

; 3543 : 
; 3544 :     // We cannot change the swapchain parameters if this is used...
; 3545 :     bWait = bWait && config.render.framerate.swapchain_wait > 0;

	cmp	DWORD PTR ?config@@3Usk_config_t@@A+420, 0
	mov	BYTE PTR ?bWait@@3_NA, 1		; bWait
	jg	SHORT $LN66@SK_DXGI_Cr
$LN65@SK_DXGI_Cr:
	mov	BYTE PTR ?bWait@@3_NA, 0		; bWait
$LN66@SK_DXGI_Cr:

; 3546 : 
; 3547 : #ifdef _WIN64
; 3548 :     if (! lstrcmpW (SK_GetHostApp (), L"DarkSoulsIII.exe"))
; 3549 :     {
; 3550 :       if (SK_DS3_IsBorderless ())
; 3551 :         pDesc->Flags &= ~DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
; 3552 :     }
; 3553 : #endif
; 3554 : 
; 3555 :     if (bFlipMode)

	cmp	BYTE PTR ?bFlipMode@@3_NA, 0		; bFlipMode
	je	SHORT $LN28@SK_DXGI_Cr

; 3556 :     {
; 3557 :       if (bWait)

	cmp	BYTE PTR ?bWait@@3_NA, 0		; bWait
	je	SHORT $LN30@SK_DXGI_Cr

; 3558 :         pDesc->Flags |= DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT;

	or	DWORD PTR [esi+56], 64			; 00000040H
$LN30@SK_DXGI_Cr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 3743 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, 3
	cmp	DWORD PTR ?config@@3Usk_config_t@@A+408, eax
	cmovg	eax, DWORD PTR ?config@@3Usk_config_t@@A+408
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3564 :       if (config.render.framerate.flip_discard &&

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+416, 0
	mov	DWORD PTR ?config@@3Usk_config_t@@A+408, eax
	je	SHORT $LN31@SK_DXGI_Cr
	cmp	BYTE PTR ?dxgi_caps@@3Udxgi_caps_t@@A+3, 0
	je	SHORT $LN31@SK_DXGI_Cr

; 3565 :           dxgi_caps.present.flip_discard)
; 3566 :         pDesc->SwapEffect  = DXGI_SWAP_EFFECT_FLIP_DISCARD;

	mov	DWORD PTR [esi+52], 4

; 3567 :       else

	jmp	SHORT $LN33@SK_DXGI_Cr
$LN31@SK_DXGI_Cr:

; 3568 :         pDesc->SwapEffect  = DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL;

	mov	DWORD PTR [esi+52], 3
	jmp	SHORT $LN33@SK_DXGI_Cr
$LN28@SK_DXGI_Cr:

; 3569 :     }
; 3570 : 
; 3571 :     else if ( pDesc->SwapEffect != DXGI_SWAP_EFFECT_FLIP_DISCARD &&

	mov	eax, DWORD PTR [esi+52]
	cmp	eax, 4
	je	SHORT $LN33@SK_DXGI_Cr
	cmp	eax, 3
	je	SHORT $LN33@SK_DXGI_Cr

; 3572 :               pDesc->SwapEffect != DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL )
; 3573 :     {
; 3574 :       // Resort to triple-buffering if flip mode is not available
; 3575 :       if (config.render.framerate.buffer_count > 3)

	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+408
	mov	eax, 3
	cmp	ecx, eax
	cmovg	ecx, eax
	mov	DWORD PTR ?config@@3Usk_config_t@@A+408, ecx

; 3576 :         config.render.framerate.buffer_count = 3;
; 3577 : 
; 3578 :       pDesc->SwapEffect = DXGI_SWAP_EFFECT_DISCARD;

	mov	DWORD PTR [esi+52], 0
$LN33@SK_DXGI_Cr:

; 3579 :     }
; 3580 : 
; 3581 :     if (config.render.framerate.buffer_count > 0)

	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+408
	test	ecx, ecx
	jle	SHORT $LN35@SK_DXGI_Cr

; 3582 :       pDesc->BufferCount = config.render.framerate.buffer_count;

	mov	DWORD PTR [esi+40], ecx
$LN35@SK_DXGI_Cr:

; 3583 : 
; 3584 :     // We cannot switch modes on a waitable swapchain
; 3585 :     if (bFlipMode && bWait)

	cmp	BYTE PTR ?bFlipMode@@3_NA, 0		; bFlipMode
	je	SHORT $LN117@SK_DXGI_Cr
	cmp	BYTE PTR ?bWait@@3_NA, 0		; bWait
	je	SHORT $LN117@SK_DXGI_Cr

; 3586 :     {
; 3587 :       pDesc->Flags |=  DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT;
; 3588 :       pDesc->Flags &= ~DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

	mov	eax, DWORD PTR [esi+56]
	and	eax, -3					; fffffffdH
	or	eax, 64					; 00000040H
	mov	DWORD PTR [esi+56], eax
$LN117@SK_DXGI_Cr:

; 3592 :   dll_log.Log ( L"[ DXGI 1.2 ] >> Using %s Presentation Model  [Waitable: %s - %li ms]",

	mov	cl, BYTE PTR ?bWait@@3_NA		; bWait
	xor	eax, eax
	test	cl, cl
	mov	edx, OFFSET ??_C@_15BICKNCBF@?$AAN?$AAo?$AA?$AA@
	mov	ecx, OFFSET ??_C@_1BI@PKCOFIGO@?$AAT?$AAr?$AAa?$AAd?$AAi?$AAt?$AAi?$AAo?$AAn?$AAa?$AAl?$AA?$AA@
	cmovne	eax, DWORD PTR ?config@@3Usk_config_t@@A+420
	push	eax
	mov	eax, OFFSET ??_C@_17PBAHFJOA@?$AAY?$AAe?$AAs?$AA?$AA@
	cmove	eax, edx
	cmp	BYTE PTR ?bFlipMode@@3_NA, 0		; bFlipMode
	push	eax
	mov	eax, OFFSET ??_C@_19EMFBKLJE@?$AAF?$AAl?$AAi?$AAp?$AA?$AA@
	cmove	eax, ecx
	push	eax
	push	OFFSET ??_C@_1IK@KCJJDMDA@?$AA?$FL?$AA?5?$AAD?$AAX?$AAG?$AAI?$AA?5?$AA1?$AA?4?$AA2?$AA?5?$AA?$FN?$AA?5?$AA?$DO?$AA?$DO?$AA?5?$AAU?$AAs?$AAi?$AAn?$AAg?$AA?5?$AA?$CF?$AAs?$AA?5?$AAP?$AAr?$AAe?$AAs?$AAe?$AAn?$AAt@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 251  :           bool isZero (void) { return x == 0 && y == 0; };

	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+460
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3592 :   dll_log.Log ( L"[ DXGI 1.2 ] >> Using %s Presentation Model  [Waitable: %s - %li ms]",

	add	esp, 20					; 00000014H
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 251  :           bool isZero (void) { return x == 0 && y == 0; };

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+464
	test	ecx, ecx
	jne	SHORT $LN86@SK_DXGI_Cr
	test	eax, eax
	je	SHORT $LN38@SK_DXGI_Cr
$LN86@SK_DXGI_Cr:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3598 :   if ((! config.render.dxgi.res.max.isZero ()) && pDesc->BufferDesc.Width > config.render.dxgi.res.max.x)

	cmp	DWORD PTR [esi], ecx
	jbe	SHORT $LN37@SK_DXGI_Cr

; 3599 :     pDesc->BufferDesc.Width = config.render.dxgi.res.max.x;

	mov	DWORD PTR [esi], ecx
	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+464
	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+460
$LN37@SK_DXGI_Cr:
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 251  :           bool isZero (void) { return x == 0 && y == 0; };

	test	ecx, ecx
	jne	SHORT $LN90@SK_DXGI_Cr
	test	eax, eax
	je	SHORT $LN38@SK_DXGI_Cr
$LN90@SK_DXGI_Cr:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3600 :   if ((! config.render.dxgi.res.max.isZero ()) && pDesc->BufferDesc.Height > config.render.dxgi.res.max.y)

	cmp	DWORD PTR [esi+4], eax
	jbe	SHORT $LN38@SK_DXGI_Cr

; 3601 :     pDesc->BufferDesc.Height = config.render.dxgi.res.max.y;

	mov	DWORD PTR [esi+4], eax
$LN38@SK_DXGI_Cr:
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 246  :           bool isZero (void) { return x == 0 && y == 0; };

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+452
	test	eax, eax
	jne	SHORT $LN94@SK_DXGI_Cr
	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+456
	test	eax, eax
	jne	SHORT $LN98@SK_DXGI_Cr
	jmp	SHORT $LN40@SK_DXGI_Cr
$LN94@SK_DXGI_Cr:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3603 :   if ((! config.render.dxgi.res.min.isZero ()) && pDesc->BufferDesc.Width < config.render.dxgi.res.min.x)

	cmp	DWORD PTR [esi], eax
	jae	SHORT $LN39@SK_DXGI_Cr

; 3604 :     pDesc->BufferDesc.Width = config.render.dxgi.res.min.x;

	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+452
$LN39@SK_DXGI_Cr:
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 246  :           bool isZero (void) { return x == 0 && y == 0; };

	test	eax, eax
	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+456
	jne	SHORT $LN98@SK_DXGI_Cr
	test	eax, eax
	je	SHORT $LN40@SK_DXGI_Cr
$LN98@SK_DXGI_Cr:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3605 :   if ((! config.render.dxgi.res.min.isZero ()) && pDesc->BufferDesc.Height < config.render.dxgi.res.min.y)

	cmp	DWORD PTR [esi+4], eax
	jae	SHORT $LN40@SK_DXGI_Cr

; 3606 :     pDesc->BufferDesc.Height = config.render.dxgi.res.min.y;

	mov	DWORD PTR [esi+4], eax
$LN40@SK_DXGI_Cr:

; 3607 : 
; 3608 : 
; 3609 :   if (translated)

	cmp	BYTE PTR _translated$1$[ebp], 0
	je	SHORT $LN43@SK_DXGI_Cr

; 3610 :   {
; 3611 :     pDesc1->BufferCount                        = pDesc->BufferCount;

	mov	eax, DWORD PTR [esi+40]

; 3612 :     pDesc1->BufferUsage                        = pDesc->BufferUsage;
; 3613 :     pDesc1->Flags                              = pDesc->Flags;
; 3614 :     pDesc1->SwapEffect                         = pDesc->SwapEffect;
; 3615 :     pDesc1->SampleDesc.Count                   = pDesc->SampleDesc.Count;
; 3616 :     pDesc1->SampleDesc.Quality                 = pDesc->SampleDesc.Quality;
; 3617 :     pDesc1->Format                             = pDesc->BufferDesc.Format;
; 3618 :     pDesc1->Height                             = pDesc->BufferDesc.Height;
; 3619 :     pDesc1->Width                              = pDesc->BufferDesc.Width;
; 3620 : 
; 3621 :     hWnd                                       = pDesc->OutputWindow;

	mov	ecx, DWORD PTR _hWnd$[ebp]
	mov	DWORD PTR [edi+28], eax
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [edi+24], eax
	mov	eax, DWORD PTR [esi+56]
	mov	DWORD PTR [edi+44], eax
	mov	eax, DWORD PTR [esi+52]
	mov	DWORD PTR [edi+36], eax
	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [edi+16], eax
	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [edi+20], eax
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [edi+8], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+4], eax
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [ecx], eax

; 3622 : 
; 3623 :     if (pFullscreenDesc != nullptr)

	test	ebx, ebx
	je	SHORT $LN42@SK_DXGI_Cr

; 3624 :     {
; 3625 :       pFullscreenDesc->Windowed                = pDesc->Windowed;

	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [ebx+16], eax

; 3626 :       pFullscreenDesc->RefreshRate.Denominator = pDesc->BufferDesc.RefreshRate.Denominator;

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [ebx+4], eax

; 3627 :       pFullscreenDesc->RefreshRate.Numerator   = pDesc->BufferDesc.RefreshRate.Numerator;

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ebx], eax

; 3628 :       pFullscreenDesc->Scaling                 = pDesc->BufferDesc.Scaling;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [ebx+12], eax

; 3629 :       pFullscreenDesc->ScanlineOrdering        = pDesc->BufferDesc.ScanlineOrdering;

	mov	eax, DWORD PTR [esi+20]
	pop	edi
	pop	esi
	mov	DWORD PTR [ebx+8], eax
	pop	ebx

; 3634 :   }
; 3635 : 
; 3636 :   //game_window.hWnd = pDesc->OutputWindow;
; 3637 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN42@SK_DXGI_Cr:

; 3630 :     }
; 3631 : 
; 3632 :     else
; 3633 :       pDesc->Windowed = TRUE;

	mov	DWORD PTR [esi+48], 1
$LN43@SK_DXGI_Cr:
	pop	edi
	pop	esi
	pop	ebx

; 3634 :   }
; 3635 : 
; 3636 :   //game_window.hWnd = pDesc->OutputWindow;
; 3637 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN125@SK_DXGI_Cr:
	DD	$LN22@SK_DXGI_Cr
	DD	$LN21@SK_DXGI_Cr
	DD	$LN20@SK_DXGI_Cr
	DD	$LN116@SK_DXGI_Cr
$LN115@SK_DXGI_Cr:
	DB	0
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
?SK_DXGI_CreateSwapChain_PreInit@@YAXPAUDXGI_SWAP_CHAIN_DESC@@PAUDXGI_SWAP_CHAIN_DESC1@@AAPAUHWND__@@PAUDXGI_SWAP_CHAIN_FULLSCREEN_DESC@@@Z ENDP ; SK_DXGI_CreateSwapChain_PreInit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\mutex
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_new_new_params$2 = -100				; size = 28
$T3 = -72						; size = 24
_client$4 = -48						; size = 16
_client$5 = -32						; size = 16
_auto_lock$6 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_This$ = 8						; size = 4
_wszFullyFormatted$1$ = 12				; size = 4
_pNewTargetParameters$ = 12				; size = 4
?DXGISwap_ResizeTarget_Override@@YGJPAUIDXGISwapChain@@PBUDXGI_MODE_DESC@@@Z PROC ; DXGISwap_ResizeTarget_Override

; 3111 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?DXGISwap_ResizeTarget_Override@@YGJPAUIDXGISwapChain@@PBUDXGI_MODE_DESC@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 3112 :   // Can't do this if waitable
; 3113 :   if (dxgi_caps.present.waitable && config.render.framerate.swapchain_wait > 0)

	cmp	BYTE PTR ?dxgi_caps@@3Udxgi_caps_t@@A+4, 0
	je	SHORT $LN2@DXGISwap_R
	cmp	DWORD PTR ?config@@3Usk_config_t@@A+420, 0
	jle	SHORT $LN2@DXGISwap_R

; 3114 :     return S_OK;

	xor	eax, eax

; 3283 :   }
; 3284 : 
; 3285 :   return ret;
; 3286 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN2@DXGISwap_R:
	push	esi
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h

; 261  :     EnterCriticalSection (cs_);

	push	DWORD PTR ?cs_mmio@@3VSK_Thread_HybridSpinlock@@A ; cs_mmio
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\mutex

; 217  : 		: _MyMutex(_Mtx)

	mov	DWORD PTR _auto_lock$6[ebp], OFFSET ?cs_mmio@@3VSK_Thread_HybridSpinlock@@A ; cs_mmio
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h

; 261  :     EnterCriticalSection (cs_);

	call	DWORD PTR __imp__EnterCriticalSection@4
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3117 :     std::lock_guard <SK_Thread_CriticalSection> auto_lock (cs_mmio);

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3118 : 
; 3119 :     SK_D3D11_EndFrame        ();

	call	?SK_D3D11_EndFrame@@YAXXZ		; SK_D3D11_EndFrame

; 3120 :     SK_CEGUI_QueueResetD3D11 (); // Prior to the next present, reset the UI

	call	?SK_CEGUI_QueueResetD3D11@@YAXXZ	; SK_CEGUI_QueueResetD3D11
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h

; 266  :     LeaveCriticalSection (cs_);

	push	DWORD PTR ?cs_mmio@@3VSK_Thread_HybridSpinlock@@A ; cs_mmio
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3121 :   }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h

; 266  :     LeaveCriticalSection (cs_);

	call	DWORD PTR __imp__LeaveCriticalSection@4
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3124 :   if (pNewTargetParameters == nullptr)

	mov	esi, DWORD PTR _pNewTargetParameters$[ebp]
	test	esi, esi
	jne	SHORT $LN3@DXGISwap_R

; 3125 :   {
; 3126 :     HRESULT ret;
; 3127 :     DXGI_CALL (ret, ResizeTarget_Original (This, pNewTargetParameters));

	push	esi
	push	DWORD PTR _This$[ebp]
	call	DWORD PTR ?ResizeTarget_Original@@3P6GJPAUIDXGISwapChain@@PBUDXGI_MODE_DESC@@@ZA ; ResizeTarget_Original
	mov	esi, eax
	push	esi
	call	?SK_DescribeHRESULT@@YGPB_WJ@Z		; SK_DescribeHRESULT
	push	eax
	push	OFFSET $SG356393
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH

; 3128 :     return ret;

	mov	eax, esi
	pop	esi

; 3283 :   }
; 3284 : 
; 3285 :   return ret;
; 3286 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	8
$LN3@DXGISwap_R:
	push	edi

; 3131 :   DXGI_LOG_CALL_I6 ( L"    IDXGISwapChain", L"ResizeTarget         ",

	push	8192					; 00002000H
	call	??_U@YAPAXI@Z				; operator new[]
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	je	SHORT $LN26@DXGISwap_R
	push	8192					; 00002000H
	push	0
	push	edi
	call	_memset
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN27@DXGISwap_R
$LN26@DXGISwap_R:
	xor	edi, edi
$LN27@DXGISwap_R:
	movss	xmm1, DWORD PTR __real@7fc00000
	test	edi, edi
	je	$LN4@DXGISwap_R
	push	OFFSET $SG356395
	push	OFFSET $SG356396
	push	OFFSET $SG356397
	push	edi
	call	__swprintf
	mov	ecx, DWORD PTR [esi+12]
	add	esp, 16					; 00000010H
	test	ecx, ecx
	je	SHORT $LN28@DXGISwap_R
	mov	eax, DWORD PTR [esi+8]
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm1, xmm0
	movd	xmm0, ecx
	cvtdq2pd xmm0, xmm0
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	cvtpd2ps xmm0, xmm0
	divss	xmm1, xmm0
	jmp	SHORT $LN44@DXGISwap_R
$LN28@DXGISwap_R:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits

; 1119 : 		return (__builtin_nanf("0"));

	movss	xmm1, DWORD PTR __real@7fc00000
$LN44@DXGISwap_R:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3131 :   DXGI_LOG_CALL_I6 ( L"    IDXGISwapChain", L"ResizeTarget         ",

	push	DWORD PTR [esi+20]
	cvtps2pd xmm0, xmm1
	lea	eax, DWORD PTR [edi+2048]
	push	DWORD PTR [esi+24]
	push	DWORD PTR [esi+16]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR [esi+4]
	push	DWORD PTR [esi]
	push	OFFSET $SG356398
	push	eax
	call	__swprintf
	lea	eax, DWORD PTR [edi+2048]
	push	eax
	push	edi
	lea	ecx, DWORD PTR [eax+2048]
	push	OFFSET $SG356399
	push	ecx
	mov	DWORD PTR _wszFullyFormatted$1$[ebp], ecx
	call	__swprintf
	mov	eax, DWORD PTR __$ReturnAddr$[ebp]
	add	esp, 52					; 00000034H
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?SK_SummarizeCaller@@YG?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAX@Z ; SK_SummarizeCaller
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN59@DXGISwap_R
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN59@DXGISwap_R:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3131 :   DXGI_LOG_CALL_I6 ( L"    IDXGISwapChain", L"ResizeTarget         ",

	push	eax
	push	DWORD PTR _wszFullyFormatted$1$[ebp]
	push	OFFSET $SG356400
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T3[ebp+20]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3131 :   DXGI_LOG_CALL_I6 ( L"    IDXGISwapChain", L"ResizeTarget         ",

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN69@DXGISwap_R
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T3[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN69@DXGISwap_R:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3131 :   DXGI_LOG_CALL_I6 ( L"    IDXGISwapChain", L"ResizeTarget         ",

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	movss	xmm1, DWORD PTR __real@7fc00000
	add	esp, 4
$LN4@DXGISwap_R:

; 3132 :                        L"{ (%lux%lu@%3.1f Hz),"
; 3133 :                        L"fmt=%lu,scaling=0x%02x,scanlines=0x%02x }",
; 3134 :                           pNewTargetParameters->Width, pNewTargetParameters->Height,
; 3135 :                           pNewTargetParameters->RefreshRate.Denominator != 0 ?
; 3136 :            static_cast <float> (pNewTargetParameters->RefreshRate.Numerator) /
; 3137 :            static_cast <float> (pNewTargetParameters->RefreshRate.Denominator) :
; 3138 :                               std::numeric_limits <float>::quiet_NaN (),
; 3139 :             static_cast <UINT> (pNewTargetParameters->Format),
; 3140 :                                 pNewTargetParameters->Scaling,
; 3141 :                                 pNewTargetParameters->ScanlineOrdering );
; 3142 : 
; 3143 :   HRESULT ret;
; 3144 : 
; 3145 :   if ( config.window.borderless ||
; 3146 :        ( config.render.dxgi.scaling_mode != -1 &&
; 3147 :           pNewTargetParameters->Scaling  != 
; 3148 :             (DXGI_MODE_SCALING)config.render.dxgi.scaling_mode )
; 3149 :                                 ||

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+728, 0
	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+472
	mov	edx, DWORD PTR ?config@@3Usk_config_t@@A+424
	jne	$LN7@DXGISwap_R
	cmp	ecx, -1
	je	SHORT $LN8@DXGISwap_R
	cmp	DWORD PTR [esi+24], ecx
	jne	$LN7@DXGISwap_R
$LN8@DXGISwap_R:
	cmp	edx, -1
	je	SHORT $LN5@DXGISwap_R
	cmp	DWORD PTR [esi+8], edx
	jne	SHORT $LN7@DXGISwap_R
$LN5@DXGISwap_R:

; 3252 :       }
; 3253 :     }
; 3254 :   }
; 3255 : 
; 3256 :   else
; 3257 :   {
; 3258 :     DXGI_CALL (ret, ResizeTarget_Original (This, pNewTargetParameters));

	push	esi
	push	DWORD PTR _This$[ebp]
	call	DWORD PTR ?ResizeTarget_Original@@3P6GJPAUIDXGISwapChain@@PBUDXGI_MODE_DESC@@@ZA ; ResizeTarget_Original
	mov	edi, eax
	push	edi
	call	?SK_DescribeHRESULT@@YGPB_WJ@Z		; SK_DescribeHRESULT
	push	eax
	push	OFFSET $SG356419
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH

; 3259 : 
; 3260 :     if (SUCCEEDED (ret))

	test	edi, edi
	js	$LN24@DXGISwap_R

; 3261 :     {
; 3262 :       if (pNewTargetParameters->Width != 0 && pNewTargetParameters->Height != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN20@DXGISwap_R
	cmp	DWORD PTR [esi+4], 0
	je	SHORT $LN20@DXGISwap_R

; 3263 :       {
; 3264 :         SK_SetWindowResX (pNewTargetParameters->Width);

	push	eax
	call	?SK_SetWindowResX@@YAXJ@Z		; SK_SetWindowResX

; 3265 :         SK_SetWindowResY (pNewTargetParameters->Height);

	push	DWORD PTR [esi+4]
	call	?SK_SetWindowResY@@YAXJ@Z		; SK_SetWindowResY

; 3266 :       }
; 3267 : 
; 3268 :       else

	mov	esi, DWORD PTR _This$[ebp]
	jmp	$LN112@DXGISwap_R
$LN20@DXGISwap_R:

; 3269 :       {
; 3270 :         RECT client;
; 3271 : 
; 3272 :         GetClientRect (game_window.hWnd, &client);

	lea	eax, DWORD PTR _client$5[ebp]
	push	eax
	push	DWORD PTR ?game_window@@3Usk_window_s@@A+4
	call	DWORD PTR __imp__GetClientRect@8

; 3273 :         SK_SetWindowResX (client.right  - client.left);

	mov	eax, DWORD PTR _client$5[ebp+8]
	sub	eax, DWORD PTR _client$5[ebp]
	push	eax
	call	?SK_SetWindowResX@@YAXJ@Z		; SK_SetWindowResX

; 3274 :         SK_SetWindowResY (client.bottom - client.top);

	mov	eax, DWORD PTR _client$5[ebp+12]
	sub	eax, DWORD PTR _client$5[ebp+4]
	push	eax
	call	?SK_SetWindowResY@@YAXJ@Z		; SK_SetWindowResY
	mov	esi, DWORD PTR _This$[ebp]
	jmp	$LN112@DXGISwap_R
$LN7@DXGISwap_R:

; 3150 :        ( config.render.framerate.refresh_rate          != -1 &&
; 3151 :            pNewTargetParameters->RefreshRate.Numerator !=
; 3152 :              (UINT)config.render.framerate.refresh_rate )
; 3153 :     )
; 3154 :   {
; 3155 :     DXGI_MODE_DESC new_new_params =
; 3156 :       *pNewTargetParameters;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR _new_new_params$2[ebp+24], eax
	movups	xmm0, XMMWORD PTR [esi]
	movups	XMMWORD PTR _new_new_params$2[ebp], xmm0
	movq	xmm0, QWORD PTR [esi+16]
	movq	QWORD PTR _new_new_params$2[ebp+16], xmm0

; 3157 : 
; 3158 :     if ( config.render.framerate.refresh_rate != -1 &&

	cmp	edx, -1
	je	SHORT $LN9@DXGISwap_R
	mov	edi, DWORD PTR _new_new_params$2[ebp+8]
	cmp	edi, edx
	je	SHORT $LN9@DXGISwap_R

; 3159 :          new_new_params.RefreshRate.Numerator != (UINT)config.render.framerate.refresh_rate )
; 3160 :     {
; 3161 :       dll_log.Log ( L"[   DXGI   ]  >> Refresh Override "

	mov	eax, DWORD PTR _new_new_params$2[ebp+12]
	test	eax, eax
	je	SHORT $LN30@DXGISwap_R
	movd	xmm0, edi
	cvtdq2pd xmm0, xmm0
	shr	edi, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edi*8]
	cvtpd2ps xmm1, xmm0
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	divss	xmm1, xmm0
$LN30@DXGISwap_R:
	push	edx
	cvtps2pd xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG356406
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 3162 :                     L"(Requested: %f, Using: %li)",
; 3163 :                       new_new_params.RefreshRate.Denominator != 0 ?
; 3164 :                         static_cast <float> (new_new_params.RefreshRate.Numerator) /
; 3165 :                         static_cast <float> (new_new_params.RefreshRate.Denominator) :
; 3166 :                           std::numeric_limits <float>::quiet_NaN (),
; 3167 :                         config.render.framerate.refresh_rate
; 3168 :                   );
; 3169 : 
; 3170 :       new_new_params.RefreshRate.Numerator   = config.render.framerate.refresh_rate;

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+424
	add	esp, 20					; 00000014H

; 3171 :       new_new_params.RefreshRate.Denominator = 1;

	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+472
	mov	DWORD PTR _new_new_params$2[ebp+8], eax
	mov	DWORD PTR _new_new_params$2[ebp+12], 1
$LN9@DXGISwap_R:

; 3172 :     }
; 3173 : 
; 3174 :     if ( config.render.dxgi.scanline_order != -1 &&

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+476
	cmp	eax, -1
	je	SHORT $LN10@DXGISwap_R
	mov	edi, DWORD PTR [esi+20]
	cmp	edi, eax
	je	SHORT $LN10@DXGISwap_R

; 3175 :           pNewTargetParameters->ScanlineOrdering  != 
; 3176 :             (DXGI_MODE_SCANLINE_ORDER)config.render.dxgi.scanline_order )
; 3177 :     {
; 3178 :       dll_log.Log ( L"[   DXGI   ]  >> Scanline Override "

	push	eax
	call	?SK_DXGI_DescribeScanlineOrder@@YAPB_WW4DXGI_MODE_SCANLINE_ORDER@@@Z ; SK_DXGI_DescribeScanlineOrder
	add	esp, 4
	push	eax
	push	edi
	call	?SK_DXGI_DescribeScanlineOrder@@YAPB_WW4DXGI_MODE_SCANLINE_ORDER@@@Z ; SK_DXGI_DescribeScanlineOrder
	add	esp, 4
	push	eax
	push	OFFSET $SG356408
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 3179 :                     L"(Requested: %s, Using: %s)",
; 3180 :                       SK_DXGI_DescribeScanlineOrder (
; 3181 :                         pNewTargetParameters->ScanlineOrdering
; 3182 :                       ),
; 3183 :                         SK_DXGI_DescribeScanlineOrder (
; 3184 :                           (DXGI_MODE_SCANLINE_ORDER)config.render.dxgi.scanline_order
; 3185 :                         )
; 3186 :                   );
; 3187 : 
; 3188 :       new_new_params.ScanlineOrdering =

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+476
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+472
	mov	DWORD PTR _new_new_params$2[ebp+20], eax
$LN10@DXGISwap_R:

; 3189 :         (DXGI_MODE_SCANLINE_ORDER)config.render.dxgi.scanline_order;
; 3190 :     }
; 3191 : 
; 3192 :     if ( config.render.dxgi.scaling_mode != -1 &&

	cmp	ecx, -1
	je	SHORT $LN11@DXGISwap_R
	mov	esi, DWORD PTR [esi+24]
	cmp	esi, ecx
	je	SHORT $LN11@DXGISwap_R

; 3193 :           pNewTargetParameters->Scaling  != 
; 3194 :             (DXGI_MODE_SCALING)config.render.dxgi.scaling_mode )
; 3195 :     {
; 3196 :       dll_log.Log ( L"[   DXGI   ]  >> Scaling Override "

	push	ecx
	call	?SK_DXGI_DescribeScalingMode@@YAPB_WW4DXGI_MODE_SCALING@@@Z ; SK_DXGI_DescribeScalingMode
	add	esp, 4
	push	eax
	push	esi
	call	?SK_DXGI_DescribeScalingMode@@YAPB_WW4DXGI_MODE_SCALING@@@Z ; SK_DXGI_DescribeScalingMode
	add	esp, 4
	push	eax
	push	OFFSET $SG356410
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 3197 :                     L"(Requested: %s, Using: %s)",
; 3198 :                       SK_DXGI_DescribeScalingMode (
; 3199 :                         pNewTargetParameters->Scaling
; 3200 :                       ),
; 3201 :                         SK_DXGI_DescribeScalingMode (
; 3202 :                           (DXGI_MODE_SCALING)config.render.dxgi.scaling_mode
; 3203 :                         )
; 3204 :                   );
; 3205 : 
; 3206 :       new_new_params.Scaling =

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+472
	add	esp, 16					; 00000010H
	mov	DWORD PTR _new_new_params$2[ebp+24], eax
$LN11@DXGISwap_R:

; 3207 :         (DXGI_MODE_SCALING)config.render.dxgi.scaling_mode;
; 3208 :     }
; 3209 : 
; 3210 :     if ( (! config.window.fullscreen) &&

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+754, 0
	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+760
	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+756
	jne	SHORT $LN13@DXGISwap_R
	cmp	BYTE PTR ?config@@3Usk_config_t@@A+728, 0
	je	SHORT $LN13@DXGISwap_R
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 425  :         bool isZero (void) { return x == 0 && y == 0; };

	test	ecx, ecx
	jne	SHORT $LN100@DXGISwap_R
	test	eax, eax
	je	SHORT $LN15@DXGISwap_R
$LN100@DXGISwap_R:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3215 :         new_new_params.Width  = config.window.res.override.x;

	mov	DWORD PTR _new_new_params$2[ebp], ecx

; 3216 :         new_new_params.Height = config.window.res.override.y;

	mov	DWORD PTR _new_new_params$2[ebp+4], eax
$LN13@DXGISwap_R:
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 425  :         bool isZero (void) { return x == 0 && y == 0; };

	test	ecx, ecx
	jne	SHORT $LN104@DXGISwap_R
	test	eax, eax
	je	SHORT $LN15@DXGISwap_R
$LN104@DXGISwap_R:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3229 :       new_new_params.Width  = config.window.res.override.x;

	mov	DWORD PTR _new_new_params$2[ebp], ecx

; 3230 :       new_new_params.Height = config.window.res.override.y;

	mov	DWORD PTR _new_new_params$2[ebp+4], eax
$LN15@DXGISwap_R:

; 3231 :     }
; 3232 : 
; 3233 : 
; 3234 : 
; 3235 :     DXGI_CALL (ret, ResizeTarget_Original (This, pNewNewTargetParameters));

	mov	esi, DWORD PTR _This$[ebp]
	lea	eax, DWORD PTR _new_new_params$2[ebp]
	push	eax
	push	esi
	call	DWORD PTR ?ResizeTarget_Original@@3P6GJPAUIDXGISwapChain@@PBUDXGI_MODE_DESC@@@ZA ; ResizeTarget_Original
	mov	edi, eax
	push	edi
	call	?SK_DescribeHRESULT@@YGPB_WJ@Z		; SK_DescribeHRESULT
	push	eax
	push	OFFSET $SG356415
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH

; 3236 : 
; 3237 :     if (SUCCEEDED (ret))

	test	edi, edi
	js	SHORT $LN24@DXGISwap_R

; 3238 :     {
; 3239 :       if (pNewNewTargetParameters->Width != 0 && pNewNewTargetParameters->Height != 0)

	mov	eax, DWORD PTR _new_new_params$2[ebp]
	test	eax, eax
	je	SHORT $LN17@DXGISwap_R
	cmp	DWORD PTR _new_new_params$2[ebp+4], 0
	je	SHORT $LN17@DXGISwap_R

; 3240 :       {
; 3241 :         SK_SetWindowResX (pNewNewTargetParameters->Width);

	push	eax
	call	?SK_SetWindowResX@@YAXJ@Z		; SK_SetWindowResX

; 3242 :         SK_SetWindowResY (pNewNewTargetParameters->Height);

	push	DWORD PTR _new_new_params$2[ebp+4]

; 3243 :       }
; 3244 : 
; 3245 :       else

	jmp	SHORT $LN113@DXGISwap_R
$LN17@DXGISwap_R:

; 3246 :       {
; 3247 :         RECT client;
; 3248 : 
; 3249 :         GetClientRect (game_window.hWnd, &client);

	lea	eax, DWORD PTR _client$4[ebp]
	push	eax
	push	DWORD PTR ?game_window@@3Usk_window_s@@A+4
	call	DWORD PTR __imp__GetClientRect@8

; 3250 :         SK_SetWindowResX (client.right  - client.left);

	mov	eax, DWORD PTR _client$4[ebp+8]
	sub	eax, DWORD PTR _client$4[ebp]
	push	eax
	call	?SK_SetWindowResX@@YAXJ@Z		; SK_SetWindowResX

; 3251 :         SK_SetWindowResY (client.bottom - client.top);

	mov	eax, DWORD PTR _client$4[ebp+12]
	sub	eax, DWORD PTR _client$4[ebp+4]
	push	eax
$LN113@DXGISwap_R:
	call	?SK_SetWindowResY@@YAXJ@Z		; SK_SetWindowResY
$LN112@DXGISwap_R:
	add	esp, 8

; 3275 :       }
; 3276 :     }
; 3277 :   }
; 3278 : 
; 3279 :   if (SUCCEEDED (ret))
; 3280 :   {
; 3281 :     SK_RunOnce (SK_DXGI_HookPresent (This));

	cmp	BYTE PTR ?first@?DN@??DXGISwap_ResizeTarget_Override@@YGJPAUIDXGISwapChain@@PBUDXGI_MODE_DESC@@@Z@4_NA, 0
	je	SHORT $LN23@DXGISwap_R
	push	0
	push	esi
	call	?SK_DXGI_HookPresent@@YAXPAUIDXGISwapChain@@_N@Z ; SK_DXGI_HookPresent
	add	esp, 8
	mov	BYTE PTR ?first@?DN@??DXGISwap_ResizeTarget_Override@@YGJPAUIDXGISwapChain@@PBUDXGI_MODE_DESC@@@Z@4_NA, 0
$LN23@DXGISwap_R:

; 3282 :     SK_RunOnce (MH_ApplyQueued      (    ));

	cmp	BYTE PTR ?first@?EB@??DXGISwap_ResizeTarget_Override@@YGJPAUIDXGISwapChain@@PBUDXGI_MODE_DESC@@@Z@4_NA, 0
	je	SHORT $LN24@DXGISwap_R
	call	_MH_ApplyQueued@0
	mov	BYTE PTR ?first@?EB@??DXGISwap_ResizeTarget_Override@@YGJPAUIDXGISwapChain@@PBUDXGI_MODE_DESC@@@Z@4_NA, 0
$LN24@DXGISwap_R:

; 3283 :   }
; 3284 : 
; 3285 :   return ret;
; 3286 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?DXGISwap_ResizeTarget_Override@@YGJPAUIDXGISwapChain@@PBUDXGI_MODE_DESC@@@Z$0:
	lea	ecx, DWORD PTR _auto_lock$6[ebp]
	jmp	??1?$lock_guard@VSK_Thread_CriticalSection@@@std@@QAE@XZ ; std::lock_guard<SK_Thread_CriticalSection>::~lock_guard<SK_Thread_CriticalSection>
__ehhandler$?DXGISwap_ResizeTarget_Override@@YGJPAUIDXGISwapChain@@PBUDXGI_MODE_DESC@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?DXGISwap_ResizeTarget_Override@@YGJPAUIDXGISwapChain@@PBUDXGI_MODE_DESC@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DXGISwap_ResizeTarget_Override@@YGJPAUIDXGISwapChain@@PBUDXGI_MODE_DESC@@@Z ENDP ; DXGISwap_ResizeTarget_Override
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\mutex
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\mutex
;	COMDAT ??1?$lock_guard@VSK_Thread_CriticalSection@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$lock_guard@VSK_Thread_CriticalSection@@@std@@QAE@XZ PROC ; std::lock_guard<SK_Thread_CriticalSection>::~lock_guard<SK_Thread_CriticalSection>, COMDAT
; _this$ = ecx
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h

; 266  :     LeaveCriticalSection (cs_);

	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp__LeaveCriticalSection@4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\mutex

; 230  : 		}

	ret	0
??1?$lock_guard@VSK_Thread_CriticalSection@@@std@@QAE@XZ ENDP ; std::lock_guard<SK_Thread_CriticalSection>::~lock_guard<SK_Thread_CriticalSection>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\mutex
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\mutex
;	COMDAT ??0?$lock_guard@VSK_Thread_CriticalSection@@@std@@QAE@AAVSK_Thread_CriticalSection@@@Z
_TEXT	SEGMENT
__Mtx$ = 8						; size = 4
??0?$lock_guard@VSK_Thread_CriticalSection@@@std@@QAE@AAVSK_Thread_CriticalSection@@@Z PROC ; std::lock_guard<SK_Thread_CriticalSection>::lock_guard<SK_Thread_CriticalSection>, COMDAT
; _this$ = ecx

; 218  : 		{	// construct and lock

	npad	2
	push	ebp
	mov	ebp, esp

; 217  : 		: _MyMutex(_Mtx)

	mov	eax, DWORD PTR __Mtx$[ebp]
	push	esi

; 218  : 		{	// construct and lock

	mov	esi, ecx
	mov	DWORD PTR [esi], eax
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h

; 261  :     EnterCriticalSection (cs_);

	push	DWORD PTR [eax]
	call	DWORD PTR __imp__EnterCriticalSection@4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\mutex

; 220  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$lock_guard@VSK_Thread_CriticalSection@@@std@@QAE@AAVSK_Thread_CriticalSection@@@Z ENDP ; std::lock_guard<SK_Thread_CriticalSection>::lock_guard<SK_Thread_CriticalSection>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\mutex
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
$T2 = -56						; size = 24
_client$3 = -32						; size = 16
_auto_lock$4 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_This$ = 8						; size = 4
_wszFullyFormatted$1$ = 12				; size = 4
_BufferCount$ = 12					; size = 4
_Width$ = 16						; size = 4
_Height$ = 20						; size = 4
_NewFormat$ = 24					; size = 4
_SwapChainFlags$ = 28					; size = 4
?DXGISwap_ResizeBuffers_Override@@YGJPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z PROC ; DXGISwap_ResizeBuffers_Override

; 3006 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?DXGISwap_ResizeBuffers_Override@@YGJPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	push	edi

; 3007 :   DXGI_LOG_CALL_I5 ( L"    IDXGISwapChain", L"ResizeBuffers         ",

	push	8192					; 00002000H
	call	??_U@YAPAXI@Z				; operator new[]
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN20@DXGISwap_R
	push	8192					; 00002000H
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN21@DXGISwap_R
$LN20@DXGISwap_R:
	xor	esi, esi
$LN21@DXGISwap_R:
	mov	ebx, DWORD PTR _BufferCount$[ebp]
	test	esi, esi
	je	$LN118@DXGISwap_R
	push	OFFSET $SG356324
	push	OFFSET $SG356325
	push	OFFSET $SG356326
	push	esi
	call	__swprintf
	mov	edi, DWORD PTR _SwapChainFlags$[ebp]
	lea	eax, DWORD PTR [esi+2048]
	push	edi
	push	DWORD PTR _NewFormat$[ebp]
	push	DWORD PTR _Height$[ebp]
	push	DWORD PTR _Width$[ebp]
	push	ebx
	push	OFFSET $SG356327
	push	eax
	call	__swprintf
	lea	eax, DWORD PTR [esi+2048]
	push	eax
	push	esi
	lea	ecx, DWORD PTR [eax+2048]
	push	OFFSET $SG356328
	push	ecx
	mov	DWORD PTR _wszFullyFormatted$1$[ebp], ecx
	call	__swprintf
	mov	eax, DWORD PTR __$ReturnAddr$[ebp]
	add	esp, 60					; 0000003cH
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?SK_SummarizeCaller@@YG?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAX@Z ; SK_SummarizeCaller
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN37@DXGISwap_R
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN37@DXGISwap_R:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3007 :   DXGI_LOG_CALL_I5 ( L"    IDXGISwapChain", L"ResizeBuffers         ",

	push	eax
	push	DWORD PTR _wszFullyFormatted$1$[ebp]
	push	OFFSET $SG356329
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T2[ebp+20]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3007 :   DXGI_LOG_CALL_I5 ( L"    IDXGISwapChain", L"ResizeBuffers         ",

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN47@DXGISwap_R

; 3609 : 			{
; 3610 : 			pointer _Ptr = _My_data._Bx._Ptr;
; 3611 : 			auto& _Al = this->_Getal();
; 3612 : 			_Al.destroy(_STD addressof(_My_data._Bx._Ptr));
; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
	push	eax
	push	DWORD PTR $T2[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN47@DXGISwap_R:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3007 :   DXGI_LOG_CALL_I5 ( L"    IDXGISwapChain", L"ResizeBuffers         ",

	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	jmp	SHORT $LN2@DXGISwap_R
$LN118@DXGISwap_R:
	mov	edi, DWORD PTR _SwapChainFlags$[ebp]
$LN2@DXGISwap_R:

; 3008 :                        L"%lu,%lu,%lu,fmt=%lu,0x%08X",
; 3009 :                          BufferCount, Width, Height,
; 3010 :                    (UINT)NewFormat, SwapChainFlags );
; 3011 : 
; 3012 :   // Can't do this if waitable
; 3013 :   if (dxgi_caps.present.waitable && config.render.framerate.swapchain_wait > 0)

	cmp	BYTE PTR ?dxgi_caps@@3Udxgi_caps_t@@A+4, 0
	je	SHORT $LN3@DXGISwap_R
	cmp	DWORD PTR ?config@@3Usk_config_t@@A+420, 0
	jle	SHORT $LN3@DXGISwap_R

; 3014 :     return S_OK;

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 3101 :   }
; 3102 : 
; 3103 :   return ret;
; 3104 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$LN3@DXGISwap_R:
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h

; 261  :     EnterCriticalSection (cs_);

	push	DWORD PTR ?cs_mmio@@3VSK_Thread_HybridSpinlock@@A ; cs_mmio
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\mutex

; 217  : 		: _MyMutex(_Mtx)

	mov	DWORD PTR _auto_lock$4[ebp], OFFSET ?cs_mmio@@3VSK_Thread_HybridSpinlock@@A ; cs_mmio
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h

; 261  :     EnterCriticalSection (cs_);

	call	DWORD PTR __imp__EnterCriticalSection@4
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3018 :     std::lock_guard <SK_Thread_CriticalSection> auto_lock (cs_mmio);

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3019 : 
; 3020 :     SK_D3D11_EndFrame        ();

	call	?SK_D3D11_EndFrame@@YAXXZ		; SK_D3D11_EndFrame

; 3021 :     SK_CEGUI_QueueResetD3D11 (); // Prior to the next present, reset the UI

	call	?SK_CEGUI_QueueResetD3D11@@YAXXZ	; SK_CEGUI_QueueResetD3D11
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h

; 266  :     LeaveCriticalSection (cs_);

	push	DWORD PTR ?cs_mmio@@3VSK_Thread_HybridSpinlock@@A ; cs_mmio
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3022 :   }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h

; 266  :     LeaveCriticalSection (cs_);

	call	DWORD PTR __imp__LeaveCriticalSection@4
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3026 :        (UINT)config.render.framerate.buffer_count !=  BufferCount &&

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+408
	cmp	eax, -1
	je	SHORT $LN4@DXGISwap_R
	cmp	eax, ebx
	je	SHORT $LN4@DXGISwap_R
	test	ebx, ebx
	je	SHORT $LN4@DXGISwap_R

; 3027 :        BufferCount                          !=  0 )
; 3028 :   {
; 3029 :     BufferCount = config.render.framerate.buffer_count;

	mov	ebx, eax

; 3030 :     dll_log.Log (L"[   DXGI   ]  >> Buffer Count Override: %lu buffers", BufferCount);

	push	ebx
	push	OFFSET $SG356332
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
$LN4@DXGISwap_R:

; 3031 :   }
; 3032 : 
; 3033 :   if (config.render.framerate.flip_discard && dxgi_caps.swapchain.allow_tearing)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+416, 0
	je	SHORT $LN5@DXGISwap_R
	cmp	DWORD PTR ?dxgi_caps@@3Udxgi_caps_t@@A+8, 0
	je	SHORT $LN5@DXGISwap_R

; 3034 :   {
; 3035 :     SwapChainFlags |= DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING;
; 3036 :     dll_log.Log ( L"[ DXGI 1.5 ]  >> Tearing Option:  Enable" );

	push	OFFSET $SG356334
	or	edi, 2048				; 00000800H
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	mov	DWORD PTR _SwapChainFlags$[ebp], edi
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8
$LN5@DXGISwap_R:

; 3037 :   }
; 3038 : 
; 3039 :   // TODO: Something if Fullscreen
; 3040 :   if (config.window.borderless && (! config.window.fullscreen))

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+728, 0
	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+760
	mov	edx, DWORD PTR ?config@@3Usk_config_t@@A+756
	je	SHORT $LN117@DXGISwap_R
	cmp	BYTE PTR ?config@@3Usk_config_t@@A+754, 0
	jne	SHORT $LN117@DXGISwap_R
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 425  :         bool isZero (void) { return x == 0 && y == 0; };

	test	edx, edx
	jne	SHORT $LN84@DXGISwap_R
	test	ecx, ecx
	je	SHORT $LN117@DXGISwap_R
$LN84@DXGISwap_R:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3044 :       Width  = config.window.res.override.x;

	mov	edi, edx

; 3045 :       Height = config.window.res.override.y;

	mov	esi, ecx
	jmp	SHORT $LN7@DXGISwap_R
$LN117@DXGISwap_R:
	mov	esi, DWORD PTR _Height$[ebp]
	mov	edi, DWORD PTR _Width$[ebp]
$LN7@DXGISwap_R:
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 251  :           bool isZero (void) { return x == 0 && y == 0; };

	cmp	DWORD PTR ?config@@3Usk_config_t@@A+460, 0
	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+464
	jne	SHORT $LN88@DXGISwap_R
	test	eax, eax
	je	SHORT $LN10@DXGISwap_R
$LN88@DXGISwap_R:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3057 :   if ((! config.render.dxgi.res.max.isZero ()) && Width > config.render.dxgi.res.max.x)

	cmp	edi, DWORD PTR ?config@@3Usk_config_t@@A+460
	cmova	edi, DWORD PTR ?config@@3Usk_config_t@@A+460
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 251  :           bool isZero (void) { return x == 0 && y == 0; };

	cmp	DWORD PTR ?config@@3Usk_config_t@@A+460, 0
	jne	SHORT $LN92@DXGISwap_R
	test	eax, eax
	je	SHORT $LN10@DXGISwap_R
$LN92@DXGISwap_R:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3059 :   if ((! config.render.dxgi.res.max.isZero ()) && Height > config.render.dxgi.res.max.y)

	cmp	esi, eax
	cmova	esi, eax
$LN10@DXGISwap_R:
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 246  :           bool isZero (void) { return x == 0 && y == 0; };

	cmp	DWORD PTR ?config@@3Usk_config_t@@A+452, 0
	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+456
	jne	SHORT $LN96@DXGISwap_R
	test	eax, eax
	jne	SHORT $LN100@DXGISwap_R
	jmp	SHORT $LN12@DXGISwap_R
$LN96@DXGISwap_R:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3062 :   if ((! config.render.dxgi.res.min.isZero ()) && Width < config.render.dxgi.res.min.x)

	cmp	edi, DWORD PTR ?config@@3Usk_config_t@@A+452
	cmovb	edi, DWORD PTR ?config@@3Usk_config_t@@A+452
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 246  :           bool isZero (void) { return x == 0 && y == 0; };

	cmp	DWORD PTR ?config@@3Usk_config_t@@A+452, 0
	jne	SHORT $LN100@DXGISwap_R
	test	eax, eax
	je	SHORT $LN12@DXGISwap_R
$LN100@DXGISwap_R:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3064 :   if ((! config.render.dxgi.res.min.isZero ()) && Height < config.render.dxgi.res.min.y)

	cmp	esi, eax
	cmovb	esi, eax
$LN12@DXGISwap_R:
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 425  :         bool isZero (void) { return x == 0 && y == 0; };

	test	edx, edx
	jne	SHORT $LN104@DXGISwap_R
	test	ecx, ecx
	je	SHORT $LN13@DXGISwap_R
$LN104@DXGISwap_R:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 3071 :     Width  = config.window.res.override.x;

	mov	edi, edx

; 3072 :     Height = config.window.res.override.y;

	mov	esi, ecx
$LN13@DXGISwap_R:

; 3073 :   }
; 3074 : 
; 3075 : 
; 3076 :   //NewFormat = DXGI_FORMAT_UNKNOWN;
; 3077 : 
; 3078 :   HRESULT     ret;
; 3079 :   DXGI_CALL ( ret, ResizeBuffers_Original ( This, BufferCount, Width, Height,

	push	DWORD PTR _SwapChainFlags$[ebp]
	push	DWORD PTR _NewFormat$[ebp]
	push	esi
	push	edi
	push	ebx
	push	DWORD PTR _This$[ebp]
	call	DWORD PTR ?ResizeBuffers_Original@@3P6GJPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@ZA ; ResizeBuffers_Original
	mov	ebx, eax
	push	ebx
	call	?SK_DescribeHRESULT@@YGPB_WJ@Z		; SK_DescribeHRESULT
	push	eax
	push	OFFSET $SG356343
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH

; 3080 :                                               NewFormat, SwapChainFlags ) );
; 3081 : 
; 3082 :   if (SUCCEEDED (ret))

	test	ebx, ebx
	js	SHORT $LN18@DXGISwap_R

; 3083 :   {
; 3084 :     if (Width != 0 && Height != 0)

	test	edi, edi
	je	SHORT $LN15@DXGISwap_R
	test	esi, esi
	je	SHORT $LN15@DXGISwap_R

; 3085 :     {
; 3086 :       SK_SetWindowResX (Width);

	push	edi
	call	?SK_SetWindowResX@@YAXJ@Z		; SK_SetWindowResX

; 3087 :       SK_SetWindowResY (Height);

	push	esi

; 3088 :     }
; 3089 : 
; 3090 :     else

	jmp	SHORT $LN120@DXGISwap_R
$LN15@DXGISwap_R:

; 3091 :     {
; 3092 :       RECT client;
; 3093 : 
; 3094 :       GetClientRect (game_window.hWnd, &client);

	lea	eax, DWORD PTR _client$3[ebp]
	push	eax
	push	DWORD PTR ?game_window@@3Usk_window_s@@A+4
	call	DWORD PTR __imp__GetClientRect@8

; 3095 :       SK_SetWindowResX (client.right  - client.left);

	mov	eax, DWORD PTR _client$3[ebp+8]
	sub	eax, DWORD PTR _client$3[ebp]
	push	eax
	call	?SK_SetWindowResX@@YAXJ@Z		; SK_SetWindowResX

; 3096 :       SK_SetWindowResY (client.bottom - client.top);

	mov	eax, DWORD PTR _client$3[ebp+12]
	sub	eax, DWORD PTR _client$3[ebp+4]
	push	eax
$LN120@DXGISwap_R:
	call	?SK_SetWindowResY@@YAXJ@Z		; SK_SetWindowResY
	add	esp, 8

; 3097 :     }
; 3098 : 
; 3099 :     SK_RunOnce (SK_DXGI_HookPresent (This));

	cmp	BYTE PTR ?first@?CN@??DXGISwap_ResizeBuffers_Override@@YGJPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z@4_NA, 0
	je	SHORT $LN17@DXGISwap_R
	push	0
	push	DWORD PTR _This$[ebp]
	call	?SK_DXGI_HookPresent@@YAXPAUIDXGISwapChain@@_N@Z ; SK_DXGI_HookPresent
	add	esp, 8
	mov	BYTE PTR ?first@?CN@??DXGISwap_ResizeBuffers_Override@@YGJPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z@4_NA, 0
$LN17@DXGISwap_R:

; 3100 :     SK_RunOnce (MH_ApplyQueued      (    ));

	cmp	BYTE PTR ?first@?DB@??DXGISwap_ResizeBuffers_Override@@YGJPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z@4_NA, 0
	je	SHORT $LN18@DXGISwap_R
	call	_MH_ApplyQueued@0
	mov	BYTE PTR ?first@?DB@??DXGISwap_ResizeBuffers_Override@@YGJPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z@4_NA, 0
$LN18@DXGISwap_R:

; 3101 :   }
; 3102 : 
; 3103 :   return ret;
; 3104 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, ebx
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?DXGISwap_ResizeBuffers_Override@@YGJPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z$1:
	lea	ecx, DWORD PTR _auto_lock$4[ebp]
	jmp	??1?$lock_guard@VSK_Thread_CriticalSection@@@std@@QAE@XZ ; std::lock_guard<SK_Thread_CriticalSection>::~lock_guard<SK_Thread_CriticalSection>
__ehhandler$?DXGISwap_ResizeBuffers_Override@@YGJPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z:
	mov	eax, OFFSET __ehfuncinfo$?DXGISwap_ResizeBuffers_Override@@YGJPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DXGISwap_ResizeBuffers_Override@@YGJPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@Z ENDP ; DXGISwap_ResizeBuffers_Override
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_desc$1 = -100						; size = 60
$T2 = -40						; size = 24
_client$3 = -16						; size = 16
__$ReturnAddr$ = 4					; size = 4
_This$ = 8						; size = 4
_Fullscreen$ = 12					; size = 4
_ret$1$ = 16						; size = 4
_wszFullyFormatted$1$ = 16				; size = 4
_pTarget$ = 16						; size = 4
?DXGISwap_SetFullscreenState_Override@@YGJPAUIDXGISwapChain@@HPAUIDXGIOutput@@@Z PROC ; DXGISwap_SetFullscreenState_Override

; 2906 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi

; 2907 :   DXGI_LOG_CALL_I2 ( L"    IDXGISwapChain", L"SetFullscreenState         ",

	push	8192					; 00002000H
	call	??_U@YAPAXI@Z				; operator new[]
	mov	edi, eax
	add	esp, 4
	test	edi, edi
	je	SHORT $LN17@DXGISwap_S
	push	8192					; 00002000H
	push	0
	push	edi
	call	_memset
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN18@DXGISwap_S
$LN17@DXGISwap_S:
	xor	edi, edi
$LN18@DXGISwap_S:
	mov	ebx, DWORD PTR _pTarget$[ebp]
	mov	esi, DWORD PTR _Fullscreen$[ebp]
	test	edi, edi
	je	$LN2@DXGISwap_S
	push	OFFSET $SG356249
	push	OFFSET $SG356250
	push	OFFSET $SG356251
	push	edi
	call	__swprintf
	mov	ecx, OFFSET $SG356253
	test	esi, esi
	push	ebx
	mov	eax, OFFSET $SG356252
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR [edi+2048]
	push	OFFSET $SG356254
	push	eax
	call	__swprintf
	lea	eax, DWORD PTR [edi+2048]
	push	eax
	push	edi
	lea	ecx, DWORD PTR [eax+2048]
	push	OFFSET $SG356255
	push	ecx
	mov	DWORD PTR _wszFullyFormatted$1$[ebp], ecx
	call	__swprintf
	mov	eax, DWORD PTR __$ReturnAddr$[ebp]
	add	esp, 48					; 00000030H
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?SK_SummarizeCaller@@YG?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAX@Z ; SK_SummarizeCaller
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN33@DXGISwap_S
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN33@DXGISwap_S:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2907 :   DXGI_LOG_CALL_I2 ( L"    IDXGISwapChain", L"SetFullscreenState         ",

	push	eax
	push	DWORD PTR _wszFullyFormatted$1$[ebp]
	push	OFFSET $SG356256
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T2[ebp+20]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2907 :   DXGI_LOG_CALL_I2 ( L"    IDXGISwapChain", L"SetFullscreenState         ",

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN43@DXGISwap_S
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T2[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN43@DXGISwap_S:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2907 :   DXGI_LOG_CALL_I2 ( L"    IDXGISwapChain", L"SetFullscreenState         ",

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@DXGISwap_S:
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h

; 8903 :     return (unsigned long) _InterlockedExchange((volatile long*) Target, (long) Value);

	mov	eax, 1
	mov	ecx, OFFSET ?__gui_reset@@3KC
	xchg	DWORD PTR [ecx], eax
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2914 :   if (config.render.framerate.swapchain_wait != 0)

	cmp	DWORD PTR ?config@@3Usk_config_t@@A+420, 0
	je	SHORT $LN3@DXGISwap_S

; 2915 :   {
; 2916 :     dll_log.Log ( L"[ DXGI 1.2 ]  >> Waitable SwapChain In Use, Skipping..." );

	push	OFFSET $SG356258
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8

; 2917 :     return S_OK;

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx

; 2995 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@DXGISwap_S:

; 2918 :   }
; 2919 : 
; 2920 :   if ( config.render.framerate.flip_discard && dxgi_caps.swapchain.allow_tearing )

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+416, 0
	je	SHORT $LN4@DXGISwap_S
	cmp	DWORD PTR ?dxgi_caps@@3Udxgi_caps_t@@A+8, 0
	je	SHORT $LN4@DXGISwap_S

; 2921 :   {
; 2922 :     Fullscreen = FALSE;
; 2923 :     dll_log.Log ( L"[ DXGI 1.5 ]  >> Tearing Override:  Enable" );

	push	OFFSET $SG356260
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	xor	esi, esi
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8

; 2924 :     pTarget = nullptr;

	xor	ebx, ebx
$LN4@DXGISwap_S:

; 2925 :   }
; 2926 : 
; 2927 :   if (config.display.force_fullscreen && Fullscreen == FALSE)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+500, 0
	je	SHORT $LN5@DXGISwap_S
	test	esi, esi
	jne	SHORT $LN5@DXGISwap_S

; 2928 :   {
; 2929 :     Fullscreen = TRUE;

	mov	esi, 1

; 2930 :     dll_log.Log ( L"[   DXGI   ]  >> Display Override "

	push	OFFSET $SG356263
	jmp	SHORT $LN71@DXGISwap_S
$LN5@DXGISwap_S:

; 2931 :                   L"(Requested: Windowed, Using: Fullscreen)" );
; 2932 :   }
; 2933 :   else if (config.display.force_windowed && Fullscreen == TRUE)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+501, 0
	je	SHORT $LN7@DXGISwap_S
	cmp	esi, 1
	jne	SHORT $LN7@DXGISwap_S

; 2934 :   {
; 2935 :     Fullscreen = FALSE;

	xor	esi, esi

; 2936 :     dll_log.Log ( L"[   DXGI   ]  >> Display Override "

	push	OFFSET $SG356265
$LN71@DXGISwap_S:
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8
$LN7@DXGISwap_S:

; 2937 :                   L"(Requested: Fullscreen, Using: Windowed)" );
; 2938 :   }
; 2939 : 
; 2940 :   if (request_mode_change == mode_change_request_e::Fullscreen && Fullscreen == FALSE)

	mov	eax, DWORD PTR ?request_mode_change@@3W4mode_change_request_e@@A ; request_mode_change
	cmp	eax, 1
	jne	SHORT $LN8@DXGISwap_S
	test	esi, esi
	jne	SHORT $LN10@DXGISwap_S

; 2941 :   {
; 2942 :     dll_log.Log ( L"[   DXGI   ]  >> Display Override "

	push	OFFSET $SG356268
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8

; 2943 :             L"User Initiated Fulllscreen Switch" );
; 2944 :     Fullscreen = TRUE;

	mov	esi, 1
	jmp	SHORT $LN10@DXGISwap_S
$LN8@DXGISwap_S:

; 2945 :   }
; 2946 :   else if (request_mode_change == mode_change_request_e::Windowed && Fullscreen == TRUE)

	test	eax, eax
	jne	SHORT $LN10@DXGISwap_S
	cmp	esi, 1
	jne	SHORT $LN10@DXGISwap_S

; 2947 :   {
; 2948 :     dll_log.Log ( L"[   DXGI   ]  >> Display Override "

	push	OFFSET $SG356270
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8

; 2949 :             L"User Initiated Windowed Switch" );
; 2950 :     Fullscreen = FALSE;

	xor	esi, esi
$LN10@DXGISwap_S:

; 2951 :   }
; 2952 : 
; 2953 :   HRESULT ret;
; 2954 :   DXGI_CALL (ret, SetFullscreenState_Original (This, Fullscreen, pTarget));

	mov	edi, DWORD PTR _This$[ebp]
	push	ebx
	push	esi
	push	edi
	call	DWORD PTR ?SetFullscreenState_Original@@3P6GJPAUIDXGISwapChain@@HPAUIDXGIOutput@@@ZA ; SetFullscreenState_Original
	mov	ebx, eax
	push	ebx
	mov	DWORD PTR _ret$1$[ebp], ebx
	call	?SK_DescribeHRESULT@@YGPB_WJ@Z		; SK_DescribeHRESULT
	push	eax
	push	OFFSET $SG356271
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH

; 2955 : 
; 2956 :   //
; 2957 :   // Necessary provisions for Fullscreen Flip Mode
; 2958 :   //
; 2959 :   if (SUCCEEDED (ret))

	test	ebx, ebx
	js	$LN11@DXGISwap_S

; 2960 :   {
; 2961 :     if (bFlipMode)

	cmp	BYTE PTR ?bFlipMode@@3_NA, 0		; bFlipMode
	je	SHORT $LN12@DXGISwap_S

; 2962 :     {
; 2963 :       // Steam Overlay does not like this, even though for compliance sake we are supposed to do it :(
; 2964 :       ResizeBuffers_Original ( This, 0, 0, 0, DXGI_FORMAT_UNKNOWN,

	push	2
	push	0
	push	0
	push	0
	push	0
	push	edi
	call	DWORD PTR ?ResizeBuffers_Original@@3P6GJPAUIDXGISwapChain@@IIIW4DXGI_FORMAT@@I@ZA ; ResizeBuffers_Original
$LN12@DXGISwap_S:

; 2965 :                                  DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH );
; 2966 :     }
; 2967 : 
; 2968 :     ///ResizeBuffers_Original (This, desc.BufferCount, desc.BufferDesc.Width,
; 2969 :     ///                          desc.BufferDesc.Height, desc.BufferDesc.Format, desc.Flags);
; 2970 : 
; 2971 :     DXGI_SWAP_CHAIN_DESC desc = { };

	push	60					; 0000003cH
	lea	eax, DWORD PTR _desc$1[ebp]
	push	0
	push	eax
	call	_memset

; 2972 : 
; 2973 :     if (SUCCEEDED (This->GetDesc (&desc)))

	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR _desc$1[ebp]
	add	esp, 12					; 0000000cH
	push	ecx
	push	edi
	call	DWORD PTR [eax+48]
	test	eax, eax
	js	SHORT $LN15@DXGISwap_S

; 2974 :     {
; 2975 :       if (desc.BufferDesc.Width != 0)

	mov	eax, DWORD PTR _desc$1[ebp]
	test	eax, eax
	je	SHORT $LN14@DXGISwap_S

; 2976 :       {
; 2977 :         SK_SetWindowResX (desc.BufferDesc.Width);

	push	eax
	call	?SK_SetWindowResX@@YAXJ@Z		; SK_SetWindowResX

; 2978 :         SK_SetWindowResY (desc.BufferDesc.Height);

	push	DWORD PTR _desc$1[ebp+4]

; 2979 :       }
; 2980 : 
; 2981 :       else

	jmp	SHORT $LN72@DXGISwap_S
$LN14@DXGISwap_S:

; 2982 :       {
; 2983 :         RECT client;
; 2984 : 
; 2985 :         GetClientRect (desc.OutputWindow, &client);

	lea	eax, DWORD PTR _client$3[ebp]
	push	eax
	push	DWORD PTR _desc$1[ebp+44]
	call	DWORD PTR __imp__GetClientRect@8

; 2986 :         SK_SetWindowResX (client.right  - client.left);

	mov	eax, DWORD PTR _client$3[ebp+8]
	sub	eax, DWORD PTR _client$3[ebp]
	push	eax
	call	?SK_SetWindowResX@@YAXJ@Z		; SK_SetWindowResX

; 2987 :         SK_SetWindowResY (client.bottom - client.top);

	mov	eax, DWORD PTR _client$3[ebp+12]
	sub	eax, DWORD PTR _client$3[ebp+4]
	push	eax
$LN72@DXGISwap_S:
	call	?SK_SetWindowResY@@YAXJ@Z		; SK_SetWindowResY
	add	esp, 8
$LN15@DXGISwap_S:

; 2988 :       }
; 2989 :     }
; 2990 : 
; 2991 :     SK_GetCurrentRenderBackend ().fullscreen_exclusive = Fullscreen;

	test	esi, esi
	setne	bl
	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend
	mov	BYTE PTR [eax+48], bl
	mov	ebx, DWORD PTR _ret$1$[ebp]
$LN11@DXGISwap_S:

; 2992 :   }
; 2993 : 
; 2994 :   return ret;

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx

; 2995 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?DXGISwap_SetFullscreenState_Override@@YGJPAUIDXGISwapChain@@HPAUIDXGIOutput@@@Z ENDP ; DXGISwap_SetFullscreenState_Override
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_This$ = 8						; size = 4
_pFullscreen$ = 12					; size = 4
_ppTarget$ = 16						; size = 4
?DXGISwap_GetFullscreenState_Override@@YGJPAUIDXGISwapChain@@PAHPAPAUIDXGIOutput@@@Z PROC ; DXGISwap_GetFullscreenState_Override

; 2896 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2898 : }

	pop	ebp

; 2897 :   return GetFullscreenState_Original (This, pFullscreen, ppTarget);

	jmp	DWORD PTR ?GetFullscreenState_Original@@3P6GJPAUIDXGISwapChain@@PAHPAPAUIDXGIOutput@@@ZA ; GetFullscreenState_Original
?DXGISwap_GetFullscreenState_Override@@YGJPAUIDXGISwapChain@@PAHPAPAUIDXGIOutput@@@Z ENDP ; DXGISwap_GetFullscreenState_Override
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
$T1 = -24						; size = 24
__$ReturnAddr$ = 4					; size = 4
_This$ = 8						; size = 4
?DXGIOutput_WaitForVBlank_Override@@YGJPAUIDXGIOutput@@@Z PROC ; DXGIOutput_WaitForVBlank_Override

; 2884 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	push	edi

; 2885 :   DXGI_LOG_CALL_I0 (L"       IDXGIOutput", L"WaitForVBlank         ");

	push	8192					; 00002000H
	call	??_U@YAPAXI@Z				; operator new[]
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN4@DXGIOutput
	push	8192					; 00002000H
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN5@DXGIOutput
$LN4@DXGIOutput:
	xor	esi, esi
$LN5@DXGIOutput:
	lea	edi, DWORD PTR [esi+2048]
	test	esi, esi
	je	$LN2@DXGIOutput
	push	ebx
	push	OFFSET $SG356217
	push	OFFSET $SG356218
	push	OFFSET $SG356219
	push	esi
	call	__swprintf
	push	OFFSET $SG356220
	push	edi
	call	__swprintf
	push	edi
	push	esi
	lea	ebx, DWORD PTR [edi+2048]
	push	OFFSET $SG356221
	push	ebx
	call	__swprintf
	mov	eax, DWORD PTR __$ReturnAddr$[ebp]
	add	esp, 40					; 00000028H
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?SK_SummarizeCaller@@YG?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAX@Z ; SK_SummarizeCaller
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN20@DXGIOutput
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN20@DXGIOutput:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2885 :   DXGI_LOG_CALL_I0 (L"       IDXGIOutput", L"WaitForVBlank         ");

	push	eax
	push	ebx
	push	OFFSET $SG356222
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T1[ebp+20]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2885 :   DXGI_LOG_CALL_I0 (L"       IDXGIOutput", L"WaitForVBlank         ");

	add	esp, 16					; 00000010H
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN30@DXGIOutput
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T1[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN30@DXGIOutput:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2885 :   DXGI_LOG_CALL_I0 (L"       IDXGIOutput", L"WaitForVBlank         ");

	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@DXGIOutput:

; 2886 : 
; 2887 :   return WaitForVBlank_Original (This);

	push	DWORD PTR _This$[ebp]
	call	DWORD PTR ?WaitForVBlank_Original@@3P6GJPAUIDXGIOutput@@@ZA ; WaitForVBlank_Original
	pop	edi
	pop	esi

; 2888 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?DXGIOutput_WaitForVBlank_Override@@YGJPAUIDXGIOutput@@@Z ENDP ; DXGIOutput_WaitForVBlank_Override
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_mode_to_match$ = -52					; size = 28
$T1 = -24						; size = 24
__$ReturnAddr$ = 4					; size = 4
_This$ = 8						; size = 4
_pModeToMatch$ = 12					; size = 4
_pClosestMatch$ = 16					; size = 4
_pConcernedDevice$ = 20					; size = 4
?DXGIOutput_FindClosestMatchingMode_Override@@YGJPAUIDXGIOutput@@PBUDXGI_MODE_DESC@@PAU2@PAUIUnknown@@@Z PROC ; DXGIOutput_FindClosestMatchingMode_Override

; 2834 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi

; 2835 :   DXGI_LOG_CALL_I3 ( L"       IDXGIOutput", L"FindClosestMatchingMode         ",

	push	8192					; 00002000H
	call	??_U@YAPAXI@Z				; operator new[]
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN6@DXGIOutput
	push	8192					; 00002000H
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN7@DXGIOutput
$LN6@DXGIOutput:
	xor	esi, esi
$LN7@DXGIOutput:
	push	edi
	lea	edi, DWORD PTR [esi+2048]
	test	esi, esi
	je	$LN2@DXGIOutput
	push	ebx
	push	OFFSET $SG356194
	push	OFFSET $SG356195
	push	OFFSET $SG356196
	push	esi
	call	__swprintf
	push	0
	push	0
	push	0
	push	OFFSET $SG356197
	push	edi
	call	__swprintf
	push	edi
	push	esi
	lea	ebx, DWORD PTR [edi+2048]
	push	OFFSET $SG356198
	push	ebx
	call	__swprintf
	mov	eax, DWORD PTR __$ReturnAddr$[ebp]
	add	esp, 52					; 00000034H
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?SK_SummarizeCaller@@YG?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAX@Z ; SK_SummarizeCaller
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN24@DXGIOutput
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN24@DXGIOutput:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2835 :   DXGI_LOG_CALL_I3 ( L"       IDXGIOutput", L"FindClosestMatchingMode         ",

	push	eax
	push	ebx
	push	OFFSET $SG356199
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T1[ebp+20]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2835 :   DXGI_LOG_CALL_I3 ( L"       IDXGIOutput", L"FindClosestMatchingMode         ",

	add	esp, 16					; 00000010H
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN34@DXGIOutput
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T1[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN34@DXGIOutput:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2835 :   DXGI_LOG_CALL_I3 ( L"       IDXGIOutput", L"FindClosestMatchingMode         ",

	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@DXGIOutput:

; 2836 :                        L"%lu, %lu, %lu",
; 2837 :                          0, 0, 0 );
; 2838 : 
; 2839 :   DXGI_MODE_DESC mode_to_match = *pModeToMatch;

	mov	eax, DWORD PTR _pModeToMatch$[ebp]
	pop	edi
	movups	xmm0, XMMWORD PTR [eax]
	mov	esi, DWORD PTR [eax+24]
	mov	DWORD PTR _mode_to_match$[ebp+24], esi
	movups	XMMWORD PTR _mode_to_match$[ebp], xmm0
	movq	xmm0, QWORD PTR [eax+16]

; 2840 : 
; 2841 :   if ( config.render.framerate.refresh_rate != -1 &&

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+424
	movq	QWORD PTR _mode_to_match$[ebp+16], xmm0
	cmp	eax, -1
	je	SHORT $LN3@DXGIOutput
	mov	edx, DWORD PTR _mode_to_match$[ebp+8]
	cmp	edx, eax
	je	SHORT $LN3@DXGIOutput

; 2844 :     dll_log.Log ( L"[   DXGI   ]  >> Refresh Override "

	mov	ecx, DWORD PTR _mode_to_match$[ebp+12]
	test	ecx, ecx
	je	SHORT $LN8@DXGIOutput
	movd	xmm0, edx
	cvtdq2pd xmm0, xmm0
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	cvtpd2ps xmm1, xmm0
	movd	xmm0, ecx
	cvtdq2pd xmm0, xmm0
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	cvtpd2ps xmm0, xmm0
	divss	xmm1, xmm0
	jmp	SHORT $LN61@DXGIOutput
$LN8@DXGIOutput:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits

; 1119 : 		return (__builtin_nanf("0"));

	movss	xmm1, DWORD PTR __real@7fc00000
$LN61@DXGIOutput:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2844 :     dll_log.Log ( L"[   DXGI   ]  >> Refresh Override "

	push	eax
	cvtps2pd xmm0, xmm1
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG356201
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 2845 :                   L"(Requested: %f, Using: %li)",
; 2846 :                     mode_to_match.RefreshRate.Denominator != 0 ?
; 2847 :                       static_cast <float> (mode_to_match.RefreshRate.Numerator) /
; 2848 :                       static_cast <float> (mode_to_match.RefreshRate.Denominator) :
; 2849 :                         std::numeric_limits <float>::quiet_NaN (),
; 2850 :                       config.render.framerate.refresh_rate
; 2851 :                 );
; 2852 : 
; 2853 :     mode_to_match.RefreshRate.Numerator   = (UINT)config.render.framerate.refresh_rate;

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+424
	add	esp, 20					; 00000014H

; 2854 :     mode_to_match.RefreshRate.Denominator =       1;

	mov	esi, DWORD PTR _mode_to_match$[ebp+24]
	mov	DWORD PTR _mode_to_match$[ebp+8], eax
	mov	DWORD PTR _mode_to_match$[ebp+12], 1
$LN3@DXGIOutput:

; 2855 :   }
; 2856 : 
; 2857 :   if ( config.render.dxgi.scaling_mode != -1 &&
; 2858 :        mode_to_match.Scaling           != config.render.dxgi.scaling_mode &&

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+472
	cmp	eax, -1
	je	SHORT $LN4@DXGIOutput
	cmp	esi, eax
	je	SHORT $LN4@DXGIOutput
	cmp	eax, 1
	je	SHORT $LN4@DXGIOutput

; 2859 :                        (DXGI_MODE_SCALING)config.render.dxgi.scaling_mode != DXGI_MODE_SCALING_CENTERED )
; 2860 :   {
; 2861 :     dll_log.Log ( L"[   DXGI   ]  >> Scaling Override "

	push	eax
	call	?SK_DXGI_DescribeScalingMode@@YAPB_WW4DXGI_MODE_SCALING@@@Z ; SK_DXGI_DescribeScalingMode
	add	esp, 4
	push	eax
	push	esi
	call	?SK_DXGI_DescribeScalingMode@@YAPB_WW4DXGI_MODE_SCALING@@@Z ; SK_DXGI_DescribeScalingMode
	add	esp, 4
	push	eax
	push	OFFSET $SG356203
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 2862 :                   L"(Requested: %s, Using: %s)",
; 2863 :                     SK_DXGI_DescribeScalingMode (
; 2864 :                       mode_to_match.Scaling
; 2865 :                     ),
; 2866 :                       SK_DXGI_DescribeScalingMode (
; 2867 :                         (DXGI_MODE_SCALING)config.render.dxgi.scaling_mode
; 2868 :                       )
; 2869 :                 );
; 2870 : 
; 2871 :     mode_to_match.Scaling =

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+472
	add	esp, 16					; 00000010H
	mov	DWORD PTR _mode_to_match$[ebp+24], eax
$LN4@DXGIOutput:

; 2872 :       (DXGI_MODE_SCALING)config.render.dxgi.scaling_mode;
; 2873 :   }
; 2874 : 
; 2875 :   pModeToMatch = &mode_to_match;
; 2876 : 
; 2877 :   return FindClosestMatchingMode_Original (This, pModeToMatch, pClosestMatch, pConcernedDevice );

	push	DWORD PTR _pConcernedDevice$[ebp]
	lea	eax, DWORD PTR _mode_to_match$[ebp]
	push	DWORD PTR _pClosestMatch$[ebp]
	push	eax
	push	DWORD PTR _This$[ebp]
	call	DWORD PTR ?FindClosestMatchingMode_Original@@3P6GJPAUIDXGIOutput@@PBUDXGI_MODE_DESC@@PAU2@PAUIUnknown@@@ZA ; FindClosestMatchingMode_Original
	pop	esi

; 2878 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?DXGIOutput_FindClosestMatchingMode_Override@@YGJPAUIDXGIOutput@@PBUDXGI_MODE_DESC@@PAU2@PAUIUnknown@@@Z ENDP ; DXGIOutput_FindClosestMatchingMode_Override
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
;	COMDAT ??$?RHIV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@@<lambda_8c641e4ce6091119a877a3a3b6ce9fff>@@QBE_NW4SK_DXGI_ResType@@AAHIV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@PAUDXGI_MODE_DESC@@@Z
_TEXT	SEGMENT
__Ans$2 = -24						; size = 8
__Ans$3 = -24						; size = 8
$T4 = -24						; size = 8
$T5 = -24						; size = 8
$T6 = -24						; size = 8
_max$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
tv550 = 8						; size = 4
_dim$ = 8						; size = 4
_last$ = 12						; size = 4
$T7 = 16						; size = 4
_i$8 = 16						; size = 4
$T9 = 16						; size = 4
_idx$ = 16						; size = 4
_covered$ = 20						; size = 8
$T10 = 28						; size = 1
$T11 = 28						; size = 1
$T12 = 28						; size = 1
$T13 = 28						; size = 1
$T14 = 28						; size = 1
$T15 = 28						; size = 4
$T16 = 28						; size = 4
$T17 = 28						; size = 4
_pDesc$ = 28						; size = 4
$T18 = 31						; size = 1
??$?RHIV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@@<lambda_8c641e4ce6091119a877a3a3b6ce9fff>@@QBE_NW4SK_DXGI_ResType@@AAHIV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@PAUDXGI_MODE_DESC@@@Z PROC ; <lambda_8c641e4ce6091119a877a3a3b6ce9fff>::operator()<int,unsigned int,std::set<int,std::less<int>,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 709  :  {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?RHIV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@@<lambda_8c641e4ce6091119a877a3a3b6ce9fff>@@QBE_NW4SK_DXGI_ResType@@AAHIV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@PAUDXGI_MODE_DESC@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	esi
	push	edi

; 710  :    UNREFERENCED_PARAMETER (last);
; 711  : 
; 712  :    auto& val = dim == WIDTH ? pDesc [idx].Width :

	mov	edi, DWORD PTR _idx$[ebp]
	mov	edx, DWORD PTR _dim$[ebp]
	mov	ecx, DWORD PTR _pDesc$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR [edi*8]
	sub	eax, edi
	test	edx, edx
	jne	SHORT $LN10@operator
	lea	esi, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv550[ebp], esi
	jmp	SHORT $LN11@operator
$LN10@operator:
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv550[ebp], eax
	lea	esi, DWORD PTR [eax+4]
$LN11@operator:

; 715  :    auto  max = dim == WIDTH ? config.render.dxgi.res.max.x :

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+464
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1603 : 		return (_Eqrange(_Keyval));

	lea	ecx, DWORD PTR _covered$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 715  :    auto  max = dim == WIDTH ? config.render.dxgi.res.max.x :

	test	edx, edx

; 716  :                               config.render.dxgi.res.max.y;
; 717  : 
; 718  :    bool covered_already = covered.count (idx) > 0;

	mov	DWORD PTR $T9[ebp], edi
	cmove	eax, DWORD PTR ?config@@3Usk_config_t@@A+460
	mov	DWORD PTR _max$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1603 : 		return (_Eqrange(_Keyval));

	lea	eax, DWORD PTR $T9[ebp]
	push	eax
	lea	eax, DWORD PTR __Ans$3[ebp]
	push	eax
	call	??$_Eqrange@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@V12@@1@ABH@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Eqrange<int>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1113 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));

	push	DWORD PTR $T13[ebp]
	push	DWORD PTR __Ans$3[ebp+4]
	push	DWORD PTR __Ans$3[ebp]
	call	??$_Distance1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@@std@@YAHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@0@0Uinput_iterator_tag@0@@Z ; std::_Distance1<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > >
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 721  :          val > max) || covered_already )

	mov	ecx, DWORD PTR _max$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1113 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));

	add	esp, 12					; 0000000cH
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 721  :          val > max) || covered_already )

	test	ecx, ecx
	je	SHORT $LN7@operator
	cmp	DWORD PTR [esi], ecx
	ja	SHORT $LN6@operator
$LN7@operator:
	test	eax, eax
	je	$LN5@operator
$LN6@operator:

; 722  :    {
; 723  :      for ( int i = idx ; i > 0 ; --i )

	mov	esi, edi
	mov	DWORD PTR _i$8[ebp], esi
	test	edi, edi
	jle	SHORT $LN213@operator
	mov	ecx, DWORD PTR _pDesc$[ebp]
	mov	edx, DWORD PTR ?config@@3Usk_config_t@@A+460
	npad	9
$LL4@operator:

; 726  :             config.render.dxgi.res.max.y >= pDesc [i].Height &&

	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi
	cmp	edx, DWORD PTR [ecx+eax*4]
	jb	SHORT $LN2@operator
	mov	edx, DWORD PTR ?config@@3Usk_config_t@@A+464
	cmp	edx, DWORD PTR [ecx+eax*4+4]
	jb	SHORT $LN214@operator
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1603 : 		return (_Eqrange(_Keyval));

	lea	eax, DWORD PTR _i$8[ebp]
	push	eax
	lea	eax, DWORD PTR __Ans$2[ebp]
	push	eax
	lea	ecx, DWORD PTR _covered$[ebp]
	call	??$_Eqrange@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@V12@@1@ABH@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Eqrange<int>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1113 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));

	push	DWORD PTR $T14[ebp]
	push	DWORD PTR __Ans$2[ebp+4]
	push	DWORD PTR __Ans$2[ebp]
	call	??$_Distance1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@@std@@YAHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@0@0Uinput_iterator_tag@0@@Z ; std::_Distance1<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > >
	mov	ecx, DWORD PTR _pDesc$[ebp]
	add	esp, 12					; 0000000cH
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 726  :             config.render.dxgi.res.max.y >= pDesc [i].Height &&

	test	eax, eax
	je	SHORT $LN209@operator
$LN214@operator:
	mov	edx, DWORD PTR ?config@@3Usk_config_t@@A+460
$LN2@operator:

; 722  :    {
; 723  :      for ( int i = idx ; i > 0 ; --i )

	dec	esi
	mov	DWORD PTR _i$8[ebp], esi
	test	esi, esi
	jg	SHORT $LL4@operator
$LN213@operator:

; 731  :          covered.insert (i);
; 732  :          return false;
; 733  :        }
; 734  :      }
; 735  : 
; 736  :      covered.insert (idx);

	mov	DWORD PTR $T16[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1209 : 		return (_Insert_nohint(false,

	lea	eax, DWORD PTR $T16[ebp]
	push	DWORD PTR $T11[ebp]
	lea	ecx, DWORD PTR _covered$[ebp]
	push	eax
	push	0
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??$_Insert_nohint@ABHU_Nil@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@1@_NABHU_Nil@1@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Insert_nohint<int const &,std::_Nil>
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 738  :      pDesc [idx].Width  = config.render.dxgi.res.max.x;

	mov	edx, DWORD PTR tv550[ebp]
	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+460

; 739  :      pDesc [idx].Height = config.render.dxgi.res.max.y;
; 740  : 
; 741  :      return true;

	mov	BYTE PTR $T18[ebp], 1
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+464
	mov	DWORD PTR [edx+4], eax
	jmp	SHORT $LN14@operator
$LN209@operator:

; 729  :          pDesc [idx] = pDesc [i];

	mov	edx, DWORD PTR tv550[ebp]
	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi

; 730  :          covered.insert (idx);

	mov	DWORD PTR $T17[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1209 : 		return (_Insert_nohint(false,

	push	DWORD PTR $T12[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 729  :          pDesc [idx] = pDesc [i];

	movups	xmm0, XMMWORD PTR [ecx+eax*4]
	movups	XMMWORD PTR [edx], xmm0
	movq	xmm0, QWORD PTR [ecx+eax*4+16]
	movq	QWORD PTR [edx+16], xmm0
	mov	eax, DWORD PTR [ecx+eax*4+24]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1209 : 		return (_Insert_nohint(false,

	lea	ecx, DWORD PTR _covered$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 729  :          pDesc [idx] = pDesc [i];

	mov	DWORD PTR [edx+24], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1209 : 		return (_Insert_nohint(false,

	lea	eax, DWORD PTR $T17[ebp]
	push	eax
	push	0
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	call	??$_Insert_nohint@ABHU_Nil@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@1@_NABHU_Nil@1@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Insert_nohint<int const &,std::_Nil>
	lea	eax, DWORD PTR _i$8[ebp]
	jmp	SHORT $LN216@operator
$LN5@operator:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 744  :    covered.insert (idx);

	mov	DWORD PTR $T15[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1209 : 		return (_Insert_nohint(false,

	lea	eax, DWORD PTR $T15[ebp]
$LN216@operator:
	push	DWORD PTR $T10[ebp]
	lea	ecx, DWORD PTR _covered$[ebp]
	push	eax
	push	0
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??$_Insert_nohint@ABHU_Nil@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@1@_NABHU_Nil@1@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Insert_nohint<int const &,std::_Nil>
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 746  :    return false;

	mov	BYTE PTR $T18[ebp], 0
$LN14@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR _covered$[ebp]

; 2184 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T7[ebp]
	push	ecx
	push	DWORD PTR [ecx]
	lea	ecx, DWORD PTR _covered$[ebp]
	push	eax
	call	?erase@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@V32@0@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	push	DWORD PTR _covered$[ebp]
	call	??3@YAXPAX@Z				; operator delete
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 746  :    return false;

	mov	al, BYTE PTR $T18[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	add	esp, 4
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 747  :  };

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?RHIV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@@<lambda_8c641e4ce6091119a877a3a3b6ce9fff>@@QBE_NW4SK_DXGI_ResType@@AAHIV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@PAUDXGI_MODE_DESC@@@Z$0:
	lea	ecx, DWORD PTR _covered$[ebp]
	jmp	??1?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QAE@XZ
__ehhandler$??$?RHIV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@@<lambda_8c641e4ce6091119a877a3a3b6ce9fff>@@QBE_NW4SK_DXGI_ResType@@AAHIV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@PAUDXGI_MODE_DESC@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$?RHIV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@@<lambda_8c641e4ce6091119a877a3a3b6ce9fff>@@QBE_NW4SK_DXGI_ResType@@AAHIV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@PAUDXGI_MODE_DESC@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?RHIV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@@<lambda_8c641e4ce6091119a877a3a3b6ce9fff>@@QBE_NW4SK_DXGI_ResType@@AAHIV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@PAUDXGI_MODE_DESC@@@Z ENDP ; <lambda_8c641e4ce6091119a877a3a3b6ce9fff>::operator()<int,unsigned int,std::set<int,std::less<int>,std::allocator<int> > >
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
;	COMDAT ??$?RHHV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@@<lambda_fc9a2ce0f8ba827916420a475022bd4b>@@QBE_NW4SK_DXGI_ResType@@AAHHV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@PAUDXGI_MODE_DESC@@@Z
_TEXT	SEGMENT
__Ans$2 = -24						; size = 8
__Ans$3 = -24						; size = 8
$T4 = -24						; size = 8
$T5 = -24						; size = 8
$T6 = -24						; size = 8
tv527 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_min$1$ = 8						; size = 4
_i$7 = 8						; size = 4
_dim$ = 8						; size = 4
_first$ = 12						; size = 4
$T8 = 16						; size = 1
$T9 = 16						; size = 1
$T10 = 16						; size = 1
$T11 = 16						; size = 1
$T12 = 16						; size = 1
_idx$ = 16						; size = 4
$T13 = 19						; size = 1
_covered$ = 20						; size = 8
$T14 = 28						; size = 4
_pDesc$ = 28						; size = 4
??$?RHHV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@@<lambda_fc9a2ce0f8ba827916420a475022bd4b>@@QBE_NW4SK_DXGI_ResType@@AAHHV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@PAUDXGI_MODE_DESC@@@Z PROC ; <lambda_fc9a2ce0f8ba827916420a475022bd4b>::operator()<int,int,std::set<int,std::less<int>,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 755  :  {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?RHHV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@@<lambda_fc9a2ce0f8ba827916420a475022bd4b>@@QBE_NW4SK_DXGI_ResType@@AAHHV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@PAUDXGI_MODE_DESC@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	esi
	push	edi

; 756  :    UNREFERENCED_PARAMETER (first);
; 757  : 
; 758  :    auto& val = dim == WIDTH ? pDesc [idx].Width :

	mov	edi, DWORD PTR _idx$[ebp]
	mov	edx, DWORD PTR _dim$[ebp]
	mov	ecx, DWORD PTR _pDesc$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR [edi*8]
	sub	eax, edi
	test	edx, edx
	jne	SHORT $LN10@operator
	lea	esi, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv527[ebp], esi
	jmp	SHORT $LN11@operator
$LN10@operator:
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv527[ebp], eax
	lea	esi, DWORD PTR [eax+4]
$LN11@operator:

; 761  :    auto  min = dim == WIDTH ? config.render.dxgi.res.min.x :

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+456
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1603 : 		return (_Eqrange(_Keyval));

	lea	ecx, DWORD PTR _covered$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 761  :    auto  min = dim == WIDTH ? config.render.dxgi.res.min.x :

	test	edx, edx
	cmove	eax, DWORD PTR ?config@@3Usk_config_t@@A+452
	mov	DWORD PTR _min$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1603 : 		return (_Eqrange(_Keyval));

	lea	eax, DWORD PTR _idx$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ans$3[ebp]
	push	eax
	call	??$_Eqrange@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@V12@@1@ABH@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Eqrange<int>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1113 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));

	push	DWORD PTR $T11[ebp]
	push	DWORD PTR __Ans$3[ebp+4]
	push	DWORD PTR __Ans$3[ebp]
	call	??$_Distance1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@@std@@YAHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@0@0Uinput_iterator_tag@0@@Z ; std::_Distance1<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > >
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 767  :          val < min) || covered_already )

	mov	ecx, DWORD PTR _min$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1113 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));

	add	esp, 12					; 0000000cH
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 767  :          val < min) || covered_already )

	test	ecx, ecx
	je	SHORT $LN7@operator
	cmp	DWORD PTR [esi], ecx
	jb	SHORT $LN6@operator
$LN7@operator:
	test	eax, eax
	je	$LN5@operator
$LN6@operator:

; 768  :    {
; 769  :      for ( int i = 0 ; i < idx ; ++i )

	xor	esi, esi
	mov	DWORD PTR _i$7[ebp], esi
	test	edi, edi
	jle	SHORT $LN213@operator
	mov	ecx, DWORD PTR _pDesc$[ebp]
	mov	edx, DWORD PTR ?config@@3Usk_config_t@@A+452
$LL4@operator:

; 772  :             config.render.dxgi.res.min.y <= pDesc [i].Height &&

	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi
	cmp	edx, DWORD PTR [ecx+eax*4]
	ja	SHORT $LN2@operator
	mov	edx, DWORD PTR ?config@@3Usk_config_t@@A+456
	cmp	edx, DWORD PTR [ecx+eax*4+4]
	ja	SHORT $LN214@operator
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1603 : 		return (_Eqrange(_Keyval));

	lea	eax, DWORD PTR _i$7[ebp]
	push	eax
	lea	eax, DWORD PTR __Ans$2[ebp]
	push	eax
	lea	ecx, DWORD PTR _covered$[ebp]
	call	??$_Eqrange@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@V12@@1@ABH@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Eqrange<int>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1113 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));

	push	DWORD PTR $T12[ebp]
	push	DWORD PTR __Ans$2[ebp+4]
	push	DWORD PTR __Ans$2[ebp]
	call	??$_Distance1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@@std@@YAHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@0@0Uinput_iterator_tag@0@@Z ; std::_Distance1<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > >
	mov	ecx, DWORD PTR _pDesc$[ebp]
	add	esp, 12					; 0000000cH
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 772  :             config.render.dxgi.res.min.y <= pDesc [i].Height &&

	test	eax, eax
	je	SHORT $LN209@operator
$LN214@operator:
	mov	edx, DWORD PTR ?config@@3Usk_config_t@@A+452
$LN2@operator:

; 768  :    {
; 769  :      for ( int i = 0 ; i < idx ; ++i )

	inc	esi
	mov	DWORD PTR _i$7[ebp], esi
	cmp	esi, edi
	jl	SHORT $LL4@operator
$LN213@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1209 : 		return (_Insert_nohint(false,

	push	DWORD PTR $T9[ebp]
	lea	eax, DWORD PTR _idx$[ebp]
	push	eax
	push	0
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	lea	ecx, DWORD PTR _covered$[ebp]
	call	??$_Insert_nohint@ABHU_Nil@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@1@_NABHU_Nil@1@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Insert_nohint<int const &,std::_Nil>
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 784  :      pDesc [idx].Width  = config.render.dxgi.res.min.x;

	mov	eax, DWORD PTR _idx$[ebp]
	mov	edx, DWORD PTR _pDesc$[ebp]

; 785  :      pDesc [idx].Height = config.render.dxgi.res.min.y;
; 786  : 
; 787  :      return true;

	mov	BYTE PTR $T13[ebp], 1
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+452
	mov	DWORD PTR [edx+ecx*4], eax
	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A+456
	mov	DWORD PTR [edx+ecx*4+4], eax
	jmp	SHORT $LN14@operator
$LN209@operator:

; 775  :          pDesc [idx] = pDesc [i];

	mov	edx, DWORD PTR tv527[ebp]
	lea	eax, DWORD PTR [esi*8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1209 : 		return (_Insert_nohint(false,

	push	DWORD PTR $T10[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 775  :          pDesc [idx] = pDesc [i];

	sub	eax, esi
	movups	xmm0, XMMWORD PTR [ecx+eax*4]
	movups	XMMWORD PTR [edx], xmm0
	movq	xmm0, QWORD PTR [ecx+eax*4+16]
	movq	QWORD PTR [edx+16], xmm0
	mov	eax, DWORD PTR [ecx+eax*4+24]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1209 : 		return (_Insert_nohint(false,

	lea	ecx, DWORD PTR _covered$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 775  :          pDesc [idx] = pDesc [i];

	mov	DWORD PTR [edx+24], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1209 : 		return (_Insert_nohint(false,

	lea	eax, DWORD PTR _idx$[ebp]
	push	eax
	push	0
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	call	??$_Insert_nohint@ABHU_Nil@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@1@_NABHU_Nil@1@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Insert_nohint<int const &,std::_Nil>
	lea	eax, DWORD PTR _i$7[ebp]
	jmp	SHORT $LN216@operator
$LN5@operator:
	lea	eax, DWORD PTR _idx$[ebp]
$LN216@operator:
	push	DWORD PTR $T8[ebp]
	lea	ecx, DWORD PTR _covered$[ebp]
	push	eax
	push	0
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??$_Insert_nohint@ABHU_Nil@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@1@_NABHU_Nil@1@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Insert_nohint<int const &,std::_Nil>
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 792  :    return false;

	mov	BYTE PTR $T13[ebp], 0
$LN14@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR _covered$[ebp]

; 2184 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T14[ebp]
	push	ecx
	push	DWORD PTR [ecx]
	lea	ecx, DWORD PTR _covered$[ebp]
	push	eax
	call	?erase@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@V32@0@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	push	DWORD PTR _covered$[ebp]
	call	??3@YAXPAX@Z				; operator delete
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 792  :    return false;

	mov	al, BYTE PTR $T13[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	add	esp, 4
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 793  :  };

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?RHHV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@@<lambda_fc9a2ce0f8ba827916420a475022bd4b>@@QBE_NW4SK_DXGI_ResType@@AAHHV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@PAUDXGI_MODE_DESC@@@Z$0:
	lea	ecx, DWORD PTR _covered$[ebp]
	jmp	??1?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QAE@XZ
__ehhandler$??$?RHHV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@@<lambda_fc9a2ce0f8ba827916420a475022bd4b>@@QBE_NW4SK_DXGI_ResType@@AAHHV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@PAUDXGI_MODE_DESC@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$?RHHV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@@<lambda_fc9a2ce0f8ba827916420a475022bd4b>@@QBE_NW4SK_DXGI_ResType@@AAHHV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@PAUDXGI_MODE_DESC@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?RHHV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@@<lambda_fc9a2ce0f8ba827916420a475022bd4b>@@QBE_NW4SK_DXGI_ResType@@AAHHV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@PAUDXGI_MODE_DESC@@@Z ENDP ; <lambda_fc9a2ce0f8ba827916420a475022bd4b>::operator()<int,int,std::set<int,std::less<int>,std::allocator<int> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??1?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QAE@XZ PROC ; std::set<int,std::less<int>,std::allocator<int> >::~set<int,std::less<int>,std::allocator<int> >, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [esi]

; 2184 : 		erase(begin(), end());

	push	eax
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?erase@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@V32@0@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	20					; 00000014H
	push	1
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QAE@XZ ENDP ; std::set<int,std::less<int>,std::allocator<int> >::~set<int,std::less<int>,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\set
;	COMDAT ??0?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Right$ = 8						; size = 4
??0?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QAE@ABV01@@Z PROC ; std::set<int,std::less<int>,std::allocator<int> >::set<int,std::less<int>,std::allocator<int> >, COMDAT
; _this$ = ecx

; 81   : 		{	// construct set by copying _Right

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 79   : 		: _Mybase(_Right,

	lea	eax, DWORD PTR $T1[ebp]

; 81   : 		{	// construct set by copying _Right

	mov	esi, ecx
	push	eax
	push	DWORD PTR __Right$[ebp]
	mov	DWORD PTR _this$[ebp], esi
	call	??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> ><std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > > >

; 82   : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QAE@ABV01@@Z ENDP ; std::set<int,std::less<int>,std::allocator<int> >::set<int,std::less<int>,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\set
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\set
;	COMDAT ??0?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QAE@XZ PROC ; std::set<int,std::less<int>,std::allocator<int> >::set<int,std::less<int>,std::allocator<int> >, COMDAT
; _this$ = ecx

; 70   : 		{	// construct empty set from defaults

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 560  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 561  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 714  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@HPAX@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\set

; 71   : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QAE@XZ ENDP ; std::set<int,std::less<int>,std::allocator<int> >::set<int,std::less<int>,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEABHPAU?$_Tree_node@HPAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEABHPAU?$_Tree_node@HPAX@2@@Z PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Key, COMDAT
; _this$ = ecx

; 2193 : 		{	// return reference to key in node

	npad	2
	push	ebp
	mov	ebp, esp

; 596  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 16					; 00000010H

; 2194 : 		return ((const key_type&)this->_Kfn(this->_Myval(_Pnode)));
; 2195 : 		}

	pop	ebp
	ret	4
?_Key@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEABHPAU?$_Tree_node@HPAX@2@@Z ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Key
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Kfn@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEABHABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEABHABH@Z PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Kfn, COMDAT
; _this$ = ecx

; 2188 : 		{	// get key from value

	npad	2
	push	ebp
	mov	ebp, esp

; 2189 : 		return (_Traits::_Kfn(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 2190 : 		}

	pop	ebp
	ret	4
?_Kfn@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEABHABH@Z ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Kfn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Tidy, COMDAT
; _this$ = ecx

; 2183 : 		{	// free all storage

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [ecx]

; 2184 : 		erase(begin(), end());

	push	eax
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?erase@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@V32@0@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::erase

; 2185 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@HPAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@HPAX@2@@Z PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 2127 : 		{	// promote left node to root of subtree

	npad	2
	push	ebp
	mov	ebp, esp

; 2128 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	esi
	mov	esi, DWORD PTR [edx]

; 2129 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [edx], eax

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [esi+8]

; 2130 : 
; 2131 : 		if (!this->_Isnil(this->_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN2@Rrotate

; 2132 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], edx
$LN2@Rrotate:

; 2133 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ecx]

; 2134 : 
; 2135 : 		if (_Wherenode == _Root())

	cmp	edx, DWORD PTR [eax+4]
	jne	SHORT $LN3@Rrotate

; 2136 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], esi

; 2141 : 
; 2142 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi+8], edx

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2144 : 		}

	pop	ebp
	ret	4
$LN3@Rrotate:

; 591  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [edx+4]

; 2137 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN5@Rrotate

; 2138 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], esi

; 2141 : 
; 2142 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi+8], edx

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2144 : 		}

	pop	ebp
	ret	4
$LN5@Rrotate:

; 2139 : 		else
; 2140 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], esi

; 2141 : 
; 2142 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi+8], edx

; 2143 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2144 : 		}

	pop	ebp
	ret	4
?_Rrotate@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@HPAX@2@@Z ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@HPAX@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@HPAX@2@XZ PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Root, COMDAT
; _this$ = ecx

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ecx]
	add	eax, 4

; 2123 : 		return (this->_Parent(this->_Myhead()));
; 2124 : 		}

	ret	0
?_Root@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@HPAX@2@XZ ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Root
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Rmost@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@HPAX@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@HPAX@2@XZ PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Rmost, COMDAT
; _this$ = ecx

; 591  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [ecx]
	add	eax, 8

; 2118 : 		return (this->_Right(this->_Myhead()));
; 2119 : 		}

	ret	0
?_Rmost@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@HPAX@2@XZ ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Rmost
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@HPAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@HPAX@2@@Z PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 2097 : 		{	// promote right node to root of subtree

	npad	2
	push	ebp
	mov	ebp, esp

; 591  : 		return ((_Nodepref)_Pnode->_Right);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	esi

; 2098 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

	mov	esi, DWORD PTR [edx+8]

; 2099 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edx+8], eax

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [esi]

; 2100 : 
; 2101 : 		if (!this->_Isnil(this->_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN2@Lrotate

; 2102 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], edx
$LN2@Lrotate:

; 2103 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ecx]

; 2104 : 
; 2105 : 		if (_Wherenode == _Root())

	cmp	edx, DWORD PTR [eax+4]
	jne	SHORT $LN3@Lrotate

; 2106 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], esi

; 2111 : 
; 2112 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi], edx

; 2113 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2114 : 		}

	pop	ebp
	ret	4
$LN3@Lrotate:

; 581  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [edx+4]

; 2107 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN5@Lrotate

; 2108 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], esi

; 2111 : 
; 2112 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi], edx

; 2113 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2114 : 		}

	pop	ebp
	ret	4
$LN5@Lrotate:

; 2109 : 		else
; 2110 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], esi

; 2111 : 
; 2112 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi], edx

; 2113 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2114 : 		}

	pop	ebp
	ret	4
?_Lrotate@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@HPAX@2@@Z ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@HPAX@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@HPAX@2@XZ PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Lmost, COMDAT
; _this$ = ecx

; 2093 : 		return (this->_Left(this->_Myhead()));

	mov	eax, DWORD PTR [ecx]

; 2094 : 		}

	ret	0
?_Lmost@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@HPAX@2@XZ ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Lmost
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Erase@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@HPAX@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@HPAX@2@@Z PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Erase, COMDAT
; _this$ = ecx

; 2048 : 		{	// free entire subtree, recursively

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi

; 2049 : 		for (_Nodeptr _Pnode = _Rootnode;

	mov	edi, DWORD PTR __Rootnode$[ebp]
	mov	ebx, ecx
	mov	esi, edi

; 2050 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	cmp	BYTE PTR [edi+13], 0
	jne	SHORT $LN3@Erase
$LL4@Erase:

; 2051 : 			{	// free subtrees, then node
; 2052 : 			_Erase(this->_Right(_Pnode));

	push	DWORD PTR [esi+8]
	mov	ecx, ebx
	call	?_Erase@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@HPAX@2@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Erase

; 2053 : 			_Pnode = this->_Left(_Pnode);

	mov	esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 2050 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	edi, esi
	cmp	BYTE PTR [esi+13], 0
	je	SHORT $LL4@Erase
$LN3@Erase:
	pop	edi
	pop	esi
	pop	ebx

; 2054 : 			this->_Getal().destroy(
; 2055 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2056 : 
; 2057 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2058 : 			}
; 2059 : 		}

	pop	ebp
	ret	4
?_Erase@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@HPAX@2@@Z ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Destroy_if_not_nil@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?_Destroy_if_not_nil@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXU_Nil@2@@Z PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Destroy_if_not_nil, COMDAT
; _this$ = ecx

; 1657 : 		}

	ret	4
?_Destroy_if_not_nil@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXU_Nil@2@@Z ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Destroy_if_not_nil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?equal_range@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@V12@@2@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?equal_range@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@V12@@2@ABH@Z PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::equal_range, COMDAT
; _this$ = ecx

; 1602 : 		{	// find range equivalent to _Keyval in nonmutable tree

	npad	2
	push	ebp
	mov	ebp, esp

; 1603 : 		return (_Eqrange(_Keyval));

	push	DWORD PTR __Keyval$[ebp]
	push	DWORD PTR ___$ReturnUdt$[ebp]
	call	??$_Eqrange@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@V12@@1@ABH@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Eqrange<int>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1604 : 		}

	pop	ebp
	ret	8
?equal_range@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@V12@@2@ABH@Z ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::equal_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?count@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEIABH@Z
_TEXT	SEGMENT
__Ans$ = -8						; size = 8
$T1 = 8							; size = 1
__Keyval$ = 8						; size = 4
?count@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEIABH@Z PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::count, COMDAT
; _this$ = ecx

; 1530 : 		{	// count all elements that match _Keyval

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1603 : 		return (_Eqrange(_Keyval));

	push	DWORD PTR __Keyval$[ebp]
	lea	eax, DWORD PTR __Ans$[ebp]
	push	eax
	call	??$_Eqrange@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@V12@@1@ABH@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Eqrange<int>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1113 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Ans$[ebp+4]
	push	DWORD PTR __Ans$[ebp]
	call	??$_Distance1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@@std@@YAHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@0@0Uinput_iterator_tag@0@@Z ; std::_Distance1<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> > > >
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1533 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?count@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEIABH@Z ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::count
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?clear@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::clear, COMDAT
; _this$ = ecx

; 1475 : 		{	// erase all

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?clear@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 1476 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1477 : 		this->_Orphan_ptr(nullptr_t{});
; 1478 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1479 : 
; 1480 : 		_Erase(_Root());

	mov	eax, DWORD PTR [edi]
	mov	ebx, DWORD PTR [eax+4]

; 2049 : 		for (_Nodeptr _Pnode = _Rootnode;

	mov	esi, ebx

; 2050 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	cmp	BYTE PTR [ebx+13], 0
	jne	SHORT $LN23@clear
	npad	4
$LL24@clear:

; 2051 : 			{	// free subtrees, then node
; 2052 : 			_Erase(this->_Right(_Pnode));

	push	DWORD PTR [esi+8]
	mov	ecx, edi
	call	?_Erase@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@HPAX@2@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Erase

; 2053 : 			_Pnode = this->_Left(_Pnode);

	mov	esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 2050 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	ebx, esi
	cmp	BYTE PTR [esi+13], 0
	je	SHORT $LL24@clear
$LN23@clear:

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [edi]

; 1485 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax], eax

; 591  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [edi]

; 1481 : 		_Root() = this->_Myhead();
; 1482 : 		_Lmost() = this->_Myhead();
; 1483 : 		_Rmost() = this->_Myhead();

	mov	DWORD PTR [eax+8], eax

; 1484 : 		this->_Mysize() = 0;

	mov	DWORD PTR [edi+4], 0

; 1485 : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?clear@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?clear@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?clear@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::clear
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@V32@0@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@V32@0@Z PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::erase, COMDAT
; _this$ = ecx

; 1452 : 		{	// erase [_First, _Last)

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 331  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __First$[ebp]

; 1453 : 		if (_First == begin() && _Last == end())

	mov	edx, DWORD PTR __Last$[ebp]
	push	esi
	push	edi
	mov	edi, ecx

; 581  : 		return ((_Nodepref)_Pnode->_Left);

	mov	esi, DWORD PTR [edi]

; 331  : 		return (this->_Ptr == _Right._Ptr);

	cmp	eax, DWORD PTR [esi]

; 1453 : 		if (_First == begin() && _Last == end())

	jne	SHORT $LN180@erase

; 331  : 		return (this->_Ptr == _Right._Ptr);

	cmp	edx, esi

; 1453 : 		if (_First == begin() && _Last == end())

	jne	SHORT $LN180@erase

; 1454 : 			{	// erase all
; 1455 : 			clear();

	call	?clear@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::clear

; 581  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [edi]
	pop	edi
	pop	esi

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 1463 : 			}
; 1464 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN180@erase:

; 331  : 		return (this->_Ptr == _Right._Ptr);

	cmp	eax, edx

; 1456 : 			return (begin());
; 1457 : 			}
; 1458 : 		else
; 1459 : 			{	// partial erase, one at a time
; 1460 : 			while (_First != _Last)

	je	SHORT $LN3@erase
$LL2@erase:

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	cmp	BYTE PTR [eax+13], 0

; 277  : 		_Myiter _Tmp = *this;

	mov	ecx, eax

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	jne	SHORT $LN136@erase

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	edx, DWORD PTR [eax+8]

; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN182@erase

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 608  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN192@erase
	npad	3
$LL147@erase:

; 609  : 			_Pnode = _Left(_Pnode);

	mov	edx, eax

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 608  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL147@erase

; 65   : 		else

	jmp	SHORT $LN192@erase
$LN182@erase:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

	mov	edx, DWORD PTR [eax+4]
	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN192@erase
$LL131@erase:
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN192@erase

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, edx
	mov	DWORD PTR __First$[ebp], eax
	mov	edx, DWORD PTR [edx+4]
	cmp	BYTE PTR [edx+13], 0
	je	SHORT $LL131@erase
$LN192@erase:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR __First$[ebp], edx
$LN136@erase:

; 1461 : 				erase(_First++);

	push	ecx
	lea	eax, DWORD PTR $T1[ebp]
	mov	ecx, edi
	push	eax
	call	?erase@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@V32@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::erase

; 331  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]

; 1456 : 			return (begin());
; 1457 : 			}
; 1458 : 		else
; 1459 : 			{	// partial erase, one at a time
; 1460 : 			while (_First != _Last)

	jne	SHORT $LL2@erase
$LN3@erase:

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx], eax

; 1462 : 			return (iterator(_First._Ptr, _STD addressof(this->_Get_data())));

	mov	eax, ecx

; 1463 : 			}
; 1464 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@V32@0@Z ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@V32@@Z
_TEXT	SEGMENT
tv1196 = -16						; size = 4
tv1197 = -12						; size = 4
tv1195 = -8						; size = 4
tv1191 = -8						; size = 4
tv1171 = -8						; size = 4
__Erasednode$1$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@V32@@Z PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::erase, COMDAT
; _this$ = ecx

; 1264 : 		{	// erase element at _Where

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 123  : 		return (_Ptr);

	mov	eax, DWORD PTR __Where$[ebp]
	push	ebx
	push	esi

; 1264 : 		{	// erase element at _Where

	mov	ebx, ecx

; 123  : 		return (_Ptr);

	mov	DWORD PTR __Erasednode$1$[ebp], eax
	push	edi

; 271  : 		++static_cast<_Mybase&>(*this);

	lea	ecx, DWORD PTR __Where$[ebp]
	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::operator++

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR __Erasednode$1$[ebp]
	mov	esi, DWORD PTR [ecx]

; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 		if (_Where._Getcont() != _STD addressof(this->_Get_data())
; 1267 : 			|| this->_Isnil(_Where._Mynode()))
; 1268 : 			{
; 1269 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1270 : 			}
; 1271 : 
; 1272 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1273 : 		++_Where;	// save successor iterator for return
; 1274 : 		_Orphan_ptr(_Erasednode);
; 1275 : 
; 1276 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1277 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1278 : 		++_Where;	// save successor iterator for return
; 1279 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1280 : 
; 1281 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1282 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1283 : 		_Nodeptr _Pnode = _Erasednode;
; 1284 : 
; 1285 : 		if (this->_Isnil(this->_Left(_Pnode)))

	cmp	BYTE PTR [esi+13], 0
	je	SHORT $LN5@erase

; 1286 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

	mov	edi, DWORD PTR [ecx+8]

; 1287 : 		else if (this->_Isnil(this->_Right(_Pnode)))

	jmp	SHORT $LN692@erase
$LN5@erase:
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LN7@erase

; 1288 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

	mov	edi, esi

; 1289 : 		else

	jmp	SHORT $LN692@erase
$LN7@erase:

; 123  : 		return (_Ptr);

	mov	edx, DWORD PTR __Where$[ebp]

; 1290 : 			{	// two subtrees, must lift successor node to replace erased
; 1291 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1292 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

	mov	edi, DWORD PTR [edx+8]

; 1293 : 			}
; 1294 : 
; 1295 : 		if (_Pnode == _Erasednode)

	cmp	edx, ecx
	jne	$LN9@erase
$LN692@erase:

; 1296 : 			{	// at most one subtree, relink it
; 1297 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1298 : 			if (!this->_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+13], 0
	mov	esi, DWORD PTR [ecx+4]
	jne	SHORT $LN11@erase

; 1299 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	DWORD PTR [edi+4], esi
$LN11@erase:

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ebx]

; 1300 : 
; 1301 : 			if (_Root() == _Erasednode)

	cmp	DWORD PTR [eax+4], ecx
	jne	SHORT $LN12@erase

; 1302 : 				_Root() = _Fixnode;	// link down from root

	mov	DWORD PTR [eax+4], edi

; 1303 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

	jmp	SHORT $LN15@erase
$LN12@erase:
	cmp	DWORD PTR [esi], ecx
	jne	SHORT $LN14@erase

; 1304 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	DWORD PTR [esi], edi

; 1305 : 			else

	jmp	SHORT $LN15@erase
$LN14@erase:

; 1306 : 				this->_Right(_Fixnodeparent) =

	mov	DWORD PTR [esi+8], edi
$LN15@erase:

; 581  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [ebx]

; 1307 : 					_Fixnode;	// link down to right
; 1308 : 
; 1309 : 			if (_Lmost() == _Erasednode)

	cmp	DWORD PTR [eax], ecx
	jne	SHORT $LN16@erase

; 1310 : 				_Lmost() = this->_Isnil(_Fixnode)

	cmp	BYTE PTR [edi+13], 0
	je	SHORT $LN42@erase
	mov	edx, esi
	jmp	SHORT $LN43@erase
$LN42@erase:

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edi]

; 691  : 		return (_Tree_val<_Val_types>::_Min(_Pnode));

	mov	edx, edi

; 608  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN166@erase
$LL165@erase:

; 609  : 			_Pnode = _Left(_Pnode);

	mov	edx, eax

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 608  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL165@erase
$LN166@erase:
	mov	eax, DWORD PTR [ebx]
$LN43@erase:

; 1310 : 				_Lmost() = this->_Isnil(_Fixnode)

	mov	DWORD PTR [eax], edx
$LN16@erase:

; 591  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [ebx]

; 1311 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1312 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree
; 1313 : 
; 1314 : 			if (_Rmost() == _Erasednode)

	cmp	DWORD PTR [eax+8], ecx
	jne	$LN373@erase

; 1315 : 				_Rmost() = this->_Isnil(_Fixnode)

	cmp	BYTE PTR [edi+13], 0
	je	SHORT $LN44@erase
	mov	edx, esi
	mov	DWORD PTR [eax+8], edx

; 1316 : 					? _Fixnodeparent	// largest is parent of erased node
; 1317 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1318 : 			}
; 1319 : 		else

	jmp	SHORT $LN373@erase
$LN44@erase:

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edi+8]

; 686  : 		return (_Tree_val<_Val_types>::_Max(_Pnode));

	mov	edx, edi

; 601  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN218@erase
$LL217@erase:

; 602  : 			_Pnode = _Right(_Pnode);

	mov	edx, eax

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx+8]

; 601  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL217@erase
$LN218@erase:
	mov	eax, DWORD PTR [ebx]

; 1315 : 				_Rmost() = this->_Isnil(_Fixnode)

	mov	DWORD PTR [eax+8], edx

; 1316 : 					? _Fixnodeparent	// largest is parent of erased node
; 1317 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1318 : 			}
; 1319 : 		else

	jmp	SHORT $LN373@erase
$LN9@erase:

; 1320 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1321 : 			this->_Parent(this->_Left(_Erasednode)) =

	mov	DWORD PTR [esi+4], edx

; 1322 : 				_Pnode;	// link left up
; 1323 : 			this->_Left(_Pnode) =

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1324 : 				this->_Left(_Erasednode);	// link successor down
; 1325 : 
; 1326 : 			if (_Pnode == this->_Right(_Erasednode))

	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN18@erase

; 1327 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	esi, edx

; 1328 : 			else

	jmp	SHORT $LN19@erase
$LN18@erase:

; 1329 : 				{	// successor further down, link in place of erased
; 1330 : 				_Fixnodeparent =
; 1331 : 					this->_Parent(_Pnode);	// parent is successor's
; 1332 : 				if (!this->_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+13], 0
	mov	esi, DWORD PTR [edx+4]
	jne	SHORT $LN20@erase

; 1333 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	DWORD PTR [edi+4], esi
$LN20@erase:

; 1334 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	DWORD PTR [esi], edi

; 1335 : 				this->_Right(_Pnode) =

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax

; 1336 : 					this->_Right(_Erasednode);	// link next down
; 1337 : 				this->_Parent(this->_Right(_Erasednode)) =

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+4], edx
$LN19@erase:

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ebx]

; 1338 : 					_Pnode;	// right up
; 1339 : 				}
; 1340 : 
; 1341 : 			if (_Root() == _Erasednode)

	cmp	DWORD PTR [eax+4], ecx
	jne	SHORT $LN21@erase

; 1342 : 				_Root() = _Pnode;	// link down from root

	mov	DWORD PTR [eax+4], edx

; 1343 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

	jmp	SHORT $LN24@erase
$LN21@erase:

; 581  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [ecx+4]

; 1343 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

	cmp	DWORD PTR [eax], ecx
	jne	SHORT $LN23@erase

; 1344 : 				this->_Left(this->_Parent(_Erasednode)) =

	mov	DWORD PTR [eax], edx

; 1345 : 					_Pnode;	// link down to left
; 1346 : 			else

	jmp	SHORT $LN24@erase
$LN23@erase:

; 1347 : 				this->_Right(this->_Parent(_Erasednode)) =

	mov	DWORD PTR [eax+8], edx
$LN24@erase:

; 1348 : 					_Pnode;	// link down to right
; 1349 : 
; 1350 : 			this->_Parent(_Pnode) =

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 67   : 	_Left = _STD move(_Right);

	mov	eax, DWORD PTR __Erasednode$1$[ebp]
	mov	cl, BYTE PTR [edx+12]
	mov	al, BYTE PTR [eax+12]
	mov	BYTE PTR [edx+12], al

; 68   : 	_Right = _STD move(_Tmp);

	mov	eax, DWORD PTR __Erasednode$1$[ebp]
	mov	BYTE PTR [eax+12], cl
	mov	ecx, eax
$LN373@erase:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1356 : 		if (this->_Color(_Erasednode) == this->_Black)

	cmp	BYTE PTR [ecx+12], 1
	jne	$LN25@erase

; 1357 : 			{	// erasing black link, must recolor/rebalance tree
; 1358 : 			for (; _Fixnode != _Root()
; 1359 : 				&& this->_Color(_Fixnode) == this->_Black;

	mov	eax, DWORD PTR [ebx]
	cmp	edi, DWORD PTR [eax+4]
	je	$LN3@erase
	npad	7
$LL4@erase:
	cmp	BYTE PTR [edi+12], 1
	mov	edx, esi
	mov	DWORD PTR tv1195[ebp], edx
	mov	DWORD PTR tv1197[ebp], esi
	mov	DWORD PTR tv1196[ebp], esi
	jne	$LN695@erase

; 1361 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

	mov	ecx, DWORD PTR [esi]
	cmp	edi, ecx
	jne	SHORT $LN26@erase

; 1362 : 					{	// fixup left subtree
; 1363 : 					_Pnode = this->_Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]

; 1364 : 					if (this->_Color(_Pnode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	jne	SHORT $LN28@erase

; 1365 : 						{	// rotate red up from right subtree
; 1366 : 						this->_Color(_Pnode) = this->_Black;

	mov	BYTE PTR [ecx+12], 1

; 1367 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1368 : 						_Lrotate(_Fixnodeparent);

	mov	ecx, ebx
	push	esi
	mov	BYTE PTR [esi+12], 0
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@HPAX@2@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Lrotate

; 1369 : 						_Pnode = this->_Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]
	mov	edx, esi
$LN28@erase:

; 1370 : 						}
; 1371 : 
; 1372 : 					if (this->_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+13], 0
	jne	$LN2@erase

; 1373 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1374 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1375 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN31@erase
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+12], 1
	je	SHORT $LN696@erase
$LN31@erase:

; 1376 : 						{	// redden right subtree with black children
; 1377 : 						this->_Color(_Pnode) = this->_Red;
; 1378 : 						_Fixnode = _Fixnodeparent;
; 1379 : 						}
; 1380 : 					else
; 1381 : 						{	// must rearrange right subtree
; 1382 : 						if (this->_Color(this->_Right(_Pnode))
; 1383 : 							== this->_Black)

	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN33@erase

; 1384 : 							{	// rotate red up from left sub-subtree
; 1385 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx]

; 1386 : 							this->_Color(_Pnode) = this->_Red;
; 1387 : 							_Rrotate(_Pnode);

	push	ecx
	mov	BYTE PTR [eax+12], 1
	mov	BYTE PTR [ecx+12], 0
	mov	ecx, ebx
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@HPAX@2@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Rrotate

; 1388 : 							_Pnode = this->_Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]
$LN33@erase:

; 1389 : 							}
; 1390 : 
; 1391 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

	mov	al, BYTE PTR [esi+12]
	mov	BYTE PTR [ecx+12], al

; 1392 : 						this->_Color(_Fixnodeparent) = this->_Black;

	mov	BYTE PTR [esi+12], 1

; 1393 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx+8]

; 1394 : 						_Lrotate(_Fixnodeparent);

	mov	ecx, ebx
	push	esi
	mov	BYTE PTR [eax+12], 1
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@HPAX@2@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Lrotate

; 1395 : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN695@erase
$LN26@erase:

; 1396 : 						}
; 1397 : 					}
; 1398 : 				else
; 1399 : 					{	// fixup right subtree
; 1400 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1401 : 					if (this->_Color(_Pnode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	jne	SHORT $LN34@erase

; 1402 : 						{	// rotate red up from left subtree
; 1403 : 						this->_Color(_Pnode) = this->_Black;

	mov	BYTE PTR [ecx+12], 1

; 1404 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1405 : 						_Rrotate(_Fixnodeparent);

	mov	ecx, ebx
	push	esi
	mov	BYTE PTR [esi+12], 0
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@HPAX@2@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Rrotate

; 1406 : 						_Pnode = this->_Left(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR tv1195[ebp]
$LN34@erase:

; 1407 : 						}
; 1408 : 
; 1409 : 					if (this->_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN2@erase

; 1410 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1411 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1412 : 						this->_Black
; 1413 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN37@erase
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN37@erase
$LN696@erase:

; 1414 : 						{	// redden left subtree with black children
; 1415 : 						this->_Color(_Pnode) = this->_Red;

	mov	BYTE PTR [ecx+12], 0
$LN2@erase:

; 1357 : 			{	// erasing black link, must recolor/rebalance tree
; 1358 : 			for (; _Fixnode != _Root()
; 1359 : 				&& this->_Color(_Fixnode) == this->_Black;

	mov	eax, DWORD PTR [ebx]

; 1360 : 				_Fixnodeparent = this->_Parent(_Fixnode))

	mov	esi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR tv1197[ebp]
	cmp	edx, DWORD PTR [eax+4]
	jne	$LL4@erase
	mov	edi, DWORD PTR tv1196[ebp]
$LN695@erase:
	mov	ecx, DWORD PTR __Erasednode$1$[ebp]
$LN3@erase:

; 1432 : 						break;	// tree now recolored/rebalanced
; 1433 : 						}
; 1434 : 					}
; 1435 : 
; 1436 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

	mov	BYTE PTR [edi+12], 1
$LN25@erase:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1444 : 		if (0 < this->_Mysize())

	mov	eax, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR __Where$[ebp]

; 1444 : 		if (0 < this->_Mysize())

	test	eax, eax
	je	SHORT $LN694@erase

; 1445 : 			--this->_Mysize();

	dec	eax
	mov	DWORD PTR [ebx+4], eax
$LN694@erase:

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR [eax], ecx

; 1446 : 
; 1447 : 		return (iterator(_Where._Ptr,
; 1448 : 			_STD addressof(this->_Get_data())));	// return successor iterator
; 1449 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN37@erase:

; 1416 : 						_Fixnode = _Fixnodeparent;
; 1417 : 						}
; 1418 : 					else
; 1419 : 						{	// must rearrange left subtree
; 1420 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN39@erase

; 1421 : 							{	// rotate red up from right sub-subtree
; 1422 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx+8]

; 1423 : 							this->_Color(_Pnode) = this->_Red;
; 1424 : 							_Lrotate(_Pnode);

	push	ecx
	mov	BYTE PTR [eax+12], 1
	mov	BYTE PTR [ecx+12], 0
	mov	ecx, ebx
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@HPAX@2@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Lrotate

; 1425 : 							_Pnode = this->_Left(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi]
$LN39@erase:

; 1426 : 							}
; 1427 : 
; 1428 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

	mov	al, BYTE PTR [esi+12]
	mov	BYTE PTR [ecx+12], al

; 1429 : 						this->_Color(_Fixnodeparent) = this->_Black;

	mov	BYTE PTR [esi+12], 1

; 1430 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx]

; 1431 : 						_Rrotate(_Fixnodeparent);

	mov	ecx, ebx
	push	esi
	mov	BYTE PTR [eax+12], 1
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@HPAX@2@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Rrotate
	jmp	SHORT $LN695@erase
?erase@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@V32@@Z ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?key_comp@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?key_comp@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::key_comp, COMDAT
; _this$ = ecx

; 1196 : 		{	// return object for comparing keys

	npad	2
	push	ebp
	mov	ebp, esp

; 1197 : 		return (this->_Getcomp());

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1198 : 		}

	pop	ebp
	ret	4
?key_comp@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBE?AU?$less@H@2@XZ ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::key_comp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::max_size, COMDAT
; _this$ = ecx

; 1181 : 		return (this->_Getal().max_size());

	mov	eax, 214748364				; 0cccccccH

; 1182 : 		}

	ret	0
?max_size@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?size@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::size, COMDAT
; _this$ = ecx

; 1176 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [ecx+4]

; 1177 : 		}

	ret	0
?size@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::end, COMDAT
; _this$ = ecx

; 1125 : 		{	// return iterator for end of mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1126 : 		return (iterator(this->_Myhead(), _STD addressof(this->_Get_data())));
; 1127 : 		}

	pop	ebp
	ret	4
?end@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::begin, COMDAT
; _this$ = ecx

; 1115 : 		{	// return iterator for beginning of mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 581  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [ecx]

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 1116 : 		return (iterator(_Lmost(), _STD addressof(this->_Get_data())));
; 1117 : 		}

	pop	ebp
	ret	4
?begin@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::~_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >, COMDAT
; _this$ = ecx

; 1098 : 		{	// destroy tree

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [esi]

; 2184 : 		erase(begin(), end());

	push	eax
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?erase@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@V32@0@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	20					; 00000014H
	push	1
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 1100 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::~_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
??0?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@@Z PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >, COMDAT
; _this$ = ecx

; 1019 : 		{	// construct empty tree from comparator

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 560  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 561  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 714  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@HPAX@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax

; 1020 : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@@Z ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@XZ PROC ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>,1>::_Get_second, COMDAT
; _this$ = ecx

; 343  : 		return (_Myval2);

	mov	eax, ecx

; 344  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@XZ ENDP ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@XZ PROC ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>,1>::_Get_second, COMDAT
; _this$ = ecx

; 338  : 		return (_Myval2);

	mov	eax, ecx

; 339  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@XZ ENDP ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@$00@std@@QBEABU?$less@H@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@$00@std@@QBEABU?$less@H@2@XZ PROC ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 323  : 		return (*this);

	mov	eax, ecx

; 324  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@$00@std@@QBEABU?$less@H@2@XZ ENDP ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@$00@std@@QAEAAU?$less@H@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@$00@std@@QAEAAU?$less@H@2@XZ PROC ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 318  : 		return (*this);

	mov	eax, ecx

; 319  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$less@H@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@2@$00@std@@QAEAAU?$less@H@2@XZ ENDP ; std::_Compressed_pair<std::less<int>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 343  : 		return (_Myval2);

	mov	eax, ecx

; 344  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 338  : 		return (_Myval2);

	mov	eax, ecx

; 339  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 323  : 		return (*this);

	mov	eax, ecx

; 324  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 318  : 		return (*this);

	mov	eax, ecx

; 319  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >,std::_Tree_val<std::_Tree_simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Min@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAPAU?$_Tree_node@HPAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAPAU?$_Tree_node@HPAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<int> >::_Min, COMDAT

; 607  : 		{	// return leftmost node in subtree at _Pnode

	npad	2
	push	ebp
	mov	ebp, esp

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [ecx]

; 608  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN15@Min
$LL2@Min:

; 609  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 608  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@Min
$LN15@Min:

; 610  : 		return (_Pnode);

	mov	eax, ecx

; 611  : 		}

	pop	ebp
	ret	0
?_Min@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAPAU?$_Tree_node@HPAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<int> >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAPAU?$_Tree_node@HPAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAPAU?$_Tree_node@HPAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<int> >::_Max, COMDAT

; 600  : 		{	// return rightmost node in subtree at _Pnode

	npad	2
	push	ebp
	mov	ebp, esp

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [ecx+8]

; 601  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN15@Max
$LL2@Max:

; 602  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 601  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@Max
$LN15@Max:

; 603  : 		return (_Pnode);

	mov	eax, ecx

; 604  : 		}

	pop	ebp
	ret	0
?_Max@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAPAU?$_Tree_node@HPAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<int> >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Myval@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAAAHPAU?$_Tree_node@HPAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAAAHPAU?$_Tree_node@HPAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<int> >::_Myval, COMDAT

; 595  : 		{	// return reference to value in node

	npad	2
	push	ebp
	mov	ebp, esp

; 596  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 16					; 00000010H

; 597  : 		}

	pop	ebp
	ret	0
?_Myval@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAAAHPAU?$_Tree_node@HPAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<int> >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Right@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAAAPAU?$_Tree_node@HPAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAAAPAU?$_Tree_node@HPAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<int> >::_Right, COMDAT

; 590  : 		{	// return reference to right pointer in node

	npad	2
	push	ebp
	mov	ebp, esp

; 591  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 8

; 592  : 		}

	pop	ebp
	ret	0
?_Right@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAAAPAU?$_Tree_node@HPAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<int> >::_Right
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Parent@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAAAPAU?$_Tree_node@HPAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAAAPAU?$_Tree_node@HPAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<int> >::_Parent, COMDAT

; 585  : 		{	// return reference to parent pointer in node

	npad	2
	push	ebp
	mov	ebp, esp

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 587  : 		}

	pop	ebp
	ret	0
?_Parent@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAAAPAU?$_Tree_node@HPAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<int> >::_Parent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Left@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAAAPAU?$_Tree_node@HPAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAAAPAU?$_Tree_node@HPAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<int> >::_Left, COMDAT

; 580  : 		{	// return reference to left pointer in node

	npad	2
	push	ebp
	mov	ebp, esp

; 581  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 582  : 		}

	pop	ebp
	ret	0
?_Left@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAAAPAU?$_Tree_node@HPAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<int> >::_Left
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAAADPAU?$_Tree_node@HPAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAAADPAU?$_Tree_node@HPAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<int> >::_Isnil, COMDAT

; 575  : 		{	// return reference to nil flag in node

	npad	2
	push	ebp
	mov	ebp, esp

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 13					; 0000000dH

; 577  : 		}

	pop	ebp
	ret	0
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAAADPAU?$_Tree_node@HPAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<int> >::_Isnil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Color@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAAADPAU?$_Tree_node@HPAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAAADPAU?$_Tree_node@HPAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<int> >::_Color, COMDAT

; 570  : 		{	// return reference to color in node

	npad	2
	push	ebp
	mov	ebp, esp

; 571  : 		return ((char&)_Pnode->_Color);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 12					; 0000000cH

; 572  : 		}

	pop	ebp
	ret	0
?_Color@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@SAAADPAU?$_Tree_node@HPAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<int> >::_Color
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<int> >::_Tree_val<std::_Tree_simple_types<int> >, COMDAT
; _this$ = ecx

; 560  : 		: _Myhead(),

	mov	DWORD PTR [ecx], 0

; 563  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<int> >::_Tree_val<std::_Tree_simple_types<int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??R?$less@H@std@@QBE_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@H@std@@QBE_NABH0@Z PROC			; std::less<int>::operator(), COMDAT
; _this$ = ecx

; 233  : 		{	// apply operator< to operands

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Right$[ebp]
	cmp	ecx, DWORD PTR [eax]
	setl	al

; 234  : 		return (_Left < _Right);
; 235  : 		}

	pop	ebp
	ret	8
??R?$less@H@std@@QBE_NABH0@Z ENDP			; std::less<int>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Mysize@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEABIXZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Mysize, COMDAT
; _this$ = ecx

; 960  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+4]

; 961  : 		}

	ret	0
?_Mysize@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEABIXZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Mysize@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEAAIXZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Mysize, COMDAT
; _this$ = ecx

; 955  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+4]

; 956  : 		}

	ret	0
?_Mysize@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEAAIXZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Myhead@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@HPAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@HPAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Myhead, COMDAT
; _this$ = ecx

; 950  : 		return (_Get_data()._Myhead);

	mov	eax, ecx

; 951  : 		}

	ret	0
?_Myhead@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@HPAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Myhead@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@HPAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@HPAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Myhead, COMDAT
; _this$ = ecx

; 945  : 		return (_Get_data()._Myhead);

	mov	eax, ecx

; 946  : 		}

	ret	0
?_Myhead@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@HPAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Get_data@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Get_data, COMDAT
; _this$ = ecx

; 940  : 		return (_Mypair._Get_second()._Get_second());

	mov	eax, ecx

; 941  : 		}

	ret	0
?_Get_data@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Get_data@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Get_data, COMDAT
; _this$ = ecx

; 935  : 		return (_Mypair._Get_second()._Get_second());

	mov	eax, ecx

; 936  : 		}

	ret	0
?_Get_data@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@H@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Getal@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Getal, COMDAT
; _this$ = ecx

; 930  : 		return (_Mypair._Get_second()._Get_first());

	mov	eax, ecx

; 931  : 		}

	ret	0
?_Getal@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Getal@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Getal, COMDAT
; _this$ = ecx

; 925  : 		return (_Mypair._Get_second()._Get_first());

	mov	eax, ecx

; 926  : 		}

	ret	0
?_Getal@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Getcomp@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEABU?$less@H@2@XZ
_TEXT	SEGMENT
?_Getcomp@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEABU?$less@H@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 920  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 921  : 		}

	ret	0
?_Getcomp@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEABU?$less@H@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Getcomp@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEAAU?$less@H@2@XZ
_TEXT	SEGMENT
?_Getcomp@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEAAU?$less@H@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 915  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 916  : 		}

	ret	0
?_Getcomp@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEAAU?$less@H@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Freenode0@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@HPAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freenode0@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@HPAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Freenode0, COMDAT
; _this$ = ecx

; 883  : 		{	// free non-value node using current allocator

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	20					; 00000014H
	push	1
	push	DWORD PTR __Pnode$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 891  : 		}

	pop	ebp
	ret	4
?_Freenode0@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@HPAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Freenode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Buynode0@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@HPAX@2@XZ
_TEXT	SEGMENT
?_Buynode0@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@HPAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Buynode0, COMDAT
; _this$ = ecx

; 864  : 		{	// allocate a non-value node

	npad	2
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	push	20					; 00000014H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 864  : 		{	// allocate a non-value node

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	edx, edx
	jne	SHORT $LN174@Buynode0
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN177@Buynode0:
$LN174@Buynode0:

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	lea	ecx, DWORD PTR [edx+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [edx], eax
	test	ecx, ecx
	je	SHORT $LN120@Buynode0
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax
$LN120@Buynode0:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 591  : 		return ((_Nodepref)_Pnode->_Right);

	lea	ecx, DWORD PTR [edx+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN167@Buynode0
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax
$LN167@Buynode0:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 879  : 		return (_Pnode);

	mov	eax, edx
	pop	esi

; 880  : 		}

	ret	0
$LN176@Buynode0:
?_Buynode0@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@HPAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Buynode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@HPAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@HPAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Freeheadnode, COMDAT
; _this$ = ecx

; 853  : 		{	// free head node using current allocator

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	20					; 00000014H
	push	1
	push	DWORD PTR __Pnode$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 861  : 		}

	pop	ebp
	ret	4
?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@HPAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@HPAX@2@XZ
_TEXT	SEGMENT
?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@HPAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Buyheadnode, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN146@Buyheadnod
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN146@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	lea	ecx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [eax], eax
	test	ecx, ecx
	je	SHORT $LN96@Buyheadnod
	mov	DWORD PTR [ecx], eax
$LN96@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 591  : 		return ((_Nodepref)_Pnode->_Right);

	lea	ecx, DWORD PTR [eax+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN131@Buyheadnod
	mov	DWORD PTR [ecx], eax
$LN131@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 847  : 		_Color(_Pnode) = _Black;

	mov	WORD PTR [eax+12], 257			; 00000101H

; 848  : 		_Isnil(_Pnode) = true;
; 849  : 		return (_Pnode);
; 850  : 		}

	ret	0
?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@HPAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Buyheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??1?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::~_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	20					; 00000014H
	push	1
	push	DWORD PTR [ecx]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 720  : 		}

	ret	0
??1?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::~_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Construct@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Construct@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Construct, COMDAT
; _this$ = ecx

; 713  : 		{	// construct head node

	npad	2
	push	esi
	mov	esi, ecx

; 714  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@HPAX@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax
	pop	esi

; 715  : 		}

	ret	0
?_Construct@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ??0?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
??0?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >, COMDAT
; _this$ = ecx

; 697  : 		{	// construct from comparator

	npad	2
	push	esi
	mov	esi, ecx

; 560  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 561  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 714  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@HPAX@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax

; 698  : 		_Construct();
; 699  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Min@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@SAPAU?$_Tree_node@HPAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@SAPAU?$_Tree_node@HPAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Min, COMDAT

; 690  : 		{	// return leftmost node in subtree at _Pnode

	npad	2
	push	ebp
	mov	ebp, esp

; 691  : 		return (_Tree_val<_Val_types>::_Min(_Pnode));

	mov	ecx, DWORD PTR __Pnode$[ebp]

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 608  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN17@Min
$LL4@Min:

; 609  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 608  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL4@Min
$LN17@Min:

; 691  : 		return (_Tree_val<_Val_types>::_Min(_Pnode));

	mov	eax, ecx

; 692  : 		}

	pop	ebp
	ret	0
?_Min@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@SAPAU?$_Tree_node@HPAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Max@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@SAPAU?$_Tree_node@HPAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@SAPAU?$_Tree_node@HPAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Max, COMDAT

; 685  : 		{	// return rightmost node in subtree at _Pnode

	npad	2
	push	ebp
	mov	ebp, esp

; 686  : 		return (_Tree_val<_Val_types>::_Max(_Pnode));

	mov	ecx, DWORD PTR __Pnode$[ebp]

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 601  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN17@Max
$LL4@Max:

; 602  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 601  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL4@Max
$LN17@Max:

; 686  : 		return (_Tree_val<_Val_types>::_Max(_Pnode));

	mov	eax, ecx

; 687  : 		}

	pop	ebp
	ret	0
?_Max@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@SAPAU?$_Tree_node@HPAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Myval@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@SAAAHPAU?$_Tree_node@HPAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@SAAAHPAU?$_Tree_node@HPAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Myval, COMDAT

; 680  : 		{	// return reference to value in node

	npad	2
	push	ebp
	mov	ebp, esp

; 596  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 16					; 00000010H

; 681  : 		return (_Tree_val<_Val_types>::_Myval(_Pnode));
; 682  : 		}

	pop	ebp
	ret	0
?_Myval@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@SAAAHPAU?$_Tree_node@HPAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Right@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@HPAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@HPAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Right, COMDAT

; 675  : 		{	// return reference to right pointer in node

	npad	2
	push	ebp
	mov	ebp, esp

; 591  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 8

; 676  : 		return (_Tree_val<_Val_types>::_Right(_Pnode));
; 677  : 		}

	pop	ebp
	ret	0
?_Right@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@HPAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Right
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Parent@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@HPAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@HPAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Parent, COMDAT

; 670  : 		{	// return reference to parent pointer in node

	npad	2
	push	ebp
	mov	ebp, esp

; 586  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 671  : 		return (_Tree_val<_Val_types>::_Parent(_Pnode));
; 672  : 		}

	pop	ebp
	ret	0
?_Parent@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@HPAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Parent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Left@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@HPAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@HPAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Left, COMDAT

; 665  : 		{	// return reference to left pointer in node

	npad	2
	push	ebp
	mov	ebp, esp

; 666  : 		return (_Tree_val<_Val_types>::_Left(_Pnode));

	mov	eax, DWORD PTR __Pnode$[ebp]

; 667  : 		}

	pop	ebp
	ret	0
?_Left@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@SAAAPAU?$_Tree_node@HPAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Left
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Isnil@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@HPAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@HPAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Isnil, COMDAT

; 660  : 		{	// return reference to nil flag in node

	npad	2
	push	ebp
	mov	ebp, esp

; 576  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 13					; 0000000dH

; 661  : 		return (_Tree_val<_Val_types>::_Isnil(_Pnode));
; 662  : 		}

	pop	ebp
	ret	0
?_Isnil@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@HPAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Isnil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
;	COMDAT ?_Color@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@HPAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@HPAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Color, COMDAT

; 655  : 		{	// return reference to color in node

	npad	2
	push	ebp
	mov	ebp, esp

; 571  : 		return ((char&)_Pnode->_Color);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 12					; 0000000cH

; 656  : 		return (_Tree_val<_Val_types>::_Color(_Pnode));
; 657  : 		}

	pop	ebp
	ret	0
?_Color@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@SAAADPAU?$_Tree_node@HPAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Color
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::max_size, COMDAT
; _this$ = ecx

; 1108 : 		return (_Mytraits::max_size(*this));

	mov	eax, 214748364				; 0cccccccH

; 1109 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@HPAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@HPAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::deallocate, COMDAT
; _this$ = ecx

; 1087 : 		{	// deallocate object at _Ptr, ignore size

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	20					; 00000014H
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 1088 : 		_Mybase::deallocate(_Ptr, _Count);
; 1089 : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@HPAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAEPAU?$_Tree_node@HPAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAEPAU?$_Tree_node@HPAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::allocate, COMDAT
; _this$ = ecx

; 1076 : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 1078 : 		}

	pop	ebp

; 1077 : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAEPAU?$_Tree_node@HPAX@2@I@Z ; std::allocator<std::_Tree_node<int,void *> >::allocate
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAEPAU?$_Tree_node@HPAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >, COMDAT
; _this$ = ecx

; 1048 : 		}

	mov	eax, ecx
	ret	4
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >, COMDAT
; _this$ = ecx

; 1038 : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QBE?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 1
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QBE?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 1013 : 		{	// get allocator to use

	npad	2
	push	ebp
	mov	ebp, esp

; 1014 : 		return (_Mytraits::select_on_container_copy_construction(*this));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1015 : 		}

	pop	ebp
	ret	8
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QBE?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@SA?AV?$allocator@U?$_Tree_node@HPAX@std@@@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@SA?AV?$allocator@U?$_Tree_node@HPAX@std@@@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<int,void *> > >::select_on_container_copy_construction, COMDAT

; 975  : 		{	// get allocator to use

	npad	2
	push	ebp
	mov	ebp, esp

; 976  : 		return (_Al);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 977  : 		}

	pop	ebp
	ret	0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@SA?AV?$allocator@U?$_Tree_node@HPAX@std@@@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<int,void *> > >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@HPAX@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@HPAX@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<int,void *> > >::max_size, COMDAT

; 970  : 		return (_Al.max_size());

	mov	eax, 214748364				; 0cccccccH

; 971  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@SAIABV?$allocator@U?$_Tree_node@HPAX@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<int,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator@U?$_Tree_node@HPAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$_Tree_node@HPAX@std@@@std@@QBEIXZ PROC ; std::allocator<std::_Tree_node<int,void *> >::max_size, COMDAT
; _this$ = ecx

; 851  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 214748364				; 0cccccccH

; 852  : 		}

	ret	0
?max_size@?$allocator@U?$_Tree_node@HPAX@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_Tree_node<int,void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAEPAU?$_Tree_node@HPAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAEPAU?$_Tree_node@HPAX@2@I@Z PROC ; std::allocator<std::_Tree_node<int,void *> >::allocate, COMDAT
; _this$ = ecx

; 827  : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 53   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 214748364				; 0cccccccH
	jbe	SHORT $LN5@allocate

; 58   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 2

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 69   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN9@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@allocate:
$LN9@allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 87   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@allocate:
$LN14@allocate:
	int	3
?allocate@?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAEPAU?$_Tree_node@HPAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<int,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAEXPAU?$_Tree_node@HPAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAEXPAU?$_Tree_node@HPAX@2@I@Z PROC ; std::allocator<std::_Tree_node<int,void *> >::deallocate, COMDAT
; _this$ = ecx

; 822  : 		{	// deallocate object at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	20					; 00000014H
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 824  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAEXPAU?$_Tree_node@HPAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<int,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::_Tree_node<int,void *> >::allocator<std::_Tree_node<int,void *> >, COMDAT
; _this$ = ecx

; 807  : 		{	// construct by copying (do nothing)
; 808  : 		}

	mov	eax, ecx
	ret	4
??0?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::_Tree_node<int,void *> >::allocator<std::_Tree_node<int,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Tree_node<int,void *> >::allocator<std::_Tree_node<int,void *> >, COMDAT
; _this$ = ecx

; 803  : 		{	// construct default allocator (do nothing)
; 804  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@U?$_Tree_node@HPAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Tree_node<int,void *> >::allocator<std::_Tree_node<int,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\set
;	COMDAT ?_Kfn@?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@SAABHABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@SAABHABH@Z PROC ; std::_Tset_traits<int,std::less<int>,std::allocator<int>,0>::_Kfn, COMDAT

; 34   : 		{	// extract key from element value

	npad	2
	push	ebp
	mov	ebp, esp

; 35   : 		return (_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 36   : 		}

	pop	ebp
	ret	0
?_Kfn@?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@SAABHABH@Z ENDP ; std::_Tset_traits<int,std::less<int>,std::allocator<int>,0>::_Kfn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\set
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\set
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\set
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\set
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\set
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\set
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\set
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\set
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
$T2 = -80						; size = 24
_coverage_min$3 = -56					; size = 8
_coverage_max$4 = -48					; size = 8
$T5 = -40						; size = 4
$T6 = -36						; size = 4
_last$7 = -32						; size = 4
_first$8 = -28						; size = 4
_hr$1$ = -24						; size = 4
_wszFullyFormatted$1$ = -24				; size = 4
_pDescLocal$1$ = -20					; size = 4
$T9 = -16						; size = 1
$T10 = -15						; size = 1
$T11 = -14						; size = 1
$T12 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_this$ = 8						; size = 4
_This$ = 8						; size = 4
_i$1$ = 12						; size = 4
_i$1$ = 12						; size = 4
_EnumFormat$ = 12					; size = 4
_this$ = 16						; size = 4
_this$ = 16						; size = 4
_Flags$ = 16						; size = 4
tv1551 = 19						; size = 1
tv1549 = 19						; size = 1
_pNumModes$ = 20					; size = 4
$T13 = 24						; size = 4
_pDesc$ = 24						; size = 4
?DXGIOutput_GetDisplayModeList_Override@@YGJPAUIDXGIOutput@@W4DXGI_FORMAT@@IPAIPAUDXGI_MODE_DESC@@@Z PROC ; DXGIOutput_GetDisplayModeList_Override

; 2708 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?DXGIOutput_GetDisplayModeList_Override@@YGJPAUIDXGIOutput@@W4DXGI_FORMAT@@IPAIPAUDXGI_MODE_DESC@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H
	push	esi

; 2709 :   if (pDesc != nullptr)

	mov	esi, DWORD PTR _pDesc$[ebp]
	push	edi
	test	esi, esi
	je	$LN614@DXGIOutput

; 2711 :     DXGI_LOG_CALL_I5 ( L"       IDXGIOutput", L"GetDisplayModeList         ",

	push	8192					; 00002000H
	call	??_U@YAPAXI@Z				; operator new[]
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN28@DXGIOutput
	push	8192					; 00002000H
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN29@DXGIOutput
$LN28@DXGIOutput:
	xor	esi, esi
$LN29@DXGIOutput:
	test	esi, esi
	je	$LN611@DXGIOutput
	push	OFFSET $SG356147
	push	OFFSET $SG356148
	push	OFFSET $SG356149
	push	esi
	call	__swprintf
	mov	edi, DWORD PTR _pNumModes$[ebp]
	mov	ecx, DWORD PTR _pDesc$[ebp]
	mov	eax, DWORD PTR _EnumFormat$[ebp]
	push	ecx
	push	DWORD PTR [edi]
	push	DWORD PTR _Flags$[ebp]
	push	eax
	mov	eax, DWORD PTR _This$[ebp]
	push	eax
	lea	eax, DWORD PTR [esi+2048]
	push	OFFSET $SG356150
	push	eax
	call	__swprintf
	lea	eax, DWORD PTR [esi+2048]
	push	eax
	push	esi
	lea	ecx, DWORD PTR [eax+2048]
	push	OFFSET $SG356151
	push	ecx
	mov	DWORD PTR _wszFullyFormatted$1$[ebp], ecx
	call	__swprintf
	mov	eax, DWORD PTR __$ReturnAddr$[ebp]
	add	esp, 60					; 0000003cH
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?SK_SummarizeCaller@@YG?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAX@Z ; SK_SummarizeCaller
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN53@DXGIOutput
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN53@DXGIOutput:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2711 :     DXGI_LOG_CALL_I5 ( L"       IDXGIOutput", L"GetDisplayModeList         ",

	push	eax
	push	DWORD PTR _wszFullyFormatted$1$[ebp]
	push	OFFSET $SG356152
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T2[ebp+20]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2711 :     DXGI_LOG_CALL_I5 ( L"       IDXGIOutput", L"GetDisplayModeList         ",

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN62@DXGIOutput

; 3609 : 			{
; 3610 : 			pointer _Ptr = _My_data._Bx._Ptr;
; 3611 : 			auto& _Al = this->_Getal();
; 3612 : 			_Al.destroy(_STD addressof(_My_data._Bx._Ptr));
; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
	push	eax
	push	DWORD PTR $T2[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN62@DXGIOutput:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2711 :     DXGI_LOG_CALL_I5 ( L"       IDXGIOutput", L"GetDisplayModeList         ",

	push	esi
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	esi, DWORD PTR _pDesc$[ebp]
	add	esp, 4
	jmp	SHORT $LN12@DXGIOutput
$LN611@DXGIOutput:
	mov	esi, DWORD PTR _pDesc$[ebp]
$LN614@DXGIOutput:
	mov	edi, DWORD PTR _pNumModes$[ebp]
$LN12@DXGIOutput:

; 2712 :                          L"%ph, %i, %02x, NumModes=%lu, %ph)",
; 2713 :                            This,
; 2714 :                            EnumFormat,
; 2715 :                                Flags,
; 2716 :                                  *pNumModes,
; 2717 :                                     pDesc );
; 2718 :   }
; 2719 : 
; 2720 :   if (config.render.dxgi.scaling_mode != -1)

	cmp	DWORD PTR ?config@@3Usk_config_t@@A+472, -1

; 2721 :     Flags |= DXGI_ENUM_MODES_SCALING;

	mov	eax, DWORD PTR _Flags$[ebp]
	je	SHORT $LN13@DXGIOutput
	or	eax, 2
	mov	DWORD PTR _Flags$[ebp], eax
$LN13@DXGIOutput:

; 2722 : 
; 2723 :   HRESULT hr =
; 2724 :     GetDisplayModeList_Original (

	push	esi
	push	edi
	push	eax
	push	DWORD PTR _EnumFormat$[ebp]
	push	DWORD PTR _This$[ebp]
	call	DWORD PTR ?GetDisplayModeList_Original@@3P6GJPAUIDXGIOutput@@W4DXGI_FORMAT@@IPAIPAUDXGI_MODE_DESC@@@ZA ; GetDisplayModeList_Original

; 2725 :       This,
; 2726 :         EnumFormat,
; 2727 :           Flags,
; 2728 :             pNumModes,
; 2729 :               pDesc );
; 2730 : 
; 2731 :   DXGI_MODE_DESC* pDescLocal = nullptr;

	mov	DWORD PTR _pDescLocal$1$[ebp], 0
	mov	ecx, eax
	mov	DWORD PTR _hr$1$[ebp], ecx

; 2732 : 
; 2733 :   if (pDesc == nullptr && SUCCEEDED (hr))

	test	esi, esi
	jne	SHORT $LN14@DXGIOutput
	test	ecx, ecx
	js	$LN609@DXGIOutput

; 2734 :   {
; 2735 :     pDescLocal = 

	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	shl	ecx, 2
	push	ecx
	mov	DWORD PTR $T13[ebp], ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	esi, eax
	mov	DWORD PTR _pDescLocal$1$[ebp], eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN30@DXGIOutput
	push	DWORD PTR $T13[ebp]
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN31@DXGIOutput
$LN30@DXGIOutput:
	xor	esi, esi
	mov	DWORD PTR _pDescLocal$1$[ebp], esi
$LN31@DXGIOutput:

; 2736 :       reinterpret_cast <DXGI_MODE_DESC *>(
; 2737 :         new uint8_t [sizeof (DXGI_MODE_DESC) * *pNumModes] { }
; 2738 :       );
; 2739 :     pDesc      = pDescLocal;
; 2740 : 
; 2741 :     hr =

	push	DWORD PTR _pDescLocal$1$[ebp]
	mov	eax, DWORD PTR _EnumFormat$[ebp]
	push	edi
	push	DWORD PTR _Flags$[ebp]
	mov	DWORD PTR _pDesc$[ebp], esi
	push	eax
	mov	eax, DWORD PTR _This$[ebp]
	push	eax
	call	DWORD PTR ?GetDisplayModeList_Original@@3P6GJPAUIDXGIOutput@@W4DXGI_FORMAT@@IPAIPAUDXGI_MODE_DESC@@@ZA ; GetDisplayModeList_Original
	mov	ecx, eax
	mov	DWORD PTR _hr$1$[ebp], ecx
$LN14@DXGIOutput:

; 2742 :       GetDisplayModeList_Original (
; 2743 :         This,
; 2744 :           EnumFormat,
; 2745 :             Flags,
; 2746 :               pNumModes,
; 2747 :                 pDesc );
; 2748 :   }
; 2749 : 
; 2750 :   if (SUCCEEDED (hr))

	test	ecx, ecx
	js	$LN25@DXGIOutput

; 2751 :   {
; 2752 :     int removed_count = 0;

	xor	edi, edi
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 246  :           bool isZero (void) { return x == 0 && y == 0; };

	cmp	DWORD PTR ?config@@3Usk_config_t@@A+452, edi
	jne	SHORT $LN94@DXGIOutput
	cmp	DWORD PTR ?config@@3Usk_config_t@@A+456, edi
	jne	SHORT $LN94@DXGIOutput

; 251  :           bool isZero (void) { return x == 0 && y == 0; };

	cmp	DWORD PTR ?config@@3Usk_config_t@@A+460, edi
	jne	SHORT $LN94@DXGIOutput
	cmp	DWORD PTR ?config@@3Usk_config_t@@A+464, edi
	je	$LN612@DXGIOutput
$LN94@DXGIOutput:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2755 :              config.render.dxgi.res.max.isZero () ) &&

	mov	eax, DWORD PTR _pNumModes$[ebp]
	cmp	DWORD PTR [eax], edi
	je	$LN586@DXGIOutput
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 714  : 		_Myhead() = _Buyheadnode();

	lea	ecx, DWORD PTR _coverage_min$3[ebp]

; 560  : 		: _Myhead(),

	mov	DWORD PTR _coverage_min$3[ebp], edi

; 561  : 		_Mysize(0)

	mov	DWORD PTR _coverage_min$3[ebp+4], edi

; 714  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@HPAX@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Buyheadnode
	mov	DWORD PTR _coverage_min$3[ebp], eax
	lea	ecx, DWORD PTR _coverage_max$4[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2761 :       std::set <int> coverage_min;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 560  : 		: _Myhead(),

	mov	DWORD PTR _coverage_max$4[ebp], 0

; 561  : 		_Mysize(0)

	mov	DWORD PTR _coverage_max$4[ebp+4], 0

; 714  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@HPAX@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Buyheadnode
	mov	edx, eax
	mov	DWORD PTR _coverage_max$4[ebp], edx
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 246  :           bool isZero (void) { return x == 0 && y == 0; };

	cmp	DWORD PTR ?config@@3Usk_config_t@@A+452, 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2762 :       std::set <int> coverage_max;

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 246  :           bool isZero (void) { return x == 0 && y == 0; };

	jne	SHORT $LN166@DXGIOutput
	cmp	DWORD PTR ?config@@3Usk_config_t@@A+456, 0
	je	SHORT $LN613@DXGIOutput
$LN166@DXGIOutput:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2767 :         for ( int i = *pNumModes - 1 ; i >= 0 ; --i )

	mov	eax, DWORD PTR _pNumModes$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	DWORD PTR _i$1$[ebp], ecx
	js	SHORT $LN3@DXGIOutput
$LL4@DXGIOutput:

; 2769 :           if (SK_DXGI_RestrictResMin (WIDTH,  first, i,  coverage_min, pDesc) |

	push	esi
	sub	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\set

; 79   : 		: _Mybase(_Right,

	lea	eax, DWORD PTR $T12[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2769 :           if (SK_DXGI_RestrictResMin (WIDTH,  first, i,  coverage_min, pDesc) |

	mov	ecx, esp
	mov	DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\set

; 79   : 		: _Mybase(_Right,

	push	eax
	lea	eax, DWORD PTR _coverage_min$3[ebp]
	push	eax
	call	??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> ><std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > > >
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2769 :           if (SK_DXGI_RestrictResMin (WIDTH,  first, i,  coverage_min, pDesc) |

	push	DWORD PTR _i$1$[ebp]
	lea	eax, DWORD PTR _first$8[ebp]
	mov	ecx, OFFSET ?SK_DXGI_RestrictResMin@@3V<lambda>@@A ; SK_DXGI_RestrictResMin
	push	eax
	push	0
	call	??$?RHHV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@@<lambda_fc9a2ce0f8ba827916420a475022bd4b>@@QBE_NW4SK_DXGI_ResType@@AAHHV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@PAUDXGI_MODE_DESC@@@Z ; <lambda_fc9a2ce0f8ba827916420a475022bd4b>::operator()<int,int,std::set<int,std::less<int>,std::allocator<int> > >
	push	esi
	sub	esp, 8
	mov	BYTE PTR tv1551[ebp], al
	mov	ecx, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\set

; 79   : 		: _Mybase(_Right,

	lea	eax, DWORD PTR $T11[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2769 :           if (SK_DXGI_RestrictResMin (WIDTH,  first, i,  coverage_min, pDesc) |

	mov	DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\set

; 79   : 		: _Mybase(_Right,

	push	eax
	lea	eax, DWORD PTR _coverage_min$3[ebp]
	push	eax
	call	??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> ><std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > > >
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2769 :           if (SK_DXGI_RestrictResMin (WIDTH,  first, i,  coverage_min, pDesc) |

	push	DWORD PTR _i$1$[ebp]
	lea	eax, DWORD PTR _first$8[ebp]
	mov	ecx, OFFSET ?SK_DXGI_RestrictResMin@@3V<lambda>@@A ; SK_DXGI_RestrictResMin
	push	eax
	push	1
	call	??$?RHHV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@@<lambda_fc9a2ce0f8ba827916420a475022bd4b>@@QBE_NW4SK_DXGI_ResType@@AAHHV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@PAUDXGI_MODE_DESC@@@Z ; <lambda_fc9a2ce0f8ba827916420a475022bd4b>::operator()<int,int,std::set<int,std::less<int>,std::allocator<int> > >
	mov	ecx, DWORD PTR _i$1$[ebp]
	dec	ecx
	or	al, BYTE PTR tv1551[ebp]
	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR _i$1$[ebp], ecx
	cmove	eax, edi
	mov	edi, eax
	test	ecx, ecx
	jns	SHORT $LL4@DXGIOutput

; 2767 :         for ( int i = *pNumModes - 1 ; i >= 0 ; --i )

	mov	edx, DWORD PTR _coverage_max$4[ebp]
$LN613@DXGIOutput:
	mov	eax, DWORD PTR _pNumModes$[ebp]
$LN3@DXGIOutput:
; File c:\users\andon\source\repos\specialk\include\specialk\config.h

; 251  :           bool isZero (void) { return x == 0 && y == 0; };

	cmp	DWORD PTR ?config@@3Usk_config_t@@A+460, 0
	jne	SHORT $LN208@DXGIOutput
	cmp	DWORD PTR ?config@@3Usk_config_t@@A+464, 0
	je	$LN6@DXGIOutput
$LN208@DXGIOutput:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2778 :         for ( UINT i = 0 ; i < *pNumModes ; ++i )

	cmp	DWORD PTR [eax], 0
	mov	DWORD PTR _i$1$[ebp], 0
	jbe	SHORT $LN6@DXGIOutput
$LL7@DXGIOutput:

; 2780 :           if (SK_DXGI_RestrictResMax (WIDTH,  last, i, coverage_max, pDesc) |

	push	esi
	sub	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\set

; 79   : 		: _Mybase(_Right,

	lea	eax, DWORD PTR $T10[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2780 :           if (SK_DXGI_RestrictResMax (WIDTH,  last, i, coverage_max, pDesc) |

	mov	ecx, esp
	mov	DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\set

; 79   : 		: _Mybase(_Right,

	push	eax
	lea	eax, DWORD PTR _coverage_max$4[ebp]
	push	eax
	call	??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> ><std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > > >
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2780 :           if (SK_DXGI_RestrictResMax (WIDTH,  last, i, coverage_max, pDesc) |

	push	DWORD PTR _i$1$[ebp]
	lea	eax, DWORD PTR _last$7[ebp]
	mov	ecx, OFFSET ?SK_DXGI_RestrictResMax@@3V<lambda>@@A ; SK_DXGI_RestrictResMax
	push	eax
	push	0
	call	??$?RHIV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@@<lambda_8c641e4ce6091119a877a3a3b6ce9fff>@@QBE_NW4SK_DXGI_ResType@@AAHIV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@PAUDXGI_MODE_DESC@@@Z ; <lambda_8c641e4ce6091119a877a3a3b6ce9fff>::operator()<int,unsigned int,std::set<int,std::less<int>,std::allocator<int> > >
	push	esi
	sub	esp, 8
	mov	BYTE PTR tv1549[ebp], al
	mov	ecx, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\set

; 79   : 		: _Mybase(_Right,

	lea	eax, DWORD PTR $T9[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2780 :           if (SK_DXGI_RestrictResMax (WIDTH,  last, i, coverage_max, pDesc) |

	mov	DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\set

; 79   : 		: _Mybase(_Right,

	push	eax
	lea	eax, DWORD PTR _coverage_max$4[ebp]
	push	eax
	call	??$?0U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABV01@$$QAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@1@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> ><std::_Wrap_alloc<std::allocator<std::_Tree_node<int,void *> > > >
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2780 :           if (SK_DXGI_RestrictResMax (WIDTH,  last, i, coverage_max, pDesc) |

	push	DWORD PTR _i$1$[ebp]
	lea	eax, DWORD PTR _last$7[ebp]
	mov	ecx, OFFSET ?SK_DXGI_RestrictResMax@@3V<lambda>@@A ; SK_DXGI_RestrictResMax
	push	eax
	push	1
	call	??$?RHIV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@@<lambda_8c641e4ce6091119a877a3a3b6ce9fff>@@QBE_NW4SK_DXGI_ResType@@AAHIV?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@PAUDXGI_MODE_DESC@@@Z ; <lambda_8c641e4ce6091119a877a3a3b6ce9fff>::operator()<int,unsigned int,std::set<int,std::less<int>,std::allocator<int> > >
	mov	ecx, DWORD PTR _i$1$[ebp]
	inc	ecx
	or	al, BYTE PTR tv1549[ebp]
	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR _i$1$[ebp], ecx
	cmove	eax, edi
	mov	edi, eax
	mov	eax, DWORD PTR _pNumModes$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jb	SHORT $LL7@DXGIOutput

; 2778 :         for ( UINT i = 0 ; i < *pNumModes ; ++i )

	mov	edx, DWORD PTR _coverage_max$4[ebp]
$LN6@DXGIOutput:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 2184 : 		erase(begin(), end());

	push	edx
	push	DWORD PTR [edx]
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	lea	ecx, DWORD PTR _coverage_max$4[ebp]
	call	?erase@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@V32@0@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	push	DWORD PTR _coverage_max$4[ebp]
	call	??3@YAXPAX@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR _coverage_min$3[ebp]

; 2184 : 		erase(begin(), end());

	lea	ecx, DWORD PTR _coverage_min$3[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xtree

; 2184 : 		erase(begin(), end());

	push	eax
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	?erase@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@V32@0@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	push	DWORD PTR _coverage_min$3[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN612@DXGIOutput:
	mov	eax, DWORD PTR _pNumModes$[ebp]
$LN586@DXGIOutput:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2787 :     if (config.render.dxgi.scaling_mode != -1)

	mov	esi, DWORD PTR ?config@@3Usk_config_t@@A+472
	cmp	esi, -1
	je	SHORT $LN9@DXGIOutput

; 2788 :     {
; 2789 :       if ( config.render.dxgi.scaling_mode != DXGI_MODE_SCALING_UNSPECIFIED &&

	test	esi, esi
	je	SHORT $LN9@DXGIOutput
	cmp	esi, 1
	je	SHORT $LN9@DXGIOutput

; 2790 :            config.render.dxgi.scaling_mode != DXGI_MODE_SCALING_CENTERED )
; 2791 :       {
; 2792 :         for ( INT i = static_cast <INT> (*pNumModes) - 1 ; i >= 0 ; --i )

	mov	edx, DWORD PTR [eax]
	sub	edx, 1
	js	SHORT $LN9@DXGIOutput
	mov	ecx, DWORD PTR _pDesc$[ebp]
	lea	eax, DWORD PTR [edx*8]
	sub	eax, edx
	lea	ecx, DWORD PTR [ecx+eax*4]
	add	ecx, 24					; 00000018H
$LL10@DXGIOutput:

; 2793 :         {
; 2794 :           if ( pDesc [i].Scaling != DXGI_MODE_SCALING_UNSPECIFIED &&
; 2795 :                pDesc [i].Scaling != DXGI_MODE_SCALING_CENTERED    &&

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN8@DXGIOutput
	cmp	eax, 1
	je	SHORT $LN8@DXGIOutput
	cmp	eax, esi
	je	SHORT $LN8@DXGIOutput

; 2796 :                pDesc [i].Scaling != config.render.dxgi.scaling_mode )
; 2797 :           {
; 2798 :             pDesc [i] = pDesc [i + 1];

	movups	xmm0, XMMWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+28]

; 2799 :             ++removed_count;

	inc	edi
	movups	XMMWORD PTR [ecx-24], xmm0
	movq	xmm0, QWORD PTR [ecx+20]
	movq	QWORD PTR [ecx-8], xmm0
	mov	DWORD PTR [ecx], eax
	mov	esi, DWORD PTR ?config@@3Usk_config_t@@A+472
$LN8@DXGIOutput:

; 2790 :            config.render.dxgi.scaling_mode != DXGI_MODE_SCALING_CENTERED )
; 2791 :       {
; 2792 :         for ( INT i = static_cast <INT> (*pNumModes) - 1 ; i >= 0 ; --i )

	sub	ecx, 28					; 0000001cH
	sub	edx, 1
	jns	SHORT $LL10@DXGIOutput
$LN9@DXGIOutput:

; 2800 :           }
; 2801 :         }
; 2802 :       }
; 2803 :     }
; 2804 : 
; 2805 :     if (pDesc != nullptr && pDescLocal == nullptr)

	cmp	DWORD PTR _pDesc$[ebp], 0
	je	SHORT $LN615@DXGIOutput
	mov	eax, DWORD PTR _pDescLocal$1$[ebp]
	test	eax, eax
	jne	SHORT $LN605@DXGIOutput

; 2806 :     {
; 2807 :       dll_log.Log ( L"[   DXGI   ]      >> %lu modes (%li removed)",

	mov	eax, DWORD PTR _pNumModes$[ebp]
	push	edi
	push	DWORD PTR [eax]
	push	OFFSET $SG356166
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 2816 : 
; 2817 :     pDescLocal = nullptr;
; 2818 :     pDesc      = nullptr;
; 2819 :   }
; 2820 : 
; 2821 :   return hr;

	mov	eax, DWORD PTR _hr$1$[ebp]
	add	esp, 16					; 00000010H

; 2822 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN615@DXGIOutput:
	mov	ecx, DWORD PTR _hr$1$[ebp]
$LN25@DXGIOutput:

; 2808 :                       *pNumModes,
; 2809 :                         removed_count );
; 2810 :     }
; 2811 :   }
; 2812 : 
; 2813 :   if (pDescLocal != nullptr)

	mov	eax, DWORD PTR _pDescLocal$1$[ebp]
	test	eax, eax
	je	SHORT $LN609@DXGIOutput
$LN605@DXGIOutput:

; 2814 :   {
; 2815 :     delete [] pDescLocal;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]

; 2816 : 
; 2817 :     pDescLocal = nullptr;
; 2818 :     pDesc      = nullptr;
; 2819 :   }
; 2820 : 
; 2821 :   return hr;

	mov	eax, DWORD PTR _hr$1$[ebp]
	add	esp, 4

; 2822 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN609@DXGIOutput:

; 2816 : 
; 2817 :     pDescLocal = nullptr;
; 2818 :     pDesc      = nullptr;
; 2819 :   }
; 2820 : 
; 2821 :   return hr;

	mov	eax, ecx

; 2822 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?DXGIOutput_GetDisplayModeList_Override@@YGJPAUIDXGIOutput@@W4DXGI_FORMAT@@IPAIPAUDXGI_MODE_DESC@@@Z$1:
	lea	ecx, DWORD PTR _coverage_min$3[ebp]
	jmp	??1?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QAE@XZ
__unwindfunclet$?DXGIOutput_GetDisplayModeList_Override@@YGJPAUIDXGIOutput@@W4DXGI_FORMAT@@IPAIPAUDXGI_MODE_DESC@@@Z$2:
	lea	ecx, DWORD PTR _coverage_max$4[ebp]
	jmp	??1?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QAE@XZ
__ehhandler$?DXGIOutput_GetDisplayModeList_Override@@YGJPAUIDXGIOutput@@W4DXGI_FORMAT@@IPAIPAUDXGI_MODE_DESC@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?DXGIOutput_GetDisplayModeList_Override@@YGJPAUIDXGIOutput@@W4DXGI_FORMAT@@IPAIPAUDXGI_MODE_DESC@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?DXGIOutput_GetDisplayModeList_Override@@YGJPAUIDXGIOutput@@W4DXGI_FORMAT@@IPAIPAUDXGI_MODE_DESC@@@Z ENDP ; DXGIOutput_GetDisplayModeList_Override
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComQIPtr@UIDXGISwapChain2@@$1?_GUID_a8be2ac4_199f_4946_b331_79599fb98de7@@3U__s_GUID@@B@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComQIPtr@UIDXGISwapChain2@@$1?_GUID_a8be2ac4_199f_4946_b331_79599fb98de7@@3U__s_GUID@@B@ATL@@QAE@XZ PROC ; ATL::CComQIPtr<IDXGISwapChain2,&_GUID_a8be2ac4_199f_4946_b331_79599fb98de7>::~CComQIPtr<IDXGISwapChain2,&_GUID_a8be2ac4_199f_4946_b331_79599fb98de7>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComQIPtr@UIDXGISwapChain2@@$1?_GUID_a8be2ac4_199f_4946_b331_79599fb98de7@@3U__s_GUID@@B@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN7@CComQIPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN7@CComQIPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComQIPtr@UIDXGISwapChain2@@$1?_GUID_a8be2ac4_199f_4946_b331_79599fb98de7@@3U__s_GUID@@B@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComQIPtr@UIDXGISwapChain2@@$1?_GUID_a8be2ac4_199f_4946_b331_79599fb98de7@@3U__s_GUID@@B@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComQIPtr@UIDXGISwapChain2@@$1?_GUID_a8be2ac4_199f_4946_b331_79599fb98de7@@3U__s_GUID@@B@ATL@@QAE@XZ ENDP ; ATL::CComQIPtr<IDXGISwapChain2,&_GUID_a8be2ac4_199f_4946_b331_79599fb98de7>::~CComQIPtr<IDXGISwapChain2,&_GUID_a8be2ac4_199f_4946_b331_79599fb98de7>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComQIPtr@UIDXGISwapChain2@@$1?_GUID_a8be2ac4_199f_4946_b331_79599fb98de7@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComQIPtr@UIDXGISwapChain2@@$1?_GUID_a8be2ac4_199f_4946_b331_79599fb98de7@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z PROC ; ATL::CComQIPtr<IDXGISwapChain2,&_GUID_a8be2ac4_199f_4946_b331_79599fb98de7>::CComQIPtr<IDXGISwapChain2,&_GUID_a8be2ac4_199f_4946_b331_79599fb98de7>, COMDAT
; _this$ = ecx

; 621  :     CComQIPtr(_Inout_opt_ IUnknown* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 622  :     {
; 623  :         if (lp != NULL)

	mov	ecx, DWORD PTR _lp$[ebp]

; 158  :         p = NULL;

	mov	DWORD PTR [esi], 0

; 622  :     {
; 623  :         if (lp != NULL)

	test	ecx, ecx
	je	SHORT $LN10@CComQIPtr

; 624  :         {
; 625  :             if (FAILED(lp->QueryInterface(*piid, (void **)&this->p)))

	mov	eax, DWORD PTR [ecx]
	push	esi
	push	OFFSET __GUID_a8be2ac4_199f_4946_b331_79599fb98de7
	push	ecx
	call	DWORD PTR [eax]
	test	eax, eax

; 627  :         }
; 628  :     }

	mov	eax, esi
	jns	SHORT $LN3@CComQIPtr

; 626  :                 this->p = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 627  :         }
; 628  :     }

	pop	ebp
	ret	4
$LN10@CComQIPtr:
	mov	eax, esi
$LN3@CComQIPtr:
	pop	esi
	pop	ebp
	ret	4
??0?$CComQIPtr@UIDXGISwapChain2@@$1?_GUID_a8be2ac4_199f_4946_b331_79599fb98de7@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z ENDP ; ATL::CComQIPtr<IDXGISwapChain2,&_GUID_a8be2ac4_199f_4946_b331_79599fb98de7>::CComQIPtr<IDXGISwapChain2,&_GUID_a8be2ac4_199f_4946_b331_79599fb98de7>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtr@UIDXGISwapChain2@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComPtr@UIDXGISwapChain2@@@ATL@@QAE@XZ PROC	; ATL::CComPtr<IDXGISwapChain2>::~CComPtr<IDXGISwapChain2>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComPtr@UIDXGISwapChain2@@@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@CComPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN4@CComPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComPtr@UIDXGISwapChain2@@@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComPtr@UIDXGISwapChain2@@@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComPtr@UIDXGISwapChain2@@@ATL@@QAE@XZ ENDP	; ATL::CComPtr<IDXGISwapChain2>::~CComPtr<IDXGISwapChain2>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UIDXGISwapChain2@@@ATL@@QAE@PAUIDXGISwapChain2@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtr@UIDXGISwapChain2@@@ATL@@QAE@PAUIDXGISwapChain2@@@Z PROC ; ATL::CComPtr<IDXGISwapChain2>::CComPtr<IDXGISwapChain2>, COMDAT
; _this$ = ecx

; 312  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi

; 312  :     {

	mov	esi, ecx

; 162  :         p = lp;

	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN6@CComPtr

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN6@CComPtr:

; 313  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtr@UIDXGISwapChain2@@@ATL@@QAE@PAUIDXGISwapChain2@@@Z ENDP ; ATL::CComPtr<IDXGISwapChain2>::CComPtr<IDXGISwapChain2>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UIDXGISwapChain2@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CComPtr@UIDXGISwapChain2@@@ATL@@QAE@XZ PROC	; ATL::CComPtr<IDXGISwapChain2>::CComPtr<IDXGISwapChain2>, COMDAT
; _this$ = ecx

; 158  :         p = NULL;

	mov	DWORD PTR [ecx], 0

; 308  :     {
; 309  :     }

	mov	eax, ecx
	ret	0
??0?$CComPtr@UIDXGISwapChain2@@@ATL@@QAE@XZ ENDP	; ATL::CComPtr<IDXGISwapChain2>::CComPtr<IDXGISwapChain2>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??8?$CComPtrBase@UIDXGISwapChain2@@@ATL@@QBE_NPAUIDXGISwapChain2@@@Z
_TEXT	SEGMENT
_pT$ = 8						; size = 4
??8?$CComPtrBase@UIDXGISwapChain2@@@ATL@@QBE_NPAUIDXGISwapChain2@@@Z PROC ; ATL::CComPtrBase<IDXGISwapChain2>::operator==, COMDAT
; _this$ = ecx

; 213  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR _pT$[ebp]
	sete	al

; 214  :         return p == pT;
; 215  :     }

	pop	ebp
	ret	4
??8?$CComPtrBase@UIDXGISwapChain2@@@ATL@@QBE_NPAUIDXGISwapChain2@@@Z ENDP ; ATL::CComPtrBase<IDXGISwapChain2>::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??9?$CComPtrBase@UIDXGISwapChain2@@@ATL@@QBE_NPAUIDXGISwapChain2@@@Z
_TEXT	SEGMENT
_pT$ = 8						; size = 4
??9?$CComPtrBase@UIDXGISwapChain2@@@ATL@@QBE_NPAUIDXGISwapChain2@@@Z PROC ; ATL::CComPtrBase<IDXGISwapChain2>::operator!=, COMDAT
; _this$ = ecx

; 209  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR _pT$[ebp]
	setne	al

; 210  :         return !operator==(pT);
; 211  :     }

	pop	ebp
	ret	4
??9?$CComPtrBase@UIDXGISwapChain2@@@ATL@@QBE_NPAUIDXGISwapChain2@@@Z ENDP ; ATL::CComPtrBase<IDXGISwapChain2>::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??C?$CComPtrBase@UIDXGISwapChain2@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIDXGISwapChain2@@@1@XZ
_TEXT	SEGMENT
??C?$CComPtrBase@UIDXGISwapChain2@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIDXGISwapChain2@@@1@XZ PROC ; ATL::CComPtrBase<IDXGISwapChain2>::operator->, COMDAT
; _this$ = ecx

; 197  :         ATLASSERT(p!=NULL);
; 198  :         return (_NoAddRefReleaseOnCComPtr<T>*)p;

	mov	eax, DWORD PTR [ecx]

; 199  :     }

	ret	0
??C?$CComPtrBase@UIDXGISwapChain2@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIDXGISwapChain2@@@1@XZ ENDP ; ATL::CComPtrBase<IDXGISwapChain2>::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??I?$CComPtrBase@UIDXGISwapChain2@@@ATL@@QAEPAPAUIDXGISwapChain2@@XZ
_TEXT	SEGMENT
??I?$CComPtrBase@UIDXGISwapChain2@@@ATL@@QAEPAPAUIDXGISwapChain2@@XZ PROC ; ATL::CComPtrBase<IDXGISwapChain2>::operator&, COMDAT
; _this$ = ecx

; 192  :         ATLASSERT(p==NULL);
; 193  :         return &p;

	mov	eax, ecx

; 194  :     }

	ret	0
??I?$CComPtrBase@UIDXGISwapChain2@@@ATL@@QAEPAPAUIDXGISwapChain2@@XZ ENDP ; ATL::CComPtrBase<IDXGISwapChain2>::operator&
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UIDXGISwapChain2@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UIDXGISwapChain2@@@ATL@@QAE@XZ PROC	; ATL::CComPtrBase<IDXGISwapChain2>::~CComPtrBase<IDXGISwapChain2>, COMDAT
; _this$ = ecx

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN2@CComPtrBas

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@CComPtrBas:

; 178  :     }

	ret	0
??1?$CComPtrBase@UIDXGISwapChain2@@@ATL@@QAE@XZ ENDP	; ATL::CComPtrBase<IDXGISwapChain2>::~CComPtrBase<IDXGISwapChain2>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UIDXGISwapChain2@@@ATL@@IAE@PAUIDXGISwapChain2@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtrBase@UIDXGISwapChain2@@@ATL@@IAE@PAUIDXGISwapChain2@@@Z PROC ; ATL::CComPtrBase<IDXGISwapChain2>::CComPtrBase<IDXGISwapChain2>, COMDAT
; _this$ = ecx

; 160  :     CComPtrBase(_Inout_opt_ T* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp

; 161  :     {
; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN4@CComPtrBas

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN4@CComPtrBas:

; 165  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtrBase@UIDXGISwapChain2@@@ATL@@IAE@PAUIDXGISwapChain2@@@Z ENDP ; ATL::CComPtrBase<IDXGISwapChain2>::CComPtrBase<IDXGISwapChain2>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UIDXGISwapChain2@@@ATL@@IAE@XZ
_TEXT	SEGMENT
??0?$CComPtrBase@UIDXGISwapChain2@@@ATL@@IAE@XZ PROC	; ATL::CComPtrBase<IDXGISwapChain2>::CComPtrBase<IDXGISwapChain2>, COMDAT
; _this$ = ecx

; 157  :     {
; 158  :         p = NULL;

	mov	DWORD PTR [ecx], 0

; 159  :     }

	mov	eax, ecx
	ret	0
??0?$CComPtrBase@UIDXGISwapChain2@@@ATL@@IAE@XZ ENDP	; ATL::CComPtrBase<IDXGISwapChain2>::CComPtrBase<IDXGISwapChain2>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComQIPtr@UIDXGISwapChain1@@$1?_GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa@@3U__s_GUID@@B@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComQIPtr@UIDXGISwapChain1@@$1?_GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa@@3U__s_GUID@@B@ATL@@QAE@XZ PROC ; ATL::CComQIPtr<IDXGISwapChain1,&_GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa>::~CComQIPtr<IDXGISwapChain1,&_GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComQIPtr@UIDXGISwapChain1@@$1?_GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa@@3U__s_GUID@@B@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN7@CComQIPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN7@CComQIPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComQIPtr@UIDXGISwapChain1@@$1?_GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa@@3U__s_GUID@@B@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComQIPtr@UIDXGISwapChain1@@$1?_GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa@@3U__s_GUID@@B@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComQIPtr@UIDXGISwapChain1@@$1?_GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa@@3U__s_GUID@@B@ATL@@QAE@XZ ENDP ; ATL::CComQIPtr<IDXGISwapChain1,&_GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa>::~CComQIPtr<IDXGISwapChain1,&_GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComQIPtr@UIDXGISwapChain1@@$1?_GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComQIPtr@UIDXGISwapChain1@@$1?_GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z PROC ; ATL::CComQIPtr<IDXGISwapChain1,&_GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa>::CComQIPtr<IDXGISwapChain1,&_GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa>, COMDAT
; _this$ = ecx

; 621  :     CComQIPtr(_Inout_opt_ IUnknown* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 622  :     {
; 623  :         if (lp != NULL)

	mov	ecx, DWORD PTR _lp$[ebp]

; 158  :         p = NULL;

	mov	DWORD PTR [esi], 0

; 622  :     {
; 623  :         if (lp != NULL)

	test	ecx, ecx
	je	SHORT $LN10@CComQIPtr

; 624  :         {
; 625  :             if (FAILED(lp->QueryInterface(*piid, (void **)&this->p)))

	mov	eax, DWORD PTR [ecx]
	push	esi
	push	OFFSET __GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa
	push	ecx
	call	DWORD PTR [eax]
	test	eax, eax

; 627  :         }
; 628  :     }

	mov	eax, esi
	jns	SHORT $LN3@CComQIPtr

; 626  :                 this->p = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 627  :         }
; 628  :     }

	pop	ebp
	ret	4
$LN10@CComQIPtr:
	mov	eax, esi
$LN3@CComQIPtr:
	pop	esi
	pop	ebp
	ret	4
??0?$CComQIPtr@UIDXGISwapChain1@@$1?_GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z ENDP ; ATL::CComQIPtr<IDXGISwapChain1,&_GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa>::CComQIPtr<IDXGISwapChain1,&_GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtr@UIDXGISwapChain1@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComPtr@UIDXGISwapChain1@@@ATL@@QAE@XZ PROC	; ATL::CComPtr<IDXGISwapChain1>::~CComPtr<IDXGISwapChain1>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComPtr@UIDXGISwapChain1@@@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@CComPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN4@CComPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComPtr@UIDXGISwapChain1@@@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComPtr@UIDXGISwapChain1@@@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComPtr@UIDXGISwapChain1@@@ATL@@QAE@XZ ENDP	; ATL::CComPtr<IDXGISwapChain1>::~CComPtr<IDXGISwapChain1>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UIDXGISwapChain1@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CComPtr@UIDXGISwapChain1@@@ATL@@QAE@XZ PROC	; ATL::CComPtr<IDXGISwapChain1>::CComPtr<IDXGISwapChain1>, COMDAT
; _this$ = ecx

; 158  :         p = NULL;

	mov	DWORD PTR [ecx], 0

; 308  :     {
; 309  :     }

	mov	eax, ecx
	ret	0
??0?$CComPtr@UIDXGISwapChain1@@@ATL@@QAE@XZ ENDP	; ATL::CComPtr<IDXGISwapChain1>::CComPtr<IDXGISwapChain1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??8?$CComPtrBase@UIDXGISwapChain1@@@ATL@@QBE_NPAUIDXGISwapChain1@@@Z
_TEXT	SEGMENT
_pT$ = 8						; size = 4
??8?$CComPtrBase@UIDXGISwapChain1@@@ATL@@QBE_NPAUIDXGISwapChain1@@@Z PROC ; ATL::CComPtrBase<IDXGISwapChain1>::operator==, COMDAT
; _this$ = ecx

; 213  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR _pT$[ebp]
	sete	al

; 214  :         return p == pT;
; 215  :     }

	pop	ebp
	ret	4
??8?$CComPtrBase@UIDXGISwapChain1@@@ATL@@QBE_NPAUIDXGISwapChain1@@@Z ENDP ; ATL::CComPtrBase<IDXGISwapChain1>::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??9?$CComPtrBase@UIDXGISwapChain1@@@ATL@@QBE_NPAUIDXGISwapChain1@@@Z
_TEXT	SEGMENT
_pT$ = 8						; size = 4
??9?$CComPtrBase@UIDXGISwapChain1@@@ATL@@QBE_NPAUIDXGISwapChain1@@@Z PROC ; ATL::CComPtrBase<IDXGISwapChain1>::operator!=, COMDAT
; _this$ = ecx

; 209  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR _pT$[ebp]
	setne	al

; 210  :         return !operator==(pT);
; 211  :     }

	pop	ebp
	ret	4
??9?$CComPtrBase@UIDXGISwapChain1@@@ATL@@QBE_NPAUIDXGISwapChain1@@@Z ENDP ; ATL::CComPtrBase<IDXGISwapChain1>::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??B?$CComPtrBase@UIDXGISwapChain1@@@ATL@@QBEPAUIDXGISwapChain1@@XZ
_TEXT	SEGMENT
??B?$CComPtrBase@UIDXGISwapChain1@@@ATL@@QBEPAUIDXGISwapChain1@@XZ PROC ; ATL::CComPtrBase<IDXGISwapChain1>::operator IDXGISwapChain1 *, COMDAT
; _this$ = ecx

; 181  :         return p;

	mov	eax, DWORD PTR [ecx]

; 182  :     }

	ret	0
??B?$CComPtrBase@UIDXGISwapChain1@@@ATL@@QBEPAUIDXGISwapChain1@@XZ ENDP ; ATL::CComPtrBase<IDXGISwapChain1>::operator IDXGISwapChain1 *
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UIDXGISwapChain1@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UIDXGISwapChain1@@@ATL@@QAE@XZ PROC	; ATL::CComPtrBase<IDXGISwapChain1>::~CComPtrBase<IDXGISwapChain1>, COMDAT
; _this$ = ecx

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN2@CComPtrBas

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@CComPtrBas:

; 178  :     }

	ret	0
??1?$CComPtrBase@UIDXGISwapChain1@@@ATL@@QAE@XZ ENDP	; ATL::CComPtrBase<IDXGISwapChain1>::~CComPtrBase<IDXGISwapChain1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UIDXGISwapChain1@@@ATL@@IAE@XZ
_TEXT	SEGMENT
??0?$CComPtrBase@UIDXGISwapChain1@@@ATL@@IAE@XZ PROC	; ATL::CComPtrBase<IDXGISwapChain1>::CComPtrBase<IDXGISwapChain1>, COMDAT
; _this$ = ecx

; 157  :     {
; 158  :         p = NULL;

	mov	DWORD PTR [ecx], 0

; 159  :     }

	mov	eax, ecx
	ret	0
??0?$CComPtrBase@UIDXGISwapChain1@@@ATL@@IAE@XZ ENDP	; ATL::CComPtrBase<IDXGISwapChain1>::CComPtrBase<IDXGISwapChain1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_desc$2 = -84						; size = 60
_desc$3 = -84						; size = 60
_pDevDXGI$4 = -24					; size = 4
_pDev$ = -20						; size = 4
_interval$2$ = -16					; size = 4
_pAdapter$5 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pFactory$6 = 8						; size = 4
_This$ = 8						; size = 4
_can_present$1$ = 11					; size = 1
_pSwapChain1$7 = 12					; size = 4
_SyncInterval$ = 12					; size = 4
_pSwapChain2$8 = 16					; size = 4
_Flags$ = 16						; size = 4
?PresentCallback@@YGJPAUIDXGISwapChain@@II@Z PROC	; PresentCallback

; 2444 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?PresentCallback@@YGJPAUIDXGISwapChain@@II@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 72					; 00000048H

; 2445 : extern HRESULT
; 2446 :   STDMETHODCALLTYPE PresentCallback (IDXGISwapChain *This,
; 2447 :                                      UINT            SyncInterval,
; 2448 :                                      UINT            Flags);
; 2449 :   //
; 2450 :   // Early-out for games that use testing to minimize blocking
; 2451 :   //
; 2452 :   if (Flags & DXGI_PRESENT_TEST)

	mov	eax, DWORD PTR _Flags$[ebp]
	test	al, 1
	je	SHORT $LN4@PresentCal

; 2453 :     return SK_DXGI_Present (This, SyncInterval, Flags);

	push	eax
	push	DWORD PTR _SyncInterval$[ebp]
	push	DWORD PTR _This$[ebp]
	call	?SK_DXGI_Present@@YAJPAUIDXGISwapChain@@II@Z ; SK_DXGI_Present
	add	esp, 12					; 0000000cH

; 2694 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN4@PresentCal:
	push	ebx

; 2454 : 
; 2455 : 
; 2456 : #ifdef DARK_SOULS
; 2457 :   if (__DS3_HEIGHT != nullptr)
; 2458 :   {
; 2459 :     DXGI_SWAP_CHAIN_DESC swap_desc;
; 2460 :     if (SUCCEEDED (This->GetDesc (&swap_desc)))
; 2461 :     {
; 2462 :       *__DS3_WIDTH  = swap_desc.BufferDesc.Width;
; 2463 :       *__DS3_HEIGHT = swap_desc.BufferDesc.Height;
; 2464 :     }
; 2465 :   }
; 2466 : #endif
; 2467 : 
; 2468 :   // Start / End / Readback Pipeline Stats
; 2469 :   SK_D3D11_UpdateRenderStats (This);

	mov	ebx, DWORD PTR _This$[ebp]
	push	esi
	push	ebx
	call	?SK_D3D11_UpdateRenderStats@@YGXPAUIDXGISwapChain@@@Z ; SK_D3D11_UpdateRenderStats

; 2470 :   SK_D3D12_UpdateRenderStats (This);

	push	ebx
	call	?SK_D3D12_UpdateRenderStats@@YGXPAUIDXGISwapChain@@@Z ; SK_D3D12_UpdateRenderStats

; 2471 : 
; 2472 :   // Establish the API used this frame (and handle possible translation layers)
; 2473 :   //
; 2474 :   switch (SK_GetDLLRole ())

	call	?SK_GetDLLRole@@YG?AW4DLL_ROLE@@XZ	; SK_GetDLLRole
	cmp	eax, -1073741808			; c0000010H
	je	SHORT $LN5@PresentCal
	cmp	eax, -1073741792			; c0000020H
	je	SHORT $LN6@PresentCal

; 2482 :     default:
; 2483 :       SK_GetCurrentRenderBackend ().api = SK_RenderAPI::D3D11;

	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend
	mov	DWORD PTR [eax], 64			; 00000040H
	jmp	SHORT $LN2@PresentCal
$LN6@PresentCal:

; 2478 :       break;
; 2479 :     case DLL_ROLE::DDraw:
; 2480 :       SK_GetCurrentRenderBackend ().api = SK_RenderAPI::DDrawOn11;

	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend
	mov	DWORD PTR [eax], 16448			; 00004040H

; 2481 :       break;

	jmp	SHORT $LN2@PresentCal
$LN5@PresentCal:

; 2475 :   {
; 2476 :     case DLL_ROLE::D3D8:
; 2477 :       SK_GetCurrentRenderBackend ().api = SK_RenderAPI::D3D8On11;

	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend
	mov	DWORD PTR [eax], 8256			; 00002040H
$LN2@PresentCal:

; 2484 :       break;
; 2485 :   }
; 2486 : 
; 2487 :   SK_BeginBufferSwap ();

	push	edi
	call	?SK_BeginBufferSwap@@YGXXZ		; SK_BeginBufferSwap
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pDev$[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2492 :   This->GetDevice (IID_PPV_ARGS (&pDev));

	mov	esi, DWORD PTR [ebx]
	lea	eax, DWORD PTR _pDev$[ebp]
	push	eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??$IID_PPV_ARGS_Helper@UID3D11Device@@@@YAPAPAXPAPAUID3D11Device@@@Z ; IID_PPV_ARGS_Helper<ID3D11Device>
	add	esp, 4
	push	eax
	push	OFFSET __GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140
	push	ebx
	call	DWORD PTR [esi+28]

; 2493 : 
; 2494 :   static bool first_frame = true;
; 2495 : 
; 2496 :   if (first_frame)

	cmp	BYTE PTR ?first_frame@?1??PresentCallback@@YGJPAUIDXGISwapChain@@II@Z@4_NA, 0
	je	$LN106@PresentCal
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 214  :         return p == pT;

	mov	eax, DWORD PTR _pDev$[ebp]
	test	eax, eax
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2513 :     if ( pDev != nullptr )

	je	$LN106@PresentCal
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pDevDXGI$4[ebp], 0
	mov	DWORD PTR _pAdapter$5[ebp], 0
	mov	DWORD PTR _pFactory$6[ebp], 0
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR _pDevDXGI$4[ebp]
	push	edx
	push	OFFSET __GUID_54ec77fa_1377_44e6_8c32_88fd5f44c84c
	push	eax
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2517 :       CComPtr <IDXGIFactory> pFactory = nullptr;

	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	call	DWORD PTR [ecx]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2520 :            SUCCEEDED (pDevDXGI->GetAdapter               (&pAdapter)) &&

	test	eax, eax
	js	$LN10@PresentCal
	mov	eax, DWORD PTR _pDevDXGI$4[ebp]
	lea	edx, DWORD PTR _pAdapter$5[ebp]
	push	edx
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+28]
	test	eax, eax
	js	$LN10@PresentCal
	mov	esi, DWORD PTR _pAdapter$5[ebp]
	lea	eax, DWORD PTR _pFactory$6[ebp]
	push	eax
	mov	edi, DWORD PTR [esi]
	call	??$IID_PPV_ARGS_Helper@UIDXGIFactory@@@@YAPAPAXPAPAUIDXGIFactory@@@Z ; IID_PPV_ARGS_Helper<IDXGIFactory>
	add	esp, 4
	push	eax
	push	OFFSET __GUID_7b7166ec_21c7_44ae_b21a_c9ae321ae369
	push	esi
	call	DWORD PTR [edi+24]
	test	eax, eax
	js	SHORT $LN10@PresentCal

; 2521 :            SUCCEEDED (pAdapter->GetParent  (IID_PPV_ARGS (&pFactory))) )
; 2522 :       {
; 2523 :         DXGI_SWAP_CHAIN_DESC desc;
; 2524 :         This->GetDesc      (&desc);

	mov	eax, DWORD PTR [ebx]
	lea	ecx, DWORD PTR _desc$3[ebp]
	push	ecx
	push	ebx
	call	DWORD PTR [eax+48]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 181  :         return p;

	mov	esi, DWORD PTR _pDev$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2526 :         SK_GetCurrentRenderBackend ().device    = pDev;

	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend
	mov	DWORD PTR [eax+36], esi

; 2527 :         SK_GetCurrentRenderBackend ().swapchain = This;

	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend
	mov	DWORD PTR [eax+40], ebx

; 2528 : 
; 2529 :         //if (sk::NVAPI::nv_hardware && config.apis.NvAPI.gsync_status)
; 2530 :         //  NvAPI_D3D_GetObjectHandleForResource (pDev, This, &SK_GetCurrentRenderBackend ().surface);
; 2531 : 
; 2532 : 
; 2533 :         if (config.render.dxgi.safe_fullscreen) pFactory->MakeWindowAssociation ( nullptr, 0 );

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+488, 0
	je	SHORT $LN11@PresentCal
	mov	eax, DWORD PTR _pFactory$6[ebp]
	push	0
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+32]
$LN11@PresentCal:

; 2534 : 
; 2535 : 
; 2536 :         if (bAlwaysAllowFullscreen)

	cmp	BYTE PTR ?bAlwaysAllowFullscreen@@3_NA, 0 ; bAlwaysAllowFullscreen
	je	SHORT $LN12@PresentCal

; 2537 :           pFactory->MakeWindowAssociation (desc.OutputWindow, DXGI_MWA_NO_WINDOW_CHANGES);

	mov	eax, DWORD PTR _pFactory$6[ebp]
	push	1
	push	DWORD PTR _desc$3[ebp+44]
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+32]
$LN12@PresentCal:

; 2538 : 
; 2539 :         hWndRender       = desc.OutputWindow;

	mov	eax, DWORD PTR _desc$3[ebp+44]

; 2540 : 
; 2541 :         SK_InstallWindowHook (hWndRender);

	push	eax
	mov	DWORD PTR ?hWndRender@@3PAUHWND__@@A, eax ; hWndRender
	call	?SK_InstallWindowHook@@YAXPAUHWND__@@@Z	; SK_InstallWindowHook

; 2542 :         game_window.hWnd =    hWndRender;

	mov	eax, DWORD PTR ?hWndRender@@3PAUHWND__@@A ; hWndRender
	add	esp, 4
	mov	DWORD PTR ?game_window@@3Usk_window_s@@A+4, eax

; 2543 : 
; 2544 :         SK_DXGI_BringRenderWindowToTop ();

	call	?SK_DXGI_BringRenderWindowToTop@@YGXXZ	; SK_DXGI_BringRenderWindowToTop
$LN10@PresentCal:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	mov	eax, DWORD PTR _pFactory$6[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2546 :     }

	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN94@PresentCal

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN94@PresentCal:

; 176  :         if (p)

	mov	eax, DWORD PTR _pAdapter$5[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2546 :     }

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN100@PresentCal

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN100@PresentCal:

; 176  :         if (p)

	mov	eax, DWORD PTR _pDevDXGI$4[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2546 :     }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN106@PresentCal

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN106@PresentCal:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2553 :   if ( config.render.framerate.flip_discard && config.render.dxgi.allow_tearing )

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+416, 0
	mov	ecx, DWORD PTR ?config@@3Usk_config_t@@A+404
	mov	BYTE PTR ?first_frame@?1??PresentCallback@@YGJPAUIDXGISwapChain@@II@Z@4_NA, 0
	mov	DWORD PTR _interval$2$[ebp], ecx
	je	SHORT $LN181@PresentCal
	cmp	BYTE PTR ?config@@3Usk_config_t@@A+487, 0
	je	SHORT $LN181@PresentCal

; 2554 :   {
; 2555 :     DXGI_SWAP_CHAIN_DESC desc;
; 2556 :     if (SUCCEEDED (This->GetDesc (&desc)))

	mov	eax, DWORD PTR [ebx]
	lea	ecx, DWORD PTR _desc$2[ebp]
	push	ecx
	push	ebx
	call	DWORD PTR [eax+48]
	test	eax, eax
	js	SHORT $LN187@PresentCal

; 2557 :     {
; 2558 :       if (desc.Windowed)

	cmp	DWORD PTR _desc$2[ebp+48], 0
	je	SHORT $LN187@PresentCal

; 2559 :       {
; 2560 :         Flags       |= DXGI_PRESENT_ALLOW_TEARING;

	mov	eax, DWORD PTR _Flags$[ebp]

; 2561 :         SyncInterval = 0;

	xor	edx, edx
	or	eax, 512				; 00000200H

; 2562 :         interval     = 0;

	xor	ecx, ecx
	mov	DWORD PTR _Flags$[ebp], eax
	jmp	SHORT $LN15@PresentCal
$LN187@PresentCal:
	mov	ecx, DWORD PTR _interval$2$[ebp]
$LN181@PresentCal:
	mov	edx, DWORD PTR _SyncInterval$[ebp]
	mov	eax, DWORD PTR _Flags$[ebp]
$LN15@PresentCal:

; 2563 :       }
; 2564 :     }
; 2565 :   }
; 2566 : 
; 2567 :   int flags    = Flags;
; 2568 : 
; 2569 :   // Application preference
; 2570 :   if (interval == -1)

	cmp	ecx, -1
	mov	edi, eax
	cmove	ecx, edx
	mov	DWORD PTR _interval$2$[ebp], ecx

; 2571 :     interval = SyncInterval;
; 2572 : 
; 2573 :   SK_GetCurrentRenderBackend ().present_interval = interval;

	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend
	mov	ecx, DWORD PTR _interval$2$[ebp]
	mov	DWORD PTR [eax+64], ecx

; 2574 : 
; 2575 :   if (bFlipMode)

	cmp	BYTE PTR ?bFlipMode@@3_NA, 0		; bFlipMode

; 2576 :   {
; 2577 :     flags |= DXGI_PRESENT_USE_DURATION | DXGI_PRESENT_RESTART;

	mov	eax, DWORD PTR _Flags$[ebp]
	je	SHORT $LN18@PresentCal
	mov	edi, eax
	or	edi, 260				; 00000104H

; 2578 : 
; 2579 :     if (bWait)

	cmp	BYTE PTR ?bWait@@3_NA, 0		; bWait
	je	SHORT $LN18@PresentCal

; 2580 :       flags |= DXGI_PRESENT_DO_NOT_WAIT;

	or	edi, 8
$LN18@PresentCal:

; 2581 :   }
; 2582 : 
; 2583 :   // Test first, then do (if test_present is true)
; 2584 :   hr = config.render.dxgi.test_present ? 

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+484, 0
	je	SHORT $LN33@PresentCal
	or	eax, 1
	push	eax
	push	0
	push	ebx
	call	?SK_DXGI_Present@@YAJPAUIDXGISwapChain@@II@Z ; SK_DXGI_Present
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 2585 :          SK_DXGI_Present (This, 0, Flags | DXGI_PRESENT_TEST) :
; 2586 :          S_OK;
; 2587 : 
; 2588 :   const bool can_present =
; 2589 :     SUCCEEDED (hr) || hr == DXGI_STATUS_OCCLUDED;

	test	esi, esi
	jns	SHORT $LN35@PresentCal
	xor	al, al
	jmp	SHORT $LN189@PresentCal
$LN33@PresentCal:

; 2581 :   }
; 2582 : 
; 2583 :   // Test first, then do (if test_present is true)
; 2584 :   hr = config.render.dxgi.test_present ? 

	xor	esi, esi
$LN35@PresentCal:

; 2585 :          SK_DXGI_Present (This, 0, Flags | DXGI_PRESENT_TEST) :
; 2586 :          S_OK;
; 2587 : 
; 2588 :   const bool can_present =
; 2589 :     SUCCEEDED (hr) || hr == DXGI_STATUS_OCCLUDED;

	mov	al, 1
$LN189@PresentCal:

; 2590 : 
; 2591 :   if (! bFlipMode)

	cmp	BYTE PTR ?bFlipMode@@3_NA, 0		; bFlipMode
	mov	BYTE PTR _can_present$1$[ebp], al
	jne	$LN19@PresentCal

; 2592 :   {
; 2593 :     if (can_present)

	test	al, al
	je	SHORT $LN21@PresentCal

; 2594 :     {
; 2595 :       SK_CEGUI_DrawD3D11 (This);

	push	ebx
	call	?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z ; SK_CEGUI_DrawD3D11

; 2596 :       SK_DXGI_Present    (This, interval, flags);

	push	edi
	push	DWORD PTR _interval$2$[ebp]
	push	ebx
	call	?SK_DXGI_Present@@YAJPAUIDXGISwapChain@@II@Z ; SK_DXGI_Present
	add	esp, 16					; 00000010H

; 2597 :     }
; 2598 : 
; 2599 :     else

	jmp	$LN183@PresentCal
$LN21@PresentCal:

; 2600 :     {
; 2601 :       dll_log.Log ( L"[   DXGI   ] *** IDXGISwapChain::Present (...) "

	mov	ecx, OFFSET $SG355114
	test	esi, esi
	mov	eax, OFFSET $SG355113
	cmovs	eax, ecx
	push	eax
	push	esi
	call	?SK_DescribeHRESULT@@YGPB_WJ@Z		; SK_DescribeHRESULT
	push	eax
	push	OFFSET $SG355115
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H

; 2602 :                     L"returned non-S_OK (%s :: %s)",
; 2603 :                       SK_DescribeHRESULT (hr),
; 2604 :                         SUCCEEDED (hr) ? L"Success" :
; 2605 :                                          L"Fail" );
; 2606 : 
; 2607 :       if (FAILED (hr) && hr == DXGI_ERROR_DEVICE_REMOVED)

	test	esi, esi
	jns	$LN183@PresentCal
	cmp	esi, -2005270523			; 887a0005H
	jne	$LN183@PresentCal
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 214  :         return p == pT;

	mov	eax, DWORD PTR _pDev$[ebp]
	test	eax, eax
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2609 :         if (pDev != nullptr)

	je	$LN183@PresentCal

; 2610 :         {
; 2611 :           // D3D11 Device Removed, let's find out why...
; 2612 :           HRESULT hr_removed = pDev->GetDeviceRemovedReason ();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+156]

; 2613 : 
; 2614 :           dll_log.Log ( L"[   DXGI   ] (*) >> Reason For Removal: %s",

	push	eax
	call	?SK_DescribeHRESULT@@YGPB_WJ@Z		; SK_DescribeHRESULT
	push	eax
	push	OFFSET $SG355118
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH

; 2615 :                          SK_DescribeHRESULT (hr_removed) );
; 2616 :         }
; 2617 :       }
; 2618 :     }
; 2619 :   }
; 2620 : 
; 2621 :   else

	jmp	SHORT $LN183@PresentCal
$LN19@PresentCal:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 625  :             if (FAILED(lp->QueryInterface(*piid, (void **)&this->p)))

	mov	eax, DWORD PTR [ebx]
	lea	ecx, DWORD PTR _pSwapChain1$7[ebp]
	push	ecx
	push	OFFSET __GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa
	push	ebx

; 158  :         p = NULL;

	mov	DWORD PTR _pSwapChain1$7[ebp], 0

; 625  :             if (FAILED(lp->QueryInterface(*piid, (void **)&this->p)))

	call	DWORD PTR [eax]
	mov	ecx, DWORD PTR _pSwapChain1$7[ebp]
	xor	edx, edx
	test	eax, eax
	cmovs	ecx, edx
	mov	DWORD PTR _pSwapChain1$7[ebp], ecx
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2624 :     CComQIPtr <IDXGISwapChain1> pSwapChain1 (This);

	mov	BYTE PTR __$EHRec$[ebp+8], 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 214  :         return p == pT;

	test	ecx, ecx
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2626 :     if (pSwapChain1 != nullptr)

	je	SHORT $LN25@PresentCal

; 2627 :     {
; 2628 :       if (can_present)

	cmp	BYTE PTR _can_present$1$[ebp], dl
	je	SHORT $LN26@PresentCal

; 2629 :       {
; 2630 :         SK_CEGUI_DrawD3D11 (This);

	push	ebx
	call	?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z ; SK_CEGUI_DrawD3D11

; 2631 : 
; 2632 : #if 0
; 2633 :         // No overlays will work if we don't do this...
; 2634 :         /////if (config.osd.show) {
; 2635 :           hr =
; 2636 :             SK_DXGI_Present (
; 2637 :               This,
; 2638 :                 0,
; 2639 :                   DXGI_PRESENT_DO_NOT_SEQUENCE | DXGI_PRESENT_DO_NOT_WAIT |
; 2640 :                   DXGI_PRESENT_USE_DURATION    | DXGI_PRESENT_TEST );
; 2641 : 
; 2642 :                 // ^^^ Deliberately invalid set of flags so that this call will fail, we just
; 2643 :                 //       want third-party overlays that don't hook Present1 to understand what
; 2644 :                 //         is going on.
; 2645 : 
; 2646 :           // Draw here to hide from Steam screenshots
; 2647 :           //SK_CEGUI_DrawD3D11 (This);
; 2648 : 
; 2649 :         /////}
; 2650 : 
; 2651 :         hr = Present1_Original (pSwapChain1, interval, flags, &pparams);
; 2652 : #else
; 2653 :         hr = SK_DXGI_Present   (This, interval, flags);

	push	edi
	push	DWORD PTR _interval$2$[ebp]
	push	ebx
	call	?SK_DXGI_Present@@YAJPAUIDXGISwapChain@@II@Z ; SK_DXGI_Present
	add	esp, 16					; 00000010H

; 2654 : #endif
; 2655 :       }
; 2656 :     }
; 2657 : 
; 2658 :     else

	jmp	SHORT $LN190@PresentCal
$LN25@PresentCal:

; 2659 :     {
; 2660 :       // Fallback for something that will probably only ever happen on Windows 7.
; 2661 :       hr = SK_DXGI_Present (This, interval, Flags);

	mov	eax, DWORD PTR _Flags$[ebp]
	push	eax
	push	DWORD PTR _interval$2$[ebp]
	push	ebx
	call	?SK_DXGI_Present@@YAJPAUIDXGISwapChain@@II@Z ; SK_DXGI_Present
	add	esp, 12					; 0000000cH
$LN190@PresentCal:
	mov	ecx, DWORD PTR _pSwapChain1$7[ebp]
	mov	esi, eax
$LN26@PresentCal:

; 2662 :     }
; 2663 :   }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	ecx, ecx
	je	SHORT $LN183@PresentCal

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN183@PresentCal:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2665 :   if (bWait)

	cmp	BYTE PTR ?bWait@@3_NA, 0		; bWait
	pop	edi
	je	SHORT $LN184@PresentCal
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 625  :             if (FAILED(lp->QueryInterface(*piid, (void **)&this->p)))

	mov	eax, DWORD PTR [ebx]
	lea	ecx, DWORD PTR _pSwapChain2$8[ebp]
	push	ecx
	push	OFFSET __GUID_a8be2ac4_199f_4946_b331_79599fb98de7
	push	ebx

; 158  :         p = NULL;

	mov	DWORD PTR _pSwapChain2$8[ebp], 0

; 625  :             if (FAILED(lp->QueryInterface(*piid, (void **)&this->p)))

	call	DWORD PTR [eax]
	mov	ecx, DWORD PTR _pSwapChain2$8[ebp]
	xor	edx, edx
	test	eax, eax
	cmovs	ecx, edx
	mov	DWORD PTR _pSwapChain2$8[ebp], ecx
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2667 :     CComQIPtr <IDXGISwapChain2> pSwapChain2 (This);

	mov	BYTE PTR __$EHRec$[ebp+8], 5
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 214  :         return p == pT;

	test	ecx, ecx
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2669 :     if (pSwapChain2 != nullptr)

	je	SHORT $LN30@PresentCal

; 2670 :     {
; 2671 :       if (pSwapChain2 != nullptr)
; 2672 :       {
; 2673 :         HANDLE hWait = pSwapChain2->GetFrameLatencyWaitableObject ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+132]

; 2674 : 
; 2675 :         WaitForSingleObjectEx ( hWait,

	push	1
	push	DWORD PTR ?config@@3Usk_config_t@@A+420
	push	eax
	call	DWORD PTR __imp__WaitForSingleObjectEx@12
	mov	ecx, DWORD PTR _pSwapChain2$8[ebp]
$LN30@PresentCal:

; 2676 :                                   config.render.framerate.swapchain_wait,
; 2677 :                                     TRUE );
; 2678 :       }
; 2679 :     }
; 2680 :   }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	ecx, ecx
	je	SHORT $LN184@PresentCal

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN184@PresentCal:

; 214  :         return p == pT;

	mov	eax, DWORD PTR _pDev$[ebp]
	test	eax, eax
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2682 :   if ( pDev != nullptr )

	je	SHORT $LN31@PresentCal

; 2683 :   {
; 2684 :     HRESULT ret =
; 2685 :       SK_EndBufferSwap (hr, pDev);

	push	eax
	push	esi
	call	?SK_EndBufferSwap@@YGJJPAUIUnknown@@@Z	; SK_EndBufferSwap
	mov	esi, eax

; 2686 : 
; 2687 :     SK_D3D11_TexCacheCheckpoint ();

	call	?SK_D3D11_TexCacheCheckpoint@@YGXXZ	; SK_D3D11_TexCacheCheckpoint
	jmp	SHORT $LN43@PresentCal
$LN31@PresentCal:

; 2693 :   return SK_EndBufferSwap (hr);

	push	0
	push	esi
	call	?SK_EndBufferSwap@@YGJJPAUIUnknown@@@Z	; SK_EndBufferSwap
	mov	esi, eax
$LN43@PresentCal:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	mov	ecx, DWORD PTR _pDev$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2693 :   return SK_EndBufferSwap (hr);

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	ecx, ecx
	je	SHORT $LN178@PresentCal

; 177  :             p->Release();

	mov	edx, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [edx+8]
$LN178@PresentCal:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2694 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?PresentCallback@@YGJPAUIDXGISwapChain@@II@Z$0:
	lea	ecx, DWORD PTR _pDev$[ebp]
	jmp	??1?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ
__unwindfunclet$?PresentCallback@@YGJPAUIDXGISwapChain@@II@Z$1:
	lea	ecx, DWORD PTR _pDevDXGI$4[ebp]
	jmp	??1?$CComPtr@UIDXGIDevice@@@ATL@@QAE@XZ
__unwindfunclet$?PresentCallback@@YGJPAUIDXGISwapChain@@II@Z$2:
	lea	ecx, DWORD PTR _pAdapter$5[ebp]
	jmp	??1?$CComPtr@UIDXGIAdapter@@@ATL@@QAE@XZ
__unwindfunclet$?PresentCallback@@YGJPAUIDXGISwapChain@@II@Z$3:
	lea	ecx, DWORD PTR _pFactory$6[ebp]
	jmp	??1?$CComPtr@UIDXGIFactory@@@ATL@@QAE@XZ
__unwindfunclet$?PresentCallback@@YGJPAUIDXGISwapChain@@II@Z$4:
	lea	ecx, DWORD PTR _pSwapChain1$7[ebp]
	jmp	??1?$CComQIPtr@UIDXGISwapChain1@@$1?_GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa@@3U__s_GUID@@B@ATL@@QAE@XZ
__unwindfunclet$?PresentCallback@@YGJPAUIDXGISwapChain@@II@Z$5:
	lea	ecx, DWORD PTR _pSwapChain2$8[ebp]
	jmp	??1?$CComQIPtr@UIDXGISwapChain2@@$1?_GUID_a8be2ac4_199f_4946_b331_79599fb98de7@@3U__s_GUID@@B@ATL@@QAE@XZ
__ehhandler$?PresentCallback@@YGJPAUIDXGISwapChain@@II@Z:
	mov	eax, OFFSET __ehfuncinfo$?PresentCallback@@YGJPAUIDXGISwapChain@@II@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?PresentCallback@@YGJPAUIDXGISwapChain@@II@Z ENDP	; PresentCallback
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
;	COMDAT ??B<lambda_13a6a98c64cd351619cda83b98571c44>@@QBEP6GKPAX@ZXZ
_TEXT	SEGMENT
??B<lambda_13a6a98c64cd351619cda83b98571c44>@@QBEP6GKPAX@ZXZ PROC ; <lambda_13a6a98c64cd351619cda83b98571c44>::operator unsigned long (__stdcall*)(void *), COMDAT
; _this$ = ecx

; 2427 :         }, nullptr, 0x00, nullptr);

	mov	eax, OFFSET ?<lambda_invoker_stdcall>@<lambda_13a6a98c64cd351619cda83b98571c44>@@CGKPAX@Z ; <lambda_13a6a98c64cd351619cda83b98571c44>::<lambda_invoker_stdcall>
	ret	0
??B<lambda_13a6a98c64cd351619cda83b98571c44>@@QBEP6GKPAX@ZXZ ENDP ; <lambda_13a6a98c64cd351619cda83b98571c44>::operator unsigned long (__stdcall*)(void *)
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
;	COMDAT ?<lambda_invoker_stdcall>@<lambda_13a6a98c64cd351619cda83b98571c44>@@CGKPAX@Z
_TEXT	SEGMENT
___p1$ = 8						; size = 4
?<lambda_invoker_stdcall>@<lambda_13a6a98c64cd351619cda83b98571c44>@@CGKPAX@Z PROC ; <lambda_13a6a98c64cd351619cda83b98571c44>::<lambda_invoker_stdcall>, COMDAT

; 2427 :         }, nullptr, 0x00, nullptr);

	npad	2
	push	ebp
	mov	ebp, esp
	xor	ecx, ecx
	pop	ebp
	jmp	??R<lambda_13a6a98c64cd351619cda83b98571c44>@@QBEKPAX@Z ; <lambda_13a6a98c64cd351619cda83b98571c44>::operator()
?<lambda_invoker_stdcall>@<lambda_13a6a98c64cd351619cda83b98571c44>@@CGKPAX@Z ENDP ; <lambda_13a6a98c64cd351619cda83b98571c44>::<lambda_invoker_stdcall>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
;	COMDAT ??R<lambda_13a6a98c64cd351619cda83b98571c44>@@QBEKPAX@Z
_TEXT	SEGMENT
_dwProtect$ = -4					; size = 4
___formal$ = 8						; size = 4
??R<lambda_13a6a98c64cd351619cda83b98571c44>@@QBEKPAX@Z PROC ; <lambda_13a6a98c64cd351619cda83b98571c44>::operator(), COMDAT
; _this$ = ecx

; 2406 :         {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	edi

; 2407 :           MH_ApplyQueued ();

	call	_MH_ApplyQueued@0

; 2408 : 
; 2409 :                        IDXGISwapChain* pSwap = (IDXGISwapChain *)SK_GetCurrentRenderBackend ().swapchain;

	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend
	mov	eax, DWORD PTR [eax+40]

; 2410 :           void** vftable = *(void***)*&pSwap;

	mov	edi, DWORD PTR [eax]

; 2411 : 
; 2412 :           DWORD dwProtect;
; 2413 :           VirtualProtect (&vftable [8], sizeof (uintptr_t), PAGE_EXECUTE_READWRITE, &dwProtect);

	lea	eax, DWORD PTR _dwProtect$[ebp]
	push	eax
	push	64					; 00000040H
	push	4
	add	edi, 32					; 00000020H
	push	edi
	call	DWORD PTR __imp__VirtualProtect@16

; 2414 :           Present_Original = (PresentSwapChain_pfn)vftable [8];

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR ?Present_Original@@3P6GJPAUIDXGISwapChain@@II@ZA, eax ; Present_Original

; 2415 :           vftable [8]      =  PresentCallback;
; 2416 :           Present_Target   = (PresentSwapChain_pfn)vftable [8];
; 2417 :           VirtualProtect (&vftable [8], sizeof (uintptr_t), dwProtect, &dwProtect);

	lea	eax, DWORD PTR _dwProtect$[ebp]
	push	eax
	mov	DWORD PTR [edi], OFFSET ?PresentCallback@@YGJPAUIDXGISwapChain@@II@Z ; PresentCallback
	push	DWORD PTR _dwProtect$[ebp]
	mov	DWORD PTR ?Present_Target@@3P6GJPAUIDXGISwapChain@@II@ZA, OFFSET ?PresentCallback@@YGJPAUIDXGISwapChain@@II@Z ; Present_Target, PresentCallback
	push	4
	push	edi
	call	DWORD PTR __imp__VirtualProtect@16

; 2418 : 
; 2419 :           memcpy (&Present_GuardBytes [1], &((uint8_t *)Present_Target) [1], 15);

	mov	ecx, DWORD PTR ?Present_Target@@3P6GJPAUIDXGISwapChain@@II@ZA ; Present_Target
	movq	xmm0, QWORD PTR [ecx+1]
	movq	QWORD PTR ?Present_GuardBytes@@3PAEA+1, xmm0
	mov	eax, DWORD PTR [ecx+9]
	mov	DWORD PTR ?Present_GuardBytes@@3PAEA+9, eax
	mov	ax, WORD PTR [ecx+13]
	mov	WORD PTR ?Present_GuardBytes@@3PAEA+13, ax
	movzx	eax, BYTE PTR [ecx+15]
	mov	BYTE PTR ?Present_GuardBytes@@3PAEA+15, al

; 2420 :           memcpy ( Present_GuardBytes,                  Present_Target,       1);

	movzx	eax, BYTE PTR [ecx]

; 2421 : 
; 2422 :           InterlockedExchange (&nest, 0);

	mov	ecx, OFFSET ?nest@?9??SK_DXGI_Present@@YAJPAUIDXGISwapChain@@II@Z@4JC
	mov	BYTE PTR ?Present_GuardBytes@@3PAEA, al
	xor	eax, eax
	xchg	DWORD PTR [ecx], eax

; 2423 : 
; 2424 :           CloseHandle (GetCurrentThread ());

	call	DWORD PTR __imp__GetCurrentThread@0
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 2425 : 
; 2426 :           return 0;

	xor	eax, eax
	pop	edi

; 2427 :         }, nullptr, 0x00, nullptr);

	mov	esp, ebp
	pop	ebp
	ret	4
??R<lambda_13a6a98c64cd351619cda83b98571c44>@@QBEKPAX@Z ENDP ; <lambda_13a6a98c64cd351619cda83b98571c44>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_hr$ = -32						; size = 4
$T2 = -25						; size = 1
__$SEHRec$ = -24					; size = 24
_This$ = 8						; size = 4
_SyncInterval$ = 12					; size = 4
_Flags$ = 16						; size = 4
?SK_DXGI_Present@@YAJPAUIDXGISwapChain@@II@Z PROC	; SK_DXGI_Present

; 2367 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	OFFSET __sehtable$?SK_DXGI_Present@@YAJPAUIDXGISwapChain@@II@Z
	push	OFFSET __except_handler3
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$SEHRec$[ebp], esp

; 2368 :   if (Present_GuardBytes [0] == 0x00)

	cmp	BYTE PTR ?Present_GuardBytes@@3PAEA, 0
	jne	SHORT $LN2@SK_DXGI_Pr

; 2369 :     return S_OK;

	xor	eax, eax

; 2436 : 
; 2437 :   return hr;
; 2438 : }

	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@SK_DXGI_Pr:

; 2370 : 
; 2371 :   HRESULT hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0

; 2372 : 
; 2373 :   extern HRESULT
; 2374 :     STDMETHODCALLTYPE PresentCallback (IDXGISwapChain *This,
; 2375 :                                        UINT            SyncInterval,
; 2376 :                                        UINT            Flags);
; 2377 : 
; 2378 :   if (config.render.dxgi.rehook_present)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+491, 0
	je	SHORT $LN6@SK_DXGI_Pr

; 2379 :   {
; 2380 :     if ((IDXGISwapChain *)SK_GetCurrentRenderBackend ().swapchain != nullptr && Present_Target != nullptr && Present_GuardBytes [0] != 0x00 && memcmp (Present_GuardBytes, Present_Target, 16))

	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN6@SK_DXGI_Pr
	mov	edi, DWORD PTR ?Present_Target@@3P6GJPAUIDXGISwapChain@@II@ZA ; Present_Target
	test	edi, edi
	je	SHORT $LN6@SK_DXGI_Pr
	mov	bl, BYTE PTR ?Present_GuardBytes@@3PAEA
	test	bl, bl
	je	SHORT $LN6@SK_DXGI_Pr
	mov	ecx, OFFSET ?Present_GuardBytes@@3PAEA	; Present_GuardBytes
	mov	edx, edi
	mov	esi, 12					; 0000000cH
	npad	1
$LL21@SK_DXGI_Pr:
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN20@SK_DXGI_Pr
	add	ecx, 4
	add	edx, 4
	sub	esi, 4
	jae	SHORT $LL21@SK_DXGI_Pr
$LN6@SK_DXGI_Pr:

; 2430 :       }
; 2431 :     }
; 2432 :   }
; 2433 : 
; 2434 :   __try                                { hr = Present_Original (This, SyncInterval, Flags); }

	mov	DWORD PTR __$SEHRec$[ebp+20], 1
	push	DWORD PTR _Flags$[ebp]
	push	DWORD PTR _SyncInterval$[ebp]
	push	DWORD PTR _This$[ebp]
	call	DWORD PTR ?Present_Original@@3P6GJPAUIDXGISwapChain@@II@ZA ; Present_Original
	mov	DWORD PTR _hr$[ebp], eax
	mov	DWORD PTR __$SEHRec$[ebp+20], -1

; 2436 : 
; 2437 :   return hr;
; 2438 : }

	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@SK_DXGI_Pr:

; 2381 :     {
; 2382 :       SK_LOG0 ( ( L"IDXGISwapChain::Present (...) function prolog altered (expected: "

	cmp	DWORD PTR ?config@@3Usk_config_t@@A+808, 0
	jl	$LN5@SK_DXGI_Pr
	movzx	eax, BYTE PTR [edi+11]
	push	eax
	movzx	eax, BYTE PTR [edi+10]
	push	eax
	movzx	eax, BYTE PTR [edi+9]
	push	eax
	movzx	eax, BYTE PTR [edi+8]
	push	eax
	movzx	eax, BYTE PTR [edi+7]
	push	eax
	movzx	eax, BYTE PTR [edi+6]
	push	eax
	movzx	eax, BYTE PTR [edi+5]
	push	eax
	movzx	eax, BYTE PTR [edi+4]
	push	eax
	movzx	eax, BYTE PTR [edi+3]
	push	eax
	movzx	eax, BYTE PTR [edi+2]
	push	eax
	movzx	eax, BYTE PTR [edi+1]
	push	eax
	movzx	eax, BYTE PTR [edi]
	push	eax
	movzx	eax, BYTE PTR ?Present_GuardBytes@@3PAEA+11
	push	eax
	movzx	eax, BYTE PTR ?Present_GuardBytes@@3PAEA+10
	push	eax
	movzx	eax, BYTE PTR ?Present_GuardBytes@@3PAEA+9
	push	eax
	movzx	eax, BYTE PTR ?Present_GuardBytes@@3PAEA+8
	push	eax
	movzx	eax, BYTE PTR ?Present_GuardBytes@@3PAEA+7
	push	eax
	movzx	eax, BYTE PTR ?Present_GuardBytes@@3PAEA+6
	push	eax
	movzx	eax, BYTE PTR ?Present_GuardBytes@@3PAEA+5
	push	eax
	movzx	eax, BYTE PTR ?Present_GuardBytes@@3PAEA+4
	push	eax
	movzx	eax, BYTE PTR ?Present_GuardBytes@@3PAEA+3
	push	eax
	movzx	eax, BYTE PTR ?Present_GuardBytes@@3PAEA+2
	push	eax
	movzx	eax, BYTE PTR ?Present_GuardBytes@@3PAEA+1
	push	eax
	movzx	eax, bl
	push	eax
	push	OFFSET $SG354828
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 104				; 00000068H
$LN5@SK_DXGI_Pr:

; 2383 :                   L"'%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x', but got "
; 2384 :                   L"'%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x'); "
; 2385 :                   L"falling back to vftable override.",
; 2386 :                   Present_GuardBytes [0], Present_GuardBytes [ 1], Present_GuardBytes [ 2],
; 2387 :                   Present_GuardBytes [3], Present_GuardBytes [ 4], Present_GuardBytes [ 5],
; 2388 :                   Present_GuardBytes [6], Present_GuardBytes [ 7], Present_GuardBytes [ 8],
; 2389 :                   Present_GuardBytes [9], Present_GuardBytes [10], Present_GuardBytes [11],
; 2390 :                  ((uint8_t *)Present_Target) [0], ((uint8_t *)Present_Target) [ 1], ((uint8_t *)Present_Target) [ 2],
; 2391 :                  ((uint8_t *)Present_Target) [3], ((uint8_t *)Present_Target) [ 4], ((uint8_t *)Present_Target) [ 5],
; 2392 :                  ((uint8_t *)Present_Target) [6], ((uint8_t *)Present_Target) [ 7], ((uint8_t *)Present_Target) [ 8],
; 2393 :                  ((uint8_t *)Present_Target) [9], ((uint8_t *)Present_Target) [10], ((uint8_t *)Present_Target) [11] ),
; 2394 :                  L"DXGI Hooks" );
; 2395 : 
; 2396 :       static volatile LONG nest = 0;
; 2397 :       if (! InterlockedCompareExchange (&nest, 1, 0))

	mov	ecx, 1
	mov	edx, OFFSET ?nest@?9??SK_DXGI_Present@@YAJPAUIDXGISwapChain@@II@Z@4JC
	xor	eax, eax
	lock	 cmpxchg DWORD PTR [edx], ecx
	test	eax, eax
	jne	$LN6@SK_DXGI_Pr

; 2398 :       {
; 2399 :         Present_GuardBytes [0] = 0x00;

	mov	BYTE PTR ?Present_GuardBytes@@3PAEA, al

; 2400 :         MH_QueueDisableHook (Present_Target);

	push	DWORD PTR ?Present_Target@@3P6GJPAUIDXGISwapChain@@II@ZA ; Present_Target
	call	_MH_QueueDisableHook@4

; 2401 : 
; 2402 :         __try                                { hr = Present_Original (This, SyncInterval, Flags); }

	mov	DWORD PTR __$SEHRec$[ebp+20], 0
	push	DWORD PTR _Flags$[ebp]
	push	DWORD PTR _SyncInterval$[ebp]
	push	DWORD PTR _This$[ebp]
	call	DWORD PTR ?Present_Original@@3P6GJPAUIDXGISwapChain@@II@ZA ; Present_Original
	mov	esi, eax
	mov	DWORD PTR _hr$[ebp], esi
	mov	DWORD PTR __$SEHRec$[ebp+20], -1
	jmp	SHORT $LN14@SK_DXGI_Pr
$LN11@SK_DXGI_Pr:
$LN24@SK_DXGI_Pr:

; 2403 :         __except (EXCEPTION_EXECUTE_HANDLER) {                                                    }

	mov	eax, 1
$LN22@SK_DXGI_Pr:
$LN13@SK_DXGI_Pr:
	ret	0
$LN12@SK_DXGI_Pr:
	mov	esp, DWORD PTR __$SEHRec$[ebp]

; 2401 : 
; 2402 :         __try                                { hr = Present_Original (This, SyncInterval, Flags); }

	mov	DWORD PTR __$SEHRec$[ebp+20], -1
	mov	esi, DWORD PTR _hr$[ebp]
$LN14@SK_DXGI_Pr:

; 2404 : 
; 2405 :         CreateThread (nullptr, 0x0, [](LPVOID) -> DWORD

	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR $T2[ebp]
	call	??B<lambda_13a6a98c64cd351619cda83b98571c44>@@QBEP6GKPAX@ZXZ ; <lambda_13a6a98c64cd351619cda83b98571c44>::operator unsigned long (__stdcall*)(void *)
	push	eax
	push	0
	push	0
	call	DWORD PTR __imp__CreateThread@24

; 2406 :         {
; 2407 :           MH_ApplyQueued ();
; 2408 : 
; 2409 :                        IDXGISwapChain* pSwap = (IDXGISwapChain *)SK_GetCurrentRenderBackend ().swapchain;
; 2410 :           void** vftable = *(void***)*&pSwap;
; 2411 : 
; 2412 :           DWORD dwProtect;
; 2413 :           VirtualProtect (&vftable [8], sizeof (uintptr_t), PAGE_EXECUTE_READWRITE, &dwProtect);
; 2414 :           Present_Original = (PresentSwapChain_pfn)vftable [8];
; 2415 :           vftable [8]      =  PresentCallback;
; 2416 :           Present_Target   = (PresentSwapChain_pfn)vftable [8];
; 2417 :           VirtualProtect (&vftable [8], sizeof (uintptr_t), dwProtect, &dwProtect);
; 2418 : 
; 2419 :           memcpy (&Present_GuardBytes [1], &((uint8_t *)Present_Target) [1], 15);
; 2420 :           memcpy ( Present_GuardBytes,                  Present_Target,       1);
; 2421 : 
; 2422 :           InterlockedExchange (&nest, 0);
; 2423 : 
; 2424 :           CloseHandle (GetCurrentThread ());
; 2425 : 
; 2426 :           return 0;
; 2427 :         }, nullptr, 0x00, nullptr);
; 2428 : 
; 2429 :         return hr;

	mov	eax, esi

; 2436 : 
; 2437 :   return hr;
; 2438 : }

	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@SK_DXGI_Pr:
$LN25@SK_DXGI_Pr:

; 2435 :   __except (EXCEPTION_EXECUTE_HANDLER) {                                                    }

	mov	eax, 1
$LN23@SK_DXGI_Pr:
$LN17@SK_DXGI_Pr:
	ret	0
$LN16@SK_DXGI_Pr:
	mov	esp, DWORD PTR __$SEHRec$[ebp]

; 2430 :       }
; 2431 :     }
; 2432 :   }
; 2433 : 
; 2434 :   __try                                { hr = Present_Original (This, SyncInterval, Flags); }

	mov	DWORD PTR __$SEHRec$[ebp+20], -1
	mov	eax, DWORD PTR _hr$[ebp]

; 2436 : 
; 2437 :   return hr;
; 2438 : }

	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SK_DXGI_Present@@YAJPAUIDXGISwapChain@@II@Z ENDP	; SK_DXGI_Present
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\combaseapi.h
;	COMDAT ??$IID_PPV_ARGS_Helper@UIDXGIFactory@@@@YAPAPAXPAPAUIDXGIFactory@@@Z
_TEXT	SEGMENT
_pp$ = 8						; size = 4
??$IID_PPV_ARGS_Helper@UIDXGIFactory@@@@YAPAPAXPAPAUIDXGIFactory@@@Z PROC ; IID_PPV_ARGS_Helper<IDXGIFactory>, COMDAT

; 227  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 228  : #pragma prefast(suppress: 6269, "Tool issue with unused static_cast")
; 229  :         static_cast<IUnknown*>(*pp);    // make sure everyone derives from IUnknown
; 230  :         return reinterpret_cast<void**>(pp);

	mov	eax, DWORD PTR _pp$[ebp]

; 231  :     }    

	pop	ebp
	ret	0
??$IID_PPV_ARGS_Helper@UIDXGIFactory@@@@YAPAPAXPAPAUIDXGIFactory@@@Z ENDP ; IID_PPV_ARGS_Helper<IDXGIFactory>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
;	COMDAT ??$QueryInterface@UIDXGIDevice@@@IUnknown@@QAGJPAPAUIDXGIDevice@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pp$ = 12						; size = 4
??$QueryInterface@UIDXGIDevice@@@IUnknown@@QAGJPAPAUIDXGIDevice@@@Z PROC ; IUnknown::QueryInterface<IDXGIDevice>, COMDAT

; 130  :             {

	npad	2
	push	ebp
	mov	ebp, esp

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	mov	eax, DWORD PTR _this$[ebp]
	push	DWORD PTR _pp$[ebp]
	push	OFFSET __GUID_54ec77fa_1377_44e6_8c32_88fd5f44c84c
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx]

; 132  :             }

	pop	ebp
	ret	8
??$QueryInterface@UIDXGIDevice@@@IUnknown@@QAGJPAPAUIDXGIDevice@@@Z ENDP ; IUnknown::QueryInterface<IDXGIDevice>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtr@UIDXGIFactory@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComPtr@UIDXGIFactory@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<IDXGIFactory>::~CComPtr<IDXGIFactory>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComPtr@UIDXGIFactory@@@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@CComPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN4@CComPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComPtr@UIDXGIFactory@@@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComPtr@UIDXGIFactory@@@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComPtr@UIDXGIFactory@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<IDXGIFactory>::~CComPtr<IDXGIFactory>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UIDXGIFactory@@@ATL@@QAE@PAUIDXGIFactory@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtr@UIDXGIFactory@@@ATL@@QAE@PAUIDXGIFactory@@@Z PROC ; ATL::CComPtr<IDXGIFactory>::CComPtr<IDXGIFactory>, COMDAT
; _this$ = ecx

; 312  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi

; 312  :     {

	mov	esi, ecx

; 162  :         p = lp;

	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN6@CComPtr

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN6@CComPtr:

; 313  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtr@UIDXGIFactory@@@ATL@@QAE@PAUIDXGIFactory@@@Z ENDP ; ATL::CComPtr<IDXGIFactory>::CComPtr<IDXGIFactory>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??C?$CComPtrBase@UIDXGIFactory@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIDXGIFactory@@@1@XZ
_TEXT	SEGMENT
??C?$CComPtrBase@UIDXGIFactory@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIDXGIFactory@@@1@XZ PROC ; ATL::CComPtrBase<IDXGIFactory>::operator->, COMDAT
; _this$ = ecx

; 197  :         ATLASSERT(p!=NULL);
; 198  :         return (_NoAddRefReleaseOnCComPtr<T>*)p;

	mov	eax, DWORD PTR [ecx]

; 199  :     }

	ret	0
??C?$CComPtrBase@UIDXGIFactory@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIDXGIFactory@@@1@XZ ENDP ; ATL::CComPtrBase<IDXGIFactory>::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??I?$CComPtrBase@UIDXGIFactory@@@ATL@@QAEPAPAUIDXGIFactory@@XZ
_TEXT	SEGMENT
??I?$CComPtrBase@UIDXGIFactory@@@ATL@@QAEPAPAUIDXGIFactory@@XZ PROC ; ATL::CComPtrBase<IDXGIFactory>::operator&, COMDAT
; _this$ = ecx

; 192  :         ATLASSERT(p==NULL);
; 193  :         return &p;

	mov	eax, ecx

; 194  :     }

	ret	0
??I?$CComPtrBase@UIDXGIFactory@@@ATL@@QAEPAPAUIDXGIFactory@@XZ ENDP ; ATL::CComPtrBase<IDXGIFactory>::operator&
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??B?$CComPtrBase@UIDXGIFactory@@@ATL@@QBEPAUIDXGIFactory@@XZ
_TEXT	SEGMENT
??B?$CComPtrBase@UIDXGIFactory@@@ATL@@QBEPAUIDXGIFactory@@XZ PROC ; ATL::CComPtrBase<IDXGIFactory>::operator IDXGIFactory *, COMDAT
; _this$ = ecx

; 181  :         return p;

	mov	eax, DWORD PTR [ecx]

; 182  :     }

	ret	0
??B?$CComPtrBase@UIDXGIFactory@@@ATL@@QBEPAUIDXGIFactory@@XZ ENDP ; ATL::CComPtrBase<IDXGIFactory>::operator IDXGIFactory *
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UIDXGIFactory@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UIDXGIFactory@@@ATL@@QAE@XZ PROC	; ATL::CComPtrBase<IDXGIFactory>::~CComPtrBase<IDXGIFactory>, COMDAT
; _this$ = ecx

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN2@CComPtrBas

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@CComPtrBas:

; 178  :     }

	ret	0
??1?$CComPtrBase@UIDXGIFactory@@@ATL@@QAE@XZ ENDP	; ATL::CComPtrBase<IDXGIFactory>::~CComPtrBase<IDXGIFactory>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UIDXGIFactory@@@ATL@@IAE@PAUIDXGIFactory@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtrBase@UIDXGIFactory@@@ATL@@IAE@PAUIDXGIFactory@@@Z PROC ; ATL::CComPtrBase<IDXGIFactory>::CComPtrBase<IDXGIFactory>, COMDAT
; _this$ = ecx

; 160  :     CComPtrBase(_Inout_opt_ T* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp

; 161  :     {
; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN4@CComPtrBas

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN4@CComPtrBas:

; 165  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtrBase@UIDXGIFactory@@@ATL@@IAE@PAUIDXGIFactory@@@Z ENDP ; ATL::CComPtrBase<IDXGIFactory>::CComPtrBase<IDXGIFactory>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtr@UIDXGIAdapter@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComPtr@UIDXGIAdapter@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<IDXGIAdapter>::~CComPtr<IDXGIAdapter>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComPtr@UIDXGIAdapter@@@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@CComPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN4@CComPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComPtr@UIDXGIAdapter@@@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComPtr@UIDXGIAdapter@@@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComPtr@UIDXGIAdapter@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<IDXGIAdapter>::~CComPtr<IDXGIAdapter>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UIDXGIAdapter@@@ATL@@QAE@PAUIDXGIAdapter@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtr@UIDXGIAdapter@@@ATL@@QAE@PAUIDXGIAdapter@@@Z PROC ; ATL::CComPtr<IDXGIAdapter>::CComPtr<IDXGIAdapter>, COMDAT
; _this$ = ecx

; 312  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi

; 312  :     {

	mov	esi, ecx

; 162  :         p = lp;

	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN6@CComPtr

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN6@CComPtr:

; 313  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtr@UIDXGIAdapter@@@ATL@@QAE@PAUIDXGIAdapter@@@Z ENDP ; ATL::CComPtr<IDXGIAdapter>::CComPtr<IDXGIAdapter>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??C?$CComPtrBase@UIDXGIAdapter@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIDXGIAdapter@@@1@XZ
_TEXT	SEGMENT
??C?$CComPtrBase@UIDXGIAdapter@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIDXGIAdapter@@@1@XZ PROC ; ATL::CComPtrBase<IDXGIAdapter>::operator->, COMDAT
; _this$ = ecx

; 197  :         ATLASSERT(p!=NULL);
; 198  :         return (_NoAddRefReleaseOnCComPtr<T>*)p;

	mov	eax, DWORD PTR [ecx]

; 199  :     }

	ret	0
??C?$CComPtrBase@UIDXGIAdapter@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIDXGIAdapter@@@1@XZ ENDP ; ATL::CComPtrBase<IDXGIAdapter>::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??I?$CComPtrBase@UIDXGIAdapter@@@ATL@@QAEPAPAUIDXGIAdapter@@XZ
_TEXT	SEGMENT
??I?$CComPtrBase@UIDXGIAdapter@@@ATL@@QAEPAPAUIDXGIAdapter@@XZ PROC ; ATL::CComPtrBase<IDXGIAdapter>::operator&, COMDAT
; _this$ = ecx

; 192  :         ATLASSERT(p==NULL);
; 193  :         return &p;

	mov	eax, ecx

; 194  :     }

	ret	0
??I?$CComPtrBase@UIDXGIAdapter@@@ATL@@QAEPAPAUIDXGIAdapter@@XZ ENDP ; ATL::CComPtrBase<IDXGIAdapter>::operator&
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UIDXGIAdapter@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UIDXGIAdapter@@@ATL@@QAE@XZ PROC	; ATL::CComPtrBase<IDXGIAdapter>::~CComPtrBase<IDXGIAdapter>, COMDAT
; _this$ = ecx

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN2@CComPtrBas

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@CComPtrBas:

; 178  :     }

	ret	0
??1?$CComPtrBase@UIDXGIAdapter@@@ATL@@QAE@XZ ENDP	; ATL::CComPtrBase<IDXGIAdapter>::~CComPtrBase<IDXGIAdapter>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UIDXGIAdapter@@@ATL@@IAE@PAUIDXGIAdapter@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtrBase@UIDXGIAdapter@@@ATL@@IAE@PAUIDXGIAdapter@@@Z PROC ; ATL::CComPtrBase<IDXGIAdapter>::CComPtrBase<IDXGIAdapter>, COMDAT
; _this$ = ecx

; 160  :     CComPtrBase(_Inout_opt_ T* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp

; 161  :     {
; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN4@CComPtrBas

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN4@CComPtrBas:

; 165  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtrBase@UIDXGIAdapter@@@ATL@@IAE@PAUIDXGIAdapter@@@Z ENDP ; ATL::CComPtrBase<IDXGIAdapter>::CComPtrBase<IDXGIAdapter>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtr@UIDXGIDevice@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComPtr@UIDXGIDevice@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<IDXGIDevice>::~CComPtr<IDXGIDevice>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComPtr@UIDXGIDevice@@@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@CComPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN4@CComPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComPtr@UIDXGIDevice@@@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComPtr@UIDXGIDevice@@@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComPtr@UIDXGIDevice@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<IDXGIDevice>::~CComPtr<IDXGIDevice>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UIDXGIDevice@@@ATL@@QAE@PAUIDXGIDevice@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtr@UIDXGIDevice@@@ATL@@QAE@PAUIDXGIDevice@@@Z PROC ; ATL::CComPtr<IDXGIDevice>::CComPtr<IDXGIDevice>, COMDAT
; _this$ = ecx

; 312  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi

; 312  :     {

	mov	esi, ecx

; 162  :         p = lp;

	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN6@CComPtr

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN6@CComPtr:

; 313  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtr@UIDXGIDevice@@@ATL@@QAE@PAUIDXGIDevice@@@Z ENDP ; ATL::CComPtr<IDXGIDevice>::CComPtr<IDXGIDevice>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??C?$CComPtrBase@UIDXGIDevice@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIDXGIDevice@@@1@XZ
_TEXT	SEGMENT
??C?$CComPtrBase@UIDXGIDevice@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIDXGIDevice@@@1@XZ PROC ; ATL::CComPtrBase<IDXGIDevice>::operator->, COMDAT
; _this$ = ecx

; 197  :         ATLASSERT(p!=NULL);
; 198  :         return (_NoAddRefReleaseOnCComPtr<T>*)p;

	mov	eax, DWORD PTR [ecx]

; 199  :     }

	ret	0
??C?$CComPtrBase@UIDXGIDevice@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIDXGIDevice@@@1@XZ ENDP ; ATL::CComPtrBase<IDXGIDevice>::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??I?$CComPtrBase@UIDXGIDevice@@@ATL@@QAEPAPAUIDXGIDevice@@XZ
_TEXT	SEGMENT
??I?$CComPtrBase@UIDXGIDevice@@@ATL@@QAEPAPAUIDXGIDevice@@XZ PROC ; ATL::CComPtrBase<IDXGIDevice>::operator&, COMDAT
; _this$ = ecx

; 192  :         ATLASSERT(p==NULL);
; 193  :         return &p;

	mov	eax, ecx

; 194  :     }

	ret	0
??I?$CComPtrBase@UIDXGIDevice@@@ATL@@QAEPAPAUIDXGIDevice@@XZ ENDP ; ATL::CComPtrBase<IDXGIDevice>::operator&
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UIDXGIDevice@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UIDXGIDevice@@@ATL@@QAE@XZ PROC	; ATL::CComPtrBase<IDXGIDevice>::~CComPtrBase<IDXGIDevice>, COMDAT
; _this$ = ecx

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN2@CComPtrBas

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@CComPtrBas:

; 178  :     }

	ret	0
??1?$CComPtrBase@UIDXGIDevice@@@ATL@@QAE@XZ ENDP	; ATL::CComPtrBase<IDXGIDevice>::~CComPtrBase<IDXGIDevice>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UIDXGIDevice@@@ATL@@IAE@PAUIDXGIDevice@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtrBase@UIDXGIDevice@@@ATL@@IAE@PAUIDXGIDevice@@@Z PROC ; ATL::CComPtrBase<IDXGIDevice>::CComPtrBase<IDXGIDevice>, COMDAT
; _this$ = ecx

; 160  :     CComPtrBase(_Inout_opt_ T* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp

; 161  :     {
; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN4@CComPtrBas

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN4@CComPtrBas:

; 165  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtrBase@UIDXGIDevice@@@ATL@@IAE@PAUIDXGIDevice@@@Z ENDP ; ATL::CComPtrBase<IDXGIDevice>::CComPtrBase<IDXGIDevice>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_desc$2 = -84						; size = 60
_pDevDXGI$3 = -24					; size = 4
_pAdapter$4 = -20					; size = 4
_pDev$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_This$ = 8						; size = 4
_pFactory$5 = 12					; size = 4
_SyncInterval$ = 12					; size = 4
_interval$2$ = 16					; size = 4
_PresentFlags$ = 16					; size = 4
_pPresentParameters$ = 20				; size = 4
?Present1Callback@@YGJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@Z PROC ; Present1Callback

; 2237 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?Present1Callback@@YGJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 72					; 00000048H

; 2238 :   SK_LOG_ONCE (L"Present1");

	cmp	BYTE PTR ?logged@?2??Present1Callback@@YGJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@Z@4_NA, 0
	jne	SHORT $LN4@Present1Ca
	push	OFFSET $SG354696
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8
	mov	BYTE PTR ?logged@?2??Present1Callback@@YGJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@Z@4_NA, 1
$LN4@Present1Ca:

; 2239 : 
; 2240 :   //
; 2241 :   // Early-out for games that use testing to minimize blocking
; 2242 :   //
; 2243 :   if (PresentFlags & DXGI_PRESENT_TEST)

	push	ebx
	mov	ebx, DWORD PTR _PresentFlags$[ebp]
	test	bl, 1
	je	SHORT $LN5@Present1Ca

; 2244 :   {
; 2245 :     return Present1_Original (

	push	DWORD PTR _pPresentParameters$[ebp]
	push	ebx
	push	DWORD PTR _SyncInterval$[ebp]
	push	DWORD PTR _This$[ebp]
	call	DWORD PTR ?Present1_Original@@3P6GJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@ZA ; Present1_Original
	pop	ebx

; 2362 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN5@Present1Ca:
	push	esi
	push	edi

; 2246 :              This,
; 2247 :                SyncInterval,
; 2248 :                  PresentFlags,
; 2249 :                    pPresentParameters );
; 2250 :   }
; 2251 : 
; 2252 :   SK_GetCurrentRenderBackend ().present_interval = SyncInterval;

	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend
	mov	ecx, DWORD PTR _SyncInterval$[ebp]

; 2253 : 
; 2254 :   // Start / End / Read back Pipeline Stats
; 2255 :   SK_D3D11_UpdateRenderStats (This);

	mov	edi, DWORD PTR _This$[ebp]
	push	edi
	mov	DWORD PTR [eax+64], ecx
	call	?SK_D3D11_UpdateRenderStats@@YGXPAUIDXGISwapChain@@@Z ; SK_D3D11_UpdateRenderStats

; 2256 :   SK_D3D12_UpdateRenderStats (This);

	push	edi
	call	?SK_D3D12_UpdateRenderStats@@YGXPAUIDXGISwapChain@@@Z ; SK_D3D12_UpdateRenderStats

; 2257 : 
; 2258 :   // Establish the API used this frame (and handle possible translation layers)
; 2259 :   //
; 2260 :   switch (SK_GetDLLRole ())

	call	?SK_GetDLLRole@@YG?AW4DLL_ROLE@@XZ	; SK_GetDLLRole
	cmp	eax, -1073741808			; c0000010H
	je	SHORT $LN6@Present1Ca
	cmp	eax, -1073741792			; c0000020H
	je	SHORT $LN7@Present1Ca

; 2268 :     default:
; 2269 :       SK_GetCurrentRenderBackend ().api = SK_RenderAPI::D3D11;

	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend
	mov	DWORD PTR [eax], 64			; 00000040H
	jmp	SHORT $LN2@Present1Ca
$LN7@Present1Ca:

; 2264 :       break;
; 2265 :     case DLL_ROLE::DDraw:
; 2266 :       SK_GetCurrentRenderBackend ().api = SK_RenderAPI::DDrawOn11;

	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend
	mov	DWORD PTR [eax], 16448			; 00004040H

; 2267 :       break;

	jmp	SHORT $LN2@Present1Ca
$LN6@Present1Ca:

; 2261 :   {
; 2262 :     case DLL_ROLE::D3D8:
; 2263 :       SK_GetCurrentRenderBackend ().api = SK_RenderAPI::D3D8On11;

	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend
	mov	DWORD PTR [eax], 8256			; 00002040H
$LN2@Present1Ca:

; 2270 :       break;
; 2271 :   }
; 2272 : 
; 2273 :   SK_BeginBufferSwap ();

	call	?SK_BeginBufferSwap@@YGXXZ		; SK_BeginBufferSwap
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pDev$[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2278 :   This->GetDevice (IID_PPV_ARGS (&pDev));

	mov	esi, DWORD PTR [edi]
	lea	eax, DWORD PTR _pDev$[ebp]
	push	eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??$IID_PPV_ARGS_Helper@UID3D11Device@@@@YAPAPAXPAPAUID3D11Device@@@Z ; IID_PPV_ARGS_Helper<ID3D11Device>
	add	esp, 4
	push	eax
	push	OFFSET __GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140
	push	edi
	call	DWORD PTR [esi+28]

; 2279 : 
; 2280 :   int interval = config.render.framerate.present_interval;

	mov	esi, DWORD PTR ?config@@3Usk_config_t@@A+404

; 2281 :   int flags    = PresentFlags;
; 2282 : 
; 2283 :   // Application preference
; 2284 :   if (interval == -1)

	cmp	esi, -1
	cmove	esi, DWORD PTR _SyncInterval$[ebp]

; 2285 :     interval = SyncInterval;
; 2286 : 
; 2287 :   if (bFlipMode)

	cmp	BYTE PTR ?bFlipMode@@3_NA, 0		; bFlipMode
	mov	DWORD PTR _interval$2$[ebp], esi
	je	SHORT $LN11@Present1Ca

; 2288 :   {
; 2289 :     flags = PresentFlags | DXGI_PRESENT_RESTART;

	or	ebx, 4

; 2290 : 
; 2291 :     if (bWait)

	cmp	BYTE PTR ?bWait@@3_NA, 0		; bWait
	je	SHORT $LN11@Present1Ca

; 2292 :       flags |= DXGI_PRESENT_DO_NOT_WAIT;

	or	ebx, 8
$LN11@Present1Ca:

; 2293 :   }
; 2294 : 
; 2295 :   static bool first_frame = true;
; 2296 : 
; 2297 :   if (first_frame)

	cmp	BYTE PTR ?first_frame@?1??Present1Callback@@YGJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@Z@4_NA, 0
	je	$LN12@Present1Ca
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 214  :         return p == pT;

	mov	eax, DWORD PTR _pDev$[ebp]
	test	eax, eax
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2308 :     if ( pDev  != nullptr )

	je	$LN13@Present1Ca
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pDevDXGI$3[ebp], 0
	mov	DWORD PTR _pAdapter$4[ebp], 0
	mov	DWORD PTR _pFactory$5[ebp], 0
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR _pDevDXGI$3[ebp]
	push	edx
	push	OFFSET __GUID_54ec77fa_1377_44e6_8c32_88fd5f44c84c
	push	eax
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2312 :       CComPtr <IDXGIFactory> pFactory = nullptr;

	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	call	DWORD PTR [ecx]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2315 :            SUCCEEDED (pDevDXGI->GetAdapter               (&pAdapter)) &&

	test	eax, eax
	js	$LN18@Present1Ca
	mov	eax, DWORD PTR _pDevDXGI$3[ebp]
	lea	edx, DWORD PTR _pAdapter$4[ebp]
	push	edx
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+28]
	test	eax, eax
	js	$LN18@Present1Ca
	mov	esi, DWORD PTR _pAdapter$4[ebp]
	lea	eax, DWORD PTR _pFactory$5[ebp]
	push	eax
	mov	edi, DWORD PTR [esi]
	call	??$IID_PPV_ARGS_Helper@UIDXGIFactory@@@@YAPAPAXPAPAUIDXGIFactory@@@Z ; IID_PPV_ARGS_Helper<IDXGIFactory>
	add	esp, 4
	push	eax
	push	OFFSET __GUID_7b7166ec_21c7_44ae_b21a_c9ae321ae369
	push	esi
	call	DWORD PTR [edi+24]

; 2316 :            SUCCEEDED (pAdapter->GetParent  (IID_PPV_ARGS (&pFactory))) )
; 2317 :       {
; 2318 :         DXGI_SWAP_CHAIN_DESC desc;
; 2319 :         This->GetDesc (&desc);

	mov	edi, DWORD PTR _This$[ebp]
	test	eax, eax
	js	SHORT $LN108@Present1Ca
	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR _desc$2[ebp]
	push	ecx
	push	edi
	call	DWORD PTR [eax+48]

; 2320 : 
; 2321 :         if (config.render.dxgi.safe_fullscreen) pFactory->MakeWindowAssociation ( nullptr, 0 );

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+488, 0
	je	SHORT $LN16@Present1Ca
	mov	eax, DWORD PTR _pFactory$5[ebp]
	push	0
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+32]
$LN16@Present1Ca:

; 2322 : 
; 2323 : 
; 2324 :         if (bAlwaysAllowFullscreen)

	cmp	BYTE PTR ?bAlwaysAllowFullscreen@@3_NA, 0 ; bAlwaysAllowFullscreen
	je	SHORT $LN17@Present1Ca

; 2325 :         {
; 2326 :           pFactory->MakeWindowAssociation (

	mov	eax, DWORD PTR _pFactory$5[ebp]
	push	1
	push	DWORD PTR _desc$2[ebp+44]
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+32]
$LN17@Present1Ca:

; 2327 :             desc.OutputWindow,
; 2328 :               DXGI_MWA_NO_WINDOW_CHANGES
; 2329 :           );
; 2330 :         }
; 2331 : 
; 2332 :         if (hWndRender == nullptr || (! IsWindow (hWndRender)))

	mov	eax, DWORD PTR ?hWndRender@@3PAUHWND__@@A ; hWndRender
	test	eax, eax
	je	SHORT $LN19@Present1Ca
	push	eax
	call	DWORD PTR __imp__IsWindow@4
	test	eax, eax
	jne	SHORT $LN108@Present1Ca
$LN19@Present1Ca:

; 2333 :         {
; 2334 :           hWndRender       = desc.OutputWindow;

	mov	eax, DWORD PTR _desc$2[ebp+44]

; 2335 : 
; 2336 :           SK_InstallWindowHook (hWndRender);

	push	eax
	mov	DWORD PTR ?hWndRender@@3PAUHWND__@@A, eax ; hWndRender
	call	?SK_InstallWindowHook@@YAXPAUHWND__@@@Z	; SK_InstallWindowHook

; 2337 :           game_window.hWnd =    hWndRender;

	mov	eax, DWORD PTR ?hWndRender@@3PAUHWND__@@A ; hWndRender
	add	esp, 4
	mov	DWORD PTR ?game_window@@3Usk_window_s@@A+4, eax
$LN108@Present1Ca:
	mov	esi, DWORD PTR _interval$2$[ebp]
$LN18@Present1Ca:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	mov	eax, DWORD PTR _pFactory$5[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2340 :     }

	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN75@Present1Ca

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN75@Present1Ca:

; 176  :         if (p)

	mov	eax, DWORD PTR _pAdapter$4[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2340 :     }

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN81@Present1Ca

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN81@Present1Ca:

; 176  :         if (p)

	mov	eax, DWORD PTR _pDevDXGI$3[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2340 :     }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN13@Present1Ca

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2343 :   else

	jmp	SHORT $LN13@Present1Ca
$LN12@Present1Ca:

; 2344 :     SK_CEGUI_DrawD3D11 (This);

	push	edi
	call	?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z ; SK_CEGUI_DrawD3D11
	add	esp, 4
$LN13@Present1Ca:

; 2345 : 
; 2346 :   hr = Present1_Original (This, interval, flags, pPresentParameters);

	push	DWORD PTR _pPresentParameters$[ebp]
	push	ebx
	push	esi
	push	edi
	call	DWORD PTR ?Present1_Original@@3P6GJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@ZA ; Present1_Original
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 214  :         return p == pT;

	mov	ecx, DWORD PTR _pDev$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2348 :   first_frame = false;

	mov	BYTE PTR ?first_frame@?1??Present1Callback@@YGJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@Z@4_NA, 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 214  :         return p == pT;

	test	ecx, ecx
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2350 :   if ( pDev  != nullptr )

	je	SHORT $LN20@Present1Ca

; 2351 :   {
; 2352 :     HRESULT ret =
; 2353 :       SK_EndBufferSwap (hr, pDev);

	push	ecx
	push	eax
	call	?SK_EndBufferSwap@@YGJJPAUIUnknown@@@Z	; SK_EndBufferSwap
	mov	esi, eax

; 2354 : 
; 2355 :     SK_D3D11_TexCacheCheckpoint ();

	call	?SK_D3D11_TexCacheCheckpoint@@YGXXZ	; SK_D3D11_TexCacheCheckpoint
	jmp	SHORT $LN26@Present1Ca
$LN20@Present1Ca:

; 2361 :   return SK_EndBufferSwap (hr);

	push	0
	push	eax
	call	?SK_EndBufferSwap@@YGJJPAUIUnknown@@@Z	; SK_EndBufferSwap
	mov	esi, eax
$LN26@Present1Ca:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	mov	ecx, DWORD PTR _pDev$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2361 :   return SK_EndBufferSwap (hr);

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	ecx, ecx
	je	SHORT $LN105@Present1Ca

; 177  :             p->Release();

	mov	edx, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [edx+8]
$LN105@Present1Ca:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2362 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?Present1Callback@@YGJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@Z$0:
	lea	ecx, DWORD PTR _pDev$[ebp]
	jmp	??1?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ
__unwindfunclet$?Present1Callback@@YGJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@Z$1:
	lea	ecx, DWORD PTR _pDevDXGI$3[ebp]
	jmp	??1?$CComPtr@UIDXGIDevice@@@ATL@@QAE@XZ
__unwindfunclet$?Present1Callback@@YGJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@Z$2:
	lea	ecx, DWORD PTR _pAdapter$4[ebp]
	jmp	??1?$CComPtr@UIDXGIAdapter@@@ATL@@QAE@XZ
__unwindfunclet$?Present1Callback@@YGJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@Z$3:
	lea	ecx, DWORD PTR _pFactory$5[ebp]
	jmp	??1?$CComPtr@UIDXGIFactory@@@ATL@@QAE@XZ
__ehhandler$?Present1Callback@@YGJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?Present1Callback@@YGJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Present1Callback@@YGJPAUIDXGISwapChain1@@IIPBUDXGI_PRESENT_PARAMETERS@@@Z ENDP ; Present1Callback
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\combaseapi.h
;	COMDAT ??$IID_PPV_ARGS_Helper@UIDXGISurface@@@@YAPAPAXPAPAUIDXGISurface@@@Z
_TEXT	SEGMENT
_pp$ = 8						; size = 4
??$IID_PPV_ARGS_Helper@UIDXGISurface@@@@YAPAPAXPAPAUIDXGISurface@@@Z PROC ; IID_PPV_ARGS_Helper<IDXGISurface>, COMDAT

; 227  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 228  : #pragma prefast(suppress: 6269, "Tool issue with unused static_cast")
; 229  :         static_cast<IUnknown*>(*pp);    // make sure everyone derives from IUnknown
; 230  :         return reinterpret_cast<void**>(pp);

	mov	eax, DWORD PTR _pp$[ebp]

; 231  :     }    

	pop	ebp
	ret	0
??$IID_PPV_ARGS_Helper@UIDXGISurface@@@@YAPAPAXPAPAUIDXGISurface@@@Z ENDP ; IID_PPV_ARGS_Helper<IDXGISurface>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtr@UIDXGISurface@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComPtr@UIDXGISurface@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<IDXGISurface>::~CComPtr<IDXGISurface>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComPtr@UIDXGISurface@@@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@CComPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN4@CComPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComPtr@UIDXGISurface@@@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComPtr@UIDXGISurface@@@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComPtr@UIDXGISurface@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<IDXGISurface>::~CComPtr<IDXGISurface>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UIDXGISurface@@@ATL@@QAE@PAUIDXGISurface@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtr@UIDXGISurface@@@ATL@@QAE@PAUIDXGISurface@@@Z PROC ; ATL::CComPtr<IDXGISurface>::CComPtr<IDXGISurface>, COMDAT
; _this$ = ecx

; 312  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi

; 312  :     {

	mov	esi, ecx

; 162  :         p = lp;

	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN6@CComPtr

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN6@CComPtr:

; 313  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtr@UIDXGISurface@@@ATL@@QAE@PAUIDXGISurface@@@Z ENDP ; ATL::CComPtr<IDXGISurface>::CComPtr<IDXGISurface>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??I?$CComPtrBase@UIDXGISurface@@@ATL@@QAEPAPAUIDXGISurface@@XZ
_TEXT	SEGMENT
??I?$CComPtrBase@UIDXGISurface@@@ATL@@QAEPAPAUIDXGISurface@@XZ PROC ; ATL::CComPtrBase<IDXGISurface>::operator&, COMDAT
; _this$ = ecx

; 192  :         ATLASSERT(p==NULL);
; 193  :         return &p;

	mov	eax, ecx

; 194  :     }

	ret	0
??I?$CComPtrBase@UIDXGISurface@@@ATL@@QAEPAPAUIDXGISurface@@XZ ENDP ; ATL::CComPtrBase<IDXGISurface>::operator&
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??B?$CComPtrBase@UIDXGISurface@@@ATL@@QBEPAUIDXGISurface@@XZ
_TEXT	SEGMENT
??B?$CComPtrBase@UIDXGISurface@@@ATL@@QBEPAUIDXGISurface@@XZ PROC ; ATL::CComPtrBase<IDXGISurface>::operator IDXGISurface *, COMDAT
; _this$ = ecx

; 181  :         return p;

	mov	eax, DWORD PTR [ecx]

; 182  :     }

	ret	0
??B?$CComPtrBase@UIDXGISurface@@@ATL@@QBEPAUIDXGISurface@@XZ ENDP ; ATL::CComPtrBase<IDXGISurface>::operator IDXGISurface *
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UIDXGISurface@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UIDXGISurface@@@ATL@@QAE@XZ PROC	; ATL::CComPtrBase<IDXGISurface>::~CComPtrBase<IDXGISurface>, COMDAT
; _this$ = ecx

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN2@CComPtrBas

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@CComPtrBas:

; 178  :     }

	ret	0
??1?$CComPtrBase@UIDXGISurface@@@ATL@@QAE@XZ ENDP	; ATL::CComPtrBase<IDXGISurface>::~CComPtrBase<IDXGISurface>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UIDXGISurface@@@ATL@@IAE@PAUIDXGISurface@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtrBase@UIDXGISurface@@@ATL@@IAE@PAUIDXGISurface@@@Z PROC ; ATL::CComPtrBase<IDXGISurface>::CComPtrBase<IDXGISurface>, COMDAT
; _this$ = ecx

; 160  :     CComPtrBase(_Inout_opt_ T* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp

; 161  :     {
; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN4@CComPtrBas

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN4@CComPtrBas:

; 165  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtrBase@UIDXGISurface@@@ATL@@IAE@PAUIDXGISurface@@@Z ENDP ; ATL::CComPtrBase<IDXGISurface>::CComPtrBase<IDXGISurface>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\memory
;	COMDAT ?get@?$unique_ptr@USK_D3D11_Stateblock_Lite@@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@@std@@QBEPAUSK_D3D11_Stateblock_Lite@@XZ
_TEXT	SEGMENT
?get@?$unique_ptr@USK_D3D11_Stateblock_Lite@@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@@std@@QBEPAUSK_D3D11_Stateblock_Lite@@XZ PROC ; std::unique_ptr<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> >::get, COMDAT
; _this$ = ecx

; 1834 : 		return (this->_Myptr());

	mov	eax, DWORD PTR [ecx]

; 1835 : 		}

	ret	0
?get@?$unique_ptr@USK_D3D11_Stateblock_Lite@@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@@std@@QBEPAUSK_D3D11_Stateblock_Lite@@XZ ENDP ; std::unique_ptr<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> >::get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\memory
;	COMDAT ??C?$unique_ptr@USK_D3D11_Stateblock_Lite@@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@@std@@QBEPAUSK_D3D11_Stateblock_Lite@@XZ
_TEXT	SEGMENT
??C?$unique_ptr@USK_D3D11_Stateblock_Lite@@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@@std@@QBEPAUSK_D3D11_Stateblock_Lite@@XZ PROC ; std::unique_ptr<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> >::operator->, COMDAT
; _this$ = ecx

; 1829 : 		return (this->_Myptr());

	mov	eax, DWORD PTR [ecx]

; 1830 : 		}

	ret	0
??C?$unique_ptr@USK_D3D11_Stateblock_Lite@@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@@std@@QBEPAUSK_D3D11_Stateblock_Lite@@XZ ENDP ; std::unique_ptr<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\memory
;	COMDAT ??1?$unique_ptr@USK_D3D11_Stateblock_Lite@@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$unique_ptr@USK_D3D11_Stateblock_Lite@@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@@std@@QAE@XZ PROC ; std::unique_ptr<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> >::~unique_ptr<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> >, COMDAT
; _this$ = ecx

; 1818 : 		if (get() != pointer())

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN29@unique_ptr

; 1608 : 		delete _Ptr;

	push	2776					; 00000ad8H
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN29@unique_ptr:

; 1819 : 			this->get_deleter()(get());
; 1820 : 		}

	ret	0
??1?$unique_ptr@USK_D3D11_Stateblock_Lite@@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@@std@@QAE@XZ ENDP ; std::unique_ptr<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> >::~unique_ptr<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\memory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\memory
;	COMDAT ??0?$unique_ptr@USK_D3D11_Stateblock_Lite@@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@@std@@QAE@PAUSK_D3D11_Stateblock_Lite@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$unique_ptr@USK_D3D11_Stateblock_Lite@@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@@std@@QAE@PAUSK_D3D11_Stateblock_Lite@@@Z PROC ; std::unique_ptr<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> >::unique_ptr<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> >, COMDAT
; _this$ = ecx

; 1733 : 		{	// construct with pointer

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 302  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\memory

; 1736 : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??0?$unique_ptr@USK_D3D11_Stateblock_Lite@@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@@std@@QAE@PAUSK_D3D11_Stateblock_Lite@@@Z ENDP ; std::unique_ptr<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> >::unique_ptr<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@PAUSK_D3D11_Stateblock_Lite@@$00@std@@QBEABQAUSK_D3D11_Stateblock_Lite@@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@PAUSK_D3D11_Stateblock_Lite@@$00@std@@QBEABQAUSK_D3D11_Stateblock_Lite@@XZ PROC ; std::_Compressed_pair<std::default_delete<SK_D3D11_Stateblock_Lite>,SK_D3D11_Stateblock_Lite *,1>::_Get_second, COMDAT
; _this$ = ecx

; 343  : 		return (_Myval2);

	mov	eax, ecx

; 344  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@PAUSK_D3D11_Stateblock_Lite@@$00@std@@QBEABQAUSK_D3D11_Stateblock_Lite@@XZ ENDP ; std::_Compressed_pair<std::default_delete<SK_D3D11_Stateblock_Lite>,SK_D3D11_Stateblock_Lite *,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@PAUSK_D3D11_Stateblock_Lite@@$00@std@@QAEAAU?$default_delete@USK_D3D11_Stateblock_Lite@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@PAUSK_D3D11_Stateblock_Lite@@$00@std@@QAEAAU?$default_delete@USK_D3D11_Stateblock_Lite@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<SK_D3D11_Stateblock_Lite>,SK_D3D11_Stateblock_Lite *,1>::_Get_first, COMDAT
; _this$ = ecx

; 318  : 		return (*this);

	mov	eax, ecx

; 319  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@PAUSK_D3D11_Stateblock_Lite@@$00@std@@QAEAAU?$default_delete@USK_D3D11_Stateblock_Lite@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<SK_D3D11_Stateblock_Lite>,SK_D3D11_Stateblock_Lite *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\memory
;	COMDAT ?_Myptr@?$_Unique_ptr_base@USK_D3D11_Stateblock_Lite@@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@@std@@QBEABQAUSK_D3D11_Stateblock_Lite@@XZ
_TEXT	SEGMENT
?_Myptr@?$_Unique_ptr_base@USK_D3D11_Stateblock_Lite@@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@@std@@QBEABQAUSK_D3D11_Stateblock_Lite@@XZ PROC ; std::_Unique_ptr_base<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> >::_Myptr, COMDAT
; _this$ = ecx

; 1690 : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 1691 : 		}

	ret	0
?_Myptr@?$_Unique_ptr_base@USK_D3D11_Stateblock_Lite@@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@@std@@QBEABQAUSK_D3D11_Stateblock_Lite@@XZ ENDP ; std::_Unique_ptr_base<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\memory
;	COMDAT ?get_deleter@?$_Unique_ptr_base@USK_D3D11_Stateblock_Lite@@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@@std@@QAEAAU?$default_delete@USK_D3D11_Stateblock_Lite@@@2@XZ
_TEXT	SEGMENT
?get_deleter@?$_Unique_ptr_base@USK_D3D11_Stateblock_Lite@@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@@std@@QAEAAU?$default_delete@USK_D3D11_Stateblock_Lite@@@2@XZ PROC ; std::_Unique_ptr_base<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> >::get_deleter, COMDAT
; _this$ = ecx

; 1675 : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 1676 : 		}

	ret	0
?get_deleter@?$_Unique_ptr_base@USK_D3D11_Stateblock_Lite@@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@@std@@QAEAAU?$default_delete@USK_D3D11_Stateblock_Lite@@@2@XZ ENDP ; std::_Unique_ptr_base<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> >::get_deleter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\memory
;	COMDAT ??R?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@QBEXPAUSK_D3D11_Stateblock_Lite@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??R?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@QBEXPAUSK_D3D11_Stateblock_Lite@@@Z PROC ; std::default_delete<SK_D3D11_Stateblock_Lite>::operator(), COMDAT
; _this$ = ecx

; 1605 : 		{	// delete a pointer

	npad	2
	push	ebp
	mov	ebp, esp

; 1606 : 		static_assert(0 < sizeof (_Ty),
; 1607 : 			"can't delete an incomplete type");
; 1608 : 		delete _Ptr;

	push	2776					; 00000ad8H
	push	DWORD PTR __Ptr$[ebp]
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 1609 : 		}

	pop	ebp
	ret	4
??R?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@QBEXPAUSK_D3D11_Stateblock_Lite@@@Z ENDP ; std::default_delete<SK_D3D11_Stateblock_Lite>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
;	COMDAT ??$QueryInterface@UID3D11Device1@@@IUnknown@@QAGJPAPAUID3D11Device1@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pp$ = 12						; size = 4
??$QueryInterface@UID3D11Device1@@@IUnknown@@QAGJPAPAUID3D11Device1@@@Z PROC ; IUnknown::QueryInterface<ID3D11Device1>, COMDAT

; 130  :             {

	npad	2
	push	ebp
	mov	ebp, esp

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	mov	eax, DWORD PTR _this$[ebp]
	push	DWORD PTR _pp$[ebp]
	push	OFFSET __GUID_a04bfb29_08ef_43d6_a49c_a9bdbdcbe686
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx]

; 132  :             }

	pop	ebp
	ret	8
??$QueryInterface@UID3D11Device1@@@IUnknown@@QAGJPAPAUID3D11Device1@@@Z ENDP ; IUnknown::QueryInterface<ID3D11Device1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
;	COMDAT ??$QueryInterface@UID3D11DeviceContext1@@@IUnknown@@QAGJPAPAUID3D11DeviceContext1@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pp$ = 12						; size = 4
??$QueryInterface@UID3D11DeviceContext1@@@IUnknown@@QAGJPAPAUID3D11DeviceContext1@@@Z PROC ; IUnknown::QueryInterface<ID3D11DeviceContext1>, COMDAT

; 130  :             {

	npad	2
	push	ebp
	mov	ebp, esp

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	mov	eax, DWORD PTR _this$[ebp]
	push	DWORD PTR _pp$[ebp]
	push	OFFSET __GUID_bb2c6faa_b5fb_4082_8e6b_388b8cfa90e1
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx]

; 132  :             }

	pop	ebp
	ret	8
??$QueryInterface@UID3D11DeviceContext1@@@IUnknown@@QAGJPAPAUID3D11DeviceContext1@@@Z ENDP ; IUnknown::QueryInterface<ID3D11DeviceContext1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
;	COMDAT ??$QueryInterface@UID3D11DeviceContext@@@IUnknown@@QAGJPAPAUID3D11DeviceContext@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pp$ = 12						; size = 4
??$QueryInterface@UID3D11DeviceContext@@@IUnknown@@QAGJPAPAUID3D11DeviceContext@@@Z PROC ; IUnknown::QueryInterface<ID3D11DeviceContext>, COMDAT

; 130  :             {

	npad	2
	push	ebp
	mov	ebp, esp

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	mov	eax, DWORD PTR _this$[ebp]
	push	DWORD PTR _pp$[ebp]
	push	OFFSET __GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx]

; 132  :             }

	pop	ebp
	ret	8
??$QueryInterface@UID3D11DeviceContext@@@IUnknown@@QAGJPAPAUID3D11DeviceContext@@@Z ENDP ; IUnknown::QueryInterface<ID3D11DeviceContext>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtr@UID3D11DeviceContext1@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComPtr@UID3D11DeviceContext1@@@ATL@@QAE@XZ PROC	; ATL::CComPtr<ID3D11DeviceContext1>::~CComPtr<ID3D11DeviceContext1>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComPtr@UID3D11DeviceContext1@@@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@CComPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN4@CComPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComPtr@UID3D11DeviceContext1@@@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComPtr@UID3D11DeviceContext1@@@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComPtr@UID3D11DeviceContext1@@@ATL@@QAE@XZ ENDP	; ATL::CComPtr<ID3D11DeviceContext1>::~CComPtr<ID3D11DeviceContext1>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UID3D11DeviceContext1@@@ATL@@QAE@PAUID3D11DeviceContext1@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtr@UID3D11DeviceContext1@@@ATL@@QAE@PAUID3D11DeviceContext1@@@Z PROC ; ATL::CComPtr<ID3D11DeviceContext1>::CComPtr<ID3D11DeviceContext1>, COMDAT
; _this$ = ecx

; 312  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi

; 312  :     {

	mov	esi, ecx

; 162  :         p = lp;

	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN6@CComPtr

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN6@CComPtr:

; 313  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtr@UID3D11DeviceContext1@@@ATL@@QAE@PAUID3D11DeviceContext1@@@Z ENDP ; ATL::CComPtr<ID3D11DeviceContext1>::CComPtr<ID3D11DeviceContext1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??I?$CComPtrBase@UID3D11DeviceContext1@@@ATL@@QAEPAPAUID3D11DeviceContext1@@XZ
_TEXT	SEGMENT
??I?$CComPtrBase@UID3D11DeviceContext1@@@ATL@@QAEPAPAUID3D11DeviceContext1@@XZ PROC ; ATL::CComPtrBase<ID3D11DeviceContext1>::operator&, COMDAT
; _this$ = ecx

; 192  :         ATLASSERT(p==NULL);
; 193  :         return &p;

	mov	eax, ecx

; 194  :     }

	ret	0
??I?$CComPtrBase@UID3D11DeviceContext1@@@ATL@@QAEPAPAUID3D11DeviceContext1@@XZ ENDP ; ATL::CComPtrBase<ID3D11DeviceContext1>::operator&
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UID3D11DeviceContext1@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UID3D11DeviceContext1@@@ATL@@QAE@XZ PROC ; ATL::CComPtrBase<ID3D11DeviceContext1>::~CComPtrBase<ID3D11DeviceContext1>, COMDAT
; _this$ = ecx

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN2@CComPtrBas

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@CComPtrBas:

; 178  :     }

	ret	0
??1?$CComPtrBase@UID3D11DeviceContext1@@@ATL@@QAE@XZ ENDP ; ATL::CComPtrBase<ID3D11DeviceContext1>::~CComPtrBase<ID3D11DeviceContext1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UID3D11DeviceContext1@@@ATL@@IAE@PAUID3D11DeviceContext1@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtrBase@UID3D11DeviceContext1@@@ATL@@IAE@PAUID3D11DeviceContext1@@@Z PROC ; ATL::CComPtrBase<ID3D11DeviceContext1>::CComPtrBase<ID3D11DeviceContext1>, COMDAT
; _this$ = ecx

; 160  :     CComPtrBase(_Inout_opt_ T* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp

; 161  :     {
; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN4@CComPtrBas

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN4@CComPtrBas:

; 165  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtrBase@UID3D11DeviceContext1@@@ATL@@IAE@PAUID3D11DeviceContext1@@@Z ENDP ; ATL::CComPtrBase<ID3D11DeviceContext1>::CComPtrBase<ID3D11DeviceContext1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtr@UID3DDeviceContextState@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComPtr@UID3DDeviceContextState@@@ATL@@QAE@XZ PROC	; ATL::CComPtr<ID3DDeviceContextState>::~CComPtr<ID3DDeviceContextState>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComPtr@UID3DDeviceContextState@@@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@CComPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN4@CComPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComPtr@UID3DDeviceContextState@@@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComPtr@UID3DDeviceContextState@@@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComPtr@UID3DDeviceContextState@@@ATL@@QAE@XZ ENDP	; ATL::CComPtr<ID3DDeviceContextState>::~CComPtr<ID3DDeviceContextState>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UID3DDeviceContextState@@@ATL@@QAE@PAUID3DDeviceContextState@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtr@UID3DDeviceContextState@@@ATL@@QAE@PAUID3DDeviceContextState@@@Z PROC ; ATL::CComPtr<ID3DDeviceContextState>::CComPtr<ID3DDeviceContextState>, COMDAT
; _this$ = ecx

; 312  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi

; 312  :     {

	mov	esi, ecx

; 162  :         p = lp;

	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN6@CComPtr

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN6@CComPtr:

; 313  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtr@UID3DDeviceContextState@@@ATL@@QAE@PAUID3DDeviceContextState@@@Z ENDP ; ATL::CComPtr<ID3DDeviceContextState>::CComPtr<ID3DDeviceContextState>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??I?$CComPtrBase@UID3DDeviceContextState@@@ATL@@QAEPAPAUID3DDeviceContextState@@XZ
_TEXT	SEGMENT
??I?$CComPtrBase@UID3DDeviceContextState@@@ATL@@QAEPAPAUID3DDeviceContextState@@XZ PROC ; ATL::CComPtrBase<ID3DDeviceContextState>::operator&, COMDAT
; _this$ = ecx

; 192  :         ATLASSERT(p==NULL);
; 193  :         return &p;

	mov	eax, ecx

; 194  :     }

	ret	0
??I?$CComPtrBase@UID3DDeviceContextState@@@ATL@@QAEPAPAUID3DDeviceContextState@@XZ ENDP ; ATL::CComPtrBase<ID3DDeviceContextState>::operator&
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UID3DDeviceContextState@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UID3DDeviceContextState@@@ATL@@QAE@XZ PROC ; ATL::CComPtrBase<ID3DDeviceContextState>::~CComPtrBase<ID3DDeviceContextState>, COMDAT
; _this$ = ecx

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN2@CComPtrBas

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@CComPtrBas:

; 178  :     }

	ret	0
??1?$CComPtrBase@UID3DDeviceContextState@@@ATL@@QAE@XZ ENDP ; ATL::CComPtrBase<ID3DDeviceContextState>::~CComPtrBase<ID3DDeviceContextState>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UID3DDeviceContextState@@@ATL@@IAE@PAUID3DDeviceContextState@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtrBase@UID3DDeviceContextState@@@ATL@@IAE@PAUID3DDeviceContextState@@@Z PROC ; ATL::CComPtrBase<ID3DDeviceContextState>::CComPtrBase<ID3DDeviceContextState>, COMDAT
; _this$ = ecx

; 160  :     CComPtrBase(_Inout_opt_ T* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp

; 161  :     {
; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN4@CComPtrBas

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN4@CComPtrBas:

; 165  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtrBase@UID3DDeviceContextState@@@ATL@@IAE@PAUID3DDeviceContextState@@@Z ENDP ; ATL::CComPtrBase<ID3DDeviceContextState>::CComPtrBase<ID3DDeviceContextState>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtr@UID3D11Device1@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComPtr@UID3D11Device1@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<ID3D11Device1>::~CComPtr<ID3D11Device1>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComPtr@UID3D11Device1@@@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@CComPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN4@CComPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComPtr@UID3D11Device1@@@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComPtr@UID3D11Device1@@@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComPtr@UID3D11Device1@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<ID3D11Device1>::~CComPtr<ID3D11Device1>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UID3D11Device1@@@ATL@@QAE@PAUID3D11Device1@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtr@UID3D11Device1@@@ATL@@QAE@PAUID3D11Device1@@@Z PROC ; ATL::CComPtr<ID3D11Device1>::CComPtr<ID3D11Device1>, COMDAT
; _this$ = ecx

; 312  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi

; 312  :     {

	mov	esi, ecx

; 162  :         p = lp;

	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN6@CComPtr

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN6@CComPtr:

; 313  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtr@UID3D11Device1@@@ATL@@QAE@PAUID3D11Device1@@@Z ENDP ; ATL::CComPtr<ID3D11Device1>::CComPtr<ID3D11Device1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??C?$CComPtrBase@UID3D11Device1@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UID3D11Device1@@@1@XZ
_TEXT	SEGMENT
??C?$CComPtrBase@UID3D11Device1@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UID3D11Device1@@@1@XZ PROC ; ATL::CComPtrBase<ID3D11Device1>::operator->, COMDAT
; _this$ = ecx

; 197  :         ATLASSERT(p!=NULL);
; 198  :         return (_NoAddRefReleaseOnCComPtr<T>*)p;

	mov	eax, DWORD PTR [ecx]

; 199  :     }

	ret	0
??C?$CComPtrBase@UID3D11Device1@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UID3D11Device1@@@1@XZ ENDP ; ATL::CComPtrBase<ID3D11Device1>::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??I?$CComPtrBase@UID3D11Device1@@@ATL@@QAEPAPAUID3D11Device1@@XZ
_TEXT	SEGMENT
??I?$CComPtrBase@UID3D11Device1@@@ATL@@QAEPAPAUID3D11Device1@@XZ PROC ; ATL::CComPtrBase<ID3D11Device1>::operator&, COMDAT
; _this$ = ecx

; 192  :         ATLASSERT(p==NULL);
; 193  :         return &p;

	mov	eax, ecx

; 194  :     }

	ret	0
??I?$CComPtrBase@UID3D11Device1@@@ATL@@QAEPAPAUID3D11Device1@@XZ ENDP ; ATL::CComPtrBase<ID3D11Device1>::operator&
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UID3D11Device1@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UID3D11Device1@@@ATL@@QAE@XZ PROC	; ATL::CComPtrBase<ID3D11Device1>::~CComPtrBase<ID3D11Device1>, COMDAT
; _this$ = ecx

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN2@CComPtrBas

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@CComPtrBas:

; 178  :     }

	ret	0
??1?$CComPtrBase@UID3D11Device1@@@ATL@@QAE@XZ ENDP	; ATL::CComPtrBase<ID3D11Device1>::~CComPtrBase<ID3D11Device1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UID3D11Device1@@@ATL@@IAE@PAUID3D11Device1@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtrBase@UID3D11Device1@@@ATL@@IAE@PAUID3D11Device1@@@Z PROC ; ATL::CComPtrBase<ID3D11Device1>::CComPtrBase<ID3D11Device1>, COMDAT
; _this$ = ecx

; 160  :     CComPtrBase(_Inout_opt_ T* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp

; 161  :     {
; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN4@CComPtrBas

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN4@CComPtrBas:

; 165  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtrBase@UID3D11Device1@@@ATL@@IAE@PAUID3D11Device1@@@Z ENDP ; ATL::CComPtrBase<ID3D11Device1>::CComPtrBase<ID3D11Device1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtr@UID3D11BlendState@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComPtr@UID3D11BlendState@@@ATL@@QAE@XZ PROC	; ATL::CComPtr<ID3D11BlendState>::~CComPtr<ID3D11BlendState>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComPtr@UID3D11BlendState@@@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@CComPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN4@CComPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComPtr@UID3D11BlendState@@@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComPtr@UID3D11BlendState@@@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComPtr@UID3D11BlendState@@@ATL@@QAE@XZ ENDP	; ATL::CComPtr<ID3D11BlendState>::~CComPtr<ID3D11BlendState>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UID3D11BlendState@@@ATL@@QAE@PAUID3D11BlendState@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtr@UID3D11BlendState@@@ATL@@QAE@PAUID3D11BlendState@@@Z PROC ; ATL::CComPtr<ID3D11BlendState>::CComPtr<ID3D11BlendState>, COMDAT
; _this$ = ecx

; 312  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi

; 312  :     {

	mov	esi, ecx

; 162  :         p = lp;

	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN6@CComPtr

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN6@CComPtr:

; 313  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtr@UID3D11BlendState@@@ATL@@QAE@PAUID3D11BlendState@@@Z ENDP ; ATL::CComPtr<ID3D11BlendState>::CComPtr<ID3D11BlendState>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??I?$CComPtrBase@UID3D11BlendState@@@ATL@@QAEPAPAUID3D11BlendState@@XZ
_TEXT	SEGMENT
??I?$CComPtrBase@UID3D11BlendState@@@ATL@@QAEPAPAUID3D11BlendState@@XZ PROC ; ATL::CComPtrBase<ID3D11BlendState>::operator&, COMDAT
; _this$ = ecx

; 192  :         ATLASSERT(p==NULL);
; 193  :         return &p;

	mov	eax, ecx

; 194  :     }

	ret	0
??I?$CComPtrBase@UID3D11BlendState@@@ATL@@QAEPAPAUID3D11BlendState@@XZ ENDP ; ATL::CComPtrBase<ID3D11BlendState>::operator&
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??B?$CComPtrBase@UID3D11BlendState@@@ATL@@QBEPAUID3D11BlendState@@XZ
_TEXT	SEGMENT
??B?$CComPtrBase@UID3D11BlendState@@@ATL@@QBEPAUID3D11BlendState@@XZ PROC ; ATL::CComPtrBase<ID3D11BlendState>::operator ID3D11BlendState *, COMDAT
; _this$ = ecx

; 181  :         return p;

	mov	eax, DWORD PTR [ecx]

; 182  :     }

	ret	0
??B?$CComPtrBase@UID3D11BlendState@@@ATL@@QBEPAUID3D11BlendState@@XZ ENDP ; ATL::CComPtrBase<ID3D11BlendState>::operator ID3D11BlendState *
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UID3D11BlendState@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UID3D11BlendState@@@ATL@@QAE@XZ PROC	; ATL::CComPtrBase<ID3D11BlendState>::~CComPtrBase<ID3D11BlendState>, COMDAT
; _this$ = ecx

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN2@CComPtrBas

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@CComPtrBas:

; 178  :     }

	ret	0
??1?$CComPtrBase@UID3D11BlendState@@@ATL@@QAE@XZ ENDP	; ATL::CComPtrBase<ID3D11BlendState>::~CComPtrBase<ID3D11BlendState>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UID3D11BlendState@@@ATL@@IAE@PAUID3D11BlendState@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtrBase@UID3D11BlendState@@@ATL@@IAE@PAUID3D11BlendState@@@Z PROC ; ATL::CComPtrBase<ID3D11BlendState>::CComPtrBase<ID3D11BlendState>, COMDAT
; _this$ = ecx

; 160  :     CComPtrBase(_Inout_opt_ T* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp

; 161  :     {
; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN4@CComPtrBas

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN4@CComPtrBas:

; 165  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtrBase@UID3D11BlendState@@@ATL@@IAE@PAUID3D11BlendState@@@Z ENDP ; ATL::CComPtrBase<ID3D11BlendState>::CComPtrBase<ID3D11BlendState>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtr@UID3D11RenderTargetView@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComPtr@UID3D11RenderTargetView@@@ATL@@QAE@XZ PROC	; ATL::CComPtr<ID3D11RenderTargetView>::~CComPtr<ID3D11RenderTargetView>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComPtr@UID3D11RenderTargetView@@@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@CComPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN4@CComPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComPtr@UID3D11RenderTargetView@@@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComPtr@UID3D11RenderTargetView@@@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComPtr@UID3D11RenderTargetView@@@ATL@@QAE@XZ ENDP	; ATL::CComPtr<ID3D11RenderTargetView>::~CComPtr<ID3D11RenderTargetView>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UID3D11RenderTargetView@@@ATL@@QAE@PAUID3D11RenderTargetView@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtr@UID3D11RenderTargetView@@@ATL@@QAE@PAUID3D11RenderTargetView@@@Z PROC ; ATL::CComPtr<ID3D11RenderTargetView>::CComPtr<ID3D11RenderTargetView>, COMDAT
; _this$ = ecx

; 312  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi

; 312  :     {

	mov	esi, ecx

; 162  :         p = lp;

	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN6@CComPtr

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN6@CComPtr:

; 313  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtr@UID3D11RenderTargetView@@@ATL@@QAE@PAUID3D11RenderTargetView@@@Z ENDP ; ATL::CComPtr<ID3D11RenderTargetView>::CComPtr<ID3D11RenderTargetView>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??I?$CComPtrBase@UID3D11RenderTargetView@@@ATL@@QAEPAPAUID3D11RenderTargetView@@XZ
_TEXT	SEGMENT
??I?$CComPtrBase@UID3D11RenderTargetView@@@ATL@@QAEPAPAUID3D11RenderTargetView@@XZ PROC ; ATL::CComPtrBase<ID3D11RenderTargetView>::operator&, COMDAT
; _this$ = ecx

; 192  :         ATLASSERT(p==NULL);
; 193  :         return &p;

	mov	eax, ecx

; 194  :     }

	ret	0
??I?$CComPtrBase@UID3D11RenderTargetView@@@ATL@@QAEPAPAUID3D11RenderTargetView@@XZ ENDP ; ATL::CComPtrBase<ID3D11RenderTargetView>::operator&
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UID3D11RenderTargetView@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UID3D11RenderTargetView@@@ATL@@QAE@XZ PROC ; ATL::CComPtrBase<ID3D11RenderTargetView>::~CComPtrBase<ID3D11RenderTargetView>, COMDAT
; _this$ = ecx

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN2@CComPtrBas

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@CComPtrBas:

; 178  :     }

	ret	0
??1?$CComPtrBase@UID3D11RenderTargetView@@@ATL@@QAE@XZ ENDP ; ATL::CComPtrBase<ID3D11RenderTargetView>::~CComPtrBase<ID3D11RenderTargetView>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UID3D11RenderTargetView@@@ATL@@IAE@PAUID3D11RenderTargetView@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtrBase@UID3D11RenderTargetView@@@ATL@@IAE@PAUID3D11RenderTargetView@@@Z PROC ; ATL::CComPtrBase<ID3D11RenderTargetView>::CComPtrBase<ID3D11RenderTargetView>, COMDAT
; _this$ = ecx

; 160  :     CComPtrBase(_Inout_opt_ T* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp

; 161  :     {
; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN4@CComPtrBas

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN4@CComPtrBas:

; 165  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtrBase@UID3D11RenderTargetView@@@ATL@@IAE@PAUID3D11RenderTargetView@@@Z ENDP ; ATL::CComPtrBase<ID3D11RenderTargetView>::CComPtrBase<ID3D11RenderTargetView>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
;	COMDAT ??$QueryInterface@UID3D11Device@@@IUnknown@@QAGJPAPAUID3D11Device@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pp$ = 12						; size = 4
??$QueryInterface@UID3D11Device@@@IUnknown@@QAGJPAPAUID3D11Device@@@Z PROC ; IUnknown::QueryInterface<ID3D11Device>, COMDAT

; 130  :             {

	npad	2
	push	ebp
	mov	ebp, esp

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	mov	eax, DWORD PTR _this$[ebp]
	push	DWORD PTR _pp$[ebp]
	push	OFFSET __GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx]

; 132  :             }

	pop	ebp
	ret	8
??$QueryInterface@UID3D11Device@@@IUnknown@@QAGJPAPAUID3D11Device@@@Z ENDP ; IUnknown::QueryInterface<ID3D11Device>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_blend$2 = -544						; size = 264
_desc$3 = -280						; size = 60
_tex2d_desc$4 = -220					; size = 44
_backbuffer_desc$5 = -176				; size = 44
_dev_lvl$6 = -132					; size = 16
_rtdesc$7 = -116					; size = 20
_pCtxStateOrig$8 = -96					; size = 4
_vp$9 = -92						; size = 24
_auto_bool$10 = -68					; size = 8
_auto_bool$1$ = -60					; size = 4
_sb$11 = -56						; size = 4
_pCtxState$12 = -52					; size = 4
_pImmediateContext1$13 = -48				; size = 4
_pBackBufferSurf$14 = -44				; size = 4
$T15 = -40						; size = 4
_ft_lvl$16 = -40					; size = 4
_pBlendState$17 = -36					; size = 4
_pDevice1$18 = -32					; size = 4
_pRenderTargetView$19 = -28				; size = 4
_pBackBuffer$20 = -24					; size = 4
_pDev$ = -20						; size = 4
_pImmediateContext$21 = -16				; size = 4
__$EHRec$ = -12						; size = 12
_This$ = 8						; size = 4
?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z PROC	; SK_CEGUI_DrawD3D11

; 1957 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 532				; 00000214H

; 1958 :   if (! config.cegui.enable)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+160, 0
	je	$LN356@SK_CEGUI_D

; 1959 :     return;
; 1960 : 
; 1961 :   if (__SK_DLL_Ending)

	cmp	DWORD PTR ?__SK_DLL_Ending@@3JC, 0	; __SK_DLL_Ending
	jne	$LN356@SK_CEGUI_D

; 1962 :     return;
; 1963 : 
; 1964 :   SK_RenderBackend& rb =

	push	esi
	push	edi
	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend
	mov	edi, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pDev$[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1967 :   CComPtr <ID3D11Device> pDev = nullptr;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h

; 8837 :     return (unsigned long) _InterlockedIncrement((volatile long*) Addend);

	lock	 inc	 DWORD PTR ?__cegui_frames_drawn@@3KC

; 9003 :     return (unsigned long) _InterlockedCompareExchange((volatile long*) Destination, (long) Exchange, (long) Comperand);

	xor	ecx, ecx
	mov	edx, OFFSET ?__gui_reset@@3KC
	mov	eax, 1
	lock	 cmpxchg DWORD PTR [edx], ecx
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1971 :   if (InterlockedCompareExchange (&__gui_reset, FALSE, TRUE))

	test	eax, eax
	je	SHORT $LN6@SK_CEGUI_D

; 1972 :   {
; 1973 :     SK_TextOverlayManager::getInstance ()->destroyAllOverlays ();

	call	?getInstance@SK_TextOverlayManager@@SAPAV1@XZ ; SK_TextOverlayManager::getInstance
	mov	ecx, eax
	call	?destroyAllOverlays@SK_TextOverlayManager@@QAEXXZ ; SK_TextOverlayManager::destroyAllOverlays

; 1974 : 
; 1975 :     rb.releaseOwnedResources ();

	mov	ecx, edi
	call	?releaseOwnedResources@SK_RenderBackend_V2@@QAEXXZ ; SK_RenderBackend_V2::releaseOwnedResources

; 1976 : 
; 1977 :     if (cegD3D11 != nullptr)

	cmp	DWORD PTR ?cegD3D11@@3PAVDirect3D11Renderer@CEGUI@@A, 0 ; cegD3D11
	je	$LN350@SK_CEGUI_D

; 1978 :     {
; 1979 :       CEGUI::WindowManager::getDllSingleton ().cleanDeadPool ();

	call	DWORD PTR __imp_?getDllSingleton@?$Singleton@VWindowManager@CEGUI@@@CEGUI@@SAAAVWindowManager@2@XZ
	mov	ecx, eax
	call	DWORD PTR __imp_?cleanDeadPool@WindowManager@CEGUI@@QAEXXZ

; 1980 :       cegD3D11->destroySystem ();

	call	DWORD PTR __imp_?destroySystem@Direct3D11Renderer@CEGUI@@SAXXZ

; 1981 :       cegD3D11 = nullptr;

	mov	DWORD PTR ?cegD3D11@@3PAVDirect3D11Renderer@CEGUI@@A, 0 ; cegD3D11

; 1982 :     }
; 1983 :   }

	jmp	$LN350@SK_CEGUI_D
$LN6@SK_CEGUI_D:

; 1984 : 
; 1985 :   else if (cegD3D11 == nullptr)

	cmp	DWORD PTR ?cegD3D11@@3PAVDirect3D11Renderer@CEGUI@@A, 0 ; cegD3D11
	jne	SHORT $LN9@SK_CEGUI_D

; 1986 :   {
; 1987 :     DXGI_SWAP_CHAIN_DESC desc;
; 1988 :     This->GetDesc      (&desc);

	mov	esi, DWORD PTR _This$[ebp]
	lea	ecx, DWORD PTR _desc$3[ebp]
	push	ecx
	push	esi
	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+48]

; 1989 : 
; 1990 :     SK_InstallWindowHook (desc.OutputWindow);

	push	DWORD PTR _desc$3[ebp+44]
	call	?SK_InstallWindowHook@@YAXPAUHWND__@@@Z	; SK_InstallWindowHook

; 1991 : 
; 1992 :     ResetCEGUI_D3D11     (This);

	push	esi
	call	?ResetCEGUI_D3D11@@YAXPAUIDXGISwapChain@@@Z ; ResetCEGUI_D3D11
	add	esp, 8
	jmp	$LN350@SK_CEGUI_D
$LN9@SK_CEGUI_D:

; 1996 :   else if ( rb.device != nullptr && 

	mov	ecx, DWORD PTR [edi+36]
	test	ecx, ecx
	je	$LN350@SK_CEGUI_D
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR _pDev$[ebp]
	push	edx
	push	OFFSET __GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140
	push	ecx
	call	DWORD PTR [eax]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1996 :   else if ( rb.device != nullptr && 

	test	eax, eax
	js	$LN350@SK_CEGUI_D

; 1997 :  SUCCEEDED (rb.device->QueryInterface <ID3D11Device> (&pDev)) )
; 1998 :   {
; 1999 :     assert (rb.device == pDev);
; 2000 : 
; 2001 :     // If the swapchain or device changed, bail-out and wait until the next frame for
; 2002 :     //   things to normalize.
; 2003 :     if (rb.device != pDev || rb.swapchain == nullptr)

	mov	eax, DWORD PTR [edi+36]
	cmp	eax, DWORD PTR _pDev$[ebp]
	jne	SHORT $LN13@SK_CEGUI_D
	cmp	DWORD PTR [edi+40], 0
	jne	SHORT $LN358@SK_CEGUI_D
$LN13@SK_CEGUI_D:

; 2004 :     {
; 2005 :       ResetCEGUI_D3D11        (This);

	mov	esi, DWORD PTR _This$[ebp]
	push	esi
	call	?ResetCEGUI_D3D11@@YAXPAUIDXGISwapChain@@@Z ; ResetCEGUI_D3D11

; 2006 :       SK_DXGI_UpdateSwapChain (This);

	push	esi
	call	?SK_DXGI_UpdateSwapChain@@YAXPAUIDXGISwapChain@@@Z ; SK_DXGI_UpdateSwapChain
	add	esp, 8
	jmp	SHORT $LN12@SK_CEGUI_D
$LN358@SK_CEGUI_D:
	mov	esi, DWORD PTR _This$[ebp]
$LN12@SK_CEGUI_D:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pBackBuffer$20[ebp], 0
	mov	DWORD PTR _pRenderTargetView$19[ebp], 0
	mov	DWORD PTR _pBlendState$17[ebp], 0
	mov	DWORD PTR _pDevice1$18[ebp], 0
	mov	DWORD PTR _pCtxState$12[ebp], 0
	mov	DWORD PTR _pCtxStateOrig$8[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2021 :     hr = This->GetBuffer (0, IID_PPV_ARGS (&pBackBuffer));

	mov	esi, DWORD PTR [esi]
	lea	eax, DWORD PTR _pBackBuffer$20[ebp]
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	call	??$IID_PPV_ARGS_Helper@UID3D11Texture2D@@@@YAPAPAXPAPAUID3D11Texture2D@@@Z ; IID_PPV_ARGS_Helper<ID3D11Texture2D>
	add	esp, 4
	push	eax
	push	OFFSET __GUID_6f15aaf2_d208_4e89_9ab4_489535d34f9c
	push	0
	push	DWORD PTR _This$[ebp]
	call	DWORD PTR [esi+36]

; 2022 : 
; 2023 :     if (FAILED (hr))

	test	eax, eax
	jns	SHORT $LN14@SK_CEGUI_D

; 2024 :     {
; 2025 :       SK_LOG_ONCE (L"[   DXGI   ]  *** Back buffer unavailable! ***");

	cmp	BYTE PTR ?logged@?BL@??SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z@4_NA, 0
	jne	$LN170@SK_CEGUI_D
	push	OFFSET $SG354359
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8
	mov	BYTE PTR ?logged@?BL@??SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z@4_NA, 1
	jmp	$LN170@SK_CEGUI_D
$LN14@SK_CEGUI_D:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pImmediateContext$21[ebp], 0
	mov	DWORD PTR _pImmediateContext1$13[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2032 :     rb.d3d11.immediate_ctx->QueryInterface <ID3D11DeviceContext> (&pImmediateContext);

	mov	eax, DWORD PTR [edi+68]
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	lea	edx, DWORD PTR _pImmediateContext$21[ebp]
	push	edx
	push	OFFSET __GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da
	push	eax
	mov	ecx, DWORD PTR [eax]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2030 :     CComPtr <ID3D11DeviceContext1> pImmediateContext1 = nullptr;

	mov	BYTE PTR __$EHRec$[ebp+8], 8
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	call	DWORD PTR [ecx]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2034 :     if (config.render.dxgi.full_state_cache)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+485, 0
	je	$LN19@SK_CEGUI_D
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	mov	eax, DWORD PTR _pImmediateContext$21[ebp]
	lea	edx, DWORD PTR _pImmediateContext1$13[ebp]
	push	edx
	push	OFFSET __GUID_bb2c6faa_b5fb_4082_8e6b_388b8cfa90e1
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pDev$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2036 :         hr =

	mov	esi, eax
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	lea	eax, DWORD PTR _pDevice1$18[ebp]
	push	eax
	push	OFFSET __GUID_a04bfb29_08ef_43d6_a49c_a9bdbdcbe686
	mov	edx, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [edx]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2040 :         if (FAILED (hr))

	test	esi, esi
	jns	$LN17@SK_CEGUI_D

; 2041 :         {
; 2042 :           SK_LOG_ONCE (L"[   DXGI   ]  *** Could not query ID3D11Device1 interface! ***");

	cmp	BYTE PTR ?logged@?CF@??SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z@4_NA, 0
	jne	SHORT $LN18@SK_CEGUI_D
	push	OFFSET $SG354363
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8
	mov	BYTE PTR ?logged@?CF@??SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z@4_NA, 1
$LN18@SK_CEGUI_D:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	mov	eax, DWORD PTR _pImmediateContext1$13[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2043 :           return;

	mov	BYTE PTR __$EHRec$[ebp+8], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN164@SK_CEGUI_D

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN164@SK_CEGUI_D:

; 176  :         if (p)

	mov	eax, DWORD PTR _pImmediateContext$21[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2043 :           return;

	mov	BYTE PTR __$EHRec$[ebp+8], 6
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN170@SK_CEGUI_D

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN170@SK_CEGUI_D:

; 176  :         if (p)

	mov	eax, DWORD PTR _pCtxState$12[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2043 :           return;

	mov	BYTE PTR __$EHRec$[ebp+8], 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN182@SK_CEGUI_D

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN182@SK_CEGUI_D:

; 176  :         if (p)

	mov	eax, DWORD PTR _pDevice1$18[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2043 :           return;

	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN188@SK_CEGUI_D

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN188@SK_CEGUI_D:

; 176  :         if (p)

	mov	eax, DWORD PTR _pBlendState$17[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2043 :           return;

	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN194@SK_CEGUI_D

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN194@SK_CEGUI_D:

; 176  :         if (p)

	mov	eax, DWORD PTR _pRenderTargetView$19[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2043 :           return;

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN200@SK_CEGUI_D

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN200@SK_CEGUI_D:

; 176  :         if (p)

	mov	eax, DWORD PTR _pBackBuffer$20[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2043 :           return;

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	$LN44@SK_CEGUI_D

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
	jmp	$LN44@SK_CEGUI_D
$LN17@SK_CEGUI_D:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2047 :         pDev->GetFeatureLevel ();

	mov	eax, DWORD PTR _pDev$[ebp]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+148]

; 2048 : 
; 2049 :       GUID              dev_lvl = (ft_lvl == D3D_FEATURE_LEVEL_11_1) ?

	cmp	eax, 45312				; 0000b100H
	mov	DWORD PTR _ft_lvl$16[ebp], eax

; 2050 :                                      __uuidof (ID3D11Device1) :
; 2051 :                                      __uuidof (ID3D11Device);
; 2052 : 
; 2053 :       //
; 2054 :       // DXGI state blocks the (fun?) way :)  -- Performance implications are unknown, as
; 2055 :       //                                           is compatibility with other injectors that
; 2056 :       //                                             may try to cache state.
; 2057 :       //
; 2058 :       if (FAILED (pDevice1->CreateDeviceContextState ( 0x00,

	mov	eax, DWORD PTR _pDevice1$18[ebp]
	mov	edx, OFFSET __GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140
	mov	ecx, OFFSET __GUID_a04bfb29_08ef_43d6_a49c_a9bdbdcbe686
	cmovne	ecx, edx
	lea	edx, DWORD PTR _pCtxState$12[ebp]
	push	edx
	push	0
	lea	edx, DWORD PTR _dev_lvl$6[ebp]
	movups	xmm0, XMMWORD PTR [ecx]
	push	edx
	push	7
	push	1
	lea	edx, DWORD PTR _ft_lvl$16[ebp]
	push	edx
	movups	XMMWORD PTR _dev_lvl$6[ebp], xmm0
	mov	ecx, DWORD PTR [eax]
	push	0
	push	eax
	call	DWORD PTR [ecx+188]
	test	eax, eax
	jns	SHORT $LN19@SK_CEGUI_D

; 2059 :                                                          &ft_lvl,
; 2060 :                                                            1,
; 2061 :                                                              D3D11_SDK_VERSION,
; 2062 :                                                                dev_lvl,
; 2063 :                                                                  nullptr,
; 2064 :                                                                    &pCtxState )))
; 2065 :       {
; 2066 :         SK_LOG_ONCE (L"[   DXGI   ]  *** CreateDeviceContextState (...) failed! ***");

	cmp	BYTE PTR ?logged@?CM@??SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z@4_NA, 0
	jne	SHORT $LN20@SK_CEGUI_D
	push	OFFSET $SG354366
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8
	mov	BYTE PTR ?logged@?CM@??SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z@4_NA, 1
$LN20@SK_CEGUI_D:

; 2067 :         config.render.dxgi.full_state_cache = false;

	mov	BYTE PTR ?config@@3Usk_config_t@@A+485, 0
$LN19@SK_CEGUI_D:

; 2068 :       }
; 2069 :     }
; 2070 : 
; 2071 :     D3D11_TEXTURE2D_DESC          tex2d_desc = { };

	push	44					; 0000002cH
	lea	eax, DWORD PTR _tex2d_desc$4[ebp]
	push	0
	push	eax
	call	_memset

; 2072 :     D3D11_RENDER_TARGET_VIEW_DESC rtdesc     = { };
; 2073 : 
; 2074 :     pBackBuffer->GetDesc (&tex2d_desc);

	mov	eax, DWORD PTR _pBackBuffer$20[ebp]
	lea	edx, DWORD PTR _tex2d_desc$4[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _rtdesc$7[ebp+16], 0
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _rtdesc$7[ebp], xmm0
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+40]

; 2075 : 
; 2076 :     // sRGB Correction for UIs
; 2077 :     switch (tex2d_desc.Format)

	mov	eax, DWORD PTR _tex2d_desc$4[ebp+16]
	cmp	eax, 29					; 0000001dH
	je	SHORT $LN21@SK_CEGUI_D
	cmp	eax, 91					; 0000005bH
	je	SHORT $LN21@SK_CEGUI_D

; 2088 :       } break;
; 2089 : 
; 2090 :       default:
; 2091 :       {
; 2092 :         hr = pDev->CreateRenderTargetView (pBackBuffer, nullptr, &pRenderTargetView);

	mov	eax, DWORD PTR _pDev$[ebp]
	lea	edx, DWORD PTR _pRenderTargetView$19[ebp]
	push	edx
	push	0
	push	DWORD PTR _pBackBuffer$20[ebp]
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+36]

; 2093 : 
; 2094 :         rb.framebuffer_flags &= (~SK_FRAMEBUFFER_FLAG_SRGB);

	mov	ecx, DWORD PTR [edi+60]
	mov	edx, eax
	and	DWORD PTR [edi+56], -2			; fffffffeH
	mov	DWORD PTR [edi+60], ecx
	jmp	SHORT $LN2@SK_CEGUI_D
$LN21@SK_CEGUI_D:

; 2078 :     {
; 2079 :       case DXGI_FORMAT_R8G8B8A8_UNORM_SRGB:
; 2080 :       case DXGI_FORMAT_B8G8R8A8_UNORM_SRGB:
; 2081 :       {
; 2082 :         rtdesc.Format        = DXGI_FORMAT_R8G8B8A8_UNORM;
; 2083 :         rtdesc.ViewDimension = D3D11_RTV_DIMENSION_TEXTURE2D;
; 2084 : 
; 2085 :         hr = pDev->CreateRenderTargetView (pBackBuffer, &rtdesc, &pRenderTargetView);

	mov	eax, DWORD PTR _pDev$[ebp]
	lea	edx, DWORD PTR _pRenderTargetView$19[ebp]
	push	edx
	lea	edx, DWORD PTR _rtdesc$7[ebp]
	mov	DWORD PTR _rtdesc$7[ebp], 28		; 0000001cH
	push	edx
	push	DWORD PTR _pBackBuffer$20[ebp]
	mov	DWORD PTR _rtdesc$7[ebp+4], 4
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+36]

; 2086 : 
; 2087 :         rb.framebuffer_flags |= SK_FRAMEBUFFER_FLAG_SRGB;

	or	DWORD PTR [edi+56], 1
	mov	edx, eax
	mov	eax, DWORD PTR [edi+60]
	mov	DWORD PTR [edi+60], eax
$LN2@SK_CEGUI_D:

; 2095 :       } break;
; 2096 :     }
; 2097 : 
; 2098 :     if (SUCCEEDED (hr))

	test	edx, edx
	js	$LN302@SK_CEGUI_D

; 2100 :       SK_ScopedBool auto_bool (&SK_TLS_Bottom ()->imgui.drawing);

	call	?SK_TLS_Bottom@@YGPAUSK_TLS@@XZ		; SK_TLS_Bottom
	add	eax, 48					; 00000030H
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h

; 137  :     pBool_ =  pBool;

	mov	DWORD PTR _auto_bool$10[ebp], eax

; 138  :     bOrig_ = *pBool;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _auto_bool$1$[ebp], eax
	mov	DWORD PTR _auto_bool$10[ebp+4], eax
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2100 :       SK_ScopedBool auto_bool (&SK_TLS_Bottom ()->imgui.drawing);

	mov	BYTE PTR __$EHRec$[ebp+8], 9

; 2101 :       SK_TLS_Bottom ()->imgui.drawing = true;

	call	?SK_TLS_Bottom@@YGPAUSK_TLS@@XZ		; SK_TLS_Bottom

; 2102 : 
; 2103 :       std::unique_ptr <SK_D3D11_Stateblock_Lite> sb (

	push	2776					; 00000ad8H
	mov	DWORD PTR [eax+48], 1
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	mov	DWORD PTR $T15[ebp], eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN29@SK_CEGUI_D
	push	2776					; 00000ad8H
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN30@SK_CEGUI_D
$LN29@SK_CEGUI_D:
	xor	esi, esi
	mov	DWORD PTR $T15[ebp], esi
$LN30@SK_CEGUI_D:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 302  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	mov	DWORD PTR _sb$11[ebp], esi
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2107 :       sb->capture (pImmediateContext);

	push	DWORD PTR _pImmediateContext$21[ebp]
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	call	?capture@SK_D3D11_Stateblock_Lite@@QAEXPAUID3D11DeviceContext@@@Z ; SK_D3D11_Stateblock_Lite::capture

; 2108 :       //D3DX11_STATE_BLOCK sb = { };
; 2109 :       //CreateStateblock (pImmediateContext, &sb);
; 2110 : 
; 2111 :       pImmediateContext->OMSetRenderTargets (1, &pRenderTargetView, nullptr);

	mov	eax, DWORD PTR _pImmediateContext$21[ebp]
	lea	edx, DWORD PTR _pRenderTargetView$19[ebp]
	push	0
	push	edx
	push	1
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+132]

; 2112 : 
; 2113 :       D3D11_VIEWPORT         vp              = { };
; 2114 :       D3D11_BLEND_DESC       blend           = { };

	push	264					; 00000108H
	xorps	xmm0, xmm0
	lea	eax, DWORD PTR _blend$2[ebp]
	push	0
	push	eax
	movups	XMMWORD PTR _vp$9[ebp], xmm0
	movq	QWORD PTR _vp$9[ebp+16], xmm0
	call	_memset

; 2115 :       D3D11_TEXTURE2D_DESC   backbuffer_desc = { };

	push	44					; 0000002cH
	lea	eax, DWORD PTR _backbuffer_desc$5[ebp]
	push	0
	push	eax
	call	_memset

; 2116 : 
; 2117 :       pBackBuffer->GetDesc (&backbuffer_desc);

	mov	eax, DWORD PTR _pBackBuffer$20[ebp]
	lea	edx, DWORD PTR _backbuffer_desc$5[ebp]
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+40]

; 2118 : 
; 2119 :       blend.RenderTarget [0].BlendEnable           = TRUE;
; 2120 :       blend.RenderTarget [0].SrcBlend              = D3D11_BLEND_ONE;
; 2121 :       blend.RenderTarget [0].DestBlend             = D3D11_BLEND_INV_SRC_ALPHA;
; 2122 :       blend.RenderTarget [0].BlendOp               = D3D11_BLEND_OP_ADD;
; 2123 :       blend.RenderTarget [0].SrcBlendAlpha         = D3D11_BLEND_ONE;
; 2124 :       blend.RenderTarget [0].DestBlendAlpha        = D3D11_BLEND_INV_SRC_ALPHA;
; 2125 :       blend.RenderTarget [0].BlendOpAlpha          = D3D11_BLEND_OP_ADD;
; 2126 :       blend.RenderTarget [0].RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL;
; 2127 : 
; 2128 :       //pImmediateContext->SOSetTargets (0, nullptr, nullptr);
; 2129 : 
; 2130 :       if (SUCCEEDED (pDev->CreateBlendState (&blend, &pBlendState)))

	mov	eax, DWORD PTR _pDev$[ebp]
	lea	edx, DWORD PTR _pBlendState$17[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@00000001000000060000000200000001
	push	edx
	movups	XMMWORD PTR _blend$2[ebp+8], xmm0
	mov	DWORD PTR _blend$2[ebp+24], 2
	lea	edx, DWORD PTR _blend$2[ebp]
	mov	DWORD PTR _blend$2[ebp+28], 6
	mov	DWORD PTR _blend$2[ebp+32], 1
	mov	BYTE PTR _blend$2[ebp+36], 15		; 0000000fH
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+80]
	test	eax, eax
	js	SHORT $LN24@SK_CEGUI_D

; 2131 :         pImmediateContext->OMSetBlendState (pBlendState, nullptr, 0xffffffff);

	mov	eax, DWORD PTR _pImmediateContext$21[ebp]
	push	-1
	push	0
	push	DWORD PTR _pBlendState$17[ebp]
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+140]
$LN24@SK_CEGUI_D:

; 2132 : 
; 2133 :       vp.Width    = static_cast <float> (backbuffer_desc.Width);

	mov	eax, DWORD PTR _backbuffer_desc$5[ebp]

; 2134 :       vp.Height   = static_cast <float> (backbuffer_desc.Height);
; 2135 :       vp.MinDepth = 0;
; 2136 :       vp.MaxDepth = 1;
; 2137 :       vp.TopLeftX = 0;
; 2138 :       vp.TopLeftY = 0;
; 2139 : 
; 2140 :       pImmediateContext->RSSetViewports (1, &vp);

	lea	edx, DWORD PTR _vp$9[ebp]
	push	edx
	mov	DWORD PTR _vp$9[ebp+16], 0
	mov	DWORD PTR _vp$9[ebp+20], 1065353216	; 3f800000H
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	mov	DWORD PTR _vp$9[ebp], 0
	mov	DWORD PTR _vp$9[ebp+4], 0
	push	1
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	eax, DWORD PTR _backbuffer_desc$5[ebp+4]
	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR _vp$9[ebp+8], xmm0
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	eax, DWORD PTR _pImmediateContext$21[ebp]
	push	eax
	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR _vp$9[ebp+12], xmm0
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+176]

; 2141 :       {
; 2142 :         cegD3D11->beginRendering ();

	mov	ecx, DWORD PTR ?cegD3D11@@3PAVDirect3D11Renderer@CEGUI@@A ; cegD3D11
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+60]

; 2143 :         {
; 2144 :           SK_TextOverlayManager::getInstance ()->drawAllOverlays (0.0f, 0.0f);

	push	0
	sub	esp, 8
	mov	DWORD PTR [esp+4], 0
	mov	DWORD PTR [esp], 0
	call	?getInstance@SK_TextOverlayManager@@SAPAV1@XZ ; SK_TextOverlayManager::getInstance
	mov	ecx, eax
	call	?drawAllOverlays@SK_TextOverlayManager@@QAEMMM_N@Z ; SK_TextOverlayManager::drawAllOverlays
	fstp	ST(0)

; 2145 : 
; 2146 :           SK_Steam_DrawOSD ();

	call	?SK_Steam_DrawOSD@@YAXXZ		; SK_Steam_DrawOSD

; 2147 : 
; 2148 :           CEGUI::System::getDllSingleton ().renderAllGUIContexts ();

	call	DWORD PTR __imp_?getDllSingleton@?$Singleton@VSystem@CEGUI@@@CEGUI@@SAAAVSystem@2@XZ
	mov	ecx, eax
	call	DWORD PTR __imp_?renderAllGUIContexts@System@CEGUI@@QAEXXZ

; 2149 : 
; 2150 :           // XXX: TODO (Full startup isn't necessary, just update framebuffer dimensions).
; 2151 :           if (ImGui_DX11Startup             ( This                         ))

	mov	esi, DWORD PTR _This$[ebp]
	push	esi
	call	?ImGui_DX11Startup@@YA_NPAUIDXGISwapChain@@@Z ; ImGui_DX11Startup
	add	esp, 4
	test	al, al
	je	SHORT $LN25@SK_CEGUI_D

; 2152 :           {
; 2153 :             extern DWORD SK_ImGui_DrawFrame ( DWORD dwFlags, void* user    );
; 2154 :                          SK_ImGui_DrawFrame (       0x00,          nullptr );

	push	0
	push	0
	call	?SK_ImGui_DrawFrame@@YAKKPAX@Z		; SK_ImGui_DrawFrame
	add	esp, 8
$LN25@SK_CEGUI_D:

; 2155 :           }
; 2156 :         }
; 2157 :         cegD3D11->endRendering ();

	mov	ecx, DWORD PTR ?cegD3D11@@3PAVDirect3D11Renderer@CEGUI@@A ; cegD3D11
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+64]

; 2158 :       }
; 2159 : 
; 2160 :       //ApplyStateblock (pImmediateContext, &sb);
; 2161 :       sb->apply (pImmediateContext);

	push	DWORD PTR _pImmediateContext$21[ebp]
	mov	ecx, DWORD PTR $T15[ebp]
	call	?apply@SK_D3D11_Stateblock_Lite@@QAEXPAUID3D11DeviceContext@@@Z ; SK_D3D11_Stateblock_Lite::apply

; 2162 : 
; 2163 :       //
; 2164 :       // Update G-Sync; doing this here prevents trying to do this on frames where
; 2165 :       //   the swapchain was resized, which would deadlock the software.
; 2166 :       //
; 2167 :       if (sk::NVAPI::nv_hardware && config.apis.NvAPI.gsync_status)

	cmp	BYTE PTR ?nv_hardware@NVAPI@sk@@3_NA, 0	; sk::NVAPI::nv_hardware
	je	SHORT $LN299@SK_CEGUI_D
	cmp	BYTE PTR ?config@@3Usk_config_t@@A+792, 0
	je	SHORT $LN299@SK_CEGUI_D
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pBackBufferSurf$14[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2171 :         if (SUCCEEDED (This->GetBuffer (0, IID_PPV_ARGS (&pBackBufferSurf))))

	mov	esi, DWORD PTR [esi]
	lea	eax, DWORD PTR _pBackBufferSurf$14[ebp]
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	call	??$IID_PPV_ARGS_Helper@UIDXGISurface@@@@YAPAPAXPAPAUIDXGISurface@@@Z ; IID_PPV_ARGS_Helper<IDXGISurface>
	add	esp, 4
	push	eax
	push	OFFSET __GUID_cafcb56c_6ac3_4889_bf47_9e23bbd260ec
	push	0
	push	DWORD PTR _This$[ebp]
	call	DWORD PTR [esi+36]
	test	eax, eax
	js	SHORT $LN27@SK_CEGUI_D

; 2172 :           NvAPI_D3D_GetObjectHandleForResource (pDev, pBackBufferSurf, &rb.surface);

	lea	eax, DWORD PTR [edi+44]
	push	eax
	push	DWORD PTR _pBackBufferSurf$14[ebp]
	push	DWORD PTR _pDev$[ebp]
	call	_NvAPI_D3D_GetObjectHandleForResource
	add	esp, 12					; 0000000cH
$LN27@SK_CEGUI_D:

; 2173 : 
; 2174 :         rb.gsync_state.update ();

	lea	ecx, DWORD PTR [edi+72]
	call	?update@gsync_s@SK_RenderBackend_V2@@QAEXXZ ; SK_RenderBackend_V2::gsync_s::update
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	mov	eax, DWORD PTR _pBackBufferSurf$14[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2175 :       }

	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN299@SK_CEGUI_D

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN299@SK_CEGUI_D:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2176 :     }

	lea	ecx, DWORD PTR _sb$11[ebp]
	call	??1?$unique_ptr@USK_D3D11_Stateblock_Lite@@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@@std@@QAE@XZ ; std::unique_ptr<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> >::~unique_ptr<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> >
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h

; 143  :     *pBool_ = bOrig_;

	mov	eax, DWORD PTR _auto_bool$10[ebp]
	mov	ecx, DWORD PTR _auto_bool$1$[ebp]
	mov	DWORD PTR [eax], ecx
$LN302@SK_CEGUI_D:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	mov	eax, DWORD PTR _pImmediateContext1$13[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2177 :   }

	mov	BYTE PTR __$EHRec$[ebp+8], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN308@SK_CEGUI_D

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN308@SK_CEGUI_D:

; 176  :         if (p)

	mov	eax, DWORD PTR _pImmediateContext$21[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2177 :   }

	mov	BYTE PTR __$EHRec$[ebp+8], 6
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN314@SK_CEGUI_D

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN314@SK_CEGUI_D:

; 176  :         if (p)

	mov	eax, DWORD PTR _pCtxState$12[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2177 :   }

	mov	BYTE PTR __$EHRec$[ebp+8], 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN326@SK_CEGUI_D

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN326@SK_CEGUI_D:

; 176  :         if (p)

	mov	eax, DWORD PTR _pDevice1$18[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2177 :   }

	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN332@SK_CEGUI_D

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN332@SK_CEGUI_D:

; 176  :         if (p)

	mov	eax, DWORD PTR _pBlendState$17[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2177 :   }

	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN338@SK_CEGUI_D

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN338@SK_CEGUI_D:

; 176  :         if (p)

	mov	eax, DWORD PTR _pRenderTargetView$19[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2177 :   }

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN344@SK_CEGUI_D

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN344@SK_CEGUI_D:

; 176  :         if (p)

	mov	eax, DWORD PTR _pBackBuffer$20[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2177 :   }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN350@SK_CEGUI_D

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN350@SK_CEGUI_D:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2181 :   config.render.dxgi.full_state_cache = SK_DXGI_FullStateCache;

	mov	al, BYTE PTR ?SK_DXGI_FullStateCache@@3_NA ; SK_DXGI_FullStateCache
	mov	BYTE PTR ?config@@3Usk_config_t@@A+485, al
$LN44@SK_CEGUI_D:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	mov	eax, DWORD PTR _pDev$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2182 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN356@SK_CEGUI_D

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN356@SK_CEGUI_D:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 2182 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z$0:
	lea	ecx, DWORD PTR _pDev$[ebp]
	jmp	??1?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ
__unwindfunclet$?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z$1:
	lea	ecx, DWORD PTR _pBackBuffer$20[ebp]
	jmp	??1?$CComPtr@UID3D11Texture2D@@@ATL@@QAE@XZ
__unwindfunclet$?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z$2:
	lea	ecx, DWORD PTR _pRenderTargetView$19[ebp]
	jmp	??1?$CComPtr@UID3D11RenderTargetView@@@ATL@@QAE@XZ
__unwindfunclet$?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z$3:
	lea	ecx, DWORD PTR _pBlendState$17[ebp]
	jmp	??1?$CComPtr@UID3D11BlendState@@@ATL@@QAE@XZ
__unwindfunclet$?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z$4:
	lea	ecx, DWORD PTR _pDevice1$18[ebp]
	jmp	??1?$CComPtr@UID3D11Device1@@@ATL@@QAE@XZ
__unwindfunclet$?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z$5:
	lea	ecx, DWORD PTR _pCtxState$12[ebp]
	jmp	??1?$CComPtr@UID3DDeviceContextState@@@ATL@@QAE@XZ
__unwindfunclet$?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z$6:
	lea	ecx, DWORD PTR _pCtxStateOrig$8[ebp]
	jmp	??1?$CComPtr@UID3DDeviceContextState@@@ATL@@QAE@XZ
__unwindfunclet$?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z$7:
	lea	ecx, DWORD PTR _pImmediateContext$21[ebp]
	jmp	??1?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@XZ
__unwindfunclet$?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z$8:
	lea	ecx, DWORD PTR _pImmediateContext1$13[ebp]
	jmp	??1?$CComPtr@UID3D11DeviceContext1@@@ATL@@QAE@XZ
__unwindfunclet$?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z$9:
	lea	ecx, DWORD PTR _auto_bool$10[ebp]
	jmp	??1SK_ScopedBool@@QAE@XZ		; SK_ScopedBool::~SK_ScopedBool
__unwindfunclet$?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z$10:
	lea	ecx, DWORD PTR _sb$11[ebp]
	jmp	??1?$unique_ptr@USK_D3D11_Stateblock_Lite@@U?$default_delete@USK_D3D11_Stateblock_Lite@@@std@@@std@@QAE@XZ ; std::unique_ptr<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> >::~unique_ptr<SK_D3D11_Stateblock_Lite,std::default_delete<SK_D3D11_Stateblock_Lite> >
__unwindfunclet$?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z$11:
	lea	ecx, DWORD PTR _pBackBufferSurf$14[ebp]
	jmp	??1?$CComPtr@UIDXGISurface@@@ATL@@QAE@XZ
__ehhandler$?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_CEGUI_DrawD3D11@@YAXPAUIDXGISwapChain@@@Z ENDP	; SK_CEGUI_DrawD3D11
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_arr$ = 8						; size = 4
_max_count$ = 12					; size = 4
??$calc_count@UID3D11RenderTargetView@@@@YAIPAPAUID3D11RenderTargetView@@I@Z PROC ; calc_count<ID3D11RenderTargetView>

; 1238 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1239 :   for ( int i = static_cast <int> (max_count) - 1 ;

	mov	edx, DWORD PTR _max_count$[ebp]
	lea	eax, DWORD PTR [edx-1]

; 1240 :             i >= 0 ;

	test	eax, eax
	js	SHORT $LN3@calc_count
	mov	ecx, DWORD PTR _arr$[ebp]
$LL4@calc_count:

; 1242 :   {
; 1243 :     if (arr [i] != 0)

	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $LN1@calc_count

; 1241 :           --i )

	sub	eax, 1

; 1240 :             i >= 0 ;

	jns	SHORT $LL4@calc_count
$LN3@calc_count:

; 1244 :       return i;
; 1245 :   }
; 1246 : 
; 1247 :   return max_count;

	mov	eax, edx
$LN1@calc_count:

; 1248 : }

	pop	ebp
	ret	0
??$calc_count@UID3D11RenderTargetView@@@@YAIPAPAUID3D11RenderTargetView@@I@Z ENDP ; calc_count<ID3D11RenderTargetView>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_arr$ = 8						; size = 4
_max_count$ = 12					; size = 4
??$calc_count@UID3D11Buffer@@@@YAIPAPAUID3D11Buffer@@I@Z PROC ; calc_count<ID3D11Buffer>

; 1238 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1239 :   for ( int i = static_cast <int> (max_count) - 1 ;

	mov	edx, DWORD PTR _max_count$[ebp]
	lea	eax, DWORD PTR [edx-1]

; 1240 :             i >= 0 ;

	test	eax, eax
	js	SHORT $LN3@calc_count
	mov	ecx, DWORD PTR _arr$[ebp]
$LL4@calc_count:

; 1242 :   {
; 1243 :     if (arr [i] != 0)

	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $LN1@calc_count

; 1241 :           --i )

	sub	eax, 1

; 1240 :             i >= 0 ;

	jns	SHORT $LL4@calc_count
$LN3@calc_count:

; 1244 :       return i;
; 1245 :   }
; 1246 : 
; 1247 :   return max_count;

	mov	eax, edx
$LN1@calc_count:

; 1248 : }

	pop	ebp
	ret	0
??$calc_count@UID3D11Buffer@@@@YAIPAPAUID3D11Buffer@@I@Z ENDP ; calc_count<ID3D11Buffer>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_arr$ = 8						; size = 4
_max_count$ = 12					; size = 4
??$calc_count@UID3D11ShaderResourceView@@@@YAIPAPAUID3D11ShaderResourceView@@I@Z PROC ; calc_count<ID3D11ShaderResourceView>

; 1238 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1239 :   for ( int i = static_cast <int> (max_count) - 1 ;

	mov	edx, DWORD PTR _max_count$[ebp]
	lea	eax, DWORD PTR [edx-1]

; 1240 :             i >= 0 ;

	test	eax, eax
	js	SHORT $LN3@calc_count
	mov	ecx, DWORD PTR _arr$[ebp]
$LL4@calc_count:

; 1242 :   {
; 1243 :     if (arr [i] != 0)

	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $LN1@calc_count

; 1241 :           --i )

	sub	eax, 1

; 1240 :             i >= 0 ;

	jns	SHORT $LL4@calc_count
$LN3@calc_count:

; 1244 :       return i;
; 1245 :   }
; 1246 : 
; 1247 :   return max_count;

	mov	eax, edx
$LN1@calc_count:

; 1248 : }

	pop	ebp
	ret	0
??$calc_count@UID3D11ShaderResourceView@@@@YAIPAPAUID3D11ShaderResourceView@@I@Z ENDP ; calc_count<ID3D11ShaderResourceView>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_arr$ = 8						; size = 4
_max_count$ = 12					; size = 4
??$calc_count@UID3D11SamplerState@@@@YAIPAPAUID3D11SamplerState@@I@Z PROC ; calc_count<ID3D11SamplerState>

; 1238 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1239 :   for ( int i = static_cast <int> (max_count) - 1 ;

	mov	edx, DWORD PTR _max_count$[ebp]
	lea	eax, DWORD PTR [edx-1]

; 1240 :             i >= 0 ;

	test	eax, eax
	js	SHORT $LN3@calc_count
	mov	ecx, DWORD PTR _arr$[ebp]
$LL4@calc_count:

; 1242 :   {
; 1243 :     if (arr [i] != 0)

	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $LN1@calc_count

; 1241 :           --i )

	sub	eax, 1

; 1240 :             i >= 0 ;

	jns	SHORT $LL4@calc_count
$LN3@calc_count:

; 1244 :       return i;
; 1245 :   }
; 1246 : 
; 1247 :   return max_count;

	mov	eax, edx
$LN1@calc_count:

; 1248 : }

	pop	ebp
	ret	0
??$calc_count@UID3D11SamplerState@@@@YAIPAPAUID3D11SamplerState@@I@Z ENDP ; calc_count<ID3D11SamplerState>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_minus_one$ = -72					; size = 32
_SOBuffersOffsets$2 = -40				; size = 16
_<end>$L0$1$ = -24					; size = 4
tv6054 = -24						; size = 4
tv6051 = -24						; size = 4
tv6048 = -24						; size = 4
tv6044 = -24						; size = 4
tv6039 = -24						; size = 4
tv6036 = -24						; size = 4
tv6033 = -24						; size = 4
tv6028 = -24						; size = 4
tv6025 = -24						; size = 4
tv6022 = -24						; size = 4
tv6017 = -24						; size = 4
tv6014 = -24						; size = 4
tv6011 = -24						; size = 4
tv6006 = -24						; size = 4
tv6003 = -24						; size = 4
tv5999 = -24						; size = 4
tv5993 = -24						; size = 4
tv5990 = -24						; size = 4
tv5987 = -24						; size = 4
tv5984 = -24						; size = 4
tv5980 = -24						; size = 4
tv5977 = -24						; size = 4
_i$1$ = -24						; size = 4
_i$1$ = -24						; size = 4
_i$1$ = -24						; size = 4
_i$1$ = -24						; size = 4
_i$1$ = -24						; size = 4
_pDev$ = -20						; size = 4
_ft_lvl$1$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_dc$ = 8						; size = 4
_sb$ = 12						; size = 4
?ApplyStateblock@@YAXPAUID3D11DeviceContext@@PAUD3DX11_STATE_BLOCK@@@Z PROC ; ApplyStateblock

; 1528 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ApplyStateblock@@YAXPAUID3D11DeviceContext@@PAUD3DX11_STATE_BLOCK@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 60					; 0000003cH
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pDev$[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1530 :                    dc->GetDevice (&pDev);

	mov	edi, DWORD PTR _dc$[ebp]
	lea	ecx, DWORD PTR _pDev$[ebp]
	push	ecx
	push	edi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR [edi]
	call	DWORD PTR [eax+12]

; 1531 :   const D3D_FEATURE_LEVEL ft_lvl = pDev->GetFeatureLevel ();

	mov	eax, DWORD PTR _pDev$[ebp]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+148]

; 1538 :   dc->VSSetShader            (sb->VS, sb->VSInterfaces, sb->VSInterfaceCount);

	mov	esi, DWORD PTR _sb$[ebp]
	mov	DWORD PTR _ft_lvl$1$[ebp], eax
	mov	eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits

; 741  : 		return (UINT_MAX);

	mov	DWORD PTR _minus_one$[ebp], -1
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1538 :   dc->VSSetShader            (sb->VS, sb->VSInterfaces, sb->VSInterfaceCount);

	push	DWORD PTR [esi+1648]
	lea	ecx, DWORD PTR [esi+636]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits

; 741  : 		return (UINT_MAX);

	mov	DWORD PTR _minus_one$[ebp+4], -1
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1538 :   dc->VSSetShader            (sb->VS, sb->VSInterfaces, sb->VSInterfaceCount);

	push	ecx
	push	DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits

; 741  : 		return (UINT_MAX);

	mov	DWORD PTR _minus_one$[ebp+8], -1
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1538 :   dc->VSSetShader            (sb->VS, sb->VSInterfaces, sb->VSInterfaceCount);

	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits

; 741  : 		return (UINT_MAX);

	mov	DWORD PTR _minus_one$[ebp+12], -1
	mov	DWORD PTR _minus_one$[ebp+16], -1
	mov	DWORD PTR _minus_one$[ebp+20], -1
	mov	DWORD PTR _minus_one$[ebp+24], -1
	mov	DWORD PTR _minus_one$[ebp+28], -1
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1538 :   dc->VSSetShader            (sb->VS, sb->VSInterfaces, sb->VSInterfaceCount);

	mov	DWORD PTR tv6054[ebp], ecx
	call	DWORD PTR [eax+44]

; 1539 : 
; 1540 :   if (sb->VS != nullptr) sb->VS->Release ();

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN86@ApplyState
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN86@ApplyState:

; 1541 : 
; 1542 :   for (UINT i = 0; i < sb->VSInterfaceCount; i++)

	xor	edi, edi
	cmp	DWORD PTR [esi+1648], edi
	jbe	SHORT $LN3@ApplyState
	lea	eax, DWORD PTR [esi+636]
$LL4@ApplyState:

; 1543 :   {
; 1544 :     if (sb->VSInterfaces [i] != nullptr)

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@ApplyState

; 1545 :       sb->VSInterfaces [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR tv6054[ebp]
$LN2@ApplyState:

; 1541 : 
; 1542 :   for (UINT i = 0; i < sb->VSInterfaceCount; i++)

	inc	edi
	add	eax, 4
	mov	DWORD PTR tv6054[ebp], eax
	cmp	edi, DWORD PTR [esi+1648]
	jb	SHORT $LL4@ApplyState
$LN3@ApplyState:

; 1239 :   for ( int i = static_cast <int> (max_count) - 1 ;

	mov	edi, 15					; 0000000fH
	lea	eax, DWORD PTR [esi+64]
	npad	2
$LL190@ApplyState:

; 1242 :   {
; 1243 :     if (arr [i] != 0)

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN368@ApplyState

; 1240 :             i >= 0 ;
; 1241 :           --i )

	sub	eax, 4
	sub	edi, 1
	jns	SHORT $LL190@ApplyState

; 1244 :       return i;
; 1245 :   }
; 1246 : 
; 1247 :   return max_count;

	mov	edi, 16					; 00000010H

; 1546 :   }
; 1547 :   
; 1548 :   UINT VSSamplerCount =
; 1549 :     calc_count               (sb->VSSamplers, D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT);
; 1550 :   
; 1551 :   if (VSSamplerCount)

	jmp	SHORT $LN600@ApplyState
$LN368@ApplyState:
	test	edi, edi
	je	SHORT $LN6@ApplyState
$LN600@ApplyState:

; 1552 :   {
; 1553 :     dc->VSSetSamplers        (0, VSSamplerCount, sb->VSSamplers);

	mov	edx, DWORD PTR _dc$[ebp]
	lea	ecx, DWORD PTR [esi+4]
	push	ecx
	push	edi
	push	0
	mov	eax, DWORD PTR [edx]
	push	edx
	mov	DWORD PTR tv6051[ebp], ecx
	call	DWORD PTR [eax+104]

; 1554 : 
; 1555 :     for (UINT i = 0; i < VSSamplerCount; i++)

	test	edi, edi
	je	SHORT $LN6@ApplyState
	lea	eax, DWORD PTR [esi+4]
$LL7@ApplyState:

; 1556 :     {
; 1557 :       if (sb->VSSamplers [i] != nullptr)

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@ApplyState

; 1558 :         sb->VSSamplers [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR tv6051[ebp]
$LN5@ApplyState:

; 1554 : 
; 1555 :     for (UINT i = 0; i < VSSamplerCount; i++)

	add	eax, 4
	mov	DWORD PTR tv6051[ebp], eax
	sub	edi, 1
	jne	SHORT $LL7@ApplyState
$LN6@ApplyState:

; 1239 :   for ( int i = static_cast <int> (max_count) - 1 ;

	mov	edi, 127				; 0000007fH
	lea	eax, DWORD PTR [esi+576]
$LL196@ApplyState:

; 1242 :   {
; 1243 :     if (arr [i] != 0)

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN369@ApplyState

; 1240 :             i >= 0 ;
; 1241 :           --i )

	sub	eax, 4
	sub	edi, 1
	jns	SHORT $LL196@ApplyState

; 1244 :       return i;
; 1245 :   }
; 1246 : 
; 1247 :   return max_count;

	mov	edi, 128				; 00000080H

; 1559 :     }
; 1560 :   }
; 1561 :   
; 1562 :   UINT VSShaderResourceCount =
; 1563 :     calc_count               (sb->VSShaderResources, D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT);
; 1564 :   
; 1565 :   if (VSShaderResourceCount)

	jmp	SHORT $LN601@ApplyState
$LN369@ApplyState:
	test	edi, edi
	je	SHORT $LN9@ApplyState
$LN601@ApplyState:

; 1566 :   {
; 1567 :     dc->VSSetShaderResources (0, VSShaderResourceCount, sb->VSShaderResources);

	mov	ecx, DWORD PTR _dc$[ebp]
	lea	edx, DWORD PTR [esi+68]
	push	edx
	push	edi
	push	0
	mov	eax, DWORD PTR [ecx]
	push	ecx
	mov	DWORD PTR tv6048[ebp], edx
	call	DWORD PTR [eax+100]

; 1568 : 
; 1569 :     for (UINT i = 0; i < VSShaderResourceCount; i++)

	test	edi, edi
	je	SHORT $LN9@ApplyState
	lea	eax, DWORD PTR [esi+68]
	npad	7
$LL10@ApplyState:

; 1570 :     {
; 1571 :       if (sb->VSShaderResources [i] != nullptr)

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN8@ApplyState

; 1572 :         sb->VSShaderResources [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR tv6048[ebp]
$LN8@ApplyState:

; 1568 : 
; 1569 :     for (UINT i = 0; i < VSShaderResourceCount; i++)

	add	eax, 4
	mov	DWORD PTR tv6048[ebp], eax
	sub	edi, 1
	jne	SHORT $LL10@ApplyState
$LN9@ApplyState:

; 1239 :   for ( int i = static_cast <int> (max_count) - 1 ;

	mov	edi, 13					; 0000000dH
	lea	eax, DWORD PTR [esi+632]
$LL202@ApplyState:

; 1242 :   {
; 1243 :     if (arr [i] != 0)

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN370@ApplyState

; 1240 :             i >= 0 ;
; 1241 :           --i )

	sub	eax, 4
	sub	edi, 1
	jns	SHORT $LL202@ApplyState

; 1244 :       return i;
; 1245 :   }
; 1246 : 
; 1247 :   return max_count;

	mov	edi, 14					; 0000000eH

; 1573 :     }
; 1574 :   }
; 1575 :   
; 1576 :   UINT VSConstantBufferCount =
; 1577 :     calc_count               (sb->VSConstantBuffers, D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT);
; 1578 :   
; 1579 :   if (VSConstantBufferCount)

	jmp	SHORT $LN602@ApplyState
$LN370@ApplyState:
	test	edi, edi
	je	SHORT $LN12@ApplyState
$LN602@ApplyState:

; 1580 :   {
; 1581 :     dc->VSSetConstantBuffers (0, VSConstantBufferCount, sb->VSConstantBuffers);

	mov	ecx, DWORD PTR _dc$[ebp]
	lea	edx, DWORD PTR [esi+580]
	push	edx
	push	edi
	push	0
	mov	eax, DWORD PTR [ecx]
	push	ecx
	mov	DWORD PTR tv6044[ebp], edx
	call	DWORD PTR [eax+28]

; 1582 : 
; 1583 :     for (UINT i = 0; i < VSConstantBufferCount; i++)

	test	edi, edi
	je	SHORT $LN12@ApplyState
	lea	eax, DWORD PTR [esi+580]
	npad	3
$LL13@ApplyState:

; 1584 :     {
; 1585 :       if (sb->VSConstantBuffers [i] != nullptr)

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN11@ApplyState

; 1586 :         sb->VSConstantBuffers [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR tv6044[ebp]
$LN11@ApplyState:

; 1582 : 
; 1583 :     for (UINT i = 0; i < VSConstantBufferCount; i++)

	add	eax, 4
	mov	DWORD PTR tv6044[ebp], eax
	sub	edi, 1
	jne	SHORT $LL13@ApplyState
$LN12@ApplyState:

; 1587 :     }
; 1588 :   }
; 1589 : 
; 1590 : 
; 1591 :   if (ft_lvl >= D3D_FEATURE_LEVEL_10_0)

	mov	eax, DWORD PTR _ft_lvl$1$[ebp]
	cmp	eax, 40960				; 0000a000H
	jl	$LN24@ApplyState

; 1592 :   {
; 1593 :     dc->GSSetShader            (sb->GS, sb->GSInterfaces, sb->GSInterfaceCount);

	push	DWORD PTR [esi+3300]
	mov	ecx, DWORD PTR _dc$[ebp]
	lea	edi, DWORD PTR [esi+2288]
	push	edi
	push	DWORD PTR [esi+1652]
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+92]

; 1594 : 
; 1595 :     if (sb->GS != nullptr) sb->GS->Release ();

	mov	ecx, DWORD PTR [esi+1652]
	test	ecx, ecx
	je	SHORT $LN95@ApplyState
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN95@ApplyState:

; 1596 : 
; 1597 :     for (UINT i = 0; i < sb->GSInterfaceCount; i++)

	xor	eax, eax
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	DWORD PTR [esi+3300], eax
	jbe	SHORT $LN15@ApplyState
$LL16@ApplyState:

; 1598 :     {
; 1599 :       if (sb->GSInterfaces [i] != nullptr)

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN14@ApplyState

; 1600 :         sb->GSInterfaces [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _i$1$[ebp]
$LN14@ApplyState:

; 1596 : 
; 1597 :     for (UINT i = 0; i < sb->GSInterfaceCount; i++)

	inc	eax
	add	edi, 4
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	eax, DWORD PTR [esi+3300]
	jb	SHORT $LL16@ApplyState
$LN15@ApplyState:

; 1239 :   for ( int i = static_cast <int> (max_count) - 1 ;

	mov	edi, 15					; 0000000fH
	lea	eax, DWORD PTR [esi+1716]
	npad	6
$LL208@ApplyState:

; 1242 :   {
; 1243 :     if (arr [i] != 0)

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN371@ApplyState

; 1240 :             i >= 0 ;
; 1241 :           --i )

	sub	eax, 4
	sub	edi, 1
	jns	SHORT $LL208@ApplyState

; 1244 :       return i;
; 1245 :   }
; 1246 : 
; 1247 :   return max_count;

	mov	edi, 16					; 00000010H

; 1601 :     }
; 1602 : 
; 1603 :     UINT GSSamplerCount =
; 1604 :       calc_count               (sb->GSSamplers, D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT);
; 1605 : 
; 1606 :     if (GSSamplerCount)

	jmp	SHORT $LN603@ApplyState
$LN371@ApplyState:
	test	edi, edi
	je	SHORT $LN18@ApplyState
$LN603@ApplyState:

; 1607 :     {
; 1608 :       dc->GSSetSamplers        (0, GSSamplerCount, sb->GSSamplers);

	mov	ecx, DWORD PTR _dc$[ebp]
	lea	edx, DWORD PTR [esi+1656]
	push	edx
	push	edi
	push	0
	mov	eax, DWORD PTR [ecx]
	push	ecx
	mov	DWORD PTR tv6039[ebp], edx
	call	DWORD PTR [eax+128]

; 1609 : 
; 1610 :       for (UINT i = 0; i < GSSamplerCount; i++)

	test	edi, edi
	je	SHORT $LN18@ApplyState
	lea	eax, DWORD PTR [esi+1656]
	npad	5
$LL19@ApplyState:

; 1611 :       {
; 1612 :         if (sb->GSSamplers [i] != nullptr)

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN17@ApplyState

; 1613 :           sb->GSSamplers [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR tv6039[ebp]
$LN17@ApplyState:

; 1609 : 
; 1610 :       for (UINT i = 0; i < GSSamplerCount; i++)

	add	eax, 4
	mov	DWORD PTR tv6039[ebp], eax
	sub	edi, 1
	jne	SHORT $LL19@ApplyState
$LN18@ApplyState:

; 1239 :   for ( int i = static_cast <int> (max_count) - 1 ;

	mov	edi, 127				; 0000007fH
	lea	eax, DWORD PTR [esi+2228]
$LL214@ApplyState:

; 1242 :   {
; 1243 :     if (arr [i] != 0)

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN372@ApplyState

; 1240 :             i >= 0 ;
; 1241 :           --i )

	sub	eax, 4
	sub	edi, 1
	jns	SHORT $LL214@ApplyState

; 1244 :       return i;
; 1245 :   }
; 1246 : 
; 1247 :   return max_count;

	mov	edi, 128				; 00000080H

; 1614 :       }
; 1615 :     }
; 1616 : 
; 1617 :     UINT GSShaderResourceCount =
; 1618 :       calc_count               (sb->GSShaderResources, D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT);
; 1619 : 
; 1620 :     if (GSShaderResourceCount)

	jmp	SHORT $LN604@ApplyState
$LN372@ApplyState:
	test	edi, edi
	je	SHORT $LN21@ApplyState
$LN604@ApplyState:

; 1621 :     {
; 1622 :       dc->GSSetShaderResources (0, GSShaderResourceCount, sb->GSShaderResources);

	mov	ecx, DWORD PTR _dc$[ebp]
	lea	edx, DWORD PTR [esi+1720]
	push	edx
	push	edi
	push	0
	mov	eax, DWORD PTR [ecx]
	push	ecx
	mov	DWORD PTR tv6036[ebp], edx
	call	DWORD PTR [eax+124]

; 1623 : 
; 1624 :       for (UINT i = 0; i < GSShaderResourceCount; i++)

	test	edi, edi
	je	SHORT $LN21@ApplyState
	lea	eax, DWORD PTR [esi+1720]
	npad	3
$LL22@ApplyState:

; 1625 :       {
; 1626 :         if (sb->GSShaderResources [i] != nullptr)

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN20@ApplyState

; 1627 :           sb->GSShaderResources [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR tv6036[ebp]
$LN20@ApplyState:

; 1623 : 
; 1624 :       for (UINT i = 0; i < GSShaderResourceCount; i++)

	add	eax, 4
	mov	DWORD PTR tv6036[ebp], eax
	sub	edi, 1
	jne	SHORT $LL22@ApplyState
$LN21@ApplyState:

; 1239 :   for ( int i = static_cast <int> (max_count) - 1 ;

	mov	edi, 13					; 0000000dH
	lea	eax, DWORD PTR [esi+2284]
$LL220@ApplyState:

; 1242 :   {
; 1243 :     if (arr [i] != 0)

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN373@ApplyState

; 1240 :             i >= 0 ;
; 1241 :           --i )

	sub	eax, 4
	sub	edi, 1
	jns	SHORT $LL220@ApplyState

; 1244 :       return i;
; 1245 :   }
; 1246 : 
; 1247 :   return max_count;

	mov	edi, 14					; 0000000eH

; 1628 :       }
; 1629 :     }
; 1630 : 
; 1631 :     UINT GSConstantBufferCount =
; 1632 :       calc_count               (sb->GSConstantBuffers, D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT);
; 1633 : 
; 1634 :     if (GSConstantBufferCount)

	jmp	SHORT $LN605@ApplyState
$LN373@ApplyState:
	test	edi, edi
	je	SHORT $LN624@ApplyState
$LN605@ApplyState:

; 1635 :     {
; 1636 :       dc->GSSetConstantBuffers (0, GSConstantBufferCount, sb->GSConstantBuffers);

	mov	ecx, DWORD PTR _dc$[ebp]
	lea	edx, DWORD PTR [esi+2232]
	push	edx
	push	edi
	push	0
	mov	eax, DWORD PTR [ecx]
	push	ecx
	mov	DWORD PTR tv6033[ebp], edx
	call	DWORD PTR [eax+88]

; 1637 : 
; 1638 :       for (UINT i = 0; i < GSConstantBufferCount; i++)

	test	edi, edi
	je	SHORT $LN624@ApplyState
	lea	eax, DWORD PTR [esi+2232]
	npad	3
$LL25@ApplyState:

; 1639 :       {
; 1640 :         if (sb->GSConstantBuffers [i] != nullptr)

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN23@ApplyState

; 1641 :           sb->GSConstantBuffers [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR tv6033[ebp]
$LN23@ApplyState:

; 1637 : 
; 1638 :       for (UINT i = 0; i < GSConstantBufferCount; i++)

	add	eax, 4
	mov	DWORD PTR tv6033[ebp], eax
	sub	edi, 1
	jne	SHORT $LL25@ApplyState
$LN624@ApplyState:
	mov	eax, DWORD PTR _ft_lvl$1$[ebp]
$LN24@ApplyState:

; 1642 :       }
; 1643 :     }
; 1644 :   }
; 1645 : 
; 1646 : 
; 1647 :   if (ft_lvl >= D3D_FEATURE_LEVEL_11_0)

	cmp	eax, 45056				; 0000b000H
	jl	$LN48@ApplyState

; 1648 :   {
; 1649 :     dc->HSSetShader            (sb->HS, sb->HSInterfaces, sb->HSInterfaceCount);

	push	DWORD PTR [esi+4952]
	mov	ecx, DWORD PTR _dc$[ebp]
	lea	edi, DWORD PTR [esi+3940]
	push	edi
	push	DWORD PTR [esi+3304]
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+240]

; 1650 : 
; 1651 :     if (sb->HS != nullptr) sb->HS->Release ();

	mov	ecx, DWORD PTR [esi+3304]
	test	ecx, ecx
	je	SHORT $LN104@ApplyState
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN104@ApplyState:

; 1652 : 
; 1653 :     for (UINT i = 0; i < sb->HSInterfaceCount; i++)

	xor	eax, eax
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	DWORD PTR [esi+4952], eax
	jbe	SHORT $LN27@ApplyState
$LL28@ApplyState:

; 1654 :     {
; 1655 :       if (sb->HSInterfaces [i] != nullptr)

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN26@ApplyState

; 1656 :         sb->HSInterfaces [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _i$1$[ebp]
$LN26@ApplyState:

; 1652 : 
; 1653 :     for (UINT i = 0; i < sb->HSInterfaceCount; i++)

	inc	eax
	add	edi, 4
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	eax, DWORD PTR [esi+4952]
	jb	SHORT $LL28@ApplyState
$LN27@ApplyState:

; 1239 :   for ( int i = static_cast <int> (max_count) - 1 ;

	mov	edi, 15					; 0000000fH
	lea	eax, DWORD PTR [esi+3368]
	npad	3
$LL226@ApplyState:

; 1242 :   {
; 1243 :     if (arr [i] != 0)

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN374@ApplyState

; 1240 :             i >= 0 ;
; 1241 :           --i )

	sub	eax, 4
	sub	edi, 1
	jns	SHORT $LL226@ApplyState

; 1244 :       return i;
; 1245 :   }
; 1246 : 
; 1247 :   return max_count;

	mov	edi, 16					; 00000010H

; 1657 :     }
; 1658 : 
; 1659 :     UINT HSSamplerCount =
; 1660 :       calc_count               (sb->HSSamplers, D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT);
; 1661 : 
; 1662 :     if (HSSamplerCount)

	jmp	SHORT $LN606@ApplyState
$LN374@ApplyState:
	test	edi, edi
	je	SHORT $LN30@ApplyState
$LN606@ApplyState:

; 1663 :     {
; 1664 :       dc->HSSetSamplers        (0, HSSamplerCount, sb->HSSamplers);

	mov	ecx, DWORD PTR _dc$[ebp]
	lea	edx, DWORD PTR [esi+3308]
	push	edx
	push	edi
	push	0
	mov	eax, DWORD PTR [ecx]
	push	ecx
	mov	DWORD PTR tv6028[ebp], edx
	call	DWORD PTR [eax+244]

; 1665 : 
; 1666 :       for (UINT i = 0; i < HSSamplerCount; i++)

	test	edi, edi
	je	SHORT $LN30@ApplyState
	lea	eax, DWORD PTR [esi+3308]
	npad	5
$LL31@ApplyState:

; 1667 :       {
; 1668 :         if (sb->HSSamplers [i] != nullptr)

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN29@ApplyState

; 1669 :           sb->HSSamplers [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR tv6028[ebp]
$LN29@ApplyState:

; 1665 : 
; 1666 :       for (UINT i = 0; i < HSSamplerCount; i++)

	add	eax, 4
	mov	DWORD PTR tv6028[ebp], eax
	sub	edi, 1
	jne	SHORT $LL31@ApplyState
$LN30@ApplyState:

; 1239 :   for ( int i = static_cast <int> (max_count) - 1 ;

	mov	edi, 127				; 0000007fH
	lea	eax, DWORD PTR [esi+3880]
$LL232@ApplyState:

; 1242 :   {
; 1243 :     if (arr [i] != 0)

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN375@ApplyState

; 1240 :             i >= 0 ;
; 1241 :           --i )

	sub	eax, 4
	sub	edi, 1
	jns	SHORT $LL232@ApplyState

; 1244 :       return i;
; 1245 :   }
; 1246 : 
; 1247 :   return max_count;

	mov	edi, 128				; 00000080H

; 1670 :       }
; 1671 :     }
; 1672 : 
; 1673 :     UINT HSShaderResourceCount =
; 1674 :       calc_count               (sb->HSShaderResources, D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT);
; 1675 : 
; 1676 :     if (HSShaderResourceCount)

	jmp	SHORT $LN607@ApplyState
$LN375@ApplyState:
	test	edi, edi
	je	SHORT $LN33@ApplyState
$LN607@ApplyState:

; 1677 :     {
; 1678 :       dc->HSSetShaderResources (0, HSShaderResourceCount, sb->HSShaderResources);

	mov	ecx, DWORD PTR _dc$[ebp]
	lea	edx, DWORD PTR [esi+3372]
	push	edx
	push	edi
	push	0
	mov	eax, DWORD PTR [ecx]
	push	ecx
	mov	DWORD PTR tv6025[ebp], edx
	call	DWORD PTR [eax+236]

; 1679 : 
; 1680 :       for (UINT i = 0; i < HSShaderResourceCount; i++)

	test	edi, edi
	je	SHORT $LN33@ApplyState
	lea	eax, DWORD PTR [esi+3372]
$LL34@ApplyState:

; 1681 :       {
; 1682 :         if (sb->HSShaderResources [i] != nullptr)

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN32@ApplyState

; 1683 :           sb->HSShaderResources [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR tv6025[ebp]
$LN32@ApplyState:

; 1679 : 
; 1680 :       for (UINT i = 0; i < HSShaderResourceCount; i++)

	add	eax, 4
	mov	DWORD PTR tv6025[ebp], eax
	sub	edi, 1
	jne	SHORT $LL34@ApplyState
$LN33@ApplyState:

; 1239 :   for ( int i = static_cast <int> (max_count) - 1 ;

	mov	edi, 13					; 0000000dH
	lea	eax, DWORD PTR [esi+3936]
$LL238@ApplyState:

; 1242 :   {
; 1243 :     if (arr [i] != 0)

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN376@ApplyState

; 1240 :             i >= 0 ;
; 1241 :           --i )

	sub	eax, 4
	sub	edi, 1
	jns	SHORT $LL238@ApplyState

; 1244 :       return i;
; 1245 :   }
; 1246 : 
; 1247 :   return max_count;

	mov	edi, 14					; 0000000eH

; 1684 :       }
; 1685 :     }
; 1686 : 
; 1687 :     UINT HSConstantBufferCount =
; 1688 :       calc_count               (sb->HSConstantBuffers, D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT);
; 1689 : 
; 1690 :     if (HSConstantBufferCount)

	jmp	SHORT $LN608@ApplyState
$LN376@ApplyState:
	test	edi, edi
	je	SHORT $LN36@ApplyState
$LN608@ApplyState:

; 1691 :     {
; 1692 :       dc->HSSetConstantBuffers (0, HSConstantBufferCount, sb->HSConstantBuffers);

	mov	ecx, DWORD PTR _dc$[ebp]
	lea	edx, DWORD PTR [esi+3884]
	push	edx
	push	edi
	push	0
	mov	eax, DWORD PTR [ecx]
	push	ecx
	mov	DWORD PTR tv6022[ebp], edx
	call	DWORD PTR [eax+248]

; 1693 : 
; 1694 :       for (UINT i = 0; i < HSConstantBufferCount; i++)

	test	edi, edi
	je	SHORT $LN36@ApplyState
	lea	eax, DWORD PTR [esi+3884]
$LL37@ApplyState:

; 1695 :       {
; 1696 :         if (sb->HSConstantBuffers [i] != nullptr)

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN35@ApplyState

; 1697 :           sb->HSConstantBuffers [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR tv6022[ebp]
$LN35@ApplyState:

; 1693 : 
; 1694 :       for (UINT i = 0; i < HSConstantBufferCount; i++)

	add	eax, 4
	mov	DWORD PTR tv6022[ebp], eax
	sub	edi, 1
	jne	SHORT $LL37@ApplyState
$LN36@ApplyState:

; 1698 :       }
; 1699 :     }
; 1700 : 
; 1701 : 
; 1702 :     dc->DSSetShader            (sb->DS, sb->DSInterfaces, sb->DSInterfaceCount);

	push	DWORD PTR [esi+6604]
	mov	ecx, DWORD PTR _dc$[ebp]
	lea	edi, DWORD PTR [esi+5592]
	push	edi
	push	DWORD PTR [esi+4956]
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+256]

; 1703 : 
; 1704 :     if (sb->DS != nullptr) sb->DS->Release ();

	mov	ecx, DWORD PTR [esi+4956]
	test	ecx, ecx
	je	SHORT $LN112@ApplyState
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN112@ApplyState:

; 1705 : 
; 1706 :     for (UINT i = 0; i < sb->DSInterfaceCount; i++)

	xor	eax, eax
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	DWORD PTR [esi+6604], eax
	jbe	SHORT $LN39@ApplyState
$LL40@ApplyState:

; 1707 :     {
; 1708 :       if (sb->DSInterfaces [i] != nullptr)

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN38@ApplyState

; 1709 :         sb->DSInterfaces [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _i$1$[ebp]
$LN38@ApplyState:

; 1705 : 
; 1706 :     for (UINT i = 0; i < sb->DSInterfaceCount; i++)

	inc	eax
	add	edi, 4
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	eax, DWORD PTR [esi+6604]
	jb	SHORT $LL40@ApplyState
$LN39@ApplyState:

; 1239 :   for ( int i = static_cast <int> (max_count) - 1 ;

	mov	edi, 15					; 0000000fH
	lea	eax, DWORD PTR [esi+5020]
	npad	1
$LL244@ApplyState:

; 1242 :   {
; 1243 :     if (arr [i] != 0)

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN377@ApplyState

; 1240 :             i >= 0 ;
; 1241 :           --i )

	sub	eax, 4
	sub	edi, 1
	jns	SHORT $LL244@ApplyState

; 1244 :       return i;
; 1245 :   }
; 1246 : 
; 1247 :   return max_count;

	mov	edi, 16					; 00000010H

; 1710 :     }
; 1711 : 
; 1712 :     UINT DSSamplerCount =
; 1713 :       calc_count               (sb->DSSamplers, D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT);
; 1714 : 
; 1715 :     if (DSSamplerCount)

	jmp	SHORT $LN609@ApplyState
$LN377@ApplyState:
	test	edi, edi
	je	SHORT $LN42@ApplyState
$LN609@ApplyState:

; 1716 :     {
; 1717 :       dc->DSSetSamplers        (0, DSSamplerCount, sb->DSSamplers);

	mov	ecx, DWORD PTR _dc$[ebp]
	lea	edx, DWORD PTR [esi+4960]
	push	edx
	push	edi
	push	0
	mov	eax, DWORD PTR [ecx]
	push	ecx
	mov	DWORD PTR tv6017[ebp], edx
	call	DWORD PTR [eax+260]

; 1718 : 
; 1719 :       for (UINT i = 0; i < DSSamplerCount; i++)

	test	edi, edi
	je	SHORT $LN42@ApplyState
	lea	eax, DWORD PTR [esi+4960]
	npad	5
$LL43@ApplyState:

; 1720 :       {
; 1721 :         if (sb->DSSamplers [i] != nullptr)

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN41@ApplyState

; 1722 :           sb->DSSamplers [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR tv6017[ebp]
$LN41@ApplyState:

; 1718 : 
; 1719 :       for (UINT i = 0; i < DSSamplerCount; i++)

	add	eax, 4
	mov	DWORD PTR tv6017[ebp], eax
	sub	edi, 1
	jne	SHORT $LL43@ApplyState
$LN42@ApplyState:

; 1239 :   for ( int i = static_cast <int> (max_count) - 1 ;

	mov	edi, 127				; 0000007fH
	lea	eax, DWORD PTR [esi+5532]
$LL250@ApplyState:

; 1242 :   {
; 1243 :     if (arr [i] != 0)

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN378@ApplyState

; 1240 :             i >= 0 ;
; 1241 :           --i )

	sub	eax, 4
	sub	edi, 1
	jns	SHORT $LL250@ApplyState

; 1244 :       return i;
; 1245 :   }
; 1246 : 
; 1247 :   return max_count;

	mov	edi, 128				; 00000080H

; 1723 :       }
; 1724 :     }
; 1725 : 
; 1726 :     UINT DSShaderResourceCount =
; 1727 :       calc_count               (sb->DSShaderResources, D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT);
; 1728 : 
; 1729 :     if (DSShaderResourceCount)

	jmp	SHORT $LN610@ApplyState
$LN378@ApplyState:
	test	edi, edi
	je	SHORT $LN45@ApplyState
$LN610@ApplyState:

; 1730 :     {
; 1731 :       dc->DSSetShaderResources (0, DSShaderResourceCount, sb->DSShaderResources);

	mov	ecx, DWORD PTR _dc$[ebp]
	lea	edx, DWORD PTR [esi+5024]
	push	edx
	push	edi
	push	0
	mov	eax, DWORD PTR [ecx]
	push	ecx
	mov	DWORD PTR tv6014[ebp], edx
	call	DWORD PTR [eax+252]

; 1732 : 
; 1733 :       for (UINT i = 0; i < DSShaderResourceCount; i++)

	test	edi, edi
	je	SHORT $LN45@ApplyState
	lea	eax, DWORD PTR [esi+5024]
$LL46@ApplyState:

; 1734 :       {
; 1735 :         if (sb->DSShaderResources [i] != nullptr)

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN44@ApplyState

; 1736 :           sb->DSShaderResources [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR tv6014[ebp]
$LN44@ApplyState:

; 1732 : 
; 1733 :       for (UINT i = 0; i < DSShaderResourceCount; i++)

	add	eax, 4
	mov	DWORD PTR tv6014[ebp], eax
	sub	edi, 1
	jne	SHORT $LL46@ApplyState
$LN45@ApplyState:

; 1239 :   for ( int i = static_cast <int> (max_count) - 1 ;

	mov	edi, 13					; 0000000dH
	lea	eax, DWORD PTR [esi+5588]
$LL256@ApplyState:

; 1242 :   {
; 1243 :     if (arr [i] != 0)

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN379@ApplyState

; 1240 :             i >= 0 ;
; 1241 :           --i )

	sub	eax, 4
	sub	edi, 1
	jns	SHORT $LL256@ApplyState

; 1244 :       return i;
; 1245 :   }
; 1246 : 
; 1247 :   return max_count;

	mov	edi, 14					; 0000000eH

; 1737 :       }
; 1738 :     }
; 1739 : 
; 1740 :     UINT DSConstantBufferCount =
; 1741 :       calc_count               (sb->DSConstantBuffers, D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT);
; 1742 : 
; 1743 :     if (DSConstantBufferCount)

	jmp	SHORT $LN611@ApplyState
$LN379@ApplyState:
	test	edi, edi
	je	SHORT $LN48@ApplyState
$LN611@ApplyState:

; 1744 :     {
; 1745 :       dc->DSSetConstantBuffers (0, DSConstantBufferCount, sb->DSConstantBuffers);

	mov	ecx, DWORD PTR _dc$[ebp]
	lea	edx, DWORD PTR [esi+5536]
	push	edx
	push	edi
	push	0
	mov	eax, DWORD PTR [ecx]
	push	ecx
	mov	DWORD PTR tv6011[ebp], edx
	call	DWORD PTR [eax+264]

; 1746 : 
; 1747 :       for (UINT i = 0; i < DSConstantBufferCount; i++)

	test	edi, edi
	je	SHORT $LN48@ApplyState
	lea	eax, DWORD PTR [esi+5536]
$LL49@ApplyState:

; 1748 :       {
; 1749 :         if (sb->DSConstantBuffers [i] != nullptr)

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN47@ApplyState

; 1750 :           sb->DSConstantBuffers [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR tv6011[ebp]
$LN47@ApplyState:

; 1746 : 
; 1747 :       for (UINT i = 0; i < DSConstantBufferCount; i++)

	add	eax, 4
	mov	DWORD PTR tv6011[ebp], eax
	sub	edi, 1
	jne	SHORT $LL49@ApplyState
$LN48@ApplyState:

; 1751 :       }
; 1752 :     }
; 1753 :   }
; 1754 : 
; 1755 : 
; 1756 :   dc->PSSetShader            (sb->PS, sb->PSInterfaces, sb->PSInterfaceCount);

	push	DWORD PTR [esi+8256]
	mov	ecx, DWORD PTR _dc$[ebp]
	lea	edi, DWORD PTR [esi+7244]
	push	edi
	push	DWORD PTR [esi+6608]
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+36]

; 1757 : 
; 1758 :   if (sb->PS != nullptr) sb->PS->Release ();

	mov	ecx, DWORD PTR [esi+6608]
	test	ecx, ecx
	je	SHORT $LN120@ApplyState
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN120@ApplyState:

; 1759 : 
; 1760 :   for (UINT i = 0; i < sb->PSInterfaceCount; i++)

	xor	eax, eax
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	DWORD PTR [esi+8256], eax
	jbe	SHORT $LN51@ApplyState
$LL52@ApplyState:

; 1761 :   {
; 1762 :     if (sb->PSInterfaces [i] != nullptr)

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN50@ApplyState

; 1763 :       sb->PSInterfaces [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _i$1$[ebp]
$LN50@ApplyState:

; 1759 : 
; 1760 :   for (UINT i = 0; i < sb->PSInterfaceCount; i++)

	inc	eax
	add	edi, 4
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	eax, DWORD PTR [esi+8256]
	jb	SHORT $LL52@ApplyState
$LN51@ApplyState:

; 1239 :   for ( int i = static_cast <int> (max_count) - 1 ;

	mov	edi, 15					; 0000000fH
	lea	eax, DWORD PTR [esi+6672]
	npad	4
$LL262@ApplyState:

; 1242 :   {
; 1243 :     if (arr [i] != 0)

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN380@ApplyState

; 1240 :             i >= 0 ;
; 1241 :           --i )

	sub	eax, 4
	sub	edi, 1
	jns	SHORT $LL262@ApplyState

; 1244 :       return i;
; 1245 :   }
; 1246 : 
; 1247 :   return max_count;

	mov	edi, 16					; 00000010H

; 1764 :   }
; 1765 : 
; 1766 :   UINT PSSamplerCount =
; 1767 :     calc_count               (sb->PSSamplers, D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT);
; 1768 : 
; 1769 :   if (PSSamplerCount)

	jmp	SHORT $LN612@ApplyState
$LN380@ApplyState:
	test	edi, edi
	je	SHORT $LN54@ApplyState
$LN612@ApplyState:

; 1770 :   {
; 1771 :     dc->PSSetSamplers        (0, PSSamplerCount, sb->PSSamplers);

	mov	ecx, DWORD PTR _dc$[ebp]
	lea	edx, DWORD PTR [esi+6612]
	push	edx
	push	edi
	push	0
	mov	eax, DWORD PTR [ecx]
	push	ecx
	mov	DWORD PTR tv6006[ebp], edx
	call	DWORD PTR [eax+40]

; 1772 : 
; 1773 :     for (UINT i = 0; i < PSSamplerCount; i++)

	test	edi, edi
	je	SHORT $LN54@ApplyState
	lea	eax, DWORD PTR [esi+6612]
$LL55@ApplyState:

; 1774 :     {
; 1775 :       if (sb->PSSamplers [i] != nullptr)

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN53@ApplyState

; 1776 :         sb->PSSamplers [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR tv6006[ebp]
$LN53@ApplyState:

; 1772 : 
; 1773 :     for (UINT i = 0; i < PSSamplerCount; i++)

	add	eax, 4
	mov	DWORD PTR tv6006[ebp], eax
	sub	edi, 1
	jne	SHORT $LL55@ApplyState
$LN54@ApplyState:

; 1239 :   for ( int i = static_cast <int> (max_count) - 1 ;

	mov	edi, 127				; 0000007fH
	lea	eax, DWORD PTR [esi+7184]
	npad	3
$LL268@ApplyState:

; 1242 :   {
; 1243 :     if (arr [i] != 0)

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN381@ApplyState

; 1240 :             i >= 0 ;
; 1241 :           --i )

	sub	eax, 4
	sub	edi, 1
	jns	SHORT $LL268@ApplyState

; 1244 :       return i;
; 1245 :   }
; 1246 : 
; 1247 :   return max_count;

	mov	edi, 128				; 00000080H

; 1777 :     }
; 1778 :   }
; 1779 : 
; 1780 :   UINT PSShaderResourceCount =
; 1781 :     calc_count               (sb->PSShaderResources, D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT);
; 1782 : 
; 1783 :   if (PSShaderResourceCount)

	jmp	SHORT $LN613@ApplyState
$LN381@ApplyState:
	test	edi, edi
	je	SHORT $LN57@ApplyState
$LN613@ApplyState:

; 1784 :   {
; 1785 :     dc->PSSetShaderResources (0, PSShaderResourceCount, sb->PSShaderResources);

	mov	ecx, DWORD PTR _dc$[ebp]
	lea	edx, DWORD PTR [esi+6676]
	push	edx
	push	edi
	push	0
	mov	eax, DWORD PTR [ecx]
	push	ecx
	mov	DWORD PTR tv6003[ebp], edx
	call	DWORD PTR [eax+32]

; 1786 : 
; 1787 :     for (UINT i = 0; i < PSShaderResourceCount; i++)

	test	edi, edi
	je	SHORT $LN57@ApplyState
	lea	eax, DWORD PTR [esi+6676]
$LL58@ApplyState:

; 1788 :     {
; 1789 :       if (sb->PSShaderResources [i] != nullptr)

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN56@ApplyState

; 1790 :         sb->PSShaderResources [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR tv6003[ebp]
$LN56@ApplyState:

; 1786 : 
; 1787 :     for (UINT i = 0; i < PSShaderResourceCount; i++)

	add	eax, 4
	mov	DWORD PTR tv6003[ebp], eax
	sub	edi, 1
	jne	SHORT $LL58@ApplyState
$LN57@ApplyState:

; 1239 :   for ( int i = static_cast <int> (max_count) - 1 ;

	mov	edi, 13					; 0000000dH
	lea	eax, DWORD PTR [esi+7240]
	npad	3
$LL274@ApplyState:

; 1242 :   {
; 1243 :     if (arr [i] != 0)

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN382@ApplyState

; 1240 :             i >= 0 ;
; 1241 :           --i )

	sub	eax, 4
	sub	edi, 1
	jns	SHORT $LL274@ApplyState

; 1244 :       return i;
; 1245 :   }
; 1246 : 
; 1247 :   return max_count;

	mov	edi, 14					; 0000000eH

; 1791 :     }
; 1792 :   }
; 1793 : 
; 1794 :   UINT PSConstantBufferCount =
; 1795 :     calc_count               (sb->PSConstantBuffers, D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT);
; 1796 : 
; 1797 :   if (PSConstantBufferCount)

	jmp	SHORT $LN614@ApplyState
$LN382@ApplyState:
	test	edi, edi
	je	SHORT $LN60@ApplyState
$LN614@ApplyState:

; 1798 :   {
; 1799 :     dc->PSSetConstantBuffers (0, PSConstantBufferCount, sb->PSConstantBuffers);

	mov	ecx, DWORD PTR _dc$[ebp]
	lea	edx, DWORD PTR [esi+7188]
	push	edx
	push	edi
	push	0
	mov	eax, DWORD PTR [ecx]
	push	ecx
	mov	DWORD PTR tv5999[ebp], edx
	call	DWORD PTR [eax+64]

; 1800 : 
; 1801 :     for (UINT i = 0; i < PSConstantBufferCount; i++)

	test	edi, edi
	je	SHORT $LN60@ApplyState
	lea	eax, DWORD PTR [esi+7188]
$LL61@ApplyState:

; 1802 :     {
; 1803 :       if (sb->PSConstantBuffers [i] != nullptr)

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN59@ApplyState

; 1804 :         sb->PSConstantBuffers [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR tv5999[ebp]
$LN59@ApplyState:

; 1800 : 
; 1801 :     for (UINT i = 0; i < PSConstantBufferCount; i++)

	add	eax, 4
	mov	DWORD PTR tv5999[ebp], eax
	sub	edi, 1
	jne	SHORT $LL61@ApplyState
$LN60@ApplyState:

; 1805 :     }
; 1806 :   }
; 1807 : 
; 1808 : 
; 1809 :   if (ft_lvl >= D3D_FEATURE_LEVEL_11_0)

	cmp	DWORD PTR _ft_lvl$1$[ebp], 45056	; 0000b000H
	jl	$LN75@ApplyState

; 1810 :   {
; 1811 :     dc->CSSetShader            (sb->CS, sb->CSInterfaces, sb->CSInterfaceCount);

	push	DWORD PTR [esi+9908]
	mov	ecx, DWORD PTR _dc$[ebp]
	lea	edi, DWORD PTR [esi+8896]
	push	edi
	push	DWORD PTR [esi+8260]
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+276]

; 1812 : 
; 1813 :     if (sb->CS != nullptr)

	mov	ecx, DWORD PTR [esi+8260]
	test	ecx, ecx
	je	SHORT $LN129@ApplyState

; 1814 :       sb->CS->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN129@ApplyState:

; 1815 : 
; 1816 :     for (UINT i = 0; i < sb->CSInterfaceCount; i++)

	xor	eax, eax
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	DWORD PTR [esi+9908], eax
	jbe	SHORT $LN63@ApplyState
	npad	5
$LL64@ApplyState:

; 1817 :     {
; 1818 :       if (sb->CSInterfaces [i] != nullptr)

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN62@ApplyState

; 1819 :         sb->CSInterfaces [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _i$1$[ebp]
$LN62@ApplyState:

; 1815 : 
; 1816 :     for (UINT i = 0; i < sb->CSInterfaceCount; i++)

	inc	eax
	add	edi, 4
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	eax, DWORD PTR [esi+9908]
	jb	SHORT $LL64@ApplyState
$LN63@ApplyState:

; 1239 :   for ( int i = static_cast <int> (max_count) - 1 ;

	mov	edi, 15					; 0000000fH
	lea	eax, DWORD PTR [esi+8324]
	npad	7
$LL280@ApplyState:

; 1242 :   {
; 1243 :     if (arr [i] != 0)

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN383@ApplyState

; 1240 :             i >= 0 ;
; 1241 :           --i )

	sub	eax, 4
	sub	edi, 1
	jns	SHORT $LL280@ApplyState

; 1244 :       return i;
; 1245 :   }
; 1246 : 
; 1247 :   return max_count;

	mov	edi, 16					; 00000010H

; 1820 :     }
; 1821 : 
; 1822 :     UINT CSSamplerCount =
; 1823 :       calc_count               (sb->CSSamplers, D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT);
; 1824 : 
; 1825 :     if (CSSamplerCount)

	jmp	SHORT $LN615@ApplyState
$LN383@ApplyState:
	test	edi, edi
	je	SHORT $LN66@ApplyState
$LN615@ApplyState:

; 1826 :     {
; 1827 :       dc->CSSetSamplers        (0, CSSamplerCount, sb->CSSamplers);

	mov	ecx, DWORD PTR _dc$[ebp]
	lea	edx, DWORD PTR [esi+8264]
	push	edx
	push	edi
	push	0
	mov	eax, DWORD PTR [ecx]
	push	ecx
	mov	DWORD PTR tv5993[ebp], edx
	call	DWORD PTR [eax+280]

; 1828 : 
; 1829 :       for (UINT i = 0; i < CSSamplerCount; i++)

	test	edi, edi
	je	SHORT $LN66@ApplyState
	lea	eax, DWORD PTR [esi+8264]
	npad	5
$LL67@ApplyState:

; 1830 :       {
; 1831 :         if (sb->CSSamplers [i] != nullptr)

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN65@ApplyState

; 1832 :           sb->CSSamplers [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR tv5993[ebp]
$LN65@ApplyState:

; 1828 : 
; 1829 :       for (UINT i = 0; i < CSSamplerCount; i++)

	add	eax, 4
	mov	DWORD PTR tv5993[ebp], eax
	sub	edi, 1
	jne	SHORT $LL67@ApplyState
$LN66@ApplyState:

; 1239 :   for ( int i = static_cast <int> (max_count) - 1 ;

	mov	edi, 127				; 0000007fH
	lea	eax, DWORD PTR [esi+8836]
$LL286@ApplyState:

; 1242 :   {
; 1243 :     if (arr [i] != 0)

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN384@ApplyState

; 1240 :             i >= 0 ;
; 1241 :           --i )

	sub	eax, 4
	sub	edi, 1
	jns	SHORT $LL286@ApplyState

; 1244 :       return i;
; 1245 :   }
; 1246 : 
; 1247 :   return max_count;

	mov	edi, 128				; 00000080H

; 1833 :       }
; 1834 :     }
; 1835 : 
; 1836 :     UINT CSShaderResourceCount =
; 1837 :       calc_count               (sb->CSShaderResources, D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT);
; 1838 : 
; 1839 :     if (CSShaderResourceCount)

	jmp	SHORT $LN616@ApplyState
$LN384@ApplyState:
	test	edi, edi
	je	SHORT $LN69@ApplyState
$LN616@ApplyState:

; 1840 :     {
; 1841 :       dc->CSSetShaderResources (0, CSShaderResourceCount, sb->CSShaderResources);

	mov	ecx, DWORD PTR _dc$[ebp]
	lea	edx, DWORD PTR [esi+8328]
	push	edx
	push	edi
	push	0
	mov	eax, DWORD PTR [ecx]
	push	ecx
	mov	DWORD PTR tv5990[ebp], edx
	call	DWORD PTR [eax+268]

; 1842 : 
; 1843 :       for (UINT i = 0; i < CSShaderResourceCount; i++)

	test	edi, edi
	je	SHORT $LN69@ApplyState
	lea	eax, DWORD PTR [esi+8328]
$LL70@ApplyState:

; 1844 :       {
; 1845 :         if (sb->CSShaderResources [i] != nullptr)

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN68@ApplyState

; 1846 :           sb->CSShaderResources [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR tv5990[ebp]
$LN68@ApplyState:

; 1842 : 
; 1843 :       for (UINT i = 0; i < CSShaderResourceCount; i++)

	add	eax, 4
	mov	DWORD PTR tv5990[ebp], eax
	sub	edi, 1
	jne	SHORT $LL70@ApplyState
$LN69@ApplyState:

; 1239 :   for ( int i = static_cast <int> (max_count) - 1 ;

	mov	edi, 13					; 0000000dH
	lea	eax, DWORD PTR [esi+8892]
$LL292@ApplyState:

; 1242 :   {
; 1243 :     if (arr [i] != 0)

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN385@ApplyState

; 1240 :             i >= 0 ;
; 1241 :           --i )

	sub	eax, 4
	sub	edi, 1
	jns	SHORT $LL292@ApplyState

; 1244 :       return i;
; 1245 :   }
; 1246 : 
; 1247 :   return max_count;

	mov	edi, 14					; 0000000eH

; 1847 :       }
; 1848 :     }
; 1849 : 
; 1850 :     UINT CSConstantBufferCount =
; 1851 :       calc_count               (sb->CSConstantBuffers, D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT);
; 1852 : 
; 1853 :     if (CSConstantBufferCount)

	jmp	SHORT $LN617@ApplyState
$LN385@ApplyState:
	test	edi, edi
	je	SHORT $LN72@ApplyState
$LN617@ApplyState:

; 1854 :     {
; 1855 :       dc->CSSetConstantBuffers (0, CSConstantBufferCount, sb->CSConstantBuffers);

	mov	ecx, DWORD PTR _dc$[ebp]
	lea	edx, DWORD PTR [esi+8840]
	push	edx
	push	edi
	push	0
	mov	eax, DWORD PTR [ecx]
	push	ecx
	mov	DWORD PTR tv5987[ebp], edx
	call	DWORD PTR [eax+284]

; 1856 : 
; 1857 :       for (UINT i = 0; i < CSConstantBufferCount; i++)

	test	edi, edi
	je	SHORT $LN72@ApplyState
	lea	eax, DWORD PTR [esi+8840]
$LL73@ApplyState:

; 1858 :       {
; 1859 :         if (sb->CSConstantBuffers [i] != nullptr)

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN71@ApplyState

; 1860 :           sb->CSConstantBuffers [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR tv5987[ebp]
$LN71@ApplyState:

; 1856 : 
; 1857 :       for (UINT i = 0; i < CSConstantBufferCount; i++)

	add	eax, 4
	mov	DWORD PTR tv5987[ebp], eax
	sub	edi, 1
	jne	SHORT $LL73@ApplyState
$LN72@ApplyState:

; 1861 :       }
; 1862 :     }
; 1863 : 
; 1864 :     dc->CSSetUnorderedAccessViews (0, D3D11_PS_CS_UAV_REGISTER_COUNT, sb->CSUnorderedAccessViews, minus_one);

	mov	ecx, DWORD PTR _dc$[ebp]
	lea	edx, DWORD PTR _minus_one$[ebp]
	push	edx
	lea	edi, DWORD PTR [esi+9912]
	push	edi
	mov	eax, DWORD PTR [ecx]
	push	8
	push	0
	push	ecx
	call	DWORD PTR [eax+272]

; 1865 : 
; 1866 :     for (auto& CSUnorderedAccessView : sb->CSUnorderedAccessViews)

	lea	eax, DWORD PTR [edi+32]
	mov	DWORD PTR _<end>$L0$1$[ebp], eax
	cmp	edi, eax
	je	SHORT $LN75@ApplyState
	npad	1
$LL76@ApplyState:

; 1867 :     {
; 1868 :       if (CSUnorderedAccessView != nullptr)

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN74@ApplyState

; 1869 :           CSUnorderedAccessView->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _<end>$L0$1$[ebp]
$LN74@ApplyState:

; 1865 : 
; 1866 :     for (auto& CSUnorderedAccessView : sb->CSUnorderedAccessViews)

	add	edi, 4
	cmp	edi, eax
	jne	SHORT $LL76@ApplyState
$LN75@ApplyState:

; 1239 :   for ( int i = static_cast <int> (max_count) - 1 ;

	mov	edi, 31					; 0000001fH
	lea	eax, DWORD PTR [esi+10068]
$LL298@ApplyState:

; 1242 :   {
; 1243 :     if (arr [i] != 0)

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN386@ApplyState

; 1240 :             i >= 0 ;
; 1241 :           --i )

	sub	eax, 4
	sub	edi, 1
	jns	SHORT $LL298@ApplyState

; 1244 :       return i;
; 1245 :   }
; 1246 : 
; 1247 :   return max_count;

	mov	edi, 32					; 00000020H

; 1870 :     }
; 1871 :   }
; 1872 : 
; 1873 : 
; 1874 :   UINT IAVertexBufferCount =
; 1875 :     calc_count               (sb->IAVertexBuffers, D3D11_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT);
; 1876 : 
; 1877 :   if (IAVertexBufferCount)

	jmp	SHORT $LN618@ApplyState
$LN386@ApplyState:
	test	edi, edi
	je	SHORT $LN78@ApplyState
$LN618@ApplyState:

; 1878 :   {
; 1879 :     dc->IASetVertexBuffers   (0, IAVertexBufferCount, sb->IAVertexBuffers, sb->IAVertexBuffersStrides, sb->IAVertexBuffersOffsets);

	mov	edx, DWORD PTR _dc$[ebp]
	lea	eax, DWORD PTR [esi+9944]
	mov	DWORD PTR tv5984[ebp], eax
	lea	eax, DWORD PTR [esi+10200]
	push	eax
	lea	eax, DWORD PTR [esi+10072]
	mov	ecx, DWORD PTR [edx]
	push	eax
	lea	eax, DWORD PTR [esi+9944]
	push	eax
	push	edi
	push	0
	push	edx
	call	DWORD PTR [ecx+72]

; 1880 : 
; 1881 :     for (UINT i = 0; i < IAVertexBufferCount; i++)

	test	edi, edi
	je	SHORT $LN78@ApplyState
	lea	eax, DWORD PTR [esi+9944]
	npad	3
$LL79@ApplyState:

; 1882 :     {
; 1883 :       if (sb->IAVertexBuffers [i] != nullptr)

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN77@ApplyState

; 1884 :           sb->IAVertexBuffers [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR tv5984[ebp]
$LN77@ApplyState:

; 1880 : 
; 1881 :     for (UINT i = 0; i < IAVertexBufferCount; i++)

	add	eax, 4
	mov	DWORD PTR tv5984[ebp], eax
	sub	edi, 1
	jne	SHORT $LL79@ApplyState
$LN78@ApplyState:

; 1885 :     }
; 1886 :   }
; 1887 : 
; 1888 :   dc->IASetIndexBuffer       (sb->IAIndexBuffer, sb->IAIndexBufferFormat, sb->IAIndexBufferOffset);

	push	DWORD PTR [esi+10336]
	mov	edi, DWORD PTR _dc$[ebp]
	push	DWORD PTR [esi+10332]
	push	DWORD PTR [esi+10328]
	mov	eax, DWORD PTR [edi]
	push	edi
	call	DWORD PTR [eax+76]

; 1889 :   dc->IASetInputLayout       (sb->IAInputLayout);

	push	DWORD PTR [esi+10340]
	mov	eax, DWORD PTR [edi]
	push	edi
	call	DWORD PTR [eax+68]

; 1890 :   dc->IASetPrimitiveTopology (sb->IAPrimitiveTopology);

	push	DWORD PTR [esi+10344]
	mov	eax, DWORD PTR [edi]
	push	edi
	call	DWORD PTR [eax+96]

; 1891 : 
; 1892 :   if (sb->IAIndexBuffer != nullptr) sb->IAIndexBuffer->Release ();

	mov	ecx, DWORD PTR [esi+10328]
	test	ecx, ecx
	je	SHORT $LN140@ApplyState
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN140@ApplyState:

; 1893 :   if (sb->IAInputLayout != nullptr) sb->IAInputLayout->Release ();

	mov	ecx, DWORD PTR [esi+10340]
	test	ecx, ecx
	je	SHORT $LN141@ApplyState
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN141@ApplyState:

; 1894 : 
; 1895 : 
; 1896 :   dc->OMSetBlendState        (sb->OMBlendState,        sb->OMBlendFactor, sb->OMSampleMask);

	push	DWORD PTR [esi+10444]
	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [esi+10428]
	push	eax
	push	DWORD PTR [esi+10424]
	push	edi
	call	DWORD PTR [ecx+140]

; 1897 :   dc->OMSetDepthStencilState (sb->OMDepthStencilState, sb->OMDepthStencilRef);

	push	DWORD PTR [esi+10420]
	mov	eax, DWORD PTR [edi]
	push	DWORD PTR [esi+10416]
	push	edi
	call	DWORD PTR [eax+144]

; 1898 : 
; 1899 :   if (sb->OMBlendState)        sb->OMBlendState->Release        ();

	mov	ecx, DWORD PTR [esi+10424]
	test	ecx, ecx
	je	SHORT $LN142@ApplyState
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN142@ApplyState:

; 1900 :   if (sb->OMDepthStencilState) sb->OMDepthStencilState->Release ();

	mov	ecx, DWORD PTR [esi+10416]
	test	ecx, ecx
	je	SHORT $LN143@ApplyState
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN143@ApplyState:

; 1239 :   for ( int i = static_cast <int> (max_count) - 1 ;

	mov	edi, 7
	lea	eax, DWORD PTR [esi+10376]
	npad	7
$LL304@ApplyState:

; 1242 :   {
; 1243 :     if (arr [i] != 0)

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN387@ApplyState

; 1240 :             i >= 0 ;
; 1241 :           --i )

	sub	eax, 4
	sub	edi, 1
	jns	SHORT $LL304@ApplyState

; 1244 :       return i;
; 1245 :   }
; 1246 : 
; 1247 :   return max_count;

	mov	edi, 8

; 1901 : 
; 1902 :   UINT OMRenderTargetCount =
; 1903 :     calc_count (sb->OMRenderTargets, D3D11_SIMULTANEOUS_RENDER_TARGET_COUNT);
; 1904 : 
; 1905 :   if (OMRenderTargetCount)

	jmp	SHORT $LN619@ApplyState
$LN387@ApplyState:
	test	edi, edi
	je	SHORT $LN81@ApplyState
$LN619@ApplyState:

; 1906 :   {
; 1907 :     dc->OMSetRenderTargets   (OMRenderTargetCount, sb->OMRenderTargets, sb->OMRenderTargetStencilView);

	mov	ecx, DWORD PTR _dc$[ebp]
	lea	edx, DWORD PTR [esi+10348]
	push	DWORD PTR [esi+10380]
	mov	DWORD PTR tv5980[ebp], edx
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	edi
	push	ecx
	call	DWORD PTR [eax+132]

; 1908 : 
; 1909 :     for (UINT i = 0; i < OMRenderTargetCount; i++)

	test	edi, edi
	je	SHORT $LN81@ApplyState
	lea	eax, DWORD PTR [esi+10348]
	npad	1
$LL82@ApplyState:

; 1910 :     {
; 1911 :       if (sb->OMRenderTargets [i] != nullptr)

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN80@ApplyState

; 1912 :         sb->OMRenderTargets [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR tv5980[ebp]
$LN80@ApplyState:

; 1908 : 
; 1909 :     for (UINT i = 0; i < OMRenderTargetCount; i++)

	add	eax, 4
	mov	DWORD PTR tv5980[ebp], eax
	sub	edi, 1
	jne	SHORT $LL82@ApplyState
$LN81@ApplyState:

; 1913 :     }
; 1914 :   }
; 1915 : 
; 1916 :   if (sb->OMRenderTargetStencilView != nullptr)

	mov	ecx, DWORD PTR [esi+10380]
	test	ecx, ecx
	je	SHORT $LN146@ApplyState

; 1917 :     sb->OMRenderTargetStencilView->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN146@ApplyState:

; 1918 : 
; 1919 :   dc->RSSetViewports         (sb->RSViewportCount,     sb->RSViewports);

	mov	edi, DWORD PTR _dc$[ebp]
	lea	eax, DWORD PTR [esi+10452]
	push	eax
	push	DWORD PTR [esi+10448]
	mov	ecx, DWORD PTR [edi]
	push	edi
	call	DWORD PTR [ecx+176]

; 1920 :   dc->RSSetScissorRects      (sb->RSScissorRectCount,  sb->RSScissorRects);

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [esi+10840]
	push	eax
	push	DWORD PTR [esi+10836]
	push	edi
	call	DWORD PTR [ecx+180]

; 1921 : 
; 1922 :   dc->RSSetState             (sb->RSRasterizerState);

	push	DWORD PTR [esi+11096]
	mov	eax, DWORD PTR [edi]
	push	edi
	call	DWORD PTR [eax+172]

; 1923 : 
; 1924 :   if (sb->RSRasterizerState != nullptr)

	mov	ecx, DWORD PTR [esi+11096]
	test	ecx, ecx
	je	SHORT $LN147@ApplyState

; 1925 :     sb->RSRasterizerState->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN147@ApplyState:

; 1926 : 
; 1927 :   if (ft_lvl >= D3D_FEATURE_LEVEL_10_0)

	cmp	DWORD PTR _ft_lvl$1$[ebp], 40960	; 0000a000H
	jl	SHORT $LN84@ApplyState

; 1928 :   {
; 1929 :     UINT SOBuffersOffsets [4] = {   }; /* (sizeof(sb->SOBuffers) / sizeof(sb->SOBuffers[0])) * 0,

	xorps	xmm0, xmm0
	lea	eax, DWORD PTR [esi+11112]
	movups	XMMWORD PTR _SOBuffersOffsets$2[ebp], xmm0

; 1239 :   for ( int i = static_cast <int> (max_count) - 1 ;

	mov	edi, 3
$LL310@ApplyState:

; 1242 :   {
; 1243 :     if (arr [i] != 0)

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN388@ApplyState

; 1240 :             i >= 0 ;
; 1241 :           --i )

	sub	eax, 4
	sub	edi, 1
	jns	SHORT $LL310@ApplyState

; 1244 :       return i;
; 1245 :   }
; 1246 : 
; 1247 :   return max_count;

	mov	edi, 4

; 1930 :                                           (sizeof(sb->SOBuffers) / sizeof(sb->SOBuffers[0])) * 1, 
; 1931 :                                           (sizeof(sb->SOBuffers) / sizeof(sb->SOBuffers[0])) * 2, 
; 1932 :                                           (sizeof(sb->SOBuffers) / sizeof(sb->SOBuffers[0])) * 3 };*/
; 1933 :   
; 1934 :     UINT SOBufferCount =
; 1935 :       calc_count (sb->SOBuffers, 4);
; 1936 :   
; 1937 :     if (SOBufferCount)

	jmp	SHORT $LN620@ApplyState
$LN388@ApplyState:
	test	edi, edi
	je	SHORT $LN622@ApplyState
$LN620@ApplyState:

; 1938 :     {
; 1939 :       dc->SOSetTargets (SOBufferCount, sb->SOBuffers, SOBuffersOffsets);

	mov	ecx, DWORD PTR _dc$[ebp]
	lea	edx, DWORD PTR [esi+11100]
	lea	esi, DWORD PTR _SOBuffersOffsets$2[ebp]
	mov	DWORD PTR tv5977[ebp], edx
	push	esi
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	edi
	push	ecx
	call	DWORD PTR [eax+148]

; 1940 :   
; 1941 :       for (UINT i = 0; i < SOBufferCount; i++)

	mov	esi, DWORD PTR _sb$[ebp]
	test	edi, edi
	je	SHORT $LN622@ApplyState
	lea	eax, DWORD PTR [esi+11100]
$LL85@ApplyState:

; 1942 :       {
; 1943 :         if (sb->SOBuffers [i] != nullptr)

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN83@ApplyState

; 1944 :         sb->SOBuffers [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR tv5977[ebp]
$LN83@ApplyState:

; 1940 :   
; 1941 :       for (UINT i = 0; i < SOBufferCount; i++)

	add	eax, 4
	mov	DWORD PTR tv5977[ebp], eax
	sub	edi, 1
	jne	SHORT $LL85@ApplyState
$LN622@ApplyState:
	mov	edi, DWORD PTR _dc$[ebp]
$LN84@ApplyState:

; 1945 :       }
; 1946 :     }
; 1947 :   }
; 1948 : 
; 1949 :   dc->SetPredication (sb->Predication, sb->PredicationValue);

	push	DWORD PTR [esi+11120]
	mov	eax, DWORD PTR [edi]
	push	DWORD PTR [esi+11116]
	push	edi
	call	DWORD PTR [eax+120]

; 1950 : 
; 1951 :   if (sb->Predication != nullptr)

	mov	ecx, DWORD PTR [esi+11116]
	pop	edi
	pop	esi
	test	ecx, ecx
	je	SHORT $LN151@ApplyState

; 1952 :     sb->Predication->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN151@ApplyState:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	mov	eax, DWORD PTR _pDev$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1953 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN317@ApplyState

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN317@ApplyState:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1953 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ApplyStateblock@@YAXPAUID3D11DeviceContext@@PAUD3DX11_STATE_BLOCK@@@Z$0:
	lea	ecx, DWORD PTR _pDev$[ebp]
	jmp	??1?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ
__ehhandler$?ApplyStateblock@@YAXPAUID3D11DeviceContext@@PAUD3DX11_STATE_BLOCK@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ApplyStateblock@@YAXPAUID3D11DeviceContext@@PAUD3DX11_STATE_BLOCK@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ApplyStateblock@@YAXPAUID3D11DeviceContext@@PAUD3DX11_STATE_BLOCK@@@Z ENDP ; ApplyStateblock
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_pDev$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_dc$ = 8						; size = 4
_sb$ = 12						; size = 4
?CreateStateblock@@YAXPAUID3D11DeviceContext@@PAUD3DX11_STATE_BLOCK@@@Z PROC ; CreateStateblock

; 1445 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CreateStateblock@@YAXPAUID3D11DeviceContext@@PAUD3DX11_STATE_BLOCK@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pDev$[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1447 :                    dc->GetDevice (&pDev);

	mov	esi, DWORD PTR _dc$[ebp]
	lea	ecx, DWORD PTR _pDev$[ebp]
	push	ecx
	push	esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+12]

; 1448 :   const D3D_FEATURE_LEVEL ft_lvl = pDev->GetFeatureLevel ();

	mov	eax, DWORD PTR _pDev$[ebp]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+148]

; 1449 : 
; 1450 :   ZeroMemory (sb, sizeof D3DX11_STATE_BLOCK);

	mov	edi, DWORD PTR _sb$[ebp]
	mov	ebx, eax
	push	11124					; 00002b74H
	push	0
	push	edi
	call	_memset

; 1451 : 
; 1452 :   dc->VSGetShader          (&sb->VS, sb->VSInterfaces, &sb->VSInterfaceCount);

	mov	edx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [edi+1648]
	add	esp, 12					; 0000000cH
	lea	eax, DWORD PTR [edi+636]
	push	ecx
	push	eax
	push	edi
	push	esi
	call	DWORD PTR [edx+304]

; 1453 :   
; 1454 :   dc->VSGetSamplers        (0, D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT,             sb->VSSamplers);

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+4]
	push	eax
	push	16					; 00000010H
	push	0
	push	esi
	call	DWORD PTR [ecx+340]

; 1455 :   dc->VSGetShaderResources (0, D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT,      sb->VSShaderResources);

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+68]
	push	eax
	push	128					; 00000080H
	push	0
	push	esi
	call	DWORD PTR [ecx+336]

; 1456 :   dc->VSGetConstantBuffers (0, D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT, sb->VSConstantBuffers);

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+580]
	push	eax
	push	14					; 0000000eH
	push	0
	push	esi
	call	DWORD PTR [ecx+288]

; 1457 :   
; 1458 :   if (ft_lvl >= D3D_FEATURE_LEVEL_10_0)

	cmp	ebx, 40960				; 0000a000H
	jl	SHORT $LN2@CreateStat

; 1459 :   {
; 1460 :     dc->GSGetShader          (&sb->GS, sb->GSInterfaces, &sb->GSInterfaceCount);

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+3300]
	push	eax
	lea	eax, DWORD PTR [edi+2288]
	push	eax
	lea	eax, DWORD PTR [edi+1652]
	push	eax
	push	esi
	call	DWORD PTR [ecx+328]

; 1461 :     
; 1462 :     dc->GSGetSamplers        (0, D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT,             sb->GSSamplers);

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+1656]
	push	eax
	push	16					; 00000010H
	push	0
	push	esi
	call	DWORD PTR [ecx+352]

; 1463 :     dc->GSGetShaderResources (0, D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT,      sb->GSShaderResources);

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+1720]
	push	eax
	push	128					; 00000080H
	push	0
	push	esi
	call	DWORD PTR [ecx+348]

; 1464 :     dc->GSGetConstantBuffers (0, D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT, sb->GSConstantBuffers);

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+2232]
	push	eax
	push	14					; 0000000eH
	push	0
	push	esi
	call	DWORD PTR [ecx+324]
$LN2@CreateStat:

; 1465 :   }
; 1466 :   
; 1467 :   if (ft_lvl >= D3D_FEATURE_LEVEL_11_0)

	cmp	ebx, 45056				; 0000b000H
	jl	$LN3@CreateStat

; 1468 :   {
; 1469 :     dc->HSGetShader          (&sb->HS, sb->HSInterfaces, &sb->HSInterfaceCount);

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+4952]
	push	eax
	lea	eax, DWORD PTR [edi+3940]
	push	eax
	lea	eax, DWORD PTR [edi+3304]
	push	eax
	push	esi
	call	DWORD PTR [ecx+392]

; 1470 :     
; 1471 :     dc->HSGetSamplers        (0, D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT,             sb->HSSamplers);

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+3308]
	push	eax
	push	16					; 00000010H
	push	0
	push	esi
	call	DWORD PTR [ecx+396]

; 1472 :     dc->HSGetShaderResources (0, D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT,      sb->HSShaderResources);

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+3372]
	push	eax
	push	128					; 00000080H
	push	0
	push	esi
	call	DWORD PTR [ecx+388]

; 1473 :     dc->HSGetConstantBuffers (0, D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT, sb->HSConstantBuffers);

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+3884]
	push	eax
	push	14					; 0000000eH
	push	0
	push	esi
	call	DWORD PTR [ecx+400]

; 1474 :     
; 1475 :     dc->DSGetShader          (&sb->DS, sb->DSInterfaces, &sb->DSInterfaceCount);

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+6604]
	push	eax
	lea	eax, DWORD PTR [edi+5592]
	push	eax
	lea	eax, DWORD PTR [edi+4956]
	push	eax
	push	esi
	call	DWORD PTR [ecx+408]

; 1476 :     dc->DSGetSamplers        (0, D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT,             sb->DSSamplers);

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+4960]
	push	eax
	push	16					; 00000010H
	push	0
	push	esi
	call	DWORD PTR [ecx+412]

; 1477 :     dc->DSGetShaderResources (0, D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT,      sb->DSShaderResources);

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+5024]
	push	eax
	push	128					; 00000080H
	push	0
	push	esi
	call	DWORD PTR [ecx+404]

; 1478 :     dc->DSGetConstantBuffers (0, D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT, sb->DSConstantBuffers);

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+5536]
	push	eax
	push	14					; 0000000eH
	push	0
	push	esi
	call	DWORD PTR [ecx+416]
$LN3@CreateStat:

; 1479 :   }
; 1480 :   
; 1481 :   dc->PSGetShader          (&sb->PS, sb->PSInterfaces, &sb->PSInterfaceCount);

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+8256]
	push	eax
	lea	eax, DWORD PTR [edi+7244]
	push	eax
	lea	eax, DWORD PTR [edi+6608]
	push	eax
	push	esi
	call	DWORD PTR [ecx+296]

; 1482 :   
; 1483 :   dc->PSGetSamplers        (0, D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT,             sb->PSSamplers);

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+6612]
	push	eax
	push	16					; 00000010H
	push	0
	push	esi
	call	DWORD PTR [ecx+300]

; 1484 :   dc->PSGetShaderResources (0, D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT,      sb->PSShaderResources);

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+6676]
	push	eax
	push	128					; 00000080H
	push	0
	push	esi
	call	DWORD PTR [ecx+292]

; 1485 :   dc->PSGetConstantBuffers (0, D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT, sb->PSConstantBuffers);

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+7188]
	push	eax
	push	14					; 0000000eH
	push	0
	push	esi
	call	DWORD PTR [ecx+308]

; 1486 :   
; 1487 :   if (ft_lvl >= D3D_FEATURE_LEVEL_11_0)

	cmp	ebx, 45056				; 0000b000H
	jl	SHORT $LN4@CreateStat

; 1488 :   {
; 1489 :     dc->CSGetShader          (&sb->CS, sb->CSInterfaces, &sb->CSInterfaceCount);

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+9908]
	push	eax
	lea	eax, DWORD PTR [edi+8896]
	push	eax
	lea	eax, DWORD PTR [edi+8260]
	push	eax
	push	esi
	call	DWORD PTR [ecx+428]

; 1490 :     
; 1491 :     dc->CSGetSamplers             (0, D3D11_COMMONSHADER_SAMPLER_SLOT_COUNT,             sb->CSSamplers);

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+8264]
	push	eax
	push	16					; 00000010H
	push	0
	push	esi
	call	DWORD PTR [ecx+432]

; 1492 :     dc->CSGetShaderResources      (0, D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT,      sb->CSShaderResources);

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+8328]
	push	eax
	push	128					; 00000080H
	push	0
	push	esi
	call	DWORD PTR [ecx+420]

; 1493 :     dc->CSGetConstantBuffers      (0, D3D11_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT, sb->CSConstantBuffers);

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+8840]
	push	eax
	push	14					; 0000000eH
	push	0
	push	esi
	call	DWORD PTR [ecx+436]

; 1494 :     dc->CSGetUnorderedAccessViews (0, D3D11_PS_CS_UAV_REGISTER_COUNT,                    sb->CSUnorderedAccessViews);

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+9912]
	push	eax
	push	8
	push	0
	push	esi
	call	DWORD PTR [ecx+424]
$LN4@CreateStat:

; 1495 :   }
; 1496 :   
; 1497 :   dc->IAGetVertexBuffers     (0, D3D11_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT, sb->IAVertexBuffers,

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+10200]
	push	eax
	lea	eax, DWORD PTR [edi+10072]
	push	eax
	lea	eax, DWORD PTR [edi+9944]
	push	eax
	push	32					; 00000020H
	push	0
	push	esi
	call	DWORD PTR [ecx+316]

; 1498 :                                                                             sb->IAVertexBuffersStrides,
; 1499 :                                                                             sb->IAVertexBuffersOffsets);
; 1500 :   dc->IAGetIndexBuffer       (&sb->IAIndexBuffer, &sb->IAIndexBufferFormat, &sb->IAIndexBufferOffset);

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+10336]
	push	eax
	lea	eax, DWORD PTR [edi+10332]
	push	eax
	lea	eax, DWORD PTR [edi+10328]
	push	eax
	push	esi
	call	DWORD PTR [ecx+320]

; 1501 :   dc->IAGetInputLayout       (&sb->IAInputLayout);

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+10340]
	push	eax
	push	esi
	call	DWORD PTR [ecx+312]

; 1502 :   dc->IAGetPrimitiveTopology (&sb->IAPrimitiveTopology);

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+10344]
	push	eax
	push	esi
	call	DWORD PTR [ecx+332]

; 1503 : 
; 1504 : 
; 1505 :   dc->OMGetBlendState        (&sb->OMBlendState,         sb->OMBlendFactor, &sb->OMSampleMask);

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+10444]
	push	eax
	lea	eax, DWORD PTR [edi+10428]
	push	eax
	lea	eax, DWORD PTR [edi+10424]
	push	eax
	push	esi
	call	DWORD PTR [ecx+364]

; 1506 :   dc->OMGetDepthStencilState (&sb->OMDepthStencilState, &sb->OMDepthStencilRef);

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+10420]
	push	eax
	lea	eax, DWORD PTR [edi+10416]
	push	eax
	push	esi
	call	DWORD PTR [ecx+368]

; 1507 : 
; 1508 :   dc->OMGetRenderTargets ( D3D11_SIMULTANEOUS_RENDER_TARGET_COUNT, sb->OMRenderTargets, &sb->OMRenderTargetStencilView );

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+10380]
	push	eax
	lea	eax, DWORD PTR [edi+10348]
	push	eax
	push	8
	push	esi
	call	DWORD PTR [ecx+356]

; 1509 : 
; 1510 :   sb->RSViewportCount    = D3D11_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE;

	lea	ecx, DWORD PTR [edi+10448]

; 1511 : 
; 1512 :   dc->RSGetViewports         (&sb->RSViewportCount, sb->RSViewports);

	lea	eax, DWORD PTR [edi+10452]
	mov	DWORD PTR [ecx], 16			; 00000010H
	mov	edx, DWORD PTR [esi]
	push	eax
	push	ecx
	push	esi
	call	DWORD PTR [edx+380]

; 1513 : 
; 1514 :   sb->RSScissorRectCount = D3D11_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE;

	lea	ecx, DWORD PTR [edi+10836]

; 1515 : 
; 1516 :   dc->RSGetScissorRects      (&sb->RSScissorRectCount, sb->RSScissorRects);

	lea	eax, DWORD PTR [edi+10840]
	mov	DWORD PTR [ecx], 16			; 00000010H
	mov	edx, DWORD PTR [esi]
	push	eax
	push	ecx
	push	esi
	call	DWORD PTR [edx+384]

; 1517 :   dc->RSGetState             (&sb->RSRasterizerState);

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+11096]
	push	eax
	push	esi
	call	DWORD PTR [ecx+376]

; 1518 : 
; 1519 :   if (ft_lvl >= D3D_FEATURE_LEVEL_10_0)

	cmp	ebx, 40960				; 0000a000H
	jl	SHORT $LN5@CreateStat

; 1520 :   {
; 1521 :     dc->SOGetTargets           (4, sb->SOBuffers);

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+11100]
	push	eax
	push	4
	push	esi
	call	DWORD PTR [ecx+372]
$LN5@CreateStat:

; 1522 :   }
; 1523 : 
; 1524 :   dc->GetPredication         (&sb->Predication, &sb->PredicationValue);

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edi+11120]
	push	eax
	lea	eax, DWORD PTR [edi+11116]
	push	eax
	push	esi
	call	DWORD PTR [ecx+344]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	mov	eax, DWORD PTR _pDev$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1525 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN21@CreateStat

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN21@CreateStat:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1525 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?CreateStateblock@@YAXPAUID3D11DeviceContext@@PAUD3DX11_STATE_BLOCK@@@Z$0:
	lea	ecx, DWORD PTR _pDev$[ebp]
	jmp	??1?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ
__ehhandler$?CreateStateblock@@YAXPAUID3D11DeviceContext@@PAUD3DX11_STATE_BLOCK@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CreateStateblock@@YAXPAUID3D11DeviceContext@@PAUD3DX11_STATE_BLOCK@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CreateStateblock@@YAXPAUID3D11DeviceContext@@PAUD3DX11_STATE_BLOCK@@@Z ENDP ; CreateStateblock
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_arr$ = 8						; size = 4
_max_count$ = 12					; size = 4
??$calc_count@UID3D11ClassInstance@@@@YAIPAPAUID3D11ClassInstance@@I@Z PROC ; calc_count<ID3D11ClassInstance>

; 1238 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1239 :   for ( int i = static_cast <int> (max_count) - 1 ;

	mov	edx, DWORD PTR _max_count$[ebp]
	lea	eax, DWORD PTR [edx-1]

; 1240 :             i >= 0 ;

	test	eax, eax
	js	SHORT $LN3@calc_count
	mov	ecx, DWORD PTR _arr$[ebp]
$LL4@calc_count:

; 1242 :   {
; 1243 :     if (arr [i] != 0)

	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $LN1@calc_count

; 1241 :           --i )

	sub	eax, 1

; 1240 :             i >= 0 ;

	jns	SHORT $LL4@calc_count
$LN3@calc_count:

; 1244 :       return i;
; 1245 :   }
; 1246 : 
; 1247 :   return max_count;

	mov	eax, edx
$LN1@calc_count:

; 1248 : }

	pop	ebp
	ret	0
??$calc_count@UID3D11ClassInstance@@@@YAIPAPAUID3D11ClassInstance@@I@Z ENDP ; calc_count<ID3D11ClassInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
;	COMDAT ?apply@SK_D3D11_Stateblock_Lite@@QAEXPAUID3D11DeviceContext@@@Z
_TEXT	SEGMENT
_i$1$ = 8						; size = 4
_pCtx$ = 8						; size = 4
?apply@SK_D3D11_Stateblock_Lite@@QAEXPAUID3D11DeviceContext@@@Z PROC ; SK_D3D11_Stateblock_Lite::apply, COMDAT
; _this$ = ecx

; 1318 :   {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 1319 :     pCtx->RSSetScissorRects      (ScissorRectsCount, ScissorRects);

	mov	edi, DWORD PTR _pCtx$[ebp]
	lea	eax, DWORD PTR [esi+8]
	push	eax
	push	DWORD PTR [esi]
	mov	ecx, DWORD PTR [edi]
	push	edi
	call	DWORD PTR [ecx+180]

; 1320 :     pCtx->RSSetViewports         (ViewportsCount,    Viewports);

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [esi+264]
	push	eax
	push	DWORD PTR [esi+4]
	push	edi
	call	DWORD PTR [ecx+176]

; 1321 :     pCtx->OMSetDepthStencilState (DepthStencilState, StencilRef);

	push	DWORD PTR [esi+676]
	mov	eax, DWORD PTR [edi]
	push	DWORD PTR [esi+680]
	push	edi
	call	DWORD PTR [eax+144]

; 1322 :     pCtx->RSSetState             (RS);

	push	DWORD PTR [esi+648]
	mov	eax, DWORD PTR [edi]
	push	edi
	call	DWORD PTR [eax+172]

; 1323 :     pCtx->PSSetShader            (PS, PSInstances,   PSInstancesCount);

	push	DWORD PTR [esi+700]
	mov	eax, DWORD PTR [edi]
	lea	ebx, DWORD PTR [esi+708]
	push	ebx
	push	DWORD PTR [esi+692]
	push	edi
	call	DWORD PTR [eax+36]

; 1324 :     pCtx->VSSetShader            (VS, VSInstances,   VSInstancesCount);

	push	DWORD PTR [esi+704]
	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR [esi+1720]
	push	ecx
	push	DWORD PTR [esi+696]
	push	edi
	call	DWORD PTR [eax+44]

; 1325 :     pCtx->IASetPrimitiveTopology (PrimitiveTopology);

	push	DWORD PTR [esi+2732]
	mov	eax, DWORD PTR [edi]
	push	edi
	call	DWORD PTR [eax+96]

; 1326 :     pCtx->OMSetBlendState        (BlendState,        BlendFactor,

	push	DWORD PTR [esi+672]
	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [esi+656]
	push	eax
	push	DWORD PTR [esi+652]
	push	edi
	call	DWORD PTR [ecx+140]

; 1327 :                                                      SampleMask);
; 1328 :     pCtx->IASetIndexBuffer       (IndexBuffer,       IndexBufferFormat,

	push	DWORD PTR [esi+2748]
	mov	eax, DWORD PTR [edi]
	push	DWORD PTR [esi+2760]
	push	DWORD PTR [esi+2736]
	push	edi
	call	DWORD PTR [eax+76]

; 1329 :                                                      IndexBufferOffset);
; 1330 :     pCtx->IASetInputLayout       (InputLayout);

	push	DWORD PTR [esi+2764]
	mov	eax, DWORD PTR [edi]
	push	edi
	call	DWORD PTR [eax+68]

; 1331 :     pCtx->PSSetShaderResources   (0, 1, &PSShaderResource);

	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR [esi+684]
	push	ecx
	push	1
	push	0
	push	edi
	call	DWORD PTR [eax+32]

; 1332 :     pCtx->VSSetConstantBuffers   (0, 1, &VSConstantBuffer);

	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR [esi+2744]
	push	ecx
	push	1
	push	0
	push	edi
	call	DWORD PTR [eax+28]

; 1333 :     pCtx->PSSetSamplers          (0, 1, &PSSampler);

	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR [esi+688]
	push	ecx
	push	1
	push	0
	push	edi
	call	DWORD PTR [eax+40]

; 1334 :     pCtx->IASetVertexBuffers     (0, 1, &VertexBuffer,    &VertexBufferStride,

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [esi+2756]
	push	eax
	lea	eax, DWORD PTR [esi+2752]
	push	eax
	lea	edx, DWORD PTR [esi+2740]
	push	edx
	push	1
	push	0
	push	edi
	call	DWORD PTR [ecx+72]

; 1335 :                                                           &VertexBufferOffset);
; 1336 :     pCtx->OMSetRenderTargets     (1,    &RenderTargetView, DepthStencilView);

	push	DWORD PTR [esi+2768]
	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR [esi+2772]
	push	ecx
	push	1
	push	edi
	call	DWORD PTR [eax+132]

; 1337 : 
; 1338 :     //
; 1339 :     // Now balance the reference counts that D3D added even though we did not want them :P
; 1340 :     //
; 1341 :     for (UINT i = 0; i < VSInstancesCount; i++)

	xor	eax, eax
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	DWORD PTR [esi+704], eax
	jbe	SHORT $LN3@apply
	lea	edi, DWORD PTR [esi+1720]
	npad	2
$LL4@apply:

; 1342 :     {
; 1343 :       if (VSInstances [i])

	mov	ecx, DWORD PTR [edi]
	test	ecx, ecx
	je	SHORT $LN2@apply

; 1344 :           VSInstances [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _i$1$[ebp]
$LN2@apply:

; 1337 : 
; 1338 :     //
; 1339 :     // Now balance the reference counts that D3D added even though we did not want them :P
; 1340 :     //
; 1341 :     for (UINT i = 0; i < VSInstancesCount; i++)

	inc	eax
	add	edi, 4
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	eax, DWORD PTR [esi+704]
	jb	SHORT $LL4@apply
$LN3@apply:

; 1345 :     }
; 1346 : 
; 1347 :     if (RS)                RS->Release                ();

	mov	ecx, DWORD PTR [esi+648]
	test	ecx, ecx
	je	SHORT $LN9@apply
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN9@apply:

; 1348 :     if (PS)                PS->Release                ();

	mov	ecx, DWORD PTR [esi+692]
	test	ecx, ecx
	je	SHORT $LN10@apply
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN10@apply:

; 1349 :     if (VS)                VS->Release                ();

	mov	ecx, DWORD PTR [esi+696]
	test	ecx, ecx
	je	SHORT $LN11@apply
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN11@apply:

; 1350 :     if (PSSampler)         PSSampler->Release         ();

	mov	ecx, DWORD PTR [esi+688]
	test	ecx, ecx
	je	SHORT $LN12@apply
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN12@apply:

; 1351 :     if (BlendState)        BlendState->Release        ();

	mov	ecx, DWORD PTR [esi+652]
	test	ecx, ecx
	je	SHORT $LN13@apply
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN13@apply:

; 1352 :     if (InputLayout)       InputLayout->Release       ();

	mov	ecx, DWORD PTR [esi+2764]
	test	ecx, ecx
	je	SHORT $LN14@apply
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN14@apply:

; 1353 :     if (IndexBuffer)       IndexBuffer->Release       ();

	mov	ecx, DWORD PTR [esi+2736]
	test	ecx, ecx
	je	SHORT $LN15@apply
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN15@apply:

; 1354 :     if (VertexBuffer)      VertexBuffer->Release      ();

	mov	ecx, DWORD PTR [esi+2740]
	test	ecx, ecx
	je	SHORT $LN16@apply
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN16@apply:

; 1355 :     if (PSShaderResource)  PSShaderResource->Release  ();

	mov	ecx, DWORD PTR [esi+684]
	test	ecx, ecx
	je	SHORT $LN17@apply
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN17@apply:

; 1356 :     if (VSConstantBuffer)  VSConstantBuffer->Release  ();

	mov	ecx, DWORD PTR [esi+2744]
	test	ecx, ecx
	je	SHORT $LN18@apply
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN18@apply:

; 1357 :     if (RenderTargetView)  RenderTargetView->Release  ();

	mov	ecx, DWORD PTR [esi+2772]
	test	ecx, ecx
	je	SHORT $LN19@apply
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN19@apply:

; 1358 :     if (DepthStencilView)  DepthStencilView->Release  ();

	mov	ecx, DWORD PTR [esi+2768]
	test	ecx, ecx
	je	SHORT $LN20@apply
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN20@apply:

; 1359 :     if (DepthStencilState) DepthStencilState->Release ();

	mov	ecx, DWORD PTR [esi+680]
	test	ecx, ecx
	je	SHORT $LN21@apply
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN21@apply:

; 1360 : 
; 1361 :     for (UINT i = 0; i < PSInstancesCount; i++)

	xor	edi, edi
	cmp	DWORD PTR [esi+700], edi
	jbe	SHORT $LN6@apply
$LL7@apply:

; 1362 :     {
; 1363 :       if (PSInstances [i])

	mov	ecx, DWORD PTR [ebx]
	test	ecx, ecx
	je	SHORT $LN5@apply

; 1364 :           PSInstances [i]->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN5@apply:

; 1360 : 
; 1361 :     for (UINT i = 0; i < PSInstancesCount; i++)

	inc	edi
	add	ebx, 4
	cmp	edi, DWORD PTR [esi+700]
	jb	SHORT $LL7@apply
$LN6@apply:
	pop	edi
	pop	esi
	pop	ebx

; 1365 :     }
; 1366 :   }

	pop	ebp
	ret	4
?apply@SK_D3D11_Stateblock_Lite@@QAEXPAUID3D11DeviceContext@@@Z ENDP ; SK_D3D11_Stateblock_Lite::apply
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
;	COMDAT ?capture@SK_D3D11_Stateblock_Lite@@QAEXPAUID3D11DeviceContext@@@Z
_TEXT	SEGMENT
_pCtx$ = 8						; size = 4
?capture@SK_D3D11_Stateblock_Lite@@QAEXPAUID3D11DeviceContext@@@Z PROC ; SK_D3D11_Stateblock_Lite::capture, COMDAT
; _this$ = ecx

; 1286 :   {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 1288 :       D3D11_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE;
; 1289 : 
; 1290 :     pCtx->RSGetScissorRects      (      &ScissorRectsCount, ScissorRects);

	mov	edi, DWORD PTR _pCtx$[ebp]
	lea	esi, DWORD PTR [ebx+4]
	mov	DWORD PTR [esi], 16			; 00000010H
	lea	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebx], 16			; 00000010H
	push	eax
	mov	edx, DWORD PTR [edi]
	push	ebx
	push	edi
	call	DWORD PTR [edx+384]

; 1291 :     pCtx->RSGetViewports         (      &ViewportsCount,    Viewports);

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ebx+264]
	push	eax
	push	esi
	push	edi
	call	DWORD PTR [ecx+380]

; 1292 :     pCtx->RSGetState             (      &RS);

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ebx+648]
	push	eax
	push	edi
	call	DWORD PTR [ecx+376]

; 1293 :     pCtx->OMGetBlendState        (      &BlendState,         BlendFactor,

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ebx+672]
	push	eax
	lea	eax, DWORD PTR [ebx+656]
	push	eax
	lea	eax, DWORD PTR [ebx+652]
	push	eax
	push	edi
	call	DWORD PTR [ecx+364]

; 1294 :                                                             &SampleMask);
; 1295 :     pCtx->OMGetDepthStencilState (      &DepthStencilState, &StencilRef);

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ebx+676]
	push	eax
	lea	eax, DWORD PTR [ebx+680]
	push	eax
	push	edi
	call	DWORD PTR [ecx+368]

; 1296 :     pCtx->PSGetShaderResources   (0, 1, &PSShaderResource);

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ebx+684]
	push	eax
	push	1
	push	0
	push	edi
	call	DWORD PTR [ecx+292]

; 1297 :     pCtx->PSGetSamplers          (0, 1, &PSSampler);

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ebx+688]
	push	eax
	push	1
	push	0
	push	edi
	call	DWORD PTR [ecx+300]

; 1298 : 
; 1299 :     PSInstancesCount = VSInstancesCount =

	lea	eax, DWORD PTR [ebx+700]
	mov	DWORD PTR [ebx+704], 253		; 000000fdH
	mov	DWORD PTR [eax], 253			; 000000fdH
	lea	esi, DWORD PTR [ebx+704]

; 1300 :       D3D11_SHADER_MAX_INTERFACES;
; 1301 : 
; 1302 :     pCtx->PSGetShader            (&PS, PSInstances, &PSInstancesCount);

	mov	ecx, DWORD PTR [edi]
	push	eax
	lea	eax, DWORD PTR [ebx+708]
	push	eax
	lea	eax, DWORD PTR [ebx+692]
	push	eax
	push	edi
	call	DWORD PTR [ecx+296]

; 1303 :     pCtx->VSGetShader            (&VS, VSInstances, &VSInstancesCount);

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ebx+1720]
	push	esi
	push	eax
	lea	eax, DWORD PTR [ebx+696]
	push	eax
	push	edi
	call	DWORD PTR [ecx+304]

; 1304 :     pCtx->VSGetConstantBuffers   (0, 1, &VSConstantBuffer);

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ebx+2744]
	push	eax
	push	1
	push	0
	push	edi
	call	DWORD PTR [ecx+288]

; 1305 :     pCtx->IAGetPrimitiveTopology (      &PrimitiveTopology);

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ebx+2732]
	push	eax
	push	edi
	call	DWORD PTR [ecx+332]

; 1306 :     pCtx->IAGetIndexBuffer       (      &IndexBuffer,  &IndexBufferFormat,

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ebx+2748]
	push	eax
	lea	eax, DWORD PTR [ebx+2760]
	push	eax
	lea	eax, DWORD PTR [ebx+2736]
	push	eax
	push	edi
	call	DWORD PTR [ecx+320]

; 1307 :                                                        &IndexBufferOffset);
; 1308 :     pCtx->IAGetVertexBuffers     (0, 1, &VertexBuffer, &VertexBufferStride,

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ebx+2756]
	push	eax
	lea	eax, DWORD PTR [ebx+2752]
	push	eax
	lea	eax, DWORD PTR [ebx+2740]
	push	eax
	push	1
	push	0
	push	edi
	call	DWORD PTR [ecx+316]

; 1309 :                                                        &VertexBufferOffset);
; 1310 :     pCtx->IAGetInputLayout       (      &InputLayout );

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ebx+2764]
	push	eax
	push	edi
	call	DWORD PTR [ecx+312]

; 1311 :     pCtx->OMGetRenderTargets     (1, &RenderTargetView, &DepthStencilView);

	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ebx+2768]
	push	eax
	lea	eax, DWORD PTR [ebx+2772]
	push	eax
	push	1
	push	edi
	call	DWORD PTR [ecx+356]

; 1312 : 
; 1313 :     PSInstancesCount = calc_count (PSInstances, PSInstancesCount);

	mov	edx, DWORD PTR [ebx+700]

; 1239 :   for ( int i = static_cast <int> (max_count) - 1 ;

	lea	eax, DWORD PTR [edx-1]

; 1240 :             i >= 0 ;

	test	eax, eax
	js	SHORT $LN5@capture

; 1287 :     ScissorRectsCount = ViewportsCount =

	lea	ecx, DWORD PTR [ebx+708]
	lea	ecx, DWORD PTR [ecx+eax*4]
$LL6@capture:

; 1243 :     if (arr [i] != 0)

	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN3@capture

; 1241 :           --i )

	sub	ecx, 4
	sub	eax, 1
	jns	SHORT $LL6@capture
$LN5@capture:

; 1244 :       return i;
; 1245 :   }
; 1246 : 
; 1247 :   return max_count;

	mov	eax, edx
$LN3@capture:

; 1314 :     VSInstancesCount = calc_count (VSInstances, VSInstancesCount);

	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [ebx+700], eax

; 1239 :   for ( int i = static_cast <int> (max_count) - 1 ;

	lea	eax, DWORD PTR [edx-1]

; 1240 :             i >= 0 ;

	test	eax, eax
	js	SHORT $LN11@capture

; 1312 : 
; 1313 :     PSInstancesCount = calc_count (PSInstances, PSInstancesCount);

	lea	ecx, DWORD PTR [ebx+1720]
	lea	ecx, DWORD PTR [ecx+eax*4]
	npad	2
$LL12@capture:

; 1243 :     if (arr [i] != 0)

	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN18@capture

; 1241 :           --i )

	sub	ecx, 4
	sub	eax, 1
	jns	SHORT $LL12@capture
$LN11@capture:
	pop	edi

; 1314 :     VSInstancesCount = calc_count (VSInstances, VSInstancesCount);

	mov	DWORD PTR [esi], edx
	pop	esi
	pop	ebx

; 1315 :   }

	pop	ebp
	ret	4
$LN18@capture:
	pop	edi

; 1314 :     VSInstancesCount = calc_count (VSInstances, VSInstancesCount);

	mov	DWORD PTR [esi], eax
	pop	esi
	pop	ebx

; 1315 :   }

	pop	ebp
	ret	4
?capture@SK_D3D11_Stateblock_Lite@@QAEXPAUID3D11DeviceContext@@@Z ENDP ; SK_D3D11_Stateblock_Lite::capture
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
?SK_CEGUI_QueueResetD3D11@@YAXXZ PROC			; SK_CEGUI_QueueResetD3D11
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h

; 8903 :     return (unsigned long) _InterlockedExchange((volatile long*) Target, (long) Value);

	mov	eax, 1
	mov	ecx, OFFSET ?__gui_reset@@3KC
	xchg	DWORD PTR [ecx], eax
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1208 : }

	ret	0
?SK_CEGUI_QueueResetD3D11@@YAXXZ ENDP			; SK_CEGUI_QueueResetD3D11
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
;	COMDAT ??$QueryInterface@UIDXGIFactory@@@IUnknown@@QAGJPAPAUIDXGIFactory@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pp$ = 12						; size = 4
??$QueryInterface@UIDXGIFactory@@@IUnknown@@QAGJPAPAUIDXGIFactory@@@Z PROC ; IUnknown::QueryInterface<IDXGIFactory>, COMDAT

; 130  :             {

	npad	2
	push	ebp
	mov	ebp, esp

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	mov	eax, DWORD PTR _this$[ebp]
	push	DWORD PTR _pp$[ebp]
	push	OFFSET __GUID_7b7166ec_21c7_44ae_b21a_c9ae321ae369
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx]

; 132  :             }

	pop	ebp
	ret	8
??$QueryInterface@UIDXGIFactory@@@IUnknown@@QAGJPAPAUIDXGIFactory@@@Z ENDP ; IUnknown::QueryInterface<IDXGIFactory>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
;	COMDAT ??$QueryInterface@UIDXGIFactory1@@@IUnknown@@QAGJPAPAUIDXGIFactory1@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pp$ = 12						; size = 4
??$QueryInterface@UIDXGIFactory1@@@IUnknown@@QAGJPAPAUIDXGIFactory1@@@Z PROC ; IUnknown::QueryInterface<IDXGIFactory1>, COMDAT

; 130  :             {

	npad	2
	push	ebp
	mov	ebp, esp

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	mov	eax, DWORD PTR _this$[ebp]
	push	DWORD PTR _pp$[ebp]
	push	OFFSET __GUID_770aae78_f26f_4dba_a829_253c83d1b387
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx]

; 132  :             }

	pop	ebp
	ret	8
??$QueryInterface@UIDXGIFactory1@@@IUnknown@@QAGJPAPAUIDXGIFactory1@@@Z ENDP ; IUnknown::QueryInterface<IDXGIFactory1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
;	COMDAT ??$QueryInterface@UIDXGIFactory2@@@IUnknown@@QAGJPAPAUIDXGIFactory2@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pp$ = 12						; size = 4
??$QueryInterface@UIDXGIFactory2@@@IUnknown@@QAGJPAPAUIDXGIFactory2@@@Z PROC ; IUnknown::QueryInterface<IDXGIFactory2>, COMDAT

; 130  :             {

	npad	2
	push	ebp
	mov	ebp, esp

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	mov	eax, DWORD PTR _this$[ebp]
	push	DWORD PTR _pp$[ebp]
	push	OFFSET __GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx]

; 132  :             }

	pop	ebp
	ret	8
??$QueryInterface@UIDXGIFactory2@@@IUnknown@@QAGJPAPAUIDXGIFactory2@@@Z ENDP ; IUnknown::QueryInterface<IDXGIFactory2>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
;	COMDAT ??$QueryInterface@UIDXGIFactory3@@@IUnknown@@QAGJPAPAUIDXGIFactory3@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pp$ = 12						; size = 4
??$QueryInterface@UIDXGIFactory3@@@IUnknown@@QAGJPAPAUIDXGIFactory3@@@Z PROC ; IUnknown::QueryInterface<IDXGIFactory3>, COMDAT

; 130  :             {

	npad	2
	push	ebp
	mov	ebp, esp

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	mov	eax, DWORD PTR _this$[ebp]
	push	DWORD PTR _pp$[ebp]
	push	OFFSET __GUID_25483823_cd46_4c7d_86ca_47aa95b837bd
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx]

; 132  :             }

	pop	ebp
	ret	8
??$QueryInterface@UIDXGIFactory3@@@IUnknown@@QAGJPAPAUIDXGIFactory3@@@Z ENDP ; IUnknown::QueryInterface<IDXGIFactory3>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
;	COMDAT ??$QueryInterface@UIDXGIFactory4@@@IUnknown@@QAGJPAPAUIDXGIFactory4@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pp$ = 12						; size = 4
??$QueryInterface@UIDXGIFactory4@@@IUnknown@@QAGJPAPAUIDXGIFactory4@@@Z PROC ; IUnknown::QueryInterface<IDXGIFactory4>, COMDAT

; 130  :             {

	npad	2
	push	ebp
	mov	ebp, esp

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	mov	eax, DWORD PTR _this$[ebp]
	push	DWORD PTR _pp$[ebp]
	push	OFFSET __GUID_1bc6ea02_ef36_464f_bf0c_21ca39e5168a
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx]

; 132  :             }

	pop	ebp
	ret	8
??$QueryInterface@UIDXGIFactory4@@@IUnknown@@QAGJPAPAUIDXGIFactory4@@@Z ENDP ; IUnknown::QueryInterface<IDXGIFactory4>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
;	COMDAT ??$QueryInterface@UIDXGIFactory5@@@IUnknown@@QAGJPAPAUIDXGIFactory5@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pp$ = 12						; size = 4
??$QueryInterface@UIDXGIFactory5@@@IUnknown@@QAGJPAPAUIDXGIFactory5@@@Z PROC ; IUnknown::QueryInterface<IDXGIFactory5>, COMDAT

; 130  :             {

	npad	2
	push	ebp
	mov	ebp, esp

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	mov	eax, DWORD PTR _this$[ebp]
	push	DWORD PTR _pp$[ebp]
	push	OFFSET __GUID_7632e1f5_ee65_4dca_87fd_84cd75f8838d
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx]

; 132  :             }

	pop	ebp
	ret	8
??$QueryInterface@UIDXGIFactory5@@@IUnknown@@QAGJPAPAUIDXGIFactory5@@@Z ENDP ; IUnknown::QueryInterface<IDXGIFactory5>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
?SK_DXGI_BeginHooking@@YAXXZ PROC			; SK_DXGI_BeginHooking
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h

; 9003 :     return (unsigned long) _InterlockedCompareExchange((volatile long*) Destination, (long) Exchange, (long) Comperand);

	mov	ecx, 1
	mov	edx, OFFSET ?hooked@?1??SK_DXGI_BeginHooking@@YAXXZ@4KC
	xor	eax, eax
	lock	 cmpxchg DWORD PTR [edx], ecx
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 879  :   if (! InterlockedCompareExchange (&hooked, TRUE, FALSE))

	test	eax, eax
	jne	SHORT $LN2@SK_DXGI_Be

; 880  :   {
; 881  : #if 0
; 882  :     HANDLE hHookInitDXGI =
; 883  :       (HANDLE)
; 884  :         _beginthreadex ( nullptr,
; 885  :                            0,
; 886  :                              HookDXGI,
; 887  :                                nullptr,
; 888  :                                  0x00,
; 889  :                                    nullptr );
; 890  : #else
; 891  :     HookDXGI (nullptr);

	push	eax
	call	?HookDXGI@@YGIPAX@Z			; HookDXGI
$LN2@SK_DXGI_Be:

; 892  : #endif
; 893  :   }
; 894  : }

	ret	0
?SK_DXGI_BeginHooking@@YAXXZ ENDP			; SK_DXGI_BeginHooking
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_dwProtect$ = 8						; size = 4
?SK_DescribeVirtualProtectFlags@@YAPB_WK@Z PROC		; SK_DescribeVirtualProtectFlags

; 850  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 851  :   switch (dwProtect)

	mov	eax, DWORD PTR _dwProtect$[ebp]
	dec	eax
	cmp	eax, 127				; 0000007fH
	ja	SHORT $LN12@SK_Describ
	movzx	eax, BYTE PTR $LN14@SK_Describ[eax]
	jmp	DWORD PTR $LN16@SK_Describ[eax*4]
$LN4@SK_Describ:

; 852  :   {
; 853  :   case 0x10:
; 854  :     return L"Execute";

	mov	eax, OFFSET $SG352938

; 871  :   }
; 872  : }

	pop	ebp
	ret	0
$LN5@SK_Describ:

; 855  :   case 0x20:
; 856  :     return L"Execute + Read-Only";

	mov	eax, OFFSET $SG352940

; 871  :   }
; 872  : }

	pop	ebp
	ret	0
$LN6@SK_Describ:

; 857  :   case 0x40:
; 858  :     return L"Execute + Read/Write";

	mov	eax, OFFSET $SG352942

; 871  :   }
; 872  : }

	pop	ebp
	ret	0
$LN7@SK_Describ:

; 859  :   case 0x80:
; 860  :     return L"Execute + Read-Only or Copy-on-Write)";

	mov	eax, OFFSET $SG352944

; 871  :   }
; 872  : }

	pop	ebp
	ret	0
$LN8@SK_Describ:

; 861  :   case 0x01:
; 862  :     return L"No Access";

	mov	eax, OFFSET $SG352946

; 871  :   }
; 872  : }

	pop	ebp
	ret	0
$LN9@SK_Describ:

; 863  :   case 0x02:
; 864  :     return L"Read-Only";

	mov	eax, OFFSET $SG352948

; 871  :   }
; 872  : }

	pop	ebp
	ret	0
$LN10@SK_Describ:

; 865  :   case 0x04:
; 866  :     return L"Read/Write";

	mov	eax, OFFSET $SG352950

; 871  :   }
; 872  : }

	pop	ebp
	ret	0
$LN11@SK_Describ:

; 867  :   case 0x08:
; 868  :     return L" Read-Only or Copy-on-Write";

	mov	eax, OFFSET $SG352952

; 871  :   }
; 872  : }

	pop	ebp
	ret	0
$LN12@SK_Describ:

; 869  :   default:
; 870  :     return L"UNKNOWN";

	mov	eax, OFFSET $SG352954

; 871  :   }
; 872  : }

	pop	ebp
	ret	0
	npad	1
$LN16@SK_Describ:
	DD	$LN8@SK_Describ
	DD	$LN9@SK_Describ
	DD	$LN10@SK_Describ
	DD	$LN11@SK_Describ
	DD	$LN4@SK_Describ
	DD	$LN5@SK_Describ
	DD	$LN6@SK_Describ
	DD	$LN7@SK_Describ
	DD	$LN12@SK_Describ
$LN14@SK_Describ:
	DB	0
	DB	1
	DB	8
	DB	2
	DB	8
	DB	8
	DB	8
	DB	3
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	4
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	5
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	6
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	7
?SK_DescribeVirtualProtectFlags@@YAPB_WK@Z ENDP		; SK_DescribeVirtualProtectFlags
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
?SK_DXGI_SupportsTearing@@YAHXZ PROC			; SK_DXGI_SupportsTearing

; 815  :   return dxgi_caps.swapchain.allow_tearing;

	mov	eax, DWORD PTR ?dxgi_caps@@3Udxgi_caps_t@@A+8

; 816  : }

	ret	0
?SK_DXGI_SupportsTearing@@YAHXZ ENDP			; SK_DXGI_SupportsTearing
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0dxgi_caps_t@@QAE@XZ
_TEXT	SEGMENT
??0dxgi_caps_t@@QAE@XZ PROC				; dxgi_caps_t::dxgi_caps_t, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	BYTE PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0dxgi_caps_t@@QAE@XZ ENDP				; dxgi_caps_t::dxgi_caps_t
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0<unnamed-type-swapchain>@dxgi_caps_t@@QAE@XZ
_TEXT	SEGMENT
??0<unnamed-type-swapchain>@dxgi_caps_t@@QAE@XZ PROC	; dxgi_caps_t::<unnamed-type-swapchain>::<unnamed-type-swapchain>, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	ret	0
??0<unnamed-type-swapchain>@dxgi_caps_t@@QAE@XZ ENDP	; dxgi_caps_t::<unnamed-type-swapchain>::<unnamed-type-swapchain>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0<unnamed-type-present>@dxgi_caps_t@@QAE@XZ
_TEXT	SEGMENT
??0<unnamed-type-present>@dxgi_caps_t@@QAE@XZ PROC	; dxgi_caps_t::<unnamed-type-present>::<unnamed-type-present>, COMDAT
; _this$ = ecx
	mov	WORD PTR [ecx], 0
	mov	eax, ecx
	mov	BYTE PTR [ecx+2], 0
	ret	0
??0<unnamed-type-present>@dxgi_caps_t@@QAE@XZ ENDP	; dxgi_caps_t::<unnamed-type-present>::<unnamed-type-present>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0<unnamed-type-device>@dxgi_caps_t@@QAE@XZ
_TEXT	SEGMENT
??0<unnamed-type-device>@dxgi_caps_t@@QAE@XZ PROC	; dxgi_caps_t::<unnamed-type-device>::<unnamed-type-device>, COMDAT
; _this$ = ecx
	mov	WORD PTR [ecx], 0
	mov	eax, ecx
	ret	0
??0<unnamed-type-device>@dxgi_caps_t@@QAE@XZ ENDP	; dxgi_caps_t::<unnamed-type-device>::<unnamed-type-device>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_override_id$ = 8					; size = 4
?SK_DXGI_SetPreferredAdapter@@YGXH@Z PROC		; SK_DXGI_SetPreferredAdapter

; 5302 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 5303 :   SK_DXGI_preferred_adapter = override_id;

	mov	eax, DWORD PTR _override_id$[ebp]
	mov	DWORD PTR ?SK_DXGI_preferred_adapter@@3HA, eax ; SK_DXGI_preferred_adapter

; 5304 : }

	pop	ebp
	ret	4
?SK_DXGI_SetPreferredAdapter@@YGXH@Z ENDP		; SK_DXGI_SetPreferredAdapter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_pSwapChain1$ = 8					; size = 4
_pSwapChain$ = 8					; size = 4
_rehook$ = 12						; size = 1
?SK_DXGI_HookPresent@@YAXPAUIDXGISwapChain@@_N@Z PROC	; SK_DXGI_HookPresent

; 4908 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?SK_DXGI_HookPresent@@YAXPAUIDXGISwapChain@@_N@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi

; 4909 :   SK_DXGI_HookPresentBase (pSwapChain, rehook);

	push	DWORD PTR _rehook$[ebp]
	mov	esi, DWORD PTR _pSwapChain$[ebp]
	push	esi
	call	?SK_DXGI_HookPresentBase@@YAXPAUIDXGISwapChain@@_N@Z ; SK_DXGI_HookPresentBase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 158  :         p = NULL;

	xor	ecx, ecx
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4909 :   SK_DXGI_HookPresentBase (pSwapChain, rehook);

	add	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 158  :         p = NULL;

	mov	DWORD PTR _pSwapChain1$[ebp], ecx

; 623  :         if (lp != NULL)

	test	esi, esi
	je	SHORT $LN8@SK_DXGI_Ho

; 624  :         {
; 625  :             if (FAILED(lp->QueryInterface(*piid, (void **)&this->p)))

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _pSwapChain1$[ebp]
	push	ecx
	push	OFFSET __GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa
	push	esi
	call	DWORD PTR [eax]
	mov	ecx, DWORD PTR _pSwapChain1$[ebp]
	xor	edx, edx
	test	eax, eax
	cmovs	ecx, edx
	mov	DWORD PTR _pSwapChain1$[ebp], ecx
$LN8@SK_DXGI_Ho:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4911 :   CComQIPtr <IDXGISwapChain1> pSwapChain1 (pSwapChain);

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 214  :         return p == pT;

	test	ecx, ecx
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4913 :   if (pSwapChain1 != nullptr)

	je	SHORT $LN2@SK_DXGI_Ho

; 4914 :   {
; 4915 :     SK_DXGI_HookPresent1 (pSwapChain1, rehook);

	push	DWORD PTR _rehook$[ebp]
	push	ecx
	call	?SK_DXGI_HookPresent1@@YAXPAUIDXGISwapChain1@@_N@Z ; SK_DXGI_HookPresent1
	mov	ecx, DWORD PTR _pSwapChain1$[ebp]
	add	esp, 8
$LN2@SK_DXGI_Ho:

; 4916 :   }
; 4917 : 
; 4918 :   if (config.system.handle_crashes)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+812, 0
	je	SHORT $LN3@SK_DXGI_Ho

; 4919 :     SK::Diagnostics::CrashHandler::Reinstall ();

	call	?Reinstall@CrashHandler@Diagnostics@SK@@YAXXZ ; SK::Diagnostics::CrashHandler::Reinstall
	mov	ecx, DWORD PTR _pSwapChain1$[ebp]
$LN3@SK_DXGI_Ho:

; 4920 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	ecx, ecx
	je	SHORT $LN27@SK_DXGI_Ho

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN27@SK_DXGI_Ho:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 4920 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_DXGI_HookPresent@@YAXPAUIDXGISwapChain@@_N@Z$0:
	lea	ecx, DWORD PTR _pSwapChain1$[ebp]
	jmp	??1?$CComQIPtr@UIDXGISwapChain1@@$1?_GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa@@3U__s_GUID@@B@ATL@@QAE@XZ
__ehhandler$?SK_DXGI_HookPresent@@YAXPAUIDXGISwapChain@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?SK_DXGI_HookPresent@@YAXPAUIDXGISwapChain@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_DXGI_HookPresent@@YAXPAUIDXGISwapChain@@_N@Z ENDP	; SK_DXGI_HookPresent
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_bFullscreen$ = 8					; size = 1
?SKX_D3D11_EnableFullscreen@@YGX_N@Z PROC		; SKX_D3D11_EnableFullscreen

; 687  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 688  :   bAlwaysAllowFullscreen = bFullscreen;

	mov	al, BYTE PTR _bFullscreen$[ebp]
	mov	BYTE PTR ?bAlwaysAllowFullscreen@@3_NA, al ; bAlwaysAllowFullscreen

; 689  : }

	pop	ebp
	ret	4
?SKX_D3D11_EnableFullscreen@@YGX_N@Z ENDP		; SKX_D3D11_EnableFullscreen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
?SK_DXGI_BringRenderWindowToTop@@YGXXZ PROC		; SK_DXGI_BringRenderWindowToTop

; 665  :   CreateThread ( nullptr,

	push	0
	push	0
	push	0
	push	OFFSET ?SK_DXGI_BringRenderWindowToTop_THREAD@@YGKPAX@Z ; SK_DXGI_BringRenderWindowToTop_THREAD
	push	0
	push	0
	call	DWORD PTR __imp__CreateThread@24

; 666  :                    0,
; 667  :                      SK_DXGI_BringRenderWindowToTop_THREAD,
; 668  :                        nullptr,
; 669  :                          0,
; 670  :                            nullptr );
; 671  : }

	ret	0
?SK_DXGI_BringRenderWindowToTop@@YGXXZ ENDP		; SK_DXGI_BringRenderWindowToTop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_user$ = 8						; size = 4
?SK_DXGI_BringRenderWindowToTop_THREAD@@YGKPAX@Z PROC	; SK_DXGI_BringRenderWindowToTop_THREAD

; 4005 :   UNREFERENCED_PARAMETER (user);
; 4006 : 
; 4007 :   if (hWndRender != nullptr)

	mov	eax, DWORD PTR ?hWndRender@@3PAUHWND__@@A ; hWndRender
	test	eax, eax
	je	SHORT $LN2@SK_DXGI_Br

; 4008 :   {
; 4009 :     SetActiveWindow     (hWndRender);

	push	eax
	call	DWORD PTR __imp__SetActiveWindow@4

; 4010 :     SetForegroundWindow (hWndRender);

	push	DWORD PTR ?hWndRender@@3PAUHWND__@@A	; hWndRender
	call	DWORD PTR __imp__SetForegroundWindow@4

; 4011 :     BringWindowToTop    (hWndRender);

	push	DWORD PTR ?hWndRender@@3PAUHWND__@@A	; hWndRender
	call	DWORD PTR __imp__BringWindowToTop@4
$LN2@SK_DXGI_Br:

; 4012 :   }
; 4013 : 
; 4014 :   CloseHandle (GetCurrentThread ());

	call	DWORD PTR __imp__GetCurrentThread@0
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 4015 : 
; 4016 :   return 0;

	xor	eax, eax

; 4017 : }

	ret	4
?SK_DXGI_BringRenderWindowToTop_THREAD@@YGKPAX@Z ENDP	; SK_DXGI_BringRenderWindowToTop_THREAD
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\comdef.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\comdef.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\comdef.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_desc$ = -132						; size = 60
_err$2 = -72						; size = 16
_featureLevel$ = -56					; size = 4
_pSwapChain1$3 = -52					; size = 4
_pFactory$4 = -48					; size = 4
_pDevDXGI$ = -44					; size = 4
_pAdapter$ = -40					; size = 4
_pFactory$ = -36					; size = 4
_pDevCtx$5 = -32					; size = 4
_hr$1$ = -28						; size = 4
_pDev$6 = -28						; size = 4
_pDevice$ = -24						; size = 4
_pImmediateContext$ = -20				; size = 4
_pSwapChain$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_user$ = 8						; size = 4
?HookDXGI@@YGIPAX@Z PROC				; HookDXGI

; 5109 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?HookDXGI@@YGIPAX@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 120				; 00000078H

; 5110 :   UNREFERENCED_PARAMETER (user);
; 5111 : 
; 5112 :   if (! config.apis.dxgi.d3d11.hook)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+789, 0
	je	$LN208@HookDXGI

; 5113 :   {
; 5114 :     return 0;
; 5115 :   }
; 5116 : 
; 5117 :   // Wait for DXGI to boot
; 5118 :   if (CreateDXGIFactory_Import == nullptr)

	cmp	DWORD PTR ?CreateDXGIFactory_Import@@3P6GJABU_GUID@@PAPAX@ZA, 0 ; CreateDXGIFactory_Import
	push	ebx
	push	esi
	mov	ebx, 1
	jne	SHORT $LN3@HookDXGI
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h

; 9003 :     return (unsigned long) _InterlockedCompareExchange((volatile long*) Destination, (long) Exchange, (long) Comperand);

	mov	ecx, ebx
	mov	edx, OFFSET ?implicit_init@?7??HookDXGI@@YGIPAX@Z@4KC
	xor	eax, eax
	lock	 cmpxchg DWORD PTR [edx], ecx
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5124 :     if (! InterlockedCompareExchange (&implicit_init, TRUE, FALSE))

	test	eax, eax
	jne	SHORT $LN200@HookDXGI

; 5125 :     {
; 5126 :       dll_log.Log (L"[  D3D 11  ]  >> Implicit Initialization Triggered <<");

	push	OFFSET $SG370018
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8

; 5127 :       SK_BootDXGI ();

	call	?SK_BootDXGI@@YAXXZ			; SK_BootDXGI
$LN200@HookDXGI:

; 5128 :     }
; 5129 : 
; 5130 :     while (CreateDXGIFactory_Import == nullptr)

	cmp	DWORD PTR ?CreateDXGIFactory_Import@@3P6GJABU_GUID@@PAPAX@ZA, 0 ; CreateDXGIFactory_Import
	jne	SHORT $LN3@HookDXGI
	mov	esi, DWORD PTR __imp__MsgWaitForMultipleObjectsEx@20
$LL2@HookDXGI:

; 5131 :       MsgWaitForMultipleObjectsEx (0, nullptr, 33, QS_ALLINPUT, MWMO_ALERTABLE);

	push	2
	push	1279					; 000004ffH
	push	33					; 00000021H
	push	0
	push	0
	call	esi
	cmp	DWORD PTR ?CreateDXGIFactory_Import@@3P6GJABU_GUID@@PAPAX@ZA, 0 ; CreateDXGIFactory_Import
	je	SHORT $LL2@HookDXGI
$LN3@HookDXGI:
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?__dxgi_ready@@3JC	; __dxgi_ready
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5136 :   if (ReadAcquire (&__dxgi_ready))

	test	eax, eax
	jne	$LN198@HookDXGI

; 5137 :   {
; 5138 :     //WaitForInit ();
; 5139 :     return 0;
; 5140 :   }
; 5141 : 
; 5142 :   bool success =
; 5143 :     SUCCEEDED ( CoInitializeEx (nullptr, COINIT_MULTITHREADED) );

	push	eax
	push	eax
	call	DWORD PTR __imp__CoInitializeEx@8

; 5144 :   DBG_UNREFERENCED_LOCAL_VARIABLE (success);
; 5145 : 
; 5146 :   dll_log.Log (L"[   DXGI   ]   Installing DXGI Hooks");

	push	OFFSET $SG370020
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pDevice$[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5154 :   CComPtr <ID3D11Device>        pDevice           = nullptr;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pImmediateContext$[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5162 :   InterlockedExchange (&SK_D3D11_init_tid, GetCurrentThreadId ());

	call	DWORD PTR __imp__GetCurrentThreadId@0
	mov	ecx, OFFSET ?SK_D3D11_init_tid@@3JC	; SK_D3D11_init_tid
	xchg	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pSwapChain$[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5164 :   CComPtr <IDXGISwapChain> pSwapChain = nullptr;

	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 5165 : 
; 5166 :   extern HWND
; 5167 :   SK_Win32_CreateDummyWindow (void);
; 5168 :   
; 5169 :   extern void
; 5170 :   SK_Win32_CleanupDummyWindow (void);
; 5171 :   
; 5172 :   HWND                   hWnd = SK_Win32_CreateDummyWindow ();

	call	?SK_Win32_CreateDummyWindow@@YAPAUHWND__@@XZ ; SK_Win32_CreateDummyWindow

; 5173 : 
; 5174 :   DXGI_SWAP_CHAIN_DESC desc = { };

	push	60					; 0000003cH
	mov	esi, eax
	lea	eax, DWORD PTR _desc$[ebp]
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 5175 :   
; 5176 :   desc.BufferDesc.Format           = DXGI_FORMAT_R8G8B8A8_UNORM;

	mov	DWORD PTR _desc$[ebp+16], 28		; 0000001cH

; 5177 :   desc.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;
; 5178 :   desc.BufferDesc.Scaling          = DXGI_MODE_SCALING_UNSPECIFIED;
; 5179 :   desc.SampleDesc.Count            = 1;
; 5180 :   desc.SampleDesc.Quality          = 0;
; 5181 :   desc.BufferUsage                 = DXGI_USAGE_BACK_BUFFER;
; 5182 :   desc.BufferCount                 = 1;
; 5183 :   desc.OutputWindow                = hWnd;
; 5184 :   desc.Windowed                    = TRUE;
; 5185 :   desc.SwapEffect                  = DXGI_SWAP_EFFECT_SEQUENTIAL;
; 5186 : 
; 5187 :   extern LPVOID pfnD3D11CreateDeviceAndSwapChain;
; 5188 : 
; 5189 :   hr =

	lea	eax, DWORD PTR _pImmediateContext$[ebp]
	mov	DWORD PTR _desc$[ebp+20], 0
	mov	DWORD PTR _desc$[ebp+24], 0
	mov	DWORD PTR _desc$[ebp+28], 1
	push	eax
	lea	eax, DWORD PTR _featureLevel$[ebp]
	mov	DWORD PTR _desc$[ebp+32], 0
	push	eax
	lea	eax, DWORD PTR _pDevice$[ebp]
	mov	DWORD PTR _desc$[ebp+36], 64		; 00000040H
	push	eax
	lea	eax, DWORD PTR _pSwapChain$[ebp]
	mov	DWORD PTR _desc$[ebp+40], 1
	push	eax
	lea	eax, DWORD PTR _desc$[ebp]
	mov	DWORD PTR _desc$[ebp+44], esi
	push	eax
	push	7
	push	0
	push	0
	push	0
	push	0
	push	1
	push	0
	mov	DWORD PTR _desc$[ebp+48], 1
	mov	DWORD PTR _desc$[ebp+52], 1
	call	DWORD PTR ?pfnD3D11CreateDeviceAndSwapChain@@3PAXA ; pfnD3D11CreateDeviceAndSwapChain
	mov	esi, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pDevDXGI$[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5203 :   d3d11_hook_ctx.ppDevice           = &pDevice;

	lea	eax, DWORD PTR _pDevice$[ebp]
	mov	DWORD PTR _hr$1$[ebp], esi
	mov	DWORD PTR ?d3d11_hook_ctx@@3Usk_hook_d3d11_t@@A, eax

; 5204 :   d3d11_hook_ctx.ppImmediateContext = &pImmediateContext;

	lea	eax, DWORD PTR _pImmediateContext$[ebp]
	mov	DWORD PTR ?d3d11_hook_ctx@@3Usk_hook_d3d11_t@@A+4, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pAdapter$[ebp], 0
	mov	DWORD PTR _pFactory$[ebp], 0
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	mov	eax, DWORD PTR _pDevice$[ebp]
	lea	edx, DWORD PTR _pDevDXGI$[ebp]
	push	edx
	push	OFFSET __GUID_54ec77fa_1377_44e6_8c32_88fd5f44c84c
	push	eax
	mov	ecx, DWORD PTR [eax]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5208 :   CComPtr <IDXGIFactory> pFactory = nullptr;

	mov	BYTE PTR __$EHRec$[ebp+8], 5
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	call	DWORD PTR [ecx]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5211 :        SUCCEEDED (pDevDXGI->GetAdapter                  (&pAdapter)) &&

	test	eax, eax
	js	$LN8@HookDXGI
	mov	eax, DWORD PTR _pDevDXGI$[ebp]
	lea	edx, DWORD PTR _pAdapter$[ebp]
	push	edx
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+28]
	test	eax, eax
	js	$LN8@HookDXGI
	mov	esi, DWORD PTR _pAdapter$[ebp]
	lea	eax, DWORD PTR _pFactory$[ebp]
	push	edi
	push	eax
	mov	edi, DWORD PTR [esi]
	call	??$IID_PPV_ARGS_Helper@UIDXGIFactory@@@@YAPAPAXPAPAUIDXGIFactory@@@Z ; IID_PPV_ARGS_Helper<IDXGIFactory>
	add	esp, 4
	push	eax
	push	OFFSET __GUID_7b7166ec_21c7_44ae_b21a_c9ae321ae369
	push	esi
	call	DWORD PTR [edi+24]
	pop	edi
	test	eax, eax
	js	$LN204@HookDXGI

; 5212 :        SUCCEEDED (pAdapter->GetParent     (IID_PPV_ARGS (&pFactory))) )
; 5213 :   {
; 5214 :     HookD3D11             (&d3d11_hook_ctx);

	push	OFFSET ?d3d11_hook_ctx@@3Usk_hook_d3d11_t@@A ; d3d11_hook_ctx
	call	?HookD3D11@@YGIPAX@Z			; HookD3D11

; 5215 :     SK_DXGI_HookFactory   (pFactory);

	push	DWORD PTR _pFactory$[ebp]
	call	?SK_DXGI_HookFactory@@YAXPAUIDXGIFactory@@@Z ; SK_DXGI_HookFactory

; 5216 :     SK_DXGI_HookSwapChain (pSwapChain);

	push	DWORD PTR _pSwapChain$[ebp]
	call	?SK_DXGI_HookSwapChain@@YAXPAUIDXGISwapChain@@@Z ; SK_DXGI_HookSwapChain

; 5217 : 
; 5218 :     // This won't catch Present1 (...), but no games use that
; 5219 :     //   and we can deal with it later if it happens.
; 5220 :     SK_DXGI_HookPresentBase ((IDXGISwapChain *)pSwapChain, false);

	push	0
	push	DWORD PTR _pSwapChain$[ebp]
	call	?SK_DXGI_HookPresentBase@@YAXPAUIDXGISwapChain@@_N@Z ; SK_DXGI_HookPresentBase
	add	esp, 16					; 00000010H

; 5222 :     CComQIPtr <IDXGISwapChain1> pSwapChain1 (pSwapChain);

	lea	ecx, DWORD PTR _pSwapChain1$3[ebp]
	push	DWORD PTR _pSwapChain$[ebp]
	call	??0?$CComQIPtr@UIDXGISwapChain1@@$1?_GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z ; ATL::CComQIPtr<IDXGISwapChain1,&_GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa>::CComQIPtr<IDXGISwapChain1,&_GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa>
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 214  :         return p == pT;

	mov	eax, DWORD PTR _pSwapChain1$3[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5222 :     CComQIPtr <IDXGISwapChain1> pSwapChain1 (pSwapChain);

	mov	BYTE PTR __$EHRec$[ebp+8], 6
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 214  :         return p == pT;

	test	eax, eax
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5224 :     if (pSwapChain1 != nullptr)

	je	SHORT $LN10@HookDXGI

; 5225 :       SK_DXGI_HookPresent1 (pSwapChain1, false);

	push	0
	push	eax
	call	?SK_DXGI_HookPresent1@@YAXPAUIDXGISwapChain1@@_N@Z ; SK_DXGI_HookPresent1
	add	esp, 8
$LN10@HookDXGI:

; 5226 : 
; 5227 :     MH_ApplyQueued  ();

	call	_MH_ApplyQueued@0

; 5228 : 
; 5229 :     if (SK_GetDLLRole () == DLL_ROLE::DXGI)

	call	?SK_GetDLLRole@@YG?AW4DLL_ROLE@@XZ	; SK_GetDLLRole
	cmp	eax, 1
	jne	SHORT $LN11@HookDXGI

; 5230 :     {
; 5231 :       // Load user-defined DLLs (Plug-In)
; 5232 : #ifdef _WIN64
; 5233 :       SK_LoadPlugIns64 ();
; 5234 : #else
; 5235 :       SK_LoadPlugIns32 ();

	call	?SK_LoadPlugIns32@@YAXXZ		; SK_LoadPlugIns32
$LN11@HookDXGI:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 158  :         p = NULL;

	mov	DWORD PTR _pFactory$4[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5240 :     CreateDXGIFactory_Import (__uuidof (IDXGIFactory1), (void **)&pFactory);

	lea	eax, DWORD PTR _pFactory$4[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	push	eax
	push	OFFSET __GUID_770aae78_f26f_4dba_a829_253c83d1b387
	call	DWORD PTR ?CreateDXGIFactory_Import@@3P6GJABU_GUID@@PAPAX@ZA ; CreateDXGIFactory_Import
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pDevCtx$5[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5244 :     if (config.render.dxgi.deferred_isolation)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+490, 0
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	je	SHORT $LN128@HookDXGI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pDev$6[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5247 :       pImmediateContext->GetDevice (&pDev);

	mov	eax, DWORD PTR _pImmediateContext$[ebp]
	lea	edx, DWORD PTR _pDev$6[ebp]
	push	edx
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+12]

; 5248 : 
; 5249 :       pDev->CreateDeferredContext (0x00,  &pDevCtx);

	mov	eax, DWORD PTR _pDev$6[ebp]
	lea	edx, DWORD PTR _pDevCtx$5[ebp]
	push	edx
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+108]

; 5250 :       d3d11_hook_ctx.ppImmediateContext = &pDevCtx;

	lea	eax, DWORD PTR _pDevCtx$5[ebp]

; 5251 :     }

	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	DWORD PTR ?d3d11_hook_ctx@@3Usk_hook_d3d11_t@@A+4, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	mov	eax, DWORD PTR _pDev$6[ebp]
	test	eax, eax
	je	SHORT $LN128@HookDXGI

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN128@HookDXGI:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5253 :     if (config.apis.dxgi.d3d11.hook) SK_D3D11_EnableHooks ();

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+789, 0
	je	SHORT $LN13@HookDXGI
	call	?SK_D3D11_EnableHooks@@YAXXZ		; SK_D3D11_EnableHooks
$LN13@HookDXGI:

; 5254 :       
; 5255 : #ifdef _WIN64
; 5256 :     if (config.apis.dxgi.d3d12.hook) SK_D3D12_EnableHooks ();
; 5257 : #endif
; 5258 : 
; 5259 :     InterlockedExchange (&__dxgi_ready, TRUE);

	mov	eax, OFFSET ?__dxgi_ready@@3JC		; __dxgi_ready
	xchg	DWORD PTR [eax], ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	mov	eax, DWORD PTR _pDevCtx$5[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5260 :   }

	mov	BYTE PTR __$EHRec$[ebp+8], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN134@HookDXGI

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN134@HookDXGI:

; 176  :         if (p)

	mov	eax, DWORD PTR _pFactory$4[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5260 :   }

	mov	BYTE PTR __$EHRec$[ebp+8], 6
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN140@HookDXGI

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN140@HookDXGI:

; 176  :         if (p)

	mov	eax, DWORD PTR _pSwapChain1$3[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5260 :   }

	mov	BYTE PTR __$EHRec$[ebp+8], 5
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	$LN162@HookDXGI

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5262 :   else

	jmp	SHORT $LN162@HookDXGI
$LN204@HookDXGI:
	mov	esi, DWORD PTR _hr$1$[ebp]
$LN8@HookDXGI:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\comdef.h

; 455  :     return (hr >= WCODE_HRESULT_FIRST && hr <= WCODE_HRESULT_LAST)

	lea	eax, DWORD PTR [esi+2147220992]

; 301  : {

	mov	DWORD PTR _err$2[ebp], OFFSET ??_7_com_error@@6B@

; 300  :     : m_hresult(hr), m_perrinfo(perrinfo), m_pszMsg(NULL)

	mov	DWORD PTR _err$2[ebp+4], esi
	mov	DWORD PTR _err$2[ebp+8], 0
	mov	DWORD PTR _err$2[ebp+12], 0

; 455  :     return (hr >= WCODE_HRESULT_FIRST && hr <= WCODE_HRESULT_LAST)

	cmp	eax, 65023				; 0000fdffH
	ja	SHORT $LN158@HookDXGI
	lea	eax, DWORD PTR [esi-512]
	movzx	esi, ax
	jmp	SHORT $LN159@HookDXGI
$LN158@HookDXGI:
	xor	esi, esi
$LN159@HookDXGI:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5266 :     dll_log.Log (L"[   DXGI   ] Unable to hook D3D11?! (0x%04x :: '%s')",

	lea	ecx, DWORD PTR _err$2[ebp]
	call	?ErrorMessage@_com_error@@QBEPB_WXZ	; _com_error::ErrorMessage
	push	eax
	movzx	eax, si
	push	eax
	push	OFFSET $SG370027
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\comdef.h

; 317  :     if (m_perrinfo != NULL) {

	mov	ecx, DWORD PTR _err$2[ebp+8]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5266 :     dll_log.Log (L"[   DXGI   ] Unable to hook D3D11?! (0x%04x :: '%s')",

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\comdef.h

; 316  : {

	mov	DWORD PTR _err$2[ebp], OFFSET ??_7_com_error@@6B@

; 317  :     if (m_perrinfo != NULL) {

	test	ecx, ecx
	je	SHORT $LN161@HookDXGI

; 318  :         m_perrinfo->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN161@HookDXGI:

; 319  :     }
; 320  :     if (m_pszMsg != NULL) {

	mov	eax, DWORD PTR _err$2[ebp+12]
	test	eax, eax
	je	SHORT $LN162@HookDXGI

; 321  :         LocalFree((HLOCAL)m_pszMsg);

	push	eax
	call	DWORD PTR __imp__LocalFree@4
$LN162@HookDXGI:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5270 :   SK_Win32_CleanupDummyWindow ();

	call	?SK_Win32_CleanupDummyWindow@@YAXXZ	; SK_Win32_CleanupDummyWindow
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	mov	eax, DWORD PTR _pFactory$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5274 :   return 0;

	mov	BYTE PTR __$EHRec$[ebp+8], 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN168@HookDXGI

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN168@HookDXGI:

; 176  :         if (p)

	mov	eax, DWORD PTR _pAdapter$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5274 :   return 0;

	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN174@HookDXGI

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN174@HookDXGI:

; 176  :         if (p)

	mov	eax, DWORD PTR _pDevDXGI$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5274 :   return 0;

	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN180@HookDXGI

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN180@HookDXGI:

; 176  :         if (p)

	mov	eax, DWORD PTR _pSwapChain$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5274 :   return 0;

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN186@HookDXGI

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN186@HookDXGI:

; 176  :         if (p)

	mov	eax, DWORD PTR _pImmediateContext$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5274 :   return 0;

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN192@HookDXGI

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN192@HookDXGI:

; 176  :         if (p)

	mov	eax, DWORD PTR _pDevice$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5274 :   return 0;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN198@HookDXGI

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN198@HookDXGI:
	pop	esi
	pop	ebx
$LN208@HookDXGI:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5275 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	xor	eax, eax
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?HookDXGI@@YGIPAX@Z$0:
	lea	ecx, DWORD PTR _pDevice$[ebp]
	jmp	??1?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ
__unwindfunclet$?HookDXGI@@YGIPAX@Z$1:
	lea	ecx, DWORD PTR _pImmediateContext$[ebp]
	jmp	??1?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@XZ
__unwindfunclet$?HookDXGI@@YGIPAX@Z$2:
	lea	ecx, DWORD PTR _pSwapChain$[ebp]
	jmp	??1?$CComPtr@UIDXGISwapChain@@@ATL@@QAE@XZ
__unwindfunclet$?HookDXGI@@YGIPAX@Z$3:
	lea	ecx, DWORD PTR _pDevDXGI$[ebp]
	jmp	??1?$CComPtr@UIDXGIDevice@@@ATL@@QAE@XZ
__unwindfunclet$?HookDXGI@@YGIPAX@Z$4:
	lea	ecx, DWORD PTR _pAdapter$[ebp]
	jmp	??1?$CComPtr@UIDXGIAdapter@@@ATL@@QAE@XZ
__unwindfunclet$?HookDXGI@@YGIPAX@Z$5:
	lea	ecx, DWORD PTR _pFactory$[ebp]
	jmp	??1?$CComPtr@UIDXGIFactory@@@ATL@@QAE@XZ
__unwindfunclet$?HookDXGI@@YGIPAX@Z$6:
	lea	ecx, DWORD PTR _pSwapChain1$3[ebp]
	jmp	??1?$CComQIPtr@UIDXGISwapChain1@@$1?_GUID_790a45f7_0d42_4876_983a_0a55cfe6f4aa@@3U__s_GUID@@B@ATL@@QAE@XZ
__unwindfunclet$?HookDXGI@@YGIPAX@Z$7:
	lea	ecx, DWORD PTR _pFactory$4[ebp]
	jmp	??1?$CComPtr@UIDXGIFactory1@@@ATL@@QAE@XZ
__unwindfunclet$?HookDXGI@@YGIPAX@Z$8:
	lea	ecx, DWORD PTR _pDevCtx$5[ebp]
	jmp	??1?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@XZ
__unwindfunclet$?HookDXGI@@YGIPAX@Z$9:
	lea	ecx, DWORD PTR _pDev$6[ebp]
	jmp	??1?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ
__ehhandler$?HookDXGI@@YGIPAX@Z:
	mov	eax, OFFSET __ehfuncinfo$?HookDXGI@@YGIPAX@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?HookDXGI@@YGIPAX@Z ENDP				; HookDXGI
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\combaseapi.h
;	COMDAT ??$IID_PPV_ARGS_Helper@UID3D11Texture2D@@@@YAPAPAXPAPAUID3D11Texture2D@@@Z
_TEXT	SEGMENT
_pp$ = 8						; size = 4
??$IID_PPV_ARGS_Helper@UID3D11Texture2D@@@@YAPAPAXPAPAUID3D11Texture2D@@@Z PROC ; IID_PPV_ARGS_Helper<ID3D11Texture2D>, COMDAT

; 227  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 228  : #pragma prefast(suppress: 6269, "Tool issue with unused static_cast")
; 229  :         static_cast<IUnknown*>(*pp);    // make sure everyone derives from IUnknown
; 230  :         return reinterpret_cast<void**>(pp);

	mov	eax, DWORD PTR _pp$[ebp]

; 231  :     }    

	pop	ebp
	ret	0
??$IID_PPV_ARGS_Helper@UID3D11Texture2D@@@@YAPAPAXPAPAUID3D11Texture2D@@@Z ENDP ; IID_PPV_ARGS_Helper<ID3D11Texture2D>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtr@UID3D11Texture2D@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComPtr@UID3D11Texture2D@@@ATL@@QAE@XZ PROC	; ATL::CComPtr<ID3D11Texture2D>::~CComPtr<ID3D11Texture2D>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComPtr@UID3D11Texture2D@@@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@CComPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN4@CComPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComPtr@UID3D11Texture2D@@@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComPtr@UID3D11Texture2D@@@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComPtr@UID3D11Texture2D@@@ATL@@QAE@XZ ENDP	; ATL::CComPtr<ID3D11Texture2D>::~CComPtr<ID3D11Texture2D>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UID3D11Texture2D@@@ATL@@QAE@PAUID3D11Texture2D@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtr@UID3D11Texture2D@@@ATL@@QAE@PAUID3D11Texture2D@@@Z PROC ; ATL::CComPtr<ID3D11Texture2D>::CComPtr<ID3D11Texture2D>, COMDAT
; _this$ = ecx

; 312  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi

; 312  :     {

	mov	esi, ecx

; 162  :         p = lp;

	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN6@CComPtr

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN6@CComPtr:

; 313  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtr@UID3D11Texture2D@@@ATL@@QAE@PAUID3D11Texture2D@@@Z ENDP ; ATL::CComPtr<ID3D11Texture2D>::CComPtr<ID3D11Texture2D>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??C?$CComPtrBase@UID3D11Texture2D@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UID3D11Texture2D@@@1@XZ
_TEXT	SEGMENT
??C?$CComPtrBase@UID3D11Texture2D@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UID3D11Texture2D@@@1@XZ PROC ; ATL::CComPtrBase<ID3D11Texture2D>::operator->, COMDAT
; _this$ = ecx

; 197  :         ATLASSERT(p!=NULL);
; 198  :         return (_NoAddRefReleaseOnCComPtr<T>*)p;

	mov	eax, DWORD PTR [ecx]

; 199  :     }

	ret	0
??C?$CComPtrBase@UID3D11Texture2D@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UID3D11Texture2D@@@1@XZ ENDP ; ATL::CComPtrBase<ID3D11Texture2D>::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??I?$CComPtrBase@UID3D11Texture2D@@@ATL@@QAEPAPAUID3D11Texture2D@@XZ
_TEXT	SEGMENT
??I?$CComPtrBase@UID3D11Texture2D@@@ATL@@QAEPAPAUID3D11Texture2D@@XZ PROC ; ATL::CComPtrBase<ID3D11Texture2D>::operator&, COMDAT
; _this$ = ecx

; 192  :         ATLASSERT(p==NULL);
; 193  :         return &p;

	mov	eax, ecx

; 194  :     }

	ret	0
??I?$CComPtrBase@UID3D11Texture2D@@@ATL@@QAEPAPAUID3D11Texture2D@@XZ ENDP ; ATL::CComPtrBase<ID3D11Texture2D>::operator&
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??B?$CComPtrBase@UID3D11Texture2D@@@ATL@@QBEPAUID3D11Texture2D@@XZ
_TEXT	SEGMENT
??B?$CComPtrBase@UID3D11Texture2D@@@ATL@@QBEPAUID3D11Texture2D@@XZ PROC ; ATL::CComPtrBase<ID3D11Texture2D>::operator ID3D11Texture2D *, COMDAT
; _this$ = ecx

; 181  :         return p;

	mov	eax, DWORD PTR [ecx]

; 182  :     }

	ret	0
??B?$CComPtrBase@UID3D11Texture2D@@@ATL@@QBEPAUID3D11Texture2D@@XZ ENDP ; ATL::CComPtrBase<ID3D11Texture2D>::operator ID3D11Texture2D *
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UID3D11Texture2D@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UID3D11Texture2D@@@ATL@@QAE@XZ PROC	; ATL::CComPtrBase<ID3D11Texture2D>::~CComPtrBase<ID3D11Texture2D>, COMDAT
; _this$ = ecx

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN2@CComPtrBas

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@CComPtrBas:

; 178  :     }

	ret	0
??1?$CComPtrBase@UID3D11Texture2D@@@ATL@@QAE@XZ ENDP	; ATL::CComPtrBase<ID3D11Texture2D>::~CComPtrBase<ID3D11Texture2D>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UID3D11Texture2D@@@ATL@@IAE@PAUID3D11Texture2D@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtrBase@UID3D11Texture2D@@@ATL@@IAE@PAUID3D11Texture2D@@@Z PROC ; ATL::CComPtrBase<ID3D11Texture2D>::CComPtrBase<ID3D11Texture2D>, COMDAT
; _this$ = ecx

; 160  :     CComPtrBase(_Inout_opt_ T* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp

; 161  :     {
; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN4@CComPtrBas

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN4@CComPtrBas:

; 165  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtrBase@UID3D11Texture2D@@@ATL@@IAE@PAUID3D11Texture2D@@@Z ENDP ; ATL::CComPtrBase<ID3D11Texture2D>::CComPtrBase<ID3D11Texture2D>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComQIPtr@UID3D11DeviceContext@@$1?_GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da@@3U__s_GUID@@B@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComQIPtr@UID3D11DeviceContext@@$1?_GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da@@3U__s_GUID@@B@ATL@@QAE@XZ PROC ; ATL::CComQIPtr<ID3D11DeviceContext,&_GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da>::~CComQIPtr<ID3D11DeviceContext,&_GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComQIPtr@UID3D11DeviceContext@@$1?_GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da@@3U__s_GUID@@B@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN7@CComQIPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN7@CComQIPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComQIPtr@UID3D11DeviceContext@@$1?_GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da@@3U__s_GUID@@B@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComQIPtr@UID3D11DeviceContext@@$1?_GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da@@3U__s_GUID@@B@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComQIPtr@UID3D11DeviceContext@@$1?_GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da@@3U__s_GUID@@B@ATL@@QAE@XZ ENDP ; ATL::CComQIPtr<ID3D11DeviceContext,&_GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da>::~CComQIPtr<ID3D11DeviceContext,&_GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComQIPtr@UID3D11DeviceContext@@$1?_GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComQIPtr@UID3D11DeviceContext@@$1?_GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z PROC ; ATL::CComQIPtr<ID3D11DeviceContext,&_GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da>::CComQIPtr<ID3D11DeviceContext,&_GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da>, COMDAT
; _this$ = ecx

; 621  :     CComQIPtr(_Inout_opt_ IUnknown* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 622  :     {
; 623  :         if (lp != NULL)

	mov	ecx, DWORD PTR _lp$[ebp]

; 158  :         p = NULL;

	mov	DWORD PTR [esi], 0

; 622  :     {
; 623  :         if (lp != NULL)

	test	ecx, ecx
	je	SHORT $LN10@CComQIPtr

; 624  :         {
; 625  :             if (FAILED(lp->QueryInterface(*piid, (void **)&this->p)))

	mov	eax, DWORD PTR [ecx]
	push	esi
	push	OFFSET __GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da
	push	ecx
	call	DWORD PTR [eax]
	test	eax, eax

; 627  :         }
; 628  :     }

	mov	eax, esi
	jns	SHORT $LN3@CComQIPtr

; 626  :                 this->p = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 627  :         }
; 628  :     }

	pop	ebp
	ret	4
$LN10@CComQIPtr:
	mov	eax, esi
$LN3@CComQIPtr:
	pop	esi
	pop	ebp
	ret	4
??0?$CComQIPtr@UID3D11DeviceContext@@$1?_GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z ENDP ; ATL::CComQIPtr<ID3D11DeviceContext,&_GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da>::CComQIPtr<ID3D11DeviceContext,&_GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_backbuffer_desc$2 = -124				; size = 44
_vp_orig$3 = -80					; size = 24
_vp$4 = -56						; size = 24
_num_vp$5 = -32						; size = 4
_pDev$ = -28						; size = 4
_rb$1$ = -24						; size = 4
_pBackBuffer$6 = -20					; size = 4
__$EHRec$ = -16						; size = 16
_pDevCtx$7 = 8						; size = 4
_This$ = 8						; size = 4
?ResetCEGUI_D3D11@@YAXPAUIDXGISwapChain@@@Z PROC	; ResetCEGUI_D3D11

; 329  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ResetCEGUI_D3D11@@YAXPAUIDXGISwapChain@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 112				; 00000070H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp

; 330  :   void
; 331  :   __stdcall
; 332  :   SK_D3D11_ResetTexCache (void);
; 333  : 
; 334  :   SK_D3D11_ResetTexCache (    );

	call	?SK_D3D11_ResetTexCache@@YGXXZ		; SK_D3D11_ResetTexCache

; 335  : 
; 336  : 
; 337  :   if (! config.cegui.enable)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+160, 0
	jne	SHORT $LN92@ResetCEGUI

; 338  :   {
; 339  :     // XXX: TODO (Full shutdown isn't necessary, just invalidate)
; 340  :     ImGui_DX11Shutdown (    );

	call	?ImGui_DX11Shutdown@@YAXXZ		; ImGui_DX11Shutdown

; 341  :     ImGui_DX11Startup  (This);

	mov	edi, DWORD PTR _This$[ebp]
	push	edi
	call	?ImGui_DX11Startup@@YA_NPAUIDXGISwapChain@@@Z ; ImGui_DX11Startup
	add	esp, 4
	jmp	SHORT $LN2@ResetCEGUI
$LN92@ResetCEGUI:
	mov	edi, DWORD PTR _This$[ebp]
$LN2@ResetCEGUI:

; 342  :   }
; 343  : 
; 344  : 
; 345  :   SK_RenderBackend& rb =

	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend
	mov	DWORD PTR _rb$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pDev$[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 354  :   if (SUCCEEDED (This->GetDevice (IID_PPV_ARGS (&pDev))))

	mov	esi, DWORD PTR [edi]
	lea	eax, DWORD PTR _pDev$[ebp]
	push	eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	??$IID_PPV_ARGS_Helper@UID3D11Device@@@@YAPAPAXPAPAUID3D11Device@@@Z ; IID_PPV_ARGS_Helper<ID3D11Device>
	add	esp, 4
	push	eax
	push	OFFSET __GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140
	push	edi
	call	DWORD PTR [esi+28]

; 355  :   {
; 356  :     assert (rb.device == nullptr || pDev == rb.device);
; 357  : 
; 358  :     rb.releaseOwnedResources (    );

	mov	esi, DWORD PTR _rb$1$[ebp]
	test	eax, eax
	js	SHORT $LN3@ResetCEGUI
	mov	ecx, esi
	call	?releaseOwnedResources@SK_RenderBackend_V2@@QAEXXZ ; SK_RenderBackend_V2::releaseOwnedResources

; 359  :     SK_DXGI_UpdateSwapChain  (This);

	push	edi
	call	?SK_DXGI_UpdateSwapChain@@YAXPAUIDXGISwapChain@@@Z ; SK_DXGI_UpdateSwapChain
	add	esp, 4
$LN3@ResetCEGUI:

; 360  :   }
; 361  : 
; 362  : 
; 363  :   if (cegD3D11 != nullptr)

	cmp	DWORD PTR ?cegD3D11@@3PAVDirect3D11Renderer@CEGUI@@A, 0 ; cegD3D11
	je	SHORT $LN4@ResetCEGUI

; 364  :   {
; 365  :     SK_TextOverlayManager::getInstance ()->destroyAllOverlays ();

	call	?getInstance@SK_TextOverlayManager@@SAPAV1@XZ ; SK_TextOverlayManager::getInstance
	mov	ecx, eax
	call	?destroyAllOverlays@SK_TextOverlayManager@@QAEXXZ ; SK_TextOverlayManager::destroyAllOverlays

; 366  :     SK_PopupManager::getInstance ()->destroyAllPopups         ();

	call	?getInstance@SK_PopupManager@@SAPAV1@XZ	; SK_PopupManager::getInstance
	mov	ecx, eax
	call	?destroyAllPopups@SK_PopupManager@@QAEXXZ ; SK_PopupManager::destroyAllPopups

; 367  : 
; 368  :     rb.releaseOwnedResources ();

	mov	ecx, esi
	call	?releaseOwnedResources@SK_RenderBackend_V2@@QAEXXZ ; SK_RenderBackend_V2::releaseOwnedResources

; 369  : 
; 370  :     CEGUI::WindowManager::getDllSingleton ().cleanDeadPool ();

	call	DWORD PTR __imp_?getDllSingleton@?$Singleton@VWindowManager@CEGUI@@@CEGUI@@SAAAVWindowManager@2@XZ
	mov	ecx, eax
	call	DWORD PTR __imp_?cleanDeadPool@WindowManager@CEGUI@@QAEXXZ

; 371  : 
; 372  :     cegD3D11->destroySystem  ();

	call	DWORD PTR __imp_?destroySystem@Direct3D11Renderer@CEGUI@@SAXXZ

; 373  :     cegD3D11 = nullptr;

	mov	DWORD PTR ?cegD3D11@@3PAVDirect3D11Renderer@CEGUI@@A, 0 ; cegD3D11

; 374  : 
; 375  :     // XXX: TODO (Full shutdown isn't necessary, just invalidate)
; 376  :     ImGui_DX11Shutdown ();

	call	?ImGui_DX11Shutdown@@YAXXZ		; ImGui_DX11Shutdown

; 377  :   }
; 378  : 
; 379  :   else

	jmp	$LN84@ResetCEGUI
$LN4@ResetCEGUI:

; 380  :   {
; 381  :     assert (rb.device != nullptr);
; 382  : 
; 383  :     if (rb.device == nullptr)

	cmp	DWORD PTR [esi+36], 0
	jne	SHORT $LN6@ResetCEGUI

; 384  :       SK_DXGI_UpdateSwapChain (This);

	push	edi
	call	?SK_DXGI_UpdateSwapChain@@YAXPAUIDXGISwapChain@@@Z ; SK_DXGI_UpdateSwapChain
	add	esp, 4
$LN6@ResetCEGUI:

; 385  : 
; 386  :     CComQIPtr <ID3D11DeviceContext> pDevCtx (rb.d3d11.immediate_ctx);

	mov	edx, DWORD PTR [esi+68]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 158  :         p = NULL;

	xor	ecx, ecx
	mov	DWORD PTR _pDevCtx$7[ebp], ecx

; 623  :         if (lp != NULL)

	test	edx, edx
	je	SHORT $LN27@ResetCEGUI

; 624  :         {
; 625  :             if (FAILED(lp->QueryInterface(*piid, (void **)&this->p)))

	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR _pDevCtx$7[ebp]
	push	ecx
	push	OFFSET __GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da
	push	edx
	call	DWORD PTR [eax]
	mov	ecx, DWORD PTR _pDevCtx$7[ebp]
	xor	edx, edx
	test	eax, eax
	cmovs	ecx, edx
	mov	DWORD PTR _pDevCtx$7[ebp], ecx
$LN27@ResetCEGUI:

; 162  :         p = lp;

	mov	DWORD PTR _pBackBuffer$6[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 390  :     CComPtr <ID3D11Texture2D> pBackBuffer = nullptr;

	xorps	xmm0, xmm0

; 391  : 
; 392  :     D3D11_VIEWPORT vp_orig = { };
; 393  :     UINT           num_vp  =  1;

	mov	DWORD PTR _num_vp$5[ebp], 1

; 394  : 
; 395  :     pDevCtx->RSGetViewports (&num_vp, &vp_orig);

	lea	edx, DWORD PTR _vp_orig$3[ebp]
	movq	QWORD PTR _vp_orig$3[ebp+16], xmm0
	push	edx
	movups	XMMWORD PTR _vp_orig$3[ebp], xmm0
	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR _num_vp$5[ebp]
	push	edx
	push	ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	call	DWORD PTR [eax+380]

; 396  : 
; 397  :     if ( SUCCEEDED (This->GetBuffer (0, IID_PPV_ARGS (&pBackBuffer))) )

	mov	esi, DWORD PTR [edi]
	lea	eax, DWORD PTR _pBackBuffer$6[ebp]
	push	eax
	call	??$IID_PPV_ARGS_Helper@UID3D11Texture2D@@@@YAPAPAXPAPAUID3D11Texture2D@@@Z ; IID_PPV_ARGS_Helper<ID3D11Texture2D>
	add	esp, 4
	push	eax
	push	OFFSET __GUID_6f15aaf2_d208_4e89_9ab4_489535d34f9c
	push	0
	push	edi
	call	DWORD PTR [esi+36]
	test	eax, eax
	js	$LN7@ResetCEGUI

; 398  :     {
; 399  :       D3D11_VIEWPORT                    vp = { };
; 400  :       D3D11_TEXTURE2D_DESC backbuffer_desc = { };

	push	44					; 0000002cH
	xorps	xmm0, xmm0
	lea	eax, DWORD PTR _backbuffer_desc$2[ebp]
	push	0
	push	eax
	movups	XMMWORD PTR _vp$4[ebp], xmm0
	movq	QWORD PTR _vp$4[ebp+16], xmm0
	call	_memset

; 401  : 
; 402  :       pBackBuffer->GetDesc (&backbuffer_desc);

	mov	eax, DWORD PTR _pBackBuffer$6[ebp]
	lea	edx, DWORD PTR _backbuffer_desc$2[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+40]

; 403  : 
; 404  :       vp.Width    = static_cast <float> (backbuffer_desc.Width);

	mov	eax, DWORD PTR _backbuffer_desc$2[ebp]

; 405  :       vp.Height   = static_cast <float> (backbuffer_desc.Height);
; 406  :       vp.MinDepth = 0;
; 407  :       vp.MaxDepth = 1;
; 408  :       vp.TopLeftX = 0;
; 409  :       vp.TopLeftY = 0;
; 410  : 
; 411  :       pDevCtx->RSSetViewports (1, &vp);

	lea	edx, DWORD PTR _vp$4[ebp]
	push	edx
	mov	DWORD PTR _vp$4[ebp+16], 0
	mov	DWORD PTR _vp$4[ebp+20], 1065353216	; 3f800000H
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	mov	DWORD PTR _vp$4[ebp], 0
	mov	DWORD PTR _vp$4[ebp+4], 0
	push	1
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	eax, DWORD PTR _backbuffer_desc$2[ebp+4]
	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR _vp$4[ebp+8], xmm0
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	eax, DWORD PTR _pDevCtx$7[ebp]
	push	eax
	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR _vp$4[ebp+12], xmm0
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+176]

; 412  : 
; 413  :       try
; 414  :       {
; 415  :         cegD3D11 = dynamic_cast <CEGUI::Direct3D11Renderer *>

	mov	eax, DWORD PTR _rb$1$[ebp]
	push	208					; 000000d0H
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	push	DWORD PTR [eax+68]
	push	DWORD PTR [eax+36]
	call	DWORD PTR __imp_?bootstrapSystem@Direct3D11Renderer@CEGUI@@SAAAV12@PAUID3D11Device@@PAUID3D11DeviceContext@@H@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?cegD3D11@@3PAVDirect3D11Renderer@CEGUI@@A, eax ; cegD3D11

; 416  :           (&CEGUI::Direct3D11Renderer::bootstrapSystem (
; 417  :             static_cast <ID3D11Device *>       (rb.device),
; 418  :             static_cast <ID3D11DeviceContext *>(rb.d3d11.immediate_ctx)
; 419  :            )
; 420  :           );
; 421  : 
; 422  :         ImGui_DX11Startup    (This);

	push	edi
	call	?ImGui_DX11Startup@@YA_NPAUIDXGISwapChain@@@Z ; ImGui_DX11Startup
	add	esp, 4

; 423  :         SK_CEGUI_RelocateLog (    );

	call	?SK_CEGUI_RelocateLog@@YAXXZ		; SK_CEGUI_RelocateLog

; 424  : 
; 425  :         pDevCtx->RSSetViewports (1, &vp_orig);

	mov	eax, DWORD PTR _pDevCtx$7[ebp]
	lea	edx, DWORD PTR _vp_orig$3[ebp]
	push	edx
	push	1
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+176]
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?SK_CEGUI_InitBase@@YAXXZ		; SK_CEGUI_InitBase
	call	?getInstance@SK_PopupManager@@SAPAV1@XZ	; SK_PopupManager::getInstance
	mov	ecx, eax
	call	?destroyAllPopups@SK_PopupManager@@QAEXXZ ; SK_PopupManager::destroyAllPopups
	push	DWORD PTR ?cegD3D11@@3PAVDirect3D11Renderer@CEGUI@@A ; cegD3D11
	call	?getInstance@SK_TextOverlayManager@@SAPAV1@XZ ; SK_TextOverlayManager::getInstance
	mov	ecx, eax
	call	?resetAllOverlays@SK_TextOverlayManager@@QAEXPAVRenderer@CEGUI@@@Z ; SK_TextOverlayManager::resetAllOverlays
	call	?SK_Steam_ClearPopups@@YAXXZ		; SK_Steam_ClearPopups
	jmp	SHORT $LN8@ResetCEGUI
__catch$?ResetCEGUI_D3D11@@YAXPAUIDXGISwapChain@@@Z$0:

; 426  :       }
; 427  : 
; 428  :       catch (...)
; 429  :       {
; 430  :         pDevCtx->RSSetViewports (1, &vp_orig);

	mov	eax, DWORD PTR _pDevCtx$7[ebp]
	lea	edx, DWORD PTR _vp_orig$3[ebp]
	push	edx
	push	1
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+176]

; 431  : 
; 432  :         cegD3D11 = nullptr;

	mov	DWORD PTR ?cegD3D11@@3PAVDirect3D11Renderer@CEGUI@@A, 0 ; cegD3D11

; 433  :         return;

	mov	eax, $LN17@ResetCEGUI
	ret	0
$LN17@ResetCEGUI:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	jmp	SHORT $LN100@ResetCEGUI
$LN7@ResetCEGUI:

; 434  :       }
; 435  : 
; 436  :       SK_CEGUI_InitBase    ();
; 437  : 
; 438  :       SK_PopupManager::getInstance       ()->destroyAllPopups (        );
; 439  :       SK_TextOverlayManager::getInstance ()->resetAllOverlays (cegD3D11);
; 440  : 
; 441  :       SK_Steam_ClearPopups ();
; 442  :     }
; 443  : 
; 444  :     else
; 445  :     {
; 446  :       dll_log.Log ( L"[   DXGI   ]  ** Failed to acquire SwapChain's Backbuffer;"

	push	OFFSET $SG352458
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8
$LN8@ResetCEGUI:

; 449  :   }

	mov	BYTE PTR __$EHRec$[ebp+12], 1
$LN100@ResetCEGUI:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	mov	eax, DWORD PTR _pBackBuffer$6[ebp]
	test	eax, eax
	je	SHORT $LN75@ResetCEGUI

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN75@ResetCEGUI:

; 176  :         if (p)

	mov	eax, DWORD PTR _pDevCtx$7[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 449  :   }

	mov	BYTE PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN84@ResetCEGUI

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN84@ResetCEGUI:

; 176  :         if (p)

	mov	eax, DWORD PTR _pDev$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 450  : }

	mov	DWORD PTR __$EHRec$[ebp+12], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN90@ResetCEGUI

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN90@ResetCEGUI:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 450  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ResetCEGUI_D3D11@@YAXPAUIDXGISwapChain@@@Z$2:
	lea	ecx, DWORD PTR _pDev$[ebp]
	jmp	??1?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ
__unwindfunclet$?ResetCEGUI_D3D11@@YAXPAUIDXGISwapChain@@@Z$3:
	lea	ecx, DWORD PTR _pDevCtx$7[ebp]
	jmp	??1?$CComQIPtr@UID3D11DeviceContext@@$1?_GUID_c0bfa96c_e089_44fb_8eaf_26f8796190da@@3U__s_GUID@@B@ATL@@QAE@XZ
__unwindfunclet$?ResetCEGUI_D3D11@@YAXPAUIDXGISwapChain@@@Z$4:
	lea	ecx, DWORD PTR _pBackBuffer$6[ebp]
	jmp	??1?$CComPtr@UID3D11Texture2D@@@ATL@@QAE@XZ
__ehhandler$?ResetCEGUI_D3D11@@YAXPAUIDXGISwapChain@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ResetCEGUI_D3D11@@YAXPAUIDXGISwapChain@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ResetCEGUI_D3D11@@YAXPAUIDXGISwapChain@@@Z ENDP	; ResetCEGUI_D3D11
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3766 : 	{	// return string + string

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 3767 : 	if (_Right.size() <= _Left.capacity() - _Left.size()
; 3768 : 		|| _Right.capacity() - _Right.size() < _Left.size())

	mov	edx, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	DWORD PTR $T1[ebp], 0
	mov	eax, DWORD PTR [edx+20]
	sub	eax, DWORD PTR [edx+16]
	cmp	DWORD PTR [ecx+16], eax
	jbe	SHORT $LN4@operator
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR [edx+16]
	jb	SHORT $LN4@operator

; 2457 : 		return (insert(_Off, _Right, 0, npos));

	push	-1
	push	0
	push	edx
	push	0
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 3770 : 	else
; 3771 : 		return (_STD move(_Right.insert(0, _Left)));

	jmp	SHORT $LN206@operator
$LN4@operator:

; 2284 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	ecx
	mov	ecx, edx
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN206@operator:

; 1595 : 		_Mysize(0),

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 1596 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 2143 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3769 : 		return (_STD move(_Left.append(_Right)));

	mov	eax, ecx

; 3772 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\depends\include\cegui\system.h
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\system.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\size.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\system.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\size.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_szRootPath$2 = -816					; size = 262
_dataPathPrefix$3 = -552				; size = 152
$T4 = -400						; size = 24
$T5 = -376						; size = 152
$T6 = -376						; size = 152
$T7 = -376						; size = 152
$T8 = -376						; size = 152
$T9 = -376						; size = 152
$T10 = -376						; size = 152
$T11 = -376						; size = 152
$T12 = -376						; size = 152
$T13 = -376						; size = 152
$T14 = -376						; size = 152
$T15 = -376						; size = 152
$T16 = -376						; size = 152
$T17 = -376						; size = 152
$T18 = -376						; size = 152
$T19 = -376						; size = 152
$T20 = -376						; size = 152
$T21 = -376						; size = 152
$T22 = -376						; size = 152
$T23 = -376						; size = 152
$T24 = -224						; size = 24
$T25 = -200						; size = 24
$T26 = -176						; size = 152
$T27 = -176						; size = 152
$T28 = -176						; size = 152
$T29 = -176						; size = 152
$T30 = -176						; size = 152
$T31 = -176						; size = 152
$T32 = -176						; size = 152
$T33 = -176						; size = 152
$T34 = -176						; size = 152
$T35 = -176						; size = 152
$T36 = -176						; size = 152
$T37 = -176						; size = 152
$T38 = -176						; size = 152
$T39 = -176						; size = 152
$T40 = -176						; size = 152
$T41 = -176						; size = 152
$T42 = -176						; size = 152
$T43 = -176						; size = 152
$T44 = -176						; size = 152
$T45 = -176						; size = 152
$T46 = -176						; size = 152
$T47 = -176						; size = 152
$T48 = -176						; size = 152
$T49 = -176						; size = 152
$T50 = -176						; size = 152
$T51 = -24						; size = 8
_rp$1$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
?SK_CEGUI_InitBase@@YAXXZ PROC				; SK_CEGUI_InitBase

; 209  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SK_CEGUI_InitBase@@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 804				; 00000324H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp

; 210  :   try

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 211  :   {
; 212  :     // initialise the required dirs for the DefaultResourceProvider
; 213  :     auto* rp =
; 214  :         dynamic_cast <CEGUI::DefaultResourceProvider *>
; 215  :             (CEGUI::System::getDllSingleton ().getResourceProvider ());

	call	DWORD PTR __imp_?getDllSingleton@?$Singleton@VSystem@CEGUI@@@CEGUI@@SAAAVSystem@2@XZ
	mov	ecx, eax
	call	DWORD PTR __imp_?getResourceProvider@System@CEGUI@@QBEPAVResourceProvider@2@XZ
	push	0
	push	OFFSET ??_R0?AVDefaultResourceProvider@CEGUI@@@8
	push	OFFSET ??_R0?AVResourceProvider@CEGUI@@@8
	push	0
	push	eax
	call	___RTDynamicCast
	add	esp, 20					; 00000014H
	mov	edi, eax

; 216  : 
; 217  :          char szRootPath [MAX_PATH + 2] = { };

	lea	eax, DWORD PTR _szRootPath$2[ebp]
	mov	DWORD PTR _rp$1$[ebp], edi
	push	262					; 00000106H
	push	0
	push	eax
	call	_memset

; 218  :     snprintf (szRootPath, MAX_PATH, "%ws", _wgetenv (L"CEGUI_PARENT_DIR"));

	push	OFFSET $SG352239
	call	DWORD PTR __imp___wgetenv
	push	eax
	push	OFFSET $SG352240
	lea	eax, DWORD PTR _szRootPath$2[ebp]
	push	260					; 00000104H
	push	eax
	call	__snprintf
	add	esp, 32					; 00000020H

; 219  :               szRootPath [MAX_PATH] = '\0';

	mov	BYTE PTR _szRootPath$2[ebp+260], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	ecx, DWORD PTR $T24[ebp]

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR $T24[ebp+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T24[ebp+20], 15		; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR $T24[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	15					; 0000000fH
	push	OFFSET $SG352241
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

	lea	ecx, DWORD PTR _szRootPath$2[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 221  :     CEGUI::String dataPathPrefix ( ( std::string (szRootPath) +

	mov	BYTE PTR __$EHRec$[ebp+12], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR $T25[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

	lea	edx, DWORD PTR [ecx+1]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T25[ebp+20], 15		; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR $T25[ebp], 0
	npad	5
$LL842@SK_CEGUI_I:

; 480  : 		return (_CSTD strlen(_First));

	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL842@SK_CEGUI_I
	sub	ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	eax, DWORD PTR _szRootPath$2[ebp]
	push	ecx
	push	eax
	lea	ecx, DWORD PTR $T25[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 221  :     CEGUI::String dataPathPrefix ( ( std::string (szRootPath) +

	lea	eax, DWORD PTR $T24[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	push	eax
	lea	eax, DWORD PTR $T25[ebp]
	push	eax
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	esi, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 221  :     CEGUI::String dataPathPrefix ( ( std::string (szRootPath) +

	mov	BYTE PTR __$EHRec$[ebp+12], 3
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN119@SK_CEGUI_I
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN119@SK_CEGUI_I:
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	lea	ecx, DWORD PTR _dataPathPrefix$3[ebp]
	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	mov	ecx, esi
	lea	edx, DWORD PTR [ecx+1]
	npad	4
$LL843@SK_CEGUI_I:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL843@SK_CEGUI_I
	sub	ecx, edx
	push	ecx
	push	esi
	lea	ecx, DWORD PTR _dataPathPrefix$3[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T4[ebp+20]
	cmp	eax, 16					; 00000010H

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN143@SK_CEGUI_I

; 3609 : 			{
; 3610 : 			pointer _Ptr = _My_data._Bx._Ptr;
; 3611 : 			auto& _Al = this->_Getal();
; 3612 : 			_Al.destroy(_STD addressof(_My_data._Bx._Ptr));
; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	eax
	push	DWORD PTR $T4[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN143@SK_CEGUI_I:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR $T4[ebp+16], 0

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T4[ebp+20], 15		; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR $T4[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T25[ebp+20]
	cmp	eax, 16					; 00000010H

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN173@SK_CEGUI_I

; 3609 : 			{
; 3610 : 			pointer _Ptr = _My_data._Bx._Ptr;
; 3611 : 			auto& _Al = this->_Getal();
; 3612 : 			_Al.destroy(_STD addressof(_My_data._Bx._Ptr));
; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	eax
	push	DWORD PTR $T25[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN173@SK_CEGUI_I:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR $T25[ebp+16], 0

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T25[ebp+20], 15		; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR $T25[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T24[ebp+20]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 221  :     CEGUI::String dataPathPrefix ( ( std::string (szRootPath) +

	mov	BYTE PTR __$EHRec$[ebp+12], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	eax, 16					; 00000010H

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN203@SK_CEGUI_I

; 3609 : 			{
; 3610 : 			pointer _Ptr = _My_data._Bx._Ptr;
; 3611 : 			auto& _Al = this->_Getal();
; 3612 : 			_Al.destroy(_STD addressof(_My_data._Bx._Ptr));
; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	eax
	push	DWORD PTR $T24[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN203@SK_CEGUI_I:
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	lea	ecx, DWORD PTR $T50[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR $T24[ebp+16], 0

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T24[ebp+20], 15		; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR $T24[ebp], 0
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	7
	push	OFFSET $SG352243
	lea	ecx, DWORD PTR $T50[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 228  :     rp->setResourceGroupDirectory("schemes",

	mov	ebx, DWORD PTR __imp_??HCEGUI@@YA?AVString@0@ABV10@PBE@Z
	lea	eax, DWORD PTR _dataPathPrefix$3[ebp]
	push	OFFSET $SG352242
	push	eax
	lea	eax, DWORD PTR $T23[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 8
	push	eax
	call	ebx
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR $T50[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 9
	mov	ecx, edi
	mov	edi, DWORD PTR __imp_?setResourceGroupDirectory@DefaultResourceProvider@CEGUI@@QAEXABVString@2@0@Z
	push	eax
	call	edi
	mov	esi, DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
	lea	ecx, DWORD PTR $T23[ebp]
	call	esi
	lea	ecx, DWORD PTR $T50[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	call	esi
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	lea	ecx, DWORD PTR $T49[ebp]
	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	9
	push	OFFSET $SG352245
	lea	ecx, DWORD PTR $T49[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 230  :     rp->setResourceGroupDirectory("imagesets",

	push	OFFSET $SG352244
	lea	eax, DWORD PTR _dataPathPrefix$3[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 10		; 0000000aH
	push	eax
	lea	eax, DWORD PTR $T22[ebp]
	push	eax
	call	ebx
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _rp$1$[ebp]
	push	eax
	lea	eax, DWORD PTR $T49[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 11		; 0000000bH
	push	eax
	call	edi
	lea	ecx, DWORD PTR $T22[ebp]
	call	esi
	lea	ecx, DWORD PTR $T49[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	call	esi
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	lea	ecx, DWORD PTR $T48[ebp]
	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	5
	push	OFFSET $SG352247
	lea	ecx, DWORD PTR $T48[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 232  :     rp->setResourceGroupDirectory("fonts",

	push	OFFSET $SG352246
	lea	eax, DWORD PTR _dataPathPrefix$3[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 12		; 0000000cH
	push	eax
	lea	eax, DWORD PTR $T21[ebp]
	push	eax
	call	ebx
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _rp$1$[ebp]
	push	eax
	lea	eax, DWORD PTR $T48[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 13		; 0000000dH
	push	eax
	call	edi
	lea	ecx, DWORD PTR $T21[ebp]
	call	esi
	lea	ecx, DWORD PTR $T48[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	call	esi
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	lea	ecx, DWORD PTR $T47[ebp]
	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	7
	push	OFFSET $SG352249
	lea	ecx, DWORD PTR $T47[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 234  :     rp->setResourceGroupDirectory("layouts",

	push	OFFSET $SG352248
	lea	eax, DWORD PTR _dataPathPrefix$3[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 14		; 0000000eH
	push	eax
	lea	eax, DWORD PTR $T20[ebp]
	push	eax
	call	ebx
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _rp$1$[ebp]
	push	eax
	lea	eax, DWORD PTR $T47[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 15		; 0000000fH
	push	eax
	call	edi
	lea	ecx, DWORD PTR $T20[ebp]
	call	esi
	lea	ecx, DWORD PTR $T47[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	call	esi
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	lea	ecx, DWORD PTR $T46[ebp]
	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	10					; 0000000aH
	push	OFFSET $SG352251
	lea	ecx, DWORD PTR $T46[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 236  :     rp->setResourceGroupDirectory("looknfeels",

	push	OFFSET $SG352250
	lea	eax, DWORD PTR _dataPathPrefix$3[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 16		; 00000010H
	push	eax
	lea	eax, DWORD PTR $T19[ebp]
	push	eax
	call	ebx
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _rp$1$[ebp]
	push	eax
	lea	eax, DWORD PTR $T46[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 17		; 00000011H
	push	eax
	call	edi
	lea	ecx, DWORD PTR $T19[ebp]
	call	esi
	lea	ecx, DWORD PTR $T46[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	call	esi
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	lea	ecx, DWORD PTR $T45[ebp]
	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	11					; 0000000bH
	push	OFFSET $SG352253
	lea	ecx, DWORD PTR $T45[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 238  :     rp->setResourceGroupDirectory("lua_scripts",

	push	OFFSET $SG352252
	lea	eax, DWORD PTR _dataPathPrefix$3[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 18		; 00000012H
	push	eax
	lea	eax, DWORD PTR $T18[ebp]
	push	eax
	call	ebx
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _rp$1$[ebp]
	push	eax
	lea	eax, DWORD PTR $T45[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 19		; 00000013H
	push	eax
	call	edi
	lea	ecx, DWORD PTR $T18[ebp]
	call	esi
	lea	ecx, DWORD PTR $T45[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	call	esi
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	lea	ecx, DWORD PTR $T44[ebp]
	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	7
	push	OFFSET $SG352255
	lea	ecx, DWORD PTR $T44[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 240  :     rp->setResourceGroupDirectory("schemas",

	push	OFFSET $SG352254
	lea	eax, DWORD PTR _dataPathPrefix$3[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 20		; 00000014H
	push	eax
	lea	eax, DWORD PTR $T17[ebp]
	push	eax
	call	ebx
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _rp$1$[ebp]
	push	eax
	lea	eax, DWORD PTR $T44[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 21		; 00000015H
	push	eax
	call	edi
	lea	ecx, DWORD PTR $T17[ebp]
	call	esi
	lea	ecx, DWORD PTR $T44[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	call	esi
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	lea	ecx, DWORD PTR $T43[ebp]
	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	10					; 0000000aH
	push	OFFSET $SG352257
	lea	ecx, DWORD PTR $T43[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 242  :     rp->setResourceGroupDirectory("animations",

	push	OFFSET $SG352256
	lea	eax, DWORD PTR _dataPathPrefix$3[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 22		; 00000016H
	push	eax
	lea	eax, DWORD PTR $T16[ebp]
	push	eax
	call	ebx
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _rp$1$[ebp]
	push	eax
	lea	eax, DWORD PTR $T43[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 23		; 00000017H
	push	eax
	call	edi
	lea	ecx, DWORD PTR $T16[ebp]
	call	esi
	lea	ecx, DWORD PTR $T43[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	call	esi
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	lea	ecx, DWORD PTR $T42[ebp]
	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	9
	push	OFFSET $SG352258
	lea	ecx, DWORD PTR $T42[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 246  :     CEGUI::ImageManager::setImagesetDefaultResourceGroup ("imagesets");

	lea	eax, DWORD PTR $T42[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 24		; 00000018H
	push	eax
	call	DWORD PTR __imp_?setImagesetDefaultResourceGroup@ImageManager@CEGUI@@SAXABVString@2@@Z
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	lea	ecx, DWORD PTR $T42[ebp]
	call	esi
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	lea	ecx, DWORD PTR $T41[ebp]
	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	5
	push	OFFSET $SG352259
	lea	ecx, DWORD PTR $T41[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 248  :     CEGUI::Font::setDefaultResourceGroup                 ("fonts");

	lea	eax, DWORD PTR $T41[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 25		; 00000019H
	push	eax
	call	DWORD PTR __imp_?setDefaultResourceGroup@Font@CEGUI@@SAXABVString@2@@Z
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	lea	ecx, DWORD PTR $T41[ebp]
	call	esi
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	lea	ecx, DWORD PTR $T40[ebp]
	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	7
	push	OFFSET $SG352260
	lea	ecx, DWORD PTR $T40[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 249  :     CEGUI::Scheme::setDefaultResourceGroup               ("schemes");

	lea	eax, DWORD PTR $T40[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 26		; 0000001aH
	push	eax
	call	DWORD PTR __imp_?setDefaultResourceGroup@Scheme@CEGUI@@SAXABVString@2@@Z
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	lea	ecx, DWORD PTR $T40[ebp]
	call	esi
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	lea	ecx, DWORD PTR $T39[ebp]
	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	10					; 0000000aH
	push	OFFSET $SG352261
	lea	ecx, DWORD PTR $T39[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 250  :     CEGUI::WidgetLookManager::setDefaultResourceGroup    ("looknfeels");

	lea	eax, DWORD PTR $T39[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 27		; 0000001bH
	push	eax
	call	DWORD PTR __imp_?setDefaultResourceGroup@WidgetLookManager@CEGUI@@SAXABVString@2@@Z
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	lea	ecx, DWORD PTR $T39[ebp]
	call	esi
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	lea	ecx, DWORD PTR $T38[ebp]
	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	7
	push	OFFSET $SG352262
	lea	ecx, DWORD PTR $T38[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 251  :     CEGUI::WindowManager::setDefaultResourceGroup        ("layouts");

	lea	eax, DWORD PTR $T38[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 28		; 0000001cH
	push	eax
	call	DWORD PTR __imp_?setDefaultResourceGroup@WindowManager@CEGUI@@SAXABVString@2@@Z
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	lea	ecx, DWORD PTR $T38[ebp]
	call	esi
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	lea	ecx, DWORD PTR $T37[ebp]
	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	11					; 0000000bH
	push	OFFSET $SG352263
	lea	ecx, DWORD PTR $T37[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 252  :     CEGUI::ScriptModule::setDefaultResourceGroup         ("lua_scripts");

	lea	eax, DWORD PTR $T37[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 29		; 0000001dH
	push	eax
	call	DWORD PTR __imp_?setDefaultResourceGroup@ScriptModule@CEGUI@@SAXABVString@2@@Z
	add	esp, 4
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	lea	ecx, DWORD PTR $T37[ebp]
	call	esi
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	lea	ecx, DWORD PTR $T36[ebp]
	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	10					; 0000000aH
	push	OFFSET $SG352264
	lea	ecx, DWORD PTR $T36[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 253  :     CEGUI::AnimationManager::setDefaultResourceGroup     ("animations");

	lea	eax, DWORD PTR $T36[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 30		; 0000001eH
	push	eax
	call	DWORD PTR __imp_?setDefaultResourceGroup@AnimationManager@CEGUI@@SAXABVString@2@@Z
	add	esp, 4
	lea	ecx, DWORD PTR $T36[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	call	esi

; 256  :       CEGUI::SchemeManager::getDllSingletonPtr ();

	call	DWORD PTR __imp_?getDllSingletonPtr@?$Singleton@VSchemeManager@CEGUI@@@CEGUI@@SAPAVSchemeManager@2@XZ
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	lea	ecx, DWORD PTR $T15[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 256  :       CEGUI::SchemeManager::getDllSingletonPtr ();

	mov	ebx, eax
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	0
	push	OFFSET $SG352265
	lea	ecx, DWORD PTR $T15[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z

; 573  : 		init();

	lea	ecx, DWORD PTR $T35[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 258  :     pSchemeMgr->createFromFile ("VanillaSkin.scheme");

	mov	BYTE PTR __$EHRec$[ebp+12], 31		; 0000001fH
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	18					; 00000012H
	push	OFFSET $SG352266
	lea	ecx, DWORD PTR $T35[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 258  :     pSchemeMgr->createFromFile ("VanillaSkin.scheme");

	mov	edi, DWORD PTR __imp_?createFromFile@?$NamedXMLResourceManager@VScheme@CEGUI@@VScheme_xmlHandler@2@@CEGUI@@QAEAAVScheme@2@ABVString@2@0W4XMLResourceExistsAction@2@@Z
	lea	eax, DWORD PTR $T15[ebp]
	push	0
	push	eax
	lea	eax, DWORD PTR $T35[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 32		; 00000020H
	push	eax
	mov	ecx, ebx
	call	edi
	lea	ecx, DWORD PTR $T35[ebp]
	call	esi
	lea	ecx, DWORD PTR $T15[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	call	esi
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	lea	ecx, DWORD PTR $T34[ebp]
	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	0
	push	OFFSET $SG352267
	lea	ecx, DWORD PTR $T34[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z

; 573  : 		init();

	lea	ecx, DWORD PTR $T14[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 259  :     pSchemeMgr->createFromFile ("TaharezLook.scheme");

	mov	BYTE PTR __$EHRec$[ebp+12], 33		; 00000021H
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	18					; 00000012H
	push	OFFSET $SG352268
	lea	ecx, DWORD PTR $T14[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 259  :     pSchemeMgr->createFromFile ("TaharezLook.scheme");

	push	0
	lea	eax, DWORD PTR $T34[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 34		; 00000022H
	push	eax
	lea	eax, DWORD PTR $T14[ebp]
	mov	ecx, ebx
	push	eax
	call	edi
	lea	ecx, DWORD PTR $T14[ebp]
	call	esi
	lea	ecx, DWORD PTR $T34[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	call	esi

; 262  :       CEGUI::FontManager::getDllSingletonPtr ();

	call	DWORD PTR __imp_?getDllSingletonPtr@?$Singleton@VFontManager@CEGUI@@@CEGUI@@SAPAVFontManager@2@XZ
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	lea	ecx, DWORD PTR $T33[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 262  :       CEGUI::FontManager::getDllSingletonPtr ();

	mov	ebx, eax
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	0
	push	OFFSET $SG352269
	lea	ecx, DWORD PTR $T33[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z

; 573  : 		init();

	lea	ecx, DWORD PTR $T13[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 264  :     pFontMgr->createFromFile ("DejaVuSans-10-NoScale.font");

	mov	BYTE PTR __$EHRec$[ebp+12], 35		; 00000023H
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	26					; 0000001aH
	push	OFFSET $SG352270
	lea	ecx, DWORD PTR $T13[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 264  :     pFontMgr->createFromFile ("DejaVuSans-10-NoScale.font");

	mov	BYTE PTR __$EHRec$[ebp+12], 36		; 00000024H
	push	0
	mov	edi, DWORD PTR __imp_?createFromFile@?$NamedXMLResourceManager@VFont@CEGUI@@VFont_xmlHandler@2@@CEGUI@@QAEAAVFont@2@ABVString@2@0W4XMLResourceExistsAction@2@@Z
	lea	eax, DWORD PTR $T33[ebp]
	push	eax
	lea	eax, DWORD PTR $T13[ebp]
	mov	ecx, ebx
	push	eax
	call	edi
	lea	ecx, DWORD PTR $T13[ebp]
	call	esi
	lea	ecx, DWORD PTR $T33[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	call	esi
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	lea	ecx, DWORD PTR $T32[ebp]
	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	0
	push	OFFSET $SG352271
	lea	ecx, DWORD PTR $T32[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z

; 573  : 		init();

	lea	ecx, DWORD PTR $T12[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 265  :     pFontMgr->createFromFile ("DejaVuSans-12-NoScale.font");

	mov	BYTE PTR __$EHRec$[ebp+12], 37		; 00000025H
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	26					; 0000001aH
	push	OFFSET $SG352272
	lea	ecx, DWORD PTR $T12[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 265  :     pFontMgr->createFromFile ("DejaVuSans-12-NoScale.font");

	push	0
	lea	eax, DWORD PTR $T32[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 38		; 00000026H
	push	eax
	lea	eax, DWORD PTR $T12[ebp]
	mov	ecx, ebx
	push	eax
	call	edi
	lea	ecx, DWORD PTR $T12[ebp]
	call	esi
	lea	ecx, DWORD PTR $T32[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	call	esi
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	lea	ecx, DWORD PTR $T31[ebp]
	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	0
	push	OFFSET $SG352273
	lea	ecx, DWORD PTR $T31[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z

; 573  : 		init();

	lea	ecx, DWORD PTR $T11[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 266  :     pFontMgr->createFromFile ("Jura-18-NoScale.font");

	mov	BYTE PTR __$EHRec$[ebp+12], 39		; 00000027H
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	20					; 00000014H
	push	OFFSET $SG352274
	lea	ecx, DWORD PTR $T11[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 266  :     pFontMgr->createFromFile ("Jura-18-NoScale.font");

	push	0
	lea	eax, DWORD PTR $T31[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 40		; 00000028H
	push	eax
	lea	eax, DWORD PTR $T11[ebp]
	mov	ecx, ebx
	push	eax
	call	edi
	lea	ecx, DWORD PTR $T11[ebp]
	call	esi
	lea	ecx, DWORD PTR $T31[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	call	esi
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	lea	ecx, DWORD PTR $T30[ebp]
	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	0
	push	OFFSET $SG352275
	lea	ecx, DWORD PTR $T30[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z

; 573  : 		init();

	lea	ecx, DWORD PTR $T10[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 267  :     pFontMgr->createFromFile ("Jura-13-NoScale.font");

	mov	BYTE PTR __$EHRec$[ebp+12], 41		; 00000029H
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	20					; 00000014H
	push	OFFSET $SG352276
	lea	ecx, DWORD PTR $T10[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 267  :     pFontMgr->createFromFile ("Jura-13-NoScale.font");

	push	0
	lea	eax, DWORD PTR $T30[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 42		; 0000002aH
	push	eax
	lea	eax, DWORD PTR $T10[ebp]
	mov	ecx, ebx
	push	eax
	call	edi
	lea	ecx, DWORD PTR $T10[ebp]
	call	esi
	lea	ecx, DWORD PTR $T30[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	call	esi
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	lea	ecx, DWORD PTR $T29[ebp]
	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	0
	push	OFFSET $SG352277
	lea	ecx, DWORD PTR $T29[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z

; 573  : 		init();

	lea	ecx, DWORD PTR $T9[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 268  :     pFontMgr->createFromFile ("Jura-10-NoScale.font");

	mov	BYTE PTR __$EHRec$[ebp+12], 43		; 0000002bH
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	20					; 00000014H
	push	OFFSET $SG352278
	lea	ecx, DWORD PTR $T9[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 268  :     pFontMgr->createFromFile ("Jura-10-NoScale.font");

	push	0
	lea	eax, DWORD PTR $T29[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 44		; 0000002cH
	push	eax
	lea	eax, DWORD PTR $T9[ebp]
	mov	ecx, ebx
	push	eax
	call	edi
	lea	ecx, DWORD PTR $T9[ebp]
	call	esi
	lea	ecx, DWORD PTR $T29[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	call	esi

; 269  : 
; 270  :     const CEGUI::System* pSys =
; 271  :       CEGUI::System::getDllSingletonPtr ();

	call	DWORD PTR __imp_?getDllSingletonPtr@?$Singleton@VSystem@CEGUI@@@CEGUI@@SAPAVSystem@2@XZ
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	lea	ecx, DWORD PTR $T8[ebp]
; File c:\users\andon\source\repos\specialk\depends\include\cegui\system.h

; 338  :     XMLParser* getXMLParser(void) const     { return d_xmlParser; }

	mov	edi, DWORD PTR [eax+192]
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	26					; 0000001aH
	push	OFFSET $SG352281
	lea	ecx, DWORD PTR $T8[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 277  :     if (parser->isPropertyPresent ("SchemaDefaultResourceGroup"))

	lea	eax, DWORD PTR $T8[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 45		; 0000002dH
	push	eax
	mov	ecx, edi
	call	DWORD PTR __imp_?isPropertyPresent@PropertySet@CEGUI@@QBE_NABVString@2@@Z
	lea	ecx, DWORD PTR $T8[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	mov	bl, al
	call	esi
	test	bl, bl
	je	SHORT $LN3@SK_CEGUI_I
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	lea	ecx, DWORD PTR $T28[ebp]
	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	7
	push	OFFSET $SG352282
	lea	ecx, DWORD PTR $T28[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z

; 573  : 		init();

	lea	ecx, DWORD PTR $T7[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 278  :       parser->setProperty ("SchemaDefaultResourceGroup", "schemas");

	mov	BYTE PTR __$EHRec$[ebp+12], 46		; 0000002eH
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	26					; 0000001aH
	push	OFFSET $SG352283
	lea	ecx, DWORD PTR $T7[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 278  :       parser->setProperty ("SchemaDefaultResourceGroup", "schemas");

	lea	eax, DWORD PTR $T28[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 47		; 0000002fH
	push	eax
	lea	eax, DWORD PTR $T7[ebp]
	mov	ecx, edi
	push	eax
	call	DWORD PTR __imp_?setProperty@PropertySet@CEGUI@@QAEXABVString@2@0@Z
	lea	ecx, DWORD PTR $T7[ebp]
	call	esi
	lea	ecx, DWORD PTR $T28[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	call	esi
$LN3@SK_CEGUI_I:

; 281  :     if ( CEGUI::System::getDllSingleton ().getRenderer ()->getDisplaySize () ==

	mov	ebx, DWORD PTR __imp_?getDllSingleton@?$Singleton@VSystem@CEGUI@@@CEGUI@@SAAAVSystem@2@XZ
	call	ebx
; File c:\users\andon\source\repos\specialk\depends\include\cegui\system.h

; 192  : 	Renderer*	getRenderer(void) const			{return d_renderer;}

	mov	ecx, DWORD PTR [eax+20]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 281  :     if ( CEGUI::System::getDllSingleton ().getRenderer ()->getDisplaySize () ==

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+72]
	mov	ecx, eax
	xorps	xmm1, xmm1
; File c:\users\andon\source\repos\specialk\depends\include\cegui\size.h

; 87   :         return d_width == other.d_width && d_height == other.d_height;

	movss	xmm0, DWORD PTR [ecx]
	ucomiss	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@SK_CEGUI_I
	movss	xmm0, DWORD PTR [ecx+4]
	ucomiss	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@SK_CEGUI_I
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 284  :       CEGUI::System::getDllSingleton ().getRenderer ()->setDisplaySize (

	call	ebx
	movd	xmm0, DWORD PTR ?game_window@@3Usk_window_s@@A+152
	lea	edx, DWORD PTR $T51[ebp]
	movd	xmm1, DWORD PTR ?game_window@@3Usk_window_s@@A+156
	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\depends\include\cegui\system.h

; 192  : 	Renderer*	getRenderer(void) const			{return d_renderer;}

	mov	ecx, DWORD PTR [eax+20]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 284  :       CEGUI::System::getDllSingleton ().getRenderer ()->setDisplaySize (

	push	edx
	cvtdq2ps xmm1, xmm1
; File c:\users\andon\source\repos\specialk\depends\include\cegui\size.h

; 76   :         d_width(width),

	movss	DWORD PTR $T51[ebp], xmm0

; 77   :         d_height(height)

	movss	DWORD PTR $T51[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 284  :       CEGUI::System::getDllSingleton ().getRenderer ()->setDisplaySize (

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+68]
$LN4@SK_CEGUI_I:

; 306  :     CEGUI::WindowManager& window_mgr =

	call	DWORD PTR __imp_?getDllSingleton@?$Singleton@VWindowManager@CEGUI@@@CEGUI@@SAAAVWindowManager@2@XZ
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	lea	ecx, DWORD PTR $T27[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 306  :     CEGUI::WindowManager& window_mgr =

	mov	edi, eax
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	4
	push	OFFSET $SG352285
	lea	ecx, DWORD PTR $T27[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z

; 573  : 		init();

	lea	ecx, DWORD PTR $T6[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 310  :       window_mgr.createWindow ("DefaultWindow", "root");

	mov	BYTE PTR __$EHRec$[ebp+12], 48		; 00000030H
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	13					; 0000000dH
	push	OFFSET $SG352286
	lea	ecx, DWORD PTR $T6[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 310  :       window_mgr.createWindow ("DefaultWindow", "root");

	lea	eax, DWORD PTR $T27[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 49		; 00000031H
	push	eax
	lea	eax, DWORD PTR $T6[ebp]
	mov	ecx, edi
	push	eax
	call	DWORD PTR __imp_?createWindow@WindowManager@CEGUI@@QAEPAVWindow@2@ABVString@2@0@Z
	lea	ecx, DWORD PTR $T6[ebp]
	mov	ebx, eax
	call	esi
	lea	ecx, DWORD PTR $T27[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 7
	call	esi

; 311  : 
; 312  :     CEGUI::System::getDllSingleton ().getDefaultGUIContext ().setRootWindow (root);

	call	DWORD PTR __imp_?getDllSingleton@?$Singleton@VSystem@CEGUI@@@CEGUI@@SAAAVSystem@2@XZ
	mov	ecx, eax
	call	DWORD PTR __imp_?getDefaultGUIContext@System@CEGUI@@QBEAAVGUIContext@2@XZ
	push	ebx
	mov	ecx, eax
	call	DWORD PTR __imp_?setRootWindow@GUIContext@CEGUI@@QAEXPAVWindow@2@@Z
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	lea	ecx, DWORD PTR $T26[ebp]
	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	0
	push	OFFSET $SG352287
	lea	ecx, DWORD PTR $T26[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z

; 573  : 		init();

	lea	ecx, DWORD PTR $T5[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 317  :     SK_achv_popup =

	mov	BYTE PTR __$EHRec$[ebp+12], 50		; 00000032H
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	19					; 00000013H
	push	OFFSET $SG352288
	lea	ecx, DWORD PTR $T5[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 317  :     SK_achv_popup =

	push	0
	push	0
	lea	eax, DWORD PTR $T26[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 51		; 00000033H
	push	eax
	lea	eax, DWORD PTR $T5[ebp]
	mov	ecx, edi
	push	eax
	call	DWORD PTR __imp_?loadLayoutFromFile@WindowManager@CEGUI@@QAEPAVWindow@2@ABVString@2@0P6A_NPAV32@AAV42@2PAX@Z3@Z
	lea	ecx, DWORD PTR $T5[ebp]
	mov	DWORD PTR ?SK_achv_popup@@3PAVWindow@CEGUI@@A, eax ; SK_achv_popup
	call	esi
	lea	ecx, DWORD PTR $T26[ebp]
	call	esi

; 318  :       window_mgr.loadLayoutFromFile ("Achievements.layout");
; 319  :  }

	lea	ecx, DWORD PTR _dataPathPrefix$3[ebp]
	call	esi
$LN57@SK_CEGUI_I:
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
	mov	DWORD PTR __$EHRec$[ebp+12], -1
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 324  : 
; 325  :   SK_Steam_ClearPopups ();
; 326  : }

	call	?SK_Steam_ClearPopups@@YAXXZ		; SK_Steam_ClearPopups
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
__catch$?SK_CEGUI_InitBase@@YAXXZ$0:

; 320  : 
; 321  :  catch (...)
; 322  :  {
; 323  :  }

	mov	eax, $LN57@SK_CEGUI_I
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$2:
	lea	ecx, DWORD PTR $T24[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$3:
	lea	ecx, DWORD PTR $T25[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$4:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$5:
	lea	ecx, DWORD PTR _dataPathPrefix$3[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$6:
	lea	ecx, DWORD PTR $T50[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$7:
	lea	ecx, DWORD PTR $T23[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$8:
	lea	ecx, DWORD PTR $T49[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$9:
	lea	ecx, DWORD PTR $T22[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$10:
	lea	ecx, DWORD PTR $T48[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$11:
	lea	ecx, DWORD PTR $T21[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$12:
	lea	ecx, DWORD PTR $T47[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$13:
	lea	ecx, DWORD PTR $T20[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$14:
	lea	ecx, DWORD PTR $T46[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$15:
	lea	ecx, DWORD PTR $T19[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$16:
	lea	ecx, DWORD PTR $T45[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$17:
	lea	ecx, DWORD PTR $T18[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$18:
	lea	ecx, DWORD PTR $T44[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$19:
	lea	ecx, DWORD PTR $T17[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$20:
	lea	ecx, DWORD PTR $T43[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$21:
	lea	ecx, DWORD PTR $T16[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$22:
	lea	ecx, DWORD PTR $T42[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$23:
	lea	ecx, DWORD PTR $T41[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$24:
	lea	ecx, DWORD PTR $T40[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$25:
	lea	ecx, DWORD PTR $T39[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$26:
	lea	ecx, DWORD PTR $T38[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$27:
	lea	ecx, DWORD PTR $T37[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$28:
	lea	ecx, DWORD PTR $T36[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$29:
	lea	ecx, DWORD PTR $T15[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$30:
	lea	ecx, DWORD PTR $T35[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$31:
	lea	ecx, DWORD PTR $T34[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$32:
	lea	ecx, DWORD PTR $T14[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$33:
	lea	ecx, DWORD PTR $T33[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$34:
	lea	ecx, DWORD PTR $T13[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$35:
	lea	ecx, DWORD PTR $T32[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$36:
	lea	ecx, DWORD PTR $T12[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$37:
	lea	ecx, DWORD PTR $T31[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$38:
	lea	ecx, DWORD PTR $T11[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$39:
	lea	ecx, DWORD PTR $T30[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$40:
	lea	ecx, DWORD PTR $T10[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$41:
	lea	ecx, DWORD PTR $T29[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$42:
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$43:
	lea	ecx, DWORD PTR $T8[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$44:
	lea	ecx, DWORD PTR $T28[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$45:
	lea	ecx, DWORD PTR $T7[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$46:
	lea	ecx, DWORD PTR $T27[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$47:
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$48:
	lea	ecx, DWORD PTR $T26[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_InitBase@@YAXXZ$49:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__ehhandler$?SK_CEGUI_InitBase@@YAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?SK_CEGUI_InitBase@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_CEGUI_InitBase@@YAXXZ ENDP				; SK_CEGUI_InitBase
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
?SK_CEGUI_GetSystem@@YAPAVSystem@CEGUI@@XZ PROC		; SK_CEGUI_GetSystem

; 204  :   return CEGUI::System::getDllSingletonPtr ();

	jmp	DWORD PTR __imp_?getDllSingletonPtr@?$Singleton@VSystem@CEGUI@@@CEGUI@@SAPAVSystem@2@XZ
?SK_CEGUI_GetSystem@@YAPAVSystem@CEGUI@@XZ ENDP		; SK_CEGUI_GetSystem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_szNewLogPath$2 = -1876					; size = 1040
_wszNewLogPath$3 = -836					; size = 520
$T4 = -316						; size = 152
$T5 = -164						; size = 152
$T6 = -164						; size = 152
__$EHRec$ = -12						; size = 12
?SK_CEGUI_RelocateLog@@YAXXZ PROC			; SK_CEGUI_RelocateLog

; 173  : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?SK_CEGUI_RelocateLog@@YAXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 1864				; 00000748H

; 174  :   // Move the log file that this darn thing just created...
; 175  :   if (GetFileAttributesW (L"CEGUI.log") != INVALID_FILE_ATTRIBUTES)

	push	OFFSET $SG352119
	call	DWORD PTR __imp__GetFileAttributesW@4
	cmp	eax, -1
	je	$LN2@SK_CEGUI_R

; 176  :   {
; 177  :     char     szNewLogPath [MAX_PATH * 4] = { };

	push	1040					; 00000410H
	lea	eax, DWORD PTR _szNewLogPath$2[ebp]
	push	0
	push	eax
	call	_memset

; 178  :     wchar_t wszNewLogPath [MAX_PATH]     = { };

	push	520					; 00000208H
	lea	eax, DWORD PTR _wszNewLogPath$3[ebp]
	push	0
	push	eax
	call	_memset
	add	esp, 24					; 00000018H

; 179  : 
; 180  :     wcscpy   (wszNewLogPath, SK_GetConfigPath ());

	call	?SK_GetConfigPath@@YGPB_WXZ		; SK_GetConfigPath
	lea	edx, DWORD PTR _wszNewLogPath$3[ebp]
	sub	edx, eax
	npad	6
$LL4@SK_CEGUI_R:
	movzx	ecx, WORD PTR [eax]
	lea	eax, DWORD PTR [eax+2]
	mov	WORD PTR [edx+eax-2], cx
	test	cx, cx
	jne	SHORT $LL4@SK_CEGUI_R

; 181  :     wcstombs ( szNewLogPath, SK_GetConfigPath (), MAX_PATH * 4 - 1);

	push	1039					; 0000040fH
	call	?SK_GetConfigPath@@YGPB_WXZ		; SK_GetConfigPath
	push	eax
	lea	eax, DWORD PTR _szNewLogPath$2[ebp]
	push	eax
	call	DWORD PTR __imp__wcstombs
	add	esp, 12					; 0000000cH

; 182  : 
; 183  :     lstrcatA ( szNewLogPath, R"(logs\CEGUI.log)");

	lea	eax, DWORD PTR _szNewLogPath$2[ebp]
	push	OFFSET $SG352120
	push	eax
	call	DWORD PTR __imp__lstrcatA@8

; 184  :     lstrcatW (wszNewLogPath, L"logs\\CEGUI.log" );

	push	OFFSET $SG352121
	lea	eax, DWORD PTR _wszNewLogPath$3[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatW@8

; 185  : 
; 186  :     CopyFileExW ( L"CEGUI.log", wszNewLogPath,

	push	0
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _wszNewLogPath$3[ebp]
	push	eax
	push	OFFSET $SG352122
	call	DWORD PTR __imp__CopyFileExW@24
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	lea	ecx, DWORD PTR $T6[ebp]
	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	lea	ecx, DWORD PTR _szNewLogPath$2[ebp]
	lea	edx, DWORD PTR [ecx+1]
	npad	2
$LL98@SK_CEGUI_R:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL98@SK_CEGUI_R
	push	esi
	push	edi
	sub	ecx, edx
	lea	eax, DWORD PTR _szNewLogPath$2[ebp]
	push	ecx
	push	eax
	lea	ecx, DWORD PTR $T6[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 190  :     CEGUI::Logger::getDllSingleton ().setLogFilename (szNewLogPath, true);

	mov	edi, DWORD PTR __imp_?getDllSingleton@?$Singleton@VLogger@CEGUI@@@CEGUI@@SAAAVLogger@2@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	edi
	push	1
	lea	ecx, DWORD PTR $T6[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	call	DWORD PTR [edx+8]
	mov	esi, DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
	lea	ecx, DWORD PTR $T6[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	esi
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	lea	ecx, DWORD PTR $T5[ebp]
	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	36					; 00000024H
	push	OFFSET $SG352123
	lea	ecx, DWORD PTR $T5[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 192  :     CEGUI::Logger::getDllSingleton ().logEvent       ("[Special K] ---- Log File Moved ----");

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	call	edi
	push	2
	lea	ecx, DWORD PTR $T5[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	lea	ecx, DWORD PTR $T5[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	esi
; File c:\users\andon\source\repos\specialk\depends\include\cegui\string.h

; 573  : 		init();

	lea	ecx, DWORD PTR $T4[ebp]
	call	DWORD PTR __imp_?init@String@CEGUI@@AAEXXZ

; 1520 : 		return assign(cstr, strlen(cstr));

	push	0
	push	OFFSET $SG352124
	lea	ecx, DWORD PTR $T4[ebp]
	call	DWORD PTR __imp_?assign@String@CEGUI@@QAEAAV12@PBDI@Z
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 193  :     CEGUI::Logger::getDllSingleton ().logEvent       ("");

	mov	DWORD PTR __$EHRec$[ebp+8], 2
	call	edi
	push	2
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	call	DWORD PTR [edx+4]
	lea	ecx, DWORD PTR $T4[ebp]
	call	esi

; 194  : 
; 195  :     DeleteFileW (L"CEGUI.log");

	push	OFFSET $SG352125
	call	DWORD PTR __imp__DeleteFileW@4
	pop	edi
	pop	esi
$LN2@SK_CEGUI_R:

; 196  :   }
; 197  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_CEGUI_RelocateLog@@YAXXZ$0:
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_RelocateLog@@YAXXZ$1:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__unwindfunclet$?SK_CEGUI_RelocateLog@@YAXXZ$2:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	DWORD PTR __imp_??1String@CEGUI@@QAE@XZ
__ehhandler$?SK_CEGUI_RelocateLog@@YAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?SK_CEGUI_RelocateLog@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_CEGUI_RelocateLog@@YAXXZ ENDP			; SK_CEGUI_RelocateLog
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\combaseapi.h
;	COMDAT ??$IID_PPV_ARGS_Helper@UID3D11Device@@@@YAPAPAXPAPAUID3D11Device@@@Z
_TEXT	SEGMENT
_pp$ = 8						; size = 4
??$IID_PPV_ARGS_Helper@UID3D11Device@@@@YAPAPAXPAPAUID3D11Device@@@Z PROC ; IID_PPV_ARGS_Helper<ID3D11Device>, COMDAT

; 227  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 228  : #pragma prefast(suppress: 6269, "Tool issue with unused static_cast")
; 229  :         static_cast<IUnknown*>(*pp);    // make sure everyone derives from IUnknown
; 230  :         return reinterpret_cast<void**>(pp);

	mov	eax, DWORD PTR _pp$[ebp]

; 231  :     }    

	pop	ebp
	ret	0
??$IID_PPV_ARGS_Helper@UID3D11Device@@@@YAPAPAXPAPAUID3D11Device@@@Z ENDP ; IID_PPV_ARGS_Helper<ID3D11Device>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@XZ PROC	; ATL::CComPtr<ID3D11DeviceContext>::~CComPtr<ID3D11DeviceContext>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@CComPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN4@CComPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@XZ ENDP	; ATL::CComPtr<ID3D11DeviceContext>::~CComPtr<ID3D11DeviceContext>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@PAUID3D11DeviceContext@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@PAUID3D11DeviceContext@@@Z PROC ; ATL::CComPtr<ID3D11DeviceContext>::CComPtr<ID3D11DeviceContext>, COMDAT
; _this$ = ecx

; 312  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi

; 312  :     {

	mov	esi, ecx

; 162  :         p = lp;

	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN6@CComPtr

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN6@CComPtr:

; 313  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@PAUID3D11DeviceContext@@@Z ENDP ; ATL::CComPtr<ID3D11DeviceContext>::CComPtr<ID3D11DeviceContext>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@XZ PROC	; ATL::CComPtr<ID3D11DeviceContext>::CComPtr<ID3D11DeviceContext>, COMDAT
; _this$ = ecx

; 158  :         p = NULL;

	mov	DWORD PTR [ecx], 0

; 308  :     {
; 309  :     }

	mov	eax, ecx
	ret	0
??0?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@XZ ENDP	; ATL::CComPtr<ID3D11DeviceContext>::CComPtr<ID3D11DeviceContext>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??8?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QBE_NPAUID3D11DeviceContext@@@Z
_TEXT	SEGMENT
_pT$ = 8						; size = 4
??8?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QBE_NPAUID3D11DeviceContext@@@Z PROC ; ATL::CComPtrBase<ID3D11DeviceContext>::operator==, COMDAT
; _this$ = ecx

; 213  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR _pT$[ebp]
	sete	al

; 214  :         return p == pT;
; 215  :     }

	pop	ebp
	ret	4
??8?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QBE_NPAUID3D11DeviceContext@@@Z ENDP ; ATL::CComPtrBase<ID3D11DeviceContext>::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??9?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QBE_NPAUID3D11DeviceContext@@@Z
_TEXT	SEGMENT
_pT$ = 8						; size = 4
??9?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QBE_NPAUID3D11DeviceContext@@@Z PROC ; ATL::CComPtrBase<ID3D11DeviceContext>::operator!=, COMDAT
; _this$ = ecx

; 209  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR _pT$[ebp]
	setne	al

; 210  :         return !operator==(pT);
; 211  :     }

	pop	ebp
	ret	4
??9?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QBE_NPAUID3D11DeviceContext@@@Z ENDP ; ATL::CComPtrBase<ID3D11DeviceContext>::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??C?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UID3D11DeviceContext@@@1@XZ
_TEXT	SEGMENT
??C?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UID3D11DeviceContext@@@1@XZ PROC ; ATL::CComPtrBase<ID3D11DeviceContext>::operator->, COMDAT
; _this$ = ecx

; 197  :         ATLASSERT(p!=NULL);
; 198  :         return (_NoAddRefReleaseOnCComPtr<T>*)p;

	mov	eax, DWORD PTR [ecx]

; 199  :     }

	ret	0
??C?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UID3D11DeviceContext@@@1@XZ ENDP ; ATL::CComPtrBase<ID3D11DeviceContext>::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??I?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QAEPAPAUID3D11DeviceContext@@XZ
_TEXT	SEGMENT
??I?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QAEPAPAUID3D11DeviceContext@@XZ PROC ; ATL::CComPtrBase<ID3D11DeviceContext>::operator&, COMDAT
; _this$ = ecx

; 192  :         ATLASSERT(p==NULL);
; 193  :         return &p;

	mov	eax, ecx

; 194  :     }

	ret	0
??I?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QAEPAPAUID3D11DeviceContext@@XZ ENDP ; ATL::CComPtrBase<ID3D11DeviceContext>::operator&
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??B?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QBEPAUID3D11DeviceContext@@XZ
_TEXT	SEGMENT
??B?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QBEPAUID3D11DeviceContext@@XZ PROC ; ATL::CComPtrBase<ID3D11DeviceContext>::operator ID3D11DeviceContext *, COMDAT
; _this$ = ecx

; 181  :         return p;

	mov	eax, DWORD PTR [ecx]

; 182  :     }

	ret	0
??B?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QBEPAUID3D11DeviceContext@@XZ ENDP ; ATL::CComPtrBase<ID3D11DeviceContext>::operator ID3D11DeviceContext *
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QAE@XZ PROC ; ATL::CComPtrBase<ID3D11DeviceContext>::~CComPtrBase<ID3D11DeviceContext>, COMDAT
; _this$ = ecx

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN2@CComPtrBas

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@CComPtrBas:

; 178  :     }

	ret	0
??1?$CComPtrBase@UID3D11DeviceContext@@@ATL@@QAE@XZ ENDP ; ATL::CComPtrBase<ID3D11DeviceContext>::~CComPtrBase<ID3D11DeviceContext>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UID3D11DeviceContext@@@ATL@@IAE@PAUID3D11DeviceContext@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtrBase@UID3D11DeviceContext@@@ATL@@IAE@PAUID3D11DeviceContext@@@Z PROC ; ATL::CComPtrBase<ID3D11DeviceContext>::CComPtrBase<ID3D11DeviceContext>, COMDAT
; _this$ = ecx

; 160  :     CComPtrBase(_Inout_opt_ T* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp

; 161  :     {
; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN4@CComPtrBas

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN4@CComPtrBas:

; 165  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtrBase@UID3D11DeviceContext@@@ATL@@IAE@PAUID3D11DeviceContext@@@Z ENDP ; ATL::CComPtrBase<ID3D11DeviceContext>::CComPtrBase<ID3D11DeviceContext>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UID3D11DeviceContext@@@ATL@@IAE@XZ
_TEXT	SEGMENT
??0?$CComPtrBase@UID3D11DeviceContext@@@ATL@@IAE@XZ PROC ; ATL::CComPtrBase<ID3D11DeviceContext>::CComPtrBase<ID3D11DeviceContext>, COMDAT
; _this$ = ecx

; 157  :     {
; 158  :         p = NULL;

	mov	DWORD PTR [ecx], 0

; 159  :     }

	mov	eax, ecx
	ret	0
??0?$CComPtrBase@UID3D11DeviceContext@@@ATL@@IAE@XZ ENDP ; ATL::CComPtrBase<ID3D11DeviceContext>::CComPtrBase<ID3D11DeviceContext>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<ID3D11Device>::~CComPtr<ID3D11Device>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@CComPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN4@CComPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<ID3D11Device>::~CComPtr<ID3D11Device>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UID3D11Device@@@ATL@@QAE@PAUID3D11Device@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtr@UID3D11Device@@@ATL@@QAE@PAUID3D11Device@@@Z PROC ; ATL::CComPtr<ID3D11Device>::CComPtr<ID3D11Device>, COMDAT
; _this$ = ecx

; 312  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi

; 312  :     {

	mov	esi, ecx

; 162  :         p = lp;

	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN6@CComPtr

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN6@CComPtr:

; 313  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtr@UID3D11Device@@@ATL@@QAE@PAUID3D11Device@@@Z ENDP ; ATL::CComPtr<ID3D11Device>::CComPtr<ID3D11Device>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<ID3D11Device>::CComPtr<ID3D11Device>, COMDAT
; _this$ = ecx

; 158  :         p = NULL;

	mov	DWORD PTR [ecx], 0

; 308  :     {
; 309  :     }

	mov	eax, ecx
	ret	0
??0?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<ID3D11Device>::CComPtr<ID3D11Device>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??8?$CComPtrBase@UID3D11Device@@@ATL@@QBE_NPAUID3D11Device@@@Z
_TEXT	SEGMENT
_pT$ = 8						; size = 4
??8?$CComPtrBase@UID3D11Device@@@ATL@@QBE_NPAUID3D11Device@@@Z PROC ; ATL::CComPtrBase<ID3D11Device>::operator==, COMDAT
; _this$ = ecx

; 213  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR _pT$[ebp]
	sete	al

; 214  :         return p == pT;
; 215  :     }

	pop	ebp
	ret	4
??8?$CComPtrBase@UID3D11Device@@@ATL@@QBE_NPAUID3D11Device@@@Z ENDP ; ATL::CComPtrBase<ID3D11Device>::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??9?$CComPtrBase@UID3D11Device@@@ATL@@QBE_NPAUID3D11Device@@@Z
_TEXT	SEGMENT
_pT$ = 8						; size = 4
??9?$CComPtrBase@UID3D11Device@@@ATL@@QBE_NPAUID3D11Device@@@Z PROC ; ATL::CComPtrBase<ID3D11Device>::operator!=, COMDAT
; _this$ = ecx

; 209  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR _pT$[ebp]
	setne	al

; 210  :         return !operator==(pT);
; 211  :     }

	pop	ebp
	ret	4
??9?$CComPtrBase@UID3D11Device@@@ATL@@QBE_NPAUID3D11Device@@@Z ENDP ; ATL::CComPtrBase<ID3D11Device>::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??C?$CComPtrBase@UID3D11Device@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UID3D11Device@@@1@XZ
_TEXT	SEGMENT
??C?$CComPtrBase@UID3D11Device@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UID3D11Device@@@1@XZ PROC ; ATL::CComPtrBase<ID3D11Device>::operator->, COMDAT
; _this$ = ecx

; 197  :         ATLASSERT(p!=NULL);
; 198  :         return (_NoAddRefReleaseOnCComPtr<T>*)p;

	mov	eax, DWORD PTR [ecx]

; 199  :     }

	ret	0
??C?$CComPtrBase@UID3D11Device@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UID3D11Device@@@1@XZ ENDP ; ATL::CComPtrBase<ID3D11Device>::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??I?$CComPtrBase@UID3D11Device@@@ATL@@QAEPAPAUID3D11Device@@XZ
_TEXT	SEGMENT
??I?$CComPtrBase@UID3D11Device@@@ATL@@QAEPAPAUID3D11Device@@XZ PROC ; ATL::CComPtrBase<ID3D11Device>::operator&, COMDAT
; _this$ = ecx

; 192  :         ATLASSERT(p==NULL);
; 193  :         return &p;

	mov	eax, ecx

; 194  :     }

	ret	0
??I?$CComPtrBase@UID3D11Device@@@ATL@@QAEPAPAUID3D11Device@@XZ ENDP ; ATL::CComPtrBase<ID3D11Device>::operator&
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??B?$CComPtrBase@UID3D11Device@@@ATL@@QBEPAUID3D11Device@@XZ
_TEXT	SEGMENT
??B?$CComPtrBase@UID3D11Device@@@ATL@@QBEPAUID3D11Device@@XZ PROC ; ATL::CComPtrBase<ID3D11Device>::operator ID3D11Device *, COMDAT
; _this$ = ecx

; 181  :         return p;

	mov	eax, DWORD PTR [ecx]

; 182  :     }

	ret	0
??B?$CComPtrBase@UID3D11Device@@@ATL@@QBEPAUID3D11Device@@XZ ENDP ; ATL::CComPtrBase<ID3D11Device>::operator ID3D11Device *
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UID3D11Device@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UID3D11Device@@@ATL@@QAE@XZ PROC	; ATL::CComPtrBase<ID3D11Device>::~CComPtrBase<ID3D11Device>, COMDAT
; _this$ = ecx

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN2@CComPtrBas

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@CComPtrBas:

; 178  :     }

	ret	0
??1?$CComPtrBase@UID3D11Device@@@ATL@@QAE@XZ ENDP	; ATL::CComPtrBase<ID3D11Device>::~CComPtrBase<ID3D11Device>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UID3D11Device@@@ATL@@IAE@PAUID3D11Device@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtrBase@UID3D11Device@@@ATL@@IAE@PAUID3D11Device@@@Z PROC ; ATL::CComPtrBase<ID3D11Device>::CComPtrBase<ID3D11Device>, COMDAT
; _this$ = ecx

; 160  :     CComPtrBase(_Inout_opt_ T* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp

; 161  :     {
; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN4@CComPtrBas

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN4@CComPtrBas:

; 165  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtrBase@UID3D11Device@@@ATL@@IAE@PAUID3D11Device@@@Z ENDP ; ATL::CComPtrBase<ID3D11Device>::CComPtrBase<ID3D11Device>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UID3D11Device@@@ATL@@IAE@XZ
_TEXT	SEGMENT
??0?$CComPtrBase@UID3D11Device@@@ATL@@IAE@XZ PROC	; ATL::CComPtrBase<ID3D11Device>::CComPtrBase<ID3D11Device>, COMDAT
; _this$ = ecx

; 157  :     {
; 158  :         p = NULL;

	mov	DWORD PTR [ecx], 0

; 159  :     }

	mov	eax, ecx
	ret	0
??0?$CComPtrBase@UID3D11Device@@@ATL@@IAE@XZ ENDP	; ATL::CComPtrBase<ID3D11Device>::CComPtrBase<ID3D11Device>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_pD3D11Dev$ = -20					; size = 4
_pImmediateContext$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
_pSwapChain$ = 8					; size = 4
?ImGui_DX11Startup@@YA_NPAUIDXGISwapChain@@@Z PROC	; ImGui_DX11Startup

; 142  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ImGui_DX11Startup@@YA_NPAUIDXGISwapChain@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pD3D11Dev$[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 143  :   CComPtr <ID3D11Device>        pD3D11Dev         = nullptr;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pImmediateContext$[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 148  :   if ( SUCCEEDED (pSwapChain->GetDevice (IID_PPV_ARGS (&pD3D11Dev))) )

	mov	edi, DWORD PTR _pSwapChain$[ebp]
	lea	eax, DWORD PTR _pD3D11Dev$[ebp]
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	esi, DWORD PTR [edi]
	call	??$IID_PPV_ARGS_Helper@UID3D11Device@@@@YAPAPAXPAPAUID3D11Device@@@Z ; IID_PPV_ARGS_Helper<ID3D11Device>
	add	esp, 4
	push	eax
	push	OFFSET __GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140
	push	edi
	call	DWORD PTR [esi+28]
	test	eax, eax
	js	SHORT $LN57@ImGui_DX11

; 149  :   {
; 150  :     assert (pD3D11Dev == rb.device);
; 151  : 
; 152  :     pD3D11Dev->GetImmediateContext (&pImmediateContext);

	mov	eax, DWORD PTR _pD3D11Dev$[ebp]
	lea	edx, DWORD PTR _pImmediateContext$[ebp]
	push	edx
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+160]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 214  :         return p == pT;

	mov	eax, DWORD PTR _pImmediateContext$[ebp]
	test	eax, eax
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 156  :     if (pImmediateContext != nullptr)

	je	SHORT $LN3@ImGui_DX11

; 157  :     {
; 158  :       imgui_swap = pSwapChain;
; 159  :       return ImGui_ImplDX11_Init (pSwapChain, pD3D11Dev, pImmediateContext);

	push	eax
	push	DWORD PTR _pD3D11Dev$[ebp]
	mov	DWORD PTR ?imgui_swap@@3PAUIDXGISwapChain@@A, edi
	push	edi
	call	?ImGui_ImplDX11_Init@@YA_NPAUIDXGISwapChain@@PAUID3D11Device@@PAUID3D11DeviceContext@@@Z ; ImGui_ImplDX11_Init
	mov	bl, al
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _pImmediateContext$[ebp]
	jmp	SHORT $LN7@ImGui_DX11
$LN57@ImGui_DX11:
	mov	eax, DWORD PTR _pImmediateContext$[ebp]
$LN3@ImGui_DX11:

; 163  :   return false;

	xor	bl, bl
$LN7@ImGui_DX11:
	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN48@ImGui_DX11

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN48@ImGui_DX11:

; 176  :         if (p)

	mov	eax, DWORD PTR _pD3D11Dev$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 163  :   return false;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN56@ImGui_DX11

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN56@ImGui_DX11:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 164  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	al, bl
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ImGui_DX11Startup@@YA_NPAUIDXGISwapChain@@@Z$0:
	lea	ecx, DWORD PTR _pD3D11Dev$[ebp]
	jmp	??1?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ
__unwindfunclet$?ImGui_DX11Startup@@YA_NPAUIDXGISwapChain@@@Z$1:
	lea	ecx, DWORD PTR _pImmediateContext$[ebp]
	jmp	??1?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@XZ
__ehhandler$?ImGui_DX11Startup@@YA_NPAUIDXGISwapChain@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ImGui_DX11Startup@@YA_NPAUIDXGISwapChain@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ImGui_DX11Startup@@YA_NPAUIDXGISwapChain@@@Z ENDP	; ImGui_DX11Startup
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
?ImGui_DX11Shutdown@@YAXXZ PROC				; ImGui_DX11Shutdown

; 136  :   ImGui_ImplDX11_Shutdown ();

	call	?ImGui_ImplDX11_Shutdown@@YAXXZ		; ImGui_ImplDX11_Shutdown

; 137  :   imgui_swap = nullptr;

	mov	DWORD PTR ?imgui_swap@@3PAUIDXGISwapChain@@A, 0

; 138  : }

	ret	0
?ImGui_DX11Shutdown@@YAXXZ ENDP				; ImGui_DX11Shutdown
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\size.h
;	COMDAT ??8?$Size@M@CEGUI@@QBE_NABV01@@Z
_TEXT	SEGMENT
_other$ = 8						; size = 4
??8?$Size@M@CEGUI@@QBE_NABV01@@Z PROC			; CEGUI::Size<float>::operator==, COMDAT
; _this$ = ecx

; 86   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 87   :         return d_width == other.d_width && d_height == other.d_height;

	mov	edx, DWORD PTR _other$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	ucomiss	xmm0, DWORD PTR [edx]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator
	movss	xmm0, DWORD PTR [ecx+4]
	ucomiss	xmm0, DWORD PTR [edx+4]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator
	mov	al, 1

; 88   :     }

	pop	ebp
	ret	4
$LN3@operator:

; 87   :         return d_width == other.d_width && d_height == other.d_height;

	xor	al, al

; 88   :     }

	pop	ebp
	ret	4
??8?$Size@M@CEGUI@@QBE_NABV01@@Z ENDP			; CEGUI::Size<float>::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\size.h
;	COMDAT ??0?$Size@M@CEGUI@@QAE@MM@Z
_TEXT	SEGMENT
_width$ = 8						; size = 4
_height$ = 12						; size = 4
??0?$Size@M@CEGUI@@QAE@MM@Z PROC			; CEGUI::Size<float>::Size<float>, COMDAT
; _this$ = ecx

; 78   :     {}

	npad	2
	push	ebp
	mov	ebp, esp

; 76   :         d_width(width),

	movss	xmm0, DWORD PTR _width$[ebp]

; 78   :     {}

	mov	eax, ecx
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR _height$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	pop	ebp
	ret	8
??0?$Size@M@CEGUI@@QAE@MM@Z ENDP			; CEGUI::Size<float>::Size<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\depends\include\cegui\memoryallocatedobject.h
;	COMDAT ??0?$AllocatedObject@V?$Size@M@CEGUI@@@CEGUI@@QAE@XZ
_TEXT	SEGMENT
??0?$AllocatedObject@V?$Size@M@CEGUI@@@CEGUI@@QAE@XZ PROC ; CEGUI::AllocatedObject<CEGUI::Size<float> >::AllocatedObject<CEGUI::Size<float> >, COMDAT
; _this$ = ecx

; 113  : 	{}

	mov	eax, ecx
	ret	0
??0?$AllocatedObject@V?$Size@M@CEGUI@@@CEGUI@@QAE@XZ ENDP ; CEGUI::AllocatedObject<CEGUI::Size<float> >::AllocatedObject<CEGUI::Size<float> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_pDev$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pDevCtx$2 = 8						; size = 4
_This$ = 8						; size = 4
?SK_DXGI_UpdateSwapChain@@YAXPAUIDXGISwapChain@@@Z PROC	; SK_DXGI_UpdateSwapChain

; 1214 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SK_DXGI_UpdateSwapChain@@YAXPAUIDXGISwapChain@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pDev$[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1217 :   if ( SUCCEEDED (This->GetDevice (IID_PPV_ARGS (&pDev))) )

	mov	edi, DWORD PTR _This$[ebp]
	lea	eax, DWORD PTR _pDev$[ebp]
	push	eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	esi, DWORD PTR [edi]
	call	??$IID_PPV_ARGS_Helper@UID3D11Device@@@@YAPAPAXPAPAUID3D11Device@@@Z ; IID_PPV_ARGS_Helper<ID3D11Device>
	add	esp, 4
	push	eax
	push	OFFSET __GUID_db6f6ddb_ac77_4e88_8253_819df9bbf140
	push	edi
	call	DWORD PTR [esi+28]
	test	eax, eax
	js	SHORT $LN30@SK_DXGI_Up

; 1218 :   {
; 1219 :     SK_RenderBackend& rb =

	call	?SK_GetCurrentRenderBackend@@YGAAVSK_RenderBackend_V2@@XZ ; SK_GetCurrentRenderBackend

; 1220 :       SK_GetCurrentRenderBackend ();
; 1221 : 
; 1222 :     rb.device    = pDev;

	mov	ecx, DWORD PTR _pDev$[ebp]
	mov	esi, eax
	mov	DWORD PTR [esi+36], ecx

; 1223 :     rb.swapchain = This;

	mov	DWORD PTR [esi+40], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pDevCtx$2[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1227 :     pDev->GetImmediateContext ((ID3D11DeviceContext **)&pDevCtx);

	mov	ecx, DWORD PTR _pDev$[ebp]
	lea	eax, DWORD PTR _pDevCtx$2[ebp]
	push	eax
	push	ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+160]

; 1228 :     rb.d3d11.immediate_ctx = pDevCtx;

	mov	eax, DWORD PTR _pDevCtx$2[ebp]
	mov	DWORD PTR [esi+68], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	mov	eax, DWORD PTR _pDevCtx$2[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1229 :   }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN30@SK_DXGI_Up

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN30@SK_DXGI_Up:

; 176  :         if (p)

	mov	eax, DWORD PTR _pDev$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1230 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN36@SK_DXGI_Up

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN36@SK_DXGI_Up:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1230 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_DXGI_UpdateSwapChain@@YAXPAUIDXGISwapChain@@@Z$0:
	lea	ecx, DWORD PTR _pDev$[ebp]
	jmp	??1?$CComPtr@UID3D11Device@@@ATL@@QAE@XZ
__unwindfunclet$?SK_DXGI_UpdateSwapChain@@YAXPAUIDXGISwapChain@@@Z$1:
	lea	ecx, DWORD PTR _pDevCtx$2[ebp]
	jmp	??1?$CComPtr@UID3D11DeviceContext@@@ATL@@QAE@XZ
__ehhandler$?SK_DXGI_UpdateSwapChain@@YAXPAUIDXGISwapChain@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?SK_DXGI_UpdateSwapChain@@YAXPAUIDXGISwapChain@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_DXGI_UpdateSwapChain@@YAXPAUIDXGISwapChain@@@Z ENDP	; SK_DXGI_UpdateSwapChain
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h
;	COMDAT ??1SK_ScopedBool@@QAE@XZ
_TEXT	SEGMENT
??1SK_ScopedBool@@QAE@XZ PROC				; SK_ScopedBool::~SK_ScopedBool, COMDAT
; _this$ = ecx

; 143  :     *pBool_ = bOrig_;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax

; 144  :   }

	ret	0
??1SK_ScopedBool@@QAE@XZ ENDP				; SK_ScopedBool::~SK_ScopedBool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\tls.h
;	COMDAT ??0SK_ScopedBool@@QAE@PAH@Z
_TEXT	SEGMENT
_pBool$ = 8						; size = 4
??0SK_ScopedBool@@QAE@PAH@Z PROC			; SK_ScopedBool::SK_ScopedBool, COMDAT
; _this$ = ecx

; 135  :   SK_ScopedBool (BOOL* pBool)

	npad	2
	push	ebp
	mov	ebp, esp

; 136  :   {
; 137  :     pBool_ =  pBool;

	mov	eax, DWORD PTR _pBool$[ebp]
	mov	DWORD PTR [ecx], eax

; 138  :     bOrig_ = *pBool;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax

; 139  :   }

	mov	eax, ecx
	pop	ebp
	ret	4
??0SK_ScopedBool@@QAE@PAH@Z ENDP			; SK_ScopedBool::SK_ScopedBool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\log.h
;	COMDAT ?auto_close@iSK_Logger@@QAE?AVAutoClose@1@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?auto_close@iSK_Logger@@QAE?AVAutoClose@1@XZ PROC	; iSK_Logger::auto_close, COMDAT
; _this$ = ecx

; 171  :   AutoClose auto_close (void) {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 165  :     AutoClose (iSK_Logger* log) : log_ (log) { }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR $T1[ebp], 0
	mov	DWORD PTR [eax], ecx

; 172  :     return AutoClose (this);
; 173  :   }

	mov	esp, ebp
	pop	ebp
	ret	4
?auto_close@iSK_Logger@@QAE?AVAutoClose@1@XZ ENDP	; iSK_Logger::auto_close
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\log.h
;	COMDAT ??0AutoClose@iSK_Logger@@IAE@PAU1@@Z
_TEXT	SEGMENT
_log$ = 8						; size = 4
??0AutoClose@iSK_Logger@@IAE@PAU1@@Z PROC		; iSK_Logger::AutoClose::AutoClose, COMDAT
; _this$ = ecx

; 165  :     AutoClose (iSK_Logger* log) : log_ (log) { }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _log$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??0AutoClose@iSK_Logger@@IAE@PAU1@@Z ENDP		; iSK_Logger::AutoClose::AutoClose
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\log.h
;	COMDAT ??1AutoClose@iSK_Logger@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1AutoClose@iSK_Logger@@QAE@XZ PROC			; iSK_Logger::AutoClose::~AutoClose, COMDAT
; _this$ = ecx

; 157  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1AutoClose@iSK_Logger@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx

; 158  :       if (log_ != nullptr)

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@AutoClose

; 159  :         log_->close ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+20]
$LN4@AutoClose:

; 160  : 
; 161  :       log_ = nullptr;
; 162  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1AutoClose@iSK_Logger@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1AutoClose@iSK_Logger@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1AutoClose@iSK_Logger@@QAE@XZ ENDP			; iSK_Logger::AutoClose::~AutoClose
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
;	COMDAT ?isZero@<unnamed-type-override>@<unnamed-type-res>@<unnamed-type-window>@sk_config_t@@QAE_NXZ
_TEXT	SEGMENT
?isZero@<unnamed-type-override>@<unnamed-type-res>@<unnamed-type-window>@sk_config_t@@QAE_NXZ PROC ; sk_config_t::<unnamed-type-window>::<unnamed-type-res>::<unnamed-type-override>::isZero, COMDAT
; _this$ = ecx

; 425  :         bool isZero (void) { return x == 0 && y == 0; };

	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN3@isZero
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN3@isZero
	mov	al, 1
	ret	0
$LN3@isZero:
	xor	al, al
	ret	0
?isZero@<unnamed-type-override>@<unnamed-type-res>@<unnamed-type-window>@sk_config_t@@QAE_NXZ ENDP ; sk_config_t::<unnamed-type-window>::<unnamed-type-res>::<unnamed-type-override>::isZero
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
;	COMDAT ?isZero@<unnamed-type-max>@<unnamed-type-res>@<unnamed-type-dxgi>@<unnamed-type-render>@sk_config_t@@QAE_NXZ
_TEXT	SEGMENT
?isZero@<unnamed-type-max>@<unnamed-type-res>@<unnamed-type-dxgi>@<unnamed-type-render>@sk_config_t@@QAE_NXZ PROC ; sk_config_t::<unnamed-type-render>::<unnamed-type-dxgi>::<unnamed-type-res>::<unnamed-type-max>::isZero, COMDAT
; _this$ = ecx

; 251  :           bool isZero (void) { return x == 0 && y == 0; };

	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN3@isZero
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN3@isZero
	mov	al, 1
	ret	0
$LN3@isZero:
	xor	al, al
	ret	0
?isZero@<unnamed-type-max>@<unnamed-type-res>@<unnamed-type-dxgi>@<unnamed-type-render>@sk_config_t@@QAE_NXZ ENDP ; sk_config_t::<unnamed-type-render>::<unnamed-type-dxgi>::<unnamed-type-res>::<unnamed-type-max>::isZero
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\config.h
;	COMDAT ?isZero@<unnamed-type-min>@<unnamed-type-res>@<unnamed-type-dxgi>@<unnamed-type-render>@sk_config_t@@QAE_NXZ
_TEXT	SEGMENT
?isZero@<unnamed-type-min>@<unnamed-type-res>@<unnamed-type-dxgi>@<unnamed-type-render>@sk_config_t@@QAE_NXZ PROC ; sk_config_t::<unnamed-type-render>::<unnamed-type-dxgi>::<unnamed-type-res>::<unnamed-type-min>::isZero, COMDAT
; _this$ = ecx

; 246  :           bool isZero (void) { return x == 0 && y == 0; };

	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN3@isZero
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN3@isZero
	mov	al, 1
	ret	0
$LN3@isZero:
	xor	al, al
	ret	0
?isZero@<unnamed-type-min>@<unnamed-type-res>@<unnamed-type-dxgi>@<unnamed-type-render>@sk_config_t@@QAE_NXZ ENDP ; sk_config_t::<unnamed-type-render>::<unnamed-type-dxgi>::<unnamed-type-res>::<unnamed-type-min>::isZero
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
;	COMDAT ??__F_AtlWinModule@ATL@@YAXXZ
text$yd	SEGMENT
??__F_AtlWinModule@ATL@@YAXXZ PROC			; ATL::`dynamic atexit destructor for '_AtlWinModule'', COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2964 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

	push	DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+4
	push	OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
	call	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 216  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32
	test	eax, eax
	je	SHORT $LN29@dynamic

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 221  : 			m_aT = NULL;

	mov	DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32, 0
$LN29@dynamic:

; 222  : 		}
; 223  : 		m_nSize = 0;
; 224  : 		m_nAllocSize = 0;

	mov	DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+40, 0
	mov	DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+36, 0
	ret	0
??__F_AtlWinModule@ATL@@YAXXZ ENDP			; ATL::`dynamic atexit destructor for '_AtlWinModule''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ??__E_AtlWinModule@ATL@@YAXXZ
text$di	SEGMENT
??__E_AtlWinModule@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for '_AtlWinModule'', COMDAT

; 2979 : __declspec(selectany) CAtlWinModule _AtlWinModule;

	mov	ecx, OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
	call	??0CAtlWinModule@ATL@@QAE@XZ		; ATL::CAtlWinModule::CAtlWinModule
	push	OFFSET ??__F_AtlWinModule@ATL@@YAXXZ	; ATL::`dynamic atexit destructor for '_AtlWinModule''
	call	_atexit
	pop	ecx
	ret	0
??__E_AtlWinModule@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for '_AtlWinModule''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ?Term@CAtlWinModule@ATL@@QAEXXZ
_TEXT	SEGMENT
?Term@CAtlWinModule@ATL@@QAEXXZ PROC			; ATL::CAtlWinModule::Term, COMDAT
; _this$ = ecx

; 2964 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

	push	DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+4
	push	ecx
	call	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm

; 2965 : 	}

	ret	0
?Term@CAtlWinModule@ATL@@QAEXXZ ENDP			; ATL::CAtlWinModule::Term
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ??1CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
??1CAtlWinModule@ATL@@QAE@XZ PROC			; ATL::CAtlWinModule::~CAtlWinModule, COMDAT
; _this$ = ecx

; 2958 : 	{

	npad	2
	push	esi

; 2964 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

	push	DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+4

; 2958 : 	{

	mov	esi, ecx

; 2964 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

	push	esi
	call	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 216  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN26@CAtlWinMod

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 221  : 			m_aT = NULL;

	mov	DWORD PTR [esi+32], 0
$LN26@CAtlWinMod:

; 222  : 		}
; 223  : 		m_nSize = 0;
; 224  : 		m_nAllocSize = 0;

	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+36], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2960 : 	}

	ret	0
??1CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::~CAtlWinModule
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CAtlWinModule@ATL@@QAE@XZ PROC			; ATL::CAtlWinModule::CAtlWinModule, COMDAT
; _this$ = ecx

; 2944 : 	CAtlWinModule()

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 151  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	movups	XMMWORD PTR [esi+4], xmm0
	lea	eax, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2944 : 	CAtlWinModule()

	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 151  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	movq	QWORD PTR [eax+16], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	0
	push	0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 119  : 		m_aT(NULL), m_nSize(0), m_nAllocSize(0)

	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2946 : 		cbSize = sizeof(_ATL_WIN_MODULE);

	mov	DWORD PTR [esi], 44			; 0000002cH

; 8412 : 	pWinModule->m_pCreateWndList = NULL;

	mov	DWORD PTR [esi+28], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	call	DWORD PTR __imp__InitializeCriticalSectionEx@12
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 171  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

	test	eax, eax
	jne	SHORT $LN26@CAtlWinMod

; 172  : 		{
; 173  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

	call	DWORD PTR __imp__GetLastError@0
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	test	eax, eax
	jle	SHORT $LN27@CAtlWinMod
	movzx	eax, ax
	or	eax, -2147024896			; 80070000H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2948 : 		if (FAILED(hr))

	test	eax, eax
$LN27@CAtlWinMod:

; 2953 : 			return;
; 2954 : 		}
; 2955 : 	}

	mov	eax, esi

; 2948 : 		if (FAILED(hr))

	jns	SHORT $LN2@CAtlWinMod

; 2949 : 		{
; 2950 : 			ATLASSERT(0);
; 2951 : 			CAtlBaseModule::m_bInitFailed = true;

	mov	BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed

; 2952 : 			cbSize = 0;

	mov	DWORD PTR [esi], 0
	pop	esi

; 2953 : 			return;
; 2954 : 		}
; 2955 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@CAtlWinMod:
	mov	eax, esi
$LN2@CAtlWinMod:
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??0CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::CAtlWinModule
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ??__F_AtlComModule@ATL@@YAXXZ
text$yd	SEGMENT
__$EHRec$ = -12						; size = 12
??__F_AtlComModule@ATL@@YAXXZ PROC			; ATL::`dynamic atexit destructor for '_AtlComModule'', COMDAT
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??__F_AtlComModule@ATL@@YAXXZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 2615 : 		Term();

	mov	ecx, OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?Term@CAtlComModule@ATL@@QAEXXZ		; ATL::CAtlComModule::Term

; 2616 : 	}

	mov	ecx, OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
	call	??1_ATL_COM_MODULE70@ATL@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
text$yd	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??__F_AtlComModule@ATL@@YAXXZ:
	mov	eax, OFFSET __ehfuncinfo$??__F_AtlComModule@ATL@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??__F_AtlComModule@ATL@@YAXXZ ENDP			; ATL::`dynamic atexit destructor for '_AtlComModule''
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ??__E_AtlComModule@ATL@@YAXXZ
text$di	SEGMENT
??__E_AtlComModule@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for '_AtlComModule'', COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	0
	push	0
	push	OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A+16
	call	DWORD PTR __imp__InitializeCriticalSectionEx@12
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 171  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

	test	eax, eax
	jne	SHORT $LN4@dynamic

; 172  : 		{
; 173  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

	call	DWORD PTR __imp__GetLastError@0
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	test	eax, eax
	jle	SHORT $LN20@dynamic
	movzx	eax, ax
	or	eax, -2147024896			; 80070000H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2602 : 		if (FAILED(m_csObjMap.Init()))

	test	eax, eax
$LN20@dynamic:
	jns	SHORT $LN4@dynamic

; 2723 : __declspec(selectany) CAtlComModule _AtlComModule;

	push	OFFSET ??__F_AtlComModule@ATL@@YAXXZ	; ATL::`dynamic atexit destructor for '_AtlComModule''

; 2606 : 			CAtlBaseModule::m_bInitFailed = true;

	mov	BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed

; 2723 : __declspec(selectany) CAtlComModule _AtlComModule;

	call	_atexit
	pop	ecx
	ret	0
$LN4@dynamic:
	push	OFFSET ??__F_AtlComModule@ATL@@YAXXZ	; ATL::`dynamic atexit destructor for '_AtlComModule''

; 2610 : 		cbSize = sizeof(_ATL_COM_MODULE);

	mov	DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A, 40 ; 00000028H

; 2723 : __declspec(selectany) CAtlComModule _AtlComModule;

	call	_atexit
	pop	ecx
	ret	0
??__E_AtlComModule@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for '_AtlComModule''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ?Term@CAtlComModule@ATL@@QAEXXZ
_TEXT	SEGMENT
?Term@CAtlComModule@ATL@@QAEXXZ PROC			; ATL::CAtlComModule::Term, COMDAT
; _this$ = ecx

; 2620 : 	{

	npad	2
	push	edi
	mov	edi, ecx

; 2621 : 		if (cbSize == 0)

	cmp	DWORD PTR [edi], 0
	je	SHORT $LN1@Term

; 2622 : 			return;
; 2623 : 
; 2624 : 		for (_ATL_OBJMAP_ENTRY_EX** ppEntry = m_ppAutoObjMapFirst; ppEntry < m_ppAutoObjMapLast; ppEntry++)

	push	esi
	mov	esi, DWORD PTR [edi+8]
	cmp	esi, DWORD PTR [edi+12]
	jae	SHORT $LN3@Term
	push	ebx
$LL4@Term:

; 2625 : 		{
; 2626 : 			if (*ppEntry != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Term

; 2627 : 			{
; 2628 : 				_ATL_OBJMAP_CACHE* pCache = (**ppEntry).pCache;

	mov	ebx, DWORD PTR [eax+16]

; 2629 : 
; 2630 : 				if (pCache->pCF != NULL)

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN2@Term

; 2631 : 				{
; 2632 : 					// Decode factory pointer if it's not null
; 2633 : 					IUnknown *factory = reinterpret_cast<IUnknown*>(::DecodePointer(pCache->pCF));

	push	eax
	call	DWORD PTR __imp__DecodePointer@4

; 2634 : 					_Analysis_assume_(factory != nullptr);
; 2635 : 					factory->Release();

	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]

; 2636 : 					pCache->pCF = NULL;

	mov	DWORD PTR [ebx], 0
$LN2@Term:

; 2622 : 			return;
; 2623 : 
; 2624 : 		for (_ATL_OBJMAP_ENTRY_EX** ppEntry = m_ppAutoObjMapFirst; ppEntry < m_ppAutoObjMapLast; ppEntry++)

	add	esi, 4
	cmp	esi, DWORD PTR [edi+12]
	jb	SHORT $LL4@Term
	pop	ebx
$LN3@Term:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 181  : 		DeleteCriticalSection(&m_sec);

	lea	eax, DWORD PTR [edi+16]
	push	eax
	call	DWORD PTR __imp__DeleteCriticalSection@4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2644 : 		cbSize = 0;

	mov	DWORD PTR [edi], 0
	pop	esi
$LN1@Term:
	pop	edi

; 2645 : 	}

	ret	0
?Term@CAtlComModule@ATL@@QAEXXZ ENDP			; ATL::CAtlComModule::Term
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ??1CAtlComModule@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1CAtlComModule@ATL@@QAE@XZ PROC			; ATL::CAtlComModule::~CAtlComModule, COMDAT
; _this$ = ecx

; 2614 : 	{

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1CAtlComModule@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 2615 : 		Term();

	call	?Term@CAtlComModule@ATL@@QAEXXZ		; ATL::CAtlComModule::Term

; 2616 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CAtlComModule@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CAtlComModule@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CAtlComModule@ATL@@QAE@XZ ENDP			; ATL::CAtlComModule::~CAtlComModule
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ??0CAtlComModule@ATL@@QAE@XZ
_TEXT	SEGMENT
??0CAtlComModule@ATL@@QAE@XZ PROC			; ATL::CAtlComModule::CAtlComModule, COMDAT
; _this$ = ecx

; 2593 : 	CAtlComModule() throw()

	npad	2
	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0
	lea	eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 151  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	movups	XMMWORD PTR [eax], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 151  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	movq	QWORD PTR [eax+16], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	0
	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2595 : 		cbSize = 0;

	mov	DWORD PTR [esi], 0

; 2596 : 
; 2597 : 		m_hInstTypeLib = reinterpret_cast<HINSTANCE>(&__ImageBase);

	mov	DWORD PTR [esi+4], OFFSET ___ImageBase

; 2598 : 
; 2599 : 		m_ppAutoObjMapFirst = &__pobjMapEntryFirst + 1;

	mov	DWORD PTR [esi+8], OFFSET ___pobjMapEntryFirst+4

; 2600 : 		m_ppAutoObjMapLast = &__pobjMapEntryLast;

	mov	DWORD PTR [esi+12], OFFSET ___pobjMapEntryLast
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	call	DWORD PTR __imp__InitializeCriticalSectionEx@12
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 171  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

	test	eax, eax
	jne	SHORT $LN2@CAtlComMod

; 172  : 		{
; 173  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

	call	DWORD PTR __imp__GetLastError@0
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	test	eax, eax
	jle	SHORT $LN18@CAtlComMod
	movzx	eax, ax
	or	eax, -2147024896			; 80070000H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2602 : 		if (FAILED(m_csObjMap.Init()))

	test	eax, eax
$LN18@CAtlComMod:
	jns	SHORT $LN2@CAtlComMod

; 2611 : 	}

	mov	eax, esi
	mov	BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed
	pop	esi
	ret	0
$LN2@CAtlComMod:

; 2603 : 		{
; 2604 : 			ATLTRACE(atlTraceCOM, 0, _T("ERROR : Unable to initialize critical section in CAtlComModule\n"));
; 2605 : 			ATLASSERT(0);
; 2606 : 			CAtlBaseModule::m_bInitFailed = true;
; 2607 : 			return;
; 2608 : 		}
; 2609 : 		// Set cbSize on success.
; 2610 : 		cbSize = sizeof(_ATL_COM_MODULE);

	mov	DWORD PTR [esi], 40			; 00000028H

; 2611 : 	}

	mov	eax, esi
	pop	esi
	ret	0
??0CAtlComModule@ATL@@QAE@XZ ENDP			; ATL::CAtlComModule::CAtlComModule
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z
_TEXT	SEGMENT
_pWinModule$ = 8					; size = 4
_hInst$ = 12						; size = 4
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z PROC ; ATL::AtlWinModuleTerm, COMDAT

; 7660 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 7661 : 	if (pWinModule == NULL)

	mov	esi, DWORD PTR _pWinModule$[ebp]
	test	esi, esi
	jne	SHORT $LN5@AtlWinModu
$LN35@AtlWinModu:

; 7662 : 		return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	pop	esi

; 7674 : }

	pop	ebp
	ret	8
$LN5@AtlWinModu:

; 7663 : 	if (pWinModule->cbSize == 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN34@AtlWinModu

; 7664 : 		return S_OK;
; 7665 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN35@AtlWinModu

; 7666 : 		return E_INVALIDARG;
; 7667 : 
; 7668 : 	for (int i = 0; i < pWinModule->m_rgWindowClassAtoms.GetSize(); i++)

	push	edi
	xor	edi, edi
	cmp	DWORD PTR [esi+36], edi
	jle	SHORT $LN3@AtlWinModu

; 7669 : 		UnregisterClass((LPCTSTR)pWinModule->m_rgWindowClassAtoms[i], hInst);

	push	ebx
	mov	ebx, DWORD PTR _hInst$[ebp]
	npad	2
$LL4@AtlWinModu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 238  : 		if(nIndex < 0 || nIndex >= m_nSize)

	test	edi, edi
	js	SHORT $LN36@AtlWinModu
	cmp	edi, DWORD PTR [esi+36]
	jge	SHORT $LN36@AtlWinModu
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 7669 : 		UnregisterClass((LPCTSTR)pWinModule->m_rgWindowClassAtoms[i], hInst);

	mov	eax, DWORD PTR [esi+32]
	push	ebx
	movzx	eax, WORD PTR [eax+edi*2]
	push	eax
	call	DWORD PTR __imp__UnregisterClassW@8
	inc	edi
	cmp	edi, DWORD PTR [esi+36]
	jl	SHORT $LL4@AtlWinModu
	pop	ebx
$LN3@AtlWinModu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 216  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR [esi+32]
	pop	edi
	test	eax, eax
	je	SHORT $LN20@AtlWinModu

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 221  : 			m_aT = NULL;

	mov	DWORD PTR [esi+32], 0
$LN20@AtlWinModu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 181  : 		DeleteCriticalSection(&m_sec);

	lea	eax, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 223  : 		m_nSize = 0;

	mov	DWORD PTR [esi+36], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 181  : 		DeleteCriticalSection(&m_sec);

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 224  : 		m_nAllocSize = 0;

	mov	DWORD PTR [esi+40], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 181  : 		DeleteCriticalSection(&m_sec);

	call	DWORD PTR __imp__DeleteCriticalSection@4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 7672 : 	pWinModule->cbSize = 0;

	mov	DWORD PTR [esi], 0
$LN34@AtlWinModu:

; 7673 : 	return S_OK;

	xor	eax, eax
	pop	esi

; 7674 : }

	pop	ebp
	ret	8
$LN36@AtlWinModu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 240  : 			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);

	push	1
	push	-1073741684				; c000008cH
	call	?_AtlRaiseException@ATL@@YAXKK@Z	; ATL::_AtlRaiseException
$LN37@AtlWinModu:
$LN33@AtlWinModu:
	int	3
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ENDP ; ATL::AtlWinModuleTerm
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z
_TEXT	SEGMENT
_pWinModule$ = 8					; size = 4
?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z PROC ; ATL::AtlWinModuleInit, COMDAT

; 8404 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 8405 : 	if (pWinModule == NULL)

	mov	eax, DWORD PTR _pWinModule$[ebp]
	test	eax, eax
	jne	SHORT $LN2@AtlWinModu
$LN15@AtlWinModu:

; 8406 : 		return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H

; 8421 : }

	pop	ebp
	ret	4
$LN2@AtlWinModu:

; 8407 : 
; 8408 : 	// check only in the DLL
; 8409 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

	cmp	DWORD PTR [eax], 44			; 0000002cH
	jne	SHORT $LN15@AtlWinModu
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 170  : 		HRESULT hRes = S_OK;

	xor	esi, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 8412 : 	pWinModule->m_pCreateWndList = NULL;

	mov	DWORD PTR [eax+28], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	esi
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 171  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

	add	eax, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	eax
	call	DWORD PTR __imp__InitializeCriticalSectionEx@12
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 171  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

	test	eax, eax
	jne	SHORT $LN14@AtlWinModu

; 172  : 		{
; 173  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

	call	DWORD PTR __imp__GetLastError@0
	mov	esi, eax
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	test	esi, esi
	jle	SHORT $LN14@AtlWinModu
	movzx	esi, si
	or	esi, -2147024896			; 80070000H
$LN14@AtlWinModu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 8420 : 	return hr;

	mov	eax, esi
	pop	esi

; 8421 : }

	pop	ebp
	ret	4
?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ENDP ; ATL::AtlWinModuleInit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
;	COMDAT ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
	npad	2
	push	esi
	mov	esi, ecx

; 216  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN19@ATL_WIN_MO

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 221  : 			m_aT = NULL;

	mov	DWORD PTR [esi+32], 0
$LN19@ATL_WIN_MO:

; 222  : 		}
; 223  : 		m_nSize = 0;
; 224  : 		m_nAllocSize = 0;

	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+36], 0
	pop	esi
	ret	0
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
;	COMDAT ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	xorps	xmm0, xmm0
	mov	DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 151  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	movups	XMMWORD PTR [ecx+4], xmm0
	mov	eax, ecx
	movq	QWORD PTR [ecx+20], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 119  : 		m_aT(NULL), m_nSize(0), m_nAllocSize(0)

	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+40], 0
	mov	esp, ebp
	pop	ebp
	ret	0
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
;	COMDAT ??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[], COMDAT
; _this$ = ecx

; 236  : 	{

	npad	2
	push	ebp
	mov	ebp, esp

; 237  : 		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
; 238  : 		if(nIndex < 0 || nIndex >= m_nSize)

	mov	edx, DWORD PTR _nIndex$[ebp]
	test	edx, edx
	js	SHORT $LN6@operator
	cmp	edx, DWORD PTR [ecx+4]
	jge	SHORT $LN6@operator

; 241  : 		}
; 242  : 		return m_aT[nIndex];

	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*2]

; 243  : 	}

	pop	ebp
	ret	4
$LN6@operator:

; 239  : 		{
; 240  : 			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);

	push	1
	push	-1073741684				; c000008cH
	call	?_AtlRaiseException@ATL@@YAXKK@Z	; ATL::_AtlRaiseException
$LN7@operator:
$LN5@operator:
	int	3
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll, COMDAT
; _this$ = ecx

; 215  : 	{

	npad	2
	push	esi
	mov	esi, ecx

; 216  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@RemoveAll

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 221  : 			m_aT = NULL;

	mov	DWORD PTR [esi], 0
$LN11@RemoveAll:

; 222  : 		}
; 223  : 		m_nSize = 0;
; 224  : 		m_nAllocSize = 0;

	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+4], 0
	pop	esi

; 225  :     }

	ret	0
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
;	COMDAT ?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ
_TEXT	SEGMENT
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize, COMDAT
; _this$ = ecx

; 161  : 		return m_nSize;

	mov	eax, DWORD PTR [ecx+4]

; 162  : 	}

	ret	0
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
;	COMDAT ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 310  : {

	npad	2
	push	esi
	mov	esi, ecx

; 216  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@CSimpleArr

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 221  : 			m_aT = NULL;

	mov	DWORD PTR [esi], 0
$LN13@CSimpleArr:

; 222  : 		}
; 223  : 		m_nSize = 0;
; 224  : 		m_nAllocSize = 0;

	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+4], 0
	pop	esi

; 311  : 	RemoveAll();
; 312  : }

	ret	0
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
;	COMDAT ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 119  : 		m_aT(NULL), m_nSize(0), m_nAllocSize(0)

	mov	DWORD PTR [ecx], 0

; 121  : 	}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1_ATL_COM_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
??1_ATL_COM_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70, COMDAT
; _this$ = ecx
	ret	0
??1_ATL_COM_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
;	COMDAT ??0_ATL_COM_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
??0_ATL_COM_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70, COMDAT
; _this$ = ecx
	xorps	xmm0, xmm0
	mov	eax, ecx

; 151  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	movups	XMMWORD PTR [ecx+16], xmm0
	movq	QWORD PTR [ecx+32], xmm0
	ret	0
??0_ATL_COM_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtr@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComPtr@UIUnknown@@@ATL@@QAE@XZ PROC		; ATL::CComPtr<IUnknown>::~CComPtr<IUnknown>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComPtr@UIUnknown@@@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@CComPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN4@CComPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComPtr@UIUnknown@@@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComPtr@UIUnknown@@@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComPtr@UIUnknown@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<IUnknown>::~CComPtr<IUnknown>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UIUnknown@@@ATL@@QAE@PAUIUnknown@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtr@UIUnknown@@@ATL@@QAE@PAUIUnknown@@@Z PROC	; ATL::CComPtr<IUnknown>::CComPtr<IUnknown>, COMDAT
; _this$ = ecx

; 312  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi

; 312  :     {

	mov	esi, ecx

; 162  :         p = lp;

	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN6@CComPtr

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN6@CComPtr:

; 313  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtr@UIUnknown@@@ATL@@QAE@PAUIUnknown@@@Z ENDP	; ATL::CComPtr<IUnknown>::CComPtr<IUnknown>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??I?$CComPtrBase@UIUnknown@@@ATL@@QAEPAPAUIUnknown@@XZ
_TEXT	SEGMENT
??I?$CComPtrBase@UIUnknown@@@ATL@@QAEPAPAUIUnknown@@XZ PROC ; ATL::CComPtrBase<IUnknown>::operator&, COMDAT
; _this$ = ecx

; 192  :         ATLASSERT(p==NULL);
; 193  :         return &p;

	mov	eax, ecx

; 194  :     }

	ret	0
??I?$CComPtrBase@UIUnknown@@@ATL@@QAEPAPAUIUnknown@@XZ ENDP ; ATL::CComPtrBase<IUnknown>::operator&
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UIUnknown@@@ATL@@QAE@XZ PROC		; ATL::CComPtrBase<IUnknown>::~CComPtrBase<IUnknown>, COMDAT
; _this$ = ecx

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN2@CComPtrBas

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@CComPtrBas:

; 178  :     }

	ret	0
??1?$CComPtrBase@UIUnknown@@@ATL@@QAE@XZ ENDP		; ATL::CComPtrBase<IUnknown>::~CComPtrBase<IUnknown>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UIUnknown@@@ATL@@IAE@PAUIUnknown@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtrBase@UIUnknown@@@ATL@@IAE@PAUIUnknown@@@Z PROC ; ATL::CComPtrBase<IUnknown>::CComPtrBase<IUnknown>, COMDAT
; _this$ = ecx

; 160  :     CComPtrBase(_Inout_opt_ T* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp

; 161  :     {
; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN4@CComPtrBas

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN4@CComPtrBas:

; 165  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtrBase@UIUnknown@@@ATL@@IAE@PAUIUnknown@@@Z ENDP ; ATL::CComPtrBase<IUnknown>::CComPtrBase<IUnknown>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
;	COMDAT ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ PROC ; ATL::CAtlBaseModule::GetModuleInstance, COMDAT
; _this$ = ecx

; 316  : 		return m_hInst;

	mov	eax, DWORD PTR [ecx+4]

; 317  : 	}

	ret	0
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ENDP ; ATL::CAtlBaseModule::GetModuleInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
;	COMDAT ?Term@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
?Term@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Term, COMDAT
; _this$ = ecx

; 180  : 	{

	npad	2

; 181  : 		DeleteCriticalSection(&m_sec);

	push	ecx
	call	DWORD PTR __imp__DeleteCriticalSection@4

; 182  : 		return S_OK;

	xor	eax, eax

; 183  : 	}

	ret	0
?Term@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Term
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
;	COMDAT ?Init@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
?Init@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Init, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	0
	push	0
	push	ecx
	call	DWORD PTR __imp__InitializeCriticalSectionEx@12
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 171  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

	test	eax, eax
	jne	SHORT $LN10@Init

; 172  : 		{
; 173  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

	call	DWORD PTR __imp__GetLastError@0
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	test	eax, eax
	jle	SHORT $LN9@Init
	movzx	eax, ax
	or	eax, -2147024896			; 80070000H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 177  : 	}

	ret	0
$LN10@Init:

; 174  : 		}
; 175  : 
; 176  : 		return hRes;

	xor	eax, eax
$LN9@Init:

; 177  : 	}

	ret	0
?Init@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
;	COMDAT ??1CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
??1CComCriticalSection@ATL@@QAE@XZ PROC			; ATL::CComCriticalSection::~CComCriticalSection, COMDAT
; _this$ = ecx

; 156  : 	}

	ret	0
??1CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::~CComCriticalSection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
??0CComCriticalSection@ATL@@QAE@XZ PROC			; ATL::CComCriticalSection::CComCriticalSection, COMDAT
; _this$ = ecx

; 149  : 	CComCriticalSection() throw()

	xorps	xmm0, xmm0

; 150  : 	{
; 151  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));
; 152  : 	}

	mov	eax, ecx
	movups	XMMWORD PTR [ecx], xmm0
	movq	QWORD PTR [ecx+16], xmm0
	ret	0
??0CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::CComCriticalSection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
;	COMDAT ?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z
_TEXT	SEGMENT
_lpCriticalSection$ = 8					; size = 4
_dwSpinCount$ = 12					; size = 4
_Flags$ = 16						; size = 4
?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z PROC ; ATL::_AtlInitializeCriticalSectionEx, COMDAT

; 727  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 728  : #if (NTDDI_VERSION >= NTDDI_VISTA) && !defined(_USING_V110_SDK71_) && !defined(_ATL_XP_TARGETING)
; 729  : 	// InitializeCriticalSectionEx is available in Vista or later, desktop or store apps
; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	DWORD PTR _Flags$[ebp]
	push	DWORD PTR _dwSpinCount$[ebp]
	push	DWORD PTR _lpCriticalSection$[ebp]
	call	DWORD PTR __imp__InitializeCriticalSectionEx@12

; 731  : #else
; 732  : 	UNREFERENCED_PARAMETER(Flags);
; 733  : 
; 734  : 	// ...otherwise fall back to using InitializeCriticalSectionAndSpinCount.
; 735  : 	return ::InitializeCriticalSectionAndSpinCount(lpCriticalSection, dwSpinCount);
; 736  : #endif
; 737  : }

	pop	ebp
	ret	0
?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ENDP ; ATL::_AtlInitializeCriticalSectionEx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlexcept.h
;	COMDAT ?_AtlRaiseException@ATL@@YAXKK@Z
_TEXT	SEGMENT
_dwExceptionCode$ = 8					; size = 4
_dwExceptionFlags$ = 12					; size = 4
?_AtlRaiseException@ATL@@YAXKK@Z PROC			; ATL::_AtlRaiseException, COMDAT

; 30   : {

	npad	2
	push	ebp
	mov	ebp, esp

; 31   : 	RaiseException( dwExceptionCode, dwExceptionFlags, 0, NULL );

	push	0
	push	0
	push	DWORD PTR _dwExceptionFlags$[ebp]
	push	DWORD PTR _dwExceptionCode$[ebp]
	call	DWORD PTR __imp__RaiseException@16

; 32   : }

	pop	ebp
	ret	0
?_AtlRaiseException@ATL@@YAXKK@Z ENDP			; ATL::_AtlRaiseException
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z PROC ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z PROC ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z PROC ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\comdef.h
;	COMDAT ??_G_com_error@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_com_error@@UAEPAXI@Z PROC				; _com_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 317  :     if (m_perrinfo != NULL) {

	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi], OFFSET ??_7_com_error@@6B@
	test	ecx, ecx
	je	SHORT $LN5@scalar

; 318  :         m_perrinfo->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN5@scalar:

; 319  :     }
; 320  :     if (m_pszMsg != NULL) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN6@scalar

; 321  :         LocalFree((HLOCAL)m_pszMsg);

	push	eax
	call	DWORD PTR __imp__LocalFree@4
$LN6@scalar:
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN8@scalar
	push	16					; 00000010H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN8@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G_com_error@@UAEPAXI@Z ENDP				; _com_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\comdef.h
;	COMDAT ?HRESULTToWCode@_com_error@@SAGJ@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
?HRESULTToWCode@_com_error@@SAGJ@Z PROC			; _com_error::HRESULTToWCode, COMDAT

; 454  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 455  :     return (hr >= WCODE_HRESULT_FIRST && hr <= WCODE_HRESULT_LAST)

	mov	ecx, DWORD PTR _hr$[ebp]
	lea	eax, DWORD PTR [ecx+2147220992]
	cmp	eax, 65023				; 0000fdffH
	ja	SHORT $LN3@HRESULTToW
	lea	eax, DWORD PTR [ecx-512]
	movzx	eax, ax

; 456  :         ? WORD(hr - WCODE_HRESULT_FIRST)
; 457  :         : 0;
; 458  : }

	pop	ebp
	ret	0
$LN3@HRESULTToW:

; 455  :     return (hr >= WCODE_HRESULT_FIRST && hr <= WCODE_HRESULT_LAST)

	xor	eax, eax

; 456  :         ? WORD(hr - WCODE_HRESULT_FIRST)
; 457  :         : 0;
; 458  : }

	pop	ebp
	ret	0
?HRESULTToWCode@_com_error@@SAGJ@Z ENDP			; _com_error::HRESULTToWCode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\comdef.h
;	COMDAT ?ErrorMessage@_com_error@@QBEPB_WXZ
_TEXT	SEGMENT
?ErrorMessage@_com_error@@QBEPB_WXZ PROC		; _com_error::ErrorMessage, COMDAT
; _this$ = ecx

; 408  : {

	npad	2
	push	esi
	push	edi
	mov	edi, ecx

; 409  :     if (m_pszMsg == NULL) {

	cmp	DWORD PTR [edi+12], 0
	lea	esi, DWORD PTR [edi+12]
	jne	$LN19@ErrorMessa

; 410  :         FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|

	push	0
	push	0
	push	esi
	push	1024					; 00000400H
	push	DWORD PTR [edi+4]
	push	0
	push	4864					; 00001300H
	call	DWORD PTR __imp__FormatMessageW@28

; 411  :                           FORMAT_MESSAGE_FROM_SYSTEM|
; 412  :                           FORMAT_MESSAGE_IGNORE_INSERTS,
; 413  :                       NULL,
; 414  :                       m_hresult,
; 415  :                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
; 416  :                       (LPTSTR)&m_pszMsg,
; 417  :                       0,
; 418  :                       NULL);
; 419  :         if (m_pszMsg != NULL) {

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN3@ErrorMessa

; 420  :             #ifdef UNICODE
; 421  :             size_t const nLen = wcslen(m_pszMsg);

	mov	edx, ecx
	lea	edi, DWORD PTR [edx+2]
	npad	8
$LL17@ErrorMessa:
	mov	ax, WORD PTR [edx]
	add	edx, 2
	test	ax, ax
	jne	SHORT $LL17@ErrorMessa
	sub	edx, edi
	sar	edx, 1

; 422  :             #else
; 423  :             size_t const nLen = strlen(m_pszMsg);
; 424  :             #endif
; 425  :             if (nLen > 1 && m_pszMsg[nLen - 1] == '\n') {

	cmp	edx, 1
	jbe	SHORT $LN20@ErrorMessa
	cmp	WORD PTR [ecx+edx*2-2], 10		; 0000000aH
	jne	SHORT $LN20@ErrorMessa

; 426  :                 m_pszMsg[nLen - 1] = 0;

	xor	eax, eax
	mov	WORD PTR [ecx+edx*2-2], ax

; 427  :                 if (m_pszMsg[nLen - 2] == '\r') {

	mov	ecx, DWORD PTR [esi]
	cmp	WORD PTR [ecx+edx*2-4], 13		; 0000000dH
	jne	SHORT $LN20@ErrorMessa

; 428  :                         m_pszMsg[nLen - 2] = 0;

	mov	WORD PTR [ecx+edx*2-4], ax

; 441  :                 }
; 442  :             }
; 443  :         }
; 444  :     }
; 445  :     return m_pszMsg;

	mov	eax, DWORD PTR [esi]
	pop	edi
	pop	esi

; 446  : }

	ret	0
$LN20@ErrorMessa:
	pop	edi

; 441  :                 }
; 442  :             }
; 443  :         }
; 444  :     }
; 445  :     return m_pszMsg;

	mov	eax, ecx
	pop	esi

; 446  : }

	ret	0
$LN3@ErrorMessa:

; 429  :                 }
; 430  :             }
; 431  :         }
; 432  :         else {
; 433  :             m_pszMsg = (LPTSTR)LocalAlloc(0, 32 * sizeof(TCHAR));

	push	64					; 00000040H
	push	0
	call	DWORD PTR __imp__LocalAlloc@8
	mov	edx, eax
	mov	DWORD PTR [esi], edx

; 434  :             if (m_pszMsg != NULL) {

	test	edx, edx
	je	SHORT $LN9@ErrorMessa

; 341  :     return HRESULTToWCode(m_hresult);

	mov	edi, DWORD PTR [edi+4]

; 455  :     return (hr >= WCODE_HRESULT_FIRST && hr <= WCODE_HRESULT_LAST)

	lea	ecx, DWORD PTR [edi+2147220992]
	cmp	ecx, 65023				; 0000fdffH
	ja	SHORT $LN8@ErrorMessa
	lea	eax, DWORD PTR [edi-512]
	movzx	eax, ax

; 435  :                 WORD wCode = WCode();
; 436  :                 if (wCode != 0) {

	test	ax, ax
	je	SHORT $LN8@ErrorMessa

; 437  :                     _COM_PRINTF_S_1(m_pszMsg, 32, TEXT("IDispatch error #%d"), (int)wCode);

	push	eax
	push	OFFSET ??_C@_1CI@KPMALOMG@?$AAI?$AAD?$AAi?$AAs?$AAp?$AAa?$AAt?$AAc?$AAh?$AA?5?$AAe?$AAr?$AAr?$AAo?$AAr?$AA?5?$AA?$CD?$AA?$CF?$AAd?$AA?$AA@

; 438  :                 }
; 439  :                 else {
; 440  :                     _COM_PRINTF_S_1(m_pszMsg, 32, TEXT("Unknown error 0x%0lX"), m_hresult);

	push	32					; 00000020H
	push	edx
	call	_swprintf_s

; 441  :                 }
; 442  :             }
; 443  :         }
; 444  :     }
; 445  :     return m_pszMsg;

	mov	eax, DWORD PTR [esi]
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi

; 446  : }

	ret	0
$LN8@ErrorMessa:

; 438  :                 }
; 439  :                 else {
; 440  :                     _COM_PRINTF_S_1(m_pszMsg, 32, TEXT("Unknown error 0x%0lX"), m_hresult);

	push	edi
	push	OFFSET ??_C@_1CK@DOIMBAJG@?$AAU?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?5?$AAe?$AAr?$AAr?$AAo?$AAr?$AA?5?$AA0?$AAx?$AA?$CF?$AA0?$AAl?$AAX?$AA?$AA@
	push	32					; 00000020H
	push	edx
	call	_swprintf_s
	add	esp, 16					; 00000010H
$LN19@ErrorMessa:

; 441  :                 }
; 442  :             }
; 443  :         }
; 444  :     }
; 445  :     return m_pszMsg;

	mov	eax, DWORD PTR [esi]
$LN9@ErrorMessa:
	pop	edi
	pop	esi

; 446  : }

	ret	0
?ErrorMessage@_com_error@@QBEPB_WXZ ENDP		; _com_error::ErrorMessage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\comdef.h
;	COMDAT ?WCode@_com_error@@QBEGXZ
_TEXT	SEGMENT
?WCode@_com_error@@QBEGXZ PROC				; _com_error::WCode, COMDAT
; _this$ = ecx

; 341  :     return HRESULTToWCode(m_hresult);

	mov	ecx, DWORD PTR [ecx+4]

; 455  :     return (hr >= WCODE_HRESULT_FIRST && hr <= WCODE_HRESULT_LAST)

	lea	eax, DWORD PTR [ecx+2147220992]
	cmp	eax, 65023				; 0000fdffH
	ja	SHORT $LN5@WCode
	lea	eax, DWORD PTR [ecx-512]
	movzx	eax, ax

; 342  : }

	ret	0
$LN5@WCode:

; 455  :     return (hr >= WCODE_HRESULT_FIRST && hr <= WCODE_HRESULT_LAST)

	xor	eax, eax

; 342  : }

	ret	0
?WCode@_com_error@@QBEGXZ ENDP				; _com_error::WCode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\comdef.h
;	COMDAT ??1_com_error@@UAE@XZ
_TEXT	SEGMENT
??1_com_error@@UAE@XZ PROC				; _com_error::~_com_error, COMDAT
; _this$ = ecx

; 316  : {

	npad	2
	push	esi
	mov	esi, ecx

; 317  :     if (m_perrinfo != NULL) {

	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi], OFFSET ??_7_com_error@@6B@
	test	ecx, ecx
	je	SHORT $LN2@com_error

; 318  :         m_perrinfo->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@com_error:

; 319  :     }
; 320  :     if (m_pszMsg != NULL) {

	mov	eax, DWORD PTR [esi+12]
	pop	esi
	test	eax, eax
	je	SHORT $LN3@com_error

; 321  :         LocalFree((HLOCAL)m_pszMsg);

	push	eax
	call	DWORD PTR __imp__LocalFree@4
$LN3@com_error:

; 322  :     }
; 323  : }

	ret	0
??1_com_error@@UAE@XZ ENDP				; _com_error::~_com_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\comdef.h
;	COMDAT ??0_com_error@@QAE@JPAUIErrorInfo@@_N@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
_perrinfo$ = 12						; size = 4
_fAddRef$ = 16						; size = 1
??0_com_error@@QAE@JPAUIErrorInfo@@_N@Z PROC		; _com_error::_com_error, COMDAT
; _this$ = ecx

; 301  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 300  :     : m_hresult(hr), m_perrinfo(perrinfo), m_pszMsg(NULL)

	mov	eax, DWORD PTR _hr$[ebp]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _perrinfo$[ebp]
	mov	DWORD PTR [esi], OFFSET ??_7_com_error@@6B@
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], ecx
	mov	DWORD PTR [esi+12], 0

; 302  :     if (m_perrinfo != NULL && fAddRef) {

	test	ecx, ecx
	je	SHORT $LN4@com_error
	cmp	BYTE PTR _fAddRef$[ebp], 0
	je	SHORT $LN4@com_error

; 303  :         m_perrinfo->AddRef();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+4]
$LN4@com_error:

; 304  :     }
; 305  : }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	12					; 0000000cH
??0_com_error@@QAE@JPAUIErrorInfo@@_N@Z ENDP		; _com_error::_com_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
?WaitForInitDXGI@@YAXXZ PROC				; WaitForInitDXGI

; 480  :   if (CreateDXGIFactory_Import == nullptr)

	cmp	DWORD PTR ?CreateDXGIFactory_Import@@3P6GJABU_GUID@@PAPAX@ZA, 0 ; CreateDXGIFactory_Import
	jne	SHORT $LN8@WaitForIni

; 481  :   {
; 482  :     SK_BootDXGI ();

	call	?SK_BootDXGI@@YAXXZ			; SK_BootDXGI
$LN8@WaitForIni:
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?__dxgi_ready@@3JC	; __dxgi_ready
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 485  :   while (! ReadAcquire (&__dxgi_ready))

	test	eax, eax
	jne	SHORT $LN3@WaitForIni
	push	esi
	mov	esi, DWORD PTR __imp__MsgWaitForMultipleObjectsEx@20
	npad	2
$LL2@WaitForIni:

; 486  :   {
; 487  :     MsgWaitForMultipleObjectsEx (0, nullptr, config.system.init_delay, QS_ALLINPUT, MWMO_ALERTABLE);

	push	2
	push	1279					; 000004ffH
	push	DWORD PTR ?config@@3Usk_config_t@@A+800
	push	0
	push	0
	call	esi
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?__dxgi_ready@@3JC	; __dxgi_ready
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 485  :   while (! ReadAcquire (&__dxgi_ready))

	test	eax, eax
	je	SHORT $LL2@WaitForIni
	pop	esi
$LN3@WaitForIni:

; 488  :   }
; 489  : }

	ret	0
?WaitForInitDXGI@@YAXXZ ENDP				; WaitForInitDXGI
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?SK_DXGI_BorderCompensation@@YAXAAI0@Z PROC		; SK_DXGI_BorderCompensation

; 2187 :   UNREFERENCED_PARAMETER (x);
; 2188 :   UNREFERENCED_PARAMETER (y);
; 2189 : 
; 2190 : #if 0
; 2191 :   if (! config.window.borderless)
; 2192 :     return;
; 2193 : 
; 2194 :   RECT game_rect = *SK_GetGameRect ();
; 2195 : 
; 2196 :   int x_dlg = SK_GetSystemMetrics (SM_CXDLGFRAME);
; 2197 :   int y_dlg = SK_GetSystemMetrics (SM_CYDLGFRAME);
; 2198 :   int title = SK_GetSystemMetrics (SM_CYCAPTION);
; 2199 : 
; 2200 :   if ( SK_DiscontEpsilon (
; 2201 :           x,
; 2202 :             (game_rect.right - game_rect.left),
; 2203 :               2 * x_dlg + 1
; 2204 :        )
; 2205 : 
; 2206 :       ||
; 2207 : 
; 2208 :        SK_DiscontEpsilon (
; 2209 :           y,
; 2210 :             (game_rect.bottom - game_rect.top),
; 2211 :               2 * y_dlg + title + 1
; 2212 :        )
; 2213 :      )
; 2214 :   {
; 2215 :     x = game_rect.right  - game_rect.left;
; 2216 :     y = game_rect.bottom - game_rect.top;
; 2217 : 
; 2218 :     dll_log.Log ( L"[Window Mgr] Border Compensated Resolution ==> (%lu x %lu)",
; 2219 :                     x, y );
; 2220 :   }
; 2221 : #endif
; 2222 : }

	ret	0
?SK_DXGI_BorderCompensation@@YAXAAI0@Z ENDP		; SK_DXGI_BorderCompensation
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_pAdapter$ = 12						; size = 4
?SK_GetDXGIAdapterInterface@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUIUnknown@@@Z PROC ; SK_GetDXGIAdapterInterface

; 1185 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 1186 :   const int iver =
; 1187 :     SK_GetDXGIAdapterInterfaceVer (pAdapter);

	push	DWORD PTR _pAdapter$[ebp]
	mov	DWORD PTR $T1[ebp], 0
	call	?SK_GetDXGIAdapterInterfaceVer@@YAHPAUIUnknown@@@Z ; SK_GetDXGIAdapterInterfaceVer
	add	esp, 4

; 1188 : 
; 1189 :   if (iver == 3)

	cmp	eax, 3
	jne	SHORT $LN2@SK_GetDXGI

; 1190 :     return SK_GetDXGIAdapterInterfaceEx (__uuidof (IDXGIAdapter3));

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	OFFSET __GUID_645967a4_1392_4310_a798_8053ce3e93fd
	push	esi
	call	?SK_GetDXGIAdapterInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z ; SK_GetDXGIAdapterInterfaceEx
	add	esp, 8
	mov	eax, esi
	pop	esi

; 1202 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@SK_GetDXGI:

; 1191 : 
; 1192 :   if (iver == 2)

	cmp	eax, 2
	jne	SHORT $LN3@SK_GetDXGI

; 1193 :     return SK_GetDXGIAdapterInterfaceEx (__uuidof (IDXGIAdapter2));

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	OFFSET __GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5
	push	esi
	call	?SK_GetDXGIAdapterInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z ; SK_GetDXGIAdapterInterfaceEx
	add	esp, 8
	mov	eax, esi
	pop	esi

; 1202 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@SK_GetDXGI:

; 1194 : 
; 1195 :   if (iver == 1)

	cmp	eax, 1
	jne	SHORT $LN4@SK_GetDXGI

; 1196 :     return SK_GetDXGIAdapterInterfaceEx (__uuidof (IDXGIAdapter1));

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	OFFSET __GUID_29038f61_3839_4626_91fd_086879011a05
	push	esi
	call	?SK_GetDXGIAdapterInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z ; SK_GetDXGIAdapterInterfaceEx
	add	esp, 8
	mov	eax, esi
	pop	esi

; 1202 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@SK_GetDXGI:

; 1197 : 
; 1198 :   if (iver == 0)

	test	eax, eax
	jne	SHORT $LN5@SK_GetDXGI

; 1199 :     return SK_GetDXGIAdapterInterfaceEx (__uuidof (IDXGIAdapter));

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	OFFSET __GUID_2411e7e1_12ac_4ccf_bd14_9798e8534dc0
	push	esi
	call	?SK_GetDXGIAdapterInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z ; SK_GetDXGIAdapterInterfaceEx
	add	esp, 8
	mov	eax, esi
	pop	esi

; 1202 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@SK_GetDXGI:

; 1200 : 
; 1201 :   return L"{Invalid-Adapter-UUID}";

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	OFFSET $SG353137
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	esi

; 1202 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SK_GetDXGIAdapterInterface@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUIUnknown@@@Z ENDP ; SK_GetDXGIAdapterInterface
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_pTemp$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pAdapter$ = 8						; size = 4
?SK_GetDXGIAdapterInterfaceVer@@YAHPAUIUnknown@@@Z PROC	; SK_GetDXGIAdapterInterfaceVer

; 1152 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SK_GetDXGIAdapterInterfaceVer@@YAHPAUIUnknown@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pTemp$[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1155 :   if (SUCCEEDED(

	mov	esi, DWORD PTR _pAdapter$[ebp]
	lea	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	push	OFFSET __GUID_645967a4_1392_4310_a798_8053ce3e93fd
	push	esi
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	DWORD PTR [eax]
	test	eax, eax
	js	SHORT $LN2@SK_GetDXGI
	mov	esi, 3
	jmp	SHORT $LN11@SK_GetDXGI
$LN2@SK_GetDXGI:

; 1156 :     pAdapter->QueryInterface (__uuidof (IDXGIAdapter3), (void **)&pTemp)))
; 1157 :   {
; 1158 :     return 3;
; 1159 :   }
; 1160 : 
; 1161 :   if (SUCCEEDED(

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	push	OFFSET __GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5
	push	esi
	call	DWORD PTR [eax]
	test	eax, eax
	js	SHORT $LN3@SK_GetDXGI

; 1162 :     pAdapter->QueryInterface (__uuidof (IDXGIAdapter2), (void **)&pTemp)))
; 1163 :   {
; 1164 :     return 2;

	mov	esi, 2
	jmp	SHORT $LN11@SK_GetDXGI
$LN3@SK_GetDXGI:

; 1165 :   }
; 1166 : 
; 1167 :   if (SUCCEEDED(

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	push	OFFSET __GUID_29038f61_3839_4626_91fd_086879011a05
	push	esi
	call	DWORD PTR [eax]
	test	eax, eax
	js	SHORT $LN4@SK_GetDXGI

; 1168 :     pAdapter->QueryInterface (__uuidof (IDXGIAdapter1), (void **)&pTemp)))
; 1169 :   {
; 1170 :     return 1;

	mov	esi, 1
	jmp	SHORT $LN11@SK_GetDXGI
$LN4@SK_GetDXGI:

; 1171 :   }
; 1172 : 
; 1173 :   if (SUCCEEDED(

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	push	OFFSET __GUID_2411e7e1_12ac_4ccf_bd14_9798e8534dc0
	push	esi
	call	DWORD PTR [eax]
	test	eax, eax
	js	SHORT $LN5@SK_GetDXGI

; 1174 :     pAdapter->QueryInterface (__uuidof (IDXGIAdapter), (void **)&pTemp)))
; 1175 :   {
; 1176 :     return 0;

	xor	esi, esi
	jmp	SHORT $LN11@SK_GetDXGI
$LN5@SK_GetDXGI:

; 1180 :   return -1;

	or	esi, -1
$LN11@SK_GetDXGI:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	mov	ecx, DWORD PTR _pTemp$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1180 :   return -1;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	ecx, ecx
	je	SHORT $LN55@SK_GetDXGI

; 177  :             p->Release();

	mov	edx, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [edx+8]
$LN55@SK_GetDXGI:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1181 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_GetDXGIAdapterInterfaceVer@@YAHPAUIUnknown@@@Z$0:
	lea	ecx, DWORD PTR _pTemp$[ebp]
	jmp	??1?$CComPtr@UIUnknown@@@ATL@@QAE@XZ
__ehhandler$?SK_GetDXGIAdapterInterfaceVer@@YAHPAUIUnknown@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?SK_GetDXGIAdapterInterfaceVer@@YAHPAUIUnknown@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_GetDXGIAdapterInterfaceVer@@YAHPAUIUnknown@@@Z ENDP	; SK_GetDXGIAdapterInterfaceVer
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
$T2 = -20						; size = 4
_pwszIID$3 = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_riid$ = 12						; size = 4
?SK_GetDXGIAdapterInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z PROC ; SK_GetDXGIAdapterInterfaceEx

; 1125 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SK_GetDXGIAdapterInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	mov	DWORD PTR $T2[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	edi
	mov	DWORD PTR [esi+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [esi], ax
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	ebx, DWORD PTR _riid$[ebp]
	lea	edi, DWORD PTR [eax+12]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1147 :   return interface_name;

	mov	DWORD PTR __$EHRec$[ebp+8], eax
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	ecx, ebx
	mov	DWORD PTR $T2[ebp], 1
	mov	edx, OFFSET __GUID_2411e7e1_12ac_4ccf_bd14_9798e8534dc0
$LL79@SK_GetDXGI:
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN2@SK_GetDXGI
	add	ecx, 4
	add	edx, 4
	sub	edi, 4
	jae	SHORT $LL79@SK_GetDXGI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	12					; 0000000cH
	push	OFFSET $SG353092
	mov	ecx, esi
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	pop	edi
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1147 :   return interface_name;

	mov	eax, esi
	pop	esi
	pop	ebx

; 1148 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@SK_GetDXGI:
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	ecx, ebx
	mov	edx, OFFSET __GUID_29038f61_3839_4626_91fd_086879011a05
	mov	edi, 12					; 0000000cH
$LL81@SK_GetDXGI:
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN4@SK_GetDXGI
	add	ecx, 4
	add	edx, 4
	sub	edi, 4
	jae	SHORT $LL81@SK_GetDXGI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	13					; 0000000dH
	push	OFFSET $SG353095
	mov	ecx, esi
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	pop	edi
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1147 :   return interface_name;

	mov	eax, esi
	pop	esi
	pop	ebx

; 1148 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@SK_GetDXGI:
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	ecx, ebx
	mov	edx, OFFSET __GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5
	mov	edi, 12					; 0000000cH
$LL83@SK_GetDXGI:
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN6@SK_GetDXGI
	add	ecx, 4
	add	edx, 4
	sub	edi, 4
	jae	SHORT $LL83@SK_GetDXGI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	13					; 0000000dH
	push	OFFSET $SG353098
	mov	ecx, esi
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	pop	edi
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1147 :   return interface_name;

	mov	eax, esi
	pop	esi
	pop	ebx

; 1148 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@SK_GetDXGI:
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	ecx, ebx
	mov	edx, OFFSET __GUID_645967a4_1392_4310_a798_8053ce3e93fd
	mov	edi, 12					; 0000000cH
	npad	2
$LL85@SK_GetDXGI:
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN8@SK_GetDXGI
	add	ecx, 4
	add	edx, 4
	sub	edi, 4
	jae	SHORT $LL85@SK_GetDXGI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	13					; 0000000dH
	push	OFFSET $SG353101
	mov	ecx, esi
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	pop	edi
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1147 :   return interface_name;

	mov	eax, esi
	pop	esi
	pop	ebx

; 1148 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@SK_GetDXGI:

; 1126 :   std::wstring interface_name;
; 1127 : 
; 1128 :   if (riid == __uuidof (IDXGIAdapter))
; 1129 :     interface_name = L"IDXGIAdapter";
; 1130 :   else if (riid == __uuidof (IDXGIAdapter1))
; 1131 :     interface_name = L"IDXGIAdapter1";
; 1132 :   else if (riid == __uuidof (IDXGIAdapter2))
; 1133 :     interface_name = L"IDXGIAdapter2";
; 1134 :   else if (riid == __uuidof (IDXGIAdapter3))
; 1135 :     interface_name = L"IDXGIAdapter3";
; 1136 :   else
; 1137 :   {
; 1138 :     wchar_t *pwszIID = nullptr;
; 1139 : 
; 1140 :     if (SUCCEEDED (StringFromIID (riid, (LPOLESTR *)&pwszIID)))

	lea	eax, DWORD PTR _pwszIID$3[ebp]
	mov	DWORD PTR _pwszIID$3[ebp], 0
	push	eax
	push	ebx
	call	DWORD PTR __imp__StringFromIID@8
	test	eax, eax
	js	SHORT $LN86@SK_GetDXGI

; 1141 :     {
; 1142 :       interface_name = pwszIID;

	push	DWORD PTR _pwszIID$3[ebp]
	mov	ecx, esi
	call	??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=

; 1143 :       CoTaskMemFree   (pwszIID);

	push	DWORD PTR _pwszIID$3[ebp]
	call	DWORD PTR __imp__CoTaskMemFree@4
$LN86@SK_GetDXGI:

; 1148 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_GetDXGIAdapterInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z$0:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 1
	je	$LN13@SK_GetDXGI
	and	DWORD PTR $T2[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN13@SK_GetDXGI:
	ret	0
__ehhandler$?SK_GetDXGIAdapterInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?SK_GetDXGIAdapterInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_GetDXGIAdapterInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z ENDP ; SK_GetDXGIAdapterInterfaceEx
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_riid$ = 8						; size = 4
?SK_GetDXGIAdapterInterfaceVer@@YAHABU_GUID@@@Z PROC	; SK_GetDXGIAdapterInterfaceVer

; 1109 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	ecx, DWORD PTR _riid$[ebp]
	mov	edx, ecx
	push	esi
	push	edi
	mov	esi, OFFSET __GUID_2411e7e1_12ac_4ccf_bd14_9798e8534dc0
	mov	edi, 12					; 0000000cH
$LL24@SK_GetDXGI:
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [esi]
	jne	SHORT $LN2@SK_GetDXGI
	add	edx, 4
	add	esi, 4
	sub	edi, 4
	jae	SHORT $LL24@SK_GetDXGI
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1111 :     return 0;

	pop	edi
	xor	eax, eax
	pop	esi

; 1121 : }

	pop	ebp
	ret	0
$LN2@SK_GetDXGI:
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	edx, ecx
	mov	esi, OFFSET __GUID_29038f61_3839_4626_91fd_086879011a05
	mov	edi, 12					; 0000000cH
	npad	7
$LL26@SK_GetDXGI:
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [esi]
	jne	SHORT $LN3@SK_GetDXGI
	add	edx, 4
	add	esi, 4
	sub	edi, 4
	jae	SHORT $LL26@SK_GetDXGI
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1113 :     return 1;

	pop	edi
	mov	eax, 1
	pop	esi

; 1121 : }

	pop	ebp
	ret	0
$LN3@SK_GetDXGI:
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	edx, ecx
	mov	esi, OFFSET __GUID_0aa1ae0a_fa0e_4b84_8644_e05ff8e5acb5
	mov	edi, 12					; 0000000cH
$LL28@SK_GetDXGI:
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [esi]
	jne	SHORT $LN4@SK_GetDXGI
	add	edx, 4
	add	esi, 4
	sub	edi, 4
	jae	SHORT $LL28@SK_GetDXGI
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1115 :     return 2;

	pop	edi
	mov	eax, 2
	pop	esi

; 1121 : }

	pop	ebp
	ret	0
$LN4@SK_GetDXGI:
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	edx, OFFSET __GUID_645967a4_1392_4310_a798_8053ce3e93fd
	mov	esi, 12					; 0000000cH
	npad	6
$LL31@SK_GetDXGI:
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN30@SK_GetDXGI
	add	ecx, 4
	add	edx, 4
	sub	esi, 4
	jae	SHORT $LL31@SK_GetDXGI
	pop	edi
	mov	eax, 3
	pop	esi
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1121 : }

	pop	ebp
	ret	0
$LN30@SK_GetDXGI:
	pop	edi
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	or	eax, -1
	pop	esi
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1121 : }

	pop	ebp
	ret	0
?SK_GetDXGIAdapterInterfaceVer@@YAHABU_GUID@@@Z ENDP	; SK_GetDXGIAdapterInterfaceVer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_pFactory$ = 12						; size = 4
?SK_GetDXGIFactoryInterface@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUIUnknown@@@Z PROC ; SK_GetDXGIFactoryInterface

; 1082 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 1083 :   const int iver =
; 1084 :     SK_GetDXGIFactoryInterfaceVer (pFactory);

	push	DWORD PTR _pFactory$[ebp]
	mov	DWORD PTR $T1[ebp], 0
	call	?SK_GetDXGIFactoryInterfaceVer@@YAHPAUIUnknown@@@Z ; SK_GetDXGIFactoryInterfaceVer
	add	esp, 4

; 1085 : 
; 1086 :   if (iver == 5)

	cmp	eax, 5
	jne	SHORT $LN2@SK_GetDXGI

; 1087 :     return SK_GetDXGIFactoryInterfaceEx (__uuidof (IDXGIFactory5));

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	OFFSET __GUID_7632e1f5_ee65_4dca_87fd_84cd75f8838d
	push	esi
	call	?SK_GetDXGIFactoryInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z ; SK_GetDXGIFactoryInterfaceEx
	add	esp, 8
	mov	eax, esi
	pop	esi

; 1105 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@SK_GetDXGI:

; 1088 : 
; 1089 :   if (iver == 4)

	cmp	eax, 4
	jne	SHORT $LN3@SK_GetDXGI

; 1090 :     return SK_GetDXGIFactoryInterfaceEx (__uuidof (IDXGIFactory4));

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	OFFSET __GUID_1bc6ea02_ef36_464f_bf0c_21ca39e5168a
	push	esi
	call	?SK_GetDXGIFactoryInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z ; SK_GetDXGIFactoryInterfaceEx
	add	esp, 8
	mov	eax, esi
	pop	esi

; 1105 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@SK_GetDXGI:

; 1091 : 
; 1092 :   if (iver == 3)

	cmp	eax, 3
	jne	SHORT $LN4@SK_GetDXGI

; 1093 :     return SK_GetDXGIFactoryInterfaceEx (__uuidof (IDXGIFactory3));

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	OFFSET __GUID_25483823_cd46_4c7d_86ca_47aa95b837bd
	push	esi
	call	?SK_GetDXGIFactoryInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z ; SK_GetDXGIFactoryInterfaceEx
	add	esp, 8
	mov	eax, esi
	pop	esi

; 1105 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@SK_GetDXGI:

; 1094 : 
; 1095 :   if (iver == 2)

	cmp	eax, 2
	jne	SHORT $LN5@SK_GetDXGI

; 1096 :     return SK_GetDXGIFactoryInterfaceEx (__uuidof (IDXGIFactory2));

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	OFFSET __GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0
	push	esi
	call	?SK_GetDXGIFactoryInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z ; SK_GetDXGIFactoryInterfaceEx
	add	esp, 8
	mov	eax, esi
	pop	esi

; 1105 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@SK_GetDXGI:

; 1097 : 
; 1098 :   if (iver == 1)

	cmp	eax, 1
	jne	SHORT $LN6@SK_GetDXGI

; 1099 :     return SK_GetDXGIFactoryInterfaceEx (__uuidof (IDXGIFactory1));

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	OFFSET __GUID_770aae78_f26f_4dba_a829_253c83d1b387
	push	esi
	call	?SK_GetDXGIFactoryInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z ; SK_GetDXGIFactoryInterfaceEx
	add	esp, 8
	mov	eax, esi
	pop	esi

; 1105 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@SK_GetDXGI:

; 1100 : 
; 1101 :   if (iver == 0)

	test	eax, eax
	jne	SHORT $LN7@SK_GetDXGI

; 1102 :     return SK_GetDXGIFactoryInterfaceEx (__uuidof (IDXGIFactory));

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	OFFSET __GUID_7b7166ec_21c7_44ae_b21a_c9ae321ae369
	push	esi
	call	?SK_GetDXGIFactoryInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z ; SK_GetDXGIFactoryInterfaceEx
	add	esp, 8
	mov	eax, esi
	pop	esi

; 1105 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@SK_GetDXGI:

; 1103 : 
; 1104 :   return L"{Invalid-Factory-UUID}";

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	OFFSET $SG353070
	call	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	esi

; 1105 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SK_GetDXGIFactoryInterface@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAUIUnknown@@@Z ENDP ; SK_GetDXGIFactoryInterface
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_pTemp$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pFactory$ = 8						; size = 4
?SK_GetDXGIFactoryInterfaceVer@@YAHPAUIUnknown@@@Z PROC	; SK_GetDXGIFactoryInterfaceVer

; 1008 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SK_GetDXGIFactoryInterfaceVer@@YAHPAUIUnknown@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pTemp$[ebp], 0
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	mov	esi, DWORD PTR _pFactory$[ebp]
	lea	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	push	OFFSET __GUID_7632e1f5_ee65_4dca_87fd_84cd75f8838d
	push	esi
	mov	eax, DWORD PTR [esi]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1009 :   CComPtr <IUnknown> pTemp = nullptr;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	call	DWORD PTR [eax]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1011 :   if (SUCCEEDED (

	test	eax, eax
	js	SHORT $LN2@SK_GetDXGI

; 1012 :     pFactory->QueryInterface <IDXGIFactory5> ((IDXGIFactory5 **)&pTemp)))
; 1013 :   {
; 1014 :     dxgi_caps.device.enqueue_event    = true;
; 1015 :     dxgi_caps.device.latency_control  = true;
; 1016 :     dxgi_caps.present.flip_sequential = true;
; 1017 :     dxgi_caps.present.waitable        = true;
; 1018 :     dxgi_caps.present.flip_discard    = true;
; 1019 : 
; 1020 :     const HRESULT hr =
; 1021 :       static_cast <IDXGIFactory5 *>(pTemp.p)->CheckFeatureSupport (

	mov	eax, DWORD PTR _pTemp$[ebp]
	push	4
	push	OFFSET ?dxgi_caps@@3Udxgi_caps_t@@A+8
	mov	DWORD PTR ?dxgi_caps@@3Udxgi_caps_t@@A, 16843009 ; 01010101H
	mov	BYTE PTR ?dxgi_caps@@3Udxgi_caps_t@@A+4, 1
	mov	ecx, DWORD PTR [eax]
	push	0
	push	eax
	call	DWORD PTR [ecx+112]

; 1022 :         DXGI_FEATURE_PRESENT_ALLOW_TEARING,
; 1023 :           &dxgi_caps.swapchain.allow_tearing,
; 1024 :             sizeof (dxgi_caps.swapchain.allow_tearing)
; 1025 :       );
; 1026 : 
; 1027 :     dxgi_caps.swapchain.allow_tearing = 

	test	eax, eax
	js	SHORT $LN9@SK_GetDXGI
	cmp	DWORD PTR ?dxgi_caps@@3Udxgi_caps_t@@A+8, 0
	mov	DWORD PTR ?dxgi_caps@@3Udxgi_caps_t@@A+8, 1
	jne	SHORT $LN10@SK_GetDXGI
$LN9@SK_GetDXGI:
	mov	DWORD PTR ?dxgi_caps@@3Udxgi_caps_t@@A+8, 0
$LN10@SK_GetDXGI:
	mov	esi, 5
	jmp	$LN17@SK_GetDXGI
$LN2@SK_GetDXGI:
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	push	OFFSET __GUID_1bc6ea02_ef36_464f_bf0c_21ca39e5168a
	push	esi
	call	DWORD PTR [eax]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1033 :   if (SUCCEEDED (

	test	eax, eax
	js	SHORT $LN3@SK_GetDXGI

; 1034 :     pFactory->QueryInterface <IDXGIFactory4> ((IDXGIFactory4 **)&pTemp)))
; 1035 :   {
; 1036 :     dxgi_caps.device.enqueue_event    = true;
; 1037 :     dxgi_caps.device.latency_control  = true;

	mov	DWORD PTR ?dxgi_caps@@3Udxgi_caps_t@@A, 16843009 ; 01010101H

; 1038 :     dxgi_caps.present.flip_sequential = true;
; 1039 :     dxgi_caps.present.waitable        = true;
; 1040 :     dxgi_caps.present.flip_discard    = true;
; 1041 :     return 4;

	mov	esi, 4
	mov	BYTE PTR ?dxgi_caps@@3Udxgi_caps_t@@A+4, 1
	jmp	$LN17@SK_GetDXGI
$LN3@SK_GetDXGI:
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	push	OFFSET __GUID_25483823_cd46_4c7d_86ca_47aa95b837bd
	push	esi
	call	DWORD PTR [eax]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1044 :   if (SUCCEEDED (

	test	eax, eax
	js	SHORT $LN4@SK_GetDXGI

; 1045 :     pFactory->QueryInterface <IDXGIFactory3> ((IDXGIFactory3 **)&pTemp)))
; 1046 :   {
; 1047 :     dxgi_caps.device.enqueue_event    = true;
; 1048 :     dxgi_caps.device.latency_control  = true;

	mov	WORD PTR ?dxgi_caps@@3Udxgi_caps_t@@A, 257 ; 00000101H

; 1049 :     dxgi_caps.present.flip_sequential = true;
; 1050 :     dxgi_caps.present.waitable        = true;
; 1051 :     return 3;

	mov	esi, 3
	mov	BYTE PTR ?dxgi_caps@@3Udxgi_caps_t@@A+2, 1
	mov	BYTE PTR ?dxgi_caps@@3Udxgi_caps_t@@A+4, 1
	jmp	SHORT $LN17@SK_GetDXGI
$LN4@SK_GetDXGI:
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	push	OFFSET __GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0
	push	esi
	call	DWORD PTR [eax]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1054 :   if (SUCCEEDED (

	test	eax, eax
	js	SHORT $LN5@SK_GetDXGI

; 1055 :     pFactory->QueryInterface <IDXGIFactory2> ((IDXGIFactory2 **)&pTemp)))
; 1056 :   {
; 1057 :     dxgi_caps.device.enqueue_event    = true;
; 1058 :     dxgi_caps.device.latency_control  = true;

	mov	WORD PTR ?dxgi_caps@@3Udxgi_caps_t@@A, 257 ; 00000101H

; 1059 :     dxgi_caps.present.flip_sequential = true;
; 1060 :     return 2;

	mov	esi, 2
	mov	BYTE PTR ?dxgi_caps@@3Udxgi_caps_t@@A+2, 1
	jmp	SHORT $LN17@SK_GetDXGI
$LN5@SK_GetDXGI:
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	push	OFFSET __GUID_770aae78_f26f_4dba_a829_253c83d1b387
	push	esi
	call	DWORD PTR [eax]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1063 :   if (SUCCEEDED (

	test	eax, eax
	js	SHORT $LN6@SK_GetDXGI

; 1064 :     pFactory->QueryInterface <IDXGIFactory1> ((IDXGIFactory1 **)&pTemp)))
; 1065 :   {
; 1066 :     dxgi_caps.device.latency_control  = true;

	mov	BYTE PTR ?dxgi_caps@@3Udxgi_caps_t@@A, 1

; 1067 :     return 1;

	mov	esi, 1
	jmp	SHORT $LN17@SK_GetDXGI
$LN6@SK_GetDXGI:
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	push	OFFSET __GUID_7b7166ec_21c7_44ae_b21a_c9ae321ae369
	push	esi
	call	DWORD PTR [eax]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1070 :   if (SUCCEEDED (

	test	eax, eax
	js	SHORT $LN7@SK_GetDXGI

; 1071 :     pFactory->QueryInterface <IDXGIFactory> ((IDXGIFactory **)&pTemp)))
; 1072 :   {
; 1073 :     return 0;

	xor	esi, esi
	jmp	SHORT $LN17@SK_GetDXGI
$LN7@SK_GetDXGI:

; 1077 :   return -1;

	or	esi, -1
$LN17@SK_GetDXGI:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	mov	ecx, DWORD PTR _pTemp$[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1077 :   return -1;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	ecx, ecx
	je	SHORT $LN89@SK_GetDXGI

; 177  :             p->Release();

	mov	edx, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [edx+8]
$LN89@SK_GetDXGI:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1078 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_GetDXGIFactoryInterfaceVer@@YAHPAUIUnknown@@@Z$0:
	lea	ecx, DWORD PTR _pTemp$[ebp]
	jmp	??1?$CComPtr@UIUnknown@@@ATL@@QAE@XZ
__ehhandler$?SK_GetDXGIFactoryInterfaceVer@@YAHPAUIUnknown@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?SK_GetDXGIFactoryInterfaceVer@@YAHPAUIUnknown@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_GetDXGIFactoryInterfaceVer@@YAHPAUIUnknown@@@Z ENDP	; SK_GetDXGIFactoryInterfaceVer
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
$T2 = -20						; size = 4
_pwszIID$3 = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_riid$ = 12						; size = 4
?SK_GetDXGIFactoryInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z PROC ; SK_GetDXGIFactoryInterfaceEx

; 977  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SK_GetDXGIFactoryInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	mov	DWORD PTR $T2[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	edi
	mov	DWORD PTR [esi+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [esi], ax
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	ebx, DWORD PTR _riid$[ebp]
	lea	edi, DWORD PTR [eax+12]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1003 :   return interface_name;

	mov	DWORD PTR __$EHRec$[ebp+8], eax
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	ecx, ebx
	mov	DWORD PTR $T2[ebp], 1
	mov	edx, OFFSET __GUID_7b7166ec_21c7_44ae_b21a_c9ae321ae369
$LL91@SK_GetDXGI:
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN2@SK_GetDXGI
	add	ecx, 4
	add	edx, 4
	sub	edi, 4
	jae	SHORT $LL91@SK_GetDXGI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	18					; 00000012H
	push	OFFSET $SG352986
	mov	ecx, esi
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	pop	edi
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1003 :   return interface_name;

	mov	eax, esi
	pop	esi
	pop	ebx

; 1004 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@SK_GetDXGI:
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	ecx, ebx
	mov	edx, OFFSET __GUID_770aae78_f26f_4dba_a829_253c83d1b387
	mov	edi, 12					; 0000000cH
$LL93@SK_GetDXGI:
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN4@SK_GetDXGI
	add	ecx, 4
	add	edx, 4
	sub	edi, 4
	jae	SHORT $LL93@SK_GetDXGI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	18					; 00000012H
	push	OFFSET $SG352989
	mov	ecx, esi
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	pop	edi
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1003 :   return interface_name;

	mov	eax, esi
	pop	esi
	pop	ebx

; 1004 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@SK_GetDXGI:
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	ecx, ebx
	mov	edx, OFFSET __GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0
	mov	edi, 12					; 0000000cH
$LL95@SK_GetDXGI:
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN6@SK_GetDXGI
	add	ecx, 4
	add	edx, 4
	sub	edi, 4
	jae	SHORT $LL95@SK_GetDXGI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	18					; 00000012H
	push	OFFSET $SG352992
	mov	ecx, esi
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	pop	edi
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1003 :   return interface_name;

	mov	eax, esi
	pop	esi
	pop	ebx

; 1004 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@SK_GetDXGI:
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	ecx, ebx
	mov	edx, OFFSET __GUID_25483823_cd46_4c7d_86ca_47aa95b837bd
	mov	edi, 12					; 0000000cH
	npad	2
$LL97@SK_GetDXGI:
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN8@SK_GetDXGI
	add	ecx, 4
	add	edx, 4
	sub	edi, 4
	jae	SHORT $LL97@SK_GetDXGI
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	18					; 00000012H
	push	OFFSET $SG352995
	mov	ecx, esi
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	pop	edi
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 1003 :   return interface_name;

	mov	eax, esi
	pop	esi
	pop	ebx

; 1004 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@SK_GetDXGI:
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	ecx, ebx
	mov	edx, OFFSET __GUID_1bc6ea02_ef36_464f_bf0c_21ca39e5168a
	mov	edi, 12					; 0000000cH
	npad	2
$LL99@SK_GetDXGI:
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN10@SK_GetDXGI
	add	ecx, 4
	add	edx, 4
	sub	edi, 4
	jae	SHORT $LL99@SK_GetDXGI
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 989  :     interface_name = L"     IDXGIFactory4";

	push	OFFSET $SG352998
	mov	ecx, esi
	call	??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
	pop	edi

; 1003 :   return interface_name;

	mov	eax, esi
	pop	esi
	pop	ebx

; 1004 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@SK_GetDXGI:
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	ecx, ebx
	mov	edx, OFFSET __GUID_7632e1f5_ee65_4dca_87fd_84cd75f8838d
	mov	edi, 12					; 0000000cH
	npad	4
$LL101@SK_GetDXGI:
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN12@SK_GetDXGI
	add	ecx, 4
	add	edx, 4
	sub	edi, 4
	jae	SHORT $LL101@SK_GetDXGI
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 991  :     interface_name = L"     IDXGIFactory5";

	push	OFFSET $SG353001
	mov	ecx, esi
	call	??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
	pop	edi

; 1003 :   return interface_name;

	mov	eax, esi
	pop	esi
	pop	ebx

; 1004 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@SK_GetDXGI:

; 992  :   else
; 993  :   {
; 994  :     wchar_t *pwszIID = nullptr;
; 995  : 
; 996  :     if (SUCCEEDED (StringFromIID (riid, (LPOLESTR *)&pwszIID)))

	lea	eax, DWORD PTR _pwszIID$3[ebp]
	mov	DWORD PTR _pwszIID$3[ebp], 0
	push	eax
	push	ebx
	call	DWORD PTR __imp__StringFromIID@8
	test	eax, eax
	js	SHORT $LN102@SK_GetDXGI

; 997  :     {
; 998  :       interface_name = pwszIID;

	push	DWORD PTR _pwszIID$3[ebp]
	mov	ecx, esi
	call	??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=

; 999  :       CoTaskMemFree   (pwszIID);

	push	DWORD PTR _pwszIID$3[ebp]
	call	DWORD PTR __imp__CoTaskMemFree@4
$LN102@SK_GetDXGI:

; 1004 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_GetDXGIFactoryInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z$0:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 1
	je	$LN17@SK_GetDXGI
	and	DWORD PTR $T2[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN17@SK_GetDXGI:
	ret	0
__ehhandler$?SK_GetDXGIFactoryInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?SK_GetDXGIFactoryInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_GetDXGIFactoryInterfaceEx@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABU_GUID@@@Z ENDP ; SK_GetDXGIFactoryInterfaceEx
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_riid$ = 8						; size = 4
?SK_GetDXGIFactoryInterfaceVer@@YAHABU_GUID@@@Z PROC	; SK_GetDXGIFactoryInterfaceVer

; 957  : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	ecx, DWORD PTR _riid$[ebp]
	mov	edx, ecx
	push	esi
	push	edi
	mov	esi, OFFSET __GUID_7b7166ec_21c7_44ae_b21a_c9ae321ae369
	mov	edi, 12					; 0000000cH
$LL34@SK_GetDXGI:
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [esi]
	jne	SHORT $LN2@SK_GetDXGI
	add	edx, 4
	add	esi, 4
	sub	edi, 4
	jae	SHORT $LL34@SK_GetDXGI
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 959  :     return 0;

	pop	edi
	xor	eax, eax
	pop	esi

; 973  : }

	pop	ebp
	ret	0
$LN2@SK_GetDXGI:
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	edx, ecx
	mov	esi, OFFSET __GUID_770aae78_f26f_4dba_a829_253c83d1b387
	mov	edi, 12					; 0000000cH
	npad	7
$LL36@SK_GetDXGI:
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [esi]
	jne	SHORT $LN3@SK_GetDXGI
	add	edx, 4
	add	esi, 4
	sub	edi, 4
	jae	SHORT $LL36@SK_GetDXGI
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 961  :     return 1;

	pop	edi
	mov	eax, 1
	pop	esi

; 973  : }

	pop	ebp
	ret	0
$LN3@SK_GetDXGI:
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	edx, ecx
	mov	esi, OFFSET __GUID_50c83a1c_e072_4c48_87b0_3630fa36a6d0
	mov	edi, 12					; 0000000cH
$LL38@SK_GetDXGI:
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [esi]
	jne	SHORT $LN4@SK_GetDXGI
	add	edx, 4
	add	esi, 4
	sub	edi, 4
	jae	SHORT $LL38@SK_GetDXGI
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 963  :     return 2;

	pop	edi
	mov	eax, 2
	pop	esi

; 973  : }

	pop	ebp
	ret	0
$LN4@SK_GetDXGI:
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	edx, ecx
	mov	esi, OFFSET __GUID_25483823_cd46_4c7d_86ca_47aa95b837bd
	mov	edi, 12					; 0000000cH
	npad	4
$LL40@SK_GetDXGI:
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [esi]
	jne	SHORT $LN5@SK_GetDXGI
	add	edx, 4
	add	esi, 4
	sub	edi, 4
	jae	SHORT $LL40@SK_GetDXGI
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 965  :     return 3;

	pop	edi
	mov	eax, 3
	pop	esi

; 973  : }

	pop	ebp
	ret	0
$LN5@SK_GetDXGI:
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	edx, ecx
	mov	esi, OFFSET __GUID_1bc6ea02_ef36_464f_bf0c_21ca39e5168a
	mov	edi, 12					; 0000000cH
$LL42@SK_GetDXGI:
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [esi]
	jne	SHORT $LN6@SK_GetDXGI
	add	edx, 4
	add	esi, 4
	sub	edi, 4
	jae	SHORT $LL42@SK_GetDXGI
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 967  :     return 4;

	pop	edi
	mov	eax, 4
	pop	esi

; 973  : }

	pop	ebp
	ret	0
$LN6@SK_GetDXGI:
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	edx, OFFSET __GUID_7632e1f5_ee65_4dca_87fd_84cd75f8838d
	mov	esi, 12					; 0000000cH
	npad	6
$LL45@SK_GetDXGI:
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN44@SK_GetDXGI
	add	ecx, 4
	add	edx, 4
	sub	esi, 4
	jae	SHORT $LL45@SK_GetDXGI
	pop	edi
	mov	eax, 5
	pop	esi
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 973  : }

	pop	ebp
	ret	0
$LN44@SK_GetDXGI:
	pop	edi
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	or	eax, -1
	pop	esi
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 973  : }

	pop	ebp
	ret	0
?SK_GetDXGIFactoryInterfaceVer@@YAHABU_GUID@@@Z ENDP	; SK_GetDXGIFactoryInterfaceVer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_override_desc$1 = -596					; size = 292
_game_desc$2 = -304					; size = 292
_pGameAdapter$ = -12					; size = 4
_pOverrideAdapter$ = -8					; size = 4
_pFactory$ = -4						; size = 4
_ppAdapter$ = 8						; size = 4
_DriverType$ = 12					; size = 4
?SK_DXGI_AdapterOverride@@YGXPAPAUIDXGIAdapter@@PAW4D3D_DRIVER_TYPE@@@Z PROC ; SK_DXGI_AdapterOverride

; 4023 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 596				; 00000254H

; 4024 :   if (SK_DXGI_preferred_adapter == -1)

	cmp	DWORD PTR ?SK_DXGI_preferred_adapter@@3HA, -1 ; SK_DXGI_preferred_adapter
	je	$LN11@SK_DXGI_Ad

; 4025 :     return;
; 4026 : 
; 4027 :   if (EnumAdapters_Original == nullptr)

	cmp	DWORD PTR ?EnumAdapters_Original@@3P6GJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@@ZA, 0 ; EnumAdapters_Original
	jne	SHORT $LN4@SK_DXGI_Ad

; 4028 :   {
; 4029 :     WaitForInitDXGI ();

	call	?WaitForInitDXGI@@YAXXZ			; WaitForInitDXGI

; 4030 : 
; 4031 :     if (EnumAdapters_Original == nullptr)

	cmp	DWORD PTR ?EnumAdapters_Original@@3P6GJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@@ZA, 0 ; EnumAdapters_Original
	je	$LN11@SK_DXGI_Ad
$LN4@SK_DXGI_Ad:
	push	ebx

; 4032 :       return;
; 4033 :   }
; 4034 : 
; 4035 :   IDXGIAdapter* pGameAdapter     = (*ppAdapter);

	mov	ebx, DWORD PTR _ppAdapter$[ebp]
	push	esi
	push	edi

; 4036 :   IDXGIAdapter* pOverrideAdapter = nullptr;

	mov	DWORD PTR _pOverrideAdapter$[ebp], 0
	mov	edi, DWORD PTR [ebx]
	mov	DWORD PTR _pGameAdapter$[ebp], edi

; 4037 :   IDXGIFactory* pFactory         = nullptr;

	mov	DWORD PTR _pFactory$[ebp], 0

; 4038 : 
; 4039 :   HRESULT res;
; 4040 : 
; 4041 :   if ((*ppAdapter) == nullptr)

	test	edi, edi
	je	SHORT $LN24@SK_DXGI_Ad

; 4042 :     res = E_FAIL;
; 4043 :   else
; 4044 :     res = (*ppAdapter)->GetParent (IID_PPV_ARGS (&pFactory));

	mov	esi, DWORD PTR [edi]
	lea	eax, DWORD PTR _pFactory$[ebp]
	push	eax
	call	??$IID_PPV_ARGS_Helper@UIDXGIFactory@@@@YAPAPAXPAPAUIDXGIFactory@@@Z ; IID_PPV_ARGS_Helper<IDXGIFactory>
	add	esp, 4
	push	eax
	push	OFFSET __GUID_7b7166ec_21c7_44ae_b21a_c9ae321ae369
	push	edi
	call	DWORD PTR [esi+24]

; 4045 : 
; 4046 :   if (FAILED (res))

	test	eax, eax
	jns	SHORT $LN23@SK_DXGI_Ad
$LN24@SK_DXGI_Ad:

; 4047 :   {
; 4048 :     if (SK_DXGI_use_factory1)

	cmp	BYTE PTR ?SK_DXGI_use_factory1@@3_NA, 0	; SK_DXGI_use_factory1

; 4049 :       res = CreateDXGIFactory1_Import (__uuidof (IDXGIFactory1), static_cast_p2p <void> (&pFactory));

	lea	eax, DWORD PTR _pFactory$[ebp]
	push	eax
	je	SHORT $LN8@SK_DXGI_Ad
	push	OFFSET __GUID_770aae78_f26f_4dba_a829_253c83d1b387
	call	DWORD PTR ?CreateDXGIFactory1_Import@@3P6GJABU_GUID@@PAPAX@ZA ; CreateDXGIFactory1_Import

; 4050 :     else

	jmp	SHORT $LN9@SK_DXGI_Ad
$LN8@SK_DXGI_Ad:

; 4051 :       res = CreateDXGIFactory_Import  (__uuidof (IDXGIFactory),  static_cast_p2p <void> (&pFactory));

	push	OFFSET __GUID_7b7166ec_21c7_44ae_b21a_c9ae321ae369
	call	DWORD PTR ?CreateDXGIFactory_Import@@3P6GJABU_GUID@@PAPAX@ZA ; CreateDXGIFactory_Import
$LN9@SK_DXGI_Ad:

; 4052 :   }
; 4053 : 
; 4054 :   if (SUCCEEDED (res))

	test	eax, eax
	js	$LN25@SK_DXGI_Ad
$LN23@SK_DXGI_Ad:

; 4055 :   {
; 4056 :     if (pFactory != nullptr)

	mov	esi, DWORD PTR _pFactory$[ebp]
	test	esi, esi
	je	$LN25@SK_DXGI_Ad

; 4057 :     {
; 4058 :       if ((*ppAdapter) == nullptr)

	cmp	DWORD PTR [ebx], 0
	jne	SHORT $LN12@SK_DXGI_Ad

; 4059 :         EnumAdapters_Original (pFactory, 0, &pGameAdapter);

	lea	eax, DWORD PTR _pGameAdapter$[ebp]
	push	eax
	push	0
	push	esi
	call	DWORD PTR ?EnumAdapters_Original@@3P6GJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@@ZA ; EnumAdapters_Original
	mov	esi, DWORD PTR _pFactory$[ebp]
$LN12@SK_DXGI_Ad:

; 4060 : 
; 4061 :       DXGI_ADAPTER_DESC game_desc { };

	push	292					; 00000124H
	lea	eax, DWORD PTR _game_desc$2[ebp]
	push	0
	push	eax
	call	_memset

; 4062 : 
; 4063 :       if (pGameAdapter != nullptr)

	mov	ecx, DWORD PTR _pGameAdapter$[ebp]
	add	esp, 12					; 0000000cH
	test	ecx, ecx
	je	SHORT $LN13@SK_DXGI_Ad

; 4064 :       {
; 4065 :         *ppAdapter  = pGameAdapter;
; 4066 :         *DriverType = D3D_DRIVER_TYPE_UNKNOWN;

	mov	eax, DWORD PTR _DriverType$[ebp]
	mov	DWORD PTR [ebx], ecx
	mov	DWORD PTR [eax], 0

; 4067 : 
; 4068 :         GetDesc_Original (pGameAdapter, &game_desc);

	lea	eax, DWORD PTR _game_desc$2[ebp]
	push	eax
	push	ecx
	call	DWORD PTR ?GetDesc_Original@@3P6GJPAUIDXGIAdapter@@PAUDXGI_ADAPTER_DESC@@@ZA ; GetDesc_Original
	mov	esi, DWORD PTR _pFactory$[ebp]
$LN13@SK_DXGI_Ad:

; 4069 :       }
; 4070 : 
; 4071 :       if ( SK_DXGI_preferred_adapter != -1 &&

	mov	eax, DWORD PTR ?SK_DXGI_preferred_adapter@@3HA ; SK_DXGI_preferred_adapter
	cmp	eax, -1
	je	$LN14@SK_DXGI_Ad
	lea	ecx, DWORD PTR _pOverrideAdapter$[ebp]
	push	ecx
	push	eax
	push	esi
	call	DWORD PTR ?EnumAdapters_Original@@3P6GJPAUIDXGIFactory@@IPAPAUIDXGIAdapter@@@ZA ; EnumAdapters_Original
	test	eax, eax
	js	$LN14@SK_DXGI_Ad

; 4072 :            SUCCEEDED (EnumAdapters_Original (pFactory, SK_DXGI_preferred_adapter, &pOverrideAdapter)) )
; 4073 :       {
; 4074 :         DXGI_ADAPTER_DESC override_desc;
; 4075 :         GetDesc_Original (pOverrideAdapter, &override_desc);

	lea	eax, DWORD PTR _override_desc$1[ebp]
	push	eax
	push	DWORD PTR _pOverrideAdapter$[ebp]
	call	DWORD PTR ?GetDesc_Original@@3P6GJPAUIDXGIAdapter@@PAUDXGI_ADAPTER_DESC@@@ZA ; GetDesc_Original

; 4076 : 
; 4077 :         if ( game_desc.VendorId     == Vendors::Intel     &&
; 4078 :              override_desc.VendorId != Vendors::Microsoft &&

	cmp	DWORD PTR _game_desc$2[ebp+256], 32902	; 00008086H
	jne	SHORT $LN16@SK_DXGI_Ad
	mov	eax, DWORD PTR _override_desc$1[ebp+256]
	cmp	eax, 5140				; 00001414H
	je	SHORT $LN16@SK_DXGI_Ad
	cmp	eax, 32902				; 00008086H
	je	SHORT $LN16@SK_DXGI_Ad

; 4079 :              override_desc.VendorId != Vendors::Intel )
; 4080 :         {
; 4081 :           dll_log.Log ( L"[   DXGI   ] !!! DXGI Adapter Override: (Using '%s' instead of '%s') !!!",

	lea	eax, DWORD PTR _game_desc$2[ebp]
	push	eax
	lea	eax, DWORD PTR _override_desc$1[ebp]
	push	eax
	push	OFFSET $SG357107
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 4082 :                         override_desc.Description, game_desc.Description );
; 4083 : 
; 4084 :           *ppAdapter = pOverrideAdapter;

	mov	eax, DWORD PTR _pOverrideAdapter$[ebp]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [ebx], eax

; 4085 :           pGameAdapter->Release ();

	mov	eax, DWORD PTR _pGameAdapter$[ebp]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]

; 4100 :                         game_desc.Description );
; 4101 :       }
; 4102 : 
; 4103 :       pFactory->Release ();

	mov	eax, DWORD PTR _pFactory$[ebp]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]
	pop	edi
	pop	esi
	pop	ebx

; 4104 :     }
; 4105 :   }
; 4106 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN16@SK_DXGI_Ad:

; 4086 :         }
; 4087 : 
; 4088 :         else
; 4089 :         {
; 4090 :           dll_log.Log ( L"[   DXGI   ] !!! DXGI Adapter Override: (Tried '%s' instead of '%s') !!!",

	lea	eax, DWORD PTR _game_desc$2[ebp]
	push	eax
	lea	eax, DWORD PTR _override_desc$1[ebp]
	push	eax
	push	OFFSET $SG357108
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 4091 :                         override_desc.Description, game_desc.Description );
; 4092 :           //SK_DXGI_preferred_adapter = -1;
; 4093 :           pOverrideAdapter->Release ();

	mov	eax, DWORD PTR _pOverrideAdapter$[ebp]
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]

; 4100 :                         game_desc.Description );
; 4101 :       }
; 4102 : 
; 4103 :       pFactory->Release ();

	mov	eax, DWORD PTR _pFactory$[ebp]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]
	pop	edi
	pop	esi
	pop	ebx

; 4104 :     }
; 4105 :   }
; 4106 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN14@SK_DXGI_Ad:

; 4094 :         }
; 4095 :       }
; 4096 : 
; 4097 :       else
; 4098 :       {
; 4099 :         dll_log.Log ( L"[   DXGI   ] !!! DXGI Adapter Override Failed, returning '%s' !!!",

	lea	eax, DWORD PTR _game_desc$2[ebp]
	push	eax
	push	OFFSET $SG357109
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 4100 :                         game_desc.Description );
; 4101 :       }
; 4102 : 
; 4103 :       pFactory->Release ();

	mov	eax, DWORD PTR _pFactory$[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN25@SK_DXGI_Ad:
	pop	edi
	pop	esi
	pop	ebx
$LN11@SK_DXGI_Ad:

; 4104 :     }
; 4105 :   }
; 4106 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SK_DXGI_AdapterOverride@@YGXPAPAUIDXGIAdapter@@PAW4D3D_DRIVER_TYPE@@@Z ENDP ; SK_DXGI_AdapterOverride
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_out$ = -40						; size = 24
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_FeatureLevels$ = 12					; size = 4
_pFeatureLevels$ = 16					; size = 4
?SK_DXGI_FeatureLevelsToStr@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPBK@Z PROC ; SK_DXGI_FeatureLevelsToStr

; 592  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SK_DXGI_FeatureLevelsToStr@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPBK@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	esi
	push	edi

; 593  :   if (FeatureLevels == 0 || pFeatureLevels == nullptr)

	mov	edi, DWORD PTR _FeatureLevels$[ebp]
	mov	DWORD PTR $T2[ebp], 0
	test	edi, edi
	je	$LN8@SK_DXGI_Fe
	cmp	DWORD PTR _pFeatureLevels$[ebp], 0
	je	$LN8@SK_DXGI_Fe
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR _out$[ebp+16], 0

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	eax
	push	OFFSET $SG352568
	lea	ecx, DWORD PTR _out$[ebp]

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR _out$[ebp+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR _out$[ebp], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 598  :   for (int i = 0; i < FeatureLevels; i++)

	xor	esi, esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	edi, edi
	jle	$LN3@SK_DXGI_Fe
	npad	2
$LL4@SK_DXGI_Fe:
	mov	eax, DWORD PTR _pFeatureLevels$[ebp]
	mov	eax, DWORD PTR [eax+esi*4]

; 599  :   {
; 600  :     switch (pFeatureLevels [i])

	cmp	eax, 41216				; 0000a100H
	ja	SHORT $LN19@SK_DXGI_Fe
	je	SHORT $LN13@SK_DXGI_Fe
	cmp	eax, 37632				; 00009300H
	ja	SHORT $LN20@SK_DXGI_Fe
	je	SHORT $LN11@SK_DXGI_Fe
	cmp	eax, 37120				; 00009100H
	je	SHORT $LN9@SK_DXGI_Fe
	cmp	eax, 37376				; 00009200H
	jne	$LN2@SK_DXGI_Fe

; 605  :     case D3D_FEATURE_LEVEL_9_2:
; 606  :       out += L" 9_2";

	push	OFFSET $SG352572
	lea	ecx, DWORD PTR _out$[ebp]
	call	??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@QB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=

; 607  :       break;

	jmp	SHORT $LN2@SK_DXGI_Fe
$LN9@SK_DXGI_Fe:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2344 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	4
	push	OFFSET $SG352570
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 604  :       break;

	jmp	SHORT $LN222@SK_DXGI_Fe
$LN11@SK_DXGI_Fe:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2344 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	4
	push	OFFSET $SG352574
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 610  :       break;

	jmp	SHORT $LN222@SK_DXGI_Fe
$LN20@SK_DXGI_Fe:

; 599  :   {
; 600  :     switch (pFeatureLevels [i])

	cmp	eax, 40960				; 0000a000H
	jne	SHORT $LN2@SK_DXGI_Fe
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2344 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	5
	push	OFFSET $SG352576
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 613  :       break;

	jmp	SHORT $LN222@SK_DXGI_Fe
$LN13@SK_DXGI_Fe:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2344 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	5
	push	OFFSET $SG352578
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 616  :       break;

	jmp	SHORT $LN222@SK_DXGI_Fe
$LN19@SK_DXGI_Fe:

; 599  :   {
; 600  :     switch (pFeatureLevels [i])

	cmp	eax, 49152				; 0000c000H
	ja	SHORT $LN21@SK_DXGI_Fe
	je	SHORT $LN16@SK_DXGI_Fe
	cmp	eax, 45056				; 0000b000H
	je	SHORT $LN14@SK_DXGI_Fe
	cmp	eax, 45312				; 0000b100H
	jne	SHORT $LN2@SK_DXGI_Fe
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2344 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	5
	push	OFFSET $SG352582
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 622  :       break;

	jmp	SHORT $LN222@SK_DXGI_Fe
$LN14@SK_DXGI_Fe:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2344 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	5
	push	OFFSET $SG352580
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 619  :       break;

	jmp	SHORT $LN222@SK_DXGI_Fe
$LN16@SK_DXGI_Fe:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2344 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	5
	push	OFFSET $SG352584
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 625  :       break;

	jmp	SHORT $LN222@SK_DXGI_Fe
$LN21@SK_DXGI_Fe:

; 599  :   {
; 600  :     switch (pFeatureLevels [i])

	cmp	eax, 49408				; 0000c100H
	jne	SHORT $LN2@SK_DXGI_Fe
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2344 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	5
	push	OFFSET $SG352586
$LN222@SK_DXGI_Fe:
	lea	ecx, DWORD PTR _out$[ebp]
	call	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
$LN2@SK_DXGI_Fe:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 598  :   for (int i = 0; i < FeatureLevels; i++)

	inc	esi
	cmp	esi, edi
	jl	$LL4@SK_DXGI_Fe
$LN3@SK_DXGI_Fe:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1595 : 		_Mysize(0),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2143 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	xmm0, XMMWORD PTR _out$[ebp]
	pop	edi
	pop	esi

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [eax+16], 0

; 1596 : 		_Myres(0)

	mov	DWORD PTR [eax+20], 0

; 2143 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	XMMWORD PTR [eax], xmm0
	movq	xmm0, QWORD PTR _out$[ebp+16]
	movq	QWORD PTR [eax+16], xmm0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 633  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@SK_DXGI_Fe:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	3
	push	OFFSET $SG352567
	mov	ecx, esi

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [esi], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 633  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_DXGI_FeatureLevelsToStr@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPBK@Z$1:
	lea	ecx, DWORD PTR _out$[ebp]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__ehhandler$?SK_DXGI_FeatureLevelsToStr@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPBK@Z:
	mov	eax, OFFSET __ehfuncinfo$?SK_DXGI_FeatureLevelsToStr@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPBK@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_DXGI_FeatureLevelsToStr@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HPBK@Z ENDP ; SK_DXGI_FeatureLevelsToStr
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_swap_flags$ = 12					; size = 4
?SK_DXGI_DescribeSwapChainFlags@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4DXGI_SWAP_CHAIN_FLAG@@@Z PROC ; SK_DXGI_DescribeSwapChainFlags

; 550  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SK_DXGI_DescribeSwapChainFlags@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4DXGI_SWAP_CHAIN_FLAG@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	mov	DWORD PTR $T2[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, esi
	push	eax
	push	OFFSET $SG352532
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 550  : {

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [esi], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 585  :   return out;

	mov	ebx, DWORD PTR _swap_flags$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T2[ebp], 1
	test	bl, 1
	je	SHORT $LN2@SK_DXGI_De
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2344 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	16					; 00000010H
	push	OFFSET $SG352534
	mov	ecx, esi
	call	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
$LN2@SK_DXGI_De:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 556  :   if (swap_flags & DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH)

	test	bl, 2
	je	SHORT $LN3@SK_DXGI_De
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2344 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	29					; 0000001dH
	push	OFFSET $SG352536
	mov	ecx, esi
	call	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
$LN3@SK_DXGI_De:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 559  :   if (swap_flags & DXGI_SWAP_CHAIN_FLAG_GDI_COMPATIBLE)

	test	bl, 4
	je	SHORT $LN4@SK_DXGI_De
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2344 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	15					; 0000000fH
	push	OFFSET $SG352538
	mov	ecx, esi
	call	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
$LN4@SK_DXGI_De:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 562  :   if (swap_flags & DXGI_SWAP_CHAIN_FLAG_RESTRICTED_CONTENT)

	test	bl, 8
	je	SHORT $LN5@SK_DXGI_De
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2344 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	40					; 00000028H
	push	OFFSET $SG352540
	mov	ecx, esi
	call	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
$LN5@SK_DXGI_De:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 565  :   if (swap_flags & DXGI_SWAP_CHAIN_FLAG_RESTRICT_SHARED_RESOURCE_DRIVER)

	test	bl, 16					; 00000010H
	je	SHORT $LN6@SK_DXGI_De
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2344 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	53					; 00000035H
	push	OFFSET $SG352542
	mov	ecx, esi
	call	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
$LN6@SK_DXGI_De:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 568  :   if (swap_flags & DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT)

	test	bl, 64					; 00000040H
	je	SHORT $LN7@SK_DXGI_De
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2344 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	17					; 00000011H
	push	OFFSET $SG352544
	mov	ecx, esi
	call	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
$LN7@SK_DXGI_De:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 571  :   if (swap_flags & DXGI_SWAP_CHAIN_FLAG_FOREGROUND_LAYER)

	test	bl, bl
	jns	SHORT $LN8@SK_DXGI_De
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2344 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	38					; 00000026H
	push	OFFSET $SG352546
	mov	ecx, esi
	call	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
$LN8@SK_DXGI_De:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 574  :   if (swap_flags & DXGI_SWAP_CHAIN_FLAG_YUV_VIDEO)

	test	ebx, 512				; 00000200H
	je	SHORT $LN9@SK_DXGI_De
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2344 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	31					; 0000001fH
	push	OFFSET $SG352548
	mov	ecx, esi
	call	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
$LN9@SK_DXGI_De:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 579  :   if (swap_flags & DXGI_SWAP_CHAIN_FLAG_HW_PROTECTED)

	test	ebx, 1024				; 00000400H
	je	SHORT $LN10@SK_DXGI_De
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2344 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	34					; 00000022H
	push	OFFSET $SG352550
	mov	ecx, esi
	call	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
$LN10@SK_DXGI_De:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 582  :   if (swap_flags & DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING)

	test	ebx, 2048				; 00000800H
	je	SHORT $LN109@SK_DXGI_De
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2344 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	34					; 00000022H
	push	OFFSET $SG352552
	mov	ecx, esi
	call	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
$LN109@SK_DXGI_De:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 586  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_DXGI_DescribeSwapChainFlags@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4DXGI_SWAP_CHAIN_FLAG@@@Z$0:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 1
	je	$LN14@SK_DXGI_De
	and	DWORD PTR $T2[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN14@SK_DXGI_De:
	ret	0
__ehhandler$?SK_DXGI_DescribeSwapChainFlags@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4DXGI_SWAP_CHAIN_FLAG@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?SK_DXGI_DescribeSwapChainFlags@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4DXGI_SWAP_CHAIN_FLAG@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_DXGI_DescribeSwapChainFlags@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@W4DXGI_SWAP_CHAIN_FLAG@@@Z ENDP ; SK_DXGI_DescribeSwapChainFlags
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_swap_effect$ = 8					; size = 4
?SK_DXGI_DescribeSwapEffect@@YAPB_WW4DXGI_SWAP_EFFECT@@@Z PROC ; SK_DXGI_DescribeSwapEffect

; 532  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 533  :   switch (swap_effect)

	mov	eax, DWORD PTR _swap_effect$[ebp]
	cmp	eax, 4
	ja	SHORT $LN8@SK_DXGI_De
	jmp	DWORD PTR $LN11@SK_DXGI_De[eax*4]
$LN4@SK_DXGI_De:

; 534  :   {
; 535  :     case DXGI_SWAP_EFFECT_DISCARD:
; 536  :       return    L"Discard  (BitBlt)";

	mov	eax, OFFSET $SG352518

; 545  :   }
; 546  : }

	pop	ebp
	ret	0
$LN5@SK_DXGI_De:

; 537  :     case DXGI_SWAP_EFFECT_SEQUENTIAL:
; 538  :       return L"Sequential  (BitBlt)";

	mov	eax, OFFSET $SG352520

; 545  :   }
; 546  : }

	pop	ebp
	ret	0
$LN6@SK_DXGI_De:

; 539  :     case DXGI_SWAP_EFFECT_FLIP_DISCARD:
; 540  :       return    L"Discard  (Flip)";

	mov	eax, OFFSET $SG352522

; 545  :   }
; 546  : }

	pop	ebp
	ret	0
$LN7@SK_DXGI_De:

; 541  :     case DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL:
; 542  :       return L"Sequential  (Flip)";

	mov	eax, OFFSET $SG352524

; 545  :   }
; 546  : }

	pop	ebp
	ret	0
$LN8@SK_DXGI_De:

; 543  :     default:
; 544  :       return L"UNKNOWN";

	mov	eax, OFFSET $SG352526

; 545  :   }
; 546  : }

	pop	ebp
	ret	0
	npad	1
$LN11@SK_DXGI_De:
	DD	$LN4@SK_DXGI_De
	DD	$LN5@SK_DXGI_De
	DD	$LN8@SK_DXGI_De
	DD	$LN7@SK_DXGI_De
	DD	$LN6@SK_DXGI_De
?SK_DXGI_DescribeSwapEffect@@YAPB_WW4DXGI_SWAP_EFFECT@@@Z ENDP ; SK_DXGI_DescribeSwapEffect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_order$ = 8						; size = 4
?SK_DXGI_DescribeScanlineOrder@@YAPB_WW4DXGI_MODE_SCANLINE_ORDER@@@Z PROC ; SK_DXGI_DescribeScanlineOrder

; 514  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 515  :   switch (order)

	mov	eax, DWORD PTR _order$[ebp]
	cmp	eax, 3
	ja	SHORT $LN8@SK_DXGI_De
	jmp	DWORD PTR $LN11@SK_DXGI_De[eax*4]
$LN4@SK_DXGI_De:

; 516  :   {
; 517  :   case DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED:
; 518  :     return L"DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED";

	mov	eax, OFFSET $SG352503

; 527  :   }
; 528  : }

	pop	ebp
	ret	0
$LN5@SK_DXGI_De:

; 519  :   case DXGI_MODE_SCANLINE_ORDER_PROGRESSIVE:
; 520  :     return L"DXGI_MODE_SCANLINE_ORDER_PROGRESSIVE";

	mov	eax, OFFSET $SG352505

; 527  :   }
; 528  : }

	pop	ebp
	ret	0
$LN6@SK_DXGI_De:

; 521  :   case DXGI_MODE_SCANLINE_ORDER_UPPER_FIELD_FIRST:
; 522  :     return L"DXGI_MODE_SCANLINE_ORDER_UPPER_FIELD_FIRST";

	mov	eax, OFFSET $SG352507

; 527  :   }
; 528  : }

	pop	ebp
	ret	0
$LN7@SK_DXGI_De:

; 523  :   case DXGI_MODE_SCANLINE_ORDER_LOWER_FIELD_FIRST:
; 524  :     return L"DXGI_MODE_SCANLINE_ORDER_LOWER_FIELD_FIRST";

	mov	eax, OFFSET $SG352509

; 527  :   }
; 528  : }

	pop	ebp
	ret	0
$LN8@SK_DXGI_De:

; 525  :   default:
; 526  :     return L"UNKNOWN";

	mov	eax, OFFSET $SG352511

; 527  :   }
; 528  : }

	pop	ebp
	ret	0
	npad	1
$LN11@SK_DXGI_De:
	DD	$LN4@SK_DXGI_De
	DD	$LN5@SK_DXGI_De
	DD	$LN6@SK_DXGI_De
	DD	$LN7@SK_DXGI_De
?SK_DXGI_DescribeScanlineOrder@@YAPB_WW4DXGI_MODE_SCANLINE_ORDER@@@Z ENDP ; SK_DXGI_DescribeScanlineOrder
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_mode$ = 8						; size = 4
?SK_DXGI_DescribeScalingMode@@YAPB_WW4DXGI_MODE_SCALING@@@Z PROC ; SK_DXGI_DescribeScalingMode

; 498  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 499  :   switch (mode)

	mov	eax, DWORD PTR _mode$[ebp]
	sub	eax, 0
	je	SHORT $LN5@SK_DXGI_De
	sub	eax, 1
	je	SHORT $LN4@SK_DXGI_De
	sub	eax, 1
	je	SHORT $LN6@SK_DXGI_De

; 507  :     default:
; 508  :       return L"UNKNOWN";

	mov	eax, OFFSET $SG352496

; 509  :   }
; 510  : }

	pop	ebp
	ret	0
$LN6@SK_DXGI_De:

; 505  :     case DXGI_MODE_SCALING_STRETCHED:
; 506  :       return L"DXGI_MODE_SCALING_STRETCHED";

	mov	eax, OFFSET $SG352494

; 509  :   }
; 510  : }

	pop	ebp
	ret	0
$LN4@SK_DXGI_De:

; 500  :   {
; 501  :     case DXGI_MODE_SCALING_CENTERED:
; 502  :       return L"DXGI_MODE_SCALING_CENTERED";

	mov	eax, OFFSET $SG352490

; 509  :   }
; 510  : }

	pop	ebp
	ret	0
$LN5@SK_DXGI_De:

; 503  :     case DXGI_MODE_SCALING_UNSPECIFIED:
; 504  :       return L"DXGI_MODE_SCALING_UNSPECIFIED";

	mov	eax, OFFSET $SG352492

; 509  :   }
; 510  : }

	pop	ebp
	ret	0
?SK_DXGI_DescribeScalingMode@@YAPB_WW4DXGI_MODE_SCALING@@@Z ENDP ; SK_DXGI_DescribeScalingMode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xatomic.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_phEvents$1 = -44					; size = 8
tv1557 = -36						; size = 4
_dwWaitStatus$1$ = -32					; size = 4
tv1758 = -28						; size = 8
tv1552 = -24						; size = 4
tv1565 = -20						; size = 4
tv1556 = -16						; size = 4
_nodes$1$ = -12						; size = 4
$T2 = -12						; size = 4
_i$1$ = -8						; size = 4
$T3 = -8						; size = 4
_success$1$ = -1					; size = 1
_user_data$ = 8						; size = 4
?BudgetThread@DXGI@SK@@YGKPAX@Z PROC			; SK::DXGI::BudgetThread

; 5564 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi

; 5565 :   auto* params =
; 5566 :     static_cast <budget_thread_params_t *> (user_data);
; 5567 : 
; 5568 :   budget_log.silent = true;

	mov	BYTE PTR ?budget_log@@3UiSK_Logger@@A+32, 1

; 5569 :   params->tid       = GetCurrentThreadId ();

	call	DWORD PTR __imp__GetCurrentThreadId@0
	mov	ebx, DWORD PTR _user_data$[ebp]

; 5570 :   params->event     =

	mov	esi, DWORD PTR __imp__CreateEventW@16
	push	OFFSET $SG370201
	push	0
	push	0
	push	0
	mov	DWORD PTR [ebx+4], eax
	call	esi

; 5571 :     CreateEvent ( nullptr,
; 5572 :                     FALSE,
; 5573 :                       FALSE,
; 5574 :                         L"DXGIMemoryBudget"
; 5575 :                 );
; 5576 :   params->shutdown  = 

	push	OFFSET $SG370202
	push	0
	push	0
	push	0
	mov	DWORD PTR [ebx+16], eax
	call	esi
	mov	DWORD PTR [ebx+20], eax

; 5577 :     CreateEvent ( nullptr,
; 5578 :                     FALSE,
; 5579 :                       FALSE,
; 5580 :                         L"DXGIMemoryBudget_Shutdown" );
; 5581 : 
; 5582 :   InterlockedExchange ( &params->ready, TRUE );

	lea	esi, DWORD PTR [ebx+24]
	mov	eax, 1
	xchg	DWORD PTR [esi], eax

; 5586 :     SUCCEEDED ( CoInitializeEx (nullptr, COINIT_MULTITHREADED ) );

	push	0
	push	0
	call	DWORD PTR __imp__CoInitializeEx@8
	test	eax, eax
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR [esi]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5586 :     SUCCEEDED ( CoInitializeEx (nullptr, COINIT_MULTITHREADED ) );

	setns	BYTE PTR _success$1$[ebp]

; 5589 :   while ( ReadAcquire ( &params->ready ) )

	test	eax, eax
	je	$LN3@BudgetThre

; 5666 :              params->pAdapter->QueryVideoMemoryInfo (
; 5667 :                node,
; 5668 :                  DXGI_MEMORY_SEGMENT_GROUP_NON_LOCAL,
; 5669 :                    &mem_info [buffer].nonlocal [node++]
; 5670 :              )
; 5671 :            )
; 5672 :          )
; 5673 :       {
; 5674 :         break;
; 5675 :       }
; 5676 :     }
; 5677 : 
; 5678 : 
; 5679 :     // Set the number of SLI/CFX Nodes
; 5680 :     mem_info [buffer].nodes = nodes;
; 5681 : 
; 5682 :     static uint64_t
; 5683 :       last_budget = mem_info [buffer].local [0].Budget;

	mov	ecx, DWORD PTR __tls_index
	mov	eax, DWORD PTR fs:__tls_array
	push	edi
	mov	edi, DWORD PTR __imp__ResetEvent@4
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR tv1565[ebp], eax
$LL2@BudgetThre:

; 5590 :   {
; 5591 :     if (__SK_DLL_Ending)

	cmp	DWORD PTR ?__SK_DLL_Ending@@3JC, 0	; __SK_DLL_Ending
	jne	$LN111@BudgetThre

; 5592 :       break;
; 5593 : 
; 5594 :     if ( params->event == nullptr )

	mov	eax, DWORD PTR [ebx+16]
	test	eax, eax
	je	$LN111@BudgetThre

; 5595 :       break;
; 5596 : 
; 5597 :     HANDLE phEvents [] = { params->event, params->shutdown };

	mov	DWORD PTR _phEvents$1[ebp], eax
	mov	eax, DWORD PTR [ebx+20]

; 5600 :       WaitForMultipleObjects ( 2,

	push	399					; 0000018fH
	mov	DWORD PTR _phEvents$1[ebp+4], eax
	lea	eax, DWORD PTR _phEvents$1[ebp]
	push	0
	push	eax
	push	2
	call	DWORD PTR __imp__WaitForMultipleObjects@16
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	ecx, DWORD PTR [esi]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5600 :       WaitForMultipleObjects ( 2,

	mov	DWORD PTR _dwWaitStatus$1$[ebp], eax

; 5601 :                                  phEvents,
; 5602 :                                    FALSE,
; 5603 :                                      BUDGET_POLL_INTERVAL * 3 );
; 5604 : 
; 5605 :     if (! ReadAcquire ( &params->ready ) )

	test	ecx, ecx
	je	$LN82@BudgetThre

; 5608 :       break;
; 5609 :     }
; 5610 : 
; 5611 :     if (dwWaitStatus == WAIT_OBJECT_0 + 1)

	cmp	eax, 1
	je	$LN83@BudgetThre

; 5615 :       break;
; 5616 :     }
; 5617 : 
; 5618 :     int         node = 0;
; 5619 : 
; 5620 :     buffer_t buffer  =
; 5621 :       mem_info [node].buffer;

	mov	esi, DWORD PTR ?mem_info@@3PAUmem_info_t@@A+272

; 5622 : 
; 5623 : 
; 5624 :     SK_D3D11_Textures.Budget = mem_info [buffer].local [0].Budget -

	imul	eax, esi, 280
	mov	edx, DWORD PTR ?mem_info@@3PAUmem_info_t@@A[eax]
	sub	edx, DWORD PTR ?mem_info@@3PAUmem_info_t@@A[eax+8]
	mov	ecx, DWORD PTR ?mem_info@@3PAUmem_info_t@@A[eax+4]
	sbb	ecx, DWORD PTR ?mem_info@@3PAUmem_info_t@@A[eax+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xatomic.h

; 1818 : 			_Store_seq_cst_8(_Tgt, _Value);

	push	ecx
	push	edx
	push	OFFSET ?SK_D3D11_Textures@@3VSK_D3D11_TexMgr@@A+248
	call	?_Store_seq_cst_8@std@@YAXPC_K_K@Z	; std::_Store_seq_cst_8
	xor	eax, eax
	add	esp, 12					; 0000000cH
	test	esi, esi
	sete	al
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5635 :     GetLocalTime ( &mem_info [buffer].time );

	imul	ebx, eax, 280
	mov	DWORD PTR tv1557[ebp], eax
	mov	DWORD PTR tv1556[ebp], ebx
	lea	eax, DWORD PTR ?mem_info@@3PAUmem_info_t@@A[ebx+256]
	push	eax
	call	DWORD PTR __imp__GetLocalTime@4
	lea	ebx, DWORD PTR ?mem_info@@3PAUmem_info_t@@A[ebx]

; 5636 : 
; 5637 :     //
; 5638 :     // Sample Fast nUMA (On-GPU / Dedicated) Memory
; 5639 :     //
; 5640 :     for ( node = 0; node < MAX_GPU_NODES; )

	xor	esi, esi
	mov	DWORD PTR tv1552[ebp], ebx
	mov	edi, ebx
	npad	6
$LL4@BudgetThre:

; 5641 :     {
; 5642 :       if ( FAILED (

	mov	eax, DWORD PTR _user_data$[ebp]
	push	edi
	push	0
	push	esi
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+56]
	inc	esi
	add	edi, 32					; 00000020H
	test	eax, eax
	js	SHORT $LN78@BudgetThre

; 5636 : 
; 5637 :     //
; 5638 :     // Sample Fast nUMA (On-GPU / Dedicated) Memory
; 5639 :     //
; 5640 :     for ( node = 0; node < MAX_GPU_NODES; )

	cmp	esi, 4
	jl	SHORT $LL4@BudgetThre
$LN78@BudgetThre:
	mov	ebx, DWORD PTR _user_data$[ebp]

; 5658 :       std::max (0, node - 1);

	lea	eax, DWORD PTR [esi-1]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 3743 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	test	eax, eax
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5658 :       std::max (0, node - 1);

	mov	DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 3743 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	ecx, DWORD PTR $T2[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5658 :       std::max (0, node - 1);

	mov	DWORD PTR $T3[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 3743 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	lea	edx, DWORD PTR $T3[ebp]
	cmovle	ecx, edx
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5663 :     for ( node = 0; node < MAX_GPU_NODES; )

	xor	esi, esi
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _nodes$1$[ebp], eax
	mov	eax, DWORD PTR tv1556[ebp]
	lea	edi, DWORD PTR ?mem_info@@3PAUmem_info_t@@A[eax+128]
$LL7@BudgetThre:

; 5664 :     {
; 5665 :       if ( FAILED (

	mov	eax, DWORD PTR [ebx]
	push	edi
	push	1
	push	esi
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+56]
	inc	esi
	add	edi, 32					; 00000020H
	test	eax, eax
	js	SHORT $LN79@BudgetThre

; 5663 :     for ( node = 0; node < MAX_GPU_NODES; )

	cmp	esi, 4
	jl	SHORT $LL7@BudgetThre
$LN79@BudgetThre:

; 5666 :              params->pAdapter->QueryVideoMemoryInfo (
; 5667 :                node,
; 5668 :                  DXGI_MEMORY_SEGMENT_GROUP_NON_LOCAL,
; 5669 :                    &mem_info [buffer].nonlocal [node++]
; 5670 :              )
; 5671 :            )
; 5672 :          )
; 5673 :       {
; 5674 :         break;
; 5675 :       }
; 5676 :     }
; 5677 : 
; 5678 : 
; 5679 :     // Set the number of SLI/CFX Nodes
; 5680 :     mem_info [buffer].nodes = nodes;
; 5681 : 
; 5682 :     static uint64_t
; 5683 :       last_budget = mem_info [buffer].local [0].Budget;

	mov	eax, DWORD PTR tv1565[ebp]
	mov	edi, DWORD PTR tv1556[ebp]
	mov	esi, DWORD PTR _nodes$1$[ebp]
	mov	ebx, DWORD PTR tv1552[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ?$TSS0@?3??BudgetThread@DXGI@SK@@YGKPAX@Z@4HA
	mov	DWORD PTR ?mem_info@@3PAUmem_info_t@@A[edi+276], esi
	cmp	eax, DWORD PTR __Init_thread_epoch[ecx]
	jg	$LN113@BudgetThre
$LN10@BudgetThre:

; 5684 : 
; 5685 : 
; 5686 :     if ( nodes > 0 )

	test	esi, esi
	jle	$LN25@BudgetThre

; 5687 :     {
; 5688 :       int i;
; 5689 : 
; 5690 :       budget_log.LogEx ( true,

	push	OFFSET $SG370212
	push	1
	push	OFFSET ?budget_log@@3UiSK_Logger@@A	; budget_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx

; 5691 :                            L"[ DXGI 1.4 ] Local Memory.....:" );
; 5692 : 
; 5693 :       for ( i = 0; i < nodes; i++ )

	xor	ebx, ebx
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _i$1$[ebp], ebx
	test	esi, esi
	jle	$LN12@BudgetThre

; 5687 :     {
; 5688 :       int i;
; 5689 : 
; 5690 :       budget_log.LogEx ( true,

	mov	esi, OFFSET ?mem_stats@@3PAUmemory_stats_t@@A+24
	lea	edi, DWORD PTR ?mem_info@@3PAUmem_info_t@@A[edi+24]
	npad	7
$LL13@BudgetThre:

; 5694 :       {
; 5695 :         if ( dwWaitStatus == WAIT_OBJECT_0 )

	cmp	DWORD PTR _dwWaitStatus$1$[ebp], 0
	jne	SHORT $LN26@BudgetThre

; 5696 :         {
; 5697 :           static UINT64
; 5698 :             LastBudget = 0ULL;
; 5699 : 
; 5700 :           mem_stats [i].budget_changes++;

	add	DWORD PTR [esi+56], 1

; 5701 : 
; 5702 :           const int64_t over_budget =
; 5703 :             ( mem_info [buffer].local [i].CurrentUsage -

	mov	ecx, DWORD PTR [edi-16]
	adc	DWORD PTR [esi+60], 0
	mov	edx, DWORD PTR [edi-24]
	sub	ecx, edx
	mov	eax, DWORD PTR [edi-12]
	mov	ebx, DWORD PTR [edi-20]
	sbb	eax, ebx

; 5704 :               mem_info [buffer].local [i].Budget );
; 5705 : 
; 5706 :             //LastBudget -
; 5707 :             //mem_info [buffer].local [i].Budget;
; 5708 : 
; 5709 :           SK_D3D11_need_tex_reset = ( over_budget > 0 );

	mov	DWORD PTR tv1758[ebp+4], eax
	js	SHORT $LN42@BudgetThre
	jg	SHORT $LN97@BudgetThre
	test	ecx, ecx
	je	SHORT $LN42@BudgetThre
$LN97@BudgetThre:
	mov	BYTE PTR ?SK_D3D11_need_tex_reset@@3_NA, 1 ; SK_D3D11_need_tex_reset
	jmp	SHORT $LN43@BudgetThre
$LN42@BudgetThre:
	mov	BYTE PTR ?SK_D3D11_need_tex_reset@@3_NA, 0 ; SK_D3D11_need_tex_reset
$LN43@BudgetThre:

; 5710 : 
; 5711 :           LastBudget =

	mov	DWORD PTR ?LastBudget@?CD@??BudgetThread@DXGI@SK@@YGKPAX@Z@4_KA+4, ebx
	mov	ebx, DWORD PTR _i$1$[ebp]
	mov	DWORD PTR ?LastBudget@?CD@??BudgetThread@DXGI@SK@@YGKPAX@Z@4_KA, edx
$LN26@BudgetThre:

; 5712 :             mem_info [buffer].local [i].Budget;
; 5713 :         }
; 5714 : 
; 5715 :         if ( i > 0 )

	test	ebx, ebx
	jle	SHORT $LN27@BudgetThre

; 5716 :         {
; 5717 :           budget_log.LogEx ( false, L"\n"                                );

	push	OFFSET $SG370215
	push	0
	push	OFFSET ?budget_log@@3UiSK_Logger@@A	; budget_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx

; 5718 :           budget_log.LogEx ( true,  L"                                 " );

	push	OFFSET $SG370216
	push	1
	push	OFFSET ?budget_log@@3UiSK_Logger@@A	; budget_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	add	esp, 24					; 00000018H
$LN27@BudgetThre:

; 5719 :         }
; 5720 : 
; 5721 :         budget_log.LogEx (

	mov	ecx, DWORD PTR [edi-24]
	mov	eax, DWORD PTR [edi-20]
	shrd	ecx, eax, 20
	shr	eax, 20					; 00000014H
	push	eax
	mov	eax, DWORD PTR [edi-12]
	push	ecx
	mov	ecx, DWORD PTR [edi-16]
	shrd	ecx, eax, 20
	shr	eax, 20					; 00000014H
	push	eax
	mov	eax, DWORD PTR [edi-4]
	push	ecx
	mov	ecx, DWORD PTR [edi-8]
	shrd	ecx, eax, 20
	shr	eax, 20					; 00000014H
	push	eax
	mov	eax, DWORD PTR [edi+4]
	push	ecx
	mov	ecx, DWORD PTR [edi]
	shrd	ecx, eax, 20
	shr	eax, 20					; 00000014H
	push	eax
	push	ecx
	push	ebx
	push	OFFSET $SG370217
	push	0
	push	OFFSET ?budget_log@@3UiSK_Logger@@A	; budget_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx

; 5722 :           false,
; 5723 :             L" Node%i (Reserve: %#5llu / %#5llu MiB - "
; 5724 :                       L"Budget: %#5llu / %#5llu MiB)",
; 5725 :           i,
; 5726 :             mem_info       [buffer].local [i].CurrentReservation      >> 20ULL,
; 5727 :               mem_info     [buffer].local [i].AvailableForReservation >> 20ULL,
; 5728 :                 mem_info   [buffer].local [i].CurrentUsage            >> 20ULL,
; 5729 :                   mem_info [buffer].local [i].Budget                  >> 20ULL
; 5730 :         );
; 5731 : 
; 5732 :         min_max ( mem_info [buffer].local [i].AvailableForReservation,

	mov	ecx, DWORD PTR [edi-4]
	add	esp, 48					; 00000030H
	mov	eax, DWORD PTR [edi-8]
	cmp	ecx, DWORD PTR [esi+4]
	jb	SHORT $LN28@BudgetThre
	ja	SHORT $LN98@BudgetThre
	cmp	eax, DWORD PTR [esi]
	jbe	SHORT $LN28@BudgetThre
$LN98@BudgetThre:
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ecx
$LN28@BudgetThre:
	cmp	ecx, DWORD PTR [esi-4]
	ja	SHORT $LN29@BudgetThre
	jb	SHORT $LN99@BudgetThre
	cmp	eax, DWORD PTR [esi-8]
	jae	SHORT $LN29@BudgetThre
$LN99@BudgetThre:
	mov	DWORD PTR [esi-8], eax
	mov	DWORD PTR [esi-4], ecx
$LN29@BudgetThre:

; 5733 :                                 mem_stats [i].min_avail_reserve,
; 5734 :                                 mem_stats [i].max_avail_reserve );
; 5735 : 
; 5736 :         min_max ( mem_info [buffer].local [i].CurrentReservation,

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi]
	cmp	ecx, DWORD PTR [esi-12]
	jb	SHORT $LN30@BudgetThre
	ja	SHORT $LN100@BudgetThre
	cmp	eax, DWORD PTR [esi-16]
	jbe	SHORT $LN30@BudgetThre
$LN100@BudgetThre:
	mov	DWORD PTR [esi-16], eax
	mov	DWORD PTR [esi-12], ecx
$LN30@BudgetThre:
	cmp	ecx, DWORD PTR [esi-20]
	ja	SHORT $LN31@BudgetThre
	jb	SHORT $LN101@BudgetThre
	cmp	eax, DWORD PTR [esi-24]
	jae	SHORT $LN31@BudgetThre
$LN101@BudgetThre:
	mov	DWORD PTR [esi-24], eax
	mov	DWORD PTR [esi-20], ecx
$LN31@BudgetThre:

; 5737 :                                 mem_stats [i].min_reserve,
; 5738 :                                 mem_stats [i].max_reserve );
; 5739 : 
; 5740 :         min_max ( mem_info [buffer].local [i].CurrentUsage,

	mov	ecx, DWORD PTR [edi-12]
	mov	eax, DWORD PTR [edi-16]
	cmp	ecx, DWORD PTR [esi+36]
	jb	SHORT $LN32@BudgetThre
	ja	SHORT $LN102@BudgetThre
	cmp	eax, DWORD PTR [esi+32]
	jbe	SHORT $LN32@BudgetThre
$LN102@BudgetThre:
	mov	DWORD PTR [esi+32], eax
	mov	DWORD PTR [esi+36], ecx
$LN32@BudgetThre:
	cmp	ecx, DWORD PTR [esi+28]
	ja	SHORT $LN33@BudgetThre
	jb	SHORT $LN103@BudgetThre
	cmp	eax, DWORD PTR [esi+24]
	jae	SHORT $LN33@BudgetThre
$LN103@BudgetThre:
	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [esi+28], ecx
$LN33@BudgetThre:

; 5741 :                                 mem_stats [i].min_usage,
; 5742 :                                 mem_stats [i].max_usage );
; 5743 : 
; 5744 :         min_max ( mem_info [buffer].local [i].Budget,

	mov	ebx, DWORD PTR [edi-20]
	mov	edx, DWORD PTR [edi-24]
	cmp	ebx, DWORD PTR [esi+20]
	jb	SHORT $LN34@BudgetThre
	ja	SHORT $LN104@BudgetThre
	cmp	edx, DWORD PTR [esi+16]
	jbe	SHORT $LN34@BudgetThre
$LN104@BudgetThre:
	mov	DWORD PTR [esi+16], edx
	mov	DWORD PTR [esi+20], ebx
$LN34@BudgetThre:
	cmp	ebx, DWORD PTR [esi+12]
	ja	SHORT $LN35@BudgetThre
	jb	SHORT $LN105@BudgetThre
	cmp	edx, DWORD PTR [esi+8]
	jae	SHORT $LN35@BudgetThre
$LN105@BudgetThre:
	mov	DWORD PTR [esi+8], edx
	mov	DWORD PTR [esi+12], ebx
$LN35@BudgetThre:

; 5745 :                                 mem_stats [i].min_budget,
; 5746 :                                 mem_stats [i].max_budget );
; 5747 : 
; 5748 :         if ( mem_info [buffer].local [i].CurrentUsage >

	cmp	ecx, ebx
	jb	SHORT $LN11@BudgetThre
	ja	SHORT $LN106@BudgetThre
	cmp	eax, edx
	jbe	SHORT $LN11@BudgetThre
$LN106@BudgetThre:

; 5749 :              mem_info [buffer].local [i].Budget)
; 5750 :         {
; 5751 :           uint64_t over_budget =
; 5752 :              ( mem_info [buffer].local [i].CurrentUsage -

	sub	eax, edx
	sbb	ecx, ebx

; 5753 :                mem_info [buffer].local [i].Budget );
; 5754 : 
; 5755 :           min_max ( over_budget,

	cmp	ecx, DWORD PTR [esi+52]
	jb	SHORT $LN37@BudgetThre
	ja	SHORT $LN107@BudgetThre
	cmp	eax, DWORD PTR [esi+48]
	jbe	SHORT $LN37@BudgetThre
$LN107@BudgetThre:
	mov	DWORD PTR [esi+48], eax
	mov	DWORD PTR [esi+52], ecx
$LN37@BudgetThre:
	cmp	ecx, DWORD PTR [esi+44]
	ja	SHORT $LN11@BudgetThre
	jb	SHORT $LN108@BudgetThre
	cmp	eax, DWORD PTR [esi+40]
	jae	SHORT $LN11@BudgetThre
$LN108@BudgetThre:
	mov	DWORD PTR [esi+40], eax
	mov	DWORD PTR [esi+44], ecx
$LN11@BudgetThre:

; 5691 :                            L"[ DXGI 1.4 ] Local Memory.....:" );
; 5692 : 
; 5693 :       for ( i = 0; i < nodes; i++ )

	mov	ebx, DWORD PTR _i$1$[ebp]
	add	edi, 32					; 00000020H
	inc	ebx
	add	esi, 88					; 00000058H
	mov	DWORD PTR _i$1$[ebp], ebx
	cmp	ebx, DWORD PTR _nodes$1$[ebp]
	jl	$LL13@BudgetThre
$LN12@BudgetThre:

; 5756 :                            mem_stats [i].min_over_budget,
; 5757 :                            mem_stats [i].max_over_budget );
; 5758 :         }
; 5759 :       }
; 5760 : 
; 5761 :       budget_log.LogEx ( false, L"\n"                              );

	push	OFFSET $SG370229
	push	0
	push	OFFSET ?budget_log@@3UiSK_Logger@@A	; budget_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx

; 5762 :       budget_log.LogEx ( true,  L"[ DXGI 1.4 ] Non-Local Memory.:" );

	push	OFFSET $SG370230
	push	1
	push	OFFSET ?budget_log@@3UiSK_Logger@@A	; budget_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx

; 5763 : 
; 5764 :       for ( i = 0; i < nodes; i++ )

	mov	ebx, DWORD PTR _nodes$1$[ebp]
	add	esp, 24					; 00000018H
	xor	edi, edi
	test	ebx, ebx
	jle	$LN15@BudgetThre

; 5756 :                            mem_stats [i].min_over_budget,
; 5757 :                            mem_stats [i].max_over_budget );
; 5758 :         }
; 5759 :       }
; 5760 : 
; 5761 :       budget_log.LogEx ( false, L"\n"                              );

	mov	eax, DWORD PTR tv1556[ebp]
	lea	esi, DWORD PTR ?mem_info@@3PAUmem_info_t@@A[eax+136]
	npad	7
$LL16@BudgetThre:

; 5765 :       {
; 5766 :         if ( i > 0 )

	test	edi, edi
	jle	SHORT $LN39@BudgetThre

; 5767 :         {
; 5768 :           budget_log.LogEx ( false, L"\n"                                );

	push	OFFSET $SG370232
	push	0
	push	OFFSET ?budget_log@@3UiSK_Logger@@A	; budget_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx

; 5769 :           budget_log.LogEx ( true,  L"                                 " );

	push	OFFSET $SG370233
	push	1
	push	OFFSET ?budget_log@@3UiSK_Logger@@A	; budget_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	add	esp, 24					; 00000018H
$LN39@BudgetThre:

; 5770 :         }
; 5771 : 
; 5772 :         budget_log.LogEx (

	mov	ecx, DWORD PTR [esi-8]
	mov	eax, DWORD PTR [esi-4]
	shrd	ecx, eax, 20
	shr	eax, 20					; 00000014H
	push	eax
	mov	eax, DWORD PTR [esi+4]
	push	ecx
	mov	ecx, DWORD PTR [esi]
	shrd	ecx, eax, 20
	shr	eax, 20					; 00000014H
	push	eax
	mov	eax, DWORD PTR [esi+12]
	push	ecx
	mov	ecx, DWORD PTR [esi+8]
	shrd	ecx, eax, 20
	shr	eax, 20					; 00000014H
	push	eax
	mov	eax, DWORD PTR [esi+20]
	push	ecx
	mov	ecx, DWORD PTR [esi+16]
	shrd	ecx, eax, 20
	shr	eax, 20					; 00000014H
	push	eax
	push	ecx
	push	edi
	push	OFFSET $SG370234
	push	0
	push	OFFSET ?budget_log@@3UiSK_Logger@@A	; budget_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	inc	edi
	add	esp, 48					; 00000030H
	add	esi, 32					; 00000020H
	cmp	edi, ebx
	jl	$LL16@BudgetThre
$LN15@BudgetThre:

; 5773 :           false,
; 5774 :             L" Node%i (Reserve: %#5llu / %#5llu MiB - "
; 5775 :                       L"Budget: %#5llu / %#5llu MiB)",    i,
; 5776 :          mem_info    [buffer].nonlocal [i].CurrentReservation      >> 20ULL,
; 5777 :           mem_info   [buffer].nonlocal [i].AvailableForReservation >> 20ULL,
; 5778 :            mem_info  [buffer].nonlocal [i].CurrentUsage            >> 20ULL,
; 5779 :             mem_info [buffer].nonlocal [i].Budget                  >> 20ULL );
; 5780 :       }
; 5781 : 
; 5782 :       budget_log.LogEx ( false, L"\n" );

	push	OFFSET $SG370235
	push	0
	push	OFFSET ?budget_log@@3UiSK_Logger@@A	; budget_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	add	esp, 12					; 0000000cH
$LN25@BudgetThre:

; 5783 :     }
; 5784 : 
; 5785 :                ( params->event != 0 ) ?

	mov	ebx, DWORD PTR _user_data$[ebp]
	mov	edi, DWORD PTR __imp__ResetEvent@4
	mov	eax, DWORD PTR [ebx+16]
	test	eax, eax
	je	SHORT $LN44@BudgetThre
	push	eax
	call	edi
$LN44@BudgetThre:

; 5789 :     mem_info [0].buffer =

	mov	eax, DWORD PTR tv1557[ebp]
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	lea	esi, DWORD PTR [ebx+24]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5789 :     mem_info [0].buffer =

	mov	DWORD PTR ?mem_info@@3PAUmem_info_t@@A+272, eax
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR [esi]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5589 :   while ( ReadAcquire ( &params->ready ) )

	test	eax, eax
	jne	$LL2@BudgetThre

; 5608 :       break;
; 5609 :     }
; 5610 : 
; 5611 :     if (dwWaitStatus == WAIT_OBJECT_0 + 1)

	jmp	SHORT $LN111@BudgetThre
$LN83@BudgetThre:

; 5612 :     {
; 5613 :       InterlockedExchange ( &params->ready, FALSE );

	xor	eax, eax
	xchg	DWORD PTR [esi], eax

; 5614 :       ResetEvent          (  params->shutdown     );

	push	DWORD PTR [ebx+20]
	jmp	SHORT $LN112@BudgetThre
$LN82@BudgetThre:

; 5606 :     {
; 5607 :       ResetEvent ( params->event );

	push	DWORD PTR [ebx+16]
$LN112@BudgetThre:
	call	edi
$LN111@BudgetThre:
	pop	edi
$LN3@BudgetThre:

; 5790 :                  buffer;
; 5791 :   }
; 5792 : 
; 5793 :   CloseHandle (params->shutdown);

	push	DWORD PTR [ebx+20]
	call	DWORD PTR __imp__CloseHandle@4

; 5794 :                params->shutdown = INVALID_HANDLE_VALUE;
; 5795 : 
; 5796 :   if (success)

	cmp	BYTE PTR _success$1$[ebp], 0
	pop	esi
	mov	DWORD PTR [ebx+20], -1
	pop	ebx
	je	SHORT $LN109@BudgetThre

; 5797 :     CoUninitialize ();

	call	DWORD PTR __imp__CoUninitialize@0
$LN109@BudgetThre:

; 5798 : 
; 5799 :   return 0;

	xor	eax, eax

; 5800 : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN113@BudgetThre:

; 5666 :              params->pAdapter->QueryVideoMemoryInfo (
; 5667 :                node,
; 5668 :                  DXGI_MEMORY_SEGMENT_GROUP_NON_LOCAL,
; 5669 :                    &mem_info [buffer].nonlocal [node++]
; 5670 :              )
; 5671 :            )
; 5672 :          )
; 5673 :       {
; 5674 :         break;
; 5675 :       }
; 5676 :     }
; 5677 : 
; 5678 : 
; 5679 :     // Set the number of SLI/CFX Nodes
; 5680 :     mem_info [buffer].nodes = nodes;
; 5681 : 
; 5682 :     static uint64_t
; 5683 :       last_budget = mem_info [buffer].local [0].Budget;

	push	OFFSET ?$TSS0@?3??BudgetThread@DXGI@SK@@YGKPAX@Z@4HA
	call	__Init_thread_header
	add	esp, 4
	cmp	DWORD PTR ?$TSS0@?3??BudgetThread@DXGI@SK@@YGKPAX@Z@4HA, -1
	jne	$LN10@BudgetThre
	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR ?last_budget@?3??BudgetThread@DXGI@SK@@YGKPAX@Z@4_KA, eax
	mov	eax, DWORD PTR [ebx+4]
	push	OFFSET ?$TSS0@?3??BudgetThread@DXGI@SK@@YGKPAX@Z@4HA
	mov	DWORD PTR ?last_budget@?3??BudgetThread@DXGI@SK@@YGKPAX@Z@4_KA+4, eax
	call	__Init_thread_footer
	add	esp, 4
	jmp	$LN10@BudgetThre
?BudgetThread@DXGI@SK@@YGKPAX@Z ENDP			; SK::DXGI::BudgetThread
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\log.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_closeme_budget_log$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
?ShutdownBudgetThread@DXGI@SK@@YAXXZ PROC		; SK::DXGI::ShutdownBudgetThread

; 5847 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ShutdownBudgetThread@DXGI@SK@@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 5848 :   SK_AutoClose_Log (

	lea	eax, DWORD PTR _closeme_budget_log$[ebp]
	mov	ecx, OFFSET ?budget_log@@3UiSK_Logger@@A ; budget_log
	push	eax
	call	?auto_close@iSK_Logger@@QAE?AVAutoClose@1@XZ ; iSK_Logger::auto_close

; 5849 :     budget_log
; 5850 :   );
; 5851 : 
; 5852 : 
; 5853 :   if ( budget_thread.handle != INVALID_HANDLE_VALUE )

	cmp	DWORD PTR ?budget_thread@@3Ubudget_thread_params_t@@A+8, -1
	je	$LN3@ShutdownBu

; 5854 :   {
; 5855 :     dll_log.LogEx (

	push	OFFSET $SG370281
	push	1
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	add	esp, 12					; 0000000cH

; 5856 :       true,
; 5857 :         L"[ DXGI 1.4 ] Shutting down Memory Budget Change Thread... "
; 5858 :     );
; 5859 : 
; 5860 :     SetEvent (budget_thread.shutdown );

	push	DWORD PTR ?budget_thread@@3Ubudget_thread_params_t@@A+20
	call	DWORD PTR __imp__SetEvent@4

; 5861 : 
; 5862 :     DWORD dwWaitState =
; 5863 :       SignalObjectAndWait ( budget_thread.event,

	push	1
	push	1000					; 000003e8H
	push	DWORD PTR ?budget_thread@@3Ubudget_thread_params_t@@A+8
	push	DWORD PTR ?budget_thread@@3Ubudget_thread_params_t@@A+16
	call	DWORD PTR __imp__SignalObjectAndWait@16

; 5864 :                               budget_thread.handle, // Give 1 second, and
; 5865 :                                 1000UL,             // then we're killing
; 5866 :                                   TRUE );           // the thing!
; 5867 : 
; 5868 :     if ( dwWaitState == WAIT_OBJECT_0 )

	test	eax, eax
	jne	SHORT $LN6@ShutdownBu

; 5869 :     {
; 5870 :       dll_log.LogEx   ( false, L"done!\n"                         );

	push	OFFSET $SG370284
	push	eax
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	add	esp, 12					; 0000000cH

; 5871 :     }
; 5872 : 
; 5873 :     else

	jmp	SHORT $LN7@ShutdownBu
$LN6@ShutdownBu:

; 5874 :     {
; 5875 :       dll_log.LogEx   ( false, L"timed out (killing manually)!\n" );

	push	OFFSET $SG370285
	push	0
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	add	esp, 12					; 0000000cH

; 5876 :       TerminateThread ( budget_thread.handle,                   0 );

	push	0
	push	DWORD PTR ?budget_thread@@3Ubudget_thread_params_t@@A+8
	call	DWORD PTR __imp__TerminateThread@8
$LN7@ShutdownBu:

; 5877 :     }
; 5878 : 
; 5879 :     CloseHandle ( budget_thread.handle );

	push	esi
	push	edi
	push	DWORD PTR ?budget_thread@@3Ubudget_thread_params_t@@A+8
	call	DWORD PTR __imp__CloseHandle@4

; 5880 :                   budget_thread.handle = INVALID_HANDLE_VALUE;
; 5881 : 
; 5882 :     // Record the final statistics always
; 5883 :     budget_log.silent    = false;
; 5884 : 
; 5885 :     budget_log.Log   ( L"--------------------"   );

	push	OFFSET $SG370286
	push	OFFSET ?budget_log@@3UiSK_Logger@@A	; budget_log
	mov	DWORD PTR ?budget_thread@@3Ubudget_thread_params_t@@A+8, -1
	mov	BYTE PTR ?budget_log@@3UiSK_Logger@@A+32, 0
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 5886 :     budget_log.Log   ( L"Shutdown Statistics:"   );

	push	OFFSET $SG370287
	push	OFFSET ?budget_log@@3UiSK_Logger@@A	; budget_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 5887 :     budget_log.Log   ( L"--------------------\n" );

	push	OFFSET $SG370288
	push	OFFSET ?budget_log@@3UiSK_Logger@@A	; budget_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log

; 5888 : 
; 5889 :     // in %10u seconds\n",
; 5890 :     budget_log.Log ( L" Memory Budget Changed %llu times\n",

	push	DWORD PTR ?mem_stats@@3PAUmemory_stats_t@@A+84
	push	DWORD PTR ?mem_stats@@3PAUmemory_stats_t@@A+80
	push	OFFSET $SG370289
	push	OFFSET ?budget_log@@3UiSK_Logger@@A	; budget_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 40					; 00000028H
	mov	esi, OFFSET ?mem_stats@@3PAUmemory_stats_t@@A ; mem_stats

; 5891 :                        mem_stats [0].budget_changes );
; 5892 : 
; 5893 :     for ( int i = 0; i < 4; i++ )

	xor	edi, edi
	npad	5
$LL4@ShutdownBu:

; 5894 :     {
; 5895 :       if ( mem_stats [i].max_usage > 0 )

	cmp	DWORD PTR [esi+60], 0
	ja	SHORT $LN21@ShutdownBu
	cmp	DWORD PTR [esi+56], 0
	jbe	$LN2@ShutdownBu
$LN21@ShutdownBu:

; 5896 :       {
; 5897 :         if ( mem_stats [i].min_reserve     == UINT64_MAX )

	mov	eax, DWORD PTR [esi]
	and	eax, DWORD PTR [esi+4]
	cmp	eax, -1
	jne	SHORT $LN9@ShutdownBu

; 5898 :              mem_stats [i].min_reserve     =  0ULL;

	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
$LN9@ShutdownBu:

; 5899 : 
; 5900 :         if ( mem_stats [i].min_over_budget == UINT64_MAX )

	mov	eax, DWORD PTR [esi+64]
	and	eax, DWORD PTR [esi+68]
	cmp	eax, -1
	jne	SHORT $LN10@ShutdownBu

; 5901 :              mem_stats [i].min_over_budget =  0ULL;

	mov	DWORD PTR [esi+64], 0
	mov	DWORD PTR [esi+68], 0
$LN10@ShutdownBu:

; 5902 : 
; 5903 :         budget_log.LogEx ( true,

	mov	ecx, DWORD PTR [esi+32]
	mov	eax, DWORD PTR [esi+36]
	shrd	ecx, eax, 20
	shr	eax, 20					; 00000014H
	push	eax
	push	ecx
	push	edi
	push	OFFSET $SG370293
	push	1
	push	OFFSET ?budget_log@@3UiSK_Logger@@A	; budget_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx

; 5904 :                              L" GPU%i: Min Budget:        %05llu MiB\n",
; 5905 :                                           i,
; 5906 :                                mem_stats [i].min_budget >> 20ULL );
; 5907 :         budget_log.LogEx ( true,

	mov	ecx, DWORD PTR [esi+40]
	mov	eax, DWORD PTR [esi+44]
	shrd	ecx, eax, 20
	shr	eax, 20					; 00000014H
	push	eax
	push	ecx
	push	OFFSET $SG370294
	push	1
	push	OFFSET ?budget_log@@3UiSK_Logger@@A	; budget_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx

; 5908 :                              L"       Max Budget:        %05llu MiB\n",
; 5909 :                                mem_stats [i].max_budget >> 20ULL );
; 5910 : 
; 5911 :         budget_log.LogEx ( true,

	mov	ecx, DWORD PTR [esi+48]
	mov	eax, DWORD PTR [esi+52]
	shrd	ecx, eax, 20
	shr	eax, 20					; 00000014H
	push	eax
	push	ecx
	push	OFFSET $SG370295
	push	1
	push	OFFSET ?budget_log@@3UiSK_Logger@@A	; budget_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx

; 5912 :                              L"       Min Usage:         %05llu MiB\n",
; 5913 :                                mem_stats [i].min_usage  >> 20ULL );
; 5914 :         budget_log.LogEx ( true,

	mov	ecx, DWORD PTR [esi+56]
	add	esp, 64					; 00000040H
	mov	eax, DWORD PTR [esi+60]
	shrd	ecx, eax, 20
	shr	eax, 20					; 00000014H
	push	eax
	push	ecx
	push	OFFSET $SG370296
	push	1
	push	OFFSET ?budget_log@@3UiSK_Logger@@A	; budget_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx

; 5915 :                              L"       Max Usage:         %05llu MiB\n",
; 5916 :                                mem_stats [i].max_usage  >> 20ULL );
; 5917 : 
; 5918 :         /*
; 5919 :         SK_BLogEx (params, true, L"       Min Reserve:       %05u MiB\n",
; 5920 :         mem_stats [i].min_reserve >> 20ULL);
; 5921 :         SK_BLogEx (params, true, L"       Max Reserve:       %05u MiB\n",
; 5922 :         mem_stats [i].max_reserve >> 20ULL);
; 5923 :         SK_BLogEx (params, true, L"       Min Avail Reserve: %05u MiB\n",
; 5924 :         mem_stats [i].min_avail_reserve >> 20ULL);
; 5925 :         SK_BLogEx (params, true, L"       Max Avail Reserve: %05u MiB\n",
; 5926 :         mem_stats [i].max_avail_reserve >> 20ULL);
; 5927 :         */
; 5928 : 
; 5929 :         budget_log.LogEx ( true,  L"------------------------------------\n" );

	push	OFFSET $SG370297
	push	1
	push	OFFSET ?budget_log@@3UiSK_Logger@@A	; budget_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx

; 5930 :         budget_log.LogEx ( true,  L" Minimum Over Budget:     %05llu MiB\n",

	mov	ecx, DWORD PTR [esi+64]
	mov	eax, DWORD PTR [esi+68]
	shrd	ecx, eax, 20
	shr	eax, 20					; 00000014H
	push	eax
	push	ecx
	push	OFFSET $SG370298
	push	1
	push	OFFSET ?budget_log@@3UiSK_Logger@@A	; budget_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx

; 5931 :                                     mem_stats [i].min_over_budget >> 20ULL  );
; 5932 :         budget_log.LogEx ( true,  L" Maximum Over Budget:     %05llu MiB\n",

	mov	ecx, DWORD PTR [esi+72]
	mov	eax, DWORD PTR [esi+76]
	shrd	ecx, eax, 20
	shr	eax, 20					; 00000014H
	push	eax
	push	ecx
	push	OFFSET $SG370299
	push	1
	push	OFFSET ?budget_log@@3UiSK_Logger@@A	; budget_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	add	esp, 72					; 00000048H

; 5933 :                                     mem_stats [i].max_over_budget >> 20ULL  );
; 5934 :         budget_log.LogEx ( true,  L"------------------------------------\n" );

	push	OFFSET $SG370300
	push	1
	push	OFFSET ?budget_log@@3UiSK_Logger@@A	; budget_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx

; 5935 :         budget_log.LogEx ( false, L"\n"                                     );

	push	OFFSET $SG370301
	push	0
	push	OFFSET ?budget_log@@3UiSK_Logger@@A	; budget_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	add	esp, 24					; 00000018H
$LN2@ShutdownBu:

; 5891 :                        mem_stats [0].budget_changes );
; 5892 : 
; 5893 :     for ( int i = 0; i < 4; i++ )

	add	esi, 88					; 00000058H
	inc	edi
	cmp	esi, OFFSET ?mem_stats@@3PAUmemory_stats_t@@A+352
	jl	$LL4@ShutdownBu
	pop	edi
	pop	esi
$LN3@ShutdownBu:
; File c:\users\andon\source\repos\specialk\include\specialk\log.h

; 158  :       if (log_ != nullptr)

	mov	eax, DWORD PTR _closeme_budget_log$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN14@ShutdownBu

; 159  :         log_->close ();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+20]
$LN14@ShutdownBu:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5939 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__ehhandler$?ShutdownBudgetThread@DXGI@SK@@YAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ShutdownBudgetThread@DXGI@SK@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ShutdownBudgetThread@DXGI@SK@@YAXXZ ENDP		; SK::DXGI::ShutdownBudgetThread
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_factory$2 = -20					; size = 4
_adapter$3 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ PROC	; SK::DXGI::StartBudgetThread_NoAdapter

; 5804 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi

; 5805 :   HRESULT hr = E_NOTIMPL;
; 5806 : 
; 5807 :   bool success =
; 5808 :     SUCCEEDED ( CoInitializeEx ( nullptr, COINIT_MULTITHREADED ) );

	push	0
	push	0
	mov	esi, -2147467263			; 80004001H
	call	DWORD PTR __imp__CoInitializeEx@8

; 5809 : 
; 5810 :   static HMODULE
; 5811 :     hDXGI = LoadLibraryW_Original ( L"dxgi.dll" );

	mov	ecx, DWORD PTR __tls_index
	test	eax, eax
	mov	eax, DWORD PTR fs:__tls_array
	setns	bl
	mov	edi, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ?$TSS0@?1??StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ@4HA
	cmp	eax, DWORD PTR __Init_thread_epoch[edi]
	jle	SHORT $LN2@StartBudge
	push	OFFSET ?$TSS0@?1??StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ@4HA
	call	__Init_thread_header
	add	esp, 4
	cmp	DWORD PTR ?$TSS0@?1??StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ@4HA, -1
	jne	SHORT $LN2@StartBudge
	push	OFFSET $SG370259
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	DWORD PTR ?LoadLibraryW_Original@@3P6GPAUHINSTANCE__@@PB_W@ZA ; LoadLibraryW_Original
	push	OFFSET ?$TSS0@?1??StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ@4HA
	mov	DWORD PTR ?hDXGI@?1??StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ@4PAUHINSTANCE__@@A, eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	__Init_thread_footer
	add	esp, 4
$LN2@StartBudge:

; 5812 : 
; 5813 :   if (hDXGI)

	cmp	DWORD PTR ?hDXGI@?1??StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ@4PAUHINSTANCE__@@A, 0
	je	$LN40@StartBudge

; 5814 :   {
; 5815 :     static auto
; 5816 :       CreateDXGIFactory =

	mov	eax, DWORD PTR ?$TSS1@?4??StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ@4HA
	cmp	eax, DWORD PTR __Init_thread_epoch[edi]
	jle	SHORT $LN3@StartBudge
	push	OFFSET ?$TSS1@?4??StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ@4HA
	call	__Init_thread_header
	add	esp, 4
	cmp	DWORD PTR ?$TSS1@?4??StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ@4HA, -1
	jne	SHORT $LN3@StartBudge

; 5817 :         (CreateDXGIFactory_pfn) GetProcAddress ( hDXGI,

	push	OFFSET $SG370261
	push	DWORD PTR ?hDXGI@?1??StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ@4PAUHINSTANCE__@@A
	call	DWORD PTR __imp__GetProcAddress@8
	push	OFFSET ?$TSS1@?4??StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ@4HA
	mov	DWORD PTR ?CreateDXGIFactory@?4??StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ@4P6GJABU_GUID@@PAPAX@ZA, eax
	call	__Init_thread_footer
	add	esp, 4
$LN3@StartBudge:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _factory$2[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5819 :     CComPtr <IDXGIFactory> factory = nullptr;

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _adapter$3[ebp], 0
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5823 :     if ( SUCCEEDED (

	lea	eax, DWORD PTR _factory$2[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	push	eax
	call	??$IID_PPV_ARGS_Helper@UIDXGIFactory@@@@YAPAPAXPAPAUIDXGIFactory@@@Z ; IID_PPV_ARGS_Helper<IDXGIFactory>
	add	esp, 4
	push	eax
	push	OFFSET __GUID_7b7166ec_21c7_44ae_b21a_c9ae321ae369
	call	DWORD PTR ?CreateDXGIFactory@?4??StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ@4P6GJABU_GUID@@PAPAX@ZA
	test	eax, eax
	js	SHORT $LN6@StartBudge

; 5824 :            CreateDXGIFactory ( IID_PPV_ARGS (&factory) )
; 5825 :          )
; 5826 :        )
; 5827 :     {
; 5828 :       if ( SUCCEEDED (

	mov	eax, DWORD PTR _factory$2[ebp]
	lea	edx, DWORD PTR _adapter$3[ebp]
	push	edx
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+28]
	test	eax, eax
	js	SHORT $LN6@StartBudge

; 5829 :              factory->EnumAdapters ( 0,
; 5830 :                                        &adapter )
; 5831 :            )
; 5832 :          )
; 5833 :       {
; 5834 :         hr = StartBudgetThread ( &adapter );

	lea	eax, DWORD PTR _adapter$3[ebp]
	push	eax
	call	?StartBudgetThread@DXGI@SK@@YAJPAPAUIDXGIAdapter@@@Z ; SK::DXGI::StartBudgetThread
	add	esp, 4
	mov	esi, eax
$LN6@StartBudge:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	mov	ecx, DWORD PTR _adapter$3[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5837 :   }

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	ecx, ecx
	je	SHORT $LN34@StartBudge

; 177  :             p->Release();

	mov	edx, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [edx+8]
$LN34@StartBudge:

; 176  :         if (p)

	mov	eax, DWORD PTR _factory$2[ebp]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5837 :   }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN40@StartBudge

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN40@StartBudge:
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5839 :   if (success)

	test	bl, bl
	je	SHORT $LN42@StartBudge

; 5840 :     CoUninitialize ();

	call	DWORD PTR __imp__CoUninitialize@0
$LN42@StartBudge:

; 5841 : 
; 5842 :   return hr;
; 5843 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ$0:
	push	OFFSET ?$TSS0@?1??StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ@4HA
	call	__Init_thread_abort
	pop	ecx
	ret	0
__unwindfunclet$?StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ$1:
	lea	ecx, DWORD PTR _factory$2[ebp]
	jmp	??1?$CComPtr@UIDXGIFactory@@@ATL@@QAE@XZ
__unwindfunclet$?StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ$2:
	lea	ecx, DWORD PTR _adapter$3[ebp]
	jmp	??1?$CComPtr@UIDXGIAdapter@@@ATL@@QAE@XZ
__ehhandler$?StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ:
	mov	eax, OFFSET __ehfuncinfo$?StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?StartBudgetThread_NoAdapter@DXGI@SK@@YAJXZ ENDP	; SK::DXGI::StartBudgetThread_NoAdapter
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\mutex
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
_desc2$2 = -368						; size = 304
_auto_lock$3 = -64					; size = 4
tv327 = -60						; size = 8
tv279 = -60						; size = 8
__mem_info$4 = -52					; size = 32
_hr$1$ = -20						; size = 4
_pAdapter3$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_ppAdapter$ = 8						; size = 4
_silent$1$ = 11						; size = 1
?StartBudgetThread@DXGI@SK@@YAJPAPAUIDXGIAdapter@@@Z PROC ; SK::DXGI::StartBudgetThread

; 5325 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?StartBudgetThread@DXGI@SK@@YAJPAPAUIDXGIAdapter@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 356				; 00000164H

; 5333 :   if (SUCCEEDED ((*ppAdapter)->QueryInterface <IDXGIAdapter3> (&pAdapter3)))

	mov	eax, DWORD PTR _ppAdapter$[ebp]
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	lea	edx, DWORD PTR _pAdapter3$[ebp]
	push	esi
	push	edx
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5330 :   IDXGIAdapter3* pAdapter3 = nullptr;

	mov	DWORD PTR _pAdapter3$[ebp], 0

; 5331 :   HRESULT        hr        = E_NOTIMPL;

	mov	esi, -2147467263			; 80004001H

; 5333 :   if (SUCCEEDED ((*ppAdapter)->QueryInterface <IDXGIAdapter3> (&pAdapter3)))

	mov	eax, DWORD PTR [eax]
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	push	OFFSET __GUID_645967a4_1392_4310_a798_8053ce3e93fd
	push	eax
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5331 :   HRESULT        hr        = E_NOTIMPL;

	mov	DWORD PTR _hr$1$[ebp], esi
; File c:\program files (x86)\windows kits\8.1\include\um\unknwnbase.h

; 131  :                 return QueryInterface(__uuidof(Q), (void **)pp);

	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx]
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5333 :   if (SUCCEEDED ((*ppAdapter)->QueryInterface <IDXGIAdapter3> (&pAdapter3)))

	test	eax, eax
	js	$LN55@StartBudge
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\mutex

; 217  : 		: _MyMutex(_Mtx)

	mov	esi, DWORD PTR ?budget_mutex@@3PAVSK_Thread_HybridSpinlock@@A ; budget_mutex
	mov	DWORD PTR _auto_lock$3[ebp], esi
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h

; 261  :     EnterCriticalSection (cs_);

	push	DWORD PTR [esi]
	call	DWORD PTR __imp__EnterCriticalSection@4
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5339 :     if ( budget_thread.handle == INVALID_HANDLE_VALUE )

	cmp	DWORD PTR ?budget_thread@@3Ubudget_thread_params_t@@A+8, -1
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	jne	$LN11@StartBudge

; 5340 :     {
; 5341 :       // We're going to Release this interface after thread spawnning, but
; 5342 :       //   the running thread still needs a reference counted.
; 5343 :       pAdapter3->AddRef ();

	mov	eax, DWORD PTR _pAdapter3$[ebp]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+4]

; 5344 : 
; 5345 :       ZeroMemory ( &budget_thread,
; 5346 :                      sizeof budget_thread_params_t );
; 5347 : 
; 5348 :       dll_log.LogEx ( true,

	push	OFFSET $SG370120
	xorps	xmm0, xmm0
	mov	DWORD PTR ?budget_thread@@3Ubudget_thread_params_t@@A+24, 0
	push	1
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	movups	XMMWORD PTR ?budget_thread@@3Ubudget_thread_params_t@@A, xmm0
	movq	QWORD PTR ?budget_thread@@3Ubudget_thread_params_t@@A+16, xmm0
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	add	esp, 12					; 0000000cH

; 5349 :                         L"[ DXGI 1.4 ]   "
; 5350 :                         L"$ Spawning Memory Budget Change Thread..: " );
; 5351 : 
; 5352 :       InterlockedExchange ( &budget_thread.ready,

	xor	eax, eax
	mov	ecx, OFFSET ?budget_thread@@3Ubudget_thread_params_t@@A+24
	xchg	DWORD PTR [ecx], eax

; 5353 :                               FALSE );
; 5354 : 
; 5355 :       budget_thread.pAdapter = pAdapter3;

	mov	eax, DWORD PTR _pAdapter3$[ebp]

; 5356 :       budget_thread.tid      = 0;
; 5357 :       budget_thread.event    = nullptr;
; 5358 :       budget_log.silent      = true;
; 5359 : 
; 5360 : 
; 5361 :       budget_thread.handle =

	push	0
	push	0
	push	OFFSET ?budget_thread@@3Ubudget_thread_params_t@@A ; budget_thread
	push	OFFSET ?BudgetThread@DXGI@SK@@YGKPAX@Z	; SK::DXGI::BudgetThread
	push	0
	push	0
	mov	DWORD PTR ?budget_thread@@3Ubudget_thread_params_t@@A, eax
	mov	DWORD PTR ?budget_thread@@3Ubudget_thread_params_t@@A+4, 0
	mov	DWORD PTR ?budget_thread@@3Ubudget_thread_params_t@@A+16, 0
	mov	BYTE PTR ?budget_log@@3UiSK_Logger@@A+32, 1
	call	DWORD PTR __imp__CreateThread@24
	mov	DWORD PTR ?budget_thread@@3Ubudget_thread_params_t@@A+8, eax
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?budget_thread@@3Ubudget_thread_params_t@@A+24
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5370 :       while ( ! ReadAcquire ( &budget_thread.ready )

	test	eax, eax
	jne	SHORT $LN3@StartBudge
	mov	esi, DWORD PTR __imp__SleepEx@8
$LL2@StartBudge:

; 5371 :             ) SleepEx (100, TRUE);

	push	1
	push	100					; 00000064H
	call	esi
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h

; 8063 :     Value = *Source;

	mov	eax, DWORD PTR ?budget_thread@@3Ubudget_thread_params_t@@A+24
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5370 :       while ( ! ReadAcquire ( &budget_thread.ready )

	test	eax, eax
	je	SHORT $LL2@StartBudge
$LN3@StartBudge:

; 5372 : 
; 5373 : 
; 5374 :       if ( budget_thread.tid != 0 )

	mov	eax, DWORD PTR ?budget_thread@@3Ubudget_thread_params_t@@A+4
	push	edi
	test	eax, eax
	je	$LN12@StartBudge

; 5375 :       {
; 5376 :         dll_log.LogEx ( false,

	push	eax
	push	OFFSET $SG370123
	push	0
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx

; 5377 :                           L"tid=0x%04x\n",
; 5378 :                             budget_thread.tid );
; 5379 : 
; 5380 :         dll_log.LogEx ( true,

	push	OFFSET $SG370124
	push	1
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx

; 5381 :                           L"[ DXGI 1.4 ]   "
; 5382 :                             L"%% Setting up Budget Change Notification.: " );
; 5383 : 
; 5384 :         HRESULT result =
; 5385 :           pAdapter3->RegisterVideoMemoryBudgetChangeNotificationEvent (

	mov	eax, DWORD PTR _pAdapter3$[ebp]
	add	esp, 28					; 0000001cH
	mov	ecx, DWORD PTR [eax]
	push	OFFSET ?budget_thread@@3Ubudget_thread_params_t@@A+12
	push	DWORD PTR ?budget_thread@@3Ubudget_thread_params_t@@A+16
	push	eax
	call	DWORD PTR [ecx+64]
	mov	edi, eax
	mov	DWORD PTR _hr$1$[ebp], edi

; 5386 :                             budget_thread.event,
; 5387 :                            &budget_thread.cookie
; 5388 :           );
; 5389 : 
; 5390 :         if ( SUCCEEDED ( result ) )

	test	edi, edi
	js	SHORT $LN14@StartBudge

; 5391 :         {
; 5392 :           dll_log.LogEx ( false,

	push	DWORD PTR ?budget_thread@@3Ubudget_thread_params_t@@A+12
	push	DWORD PTR ?budget_thread@@3Ubudget_thread_params_t@@A+16
	push	OFFSET $SG370127
	push	0
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	add	esp, 20					; 00000014H

; 5393 :                             L"eid=0x%p, cookie=%u\n",
; 5394 :                               budget_thread.event,
; 5395 :                                         budget_thread.cookie );
; 5396 : 
; 5397 :           hr = S_OK;

	mov	DWORD PTR _hr$1$[ebp], 0

; 5398 :         }
; 5399 : 
; 5400 :         else

	jmp	SHORT $LN13@StartBudge
$LN14@StartBudge:

; 5401 :         {
; 5402 :           dll_log.LogEx ( false,

	push	edi
	call	?SK_DescribeHRESULT@@YGPB_WJ@Z		; SK_DescribeHRESULT
	push	eax
	push	OFFSET $SG370128
	push	0
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	add	esp, 16					; 00000010H

; 5403 :                             L"Failed! (%s)\n",
; 5404 :                               SK_DescribeHRESULT ( result ) );
; 5405 : 
; 5406 :           hr = result;
; 5407 :         }
; 5408 :       }
; 5409 : 
; 5410 :       else

	jmp	SHORT $LN13@StartBudge
$LN12@StartBudge:

; 5411 :       {
; 5412 :         dll_log.LogEx (false, L"failed!\n");

	push	OFFSET $SG370129
	push	0
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	add	esp, 12					; 0000000cH

; 5413 : 
; 5414 :         hr = E_FAIL;

	mov	DWORD PTR _hr$1$[ebp], -2147467259	; 80004005H
$LN13@StartBudge:

; 5415 :       }
; 5416 : 
; 5417 :       dll_log.LogEx ( true,

	push	OFFSET $SG370130
	push	1
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx

; 5418 :                         L"[ DXGI 1.2 ] GPU Scheduling...:"
; 5419 :                                      L" Pre-Emptive" );
; 5420 : 
; 5421 :       DXGI_QUERY_VIDEO_MEMORY_INFO
; 5422 :               _mem_info = { };
; 5423 :       DXGI_ADAPTER_DESC2
; 5424 :                   desc2 = { };

	push	304					; 00000130H
	xorps	xmm0, xmm0
	lea	eax, DWORD PTR _desc2$2[ebp]
	push	0
	push	eax
	movups	XMMWORD PTR __mem_info$4[ebp], xmm0
	movups	XMMWORD PTR __mem_info$4[ebp+16], xmm0
	call	_memset

; 5425 : 
; 5426 :       int     i      = 0;
; 5427 :       bool    silent = dll_log.silent;

	mov	al, BYTE PTR ?dll_log@@3UiSK_Logger@@A+32

; 5428 :       dll_log.silent = true;
; 5429 :       {
; 5430 :         // Don't log this call, because that would be silly...
; 5431 :         pAdapter3->GetDesc2 ( &desc2 );

	lea	edx, DWORD PTR _desc2$2[ebp]
	mov	BYTE PTR _silent$1$[ebp], al
	add	esp, 24					; 00000018H
	mov	eax, DWORD PTR _pAdapter3$[ebp]
	xor	esi, esi
	mov	BYTE PTR ?dll_log@@3UiSK_Logger@@A+32, 1
	push	edx
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+44]

; 5432 :       }
; 5433 :       dll_log.silent = silent;

	mov	al, BYTE PTR _silent$1$[ebp]
	mov	BYTE PTR ?dll_log@@3UiSK_Logger@@A+32, al

; 5434 : 
; 5435 : 
; 5436 :       switch ( desc2.GraphicsPreemptionGranularity )

	mov	eax, DWORD PTR _desc2$2[ebp+296]
	cmp	eax, 4
	ja	SHORT $LN21@StartBudge
	jmp	DWORD PTR $LN58@StartBudge[eax*4]
$LN16@StartBudge:

; 5437 :       {
; 5438 :         case DXGI_GRAPHICS_PREEMPTION_DMA_BUFFER_BOUNDARY:
; 5439 :           dll_log.LogEx ( false, L" (DMA Buffer)\n"         );

	push	OFFSET $SG370132

; 5440 :           break;

	jmp	SHORT $LN57@StartBudge
$LN17@StartBudge:

; 5441 : 
; 5442 :         case DXGI_GRAPHICS_PREEMPTION_PRIMITIVE_BOUNDARY:
; 5443 :           dll_log.LogEx ( false, L" (Graphics Primitive)\n" );

	push	OFFSET $SG370134

; 5444 :           break;

	jmp	SHORT $LN57@StartBudge
$LN18@StartBudge:

; 5445 : 
; 5446 :         case DXGI_GRAPHICS_PREEMPTION_TRIANGLE_BOUNDARY:
; 5447 :           dll_log.LogEx ( false, L" (Triangle)\n"           );

	push	OFFSET $SG370136

; 5448 :           break;

	jmp	SHORT $LN57@StartBudge
$LN19@StartBudge:

; 5449 : 
; 5450 :         case DXGI_GRAPHICS_PREEMPTION_PIXEL_BOUNDARY:
; 5451 :           dll_log.LogEx ( false, L" (Fragment)\n"           );

	push	OFFSET $SG370138

; 5452 :           break;

	jmp	SHORT $LN57@StartBudge
$LN20@StartBudge:

; 5453 : 
; 5454 :         case DXGI_GRAPHICS_PREEMPTION_INSTRUCTION_BOUNDARY:
; 5455 :           dll_log.LogEx ( false, L" (Instruction)\n"        );

	push	OFFSET $SG370140

; 5456 :           break;

	jmp	SHORT $LN57@StartBudge
$LN21@StartBudge:

; 5457 : 
; 5458 :         default:
; 5459 :           dll_log.LogEx (false, L"UNDEFINED\n");

	push	OFFSET $SG370142
$LN57@StartBudge:
	push	0
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	add	esp, 12					; 0000000cH

; 5460 :           break;
; 5461 :       }
; 5462 : 
; 5463 :       dll_log.LogEx ( true,

	push	OFFSET $SG370143
	push	1
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx

; 5464 :                         L"[ DXGI 1.4 ] Local Memory.....:" );
; 5465 : 
; 5466 :       while ( SUCCEEDED (

	mov	eax, DWORD PTR _pAdapter3$[ebp]
	lea	edx, DWORD PTR __mem_info$4[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	0
	push	0
	push	eax
	call	DWORD PTR [ecx+56]
	test	eax, eax
	js	$LN7@StartBudge
$LL6@StartBudge:

; 5467 :                 pAdapter3->QueryVideoMemoryInfo (
; 5468 :                   i,
; 5469 :                     DXGI_MEMORY_SEGMENT_GROUP_LOCAL,
; 5470 :                       &_mem_info
; 5471 :                 )
; 5472 :               )
; 5473 :             )
; 5474 :       {
; 5475 :         if ( i > 0 )

	test	esi, esi
	jle	SHORT $LN22@StartBudge

; 5476 :         {
; 5477 :           dll_log.LogEx ( false, L"\n"                              );

	push	OFFSET $SG370145
	push	0
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx

; 5478 :           dll_log.LogEx ( true,  L"                               " );

	push	OFFSET $SG370146
	push	1
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	add	esp, 24					; 00000018H
$LN22@StartBudge:

; 5479 :         }
; 5480 : 
; 5481 :         dll_log.LogEx ( false,

	mov	ecx, DWORD PTR __mem_info$4[ebp]
	mov	eax, DWORD PTR __mem_info$4[ebp+4]
	shrd	ecx, eax, 20
	shr	eax, 20					; 00000014H
	push	eax
	mov	eax, DWORD PTR __mem_info$4[ebp+12]
	push	ecx
	mov	ecx, DWORD PTR __mem_info$4[ebp+8]
	shrd	ecx, eax, 20
	shr	eax, 20					; 00000014H
	push	eax
	mov	eax, DWORD PTR __mem_info$4[ebp+20]
	push	ecx
	mov	ecx, DWORD PTR __mem_info$4[ebp+16]
	shrd	ecx, eax, 20
	shr	eax, 20					; 00000014H
	push	eax
	mov	eax, DWORD PTR __mem_info$4[ebp+28]
	push	ecx
	mov	ecx, DWORD PTR __mem_info$4[ebp+24]
	shrd	ecx, eax, 20
	shr	eax, 20					; 00000014H
	push	eax
	push	ecx
	push	esi
	push	OFFSET $SG370147
	push	0
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	inc	esi
	add	esp, 48					; 00000030H

; 5482 :                           L" Node%i       (Reserve: %#5llu / %#5llu MiB - "
; 5483 :                                          L"Budget: %#5llu / %#5llu MiB)",
; 5484 :                             i++,
; 5485 :                               _mem_info.CurrentReservation      >> 20ULL,
; 5486 :                               _mem_info.AvailableForReservation >> 20ULL,
; 5487 :                               _mem_info.CurrentUsage            >> 20ULL,
; 5488 :                               _mem_info.Budget                  >> 20ULL
; 5489 :                       );
; 5490 : 
; 5491 :         pAdapter3->SetVideoMemoryReservation (

	cmp	esi, 1
	jne	SHORT $LN25@StartBudge
	mov	edx, DWORD PTR __mem_info$4[ebp+20]
	mov	ecx, DWORD PTR __mem_info$4[ebp+16]
	call	__ultod3
	cvtsd2ss xmm0, xmm0
	mulss	xmm0, DWORD PTR ?config@@3Usk_config_t@@A+16
	mulss	xmm0, DWORD PTR __real@3c23d70a
	call	__ftoul3
	mov	edi, eax
	mov	eax, edx
	jmp	SHORT $LN26@StartBudge
$LN25@StartBudge:
	xorps	xmm0, xmm0
	movlpd	QWORD PTR tv279[ebp], xmm0
	mov	eax, DWORD PTR tv279[ebp+4]
	mov	edi, DWORD PTR tv279[ebp]
$LN26@StartBudge:
	mov	ecx, DWORD PTR _pAdapter3$[ebp]
	push	eax
	push	edi
	push	0
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [esi-1]
	push	eax
	push	ecx
	call	DWORD PTR [edx+60]
	mov	eax, DWORD PTR _pAdapter3$[ebp]
	lea	edx, DWORD PTR __mem_info$4[ebp]
	push	edx
	push	0
	push	esi
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+56]
	test	eax, eax
	jns	$LL6@StartBudge
$LN7@StartBudge:

; 5492 :               ( i - 1 ),
; 5493 :                 DXGI_MEMORY_SEGMENT_GROUP_LOCAL,
; 5494 :                   ( i == 1 ) ?
; 5495 :                     uint64_t ( _mem_info.AvailableForReservation *
; 5496 :                                  config.mem.reserve * 0.01f ) 
; 5497 :                            :
; 5498 :                            0
; 5499 :         );
; 5500 :       }
; 5501 : 
; 5502 :       i = 0;
; 5503 : 
; 5504 :       dll_log.LogEx ( false, L"\n"                              );

	push	OFFSET $SG370148
	xor	esi, esi
	push	esi
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx

; 5505 :       dll_log.LogEx ( true,  L"[ DXGI 1.4 ] Non-Local Memory.:" );

	push	OFFSET $SG370149
	push	1
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx

; 5506 : 
; 5507 :       while ( SUCCEEDED (

	mov	eax, DWORD PTR _pAdapter3$[ebp]
	lea	edx, DWORD PTR __mem_info$4[ebp]
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	1
	push	esi
	push	eax
	call	DWORD PTR [ecx+56]
	test	eax, eax
	js	$LN9@StartBudge
	npad	1
$LL8@StartBudge:

; 5508 :                 pAdapter3->QueryVideoMemoryInfo (
; 5509 :                   i,
; 5510 :                     DXGI_MEMORY_SEGMENT_GROUP_NON_LOCAL,
; 5511 :                       &_mem_info
; 5512 :                 )
; 5513 :               )
; 5514 :             )
; 5515 :       {
; 5516 :         if ( i > 0 )

	test	esi, esi
	jle	SHORT $LN23@StartBudge

; 5517 :         {
; 5518 :           dll_log.LogEx ( false, L"\n"                              );

	push	OFFSET $SG370151
	push	0
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx

; 5519 :           dll_log.LogEx ( true,  L"                               " );

	push	OFFSET $SG370152
	push	1
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	add	esp, 24					; 00000018H
$LN23@StartBudge:

; 5520 :         }
; 5521 : 
; 5522 :         dll_log.LogEx ( false,

	mov	ecx, DWORD PTR __mem_info$4[ebp]
	mov	eax, DWORD PTR __mem_info$4[ebp+4]
	shrd	ecx, eax, 20
	shr	eax, 20					; 00000014H
	push	eax
	mov	eax, DWORD PTR __mem_info$4[ebp+12]
	push	ecx
	mov	ecx, DWORD PTR __mem_info$4[ebp+8]
	shrd	ecx, eax, 20
	shr	eax, 20					; 00000014H
	push	eax
	mov	eax, DWORD PTR __mem_info$4[ebp+20]
	push	ecx
	mov	ecx, DWORD PTR __mem_info$4[ebp+16]
	shrd	ecx, eax, 20
	shr	eax, 20					; 00000014H
	push	eax
	mov	eax, DWORD PTR __mem_info$4[ebp+28]
	push	ecx
	mov	ecx, DWORD PTR __mem_info$4[ebp+24]
	shrd	ecx, eax, 20
	shr	eax, 20					; 00000014H
	push	eax
	push	ecx
	push	esi
	push	OFFSET $SG370153
	push	0
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	inc	esi
	add	esp, 48					; 00000030H

; 5523 :                           L" Node%i       (Reserve: %#5llu / %#5llu MiB - "
; 5524 :                                          L"Budget: %#5llu / %#5llu MiB)",
; 5525 :                             i++,
; 5526 :                               _mem_info.CurrentReservation      >> 20ULL,
; 5527 :                               _mem_info.AvailableForReservation >> 20ULL,
; 5528 :                               _mem_info.CurrentUsage            >> 20ULL,
; 5529 :                               _mem_info.Budget                  >> 20ULL
; 5530 :                       );
; 5531 : 
; 5532 :         pAdapter3->SetVideoMemoryReservation (

	cmp	esi, 1
	jne	SHORT $LN27@StartBudge
	mov	edx, DWORD PTR __mem_info$4[ebp+20]
	mov	ecx, DWORD PTR __mem_info$4[ebp+16]
	call	__ultod3
	cvtsd2ss xmm0, xmm0
	mulss	xmm0, DWORD PTR ?config@@3Usk_config_t@@A+16
	mulss	xmm0, DWORD PTR __real@3c23d70a
	call	__ftoul3
	mov	edi, edx
	jmp	SHORT $LN28@StartBudge
$LN27@StartBudge:
	xorps	xmm0, xmm0
	movlpd	QWORD PTR tv327[ebp], xmm0
	mov	edi, DWORD PTR tv327[ebp+4]
	mov	eax, DWORD PTR tv327[ebp]
$LN28@StartBudge:
	mov	ecx, DWORD PTR _pAdapter3$[ebp]
	push	edi
	push	eax
	push	1
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [esi-1]
	push	eax
	push	ecx
	call	DWORD PTR [edx+60]
	mov	eax, DWORD PTR _pAdapter3$[ebp]
	lea	edx, DWORD PTR __mem_info$4[ebp]
	push	edx
	push	1
	push	esi
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+56]
	test	eax, eax
	jns	$LL8@StartBudge
$LN9@StartBudge:

; 5533 :               ( i - 1 ),
; 5534 :                 DXGI_MEMORY_SEGMENT_GROUP_NON_LOCAL,
; 5535 :                   ( i == 1 ) ?
; 5536 :                     uint64_t ( _mem_info.AvailableForReservation *
; 5537 :                                  config.mem.reserve * 0.01f )
; 5538 :                            :
; 5539 :                            0
; 5540 :         );
; 5541 :       }
; 5542 : 
; 5543 :       ::mem_info [0].nodes = ( i - 1 );
; 5544 :       ::mem_info [1].nodes = ( i - 1 );
; 5545 : 
; 5546 :       dll_log.LogEx ( false, L"\n" );

	push	OFFSET $SG370154
	lea	eax, DWORD PTR [esi-1]
	push	0
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	mov	DWORD PTR ?mem_info@@3PAUmem_info_t@@A+276, eax
	mov	DWORD PTR ?mem_info@@3PAUmem_info_t@@A+556, eax
	call	?LogEx@iSK_Logger@@UAAX_NQB_WZZ		; iSK_Logger::LogEx
	mov	esi, DWORD PTR _auto_lock$3[ebp]
	add	esp, 12					; 0000000cH
	pop	edi
$LN11@StartBudge:
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h

; 266  :     LeaveCriticalSection (cs_);

	push	DWORD PTR [esi]
	call	DWORD PTR __imp__LeaveCriticalSection@4
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp

; 5550 :   return hr;

	mov	eax, DWORD PTR _hr$1$[ebp]
	pop	esi

; 5551 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN55@StartBudge:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN58@StartBudge:
	DD	$LN16@StartBudge
	DD	$LN17@StartBudge
	DD	$LN18@StartBudge
	DD	$LN19@StartBudge
	DD	$LN20@StartBudge
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?StartBudgetThread@DXGI@SK@@YAJPAPAUIDXGIAdapter@@@Z$0:
	lea	ecx, DWORD PTR _auto_lock$3[ebp]
	jmp	??1?$lock_guard@VSK_Thread_CriticalSection@@@std@@QAE@XZ ; std::lock_guard<SK_Thread_CriticalSection>::~lock_guard<SK_Thread_CriticalSection>
__ehhandler$?StartBudgetThread@DXGI@SK@@YAJPAPAUIDXGIAdapter@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?StartBudgetThread@DXGI@SK@@YAJPAPAUIDXGIAdapter@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?StartBudgetThread@DXGI@SK@@YAJPAPAUIDXGIAdapter@@@Z ENDP ; SK::DXGI::StartBudgetThread
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
?Shutdown@DXGI@SK@@YA_NXZ PROC				; SK::DXGI::Shutdown

; 5281 : #ifdef _WIN64
; 5282 :   if (! lstrcmpW (SK_GetHostApp (), L"DarkSoulsIII.exe"))
; 5283 :   {
; 5284 :     SK_DS3_ShutdownPlugin (L"dxgi");
; 5285 :   }
; 5286 : #endif
; 5287 : 
; 5288 :   if (config.apis.dxgi.d3d11.hook) SK_D3D11_Shutdown ();

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+789, 0
	je	SHORT $LN2@Shutdown
	call	?SK_D3D11_Shutdown@@YAXXZ		; SK_D3D11_Shutdown
$LN2@Shutdown:

; 5289 : 
; 5290 : #ifdef _WIN64
; 5291 :   if (config.apis.dxgi.d3d12.hook) SK_D3D12_Shutdown ();
; 5292 : #endif
; 5293 : 
; 5294 :   return SK_ShutdownCore (L"dxgi");

	push	OFFSET $SG370033
	call	?SK_ShutdownCore@@YG_NPB_W@Z		; SK_ShutdownCore

; 5295 : }

	ret	0
?Shutdown@DXGI@SK@@YA_NXZ ENDP				; SK::DXGI::Shutdown
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
_TEXT	SEGMENT
?Startup@DXGI@SK@@YA_NXZ PROC				; SK::DXGI::Startup

; 4768 :   return SK_StartupCore (L"dxgi", dxgi_init_callback);

	push	OFFSET ?dxgi_init_callback@@YGXP6GXXZ@Z	; dxgi_init_callback
	push	OFFSET $SG366063
	call	?SK_StartupCore@@YG_NPB_WPAX@Z		; SK_StartupCore

; 4769 : }

	ret	0
?Startup@DXGI@SK@@YA_NXZ ENDP				; SK::DXGI::Startup
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0mem_info_t@@QAE@XZ
_TEXT	SEGMENT
??0mem_info_t@@QAE@XZ PROC				; mem_info_t::mem_info_t, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx+272], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+276], 0
	ret	0
??0mem_info_t@@QAE@XZ ENDP				; mem_info_t::mem_info_t
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0memory_stats_t@@QAE@XZ
_TEXT	SEGMENT
??0memory_stats_t@@QAE@XZ PROC				; memory_stats_t::memory_stats_t, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], -1
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], -1
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], -1
	mov	DWORD PTR [ecx+20], -1
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+32], -1
	mov	DWORD PTR [ecx+36], -1
	mov	DWORD PTR [ecx+40], 0
	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR [ecx+48], -1
	mov	DWORD PTR [ecx+52], -1
	mov	DWORD PTR [ecx+56], 0
	mov	DWORD PTR [ecx+60], 0
	mov	DWORD PTR [ecx+64], -1
	mov	DWORD PTR [ecx+68], -1
	mov	DWORD PTR [ecx+72], 0
	mov	DWORD PTR [ecx+76], 0
	mov	DWORD PTR [ecx+80], 0
	mov	DWORD PTR [ecx+84], 0
	ret	0
??0memory_stats_t@@QAE@XZ ENDP				; memory_stats_t::memory_stats_t
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ?unlock@SK_Thread_CriticalSection@@QAEXXZ
_TEXT	SEGMENT
?unlock@SK_Thread_CriticalSection@@QAEXXZ PROC		; SK_Thread_CriticalSection::unlock, COMDAT
; _this$ = ecx

; 266  :     LeaveCriticalSection (cs_);

	push	DWORD PTR [ecx]
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 267  :   }

	ret	0
?unlock@SK_Thread_CriticalSection@@QAEXXZ ENDP		; SK_Thread_CriticalSection::unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ?lock@SK_Thread_CriticalSection@@QAEXXZ
_TEXT	SEGMENT
?lock@SK_Thread_CriticalSection@@QAEXXZ PROC		; SK_Thread_CriticalSection::lock, COMDAT
; _this$ = ecx

; 261  :     EnterCriticalSection (cs_);

	push	DWORD PTR [ecx]
	call	DWORD PTR __imp__EnterCriticalSection@4

; 262  :   }

	ret	0
?lock@SK_Thread_CriticalSection@@QAEXXZ ENDP		; SK_Thread_CriticalSection::lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran, COMDAT

; 3646 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN4@Xran:
$LN3@Xran:
	int	3
?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Check_offset, COMDAT
; _this$ = ecx

; 3629 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

	npad	2
	push	ebp
	mov	ebp, esp

; 3630 : 		if (this->_Mysize() < _Off)

	mov	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Off$[ebp]
	jb	SHORT $LN14@Check_offs

; 3633 : 			}
; 3634 : 		}

	pop	ebp
	ret	4
$LN14@Check_offs:

; 3631 : 			{
; 3632 : 			_Xran();

	call	?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
$LN16@Check_offs:
$LN13@Check_offs:
	int	3
?_Check_offset@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen, COMDAT

; 3625 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 3605 : 		{	// initialize buffer, deallocating any storage

	npad	2
	push	esi
	mov	esi, ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 8

; 3606 : 		this->_Orphan_all();
; 3607 : 		auto& _My_data = this->_Get_data();
; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN2@Tidy_deall
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN2@Tidy_deall:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [esi], ax
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3621 : 		}

	ret	0
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [ecx], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3602 : 		}

	ret	0
?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NQB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NQB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside, COMDAT
; _this$ = ecx

; 3588 : 		{	// test if _Ptr points inside string

	npad	2
	push	ebp
	mov	ebp, esp

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN13@Inside
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	jmp	SHORT $LN14@Inside
$LN13@Inside:
	mov	edx, ecx
$LN14@Inside:

; 3589 : 		const auto& _My_data = this->_Get_data();
; 3590 : 		const _Elem * const _My_chars = _My_data._Myptr();
; 3591 : 		return (_My_chars <= _Ptr && _Ptr < _My_chars + _My_data._Mysize);

	cmp	edx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
	mov	eax, DWORD PTR [ecx+16]
	lea	eax, DWORD PTR [edx+eax*2]
	cmp	DWORD PTR __Ptr$[ebp], eax
	jae	SHORT $LN3@Inside
	mov	al, 1

; 3592 : 		}

	pop	ebp
	ret	4
$LN3@Inside:

; 3589 : 		const auto& _My_data = this->_Get_data();
; 3590 : 		const _Elem * const _My_chars = _My_data._Myptr();
; 3591 : 		return (_My_chars <= _Ptr && _Ptr < _My_chars + _My_data._Mysize);

	xor	al, al

; 3592 : 		}

	pop	ebp
	ret	4
?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NQB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow, COMDAT
; _this$ = ecx

; 3572 : 		{	// ensure buffer is big enough

	npad	2
	push	ebp
	mov	ebp, esp

; 3573 : 		if (_Newsize == 0)

	mov	eax, DWORD PTR __Newsize$[ebp]
	test	eax, eax
	jne	SHORT $LN2@Grow

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN16@Grow
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN16@Grow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
	mov	WORD PTR [ecx], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3576 : 			return (false);

	xor	al, al

; 3585 : 		}

	pop	ebp
	ret	4
$LN2@Grow:

; 3577 : 			}
; 3578 : 
; 3579 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [ecx+20], eax
	jae	SHORT $LN3@Grow

; 3580 : 			{	// reallocate to grow
; 3581 : 			_Copy(_Newsize);

	push	eax
	call	?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
$LN3@Grow:

; 3582 : 			}
; 3583 : 
; 3584 : 		return (true);	// return true only if more work to do

	mov	al, 1

; 3585 : 		}

	pop	ebp
	ret	4
?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos, COMDAT
; _this$ = ecx

; 3566 : 		{	// set new length and null terminator

	npad	2
	push	ebp
	mov	ebp, esp

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 3567 : 		auto& _My_data = this->_Get_data();
; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN11@Eos
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax+edx*2], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3569 : 		}

	pop	ebp
	ret	4
$LN11@Eos:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
	mov	WORD PTR [ecx+edx*2], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3569 : 		}

	pop	ebp
	ret	4
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Oldres$ = -28						; size = 4
_this$ = -24						; size = 4
__Ptr$1$ = -20						; size = 4
__Ptr$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newres$ = 8						; size = 4
__Newsize$ = 8						; size = 4
?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy, COMDAT
; _this$ = ecx

; 3514 : 		{	// reallocate to new buffer of at least _Newsize, copying existing elements there

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H

; 3515 : 		const auto _Max = max_size();
; 3516 : 		if (_Newsize > _Max)

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	cmp	eax, 2147483646				; 7ffffffeH
	jbe	SHORT $LN2@Copy

; 3517 : 			{	// too long
; 3518 : 			_Xlen();

	call	?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
$LN102@Copy:
$LN2@Copy:

; 3519 : 			}
; 3520 : 
; 3521 : 		auto& _My_data = this->_Get_data();
; 3522 : 		const size_type _Oldres = _My_data._Myres;

	mov	ebx, DWORD PTR [esi+20]

; 3523 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	edi, eax
	or	edi, 7
	mov	DWORD PTR __Oldres$[ebp], ebx

; 3524 : 		if (_Max < _Newres)

	cmp	edi, 2147483646				; 7ffffffeH
	jbe	SHORT $LN3@Copy

; 3525 : 			{
; 3526 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	edi, eax
	jmp	SHORT $LN8@Copy
$LN3@Copy:

; 3527 : 			}
; 3528 : 		else if (_Oldres / 2 <= _Newres / 3)

	mov	eax, -1431655765			; aaaaaaabH
	mov	ecx, ebx
	mul	edi
	shr	ecx, 1
	shr	edx, 1
	cmp	ecx, edx
	jbe	SHORT $LN8@Copy

; 3529 : 			;
; 3530 : 		else if (_Oldres <= _Max - _Oldres / 2)

	mov	eax, 2147483646				; 7ffffffeH

; 3531 : 			{
; 3532 : 			_Newres = _Oldres + _Oldres / 2;	// grow exponentially if possible

	lea	edi, DWORD PTR [ecx+ebx]
	sub	eax, ecx
	cmp	ebx, eax
	jbe	SHORT $LN8@Copy

; 3533 : 			}
; 3534 : 		else
; 3535 : 			{
; 3536 : 			_Newres = _Max;	// settle for max_size()

	mov	edi, 2147483646				; 7ffffffeH
$LN8@Copy:

; 3537 : 			}
; 3538 : 
; 3539 : 		auto& _Al = this->_Getal();
; 3540 : 		pointer _Ptr;
; 3541 : 		_TRY_BEGIN
; 3542 : 			_Ptr = _Al.allocate(_Newres + 1);

	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1077 : 		return (_Mybase::allocate(_Count));

	push	eax
	mov	ecx, esi
	call	?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
	mov	ecx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
	jmp	SHORT $LN100@Copy
__catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z$0:

; 3544 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	eax, DWORD PTR __Newsize$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1077 : 		return (_Mybase::allocate(_Count));

	mov	ecx, DWORD PTR _this$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3544 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	DWORD PTR __Newres$[ebp], eax

; 3545 : 			_Ptr = _Al.allocate(_Newres + 1);	// if throws, *this unmodified

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1077 : 		return (_Mybase::allocate(_Count));

	push	eax
	call	?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3545 : 			_Ptr = _Al.allocate(_Newres + 1);	// if throws, *this unmodified

	mov	DWORD PTR __Ptr$[ebp], eax

; 3546 : 		_CATCH_END

	mov	eax, $LN97@Copy
	ret	0
$LN97@Copy:
	mov	esi, DWORD PTR _this$[ebp]
	mov	ebx, DWORD PTR __Oldres$[ebp]
	mov	edi, DWORD PTR __Newres$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
$LN100@Copy:

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	mov	eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3546 : 		_CATCH_END

	mov	DWORD PTR __Ptr$1$[ebp], ecx
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	lea	eax, DWORD PTR [eax*2+2]
	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3550 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN10@Copy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	push	DWORD PTR [esi]
	push	ecx
	call	_memcpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3553 : 			_Al.deallocate(_My_data._Bx._Ptr, _Oldres + 1);

	lea	eax, DWORD PTR [ebx+1]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3556 : 		else

	jmp	SHORT $LN101@Copy
$LN10@Copy:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	push	esi
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN101@Copy:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3563 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3562 : 		_My_data._Myres = _Newres;

	mov	DWORD PTR [esi+20], edi

; 3563 : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN99@Copy:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Equal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NQB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Equal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NQB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Equal, COMDAT
; _this$ = ecx

; 3420 : 		{	// compare [0, _Mysize()) with _Ptr for equality

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	mov	edx, DWORD PTR __Ptr$[ebp]
	push	esi
	push	edi
	mov	edi, edx
	lea	esi, DWORD PTR [edi+2]
	npad	1
$LL51@Equal:
	mov	ax, WORD PTR [edi]
	add	edi, 2
	test	ax, ax
	jne	SHORT $LL51@Equal
	sub	edi, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1844 : 		return (_Get_data()._Mysize);

	lea	esi, DWORD PTR [ecx+16]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	sar	edi, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN25@Equal
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN25@Equal:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3421 : 		return (_Traits_equal<_Traits>(this->_Myptr(), this->_Mysize(), _Ptr, _Traits::length(_Ptr)));

	mov	esi, DWORD PTR [esi]

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

	cmp	esi, edi
	jne	SHORT $LN33@Equal
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 216  :         for (; 0 < _N; ++_S1, ++_S2, --_N)

	test	esi, esi
	je	SHORT $LN50@Equal
$LL42@Equal:

; 217  :             if (*_S1 != *_S2)

	mov	ax, WORD PTR [ecx]
	cmp	ax, WORD PTR [edx]
	jne	SHORT $LN46@Equal

; 216  :         for (; 0 < _N; ++_S1, ++_S2, --_N)

	add	ecx, 2
	add	edx, 2
	sub	esi, 1
	jne	SHORT $LL42@Equal
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

	mov	al, 1
	pop	esi

; 3422 : 		}

	pop	ebp
	ret	4
$LN46@Equal:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 218  :                 return *_S1 < *_S2 ? -1 : 1;

	movzx	eax, WORD PTR [ecx]
	cmp	ax, WORD PTR [edx]
	sbb	eax, eax
	and	eax, -2					; fffffffeH
	add	eax, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

	jne	SHORT $LN33@Equal
$LN50@Equal:
	pop	edi
	mov	al, 1
	pop	esi

; 3422 : 		}

	pop	ebp
	ret	4
$LN33@Equal:
	pop	edi

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

	xor	al, al
	pop	esi

; 3422 : 		}

	pop	ebp
	ret	4
?_Equal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE_NQB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Equal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Size$ = 12						; size = 4
?_Clamp_suffix_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIII@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 3410 : 		{	// trims _Size to the longest it can be assuming a string at/after _Off

	npad	2
	push	ebp
	mov	ebp, esp

; 3411 : 		return (_Min_value(_Size, this->_Mysize() - _Off));

	mov	ecx, DWORD PTR [ecx+16]
	sub	ecx, DWORD PTR __Off$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

	mov	eax, DWORD PTR __Size$[ebp]
	cmp	ecx, eax
	cmovb	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3412 : 		}

	pop	ebp
	ret	8
?_Clamp_suffix_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIII@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size, COMDAT
; _this$ = ecx

; 3030 : 		const size_type _Num = this->_Getal().max_size();
; 3031 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	eax, 2147483646				; 7ffffffeH

; 3032 : 		}

	ret	0
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN13@c_str

; 3003 : 		return (this->_Myptr());

	mov	eax, DWORD PTR [ecx]

; 3004 : 		}

	ret	0
$LN13@c_str:

; 3003 : 		return (this->_Myptr());

	mov	eax, ecx

; 3004 : 		}

	ret	0
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase, COMDAT
; _this$ = ecx

; 2592 : 		{	// erase elements [_Off, _Off + _Count)

	npad	2
	push	ebp
	mov	ebp, esp

; 3630 : 		if (this->_Mysize() < _Off)

	mov	edx, DWORD PTR __Off$[ebp]
	push	ebx
	push	esi

; 2592 : 		{	// erase elements [_Off, _Off + _Count)

	mov	esi, ecx
	push	edi

; 3630 : 		if (this->_Mysize() < _Off)

	mov	edi, DWORD PTR [esi+16]
	cmp	edi, edx
	jb	$LN97@erase

; 2593 : 		_Check_offset(_Off);
; 2594 : 		if (this->_Mysize() - _Off <= _Count)

	mov	ebx, DWORD PTR __Count$[ebp]
	mov	eax, edi
	sub	eax, edx
	cmp	eax, ebx
	ja	SHORT $LN2@erase

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN38@erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	pop	edi
	mov	WORD PTR [eax+edx*2], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2606 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2607 : 		}

	pop	ebp
	ret	8
$LN38@erase:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	WORD PTR [eax+edx*2], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2607 : 		}

	pop	ebp
	ret	8
$LN2@erase:

; 2595 : 			{
; 2596 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 2597 : 			}
; 2598 : 		else if (_Count != 0)

	test	ebx, ebx
	je	SHORT $LN94@erase

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN57@erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN58@erase
$LN57@erase:
	mov	eax, esi
$LN58@erase:

; 2599 : 			{	// move elements down
; 2600 : 			value_type *_Ptr = this->_Myptr() + _Off;

	lea	ecx, DWORD PTR [eax+edx*2]

; 2601 : 			size_type _Newsize = this->_Mysize() - _Count;

	sub	edi, ebx
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

	mov	eax, edi
	sub	eax, edx
	add	eax, eax
	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2602 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	lea	eax, DWORD PTR [ecx+ebx*2]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

	push	eax
	push	ecx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN87@erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax+edi*2], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2606 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 2607 : 		}

	pop	ebp
	ret	8
$LN87@erase:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax+edi*2], cx
$LN94@erase:
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2606 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2607 : 		}

	pop	ebp
	ret	8
$LN97@erase:

; 3632 : 			_Xran();

	call	?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
$LN99@erase:
$LN96@erase:
	int	3
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase, COMDAT
; _this$ = ecx

; 2585 : 		{	// erase elements [_Off, ...)

	npad	2
	push	ebp
	mov	ebp, esp

; 3630 : 		if (this->_Mysize() < _Off)

	mov	eax, DWORD PTR __Off$[ebp]
	cmp	DWORD PTR [ecx+16], eax
	jb	SHORT $LN36@erase

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN26@erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [ecx]
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	esi, esi
	mov	WORD PTR [edx+eax*2], si
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2588 : 		return (*this);

	mov	eax, ecx
	pop	esi

; 2589 : 		}

	pop	ebp
	ret	4
$LN26@erase:

; 1614 : 		return (_Large_string_engaged()

	mov	edx, ecx
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	esi, esi
	mov	WORD PTR [edx+eax*2], si
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2588 : 		return (*this);

	mov	eax, ecx
	pop	esi

; 2589 : 		}

	pop	ebp
	ret	4
$LN36@erase:

; 3632 : 			_Xran();

	call	?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
$LN38@erase:
$LN35@erase:
	int	3
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 2428 : 		{	// assign [_Ptr, <null>)

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, edx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2428 : 		{	// assign [_Ptr, <null>)

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	lea	edi, DWORD PTR [eax+2]
$LL6@assign:
	mov	cx, WORD PTR [eax]
	add	eax, 2
	test	cx, cx
	jne	SHORT $LL6@assign
	sub	eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	sar	eax, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	eax
	push	edx
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	pop	edi
	pop	esi

; 2430 : 		}

	pop	ebp
	ret	4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 2412 : 		{	// assign [_Ptr, _Ptr + _Count)

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN17@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	jmp	SHORT $LN18@assign
$LN17@assign:
	mov	edx, esi
$LN18@assign:

; 3591 : 		return (_My_chars <= _Ptr && _Ptr < _My_chars + _My_data._Mysize);

	mov	edi, DWORD PTR __Ptr$[ebp]
	cmp	edx, edi
	ja	SHORT $LN2@assign
	mov	eax, DWORD PTR [esi+16]
	lea	eax, DWORD PTR [edx+eax*2]
	cmp	edi, eax
	jae	SHORT $LN2@assign

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	ecx, 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN33@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN34@assign
$LN33@assign:
	mov	eax, esi
$LN34@assign:

; 2413 : 		if (_Inside(_Ptr))
; 2414 : 			{
; 2415 : 			return (assign(*this, _Ptr - this->_Myptr(), _Count));	// substring

	push	DWORD PTR __Count$[ebp]
	sub	edi, eax
	mov	ecx, esi
	sar	edi, 1
	push	edi
	push	esi
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	pop	edi
	pop	esi

; 2425 : 		}

	pop	ebp
	ret	8
$LN2@assign:
	push	ebx

; 3573 : 		if (_Newsize == 0)

	mov	ebx, DWORD PTR __Count$[ebp]
	test	ebx, ebx
	jne	SHORT $LN40@assign

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ebx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	ecx, 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN53@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	pop	ebx
	pop	edi
	mov	WORD PTR [eax], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2424 : 		return (*this);

	mov	eax, esi
	pop	esi

; 2425 : 		}

	pop	ebp
	ret	8
$LN53@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	pop	ebx
	pop	edi
	pop	esi
	mov	WORD PTR [eax], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2425 : 		}

	pop	ebp
	ret	8
$LN40@assign:

; 3579 : 		if (this->_Myres() < _Newsize)

	cmp	ecx, ebx
	jae	SHORT $LN41@assign

; 3580 : 			{	// reallocate to grow
; 3581 : 			_Copy(_Newsize);

	push	ebx
	mov	ecx, esi
	call	?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
$LN41@assign:

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN81@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN82@assign
$LN81@assign:
	mov	eax, esi
$LN82@assign:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	lea	ecx, DWORD PTR [ebx+ebx]
	push	ecx
	push	edi
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ebx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN102@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax+ebx*2], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2424 : 		return (*this);

	mov	eax, esi
	pop	ebx
	pop	edi
	pop	esi

; 2425 : 		}

	pop	ebp
	ret	8
$LN102@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax+ebx*2], cx
	pop	ebx
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2425 : 		}

	pop	ebp
	ret	8
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 2378 : 		{	// assign _Right [_Roff, _Roff + _Count)

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx

; 3630 : 		if (this->_Mysize() < _Off)

	mov	ebx, DWORD PTR __Right$[ebp]
	push	esi

; 2378 : 		{	// assign _Right [_Roff, _Roff + _Count)

	mov	esi, ecx

; 3630 : 		if (this->_Mysize() < _Off)

	mov	ecx, DWORD PTR __Roff$[ebp]
	push	edi
	mov	eax, DWORD PTR [ebx+16]
	cmp	eax, ecx
	jb	$LN161@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

	mov	edi, DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3411 : 		return (_Min_value(_Size, this->_Mysize() - _Off));

	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

	cmp	eax, edi
	cmovb	edi, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2382 : 		if (this == _STD addressof(_Right))

	cmp	esi, ebx
	jne	SHORT $LN2@assign

; 2383 : 			{	// substring
; 2384 : 			erase(_Roff + _Count);

	lea	eax, DWORD PTR [ecx+edi]

; 3630 : 		if (this->_Mysize() < _Off)

	cmp	DWORD PTR [esi+16], eax
	jb	$LN163@assign

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], eax

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN62@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN63@assign
$LN62@assign:
	mov	edx, esi
$LN63@assign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	edi, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2385 : 			erase(0, _Roff);

	push	ecx
	push	edi
	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [edx+eax*2], di
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2385 : 			erase(0, _Roff);

	call	?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
	pop	edi

; 2393 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN2@assign:

; 3573 : 		if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN72@assign

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN85@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	pop	edi
	mov	WORD PTR [eax], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2393 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN85@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	WORD PTR [eax], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN72@assign:

; 3579 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN73@assign

; 3580 : 			{	// reallocate to grow
; 3581 : 			_Copy(_Newsize);

	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
	mov	ecx, DWORD PTR __Roff$[ebp]
$LN73@assign:

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ebx+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN113@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ebx, DWORD PTR [ebx]
$LN113@assign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN129@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN130@assign
$LN129@assign:
	mov	edx, esi
$LN130@assign:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	lea	eax, DWORD PTR [edi+edi]
	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2389 : 			_Traits::copy(this->_Myptr(), _Right._Myptr() + _Roff, _Count);

	lea	eax, DWORD PTR [ebx+ecx*2]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	push	eax
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN150@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax+edi*2], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2393 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN150@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax+edi*2], cx
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN161@assign:

; 3632 : 			_Xran();

	call	?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
$LN164@assign:
$LN163@assign:
	call	?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
$LN165@assign:
$LN160@assign:
	int	3
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 2343 : 		{	// append [_Ptr, <null>)

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, edx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2343 : 		{	// append [_Ptr, <null>)

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	lea	edi, DWORD PTR [eax+2]
$LL6@append:
	mov	cx, WORD PTR [eax]
	add	eax, 2
	test	cx, cx
	jne	SHORT $LL6@append
	sub	eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2344 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	sar	eax, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2344 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	eax
	push	edx
	call	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
	pop	edi
	pop	esi

; 2345 : 		}

	pop	ebp
	ret	4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 2321 : 		{	// append [_Ptr, _Ptr + _Count)

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	edx, DWORD PTR [esi+20]
	cmp	edx, 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN19@append
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
$LN19@append:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3591 : 		return (_My_chars <= _Ptr && _Ptr < _My_chars + _My_data._Mysize);

	mov	edi, DWORD PTR __Ptr$[ebp]
	cmp	ecx, edi
	ja	SHORT $LN2@append
	mov	eax, DWORD PTR [esi+16]
	lea	eax, DWORD PTR [ecx+eax*2]
	cmp	edi, eax
	jae	SHORT $LN2@append

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	edx, 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN34@append
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN35@append
$LN34@append:
	mov	eax, esi
$LN35@append:

; 2322 : 		if (_Inside(_Ptr))
; 2323 : 			{
; 2324 : 			return (append(*this, _Ptr - this->_Myptr(), _Count));	// substring

	push	DWORD PTR __Count$[ebp]
	sub	edi, eax
	mov	ecx, esi
	sar	edi, 1
	push	edi
	push	esi
	call	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
	pop	edi
	pop	esi

; 2340 : 		}

	pop	ebp
	ret	8
$LN2@append:

; 2325 : 			}
; 2326 : 
; 2327 : 		if (npos - this->_Mysize() <= _Count)

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ebx
	mov	ebx, DWORD PTR [esi+16]
	mov	eax, ebx
	not	eax
	cmp	eax, ecx
	jbe	$LN142@append

; 2330 : 			}
; 2331 : 
; 2332 : 		const size_type _Num = this->_Mysize() + _Count;

	add	ebx, ecx

; 2333 : 		if (_Count != 0 && _Grow(_Num))

	test	ecx, ecx
	je	SHORT $LN137@append

; 3573 : 		if (_Newsize == 0)

	test	ebx, ebx
	jne	SHORT $LN59@append

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ebx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	edx, 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN72@append
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	pop	ebx
	pop	edi
	mov	WORD PTR [eax], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2339 : 		return (*this);

	mov	eax, esi
	pop	esi

; 2340 : 		}

	pop	ebp
	ret	8
$LN72@append:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	pop	ebx
	pop	edi
	pop	esi
	mov	WORD PTR [eax], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2340 : 		}

	pop	ebp
	ret	8
$LN59@append:

; 3579 : 		if (this->_Myres() < _Newsize)

	cmp	edx, ebx
	jae	SHORT $LN60@append

; 3580 : 			{	// reallocate to grow
; 3581 : 			_Copy(_Newsize);

	push	ebx
	mov	ecx, esi
	call	?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
	mov	ecx, DWORD PTR __Count$[ebp]
$LN60@append:

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN100@append
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN101@append
$LN100@append:
	mov	edx, esi
$LN101@append:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	lea	eax, DWORD PTR [ecx+ecx]
	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2335 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);

	mov	eax, DWORD PTR [esi+16]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2335 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);

	lea	eax, DWORD PTR [edx+eax*2]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ebx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN130@append
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax+ebx*2], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2339 : 		return (*this);

	mov	eax, esi
	pop	ebx
	pop	edi
	pop	esi

; 2340 : 		}

	pop	ebp
	ret	8
$LN130@append:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax+ebx*2], cx
$LN137@append:
	pop	ebx
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2339 : 		return (*this);

	mov	eax, esi
	pop	esi

; 2340 : 		}

	pop	ebp
	ret	8
$LN142@append:

; 2328 : 			{
; 2329 : 			_Xlen();	// result too long

	call	?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
$LN144@append:
$LN141@append:
	int	3
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
tv494 = 16						; size = 4
__Count$ = 16						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 2288 : 		{	// append _Right [_Roff, _Roff + _Count)

	npad	2
	push	ebp
	mov	ebp, esp

; 3630 : 		if (this->_Mysize() < _Off)

	mov	edx, DWORD PTR __Roff$[ebp]
	push	ebx
	mov	ebx, DWORD PTR __Right$[ebp]
	push	esi
	push	edi

; 2288 : 		{	// append _Right [_Roff, _Roff + _Count)

	mov	esi, ecx

; 3630 : 		if (this->_Mysize() < _Off)

	mov	eax, DWORD PTR [ebx+16]
	cmp	eax, edx
	jb	$LN150@append
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

	mov	ecx, DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3411 : 		return (_Min_value(_Size, this->_Mysize() - _Off));

	sub	eax, edx

; 2291 : 		if (npos - this->_Mysize() <= _Count)

	mov	edi, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

	cmp	eax, ecx
	cmovb	ecx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2291 : 		if (npos - this->_Mysize() <= _Count)

	mov	eax, edi
	not	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

	mov	DWORD PTR __Count$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2291 : 		if (npos - this->_Mysize() <= _Count)

	cmp	eax, ecx
	jbe	$LN152@append

; 2294 : 			}
; 2295 : 
; 2296 : 		const size_type _Num = this->_Mysize() + _Count;

	add	edi, ecx

; 2297 : 		if (_Count != 0 && _Grow(_Num))

	test	ecx, ecx
	je	$LN146@append

; 3573 : 		if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN52@append

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN65@append
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	pop	edi
	mov	WORD PTR [eax], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2302 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2303 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN65@append:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	WORD PTR [eax], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2303 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN52@append:

; 3579 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN53@append

; 3580 : 			{	// reallocate to grow
; 3581 : 			_Copy(_Newsize);

	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Copy
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Roff$[ebp]
$LN53@append:

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ebx+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN93@append
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ebx, DWORD PTR [ebx]
$LN93@append:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN109@append
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR tv494[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN110@append
$LN109@append:
	mov	DWORD PTR tv494[ebp], esi
$LN110@append:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	lea	eax, DWORD PTR [ecx+ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2299 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Right._Myptr() + _Roff, _Count);

	mov	ecx, DWORD PTR tv494[ebp]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2299 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Right._Myptr() + _Roff, _Count);

	lea	eax, DWORD PTR [ebx+edx*2]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2299 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Right._Myptr() + _Roff, _Count);

	mov	eax, DWORD PTR [esi+16]
	lea	eax, DWORD PTR [ecx+eax*2]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN139@append
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax+edi*2], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2302 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 2303 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN139@append:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [eax+edi*2], cx
$LN146@append:
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2302 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2303 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN150@append:

; 3632 : 			_Xran();

	call	?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xran
$LN153@append:
$LN152@append:

; 2292 : 			{
; 2293 : 			_Xlen();	// result too long

	call	?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
$LN154@append:
$LN149@append:
	int	3
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@QB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@QB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=, COMDAT
; _this$ = ecx

; 2272 : 		{	// append [_Ptr, <null>)

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, edx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2272 : 		{	// append [_Ptr, <null>)

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	lea	edi, DWORD PTR [eax+2]
$LL8@operator:
	mov	cx, WORD PTR [eax]
	add	eax, 2
	test	cx, cx
	jne	SHORT $LL8@operator
	sub	eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2344 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	sar	eax, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2344 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	eax
	push	edx
	call	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
	pop	edi
	pop	esi

; 2273 : 		return (append(_Ptr));
; 2274 : 		}

	pop	ebp
	ret	4
??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@QB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@QB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@QB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=, COMDAT
; _this$ = ecx

; 2250 : 		{	// assign [_Ptr, <null>)

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, edx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2250 : 		{	// assign [_Ptr, <null>)

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	lea	edi, DWORD PTR [eax+2]
$LL8@operator:
	mov	cx, WORD PTR [eax]
	add	eax, 2
	test	cx, cx
	jne	SHORT $LL8@operator
	sub	eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	sar	eax, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	eax
	push	edx
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	pop	edi
	pop	esi

; 2251 : 		return (assign(_Ptr));
; 2252 : 		}

	pop	ebp
	ret	4
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@QB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 2215 : 		{	// destroy the string

	npad	2
	push	esi
	mov	esi, ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN4@basic_stri
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN4@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [esi], ax
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2217 : 		}

	ret	0
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv_contents_with_alloc_always_equal, COMDAT
; _this$ = ecx

; 2122 : 		{	// assign by stealing _Right's buffer, memcpy optimization

	npad	2
	push	ebp
	mov	ebp, esp

; 2123 : 			// pre: this != &_Right
; 2124 : 			// pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2125 : 			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2126 : 		auto& _Right_data = _Right._Get_data();
; 2127 : 
; 2128 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2129 : 		if (_Right_data._Large_string_engaged())
; 2130 : 			{	// take ownership of _Right's iterators along with its buffer
; 2131 : 			this->_Swap_all(_Right);
; 2132 : 			}
; 2133 : 		else
; 2134 : 			{
; 2135 : 			_Right._Orphan_all();
; 2136 : 			}
; 2137 : #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 2138 : 
; 2139 : 		const auto _My_data_mem = reinterpret_cast<unsigned char *>(_STD addressof(this->_Get_data()))
; 2140 : 			+ _Memcpy_move_offset;
; 2141 : 		const auto _Right_data_mem = reinterpret_cast<unsigned char *>(_STD addressof(_Right_data))
; 2142 : 			+ _Memcpy_move_offset;
; 2143 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	mov	eax, DWORD PTR __Right$[ebp]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	ecx, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [eax], cx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2145 : 		}

	pop	ebp
	ret	8
?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv_contents_with_alloc_always_equal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 2054 : 		{	// construct by moving _Right

	npad	2
	push	ebp
	mov	ebp, esp

; 2143 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	mov	eax, DWORD PTR __Right$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 1596 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 2143 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [eax], dx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2056 : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 1980 : 		{	// construct from [_Ptr, <null>)

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	mov	edx, DWORD PTR __Ptr$[ebp]

; 326  : 		_Left = _Right;

	xor	eax, eax
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1980 : 		{	// construct from [_Ptr, <null>)

	mov	esi, ecx
	push	edi

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [esi], ax

; 289  : 		return (_CSTD wcslen(_First));

	mov	eax, edx
	lea	edi, DWORD PTR [eax+2]
$LL25@basic_stri:
	mov	cx, WORD PTR [eax]
	add	eax, 2
	test	cx, cx
	jne	SHORT $LL25@basic_stri
	sub	eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 289  : 		return (_CSTD wcslen(_First));

	sar	eax, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	eax
	push	edx
	call	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
	pop	edi

; 1981 : 		_Tidy_init();
; 1982 : 		assign(_Ptr);
; 1983 : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@QB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [ecx], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1941 : 		}

	mov	eax, ecx
	ret	0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >, COMDAT
; _this$ = ecx
	ret	0
??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 343  : 		return (_Myval2);

	mov	eax, ecx

; 344  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 338  : 		return (_Myval2);

	mov	eax, ecx

; 339  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 323  : 		return (*this);

	mov	eax, ecx

; 324  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 318  : 		return (*this);

	mov	eax, ecx

; 319  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myres, COMDAT
; _this$ = ecx

; 1849 : 		return (_Get_data()._Myres);

	lea	eax, DWORD PTR [ecx+20]

; 1850 : 		}

	ret	0
?_Myres@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize, COMDAT
; _this$ = ecx

; 1844 : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 1845 : 		}

	ret	0
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize, COMDAT
; _this$ = ecx

; 1839 : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 1840 : 		}

	ret	0
?_Mysize@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data, COMDAT
; _this$ = ecx

; 1834 : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 1835 : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data, COMDAT
; _this$ = ecx

; 1829 : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 1830 : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal, COMDAT
; _this$ = ecx

; 1824 : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 1825 : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal, COMDAT
; _this$ = ecx

; 1819 : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 1820 : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Orphan_all@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 1809 : 		_Get_data()._Orphan_all();
; 1810 : 		}

	ret	0
?_Orphan_all@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >, COMDAT
; _this$ = ecx

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 1697 : 		}

	mov	eax, ecx

; 1596 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 1697 : 		}

	ret	0
??0?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN11@Myptr

; 1690 : 		return (_Get_data()._Myptr());

	mov	eax, DWORD PTR [ecx]

; 1691 : 		}

	ret	0
$LN11@Myptr:

; 1690 : 		return (_Get_data()._Myptr());

	mov	eax, ecx

; 1691 : 		}

	ret	0
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEPA_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEPA_WXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN11@Myptr

; 1685 : 		return (_Get_data()._Myptr());

	mov	eax, DWORD PTR [ecx]

; 1686 : 		}

	ret	0
$LN11@Myptr:

; 1685 : 		return (_Get_data()._Myptr());

	mov	eax, ecx

; 1686 : 		}

	ret	0
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEPA_WXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 1639 : 			}

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 1634 : 			{	// user-provided, for fancy pointers
; 1635 : 			}

	mov	eax, ecx
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 1627 : 		{	// returns whether the large string mode (allocated memory) is engaged

	cmp	DWORD PTR [ecx+20], 8
	setae	al

; 1628 : 		return (this->_BUF_SIZE <= _Myres);
; 1629 : 		}

	ret	0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx]

; 1622 : 			? _Unfancy(_Bx._Ptr)
; 1623 : 			: _Bx._Buf);
; 1624 : 		}

	ret	0
$LN3@Myptr:

; 1621 : 		return (_Large_string_engaged()

	mov	eax, ecx

; 1622 : 			? _Unfancy(_Bx._Ptr)
; 1623 : 			: _Bx._Buf);
; 1624 : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx]

; 1615 : 			? _Unfancy(_Bx._Ptr)
; 1616 : 			: _Bx._Buf);
; 1617 : 		}

	ret	0
$LN3@Myptr:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, ecx

; 1615 : 			? _Unfancy(_Bx._Ptr)
; 1616 : 			: _Bx._Buf);
; 1617 : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >, COMDAT
; _this$ = ecx

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 1598 : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+20], 0
	ret	0
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::max_size, COMDAT
; _this$ = ecx

; 1108 : 		return (_Mytraits::max_size(*this));

	mov	eax, 2147483647				; 7fffffffH

; 1109 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate, COMDAT
; _this$ = ecx

; 1087 : 		{	// deallocate object at _Ptr, ignore size

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 1088 : 		_Mybase::deallocate(_Ptr, _Count);
; 1089 : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::allocate, COMDAT
; _this$ = ecx

; 1076 : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 1078 : 		}

	pop	ebp

; 1077 : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 1048 : 		}

	mov	eax, ecx
	ret	4
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 1038 : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<wchar_t> >::_Wrap_alloc<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::max_size, COMDAT

; 970  : 		return (_Al.max_size());

	mov	eax, 2147483647				; 7fffffffH

; 971  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@_W@std@@QBEIXZ PROC		; std::allocator<wchar_t>::max_size, COMDAT
; _this$ = ecx

; 851  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 2147483647				; 7fffffffH

; 852  : 		}

	ret	0
?max_size@?$allocator@_W@std@@QBEIXZ ENDP		; std::allocator<wchar_t>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@_W@std@@QAEPA_WI@Z PROC		; std::allocator<wchar_t>::allocate, COMDAT
; _this$ = ecx

; 827  : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 53   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 2147483647				; 7fffffffH
	jbe	SHORT $LN5@allocate

; 58   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	add	eax, eax

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 69   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN9@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@allocate:
$LN9@allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 87   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@allocate:
$LN14@allocate:
	int	3
?allocate@?$allocator@_W@std@@QAEPA_WI@Z ENDP		; std::allocator<wchar_t>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z PROC	; std::allocator<wchar_t>::deallocate, COMDAT
; _this$ = ecx

; 822  : 		{	// deallocate object at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 824  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ENDP	; std::allocator<wchar_t>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@_W@std@@QAE@ABV01@@Z PROC		; std::allocator<wchar_t>::allocator<wchar_t>, COMDAT
; _this$ = ecx

; 807  : 		{	// construct by copying (do nothing)
; 808  : 		}

	mov	eax, ecx
	ret	4
??0?$allocator@_W@std@@QAE@ABV01@@Z ENDP		; std::allocator<wchar_t>::allocator<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@_W@std@@QAE@XZ PROC			; std::allocator<wchar_t>::allocator<wchar_t>, COMDAT
; _this$ = ecx

; 803  : 		{	// construct default allocator (do nothing)
; 804  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@_W@std@@QAE@XZ ENDP			; std::allocator<wchar_t>::allocator<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT

; 3646 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN4@Xran:
$LN3@Xran:
	int	3
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset, COMDAT
; _this$ = ecx

; 3629 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

	npad	2
	push	ebp
	mov	ebp, esp

; 3630 : 		if (this->_Mysize() < _Off)

	mov	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Off$[ebp]
	jb	SHORT $LN14@Check_offs

; 3633 : 			}
; 3634 : 		}

	pop	ebp
	ret	4
$LN14@Check_offs:

; 3631 : 			{
; 3632 : 			_Xran();

	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN16@Check_offs:
$LN13@Check_offs:
	int	3
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT

; 3625 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 3605 : 		{	// initialize buffer, deallocating any storage

	npad	2
	push	esi
	mov	esi, ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H

; 3606 : 		this->_Orphan_all();
; 3607 : 		auto& _My_data = this->_Get_data();
; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN2@Tidy_deall
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN2@Tidy_deall:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3621 : 		}

	ret	0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 3596 : 		auto& _My_data = this->_Get_data();
; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3602 : 		}

	ret	0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 3588 : 		{	// test if _Ptr points inside string

	npad	2
	push	ebp
	mov	ebp, esp

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN13@Inside
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	jmp	SHORT $LN14@Inside
$LN13@Inside:
	mov	edx, ecx
$LN14@Inside:

; 3589 : 		const auto& _My_data = this->_Get_data();
; 3590 : 		const _Elem * const _My_chars = _My_data._Myptr();
; 3591 : 		return (_My_chars <= _Ptr && _Ptr < _My_chars + _My_data._Mysize);

	cmp	edx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
	mov	eax, DWORD PTR [ecx+16]
	add	eax, edx
	cmp	DWORD PTR __Ptr$[ebp], eax
	jae	SHORT $LN3@Inside
	mov	al, 1

; 3592 : 		}

	pop	ebp
	ret	4
$LN3@Inside:

; 3589 : 		const auto& _My_data = this->_Get_data();
; 3590 : 		const _Elem * const _My_chars = _My_data._Myptr();
; 3591 : 		return (_My_chars <= _Ptr && _Ptr < _My_chars + _My_data._Mysize);

	xor	al, al

; 3592 : 		}

	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 3572 : 		{	// ensure buffer is big enough

	npad	2
	push	ebp
	mov	ebp, esp

; 3573 : 		if (_Newsize == 0)

	mov	eax, DWORD PTR __Newsize$[ebp]
	test	eax, eax
	jne	SHORT $LN2@Grow

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN16@Grow
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN16@Grow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3576 : 			return (false);

	xor	al, al

; 3585 : 		}

	pop	ebp
	ret	4
$LN2@Grow:

; 3577 : 			}
; 3578 : 
; 3579 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [ecx+20], eax
	jae	SHORT $LN3@Grow

; 3580 : 			{	// reallocate to grow
; 3581 : 			_Copy(_Newsize);

	push	eax
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
$LN3@Grow:

; 3582 : 			}
; 3583 : 
; 3584 : 		return (true);	// return true only if more work to do

	mov	al, 1

; 3585 : 		}

	pop	ebp
	ret	4
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 3566 : 		{	// set new length and null terminator

	npad	2
	push	ebp
	mov	ebp, esp

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 3567 : 		auto& _My_data = this->_Get_data();
; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN11@Eos
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3569 : 		}

	pop	ebp
	ret	4
$LN11@Eos:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [ecx+edx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3569 : 		}

	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Oldres$ = -28						; size = 4
_this$ = -24						; size = 4
__Ptr$1$ = -20						; size = 4
__Ptr$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newres$ = 8						; size = 4
__Newsize$ = 8						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 3514 : 		{	// reallocate to new buffer of at least _Newsize, copying existing elements there

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H

; 3515 : 		const auto _Max = max_size();
; 3516 : 		if (_Newsize > _Max)

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	cmp	eax, -2					; fffffffeH
	jbe	SHORT $LN2@Copy

; 3517 : 			{	// too long
; 3518 : 			_Xlen();

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN94@Copy:
$LN2@Copy:

; 3519 : 			}
; 3520 : 
; 3521 : 		auto& _My_data = this->_Get_data();
; 3522 : 		const size_type _Oldres = _My_data._Myres;

	mov	ebx, DWORD PTR [esi+20]

; 3523 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	edi, eax
	or	edi, 15					; 0000000fH
	mov	DWORD PTR __Oldres$[ebp], ebx

; 3524 : 		if (_Max < _Newres)

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN3@Copy

; 3525 : 			{
; 3526 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	edi, eax
	jmp	SHORT $LN8@Copy
$LN3@Copy:

; 3527 : 			}
; 3528 : 		else if (_Oldres / 2 <= _Newres / 3)

	mov	eax, -1431655765			; aaaaaaabH
	mov	ecx, ebx
	mul	edi
	shr	ecx, 1
	shr	edx, 1
	cmp	ecx, edx
	jbe	SHORT $LN8@Copy

; 3529 : 			;
; 3530 : 		else if (_Oldres <= _Max - _Oldres / 2)

	mov	eax, -2					; fffffffeH

; 3531 : 			{
; 3532 : 			_Newres = _Oldres + _Oldres / 2;	// grow exponentially if possible

	lea	edi, DWORD PTR [ecx+ebx]
	sub	eax, ecx
	cmp	ebx, eax
	jbe	SHORT $LN8@Copy

; 3533 : 			}
; 3534 : 		else
; 3535 : 			{
; 3536 : 			_Newres = _Max;	// settle for max_size()

	mov	edi, -2					; fffffffeH
$LN8@Copy:

; 3537 : 			}
; 3538 : 
; 3539 : 		auto& _Al = this->_Getal();
; 3540 : 		pointer _Ptr;
; 3541 : 		_TRY_BEGIN
; 3542 : 			_Ptr = _Al.allocate(_Newres + 1);

	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	push	eax
	mov	ecx, esi
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	ecx, eax
	jmp	SHORT $LN92@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z$0:

; 3543 : 		_CATCH_ALL
; 3544 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	eax, DWORD PTR __Newsize$[ebp]

; 3545 : 			_Ptr = _Al.allocate(_Newres + 1);	// if throws, *this unmodified

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR __Newres$[ebp], eax
	inc	eax
	push	eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR __Ptr$[ebp], eax

; 3546 : 		_CATCH_END

	mov	eax, $LN89@Copy
	ret	0
$LN89@Copy:
	mov	esi, DWORD PTR _this$[ebp]
	mov	ebx, DWORD PTR __Oldres$[ebp]
	mov	edi, DWORD PTR __Newres$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
$LN92@Copy:

; 3551 : 			{	// copy and deallocate old buffer
; 3552 : 			_Traits::copy(_Unfancy(_Ptr), _Unfancy(_My_data._Bx._Ptr), _My_data._Mysize + 1);

	mov	eax, DWORD PTR [esi+16]
	inc	eax
	mov	DWORD PTR __Ptr$1$[ebp], ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3550 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN10@Copy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	DWORD PTR [esi]
	push	ecx
	call	_memcpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3553 : 			_Al.deallocate(_My_data._Bx._Ptr, _Oldres + 1);

	lea	eax, DWORD PTR [ebx+1]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3556 : 		else

	jmp	SHORT $LN93@Copy
$LN10@Copy:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	esi
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN93@Copy:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3563 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3562 : 		_My_data._Myres = _Newres;

	mov	DWORD PTR [esi+20], edi

; 3563 : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN91@Copy:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Size$ = 12						; size = 4
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 3410 : 		{	// trims _Size to the longest it can be assuming a string at/after _Off

	npad	2
	push	ebp
	mov	ebp, esp

; 3411 : 		return (_Min_value(_Size, this->_Mysize() - _Off));

	mov	ecx, DWORD PTR [ecx+16]
	sub	ecx, DWORD PTR __Off$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

	mov	eax, DWORD PTR __Size$[ebp]
	cmp	ecx, eax
	cmovb	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3412 : 		}

	pop	ebp
	ret	8
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::capacity, COMDAT
; _this$ = ecx

; 3053 : 		return (this->_Myres());

	mov	eax, DWORD PTR [ecx+20]

; 3054 : 		}

	ret	0
?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3030 : 		const size_type _Num = this->_Getal().max_size();
; 3031 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	eax, -2					; fffffffeH

; 3032 : 		}

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 3025 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [ecx+16]

; 3026 : 		}

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN13@c_str

; 3003 : 		return (this->_Myptr());

	mov	eax, DWORD PTR [ecx]

; 3004 : 		}

	ret	0
$LN13@c_str:

; 3003 : 		return (this->_Myptr());

	mov	eax, ecx

; 3004 : 		}

	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 2592 : 		{	// erase elements [_Off, _Off + _Count)

	npad	2
	push	ebp
	mov	ebp, esp

; 3630 : 		if (this->_Mysize() < _Off)

	mov	edx, DWORD PTR __Off$[ebp]
	push	ebx
	push	esi

; 2592 : 		{	// erase elements [_Off, _Off + _Count)

	mov	esi, ecx
	push	edi

; 3630 : 		if (this->_Mysize() < _Off)

	mov	edi, DWORD PTR [esi+16]
	cmp	edi, edx
	jb	SHORT $LN95@erase

; 2593 : 		_Check_offset(_Off);
; 2594 : 		if (this->_Mysize() - _Off <= _Count)

	mov	ebx, DWORD PTR __Count$[ebp]
	mov	eax, edi
	sub	eax, edx
	cmp	eax, ebx
	ja	SHORT $LN2@erase

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN38@erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2606 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2607 : 		}

	pop	ebp
	ret	8
$LN38@erase:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2607 : 		}

	pop	ebp
	ret	8
$LN2@erase:

; 2595 : 			{
; 2596 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 2597 : 			}
; 2598 : 		else if (_Count != 0)

	test	ebx, ebx
	je	SHORT $LN92@erase

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN57@erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN58@erase
$LN57@erase:
	mov	eax, esi
$LN58@erase:

; 2599 : 			{	// move elements down
; 2600 : 			value_type *_Ptr = this->_Myptr() + _Off;

	lea	ecx, DWORD PTR [eax+edx]

; 2601 : 			size_type _Newsize = this->_Mysize() - _Count;

	sub	edi, ebx

; 2602 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	eax, edi
	sub	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2602 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	lea	eax, DWORD PTR [ecx+ebx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

	push	eax
	push	ecx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN85@erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2606 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 2607 : 		}

	pop	ebp
	ret	8
$LN85@erase:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN92@erase:
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2606 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2607 : 		}

	pop	ebp
	ret	8
$LN95@erase:

; 3632 : 			_Xran();

	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN97@erase:
$LN94@erase:
	int	3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 2585 : 		{	// erase elements [_Off, ...)

	npad	2
	push	ebp
	mov	ebp, esp

; 3630 : 		if (this->_Mysize() < _Off)

	mov	eax, DWORD PTR __Off$[ebp]
	cmp	DWORD PTR [ecx+16], eax
	jb	SHORT $LN36@erase

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN26@erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2588 : 		return (*this);

	mov	eax, ecx

; 2589 : 		}

	pop	ebp
	ret	4
$LN26@erase:

; 1614 : 		return (_Large_string_engaged()

	mov	edx, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2588 : 		return (*this);

	mov	eax, ecx

; 2589 : 		}

	pop	ebp
	ret	4
$LN36@erase:

; 3632 : 			_Xran();

	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN38@erase:
$LN35@erase:
	int	3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z
_TEXT	SEGMENT
tv785 = -4						; size = 4
__Off$ = 8						; size = 4
tv786 = 12						; size = 4
tv784 = 12						; size = 4
__Right$ = 12						; size = 4
__Roff$ = 16						; size = 4
__Count$ = 20						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 2461 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 3630 : 		if (this->_Mysize() < _Off)

	mov	ecx, DWORD PTR [esi+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jb	$LN239@insert
	mov	edi, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Roff$[ebp]
	mov	eax, DWORD PTR [edi+16]
	cmp	eax, edx
	jb	$LN241@insert

; 3411 : 		return (_Min_value(_Size, this->_Mysize() - _Off));

	sub	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

	mov	edx, DWORD PTR __Count$[ebp]
	cmp	eax, edx
	cmovb	edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2465 : 		if (npos - this->_Mysize() <= _Count)

	mov	eax, ecx
	not	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

	mov	DWORD PTR __Count$[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2465 : 		if (npos - this->_Mysize() <= _Count)

	cmp	eax, edx
	jbe	$LN242@insert

; 2468 : 			}
; 2469 : 
; 2470 : 		const size_type _Num = this->_Mysize() + _Count;

	lea	ebx, DWORD PTR [ecx+edx]

; 2471 : 		if (_Count != 0 && _Grow(_Num))

	test	edx, edx
	je	$LN234@insert

; 3573 : 		if (_Newsize == 0)

	test	ebx, ebx
	jne	SHORT $LN66@insert

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ebx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN79@insert
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax], bl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2488 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2489 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN79@insert:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2489 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN66@insert:

; 3579 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], ebx
	jae	SHORT $LN67@insert

; 3580 : 			{	// reallocate to grow
; 3581 : 			_Copy(_Newsize);

	push	ebx
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	edx, DWORD PTR __Count$[ebp]
$LN67@insert:

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN116@insert
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR tv786[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN117@insert
$LN116@insert:
	mov	DWORD PTR tv786[ebp], esi
$LN117@insert:

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	eax, 16					; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN132@insert
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR tv785[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN133@insert
$LN132@insert:
	mov	DWORD PTR tv785[ebp], esi
$LN133@insert:

; 2473 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	ecx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR [esi+16]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2473 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR tv786[ebp]
	add	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2473 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR tv785[ebp]
	add	eax, ecx
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2476 : 			if (this == _STD addressof(_Right))

	cmp	esi, edi
	jne	SHORT $LN4@insert

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN154@insert
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR tv784[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN155@insert
$LN154@insert:
	mov	DWORD PTR tv784[ebp], esi
$LN155@insert:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

	mov	edx, DWORD PTR __Off$[ebp]
	lea	edi, DWORD PTR __Roff$[ebp]
	cmp	DWORD PTR __Roff$[ebp], edx
	lea	ecx, DWORD PTR __Off$[ebp]
	cmovae	edi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	eax, 16					; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN173@insert
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN174@insert
$LN173@insert:
	mov	ecx, esi
$LN174@insert:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

	push	DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2478 : 				_Traits::move(this->_Myptr() + _Off, this->_Myptr() + _Min_value(_Off, _Roff), _Count);	// substring

	mov	eax, DWORD PTR [edi]
	add	eax, DWORD PTR tv784[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2478 : 				_Traits::move(this->_Myptr() + _Off, this->_Myptr() + _Min_value(_Off, _Roff), _Count);	// substring

	lea	eax, DWORD PTR [ecx+edx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

	push	eax
	call	DWORD PTR __imp__memmove
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2480 : 			else

	jmp	SHORT $LN238@insert
$LN4@insert:

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [edi+20], 16			; 00000010H

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN192@insert
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edi, DWORD PTR [edi]
$LN192@insert:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN208@insert
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN209@insert
$LN208@insert:
	mov	ecx, esi
$LN209@insert:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2482 : 				_Traits::copy(this->_Myptr() + _Off, _Right._Myptr() + _Roff, _Count);	// fill hole

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2482 : 				_Traits::copy(this->_Myptr() + _Off, _Right._Myptr() + _Roff, _Count);	// fill hole

	mov	eax, DWORD PTR __Off$[ebp]
	add	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	call	_memcpy
$LN238@insert:
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ebx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN227@insert
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+ebx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2488 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2489 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN227@insert:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+ebx], 0
$LN234@insert:
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2488 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2489 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN239@insert:

; 3632 : 			_Xran();

	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN243@insert:
$LN241@insert:
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN244@insert:
$LN242@insert:

; 2466 : 			{
; 2467 : 			_Xlen();	// result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN245@insert:
$LN237@insert:
	int	3
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Right$ = 12						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 2456 : 		{	// insert _Right at _Off

	npad	2
	push	ebp
	mov	ebp, esp

; 2457 : 		return (insert(_Off, _Right, 0, npos));

	push	-1
	push	0
	push	DWORD PTR __Right$[ebp]
	push	DWORD PTR __Off$[ebp]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 2458 : 		}

	pop	ebp
	ret	8
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2428 : 		{	// assign [_Ptr, <null>)

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, edx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2428 : 		{	// assign [_Ptr, <null>)

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

	lea	edi, DWORD PTR [eax+1]
$LL6@assign:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL6@assign
	sub	eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, esi
	push	eax
	push	edx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	pop	esi

; 2430 : 		}

	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2412 : 		{	// assign [_Ptr, _Ptr + _Count)

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	esi, ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN17@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	jmp	SHORT $LN18@assign
$LN17@assign:
	mov	edx, esi
$LN18@assign:

; 3591 : 		return (_My_chars <= _Ptr && _Ptr < _My_chars + _My_data._Mysize);

	mov	ebx, DWORD PTR __Ptr$[ebp]
	cmp	edx, ebx
	ja	SHORT $LN2@assign
	mov	eax, DWORD PTR [esi+16]
	add	eax, edx
	cmp	ebx, eax
	jae	SHORT $LN2@assign

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	ecx, 16					; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN33@assign

; 2415 : 			return (assign(*this, _Ptr - this->_Myptr(), _Count));	// substring

	push	DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2415 : 			return (assign(*this, _Ptr - this->_Myptr(), _Count));	// substring

	mov	ecx, esi
	sub	ebx, eax
	push	ebx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi
	pop	ebx

; 2425 : 		}

	pop	ebp
	ret	8
$LN33@assign:

; 2415 : 			return (assign(*this, _Ptr - this->_Myptr(), _Count));	// substring

	push	DWORD PTR __Count$[ebp]

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi

; 2415 : 			return (assign(*this, _Ptr - this->_Myptr(), _Count));	// substring

	mov	ecx, esi
	sub	ebx, eax
	push	ebx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi
	pop	ebx

; 2425 : 		}

	pop	ebp
	ret	8
$LN2@assign:
	push	edi

; 3573 : 		if (_Newsize == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	jne	SHORT $LN40@assign

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	ecx, 16					; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN53@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2424 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2425 : 		}

	pop	ebp
	ret	8
$LN53@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2425 : 		}

	pop	ebp
	ret	8
$LN40@assign:

; 3579 : 		if (this->_Myres() < _Newsize)

	cmp	ecx, edi
	jae	SHORT $LN41@assign

; 3580 : 			{	// reallocate to grow
; 3581 : 			_Copy(_Newsize);

	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
$LN41@assign:

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN81@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN82@assign
$LN81@assign:
	mov	eax, esi
$LN82@assign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	edi
	push	ebx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN100@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2424 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 2425 : 		}

	pop	ebp
	ret	8
$LN100@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2425 : 		}

	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2378 : 		{	// assign _Right [_Roff, _Roff + _Count)

	npad	2
	push	ebp
	mov	ebp, esp

; 3630 : 		if (this->_Mysize() < _Off)

	mov	eax, DWORD PTR __Roff$[ebp]
	push	ebx
	mov	ebx, DWORD PTR __Right$[ebp]
	push	esi

; 2378 : 		{	// assign _Right [_Roff, _Roff + _Count)

	mov	esi, ecx
	push	edi

; 3630 : 		if (this->_Mysize() < _Off)

	mov	ecx, DWORD PTR [ebx+16]
	cmp	ecx, eax
	jb	$LN159@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

	mov	edi, DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3411 : 		return (_Min_value(_Size, this->_Mysize() - _Off));

	sub	ecx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

	cmp	ecx, edi
	cmovb	edi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2382 : 		if (this == _STD addressof(_Right))

	cmp	esi, ebx
	jne	SHORT $LN2@assign

; 2383 : 			{	// substring
; 2384 : 			erase(_Roff + _Count);

	lea	ecx, DWORD PTR [eax+edi]

; 3630 : 		if (this->_Mysize() < _Off)

	cmp	DWORD PTR [esi+16], ecx
	jb	$LN161@assign

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN62@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2385 : 			erase(0, _Roff);

	push	eax
	push	0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [edx+ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2385 : 			erase(0, _Roff);

	mov	ecx, esi
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi

; 2393 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN62@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	edx, esi

; 2385 : 			erase(0, _Roff);

	push	eax
	push	0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [edx+ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2385 : 			erase(0, _Roff);

	mov	ecx, esi
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi

; 2393 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN2@assign:

; 3573 : 		if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN72@assign

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN85@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2393 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN85@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN72@assign:

; 3579 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN73@assign

; 3580 : 			{	// reallocate to grow
; 3581 : 			_Copy(_Newsize);

	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	eax, DWORD PTR __Roff$[ebp]
$LN73@assign:

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ebx+20], 16			; 00000010H

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN113@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ebx, DWORD PTR [ebx]
$LN113@assign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN129@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN130@assign
$LN129@assign:
	mov	ecx, esi
$LN130@assign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2389 : 			_Traits::copy(this->_Myptr(), _Right._Myptr() + _Roff, _Count);

	add	eax, ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN148@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2393 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN148@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN159@assign:

; 3632 : 			_Xran();

	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN162@assign:
$LN161@assign:
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN163@assign:
$LN158@assign:
	int	3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
tv502 = 16						; size = 4
__Count$ = 16						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2288 : 		{	// append _Right [_Roff, _Roff + _Count)

	npad	2
	push	ebp
	mov	ebp, esp

; 3630 : 		if (this->_Mysize() < _Off)

	mov	edx, DWORD PTR __Roff$[ebp]
	push	ebx
	mov	ebx, DWORD PTR __Right$[ebp]
	push	esi
	push	edi

; 2288 : 		{	// append _Right [_Roff, _Roff + _Count)

	mov	esi, ecx

; 3630 : 		if (this->_Mysize() < _Off)

	mov	eax, DWORD PTR [ebx+16]
	cmp	eax, edx
	jb	$LN148@append
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

	mov	ecx, DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3411 : 		return (_Min_value(_Size, this->_Mysize() - _Off));

	sub	eax, edx

; 2291 : 		if (npos - this->_Mysize() <= _Count)

	mov	edi, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

	cmp	eax, ecx
	cmovb	ecx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2291 : 		if (npos - this->_Mysize() <= _Count)

	mov	eax, edi
	not	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

	mov	DWORD PTR __Count$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2291 : 		if (npos - this->_Mysize() <= _Count)

	cmp	eax, ecx
	jbe	$LN150@append

; 2294 : 			}
; 2295 : 
; 2296 : 		const size_type _Num = this->_Mysize() + _Count;

	add	edi, ecx

; 2297 : 		if (_Count != 0 && _Grow(_Num))

	test	ecx, ecx
	je	$LN144@append

; 3573 : 		if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN52@append

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN65@append
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2302 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2303 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN65@append:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2303 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN52@append:

; 3579 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN53@append

; 3580 : 			{	// reallocate to grow
; 3581 : 			_Copy(_Newsize);

	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Roff$[ebp]
$LN53@append:

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ebx+20], 16			; 00000010H

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN93@append
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ebx, DWORD PTR [ebx]
$LN93@append:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN109@append
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR tv502[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN110@append
$LN109@append:
	mov	DWORD PTR tv502[ebp], esi
$LN110@append:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2299 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Right._Myptr() + _Roff, _Count);

	lea	eax, DWORD PTR [ebx+edx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2299 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Right._Myptr() + _Roff, _Count);

	mov	eax, DWORD PTR [esi+16]
	add	eax, DWORD PTR tv502[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN137@append
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2302 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 2303 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN137@append:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN144@append:
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2302 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2303 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN148@append:

; 3632 : 			_Xran();

	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN151@append:
$LN150@append:

; 2292 : 			{
; 2293 : 			_Xlen();	// result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN152@append:
$LN147@append:
	int	3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2283 : 		{	// append _Right

	npad	2
	push	ebp
	mov	ebp, esp

; 2284 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	DWORD PTR __Right$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2285 : 		}

	pop	ebp
	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2215 : 		{	// destroy the string

	npad	2
	push	esi
	mov	esi, ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN4@basic_stri
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN4@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2217 : 		}

	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal, COMDAT
; _this$ = ecx

; 2122 : 		{	// assign by stealing _Right's buffer, memcpy optimization

	npad	2
	push	ebp
	mov	ebp, esp

; 2123 : 			// pre: this != &_Right
; 2124 : 			// pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2125 : 			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2126 : 		auto& _Right_data = _Right._Get_data();
; 2127 : 
; 2128 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2129 : 		if (_Right_data._Large_string_engaged())
; 2130 : 			{	// take ownership of _Right's iterators along with its buffer
; 2131 : 			this->_Swap_all(_Right);
; 2132 : 			}
; 2133 : 		else
; 2134 : 			{
; 2135 : 			_Right._Orphan_all();
; 2136 : 			}
; 2137 : #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 2138 : 
; 2139 : 		const auto _My_data_mem = reinterpret_cast<unsigned char *>(_STD addressof(this->_Get_data()))
; 2140 : 			+ _Memcpy_move_offset;
; 2141 : 		const auto _Right_data_mem = reinterpret_cast<unsigned char *>(_STD addressof(_Right_data))
; 2142 : 			+ _Memcpy_move_offset;
; 2143 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	mov	eax, DWORD PTR __Right$[ebp]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2145 : 		}

	pop	ebp
	ret	8
?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2054 : 		{	// construct by moving _Right

	npad	2
	push	ebp
	mov	ebp, esp

; 2143 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	mov	eax, DWORD PTR __Right$[ebp]

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 1596 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 2143 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [eax+16]
	movq	QWORD PTR [ecx+16], xmm0

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [eax+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2056 : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1980 : 		{	// construct from [_Ptr, <null>)

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, edx
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1980 : 		{	// construct from [_Ptr, <null>)

	mov	esi, ecx
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

	lea	edi, DWORD PTR [eax+1]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
$LL25@basic_stri:

; 480  : 		return (_CSTD strlen(_First));

	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL25@basic_stri
	sub	eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2429 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, esi
	push	eax
	push	edx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi

; 1981 : 		_Tidy_init();
; 1982 : 		assign(_Ptr);
; 1983 : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx
	ret	0
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 343  : 		return (_Myval2);

	mov	eax, ecx

; 344  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 338  : 		return (_Myval2);

	mov	eax, ecx

; 339  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 323  : 		return (*this);

	mov	eax, ecx

; 324  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 318  : 		return (*this);

	mov	eax, ecx

; 319  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres, COMDAT
; _this$ = ecx

; 1854 : 		return (_Get_data()._Myres);

	lea	eax, DWORD PTR [ecx+20]

; 1855 : 		}

	ret	0
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres, COMDAT
; _this$ = ecx

; 1849 : 		return (_Get_data()._Myres);

	lea	eax, DWORD PTR [ecx+20]

; 1850 : 		}

	ret	0
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 1844 : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 1845 : 		}

	ret	0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 1839 : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 1840 : 		}

	ret	0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 1834 : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 1835 : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 1829 : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 1830 : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 1824 : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 1825 : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 1819 : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 1820 : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 1809 : 		_Get_data()._Orphan_all();
; 1810 : 		}

	ret	0
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 1697 : 		}

	mov	eax, ecx

; 1596 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 1697 : 		}

	ret	0
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN11@Myptr

; 1690 : 		return (_Get_data()._Myptr());

	mov	eax, DWORD PTR [ecx]

; 1691 : 		}

	ret	0
$LN11@Myptr:

; 1690 : 		return (_Get_data()._Myptr());

	mov	eax, ecx

; 1691 : 		}

	ret	0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN11@Myptr

; 1685 : 		return (_Get_data()._Myptr());

	mov	eax, DWORD PTR [ecx]

; 1686 : 		}

	ret	0
$LN11@Myptr:

; 1685 : 		return (_Get_data()._Myptr());

	mov	eax, ecx

; 1686 : 		}

	ret	0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 1639 : 			}

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 1634 : 			{	// user-provided, for fancy pointers
; 1635 : 			}

	mov	eax, ecx
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 1627 : 		{	// returns whether the large string mode (allocated memory) is engaged

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	setae	al

; 1628 : 		return (this->_BUF_SIZE <= _Myres);
; 1629 : 		}

	ret	0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx]

; 1622 : 			? _Unfancy(_Bx._Ptr)
; 1623 : 			: _Bx._Buf);
; 1624 : 		}

	ret	0
$LN3@Myptr:

; 1621 : 		return (_Large_string_engaged()

	mov	eax, ecx

; 1622 : 			? _Unfancy(_Bx._Ptr)
; 1623 : 			: _Bx._Buf);
; 1624 : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx]

; 1615 : 			? _Unfancy(_Bx._Ptr)
; 1616 : 			: _Bx._Buf);
; 1617 : 		}

	ret	0
$LN3@Myptr:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, ecx

; 1615 : 			? _Unfancy(_Bx._Ptr)
; 1616 : 			: _Bx._Buf);
; 1617 : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 1598 : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+20], 0
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1108 : 		return (_Mytraits::max_size(*this));

	or	eax, -1

; 1109 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 1087 : 		{	// deallocate object at _Ptr, ignore size

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 1088 : 		_Mybase::deallocate(_Ptr, _Count);
; 1089 : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 1076 : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 53   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN6@allocate
$LN15@allocate:

; 1077 : 		return (_Mybase::allocate(_Count));
; 1078 : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN8@allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN10@allocate

; 69   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN18@allocate:
$LN10@allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN11@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN19@allocate:
$LN11@allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 1077 : 		return (_Mybase::allocate(_Count));
; 1078 : 		}

	pop	ebp
	ret	4
$LN8@allocate:

; 87   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN15@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN20@allocate:
$LN17@allocate:
	int	3
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 1048 : 		}

	mov	eax, ecx
	ret	4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 1038 : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 970  : 		return (_Al.max_size());

	or	eax, -1

; 971  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 851  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 852  : 		}

	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 827  : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 53   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 69   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN8@allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN9@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN16@allocate:
$LN9@allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 87   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@allocate:
$LN14@allocate:
	int	3
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 822  : 		{	// deallocate object at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 824  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 807  : 		{	// construct by copying (do nothing)
; 808  : 		}

	mov	eax, ecx
	ret	4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 803  : 		{	// construct default allocator (do nothing)
; 804  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 96   : 	{	// deallocate storage for _Count elements of size _Sz

	npad	2
	push	ebp
	mov	ebp, esp

; 97   :  #if defined(_M_IX86) || defined(_M_X64)
; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	or	eax, -1
	mov	ecx, DWORD PTR __Count$[ebp]
	xor	edx, edx
	div	DWORD PTR __Sz$[ebp]
	cmp	ecx, eax
	jbe	SHORT $LN2@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2@Deallocate:

; 99   : 	const size_t _User_size = _Count * _Sz;

	imul	ecx, DWORD PTR __Sz$[ebp]

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN9@Deallocate

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	al, 31					; 0000001fH
	je	SHORT $LN4@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4@Deallocate:

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	ecx, DWORD PTR [eax-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	ecx, eax
	jb	SHORT $LN5@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN5@Deallocate:

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	eax, ecx
	cmp	eax, 4
	jae	SHORT $LN6@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN6@Deallocate:

; 126  : 			<= _Ptr_user - _Ptr_container);
; 127  :  #endif /* _DEBUG */
; 128  : 
; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	eax, 35					; 00000023H
	jbe	SHORT $LN3@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 130  : 			<= _NON_USER_SIZE);
; 131  : 
; 132  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 133  : 		}
; 134  : 
; 135  :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 136  : 	static_cast<void>(_Count);
; 137  : 	static_cast<void>(_Sz);
; 138  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 139  : 
; 140  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 	}

	pop	ebp
	ret	0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 50   : 	{	// allocate storage for _Count elements of size _Sz

	npad	2
	push	ebp
	mov	ebp, esp

; 51   : 	void *_Ptr = 0;
; 52   : 
; 53   : 	if (_Count == 0)

	mov	ecx, DWORD PTR __Count$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@Allocate

; 54   : 		return (_Ptr);

	xor	eax, eax
$LN1@Allocate:

; 89   : 		}
; 90   : 	return (_Ptr);
; 91   : 	}

	pop	ebp
	ret	0
$LN2@Allocate:

; 55   : 
; 56   : 	// check overflow of multiply
; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Sz$[ebp]
	cmp	eax, ecx
	jae	SHORT $LN3@Allocate

; 58   : 		_Xbad_alloc();	// report no memory

	jmp	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN3@Allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	imul	ecx, DWORD PTR __Sz$[ebp]

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	BYTE PTR __Try_aligned_allocation$[ebp], 0
	je	SHORT $LN4@Allocate
	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN4@Allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	eax, DWORD PTR [ecx+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	eax, ecx
	ja	SHORT $LN6@Allocate

; 69   : 			_Xbad_alloc();	// report no memory

	jmp	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN6@Allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	eax
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN7@Allocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN7@Allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 89   : 		}
; 90   : 	return (_Ptr);
; 91   : 	}

	pop	ebp
	ret	0
$LN4@Allocate:

; 76   : 
; 77   :  #ifdef _DEBUG
; 78   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 79   :  #endif /* _DEBUG */
; 80   : 		}
; 81   : 	else
; 82   :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 83   : 	static_cast<void>(_Try_aligned_allocation);
; 84   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 85   : 
; 86   : 		{	// allocate normal block
; 87   : 		_Ptr = ::operator new(_User_size);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN1@Allocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits
;	COMDAT ?quiet_NaN@?$numeric_limits@M@std@@SAMXZ
_TEXT	SEGMENT
?quiet_NaN@?$numeric_limits@M@std@@SAMXZ PROC		; std::numeric_limits<float>::quiet_NaN, COMDAT

; 1119 : 		return (__builtin_nanf("0"));

	fld	DWORD PTR __real@7fc00000

; 1120 : 		}

	ret	0
?quiet_NaN@?$numeric_limits@M@std@@SAMXZ ENDP		; std::numeric_limits<float>::quiet_NaN
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits
;	COMDAT ?max@?$numeric_limits@I@std@@SAIXZ
_TEXT	SEGMENT
?max@?$numeric_limits@I@std@@SAIXZ PROC			; std::numeric_limits<unsigned int>::max, COMDAT

; 741  : 		return (UINT_MAX);

	or	eax, -1

; 742  : 		}

	ret	0
?max@?$numeric_limits@I@std@@SAIXZ ENDP			; std::numeric_limits<unsigned int>::max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xxatomic
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xxatomic
;	COMDAT ?atomic_store@std@@YAXPAU_Atomic_ullong@1@_K@Z
_TEXT	SEGMENT
__Atom$ = 8						; size = 4
__Value$ = 12						; size = 8
?atomic_store@std@@YAXPAU_Atomic_ullong@1@_K@Z PROC	; std::atomic_store, COMDAT

; 518  : 	{	// store _Value into *_Atom

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xatomic.h

; 1818 : 			_Store_seq_cst_8(_Tgt, _Value);

	push	DWORD PTR __Value$[ebp+4]
	push	DWORD PTR __Value$[ebp]
	push	DWORD PTR __Atom$[ebp]
	call	?_Store_seq_cst_8@std@@YAXPC_K_K@Z	; std::_Store_seq_cst_8
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xxatomic

; 520  : 	}

	pop	ebp
	ret	0
?atomic_store@std@@YAXPAU_Atomic_ullong@1@_K@Z ENDP	; std::atomic_store
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xxatomic
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xxatomic
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xxatomic
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xxatomic
;	COMDAT ?atomic_store_explicit@std@@YAXPAU_Atomic_ullong@1@_KW4memory_order@1@@Z
_TEXT	SEGMENT
__Atom$ = 8						; size = 4
__Value$ = 12						; size = 8
__Order$ = 20						; size = 4
?atomic_store_explicit@std@@YAXPAU_Atomic_ullong@1@_KW4memory_order@1@@Z PROC ; std::atomic_store_explicit, COMDAT

; 506  : 	{	// store _Value into *_Atom

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xatomic.h

; 1807 : 	switch (_Order)

	mov	eax, DWORD PTR __Order$[ebp]
	sub	eax, 0
	je	SHORT $LN6@atomic_sto
	sub	eax, 3
	je	SHORT $LN7@atomic_sto
	sub	eax, 2
	jne	SHORT $LN9@atomic_sto

; 1815 : 			break;
; 1816 : 
; 1817 : 		case memory_order_seq_cst:
; 1818 : 			_Store_seq_cst_8(_Tgt, _Value);

	push	DWORD PTR __Value$[ebp+4]
	push	DWORD PTR __Value$[ebp]
	push	DWORD PTR __Atom$[ebp]
	call	?_Store_seq_cst_8@std@@YAXPC_K_K@Z	; std::_Store_seq_cst_8
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xxatomic

; 508  : 	}

	pop	ebp
	ret	0
$LN7@atomic_sto:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xatomic.h

; 1814 : 			_Store_release_8(_Tgt, _Value);

	push	DWORD PTR __Value$[ebp+4]
	push	DWORD PTR __Value$[ebp]
	push	DWORD PTR __Atom$[ebp]
	call	?_Store_release_8@std@@YAXPC_K_K@Z	; std::_Store_release_8
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xxatomic

; 508  : 	}

	pop	ebp
	ret	0
$LN6@atomic_sto:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xatomic.h

; 1810 : 			_Store_relaxed_8(_Tgt, _Value);

	push	DWORD PTR __Value$[ebp+4]
	push	DWORD PTR __Value$[ebp]
	push	DWORD PTR __Atom$[ebp]
	call	?_Store_relaxed_8@std@@YAXPC_K_K@Z	; std::_Store_relaxed_8
	add	esp, 12					; 0000000cH
$LN9@atomic_sto:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xxatomic

; 508  : 	}

	pop	ebp
	ret	0
?atomic_store_explicit@std@@YAXPAU_Atomic_ullong@1@_KW4memory_order@1@@Z ENDP ; std::atomic_store_explicit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xxatomic
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xxatomic
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xxatomic
;	COMDAT ??4?$atomic@_K@std@@QAE_K_K@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 8
??4?$atomic@_K@std@@QAE_K_K@Z PROC			; std::atomic<unsigned __int64>::operator=, COMDAT
; _this$ = ecx

; 196  : 		{	// assign from _Val

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xatomic.h

; 1818 : 			_Store_seq_cst_8(_Tgt, _Value);

	push	DWORD PTR __Val$[ebp+4]
	push	DWORD PTR __Val$[ebp]
	push	ecx
	call	?_Store_seq_cst_8@std@@YAXPC_K_K@Z	; std::_Store_seq_cst_8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xxatomic

; 197  : 		return (_ATOMIC_ITYPE::operator=(_Val));

	mov	eax, DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xatomic.h

; 1818 : 			_Store_seq_cst_8(_Tgt, _Value);

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xxatomic

; 197  : 		return (_ATOMIC_ITYPE::operator=(_Val));

	mov	edx, DWORD PTR __Val$[ebp+4]

; 198  : 		}

	pop	ebp
	ret	8
??4?$atomic@_K@std@@QAE_K_K@Z ENDP			; std::atomic<unsigned __int64>::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xxatomic
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xxatomic
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xatomic.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xxatomic
;	COMDAT ??4_Atomic_ullong@std@@QAE_K_K@Z
_TEXT	SEGMENT
__Value$ = 8						; size = 8
??4_Atomic_ullong@std@@QAE_K_K@Z PROC			; std::_Atomic_ullong::operator=, COMDAT
; _this$ = ecx

; 642  : 	{	// assign _Value to *this

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xatomic.h

; 1818 : 			_Store_seq_cst_8(_Tgt, _Value);

	push	DWORD PTR __Value$[ebp+4]
	push	DWORD PTR __Value$[ebp]
	push	ecx
	call	?_Store_seq_cst_8@std@@YAXPC_K_K@Z	; std::_Store_seq_cst_8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xxatomic

; 644  : 	return (_Value);

	mov	eax, DWORD PTR __Value$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xatomic.h

; 1818 : 			_Store_seq_cst_8(_Tgt, _Value);

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xxatomic

; 644  : 	return (_Value);

	mov	edx, DWORD PTR __Value$[ebp+4]

; 645  : 	}

	pop	ebp
	ret	8
??4_Atomic_ullong@std@@QAE_K_K@Z ENDP			; std::_Atomic_ullong::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xatomic.h
;	COMDAT ?_Atomic_store_8@std@@YAXPC_K_KW4memory_order@1@@Z
_TEXT	SEGMENT
__Tgt$ = 8						; size = 4
__Value$ = 12						; size = 8
__Order$ = 20						; size = 4
?_Atomic_store_8@std@@YAXPC_K_KW4memory_order@1@@Z PROC	; std::_Atomic_store_8, COMDAT

; 1806 : 	{	/* store _Value atomically */

	npad	2
	push	ebp
	mov	ebp, esp

; 1807 : 	switch (_Order)

	mov	eax, DWORD PTR __Order$[ebp]
	sub	eax, 0
	je	SHORT $LN4@Atomic_sto
	sub	eax, 3
	je	SHORT $LN5@Atomic_sto
	sub	eax, 2
	jne	SHORT $LN7@Atomic_sto

; 1815 : 			break;
; 1816 : 
; 1817 : 		case memory_order_seq_cst:
; 1818 : 			_Store_seq_cst_8(_Tgt, _Value);

	push	DWORD PTR __Value$[ebp+4]
	push	DWORD PTR __Value$[ebp]
	push	DWORD PTR __Tgt$[ebp]
	call	?_Store_seq_cst_8@std@@YAXPC_K_K@Z	; std::_Store_seq_cst_8
	add	esp, 12					; 0000000cH

; 1819 : 			break;
; 1820 : 
; 1821 : 		default:
; 1822 : 			_INVALID_MEMORY_ORDER;
; 1823 : 			break;
; 1824 : 		}
; 1825 : 	}

	pop	ebp
	ret	0
$LN5@Atomic_sto:

; 1811 : 			break;
; 1812 : 
; 1813 : 		case memory_order_release:
; 1814 : 			_Store_release_8(_Tgt, _Value);

	push	DWORD PTR __Value$[ebp+4]
	push	DWORD PTR __Value$[ebp]
	push	DWORD PTR __Tgt$[ebp]
	call	?_Store_release_8@std@@YAXPC_K_K@Z	; std::_Store_release_8
	add	esp, 12					; 0000000cH

; 1819 : 			break;
; 1820 : 
; 1821 : 		default:
; 1822 : 			_INVALID_MEMORY_ORDER;
; 1823 : 			break;
; 1824 : 		}
; 1825 : 	}

	pop	ebp
	ret	0
$LN4@Atomic_sto:

; 1808 : 		{
; 1809 : 		case memory_order_relaxed:
; 1810 : 			_Store_relaxed_8(_Tgt, _Value);

	push	DWORD PTR __Value$[ebp+4]
	push	DWORD PTR __Value$[ebp]
	push	DWORD PTR __Tgt$[ebp]
	call	?_Store_relaxed_8@std@@YAXPC_K_K@Z	; std::_Store_relaxed_8
	add	esp, 12					; 0000000cH
$LN7@Atomic_sto:

; 1819 : 			break;
; 1820 : 
; 1821 : 		default:
; 1822 : 			_INVALID_MEMORY_ORDER;
; 1823 : 			break;
; 1824 : 		}
; 1825 : 	}

	pop	ebp
	ret	0
?_Atomic_store_8@std@@YAXPC_K_KW4memory_order@1@@Z ENDP	; std::_Atomic_store_8
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xatomic.h
;	COMDAT ?_Store_seq_cst_8@std@@YAXPC_K_K@Z
_TEXT	SEGMENT
__Oldval$2$ = -4					; size = 4
__Tgt$ = 8						; size = 4
__Value$ = 12						; size = 8
?_Store_seq_cst_8@std@@YAXPC_K_K@Z PROC			; std::_Store_seq_cst_8, COMDAT

; 1791 : 	{	/* store _Value atomically with

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 67   : 	_Compiler_barrier();

	mov	ecx, DWORD PTR __Value$[ebp+4]
	push	ebx
	push	esi
	push	edi
	npad	4
$LL6@Store_seq_:

; 68   : 	do
; 69   : 		{
; 70   : 		_Oldval = *_Tgt;

	mov	eax, DWORD PTR __Tgt$[ebp]
	mov	edi, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]

; 71   : 		} while (_Oldval != _InterlockedCompareExchange64(_Tgt, _Value, _Oldval));

	mov	eax, edi
	mov	DWORD PTR __Oldval$2$[ebp], esi
	mov	edx, esi
	mov	ebx, DWORD PTR __Value$[ebp]
	mov	esi, DWORD PTR __Tgt$[ebp]
	lock	 cmpxchg8b QWORD PTR [esi]
	mov	esi, DWORD PTR __Oldval$2$[ebp]
	cmp	edi, eax
	jne	SHORT $LL6@Store_seq_
	cmp	esi, edx
	jne	SHORT $LL6@Store_seq_
	pop	edi
	pop	esi
	pop	ebx

; 1792 : 			sequentially consistent memory order */
; 1793 : 
; 1794 :  #if defined(_M_ARM64)
; 1795 : 	_Memory_barrier();
; 1796 : 	__iso_volatile_store64((volatile long long *)_Tgt, _Value);
; 1797 : 	_Memory_barrier();
; 1798 : 
; 1799 :  #else
; 1800 : 	_INTRIN_SEQ_CST(_InterlockedExchange64)((volatile long long *)_Tgt, _Value);
; 1801 :  #endif
; 1802 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Store_seq_cst_8@std@@YAXPC_K_K@Z ENDP			; std::_Store_seq_cst_8
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xatomic.h
;	COMDAT ?_Store_release_8@std@@YAXPC_K_K@Z
_TEXT	SEGMENT
__Oldval$2$ = -4					; size = 4
__Tgt$ = 8						; size = 4
__Value$ = 12						; size = 8
?_Store_release_8@std@@YAXPC_K_K@Z PROC			; std::_Store_release_8, COMDAT

; 1775 : 	{	/* store _Value atomically with release memory order */

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 67   : 	_Compiler_barrier();

	mov	ecx, DWORD PTR __Value$[ebp+4]
	push	ebx
	push	esi
	push	edi
	npad	4
$LL6@Store_rele:

; 68   : 	do
; 69   : 		{
; 70   : 		_Oldval = *_Tgt;

	mov	eax, DWORD PTR __Tgt$[ebp]
	mov	edi, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]

; 71   : 		} while (_Oldval != _InterlockedCompareExchange64(_Tgt, _Value, _Oldval));

	mov	eax, edi
	mov	DWORD PTR __Oldval$2$[ebp], esi
	mov	edx, esi
	mov	ebx, DWORD PTR __Value$[ebp]
	mov	esi, DWORD PTR __Tgt$[ebp]
	lock	 cmpxchg8b QWORD PTR [esi]
	mov	esi, DWORD PTR __Oldval$2$[ebp]
	cmp	edi, eax
	jne	SHORT $LL6@Store_rele
	cmp	esi, edx
	jne	SHORT $LL6@Store_rele
	pop	edi
	pop	esi
	pop	ebx

; 1776 : 
; 1777 :  #if defined(_M_X64)
; 1778 : 	_Compiler_barrier();
; 1779 : 	*_Tgt = _Value;
; 1780 : 
; 1781 :  #elif defined(_M_ARM64)
; 1782 : 	_Memory_barrier();
; 1783 : 	__iso_volatile_store64((volatile long long *)_Tgt, _Value);
; 1784 : 
; 1785 :  #else
; 1786 : 	_INTRIN_RELEASE(_InterlockedExchange64)((volatile long long *)_Tgt, _Value);
; 1787 :  #endif
; 1788 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Store_release_8@std@@YAXPC_K_K@Z ENDP			; std::_Store_release_8
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xatomic.h
;	COMDAT ?_Store_relaxed_8@std@@YAXPC_K_K@Z
_TEXT	SEGMENT
__Oldval$2$ = -4					; size = 4
__Tgt$ = 8						; size = 4
__Value$ = 12						; size = 8
?_Store_relaxed_8@std@@YAXPC_K_K@Z PROC			; std::_Store_relaxed_8, COMDAT

; 1761 : 	{	/* store _Value atomically with relaxed memory order */

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 67   : 	_Compiler_barrier();

	mov	ecx, DWORD PTR __Value$[ebp+4]
	push	ebx
	push	esi
	push	edi
	npad	4
$LL6@Store_rela:

; 68   : 	do
; 69   : 		{
; 70   : 		_Oldval = *_Tgt;

	mov	eax, DWORD PTR __Tgt$[ebp]
	mov	edi, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]

; 71   : 		} while (_Oldval != _InterlockedCompareExchange64(_Tgt, _Value, _Oldval));

	mov	eax, edi
	mov	DWORD PTR __Oldval$2$[ebp], esi
	mov	edx, esi
	mov	ebx, DWORD PTR __Value$[ebp]
	mov	esi, DWORD PTR __Tgt$[ebp]
	lock	 cmpxchg8b QWORD PTR [esi]
	mov	esi, DWORD PTR __Oldval$2$[ebp]
	cmp	edi, eax
	jne	SHORT $LL6@Store_rela
	cmp	esi, edx
	jne	SHORT $LL6@Store_rela
	pop	edi
	pop	esi
	pop	ebx

; 1762 : 
; 1763 :  #if defined(_M_X64)
; 1764 : 	*_Tgt = _Value;
; 1765 : 
; 1766 :  #elif defined(_M_ARM64)
; 1767 : 	__iso_volatile_store64((volatile long long *)_Tgt, _Value);
; 1768 : 
; 1769 :  #else
; 1770 : 	_INTRIN_RELAXED(_InterlockedExchange64)((volatile long long *)_Tgt, _Value);
; 1771 :  #endif
; 1772 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Store_relaxed_8@std@@YAXPC_K_K@Z ENDP			; std::_Store_relaxed_8
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xatomic.h
;	COMDAT ?_InterlockedExchange64_INLINE@@YA_JPC_J_J@Z
_TEXT	SEGMENT
__Oldval$1$ = 8						; size = 4
__Tgt$ = 8						; size = 4
__Value$ = 12						; size = 8
?_InterlockedExchange64_INLINE@@YA_JPC_J_J@Z PROC	; _InterlockedExchange64_INLINE, COMDAT

; 65   : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi

; 66   : 	long long _Oldval;
; 67   : 	_Compiler_barrier();

	mov	edi, DWORD PTR __Tgt$[ebp]
	npad	5
$LL4@Interlocke:

; 68   : 	do
; 69   : 		{
; 70   : 		_Oldval = *_Tgt;

	mov	eax, DWORD PTR [edi]
	mov	esi, DWORD PTR [edi+4]

; 71   : 		} while (_Oldval != _InterlockedCompareExchange64(_Tgt, _Value, _Oldval));

	mov	edx, esi
	mov	ecx, DWORD PTR __Value$[ebp+4]
	mov	DWORD PTR __Oldval$1$[ebp], eax
	mov	ebx, DWORD PTR __Value$[ebp]
	lock	 cmpxchg8b QWORD PTR [edi]
	mov	ecx, DWORD PTR __Oldval$1$[ebp]
	cmp	ecx, eax
	jne	SHORT $LL4@Interlocke
	cmp	esi, edx
	jne	SHORT $LL4@Interlocke

; 72   : 	_Compiler_barrier();

	pop	edi

; 73   : 
; 74   : 	return (_Oldval);

	mov	edx, esi
	mov	eax, ecx
	pop	esi
	pop	ebx

; 75   : }

	pop	ebp
	ret	0
?_InterlockedExchange64_INLINE@@YA_JPC_J_J@Z ENDP	; _InterlockedExchange64_INLINE
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Orphan_all@_Container_base12@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base12@std@@QAEXXZ PROC		; std::_Container_base12::_Orphan_all, COMDAT
; _this$ = ecx

; 239  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 240  : 	if (_Myproxy != 0)
; 241  : 		{	// proxy allocated, drain it
; 242  : 		_Lockit _Lock(_LOCK_DEBUG);
; 243  : 
; 244  : 		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
; 245  : 			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)
; 246  : 			(*_Pnext)->_Myproxy = 0;
; 247  : 		_Myproxy->_Myfirstiter = 0;
; 248  : 		}
; 249  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 250  : 	}

	ret	0
?_Orphan_all@_Container_base12@std@@QAEXXZ ENDP		; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??1_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
??1_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::~_Container_base12, COMDAT
; _this$ = ecx

; 115  : 		_Orphan_all();
; 116  : 		}

	ret	0
??1_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::~_Container_base12
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??0_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
??0_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT
; _this$ = ecx

; 99   : 		: _Myproxy(0)

	mov	DWORD PTR [ecx], 0

; 101  : 		}

	mov	eax, ecx
	ret	0
??0_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??0_Container_proxy@std@@QAE@XZ
_TEXT	SEGMENT
??0_Container_proxy@std@@QAE@XZ PROC			; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 87   : 		: _Mycont(0), _Myfirstiter(0)

	mov	DWORD PTR [ecx], 0

; 89   : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0_Container_proxy@std@@QAE@XZ ENDP			; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 75   : 		}

	ret	4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 64   : 		}

	ret	0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 516  : 		{	// assign an element

	npad	2
	push	ebp
	mov	ebp, esp

; 517  : 		_Left = _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	eax, DWORD PTR __Left$[ebp]
	mov	BYTE PTR [eax], cl

; 518  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADQADQBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 505  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	npad	2
	push	ebp
	mov	ebp, esp

; 507  : 		}

	pop	ebp

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

	jmp	DWORD PTR __imp__memmove
?move@?$char_traits@D@std@@SAPADQADQBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADQADQBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 485  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	npad	2
	push	ebp
	mov	ebp, esp

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __First2$[ebp]
	push	DWORD PTR __First1$[ebp]
	call	_memcpy
	add	esp, 12					; 0000000cH

; 487  : 		}

	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADQADQBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIQBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIQBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 479  : 		{	// find length of null-terminated string

	npad	2
	push	ebp
	mov	ebp, esp

; 480  : 		return (_CSTD strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [eax+1]
	npad	5
$LL3@length:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL3@length
	sub	eax, edx

; 481  : 		}

	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIQBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z PROC	; std::char_traits<wchar_t>::assign, COMDAT

; 325  : 		{	// assign an element

	npad	2
	push	ebp
	mov	ebp, esp

; 326  : 		_Left = _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	cx, WORD PTR [eax]
	mov	eax, DWORD PTR __Left$[ebp]
	mov	WORD PTR [eax], cx

; 327  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ENDP	; std::char_traits<wchar_t>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?move@?$char_traits@_W@std@@SAPA_WQA_WQB_WI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@_W@std@@SAPA_WQA_WQB_WI@Z PROC	; std::char_traits<wchar_t>::move, COMDAT

; 314  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, eax
	mov	DWORD PTR __Count$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 316  : 		}

	pop	ebp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

	jmp	DWORD PTR __imp__memmove
?move@?$char_traits@_W@std@@SAPA_WQA_WQB_WI@Z ENDP	; std::char_traits<wchar_t>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?copy@?$char_traits@_W@std@@SAPA_WQA_WQB_WI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@_W@std@@SAPA_WQA_WQB_WI@Z PROC	; std::char_traits<wchar_t>::copy, COMDAT

; 294  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	mov	eax, DWORD PTR __Count$[ebp]
	add	eax, eax
	push	eax
	push	DWORD PTR __First2$[ebp]
	push	DWORD PTR __First1$[ebp]
	call	_memcpy
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 296  : 		}

	pop	ebp
	ret	0
?copy@?$char_traits@_W@std@@SAPA_WQA_WQB_WI@Z ENDP	; std::char_traits<wchar_t>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?length@?$char_traits@_W@std@@SAIQB_W@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@_W@std@@SAIQB_W@Z PROC		; std::char_traits<wchar_t>::length, COMDAT

; 288  : 		{	// find length of null-terminated sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 289  : 		return (_CSTD wcslen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [eax+2]
	npad	5
$LL3@length:
	mov	cx, WORD PTR [eax]
	add	eax, 2
	test	cx, cx
	jne	SHORT $LL3@length
	sub	eax, edx
	sar	eax, 1

; 290  : 		}

	pop	ebp
	ret	0
?length@?$char_traits@_W@std@@SAIQB_W@Z ENDP		; std::char_traits<wchar_t>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?compare@?$char_traits@_W@std@@SAHQB_W0I@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?compare@?$char_traits@_W@std@@SAHQB_W0I@Z PROC		; std::char_traits<wchar_t>::compare, COMDAT

; 283  : 		{	// compare [_First1, _First1 + _Count) with [_First2, ...)

	npad	2
	push	ebp
	mov	ebp, esp

; 284  : 		return (_CSTD wmemcmp(_First1, _First2, _Count));

	mov	edx, DWORD PTR __First2$[ebp]
	mov	eax, DWORD PTR __First1$[ebp]
	push	esi
	mov	esi, DWORD PTR __Count$[ebp]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 216  :         for (; 0 < _N; ++_S1, ++_S2, --_N)

	test	esi, esi
	je	SHORT $LN5@compare
$LL6@compare:

; 217  :             if (*_S1 != *_S2)

	mov	cx, WORD PTR [eax]
	cmp	cx, WORD PTR [edx]
	jne	SHORT $LN14@compare

; 216  :         for (; 0 < _N; ++_S1, ++_S2, --_N)

	add	eax, 2
	add	edx, 2
	sub	esi, 1
	jne	SHORT $LL6@compare
$LN5@compare:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 284  : 		return (_CSTD wmemcmp(_First1, _First2, _Count));

	xor	eax, eax
	pop	esi

; 285  : 		}

	pop	ebp
	ret	0
$LN14@compare:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h

; 218  :                 return *_S1 < *_S2 ? -1 : 1;

	sbb	eax, eax
	and	eax, -2					; fffffffeH
	inc	eax
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 285  : 		}

	pop	ebp
	ret	0
?compare@?$char_traits@_W@std@@SAHQB_W0I@Z ENDP		; std::char_traits<wchar_t>::compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 91   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 92   :         (void)_Size;
; 93   :         return _Where;

	mov	eax, DWORD PTR __Where$[ebp]

; 94   :     }

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
;	COMDAT _wmemmove
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemmove PROC						; COMDAT

; 244  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 245  :         #pragma warning(push)
; 246  :         #pragma warning(disable : 4996 6386)
; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

	mov	eax, DWORD PTR __N$[ebp]
	add	eax, eax
	mov	DWORD PTR __N$[ebp], eax

; 248  :         #pragma warning(pop)
; 249  :     }

	pop	ebp

; 245  :         #pragma warning(push)
; 246  :         #pragma warning(disable : 4996 6386)
; 247  :         return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));

	jmp	DWORD PTR __imp__memmove
_wmemmove ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
;	COMDAT _wmemcpy
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemcpy PROC						; COMDAT

; 231  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 232  :         #pragma warning(push)
; 233  :         #pragma warning(disable : 4995 4996 6386)
; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	mov	eax, DWORD PTR __N$[ebp]
	add	eax, eax
	mov	DWORD PTR __N$[ebp], eax

; 235  :         #pragma warning(pop)
; 236  :     }

	pop	ebp

; 232  :         #pragma warning(push)
; 233  :         #pragma warning(disable : 4995 4996 6386)
; 234  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	jmp	_memcpy
_wmemcpy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\wchar.h
;	COMDAT _wmemcmp
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemcmp PROC						; COMDAT

; 215  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 216  :         for (; 0 < _N; ++_S1, ++_S2, --_N)

	mov	esi, DWORD PTR __N$[ebp]
	test	esi, esi
	je	SHORT $LN3@wmemcmp
	mov	ecx, DWORD PTR __S2$[ebp]
	mov	edx, DWORD PTR __S1$[ebp]
$LL4@wmemcmp:

; 217  :             if (*_S1 != *_S2)

	mov	ax, WORD PTR [edx]
	cmp	ax, WORD PTR [ecx]
	jne	SHORT $LN8@wmemcmp

; 216  :         for (; 0 < _N; ++_S1, ++_S2, --_N)

	add	edx, 2
	add	ecx, 2
	sub	esi, 1
	jne	SHORT $LL4@wmemcmp
$LN3@wmemcmp:

; 219  : 
; 220  :         return 0;

	xor	eax, eax
	pop	esi

; 221  :     }

	pop	ebp
	ret	0
$LN8@wmemcmp:

; 218  :                 return *_S1 < *_S2 ? -1 : 1;

	movzx	eax, WORD PTR [edx]
	cmp	ax, WORD PTR [ecx]
	pop	esi
	sbb	eax, eax
	and	eax, -2					; fffffffeH
	inc	eax

; 221  :     }

	pop	ebp
	ret	0
_wmemcmp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h
;	COMDAT ?_InterlockedCompareExchange@@YAKPCKKK@Z
_TEXT	SEGMENT
_Destination$ = 8					; size = 4
_Exchange$ = 12						; size = 4
_Comperand$ = 16					; size = 4
?_InterlockedCompareExchange@@YAKPCKKK@Z PROC		; _InterlockedCompareExchange, COMDAT

; 9002 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 9003 :     return (unsigned long) _InterlockedCompareExchange((volatile long*) Destination, (long) Exchange, (long) Comperand);

	mov	edx, DWORD PTR _Exchange$[ebp]
	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	eax, DWORD PTR _Comperand$[ebp]
	lock	 cmpxchg DWORD PTR [ecx], edx

; 9004 : }

	pop	ebp
	ret	0
?_InterlockedCompareExchange@@YAKPCKKK@Z ENDP		; _InterlockedCompareExchange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h
;	COMDAT ?_InterlockedExchange@@YAKPCKK@Z
_TEXT	SEGMENT
_Target$ = 8						; size = 4
_Value$ = 12						; size = 4
?_InterlockedExchange@@YAKPCKK@Z PROC			; _InterlockedExchange, COMDAT

; 8902 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 8903 :     return (unsigned long) _InterlockedExchange((volatile long*) Target, (long) Value);

	mov	eax, DWORD PTR _Value$[ebp]
	mov	ecx, DWORD PTR _Target$[ebp]
	xchg	DWORD PTR [ecx], eax

; 8904 : }

	pop	ebp
	ret	0
?_InterlockedExchange@@YAKPCKK@Z ENDP			; _InterlockedExchange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h
;	COMDAT ?_InterlockedIncrement@@YAKPCK@Z
_TEXT	SEGMENT
_Addend$ = 8						; size = 4
?_InterlockedIncrement@@YAKPCK@Z PROC			; _InterlockedIncrement, COMDAT

; 8836 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 8837 :     return (unsigned long) _InterlockedIncrement((volatile long*) Addend);

	mov	ecx, DWORD PTR _Addend$[ebp]
	mov	eax, 1
	lock	 xadd	 DWORD PTR [ecx], eax
	inc	eax

; 8838 : }

	pop	ebp
	ret	0
?_InterlockedIncrement@@YAKPCK@Z ENDP			; _InterlockedIncrement
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
;	COMDAT _HRESULT_FROM_WIN32
_TEXT	SEGMENT
_x$ = 8							; size = 4
_HRESULT_FROM_WIN32 PROC				; COMDAT

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _x$[ebp]
	test	eax, eax
	jle	SHORT $LN4@HRESULT_FR
	movzx	eax, ax
	or	eax, -2147024896			; 80070000H
$LN4@HRESULT_FR:
	pop	ebp
	ret	0
_HRESULT_FROM_WIN32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winnt.h
;	COMDAT _ReadAcquire
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_ReadAcquire PROC					; COMDAT

; 8059 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 8060 : 
; 8061 :     LONG Value;
; 8062 : 
; 8063 :     Value = *Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	eax, DWORD PTR [eax]

; 8064 :     return Value;
; 8065 : }

	pop	ebp
	ret	0
_ReadAcquire ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
;	COMDAT _==
_TEXT	SEGMENT
_guidOne$ = 8						; size = 4
_guidOther$ = 12					; size = 4
_==	PROC						; COMDAT

; 193  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	edx, DWORD PTR _guidOne$[ebp]
	mov	eax, DWORD PTR _guidOther$[ebp]
	push	esi
	mov	esi, 12					; 0000000cH
$LL7@:
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN6@
	add	edx, 4
	add	eax, 4
	sub	esi, 4
	jae	SHORT $LL7@

; 194  :     return !!IsEqualGUID(guidOne,guidOther);

	mov	al, 1
	pop	esi

; 195  : }

	pop	ebp
	ret	0
$LN6@:

; 194  :     return !!IsEqualGUID(guidOne,guidOther);

	xor	al, al
	pop	esi

; 195  : }

	pop	ebp
	ret	0
_==	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT
_rguid1$ = 8						; size = 4
_rguid2$ = 12						; size = 4
_IsEqualGUID PROC					; COMDAT

; 160  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	edx, DWORD PTR _rguid1$[ebp]
	mov	eax, DWORD PTR _rguid2$[ebp]
	push	esi
	mov	esi, 12					; 0000000cH
$LL5@IsEqualGUI:
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN4@IsEqualGUI
	add	edx, 4
	add	eax, 4
	sub	esi, 4
	jae	SHORT $LL5@IsEqualGUI
	mov	eax, 1
	pop	esi

; 162  : }

	pop	ebp
	ret	0
$LN4@IsEqualGUI:

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	xor	eax, eax
	pop	esi

; 162  : }

	pop	ebp
	ret	0
_IsEqualGUID ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

; 5940 : }

	ret	0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\dxgi.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

; 5940 : }

	ret	0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___n$[ebp]
	test	esi, esi
	je	SHORT $LN6@vector
	push	ebx
	mov	ebx, DWORD PTR ___f$[ebp]
	push	edi
	mov	edi, DWORD PTR ___t$[ebp]
$LL2@vector:
	mov	ecx, edi
	call	ebx
	add	edi, DWORD PTR ___s$[ebp]
	sub	esi, 1
	jne	SHORT $LL2@vector
	pop	edi
	pop	ebx
$LN6@vector:
	pop	esi
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
