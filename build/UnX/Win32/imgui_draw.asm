; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	C:\Users\andon\Source\Repos\SpecialK\src\imgui\imgui_draw.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG14850 DB	'name', 00H
	ORG $+3
$SG15910 DB	'ProggyClean.ttf, 13px', 00H
	ORG $+2
$SG14903 DB	'head', 00H
	ORG $+3
$SG14905 DB	'name', 00H
	ORG $+3
$SG15931 DB	'rb', 00H
	ORG $+1
$SG15934 DB	'%s, %.0fpx', 00H
	ORG $+1
$SG128600 DB	'[', 00H, 'I', 00H, 'm', 00H, 'G', 00H, 'u', 00H, 'i', 00H
	DB	' ', 00H, 'F', 00H, 'o', 00H, 'n', 00H, 't', 00H, ']', 00H, ' '
	DB	00H, 'U', 00H, 'n', 00H, 'p', 00H, 'r', 00H, 'i', 00H, 'n', 00H
	DB	't', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, ' ', 00H, 'C'
	DB	00H, 'h', 00H, 'a', 00H, 'r', 00H, 'a', 00H, 'c', 00H, 't', 00H
	DB	'e', 00H, 'r', 00H, ':', 00H, ' ', 00H, '''', 00H, '%', 00H, 'w'
	DB	00H, 'c', 00H, '''', 00H, ' ', 00H, '(', 00H, 'U', 00H, '+', 00H
	DB	'%', 00H, 'l', 00H, 'x', 00H, ')', 00H, 00H, 00H
$SG12965 DB	'typ1', 00H
	ORG $+3
$SG12966 DB	'typ1', 00H
	ORG $+3
$SG12967 DB	'typ1', 00H
	ORG $+3
$SG12968 DB	'typ1', 00H
	ORG $+3
$SG12970 DB	'OTTO', 00H
	ORG $+3
$SG12971 DB	'OTTO', 00H
	ORG $+3
$SG12972 DB	'OTTO', 00H
	ORG $+3
$SG12973 DB	'OTTO', 00H
	ORG $+3
$SG12976 DB	'true', 00H
	ORG $+3
$SG12977 DB	'true', 00H
	ORG $+3
$SG12978 DB	'true', 00H
	ORG $+3
$SG12979 DB	'true', 00H
	ORG $+7
?proggy_clean_ttf_compressed_data_base85@@3QBDB DB '7])#######hV0qs''/###'
	DB	'[),##/l:$#Q6>##5[n42>c-TH`->>#/e>11NNV=Bv(*:.F?uu#(gRU.o0XGH`'
	DB	'$vhLG1hxt9?W`#,5LsCp#-i>.r$<$6pD>Lb'';9Crc6tgXmKVeU2cD4Eo3R/2'
	DB	'*>]b(MC;$jPfY.;h^`IWM9<Lh2TlS+f-s$o6Q<BWH`YiU.xfLq$N;$0iR/GX:'
	DB	'U(jcW2p/W*q?-qmnUCI;jHSAiFWM.R*kU@C=GH?a9wp8f$e.-4^Qg1)Q-GL(l'
	DB	'f(r/7GrRgwV%MS=C#`8ND>Qo#t''X#(v#Y9w0#1D$CIf;W''#pWUPXOuxXuU('
	DB	'H9M(1<q-UE31#^-V''8IRUo7Qf./L>=Ke$$''5F%)]0^#0X@U.a<r:QLtFsLc'
	DB	'L6##lOj)#.Y5<-R&KgLwqJfLgN&;Q?gI^#DY2uLi@^rMl9t=cWq6##weg>$FB'
	DB	'jVQTSDgEKnIS7EM9>ZY9w0#L;>>#Mx&4Mvt//L[MkA#W@lK.N''[0#7RL_&#w'
	DB	'+F%HtG9M#XL`N&.,GM4Pg;-<nLENhvx>-VsM.M0rJfLH2eTM`*oJMHRC`Nkfi'
	DB	'mM2J,W-jXS:)r0wK#@Fge$U>`w''N7G#$#fB#$E^$#:9:hk+eOe--6x)F7*E%'
	DB	'?76%^GMHePW-Z5l''&GiF#$956:rS?dA#fiK:)Yr+`&#0j@''DbG&#^$PG.Ll'
	DB	'+DNa<XCMKEV*N)LN/N*b=%Q6pia-Xg8I$<MR&,VdJe$<(7G;Ckl''&hF;;$<_'
	DB	'=X(b.RS%%)###MPBuuE1V:v&cX&#2m#(&cV]`k9OhLMbn%s$G2,B$BfD3X*sp'
	DB	'5#l,$R#]x_X1xKX%b5U*[r5iMfUo9U`N99hG)tm+/Us9pG)XPu`<0s-)WTt(g'
	DB	'CRxIg(%6sfh=ktMKn3j)<6<b5Sk_/0(^]AaN#(p/L>&VZ>1i%h1S9u5o@YaaW'
	DB	'$e+b<TWFn/Z:Oh(Cx2$lNEoN^e)#CFY@@I;BOQ*sRwZtZxRcU7uW6CXow0i(?'
	DB	'$Q[cjOd[P4d)]>ROPOpxTO7Stwi1::iB1q)C_=dV26J;2,]7op$]uQr@_V7$q'
	DB	'^%lQwtuHY]=DX,n3L#0PHDO4f9>dC@O>HBuKPpP*E,N+b3L#lpR/MrTEH.IAQ'
	DB	'k.a>D[.e;mc.x]Ip.PH^''/aqUO/$1WxLoW0[iLA<QT;5HKD+@qQ''NQ(3_PL'
	DB	'hE48R.qAPSwQ0/WK?Z,[x?-J;jQTWA0X@KJ(_Y8N-:/M74:/-ZpKrUss?d#dZ'
	DB	'q]DAbkU*JqkL+nwX@@47`5>w=4h(9.`GCRUxHPeR`5Mjol(dUWxZa(>STrPkr'
	DB	'JiWx`5U7F#.g*jrohGg`cg:lSTvEY/EV_7H4Q9[Z%cnv;JQYZ5q.l7Zeas:HO'
	DB	'IZOB?G<Nald$qs]@]L<J7bR*>gv:[7MI2k).''2($5FNP&EQ(,)U]W]+fh18.'
	DB	'vsai00);D3@4ku5P?DP8aJt+;qUM]=+b''8@;mViBKx0DE[-auGl8:PJ&Dj+M'
	DB	'6OC]O^((##]`0i)drT;-7X`=-H3[igUnPG-NZlo.#k@h#=Ork$m>a>$-?Tm$U'
	DB	'V(?#P6YY#''/###xe7q.73rI3*pP/$1>s9)W,JrM7SN]''/4C#v$U`0#V.[0>'
	DB	'xQsH$fEmPMgY2u7Kh(G%siIfLSoS+MK2eTM$=5,M8p`A.;_R%#u[K#$x4AG8.'
	DB	'kK/HSB==-''Ie/QTtG?-.*^N-4B/ZM_3YlQC7(p7q)&](`6_c)$/*JL(L-^(]'
	DB	'$wIM`dPtOdGA,U3:w2M-0<q-]L_?^)1vw''.,MRsqVr.L;aN&#/EgJ)PBc[-f'
	DB	'>+WomX2u7lqM2iEumMTcsF?-aT=Z-97UEnXglEn1K-bnEO`guFt(c%=;Am_Qs'
	DB	'@jLooI&NX;]0#j4#F14;gl8-GQpgwhrq8''=l_f-b49''UOqkLu7-##oDY2L('
	DB	'te+Mch&gLYtJ,MEtJfLh''x''M=$CS-ZZ%P]8bZ>#S?YY#%Q&q''3^Fw&?D)U'
	DB	'DNrocM3A76//oL?#h7gl85[qW/NDOk%16ij;+:1a''iNIdb-ou8.P*w,v5#EI'
	DB	'$TWS>Pot-R*H''-SEpA:g)f+O$%%`kA#G=8RMmG1&O`>to8bC]T&$,n.LoO>2'
	DB	'9sp3dt-52U%VM#q7''DHpg+#Z9%H[K<L%a2E-grWVM3@2=-k22tL]4$##6We'''
	DB	'8UJCKE[d_=%wI;''6X-GsLX4j^SgJ$##R*w,vP3wK#iiW&#*h^D&R?jp7+/u&'
	DB	'#(AP##XU8c$fSYW-J95_-Dp[g9wcO&#M-h1OcJlc-*vpw0xUX&#OQFKNX@QI'''
	DB	'IoPp7nb,QU//MQ&ZDkKP)X<WSVL(68uVl&#c''[0#(s1X&xm$Y%B7*K:eDA32'
	DB	'3j998GXbA#pwMs-jgD$9QISB-A_(aN4xoFM^@C58D0+Q+q3n0#3U1InDjF682'
	DB	'-SjMXJK)(h$hxua_K]ul92%''BOU&#BRRh-slg8KDlr:%L71Ka:.A;%YULjDP'
	DB	'mL<LYs8i#XwJOYaKPKc1h:''9Ke,g)b),78=I39B;xiY$bgGw-&.Zi9InXDuY'
	DB	'a%G*f2Bq7mn9^#p1vv%#(Wi-;/Z5ho;#2:;%d&#x9v68C5g?ntX0X)pT`;%pB'
	DB	'3q7mgGN)3%(P8nTd5L7GeA-GL@+%J3u2:(Yf>et`e;)f#Km8&+DC$I46>#Kr]'
	DB	']u-[=99tts1.qb#q72g1WJO81q+eN''03''eM>&1XxY-caEnOj%2n8)),?ILR'
	DB	'5^.Ibn<-X-Mq7[a82Lq:F&#ce+S9wsCK*x`569E8ew''He]h:sI[2LM$[guka'
	DB	'3ZRd6:t%IG:;$%YiJ:Nq=?eAw;/:nnDq0(CYcMpG)qLN4$##&J<j$UpK<Q4a1'
	DB	']MupW^-sj_$%[HK%''F####QRZJ::Y3EGl4''@%FkiAOg#p[##O`gukTfBHag'
	DB	'L<LHw%q&OV0##F=6/:chIm0@eCP8X]:kFI%hl8hgO@RcBhS-@Qb$%+m=hPDLg'
	DB	'*%K8ln(wcf3/''DW-$.lR?n[nCH-eXOONTJlh:.RYF%3''p6sq:UIMA945&^H'
	DB	'FS87@$EP2iG<-lCO$%c`uKGD3rC$x0BL8aFn--`ke%#HMP''vh1/R&O_J9''u'
	DB	'm,.<tx[@%wsJk&bUT2`0uMv7gg#qp/ij.L56''hl;.s5CUrxjOM7-##.l+Au'''
	DB	'A&O:-T72L]P`&=;ctp''XScX*rU.>-XTt,%OVU4)S1+R-#dg0/Nn?Ku1^0f$B'
	DB	'*P:Rowwm-`0PKjYDDM''3]d39VZHEl4,.j'']Pk-M.h^&:0FACm$maq-&sgw0'
	DB	't7/6(^xtk%LuH88Fj-ekm>GA#_>568x6(OFRl-IZp`&b,_P''$M<Jnq79VsJW'
	DB	'/mWS*PUiq76;]/NM_>hLbxfc$mj`,O;&%W2m`Zh:/)Uetw:aJ%]K9h:TcF]u_'
	DB	'-Sj9,VK3M.*''&0D[Ca]J9gp8,kAW]%(?A%R$f<->Zts''^kn=-^@c4%-pY6q'
	DB	'I%J%1IGxfLU9CP8cbPlXv);C=b),<2mOvP8up,UVf3839acAWAW-W?#ao/^#%'
	DB	'KYo8fRULNd2.>%m]UK:n%r$''sw]J;5pAoO_#2mO3n,''=H5(etHg*`+RLgv>'
	DB	'=4U8guD$I%D:W>-r5V*%j*W:Kvej.Lp$<M-SGZ'':+Q_k+uvOSLiEo(<aD/K<'
	DB	'CCc`''Lx>''?;++O''>()jLR-^u68PHm8ZFWe+ej8h:9r6L*0//c&iH&R8pRb'
	DB	'A#Kjm%upV1g:a_#Ur7FuA#(tRh#.Y5K+@?3<-8m0$PEn;J:rh6?I6uG<-`wMU'
	DB	'''ircp0LaE_OtlMb&1#6T.#FDKu#1Lw%u%+GM+X''e?YLfjM[VO0MbuFp7;>Q'
	DB	'&#WIo)0@F%q7c#4XAXN-U&VB<HFF*qL($/V,;(kXZejWO`<[5??ewY(*9=%wD'
	DB	'c;,u<''9t3W-(H1th3+G]ucQ]kLs7df($/*JL]@*t7Bu_G3_7mp7<iaQjO@.k'
	DB	'Lg;x3B0lqp7Hf,^Ze7-##@/c58Mo(3;knp0%)A7?-W+eI''o8)b<nKnw''Ho8'
	DB	'C=Y>pqB>0ie&jhZ[?iLR@@_AvA-iQC(=ksRZRVp7`.=+NpBC%rh&3]R:8XDmE'
	DB	'5^V8O(x<<aG/1N$#FX$0V5Y6x''aErI3I$7x%E`v<-BY,)%-?Psf*l?%C3.mM'
	DB	'(=/M0:JxG''?7WhH%o''a<-80g0NBxoO(GH<dM]n.+%q@jH?f.UsJ2Ggs&4<-'
	DB	'e47&Kl+f//9@`b+?.TeN_&B8Ss?v;^Trk;f#YvJkl&w$]>-+k?''(<S:68tq*'
	DB	'WoDfZu'';mM?8X[ma8W%*`-=;D.(nc7/;)g:T1=^J$&BRV(-lTmNB6xqB[@0*'
	DB	'o.erM*<SWF]u2=st-*(6v>^](H.aREZSi,#1:[IXaZFOm<-ui#qUq2$##Ri;u'
	DB	'75OK#(RtaW-K-F`S+cF]uN`-KMQ%rP/Xri.LRcB##=YL3BgM/3MD?@f&1''BW'
	DB	'-)Ju<L25gl8uhVm1hL$##*8###''A3/LkKW+(^rWX?5W_8g)a(m&K8P>#bmmW'
	DB	'CMkk&#TR`C,5d>g)F;t,4:@_l8G/5h4vUd%&%950:VXD''QdWoY-F$BtUwmfe'
	DB	'$YqL''8(PWX(P?^@Po3$##`MSs?DWBZ/S>+4%>fX,VWv/w''KD`LP5IbH;rTV'
	DB	'>n3cEK8U#bX]l-/V+^lj3;vlMb&[5YQ8#pekX9JP3XUC72L,,?+Ni&co7ApnO'
	DB	'*5NK,((W-i:$,kp''UDAO(G0Sq7MVjJsbIu)''Z,*[>br5fX^:FPAWr-m2KgL'
	DB	'<LUN098kTF&#lvo58=/vjDo;.;)Ka*hLR#/k=rKbxuV`>Q_nN6''8uTG&#1T5'
	DB	'g)uLv:873UpTLgH+#FgpH''_o1780Ph8KmxQJ8#H72L4@768@Tm&Qh4CB/5Ov'
	DB	'mA&,Q&QbUoi$a_%3M01H)4x7I^&KQVgtFnV+;[Pc>[m4k//,]1?#`VY[Jr*3&'
	DB	'&slRfLiVZJ:]?=K3Sw=[$=uRB?3xk48@aeg<Z''<$#4H)6,>e0jT6''N#(q%.'
	DB	'O=?2S]u*(m<-V8J''(1)G][68hW$5''q[GC&5j`TE?m''esFGNRM)j,ffZ?-q'
	DB	'x8;->g4t*:CIP/[Qap7/9''#(1sao7w-.qNUdkJ)tCF&#B^;xGvn2r9FEPFFF'
	DB	'cL@.iFNkTve$m%#QvQS8U@)2Z+3K:AKM5isZ88+dKQ)W6>J%CL<KE>`.d*(B`'
	DB	'-n8D9oK<Up]c$X$(,)M8Zt7/[rdkqTgl-0cuGMv''?>-XV1q[''-5k''cAZ69'
	DB	'e;D_?$ZPP&s^+7])$*$#@QYi9,5P&#9r+$%CE=68>K8r0=dSC%%(@p7.m7jil'
	DB	'Q02''0-VWAg<a/''''3u.=4L$Y)6k/K:_[3=&jvL<L0C/2''v:^;-DIBW,B4E'
	DB	'68:kZ;%?8(Q8BH=kO65BW?xSG&#@uU,DS*,?.+(o(#1vCS8#CHF>TlGW''b)T'
	DB	'q7VT9q^*^$$.:&N@@$&)WHtPm*5_rO0&e%K&#-30j(E4#''Zb.o/(Tpm$>K'''
	DB	'f@[PvFl,hfINTNU6u''0pao7%XUp9]5.>%h`8_=VYbxuel.NTSsJfLacFu3B'''
	DB	'lQSu/m6-Oqem8T+oE--$0a/k]uj9EwsG>%veR*hv^BFpQj:K''#SJ,sB-''#]'
	DB	'(j.Lg92rTw-*n%@/;39rrJF,l#qV%OrtBeC6/,;qB3ebNW[?,Hqj2L.1NP&Gj'
	DB	'UR=1D8QaS3Up&@*9wP?+lo7b?@%''k4`p0Z$22%K3+iCZj?XJN4Nm&+YF]u@-'
	DB	'W$U%VEQ/,,>>#)D<h#`)h0:<Q6909ua+&VU%n2:cG3FJ-%@Bj-DgLr`Hw&HAK'
	DB	'jKjseK</xKT*)B,N9X3]krc12t''pgTV(Lv-tL[xg_%=M_q7a^x?7Ubd>#%8c'
	DB	'Y#YZ?=,`Wdxu/ae&#w6)R89tI#6@s''(6Bf7a&?S=^ZI_kS&ai`&=tE72L_D,'
	DB	';^R)7[$s<Eh#c&)q.MXI%#v9ROa5FZO%sF7q7Nwb&#ptUJ:aqJe$Sl68%.D##'
	DB	'#EC><?-aF&#RNQv>o8lKN%5/$(vdfq7+ebA#u1p]ovUKW&Y%q]''>$1@-[xfn'
	DB	'$7ZTp7mM,G,Ko7a&Gu%G[RMxJs[0MM%wci.LFDK)(<c`Q8N)jEIF*+?P2a8g%'
	DB	')$q]o2aH8C&<SibC/q,(e:v;-b#6[$NtDZ84Je2KNvB#$P5?tQ3nt(0d=j.LQ'
	DB	'f./Ll33+(;q3L-w=8dX$#WF&uIJ@-bfI>%:_i2B5CsR8&9Z&#=mPEnm0f`<&c'
	DB	')QL5uJ#%u%lJj+D-r;BoF&#4DoS97h5g)E#o:&S4weDF,9^Hoe`h*L+_a*NrL'
	DB	'W-1pG_&2UdB86e%B/:=>)N4xeW.*wft-;$''58-ESqr<b?UI(_%@[P46>#U`'''
	DB	'6AQ]m&6/`Z>#S?YY#Vc;r7U2&326d=w&H####?TZ`*4?&.MK?LP8Vxg>$[QXc'
	DB	'%QJv92.(Db*B)gb*BM9dM*hJMAo*c&#b0v=Pjer]$gG&JXDf->''StvU7505l'
	DB	'9$AFvgYRI^&<^b68?j#q9QX4SM''RO#&sL1IM.rJfLUAj221]d##DW=m83u5;'
	DB	'''bYx,*Sl0hL(W;;$doB&O/TQ:(Z^xBdLjL<Lni;''''X.`$#8+1GD:k$YUWs'
	DB	'bn8ogh6rxZ2Z9]%nd+>V#*8U_72Lh+2Q8Cj0i:6hp&$C/:p(HK>T8Y[gHQ4`4'
	DB	')''$Ab(Nof%V''8hL&#<NEdtg(n''=S1A(Q1/I&4([%dM`,Iu''1:_hL>SfD0'
	DB	'7&6D<fp8dHM7/g+tlPN9J*rKaPct&?''uBCem^jn%9_K)<,C5K3s=5g&GmJb*'
	DB	'[SYq7K;TRLGCsM-$$;S%:Y@r7AK0pprpL<Lrh,q7e/%KWK:50I^+m''vi`3?%'
	DB	'Zp+<-d+$L-Sv:@.o19n$s0&39;kn;S%BSq*$3WoJSCLweV[aZ''MQIjO<7;X-'
	DB	'X;&+dMLvu#^UsGEC9WEc[X(wI7#2.(F0jV*eZf<-Qv3J-c+J5AlrB#$p(H68L'
	DB	'vEA''q3n0#m,[`*8Ft)FcYgEud]CWfm68,(aLA$@EFTgLXoBq/UPlp7:d[/;r'
	DB	'_ix=:TF`S5H-b<LI&HY(K=h#)]Lk$K14lVfm:x$H<3^Ql<M`$OhapBnkup''D'
	DB	'#L$Pb_`N*g]2e;X/Dtg,bsj&K#2[-:iYr''_wgH)NUIR8a1n#S?Yej''h8^58'
	DB	'UbZd+^FKD*T@;6A7aQC[K8d-(v6GI$x:T<&''Gp5Uf>@M.*J:;$-rv29''M]8'
	DB	'qMv-tLp,''886iaC=Hb*YJoKJ,(j%K=H`K.v9HggqBIiZu''QvBT.#=)0ukru'
	DB	'V&.)3=(^1`o*Pj4<-<aN((^7(''#Z0wK#5GX@7u][`*S^43933A4rl][`*O4C'
	DB	'gLEl]v$1Q3AeF37dbXk,.)vj#x''d`;qgbQR%FW,2(?LO=s%Sc68%NP''##Ao'
	DB	'tl8x=BE#j1UD([3$M(]UI2LX3RpKN@;/#f''f/&_mt&F)XdF<9t4)Qa.*kTLw'
	DB	'Q''(TTB9.xH''>#MJ+gLq9-##@HuZPN0]u:h7.T..G:;$/Usj(T7`Q8tT72Ln'
	DB	'Yl<-qx8;-HV7Q-&Xdx%1a,hC=0u+HlsV>nuIQL-5<N?)NBS)QN*_I,?&)2''I'
	DB	'M%L3I)X((e/dl2&8''<M:^#M*Q+[T.Xri.LYS3v%fF`68h;b-X[/En''CR.q7'
	DB	'E)p''/kle2HM,u;^%OKC-N+Ll%F9CF<Nf''^#t2L,;27W:0O@6##U6W7:$rJf'
	DB	'LWHj$#)woqBefIZ.PK<b*t7ed;p*_m;4ExK#h@&]>_>@kXQtMacfD.m-VAb8;'
	DB	'IReM3$wf0''''hra*so568''Ip&vRs849''MRYSp%:t:h5qSgwpEr$B>Q,;s('
	DB	'C#$)`svQuF$##-D,##,g68@2[T;.XSdN9Qe)rpt._K-#5wF)sP''##p#C0c%-'
	DB	'Gb%hd+<-j''Ai*x&&HMkT]C''OSl##5RG[JXaHN;d''uA#x._U;.`PU@(Z3dt'
	DB	'4r152@:v,''R.Sj''w#0<-;kPI)FfJ&#AYJ&#//)>-k=m=*XnK$>=)72L]0I%'
	DB	'>.G690a:$##<,);?;72#?x9+d;^V''9;jY@;)br#q^YQpx:X#Te$Z^''=-=bG'
	DB	'hLf:D6&bNwZ9-ZD#n^9HhLMr5G;'']d&6''wYmTFmL<LD)F^%[tC''8;+9E#C'
	DB	'$g%#5Y>q9wI>P(9mI[>kC-ekLC/R&CH+s''B;K-M6$EB%is00:+A4[7xks.Lr'
	DB	'Nk0&E)wILYF@2L''0Nb$+pv<(2.768/FrY&h$^3i&@+G%JT''<-,v`3;_)I9M'
	DB	'^AE]CN?Cl2AZg+%4iTpT3<n-&%H%b<FDj2M<hH=&Eh<2Len$b*aTX=-8QxN)k'
	DB	'11IM1c^j%9s<L<NFSo)B?+<-(GxsF,^-Eh@$4dXhN$+#rxK8''je''D7k`e;)'
	DB	'2pYwPA''_p9&@^18ml1^[@g4t*[JOa*[=Qp7(qJ_oOL^(''7fB&Hq-:sf,sNj'
	DB	'8xq^>$U4O]GKx''m9)b@p7YsvK3w^YR-CdQ*:Ir<($u&)#(&?L9Rg3H)4fiEp'
	DB	'^iI9O8KnTj,]H?D*r7''M;PwZ9K0E^k&-cpI;.p/6_vwoFMV<->#%Xi.LxVnr'
	DB	'U(4&8/P+:hLSKj$#U%]49t''I:rgMi''FL@a:0Y-uA[39'',(vbma*hU%<-SR'
	DB	'F`Tt:542R_VV$p@[p8DV[A,?1839FWdF<TddF<9Ah-6&9tWoDlh]&1SpGMq>T'
	DB	'i1O*H&#(AL8[_P%.M>v^-))qOT*F5Cq0`Ye%+$B6i:7@0IX<N+T+0MlMBPQ*V'
	DB	'j>SsD<U4JHY8kD2)2fU/M#$e.)T4,_=8hLim[&);?UkK''-x?''(:siIfL<$p'
	DB	'FM`i<?%W(mGDHM%>iWP,##P`%/L<eXi:@Z9C.7o=@(pXdAO/NLQ8lPl+HPOQa'
	DB	'8wD8=^GlPa8TKI1CjhsCTSLJM''/Wl>-S(qw%sf/@%#B6;/U7K]uZbi^Oc^2n'
	DB	'<bhPmUkMw>%t<)''mEVE''''n`WnJra$^TKvX5B>;_aSEK'',(hwa0:i4G?.B'
	DB	'ci.(X[?b*($,=-n<.Q%`(X=?+@Am*Js0&=3bh8K]mL<LoNs''6,''85`0?t/'''
	DB	'_U59@]ddF<#LdF<eWdF<OuN/45rY<-L@&#+fm>69=Lb,OcZV/);TTm8VI;?%O'
	DB	'tJ<(b4mq7M6:u?KRdF<gR@2L=FNU-<b[(9c/ML3m;Z[$oF3g)GAWqpARc=<RO'
	DB	'u7cL5l;-[A]%/+fsd;l#SafT/f*W]0=O''$(Tb<[)*@e775R-:Yob%g*>l*:x'
	DB	'P?Yb.5)%w_I?7uk5JC+FS(m#i''k.''a0i)9<7b''fs''59hq$*5Uhv##pi^8'
	DB	'+hIEBF`nvo`;''l0.^S1<-wUK2/Coh58KKhLjM=SO*rfO`+qC`W-On.=AJ56>'
	DB	'>i2@2LH6A:&5q`?9I3@@''04&p2/LVa*T-4<-i3;M9UvZd+N7>b*eIwg:CC)c'
	DB	'<>nO&#<IGe;__.thjZl<%w(Wk2xmp4Q@I#I9,DF]u7-P=.-_:YJ]aS@V?6*C('
	DB	')dOp7:WL,b&3Rg/.cmM9&r^>$(>.Z-I&J(Q0Hd5Q%7Co-b`-c<N(6r@ip+Aur'
	DB	'K<m86QIth*#v;-OBqi+L7wDE-Ir8K[''m+DDSLwK&/.?-V%U_%3:qKNu$_b*B'
	DB	'-kp7NaD''QdWQPKYq[@>P)hI;*_F]u`Rb[.j8_Q/<&>uu+VsH$sM9TA%?)(vm'
	DB	'J80),P7E>)tjD%2L=-t#fK[%`v=Q8<FfNkgg^oIbah*#8/Qt$F&:K*-(N/''+'
	DB	'1vMB,u()-a.VUU*#[e%gAAO(S>WlA2);Sa>gXm8YB`1d@K#n]76-a$U,mF<fX'
	DB	']idqd)<3,]J7JmW4`6]uks=4-72L(jEk+:bJ0M^q-8Dm_Z?0olP1C9Sa&H[d&'
	DB	'c$ooQUj]Exd*3ZM@-WGW2%s'',B-_M%>%Ul:#/''xoFM9QX-$.QN''>[%$Z$u'
	DB	'F6pA6Ki2O5:8w*vP1<-1`[G,)-m#>0`P&#eb#.3i)rtB61(o''$?X3B</R90;'
	DB	'eZ]%Ncq;-Tl]#F>2Qft^ae_5tKL9MUe9b*sLEQ95C&`=G?@Mj=wh*''3E>=-<'
	DB	')Gt*Iw)''QG:`@IwOf7&]1i''S01B+Ev/Nac#9S;=;YQpg_6U`*kVY39xK,[/'
	DB	'6Aj7:''1Bm-_1EYfa1+o&o4hp7KN_Q(OlIo@S%;jVdn0''1<Vc52=u`3^o-n1'
	DB	'''g4v58Hj&6_t7$##?M)c<$bgQ_''SY((-xkA#Y(,p''H9rIVY-b,''%bCPF7'
	DB	'.J<Up^,(dU1VY*5#WkTU>h19w,WQhLI)3S#f$2(eb,jr*b;3Vw]*7NH%$c4Vs'
	DB	',eD9>XW8?N]o+(*pgC%/72LV-u<Hp,3@e^9UB1J+ak9-TN/mhKPg+AJYd$Mlv'
	DB	'AF_jCK*.O-^(63adMT->W%iewS8W6m2rtCpo''RS1R84=@paTKt)>=%&1[)*v'
	DB	'p''u+x,VrwN;&]kuO9JDbg=pO$J*.jVe;u''m0dr9l,<*wMK*Oe=g8lV_KEBF'
	DB	'kO''oU]^=[-792#ok,)i]lR8qQ2oA8wcRCZ^7w/Njh;?.stX?Q1>S1q4Bn$)K'
	DB	'1<-rGdO''$Wr.Lc.CG)$/*JL4tNR/,SVO3,aUw''DJN:)Ss;wGn9A32ijw%FL'
	DB	'+Z0Fn.U9;reSq)bmI32U==5ALuG&#Vf1398/pVo1*c-(aY168o<`JsSbk-,1N'
	DB	';$>0:OUas(3:8Z972LSfF8eb=c-;>SPw7.6hn3m`9^Xkn(r.qS[0;T%&Qc=+S'
	DB	'TRxX''q1BNk3&*eu2;&8q$&x>Q#Q7^Tf+6<(d%ZVmj2bDi%.3L2n+4W''$PiD'
	DB	'DG)g,r%+?,$@?uou5tSe2aN_AQU*<h`e-GI7)?OK2A.d7_c)?wQ5AS@DL3r#7'
	DB	'fSkgl6-++D:''A,uq7SvlB$pcpH''q3n0#_%dY#xCpr-l<F0NR@-##FEV6NTF'
	DB	'6##$l84N1w?AO>''IAOURQ##V^Fv-XFbGM7Fl(N<3DhLGF%q.1rC$#:T__&Pi'
	DB	'68%0xi_&[qFJ(77j_&JWoF.V735&T,[R*:xFR*K5>>#`bW-?4Ne_&6Ne_&6Ne'
	DB	'_&n`kr-#GJcM6X;uM6X;uM(.a..^2TkL%oR(#;u.T%fAr%4tJ8&><1=GHZ_+m'
	DB	'9/#H1F^R#SC#*N=BA9(D?v[UiFY>>^8p,KKF.W]L29uLkLlu/+4T<XoIB&hx='
	DB	'T1PcDaB&;HH+-AFr?(m9HZV)FKS8JCw;SD=6[^/DZUL`EUDf]GGlG&>w$)F./'
	DB	'^n3+rlo+DB;5sIYGNk+i1t-69Jg--0pao7Sm#K)pdHW&;LuDNH@H>#/X-TI(;'
	DB	'P>#,Gc>#0Su>#4`1?#8lC?#<xU?#@.i?#D:%@#HF7@#LRI@#P_[@#Tkn@#Xw*'
	DB	'A#]-=A#a9OA#d<F&#*;G##.GY##2Sl##6`($#:l:$#>xL$#B.`$#F:r$#JF.%'
	DB	'#NR@%#R_R%#Vke%#Zww%#_-4&#3^Rh%Sflr-k''MS.o?.5/sWel/wpEM0%3'''
	DB	'/1)K^f1-d>G21&v(35>V`39V7A4=onx4A1OY5EI0;6Ibgr6M$HS7Q<)58C5w,'
	DB	';WoA*#[%T*#`1g*#d=#+#hI5+#lUG+#pbY+#tnl+#x$),#&1;,#*=M,#.I`,#'
	DB	'2Ur,#6b.-#;w[H#iQtA#m^0B#qjBB#uvTB##-hB#''9$C#+E6C#/QHC#3^ZC#'
	DB	'7jmC#;v)D#?,<D#C8ND#GDaD#KPsD#O]/E#g1A5#KA*1#gC17#MGd;#8(02#L'
	DB	'-d3#rWM4#Hga1#,<w0#T.j<#O#''2#CYN1#qa^:#_4m3#o@/=#eG8=#t8J5#`'
	DB	'+78#4uI-#m3B2#SB[8#Q0@8#i[*9#iOn8#1Nm;#^sN9#qh<9#:=x-#P;K2#$%'
	DB	'X9#bC+.#Rg;<#mN=.#MTF.#RZO.#2?)4#Y#(/#[)1/#b;L/#dAU/#0Sv;#lY$'
	DB	'0#n`-0#sf60#(F24#wrH0#%/e0#TmD<#%JSMFove:CTBEXI:<eh2g)B,3h2^G'
	DB	'3i;#d3jD>)4kMYD4lVu`4m`:&5niUA5@(A5BA1]PBB:xlBCC=2CDLXMCEUtiC'
	DB	'f&0g2''tN?PGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CP'
	DB	'GT4CPGT4CPGT4CP-qekC`.9kEg^+F$kwViFJTB&5KTB&5KTB&5KTB&5KTB&5K'
	DB	'TB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5o,^<-28ZI''O'
	DB	'?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?'
	DB	';xpO?;xp;7q-#lLYI:xvD=#', 00H		; proggy_clean_ttf_compressed_data_base85
	ORG $+3
$SG13000 DB	'ttcf', 00H
	ORG $+3
$SG13001 DB	'ttcf', 00H
	ORG $+3
$SG13002 DB	'ttcf', 00H
	ORG $+3
$SG13003 DB	'ttcf', 00H
	ORG $+3
$SG13012 DB	'ttcf', 00H
	ORG $+3
$SG13013 DB	'ttcf', 00H
	ORG $+3
$SG13014 DB	'ttcf', 00H
	ORG $+3
$SG13015 DB	'ttcf', 00H
	ORG $+3
$SG13070 DB	'cmap', 00H
	ORG $+3
$SG13071 DB	'loca', 00H
	ORG $+3
$SG13072 DB	'head', 00H
	ORG $+3
$SG13073 DB	'glyf', 00H
	ORG $+3
$SG13074 DB	'hhea', 00H
	ORG $+3
$SG13075 DB	'hmtx', 00H
	ORG $+3
$SG13076 DB	'kern', 00H
	ORG $+3
$SG13082 DB	'CFF ', 00H
	ORG $+3
$SG13088 DB	'maxp', 00H
	ORG $+3
$SG16247 DB	'..-         -XXXXXXX-    X    -           X           -X'
	DB	'XXXXXX          -          XXXXXXX..-         -X.....X-   X.X'
	DB	'   -          X.X          -X.....X          -          X....'
	DB	'.X---         -XXX.XXX-  X...X  -         X...X         -X...'
	DB	'.X           -           X....XX           -  X.X  - X.....X '
	DB	'-        X.....X        -X...X            -            X...XX'
	DB	'X          -  X.X  -X.......X-       X.......X       -X..X.X '
	DB	'          -           X.X..XX.X         -  X.X  -XXXX.XXXX-  '
	DB	'     XXXX.XXXX       -X.X X.X          -          X.X X.XX..X'
	DB	'        -  X.X  -   X.X   -          X.X          -XX   X.X  '
	DB	'       -         X.X   XXX...X       -  X.X  -   X.X   -    X'
	DB	'X    X.X    XX    -      X.X        -        X.X      X....X '
	DB	'     -  X.X  -   X.X   -   X.X    X.X    X.X   -       X.X   '
	DB	'    -       X.X       X.....X     -  X.X  -   X.X   -  X..X  '
	DB	'  X.X    X..X  -        X.X      -      X.X        X......X  '
	DB	'  -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -         X.X   X'
	DB	'X-XX   X.X         X.......X   -  X.X  -   X.X   -X..........'
	DB	'...........X-          X.X X.X-X.X X.X          X........X  -'
	DB	'  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -           X.X..X-X'
	DB	'..X.X           X.........X -XXX.XXX-   X.X   -  X..X    X.X '
	DB	'   X..X  -            X...X-X...X            X..........X-X..'
	DB	'...X-   X.X   -   X.X    X.X    X.X   -           X....X-X...'
	DB	'.X           X......XXXXX-XXXXXXX-   X.X   -    XX    X.X    '
	DB	'XX    -          X.....X-X.....X          X...X..X    -------'
	DB	'--   X.X   -          X.X          -          XXXXXXX-XXXXXXX'
	DB	'          X..X X..X   -       -XXXX.XXXX-       XXXX.XXXX    '
	DB	'   ------------------------------------X.X  X..X   -       -X'
	DB	'.......X-       X.......X       -    XX           XX    -    '
	DB	'       XX    X..X  -       - X.....X -        X.....X        '
	DB	'-   X.X           X.X   -                 X..X          -  X.'
	DB	'..X  -         X...X         -  X..X           X..X  -       '
	DB	'           XX           -   X.X   -          X.X          - X'
	DB	'...XXXXXXXXXXXXX...X -           ------------        -    X  '
	DB	'  -           X           -X.....................X-          '
	DB	'                     ----------------------------------- X...'
	DB	'XXXXXXXXXXXXX...X -                                          '
	DB	'                       -  X..X           X..X  -             '
	DB	'                                                    -   X.X  '
	DB	'         X.X   -                                             '
	DB	'                    -    XX           XX    -           ', 00H
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0ImVec2@@QAE@XZ				; ImVec2::ImVec2
PUBLIC	??0ImVec2@@QAE@MM@Z				; ImVec2::ImVec2
PUBLIC	??0ImVec4@@QAE@XZ				; ImVec4::ImVec4
PUBLIC	??0ImVec4@@QAE@MMMM@Z				; ImVec4::ImVec4
PUBLIC	??0?$ImVector@D@@QAE@XZ				; ImVector<char>::ImVector<char>
PUBLIC	??1?$ImVector@D@@QAE@XZ				; ImVector<char>::~ImVector<char>
PUBLIC	??0ImDrawCmd@@QAE@XZ				; ImDrawCmd::ImDrawCmd
PUBLIC	??0?$ImVector@UImDrawCmd@@@@QAE@XZ		; ImVector<ImDrawCmd>::ImVector<ImDrawCmd>
PUBLIC	??1?$ImVector@UImDrawCmd@@@@QAE@XZ		; ImVector<ImDrawCmd>::~ImVector<ImDrawCmd>
PUBLIC	??A?$ImVector@UImDrawCmd@@@@QAEAAUImDrawCmd@@H@Z ; ImVector<ImDrawCmd>::operator[]
PUBLIC	?clear@?$ImVector@UImDrawCmd@@@@QAEXXZ		; ImVector<ImDrawCmd>::clear
PUBLIC	?back@?$ImVector@UImDrawCmd@@@@QAEAAUImDrawCmd@@XZ ; ImVector<ImDrawCmd>::back
PUBLIC	?_grow_capacity@?$ImVector@UImDrawCmd@@@@QAEHH@Z ; ImVector<ImDrawCmd>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImDrawCmd@@@@QAEXH@Z	; ImVector<ImDrawCmd>::resize
PUBLIC	?reserve@?$ImVector@UImDrawCmd@@@@QAEXH@Z	; ImVector<ImDrawCmd>::reserve
PUBLIC	?push_back@?$ImVector@UImDrawCmd@@@@QAEXABUImDrawCmd@@@Z ; ImVector<ImDrawCmd>::push_back
PUBLIC	?pop_back@?$ImVector@UImDrawCmd@@@@QAEXXZ	; ImVector<ImDrawCmd>::pop_back
PUBLIC	??0?$ImVector@G@@QAE@XZ				; ImVector<unsigned short>::ImVector<unsigned short>
PUBLIC	??1?$ImVector@G@@QAE@XZ				; ImVector<unsigned short>::~ImVector<unsigned short>
PUBLIC	?empty@?$ImVector@G@@QBE_NXZ			; ImVector<unsigned short>::empty
PUBLIC	??A?$ImVector@G@@QAEAAGH@Z			; ImVector<unsigned short>::operator[]
PUBLIC	??A?$ImVector@G@@QBEABGH@Z			; ImVector<unsigned short>::operator[]
PUBLIC	?clear@?$ImVector@G@@QAEXXZ			; ImVector<unsigned short>::clear
PUBLIC	?_grow_capacity@?$ImVector@G@@QAEHH@Z		; ImVector<unsigned short>::_grow_capacity
PUBLIC	?resize@?$ImVector@G@@QAEXH@Z			; ImVector<unsigned short>::resize
PUBLIC	?reserve@?$ImVector@G@@QAEXH@Z			; ImVector<unsigned short>::reserve
PUBLIC	??0ImDrawChannel@@QAE@XZ			; ImDrawChannel::ImDrawChannel
PUBLIC	??0?$ImVector@UImDrawVert@@@@QAE@XZ		; ImVector<ImDrawVert>::ImVector<ImDrawVert>
PUBLIC	??1?$ImVector@UImDrawVert@@@@QAE@XZ		; ImVector<ImDrawVert>::~ImVector<ImDrawVert>
PUBLIC	??A?$ImVector@UImDrawVert@@@@QAEAAUImDrawVert@@H@Z ; ImVector<ImDrawVert>::operator[]
PUBLIC	?clear@?$ImVector@UImDrawVert@@@@QAEXXZ		; ImVector<ImDrawVert>::clear
PUBLIC	?swap@?$ImVector@UImDrawVert@@@@QAEXAAV1@@Z	; ImVector<ImDrawVert>::swap
PUBLIC	?_grow_capacity@?$ImVector@UImDrawVert@@@@QAEHH@Z ; ImVector<ImDrawVert>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImDrawVert@@@@QAEXH@Z	; ImVector<ImDrawVert>::resize
PUBLIC	?reserve@?$ImVector@UImDrawVert@@@@QAEXH@Z	; ImVector<ImDrawVert>::reserve
PUBLIC	?clear@?$ImVector@UImVec4@@@@QAEXXZ		; ImVector<ImVec4>::clear
PUBLIC	?back@?$ImVector@UImVec4@@@@QAEAAUImVec4@@XZ	; ImVector<ImVec4>::back
PUBLIC	?_grow_capacity@?$ImVector@UImVec4@@@@QAEHH@Z	; ImVector<ImVec4>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImVec4@@@@QAEXH@Z		; ImVector<ImVec4>::resize
PUBLIC	?reserve@?$ImVector@UImVec4@@@@QAEXH@Z		; ImVector<ImVec4>::reserve
PUBLIC	?push_back@?$ImVector@UImVec4@@@@QAEXABUImVec4@@@Z ; ImVector<ImVec4>::push_back
PUBLIC	?pop_back@?$ImVector@UImVec4@@@@QAEXXZ		; ImVector<ImVec4>::pop_back
PUBLIC	?empty@?$ImVector@PAX@@QBE_NXZ			; ImVector<void *>::empty
PUBLIC	?clear@?$ImVector@PAX@@QAEXXZ			; ImVector<void *>::clear
PUBLIC	?back@?$ImVector@PAX@@QAEAAPAXXZ		; ImVector<void *>::back
PUBLIC	?_grow_capacity@?$ImVector@PAX@@QAEHH@Z		; ImVector<void *>::_grow_capacity
PUBLIC	?resize@?$ImVector@PAX@@QAEXH@Z			; ImVector<void *>::resize
PUBLIC	?reserve@?$ImVector@PAX@@QAEXH@Z		; ImVector<void *>::reserve
PUBLIC	?push_back@?$ImVector@PAX@@QAEXABQAX@Z		; ImVector<void *>::push_back
PUBLIC	?pop_back@?$ImVector@PAX@@QAEXXZ		; ImVector<void *>::pop_back
PUBLIC	?clear@?$ImVector@UImVec2@@@@QAEXXZ		; ImVector<ImVec2>::clear
PUBLIC	?back@?$ImVector@UImVec2@@@@QAEAAUImVec2@@XZ	; ImVector<ImVec2>::back
PUBLIC	?_grow_capacity@?$ImVector@UImVec2@@@@QAEHH@Z	; ImVector<ImVec2>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImVec2@@@@QAEXH@Z		; ImVector<ImVec2>::resize
PUBLIC	?reserve@?$ImVector@UImVec2@@@@QAEXH@Z		; ImVector<ImVec2>::reserve
PUBLIC	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back
PUBLIC	??A?$ImVector@UImDrawChannel@@@@QAEAAUImDrawChannel@@H@Z ; ImVector<ImDrawChannel>::operator[]
PUBLIC	?clear@?$ImVector@UImDrawChannel@@@@QAEXXZ	; ImVector<ImDrawChannel>::clear
PUBLIC	?_grow_capacity@?$ImVector@UImDrawChannel@@@@QAEHH@Z ; ImVector<ImDrawChannel>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImDrawChannel@@@@QAEXH@Z	; ImVector<ImDrawChannel>::resize
PUBLIC	?reserve@?$ImVector@UImDrawChannel@@@@QAEXH@Z	; ImVector<ImDrawChannel>::reserve
PUBLIC	?PushClipRect@ImDrawList@@QAEXUImVec2@@0_N@Z	; ImDrawList::PushClipRect
PUBLIC	?PushClipRectFullScreen@ImDrawList@@QAEXXZ	; ImDrawList::PushClipRectFullScreen
PUBLIC	?PopClipRect@ImDrawList@@QAEXXZ			; ImDrawList::PopClipRect
PUBLIC	?PushTextureID@ImDrawList@@QAEXABQAX@Z		; ImDrawList::PushTextureID
PUBLIC	?PopTextureID@ImDrawList@@QAEXXZ		; ImDrawList::PopTextureID
PUBLIC	?AddLine@ImDrawList@@QAEXABUImVec2@@0IM@Z	; ImDrawList::AddLine
PUBLIC	?AddRect@ImDrawList@@QAEXABUImVec2@@0IMHM@Z	; ImDrawList::AddRect
PUBLIC	?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
PUBLIC	?AddRectFilledMultiColor@ImDrawList@@QAEXABUImVec2@@0IIII@Z ; ImDrawList::AddRectFilledMultiColor
PUBLIC	?AddQuad@ImDrawList@@QAEXABUImVec2@@000IM@Z	; ImDrawList::AddQuad
PUBLIC	?AddQuadFilled@ImDrawList@@QAEXABUImVec2@@000I@Z ; ImDrawList::AddQuadFilled
PUBLIC	?AddTriangle@ImDrawList@@QAEXABUImVec2@@00IM@Z	; ImDrawList::AddTriangle
PUBLIC	?AddTriangleFilled@ImDrawList@@QAEXABUImVec2@@00I@Z ; ImDrawList::AddTriangleFilled
PUBLIC	?AddCircle@ImDrawList@@QAEXABUImVec2@@MIHM@Z	; ImDrawList::AddCircle
PUBLIC	?AddCircleFilled@ImDrawList@@QAEXABUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
PUBLIC	?AddText@ImDrawList@@QAEXABUImVec2@@IPBD1@Z	; ImDrawList::AddText
PUBLIC	?AddText@ImDrawList@@QAEXPBUImFont@@MABUImVec2@@IPBD2MPBUImVec4@@@Z ; ImDrawList::AddText
PUBLIC	?AddImage@ImDrawList@@QAEXPAXABUImVec2@@111I@Z	; ImDrawList::AddImage
PUBLIC	?AddPolyline@ImDrawList@@QAEXPBUImVec2@@HI_NM1@Z ; ImDrawList::AddPolyline
PUBLIC	?AddConvexPolyFilled@ImDrawList@@QAEXPBUImVec2@@HI_N@Z ; ImDrawList::AddConvexPolyFilled
PUBLIC	?AddBezierCurve@ImDrawList@@QAEXABUImVec2@@000IMH@Z ; ImDrawList::AddBezierCurve
PUBLIC	?PathClear@ImDrawList@@QAEXXZ			; ImDrawList::PathClear
PUBLIC	?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z	; ImDrawList::PathLineTo
PUBLIC	?PathFill@ImDrawList@@QAEXI@Z			; ImDrawList::PathFill
PUBLIC	?PathStroke@ImDrawList@@QAEXI_NM@Z		; ImDrawList::PathStroke
PUBLIC	?PathArcTo@ImDrawList@@QAEXABUImVec2@@MMMH@Z	; ImDrawList::PathArcTo
PUBLIC	?PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z	; ImDrawList::PathArcToFast
PUBLIC	?PathBezierCurveTo@ImDrawList@@QAEXABUImVec2@@00H@Z ; ImDrawList::PathBezierCurveTo
PUBLIC	?PathRect@ImDrawList@@QAEXABUImVec2@@0MH@Z	; ImDrawList::PathRect
PUBLIC	?ChannelsSplit@ImDrawList@@QAEXH@Z		; ImDrawList::ChannelsSplit
PUBLIC	?ChannelsMerge@ImDrawList@@QAEXXZ		; ImDrawList::ChannelsMerge
PUBLIC	?ChannelsSetCurrent@ImDrawList@@QAEXH@Z		; ImDrawList::ChannelsSetCurrent
PUBLIC	?AddCallback@ImDrawList@@QAEXP6AXPBU1@PBUImDrawCmd@@@ZPAX@Z ; ImDrawList::AddCallback
PUBLIC	?AddDrawCmd@ImDrawList@@QAEXXZ			; ImDrawList::AddDrawCmd
PUBLIC	?Clear@ImDrawList@@QAEXXZ			; ImDrawList::Clear
PUBLIC	?ClearFreeMemory@ImDrawList@@QAEXXZ		; ImDrawList::ClearFreeMemory
PUBLIC	?PrimReserve@ImDrawList@@QAEXHH@Z		; ImDrawList::PrimReserve
PUBLIC	?PrimRect@ImDrawList@@QAEXABUImVec2@@0I@Z	; ImDrawList::PrimRect
PUBLIC	?PrimRectUV@ImDrawList@@QAEXABUImVec2@@000I@Z	; ImDrawList::PrimRectUV
PUBLIC	?PrimQuadUV@ImDrawList@@QAEXABUImVec2@@0000000I@Z ; ImDrawList::PrimQuadUV
PUBLIC	?PrimWriteVtx@ImDrawList@@QAEXABUImVec2@@0I@Z	; ImDrawList::PrimWriteVtx
PUBLIC	?PrimWriteIdx@ImDrawList@@QAEXG@Z		; ImDrawList::PrimWriteIdx
PUBLIC	?UpdateClipRect@ImDrawList@@QAEXXZ		; ImDrawList::UpdateClipRect
PUBLIC	?UpdateTextureID@ImDrawList@@QAEXXZ		; ImDrawList::UpdateTextureID
PUBLIC	?DeIndexAllBuffers@ImDrawData@@QAEXXZ		; ImDrawData::DeIndexAllBuffers
PUBLIC	?ScaleClipRects@ImDrawData@@QAEXABUImVec2@@@Z	; ImDrawData::ScaleClipRects
PUBLIC	??0ImFontConfig@@QAE@XZ				; ImFontConfig::ImFontConfig
PUBLIC	??0ImFontAtlas@@QAE@XZ				; ImFontAtlas::ImFontAtlas
PUBLIC	??1ImFontAtlas@@QAE@XZ				; ImFontAtlas::~ImFontAtlas
PUBLIC	?AddFont@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z ; ImFontAtlas::AddFont
PUBLIC	?AddFontDefault@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z ; ImFontAtlas::AddFontDefault
PUBLIC	?AddFontFromFileTTF@ImFontAtlas@@QAEPAUImFont@@PBDMPBUImFontConfig@@PBG@Z ; ImFontAtlas::AddFontFromFileTTF
PUBLIC	?AddFontFromMemoryTTF@ImFontAtlas@@QAEPAUImFont@@PAXHMPBUImFontConfig@@PBG@Z ; ImFontAtlas::AddFontFromMemoryTTF
PUBLIC	?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QAEPAUImFont@@PBXHMPBUImFontConfig@@PBG@Z ; ImFontAtlas::AddFontFromMemoryCompressedTTF
PUBLIC	?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QAEPAUImFont@@PBDMPBUImFontConfig@@PBG@Z ; ImFontAtlas::AddFontFromMemoryCompressedBase85TTF
PUBLIC	?ClearTexData@ImFontAtlas@@QAEXXZ		; ImFontAtlas::ClearTexData
PUBLIC	?ClearInputData@ImFontAtlas@@QAEXXZ		; ImFontAtlas::ClearInputData
PUBLIC	?ClearFonts@ImFontAtlas@@QAEXXZ			; ImFontAtlas::ClearFonts
PUBLIC	?Clear@ImFontAtlas@@QAEXXZ			; ImFontAtlas::Clear
PUBLIC	?GetTexDataAsAlpha8@ImFontAtlas@@QAEXPAPAEPAH11@Z ; ImFontAtlas::GetTexDataAsAlpha8
PUBLIC	?GetTexDataAsRGBA32@ImFontAtlas@@QAEXPAPAEPAH11@Z ; ImFontAtlas::GetTexDataAsRGBA32
PUBLIC	?GetGlyphRangesDefault@ImFontAtlas@@QAEPBGXZ	; ImFontAtlas::GetGlyphRangesDefault
PUBLIC	?GetGlyphRangesKorean@ImFontAtlas@@QAEPBGXZ	; ImFontAtlas::GetGlyphRangesKorean
PUBLIC	?GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ	; ImFontAtlas::GetGlyphRangesJapanese
PUBLIC	?GetGlyphRangesChinese@ImFontAtlas@@QAEPBGXZ	; ImFontAtlas::GetGlyphRangesChinese
PUBLIC	?GetGlyphRangesCyrillic@ImFontAtlas@@QAEPBGXZ	; ImFontAtlas::GetGlyphRangesCyrillic
PUBLIC	?GetGlyphRangesThai@ImFontAtlas@@QAEPBGXZ	; ImFontAtlas::GetGlyphRangesThai
PUBLIC	??0?$ImVector@PAUImFont@@@@QAE@XZ		; ImVector<ImFont *>::ImVector<ImFont *>
PUBLIC	??1?$ImVector@PAUImFont@@@@QAE@XZ		; ImVector<ImFont *>::~ImVector<ImFont *>
PUBLIC	??A?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@H@Z	; ImVector<ImFont *>::operator[]
PUBLIC	?clear@?$ImVector@PAUImFont@@@@QAEXXZ		; ImVector<ImFont *>::clear
PUBLIC	?back@?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@XZ ; ImVector<ImFont *>::back
PUBLIC	?_grow_capacity@?$ImVector@PAUImFont@@@@QAEHH@Z	; ImVector<ImFont *>::_grow_capacity
PUBLIC	?reserve@?$ImVector@PAUImFont@@@@QAEXH@Z	; ImVector<ImFont *>::reserve
PUBLIC	?push_back@?$ImVector@PAUImFont@@@@QAEXABQAUImFont@@@Z ; ImVector<ImFont *>::push_back
PUBLIC	??0?$ImVector@UImFontConfig@@@@QAE@XZ		; ImVector<ImFontConfig>::ImVector<ImFontConfig>
PUBLIC	??1?$ImVector@UImFontConfig@@@@QAE@XZ		; ImVector<ImFontConfig>::~ImVector<ImFontConfig>
PUBLIC	?empty@?$ImVector@UImFontConfig@@@@QBE_NXZ	; ImVector<ImFontConfig>::empty
PUBLIC	??A?$ImVector@UImFontConfig@@@@QAEAAUImFontConfig@@H@Z ; ImVector<ImFontConfig>::operator[]
PUBLIC	?clear@?$ImVector@UImFontConfig@@@@QAEXXZ	; ImVector<ImFontConfig>::clear
PUBLIC	?back@?$ImVector@UImFontConfig@@@@QAEAAUImFontConfig@@XZ ; ImVector<ImFontConfig>::back
PUBLIC	?_grow_capacity@?$ImVector@UImFontConfig@@@@QAEHH@Z ; ImVector<ImFontConfig>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImFontConfig@@@@QAEXH@Z	; ImVector<ImFontConfig>::reserve
PUBLIC	?push_back@?$ImVector@UImFontConfig@@@@QAEXABUImFontConfig@@@Z ; ImVector<ImFontConfig>::push_back
PUBLIC	?Build@ImFontAtlas@@QAE_NXZ			; ImFontAtlas::Build
PUBLIC	?RenderCustomTexData@ImFontAtlas@@QAEXHPAX@Z	; ImFontAtlas::RenderCustomTexData
PUBLIC	??0?$ImVector@UGlyph@ImFont@@@@QAE@XZ		; ImVector<ImFont::Glyph>::ImVector<ImFont::Glyph>
PUBLIC	??1?$ImVector@UGlyph@ImFont@@@@QAE@XZ		; ImVector<ImFont::Glyph>::~ImVector<ImFont::Glyph>
PUBLIC	??A?$ImVector@UGlyph@ImFont@@@@QAEAAUGlyph@ImFont@@H@Z ; ImVector<ImFont::Glyph>::operator[]
PUBLIC	?clear@?$ImVector@UGlyph@ImFont@@@@QAEXXZ	; ImVector<ImFont::Glyph>::clear
PUBLIC	?back@?$ImVector@UGlyph@ImFont@@@@QAEAAUGlyph@ImFont@@XZ ; ImVector<ImFont::Glyph>::back
PUBLIC	?_grow_capacity@?$ImVector@UGlyph@ImFont@@@@QAEHH@Z ; ImVector<ImFont::Glyph>::_grow_capacity
PUBLIC	?resize@?$ImVector@UGlyph@ImFont@@@@QAEXH@Z	; ImVector<ImFont::Glyph>::resize
PUBLIC	?reserve@?$ImVector@UGlyph@ImFont@@@@QAEXH@Z	; ImVector<ImFont::Glyph>::reserve
PUBLIC	??0?$ImVector@M@@QAE@XZ				; ImVector<float>::ImVector<float>
PUBLIC	??1?$ImVector@M@@QAE@XZ				; ImVector<float>::~ImVector<float>
PUBLIC	??A?$ImVector@M@@QAEAAMH@Z			; ImVector<float>::operator[]
PUBLIC	??A?$ImVector@M@@QBEABMH@Z			; ImVector<float>::operator[]
PUBLIC	?clear@?$ImVector@M@@QAEXXZ			; ImVector<float>::clear
PUBLIC	?_grow_capacity@?$ImVector@M@@QAEHH@Z		; ImVector<float>::_grow_capacity
PUBLIC	?resize@?$ImVector@M@@QAEXH@Z			; ImVector<float>::resize
PUBLIC	?reserve@?$ImVector@M@@QAEXH@Z			; ImVector<float>::reserve
PUBLIC	??0ImFont@@QAE@XZ				; ImFont::ImFont
PUBLIC	??1ImFont@@QAE@XZ				; ImFont::~ImFont
PUBLIC	?Clear@ImFont@@QAEXXZ				; ImFont::Clear
PUBLIC	?BuildLookupTable@ImFont@@QAEXXZ		; ImFont::BuildLookupTable
PUBLIC	?FindGlyph@ImFont@@QBEPBUGlyph@1@G@Z		; ImFont::FindGlyph
PUBLIC	?SetFallbackChar@ImFont@@QAEXG@Z		; ImFont::SetFallbackChar
PUBLIC	?CalcTextSizeA@ImFont@@QBE?AUImVec2@@MMMPBD0PAPBD@Z ; ImFont::CalcTextSizeA
PUBLIC	?CalcWordWrapPositionA@ImFont@@QBEPBDMPBD0M@Z	; ImFont::CalcWordWrapPositionA
PUBLIC	?RenderChar@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IG@Z ; ImFont::RenderChar
PUBLIC	?RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z ; ImFont::RenderText
PUBLIC	?GrowIndex@ImFont@@QAEXH@Z			; ImFont::GrowIndex
PUBLIC	?AddRemapChar@ImFont@@QAEXGG_N@Z		; ImFont::AddRemapChar
PUBLIC	??_GImFont@@QAEPAXI@Z				; ImFont::`scalar deleting destructor'
PUBLIC	_cosf
PUBLIC	_fabsf
PUBLIC	_sinf
PUBLIC	_sqrtf
PUBLIC	??2@YAPAXIUImPlacementNewDummy@@PAX@Z		; operator new
PUBLIC	??3@YAXPAXUImPlacementNewDummy@@0@Z		; operator delete
PUBLIC	??0ImRect@@QAE@XZ				; ImRect::ImRect
PUBLIC	??0ImRect@@QAE@ABUImVec2@@0@Z			; ImRect::ImRect
PUBLIC	??0ImRect@@QAE@ABUImVec4@@@Z			; ImRect::ImRect
PUBLIC	??0ImRect@@QAE@MMMM@Z				; ImRect::ImRect
PUBLIC	?GetCenter@ImRect@@QBE?AUImVec2@@XZ		; ImRect::GetCenter
PUBLIC	?GetSize@ImRect@@QBE?AUImVec2@@XZ		; ImRect::GetSize
PUBLIC	?GetWidth@ImRect@@QBEMXZ			; ImRect::GetWidth
PUBLIC	?GetHeight@ImRect@@QBEMXZ			; ImRect::GetHeight
PUBLIC	?GetTL@ImRect@@QBE?AUImVec2@@XZ			; ImRect::GetTL
PUBLIC	?GetTR@ImRect@@QBE?AUImVec2@@XZ			; ImRect::GetTR
PUBLIC	?GetBL@ImRect@@QBE?AUImVec2@@XZ			; ImRect::GetBL
PUBLIC	?GetBR@ImRect@@QBE?AUImVec2@@XZ			; ImRect::GetBR
PUBLIC	?Contains@ImRect@@QBE_NABUImVec2@@@Z		; ImRect::Contains
PUBLIC	?Contains@ImRect@@QBE_NABU1@@Z			; ImRect::Contains
PUBLIC	?Overlaps@ImRect@@QBE_NABU1@@Z			; ImRect::Overlaps
PUBLIC	?Add@ImRect@@QAEXABUImVec2@@@Z			; ImRect::Add
PUBLIC	?Add@ImRect@@QAEXABU1@@Z			; ImRect::Add
PUBLIC	?Expand@ImRect@@QAEXM@Z				; ImRect::Expand
PUBLIC	?Expand@ImRect@@QAEXABUImVec2@@@Z		; ImRect::Expand
PUBLIC	?Translate@ImRect@@QAEXABUImVec2@@@Z		; ImRect::Translate
PUBLIC	?Clip@ImRect@@QBEXAAU1@@Z			; ImRect::Clip
PUBLIC	?Floor@ImRect@@QAEXXZ				; ImRect::Floor
PUBLIC	?GetClosestPoint@ImRect@@QBE?AUImVec2@@U2@_N@Z	; ImRect::GetClosestPoint
PUBLIC	??4ImRect@@QAEAAU0@ABU0@@Z			; ImRect::operator=
PUBLIC	??4ImRect@@QAEAAU0@$$QAU0@@Z			; ImRect::operator=
PUBLIC	??4ImGuiSimpleColumns@@QAEAAU0@ABU0@@Z		; ImGuiSimpleColumns::operator=
PUBLIC	??4ImGuiSimpleColumns@@QAEAAU0@$$QAU0@@Z	; ImGuiSimpleColumns::operator=
PUBLIC	??0ImGuiTextEditState@@QAE@XZ			; ImGuiTextEditState::ImGuiTextEditState
PUBLIC	?CursorAnimReset@ImGuiTextEditState@@QAEXXZ	; ImGuiTextEditState::CursorAnimReset
PUBLIC	?CursorClamp@ImGuiTextEditState@@QAEXXZ		; ImGuiTextEditState::CursorClamp
PUBLIC	?HasSelection@ImGuiTextEditState@@QBE_NXZ	; ImGuiTextEditState::HasSelection
PUBLIC	?ClearSelection@ImGuiTextEditState@@QAEXXZ	; ImGuiTextEditState::ClearSelection
PUBLIC	?SelectAll@ImGuiTextEditState@@QAEXXZ		; ImGuiTextEditState::SelectAll
PUBLIC	??1ImGuiTextEditState@@QAE@XZ			; ImGuiTextEditState::~ImGuiTextEditState
PUBLIC	??4ImGuiTextEditState@@QAEAAU0@ABU0@@Z		; ImGuiTextEditState::operator=
PUBLIC	??4ImGuiTextEditState@@QAEAAU0@$$QAU0@@Z	; ImGuiTextEditState::operator=
PUBLIC	??0?$ImVector@PAUImGuiWindow@@@@QAE@XZ		; ImVector<ImGuiWindow *>::ImVector<ImGuiWindow *>
PUBLIC	??1?$ImVector@PAUImGuiWindow@@@@QAE@XZ		; ImVector<ImGuiWindow *>::~ImVector<ImGuiWindow *>
PUBLIC	??0?$ImVector@H@@QAE@XZ				; ImVector<int>::ImVector<int>
PUBLIC	??1?$ImVector@H@@QAE@XZ				; ImVector<int>::~ImVector<int>
PUBLIC	??0?$ImVector@UImGuiGroupData@@@@QAE@XZ		; ImVector<ImGuiGroupData>::ImVector<ImGuiGroupData>
PUBLIC	??1?$ImVector@UImGuiGroupData@@@@QAE@XZ		; ImVector<ImGuiGroupData>::~ImVector<ImGuiGroupData>
PUBLIC	??0?$ImVector@UImGuiColumnData@@@@QAE@XZ	; ImVector<ImGuiColumnData>::ImVector<ImGuiColumnData>
PUBLIC	??1?$ImVector@UImGuiColumnData@@@@QAE@XZ	; ImVector<ImGuiColumnData>::~ImVector<ImGuiColumnData>
PUBLIC	??0ImGuiDrawContext@@QAE@XZ			; ImGuiDrawContext::ImGuiDrawContext
PUBLIC	??1ImGuiDrawContext@@QAE@XZ			; ImGuiDrawContext::~ImGuiDrawContext
PUBLIC	??4ImGuiDrawContext@@QAEAAU0@ABU0@@Z		; ImGuiDrawContext::operator=
PUBLIC	??4ImGuiDrawContext@@QAEAAU0@$$QAU0@@Z		; ImGuiDrawContext::operator=
PUBLIC	?Rect@ImGuiWindow@@QBE?AUImRect@@XZ		; ImGuiWindow::Rect
PUBLIC	?CalcFontSize@ImGuiWindow@@QBEMXZ		; ImGuiWindow::CalcFontSize
PUBLIC	?TitleBarHeight@ImGuiWindow@@QBEMXZ		; ImGuiWindow::TitleBarHeight
PUBLIC	?TitleBarRect@ImGuiWindow@@QBE?AUImRect@@XZ	; ImGuiWindow::TitleBarRect
PUBLIC	?MenuBarHeight@ImGuiWindow@@QBEMXZ		; ImGuiWindow::MenuBarHeight
PUBLIC	?MenuBarRect@ImGuiWindow@@QBE?AUImRect@@XZ	; ImGuiWindow::MenuBarRect
PUBLIC	??4ImGuiWindow@@QAEAAU0@ABU0@@Z			; ImGuiWindow::operator=
PUBLIC	__MarkAllocaS
PUBLIC	__MallocaComputeSize
PUBLIC	??0?$ImVector@Ustbrp_rect@@@@QAE@XZ		; ImVector<stbrp_rect>::ImVector<stbrp_rect>
PUBLIC	??1?$ImVector@Ustbrp_rect@@@@QAE@XZ		; ImVector<stbrp_rect>::~ImVector<stbrp_rect>
PUBLIC	??A?$ImVector@Ustbrp_rect@@@@QAEAAUstbrp_rect@@H@Z ; ImVector<stbrp_rect>::operator[]
PUBLIC	?_grow_capacity@?$ImVector@Ustbrp_rect@@@@QAEHH@Z ; ImVector<stbrp_rect>::_grow_capacity
PUBLIC	?reserve@?$ImVector@Ustbrp_rect@@@@QAEXH@Z	; ImVector<stbrp_rect>::reserve
PUBLIC	?push_back@?$ImVector@Ustbrp_rect@@@@QAEXABUstbrp_rect@@@Z ; ImVector<stbrp_rect>::push_back
PUBLIC	?_Hash_seq@std@@YAIPBEI@Z			; std::_Hash_seq
PUBLIC	??R?$_Bitwise_hash@G@std@@QBEIABG@Z		; std::_Bitwise_hash<unsigned short>::operator()
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ ; std::_Iterator_base0::_Getcont
PUBLIC	?_Allocate@std@@YAPAXII_N@Z			; std::_Allocate
PUBLIC	?_Deallocate@std@@YAXPAXII@Z			; std::_Deallocate
PUBLIC	??0?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@QAE@U?$hash@G@1@U?$equal_to@G@1@@Z ; std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >
PUBLIC	??R?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@QBEIABG@Z ; std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >::operator()
PUBLIC	??R?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@QBE_NABG0@Z ; std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >::operator()
PUBLIC	?_Gethash@?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@QBEABU?$hash@G@2@XZ ; std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >::_Gethash
PUBLIC	?_Getkeyeq@?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@QBEABU?$equal_to@G@2@XZ ; std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >::_Getkeyeq
PUBLIC	?_Get_max_bucket_size@?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@QAEAAMXZ ; std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >::_Get_max_bucket_size
PUBLIC	?_Get_max_bucket_size@?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@QBEABMXZ ; std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >::_Get_max_bucket_size
PUBLIC	??R?$equal_to@G@std@@QBE_NABG0@Z		; std::equal_to<unsigned short>::operator()
PUBLIC	?_Get_first@?$_Compressed_pair@U?$equal_to@G@std@@M$00@std@@QBEABU?$equal_to@G@2@XZ ; std::_Compressed_pair<std::equal_to<unsigned short>,float,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$equal_to@G@std@@M$00@std@@QAEAAMXZ ; std::_Compressed_pair<std::equal_to<unsigned short>,float,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$equal_to@G@std@@M$00@std@@QBEABMXZ ; std::_Compressed_pair<std::equal_to<unsigned short>,float,1>::_Get_second
PUBLIC	?_Get_first@?$_Compressed_pair@U?$hash@G@std@@V?$_Compressed_pair@U?$equal_to@G@std@@M$00@2@$00@std@@QBEABU?$hash@G@2@XZ ; std::_Compressed_pair<std::hash<unsigned short>,std::_Compressed_pair<std::equal_to<unsigned short>,float,1>,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$hash@G@std@@V?$_Compressed_pair@U?$equal_to@G@std@@M$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$equal_to@G@std@@M$00@2@XZ ; std::_Compressed_pair<std::hash<unsigned short>,std::_Compressed_pair<std::equal_to<unsigned short>,float,1>,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$hash@G@std@@V?$_Compressed_pair@U?$equal_to@G@std@@M$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$equal_to@G@std@@M$00@2@XZ ; std::_Compressed_pair<std::hash<unsigned short>,std::_Compressed_pair<std::equal_to<unsigned short>,float,1>,1>::_Get_second
PUBLIC	??0?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@QAE@ABV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@1@@Z ; std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0>::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0>
PUBLIC	?_Kfn@?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@SAABGABG@Z ; std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0>::_Kfn
PUBLIC	??0?$allocator@G@std@@QAE@XZ			; std::allocator<unsigned short>::allocator<unsigned short>
PUBLIC	?deallocate@?$allocator@U?$_List_node@GPAX@std@@@std@@QAEXPAU?$_List_node@GPAX@2@I@Z ; std::allocator<std::_List_node<unsigned short,void *> >::deallocate
PUBLIC	?allocate@?$allocator@U?$_List_node@GPAX@std@@@std@@QAEPAU?$_List_node@GPAX@2@I@Z ; std::allocator<std::_List_node<unsigned short,void *> >::allocate
PUBLIC	?max_size@?$allocator@U?$_List_node@GPAX@std@@@std@@QBEIXZ ; std::allocator<std::_List_node<unsigned short,void *> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@GPAX@std@@@2@@Z ; std::allocator_traits<std::allocator<std::_List_node<unsigned short,void *> > >::max_size
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@QAEPAU?$_List_node@GPAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@QAEXPAU?$_List_node@GPAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >::max_size
PUBLIC	?_Nextnode@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@SAAAPAU?$_List_node@GPAX@2@PAU32@@Z ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Nextnode
PUBLIC	?_Prevnode@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@SAAAPAU?$_List_node@GPAX@2@PAU32@@Z ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Prevnode
PUBLIC	?_Myval@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@SAAAGPAU?$_List_node@GPAX@2@@Z ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Myval
PUBLIC	??1?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@XZ ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::~_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >
PUBLIC	?_Buyheadnode@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEPAU?$_List_node@GPAX@2@XZ ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Buyheadnode
PUBLIC	?_Freeheadnode@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEXPAU?$_List_node@GPAX@2@@Z ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Freeheadnode
PUBLIC	?_Buynode0@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEPAU?$_List_node@GPAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Buynode0
PUBLIC	?_Getal@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@2@XZ ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Getal
PUBLIC	?_Getal@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@2@XZ ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Getal
PUBLIC	?_Get_data@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAV?$_List_val@U?$_List_simple_types@G@std@@@2@XZ ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Get_data
PUBLIC	?_Get_data@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABV?$_List_val@U?$_List_simple_types@G@std@@@2@XZ ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Get_data
PUBLIC	?_Myhead@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAPAU?$_List_node@GPAX@2@XZ ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Myhead
PUBLIC	?_Myhead@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABQAU?$_List_node@GPAX@2@XZ ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Myhead
PUBLIC	?_Mysize@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAIXZ ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Mysize
PUBLIC	?_Mysize@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABIXZ ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Mysize
PUBLIC	??0?$_List_val@U?$_List_simple_types@G@std@@@std@@QAE@XZ ; std::_List_val<std::_List_simple_types<unsigned short> >::_List_val<std::_List_simple_types<unsigned short> >
PUBLIC	?_Nextnode@?$_List_val@U?$_List_simple_types@G@std@@@std@@SAAAPAU?$_List_node@GPAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<unsigned short> >::_Nextnode
PUBLIC	?_Prevnode@?$_List_val@U?$_List_simple_types@G@std@@@std@@SAAAPAU?$_List_node@GPAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<unsigned short> >::_Prevnode
PUBLIC	?_Myval@?$_List_val@U?$_List_simple_types@G@std@@@std@@SAAAGPAU?$_List_node@GPAX@2@@Z ; std::_List_val<std::_List_simple_types<unsigned short> >::_Myval
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@G@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >,std::_List_val<std::_List_simple_types<unsigned short> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@G@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >,std::_List_val<std::_List_simple_types<unsigned short> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@G@std@@@2@$00@std@@QAEAAV?$_List_val@U?$_List_simple_types@G@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >,std::_List_val<std::_List_simple_types<unsigned short> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@G@std@@@2@$00@std@@QBEABV?$_List_val@U?$_List_simple_types@G@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >,std::_List_val<std::_List_simple_types<unsigned short> >,1>::_Get_second
PUBLIC	?_Freenode@?$_List_buy@GV?$allocator@G@std@@@std@@QAEXPAU?$_List_node@GPAX@2@@Z ; std::_List_buy<unsigned short,std::allocator<unsigned short> >::_Freenode
PUBLIC	??1?$_List_buy@GV?$allocator@G@std@@@std@@QAE@XZ ; std::_List_buy<unsigned short,std::allocator<unsigned short> >::~_List_buy<unsigned short,std::allocator<unsigned short> >
PUBLIC	??0?$list@GV?$allocator@G@std@@@std@@QAE@ABV?$allocator@G@1@@Z ; std::list<unsigned short,std::allocator<unsigned short> >::list<unsigned short,std::allocator<unsigned short> >
PUBLIC	??1?$list@GV?$allocator@G@std@@@std@@QAE@XZ	; std::list<unsigned short,std::allocator<unsigned short> >::~list<unsigned short,std::allocator<unsigned short> >
PUBLIC	?begin@?$list@GV?$allocator@G@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@XZ ; std::list<unsigned short,std::allocator<unsigned short> >::begin
PUBLIC	?end@?$list@GV?$allocator@G@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@XZ ; std::list<unsigned short,std::allocator<unsigned short> >::end
PUBLIC	?_Unchecked_begin@?$list@GV?$allocator@G@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@XZ ; std::list<unsigned short,std::allocator<unsigned short> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$list@GV?$allocator@G@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@XZ ; std::list<unsigned short,std::allocator<unsigned short> >::_Unchecked_end
PUBLIC	?_Unchecked_end@?$list@GV?$allocator@G@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::list<unsigned short,std::allocator<unsigned short> >::_Unchecked_end
PUBLIC	?_Make_iter@?$list@GV?$allocator@G@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@@Z ; std::list<unsigned short,std::allocator<unsigned short> >::_Make_iter
PUBLIC	?_Make_iter@?$list@GV?$allocator@G@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::list<unsigned short,std::allocator<unsigned short> >::_Make_iter
PUBLIC	?size@?$list@GV?$allocator@G@std@@@std@@QBEIXZ	; std::list<unsigned short,std::allocator<unsigned short> >::size
PUBLIC	?max_size@?$list@GV?$allocator@G@std@@@std@@QBEIXZ ; std::list<unsigned short,std::allocator<unsigned short> >::max_size
PUBLIC	?front@?$list@GV?$allocator@G@std@@@std@@QAEAAGXZ ; std::list<unsigned short,std::allocator<unsigned short> >::front
PUBLIC	?_Unlinknode@?$list@GV?$allocator@G@std@@@std@@QAEPAU?$_List_node@GPAX@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@@Z ; std::list<unsigned short,std::allocator<unsigned short> >::_Unlinknode
PUBLIC	?erase@?$list@GV?$allocator@G@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@@Z ; std::list<unsigned short,std::allocator<unsigned short> >::erase
PUBLIC	?clear@?$list@GV?$allocator@G@std@@@std@@QAEXXZ	; std::list<unsigned short,std::allocator<unsigned short> >::clear
PUBLIC	?_Unchecked_splice@?$list@GV?$allocator@G@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@00@Z ; std::list<unsigned short,std::allocator<unsigned short> >::_Unchecked_splice
PUBLIC	?_Tidy@?$list@GV?$allocator@G@std@@@std@@QAEXXZ	; std::list<unsigned short,std::allocator<unsigned short> >::_Tidy
PUBLIC	?_Incsize@?$list@GV?$allocator@G@std@@@std@@QAEXI@Z ; std::list<unsigned short,std::allocator<unsigned short> >::_Incsize
PUBLIC	??0?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@1@ABV?$allocator@G@1@@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >
PUBLIC	??1?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE@XZ ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::~_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >
PUBLIC	?end@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@XZ ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::end
PUBLIC	?_Unchecked_begin@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Unchecked_end
PUBLIC	?_Unchecked_end@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Unchecked_end
PUBLIC	?_Make_iter@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Make_iter
PUBLIC	?_Make_iter@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@V32@@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Make_iter
PUBLIC	?size@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBEIXZ ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::size
PUBLIC	?bucket_count@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBEIXZ ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::bucket_count
PUBLIC	?load_factor@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBEMXZ ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::load_factor
PUBLIC	?max_load_factor@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBEMXZ ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::max_load_factor
PUBLIC	?erase@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@V32@@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::erase
PUBLIC	?count@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBEIABG@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::count
PUBLIC	?equal_range@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@V12@@2@ABG@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::equal_range
PUBLIC	?_Destroy_if_not_nil@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Destroy_if_not_nil
PUBLIC	?_Vec_lo@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Vec_lo
PUBLIC	?_Vec_lo@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IBEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Vec_lo
PUBLIC	?_Vec_hi@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Vec_hi
PUBLIC	?_Vec_hi@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IBEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Vec_hi
PUBLIC	?_Begin@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Begin
PUBLIC	?_Begin@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Begin
PUBLIC	?_End@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_End
PUBLIC	?_End@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_End
PUBLIC	?_Erase_bucket@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEXV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@I@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Erase_bucket
PUBLIC	?_Insert_bucket@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@0I@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Insert_bucket
PUBLIC	?_Hashval@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IBEIABG@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Hashval
PUBLIC	?_Init@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEXI@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Init
PUBLIC	?_Check_size@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEXXZ ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Check_size
PUBLIC	?_Reinsert@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEXXZ ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Reinsert
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEAAMXZ ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Max_bucket_size
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IBEABMXZ ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Max_bucket_size
PUBLIC	??0?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
PUBLIC	?deallocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >::deallocate
PUBLIC	?allocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >::allocate
PUBLIC	?max_size@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@QBEIXZ ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@SAIABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@2@@Z ; std::allocator_traits<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QAE@ABU01@@Z ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >::max_size
PUBLIC	?max_size@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@SAIABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@Z ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::max_size
PUBLIC	?allocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::max_size
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Orphan_all
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Getal
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QBEABU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Getal
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Get_data
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QAEAAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QBEABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QAEAAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QBEABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Mylast
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QAEAAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Myend
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QBEABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Myend
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >,1>::_Get_second
PUBLIC	??0?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >
PUBLIC	??1?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QAE@XZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::~vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >
PUBLIC	?assign@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QAEXIABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::assign
PUBLIC	?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXI@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Reallocate_exactly
PUBLIC	?reserve@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QAEXI@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::reserve
PUBLIC	?size@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::size
PUBLIC	?max_size@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::max_size
PUBLIC	?capacity@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::capacity
PUBLIC	??A?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QAEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@I@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::operator[]
PUBLIC	??A?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QBEABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@I@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::operator[]
PUBLIC	?_Ufill@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@PAV32@IABV32@@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Ufill
PUBLIC	?_Umove_if_noexcept1@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@00U?$integral_constant@_N$00@2@@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Umove_if_noexcept1
PUBLIC	?_Umove_if_noexcept@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@00@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Umove_if_noexcept
PUBLIC	?_Destroy@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@0@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@ABEII@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Calculate_growth
PUBLIC	?_Buy@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAE_NI@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Buy
PUBLIC	?_Change_array@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@II@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Change_array
PUBLIC	?_Tidy@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXXZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Tidy
PUBLIC	?_Xlength@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Xlength
PUBLIC	??0?$unordered_set@GU?$hash@G@std@@U?$equal_to@G@2@V?$allocator@G@2@@std@@QAE@XZ ; std::unordered_set<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short>,std::allocator<unsigned short> >::unordered_set<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short>,std::allocator<unsigned short> >
PUBLIC	??1?$unordered_set@GU?$hash@G@std@@U?$equal_to@G@2@V?$allocator@G@2@@std@@QAE@XZ ; std::unordered_set<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short>,std::allocator<unsigned short> >::~unordered_set<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short>,std::allocator<unsigned short> >
PUBLIC	??$emplace@G@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@$$QAG@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::emplace<unsigned short>
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@GPAX@1@PBV?$_List_val@U?$_List_simple_types@G@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>
PUBLIC	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@QBEABGXZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>::operator*
PUBLIC	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>::operator++
PUBLIC	??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>::operator--
PUBLIC	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>::operator==
PUBLIC	??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>::operator!=
PUBLIC	?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@GPAX@2@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>::_Mynode
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QAE@PAU?$_List_node@GPAX@1@PBV?$_List_val@U?$_List_simple_types@G@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >
PUBLIC	?_Unchecked@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >::_Unchecked
PUBLIC	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QBEABGXZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >::operator*
PUBLIC	??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >::operator++
PUBLIC	??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QAE?AV01@H@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >::operator++
PUBLIC	??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >::operator==
PUBLIC	??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >::operator!=
PUBLIC	??$distance@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@@std@@YAHV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@0@0@Z ; std::distance<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > > >
PUBLIC	??$?0V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@V01@X$0A@@?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@V12@@std@@QAE@$$QAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@1@0@Z ; std::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >,std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > > >::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >,std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > > ><std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >,std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >,void,0>
PUBLIC	??$?0ABV?$allocator@G@std@@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QAE@ABV?$allocator@G@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > ><std::allocator<unsigned short> const &>
PUBLIC	??$?0AAU?$hash@G@std@@U_One_then_variadic_args_t@1@AAU?$equal_to@G@1@M@?$_Compressed_pair@U?$hash@G@std@@V?$_Compressed_pair@U?$equal_to@G@std@@M$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@AAU?$hash@G@1@$$QAU21@AAU?$equal_to@G@1@$$QAM@Z ; std::_Compressed_pair<std::hash<unsigned short>,std::_Compressed_pair<std::equal_to<unsigned short>,float,1>,1>::_Compressed_pair<std::hash<unsigned short>,std::_Compressed_pair<std::equal_to<unsigned short>,float,1>,1><std::hash<unsigned short> &,std::_One_then_variadic_args_t,std::equal_to<unsigned short> &,float>
PUBLIC	??$?0ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@@Z ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > ><std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > const &,void>
PUBLIC	??$?0ABV?$allocator@G@std@@X@?$_List_buy@GV?$allocator@G@std@@@std@@QAE@ABV?$allocator@G@1@@Z ; std::_List_buy<unsigned short,std::allocator<unsigned short> >::_List_buy<unsigned short,std::allocator<unsigned short> ><std::allocator<unsigned short> const &,void>
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QAE@PAU?$_List_node@GPAX@1@PBV?$_List_val@U?$_List_simple_types@G@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >::_List_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >
PUBLIC	??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QBEAAGXZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >::operator*
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@0AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *>
PUBLIC	??$_Fill_unchecked@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@0ABV10@@Z ; std::_Fill_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
PUBLIC	??$addressof@PAU?$_List_node@GPAX@std@@@std@@YAPAPAU?$_List_node@GPAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<unsigned short,void *> *>
PUBLIC	??$destroy@PAU?$_List_node@GPAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@GPAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >::destroy<std::_List_node<unsigned short,void *> *>
PUBLIC	??$addressof@$$CBV?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@YAPBV?$_List_val@U?$_List_simple_types@G@std@@@0@ABV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<unsigned short> > const >
PUBLIC	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QAE@PAU?$_List_node@GPAX@1@PBV?$_List_val@U?$_List_simple_types@G@std@@@1@@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >
PUBLIC	??$_Uninitialized_fill_n@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@IU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@PAV10@IABV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@0@@Z ; std::_Uninitialized_fill_n<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,unsigned int,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >
PUBLIC	??$addressof@G@std@@YAPAGAAG@Z			; std::addressof<unsigned short>
PUBLIC	??$destroy@G@?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@QAEXPAG@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >::destroy<unsigned short>
PUBLIC	??$addressof@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@G@std@@@0@AAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<unsigned short> > >
PUBLIC	??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@_Alloc_max_size@std@@SAIHABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@@Z ; std::_Alloc_max_size::_Fn<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >
PUBLIC	??$_Uninitialized_move@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >
PUBLIC	??$forward@G@std@@YA$$QAGAAG@Z			; std::forward<unsigned short>
PUBLIC	??$emplace_front@G@?$list@GV?$allocator@G@std@@@std@@QAEX$$QAG@Z ; std::list<unsigned short,std::allocator<unsigned short> >::emplace_front<unsigned short>
PUBLIC	??$_Insert@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Insert<unsigned short &,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
PUBLIC	??$_Distance1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@@std@@YAHV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@0@0Uinput_iterator_tag@0@@Z ; std::_Distance1<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > > >
PUBLIC	??$forward@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@@std@@YA$$QAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@0@AAV10@@Z ; std::forward<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > > >
PUBLIC	??$forward@ABV?$allocator@G@std@@@std@@YAABV?$allocator@G@0@ABV10@@Z ; std::forward<std::allocator<unsigned short> const &>
PUBLIC	??$?0G@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAE@ABV?$allocator@G@1@@Z ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> ><unsigned short>
PUBLIC	??$forward@AAU?$hash@G@std@@@std@@YAAAU?$hash@G@0@AAU10@@Z ; std::forward<std::hash<unsigned short> &>
PUBLIC	??$forward@U_One_then_variadic_args_t@std@@@std@@YA$$QAU_One_then_variadic_args_t@0@AAU10@@Z ; std::forward<std::_One_then_variadic_args_t>
PUBLIC	??$forward@AAU?$equal_to@G@std@@@std@@YAAAU?$equal_to@G@0@AAU10@@Z ; std::forward<std::equal_to<unsigned short> &>
PUBLIC	??$forward@M@std@@YA$$QAMAAM@Z			; std::forward<float>
PUBLIC	??$?0AAU?$equal_to@G@std@@M@?$_Compressed_pair@U?$equal_to@G@std@@M$00@std@@QAE@U_One_then_variadic_args_t@1@AAU?$equal_to@G@1@$$QAM@Z ; std::_Compressed_pair<std::equal_to<unsigned short>,float,1>::_Compressed_pair<std::equal_to<unsigned short>,float,1><std::equal_to<unsigned short> &,float>
PUBLIC	??$forward@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@YAABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@0@ABU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > const &>
PUBLIC	??$?0ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >,1><std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > const &>
PUBLIC	??$?0ABV?$allocator@G@std@@X@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@ABV?$allocator@G@1@@Z ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > ><std::allocator<unsigned short> const &,void>
PUBLIC	??$_Destroy_range1@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@0AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *>
PUBLIC	??$_Fill_memset_is_safe@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YA?AU?$integral_constant@_N$0A@@0@ABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@ABV20@@Z ; std::_Fill_memset_is_safe<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
PUBLIC	??$_Fill_unchecked1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@0ABV10@U?$integral_constant@_N$0A@@0@@Z ; std::_Fill_unchecked1<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
PUBLIC	??$destroy@PAU?$_List_node@GPAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@GPAX@std@@@1@PAPAU?$_List_node@GPAX@1@@Z ; std::allocator_traits<std::allocator<std::_List_node<unsigned short,void *> > >::destroy<std::_List_node<unsigned short,void *> *>
PUBLIC	??$_Unfancy@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@PAV10@@Z ; std::_Unfancy<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
PUBLIC	??$_Uninit_alloc_fill_n1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@IU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@PAV10@IABV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninit_alloc_fill_n1<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,unsigned int,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >
PUBLIC	??$destroy@G@?$allocator_traits@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@GPAX@std@@@1@PAG@Z ; std::allocator_traits<std::allocator<std::_List_node<unsigned short,void *> > >::destroy<unsigned short>
PUBLIC	??$_Unchecked@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@PAV10@@Z ; std::_Unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *>
PUBLIC	??$_Ptr_move_cat@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YA?AU_Trivially_copyable_ptr_iterator_tag@0@ABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@0@Z ; std::_Ptr_move_cat<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
PUBLIC	??$move@AAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA$$QAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@AAV10@@Z ; std::move<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> &>
PUBLIC	??$_Uninitialized_move_al_unchecked@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >
PUBLIC	??$?0U?$integral_constant@_N$0A@@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$0A@@1@@Z ; std::_Any_tag::_Any_tag<std::integral_constant<bool,0> >
PUBLIC	??$_Rechecked@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@PAV12@@std@@YAAAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@AAPAV10@PAV10@@Z ; std::_Rechecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *>
PUBLIC	??$_Insert@G@?$list@GV?$allocator@G@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@$$QAG@Z ; std::list<unsigned short,std::allocator<unsigned short> >::_Insert<unsigned short>
PUBLIC	??$?0V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_NX$0A@@?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >,bool>::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >,bool><std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >,bool,void,0>
PUBLIC	??$forward@AAG@std@@YAAAGAAG@Z			; std::forward<unsigned short &>
PUBLIC	??$_Buynode_if_nil@AAG@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@AAGV21@@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Buynode_if_nil<unsigned short &>
PUBLIC	??$?0ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > ><std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > const &>
PUBLIC	??$?0ABV?$allocator@G@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@G@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@G@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >,std::_List_val<std::_List_simple_types<unsigned short> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >,std::_List_val<std::_List_simple_types<unsigned short> >,1><std::allocator<unsigned short> const &>
PUBLIC	??$destroy@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::destroy<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
PUBLIC	??$destroy@PAU?$_List_node@GPAX@std@@@?$allocator@U?$_List_node@GPAX@std@@@std@@QAEXPAPAU?$_List_node@GPAX@1@@Z ; std::allocator<std::_List_node<unsigned short,void *> >::destroy<std::_List_node<unsigned short,void *> *>
PUBLIC	??$construct@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@ABV12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@ABV21@@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::construct<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> const &>
PUBLIC	??$destroy@G@?$allocator@U?$_List_node@GPAX@std@@@std@@QAEXPAG@Z ; std::allocator<std::_List_node<unsigned short,void *> >::destroy<unsigned short>
PUBLIC	??$construct@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@$$QAV21@@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::construct<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
PUBLIC	??$construct@PAU?$_List_node@GPAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@GPAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >::construct<std::_List_node<unsigned short,void *> *,std::_List_node<unsigned short,void *> * &>
PUBLIC	??$_Insert@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Insert<unsigned short const &,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
PUBLIC	??$_Buynode@G@?$_List_buy@GV?$allocator@G@std@@@std@@QAEPAU?$_List_node@GPAX@1@PAU21@0$$QAG@Z ; std::_List_buy<unsigned short,std::allocator<unsigned short> >::_Buynode<unsigned short>
PUBLIC	??$forward@_N@std@@YA$$QA_NAA_N@Z		; std::forward<bool>
PUBLIC	??$?0ABV?$allocator@G@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@QAE@ABV?$allocator@G@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > ><std::allocator<unsigned short> const &>
PUBLIC	??$destroy@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::destroy<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
PUBLIC	??$forward@ABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@ABV10@@Z ; std::forward<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> const &>
PUBLIC	??$construct@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@ABV12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@ABV31@@Z ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::construct<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> const &>
PUBLIC	??$forward@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA$$QAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@AAV10@@Z ; std::forward<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
PUBLIC	??$construct@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@$$QAV31@@Z ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::construct<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
PUBLIC	??$forward@AAPAU?$_List_node@GPAX@std@@@std@@YAAAPAU?$_List_node@GPAX@0@AAPAU10@@Z ; std::forward<std::_List_node<unsigned short,void *> * &>
PUBLIC	??$construct@PAU?$_List_node@GPAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@GPAX@std@@@1@PAPAU?$_List_node@GPAX@1@AAPAU31@@Z ; std::allocator_traits<std::allocator<std::_List_node<unsigned short,void *> > >::construct<std::_List_node<unsigned short,void *> *,std::_List_node<unsigned short,void *> * &>
PUBLIC	??$forward@ABG@std@@YAABGABG@Z			; std::forward<unsigned short const &>
PUBLIC	??$_Buynode_if_nil@ABG@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@ABGV21@@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Buynode_if_nil<unsigned short const &>
PUBLIC	??$construct@GG@?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@QAEXPAG$$QAG@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >::construct<unsigned short,unsigned short>
PUBLIC	??$?0G@?$allocator@U?$_List_node@GPAX@std@@@std@@QAE@ABV?$allocator@G@1@@Z ; std::allocator<std::_List_node<unsigned short,void *> >::allocator<std::_List_node<unsigned short,void *> ><unsigned short>
PUBLIC	??$_Destroy1@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@U?$integral_constant@_N$00@1@@Z ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Destroy1<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
PUBLIC	??$_Construct1@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@ABV12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@SAXU?$integral_constant@_N$00@1@AAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@ABV41@@Z ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Construct1<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> const &>
PUBLIC	??$_Construct1@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@SAXU?$integral_constant@_N$00@1@AAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@$$QAV41@@Z ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Construct1<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
PUBLIC	??$construct@PAU?$_List_node@GPAX@std@@AAPAU12@@?$allocator@U?$_List_node@GPAX@std@@@std@@QAEXPAPAU?$_List_node@GPAX@1@AAPAU21@@Z ; std::allocator<std::_List_node<unsigned short,void *> >::construct<std::_List_node<unsigned short,void *> *,std::_List_node<unsigned short,void *> * &>
PUBLIC	??$construct@GG@?$allocator_traits@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@GPAX@std@@@1@PAG$$QAG@Z ; std::allocator_traits<std::allocator<std::_List_node<unsigned short,void *> > >::construct<unsigned short,unsigned short>
PUBLIC	??$construct@GG@?$allocator@U?$_List_node@GPAX@std@@@std@@QAEXPAG$$QAG@Z ; std::allocator<std::_List_node<unsigned short,void *> >::construct<unsigned short,unsigned short>
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@358637bd
PUBLIC	__real@37800000
PUBLIC	__real@38800000
PUBLIC	__real@3e800000
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3ffeb852
PUBLIC	__real@40400000
PUBLIC	__real@40800000
PUBLIC	__real@40c90fdb
PUBLIC	__real@40e00000
PUBLIC	__real@41100000
PUBLIC	__real@41400000
PUBLIC	__real@41500000
PUBLIC	__real@41800000
PUBLIC	__real@41880000
PUBLIC	__real@41900000
PUBLIC	__real@41980000
PUBLIC	__real@41a80000
PUBLIC	__real@41b80000
PUBLIC	__real@41f80000
PUBLIC	__real@425c0000
PUBLIC	__real@42920000
PUBLIC	__real@42b60000
PUBLIC	__real@42c80000
PUBLIC	__real@4330000000000000
PUBLIC	__real@437f0000
PUBLIC	__real@8000000000000000
PUBLIC	__real@bf800000
PUBLIC	__xmm@00000000000000004198000041400000
PUBLIC	__xmm@00000003000000020000000100000000
PUBLIC	__xmm@00000008000000080000000800000008
PUBLIC	__xmm@3daaaaab3daaaaab3daaaaab3daaaaab
PUBLIC	__xmm@3f80000000000000000000003f800000
PUBLIC	__xmm@40000000400000004000000040000000
PUBLIC	__xmm@40490fdb40490fdb40490fdb40490fdb
PUBLIC	__xmm@40a00000413000004110000041b80000
PUBLIC	__xmm@41000000408000004180000040e00000
PUBLIC	__xmm@41100000411000004188000041880000
PUBLIC	__xmm@4130000040a0000041b8000041100000
PUBLIC	__xmm@413000004130000041b8000041b80000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@7fffffff7fffffff7fffffff7fffffff
PUBLIC	__xmm@7fffffffffffffff7fffffffffffffff
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_abort:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	___std_terminate:PROC
EXTRN	__imp___invalid_parameter_noinfo_noreturn:PROC
EXTRN	?MemAlloc@ImGui@@YAPAXI@Z:PROC			; ImGui::MemAlloc
EXTRN	?MemFree@ImGui@@YAXPAX@Z:PROC			; ImGui::MemFree
EXTRN	__snprintf:PROC
EXTRN	?ImTextCharFromUtf8@@YAHPAIPBD1@Z:PROC		; ImTextCharFromUtf8
EXTRN	?ImFileLoadToMemory@@YAPAXPBD0PAHH@Z:PROC	; ImFileLoadToMemory
EXTRN	__imp__malloc:PROC
EXTRN	__imp__qsort:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	?Log@iSK_Logger@@UAAXQB_WZZ:PROC		; iSK_Logger::Log
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___libm_sse2_cosf:PROC
EXTRN	___libm_sse2_sinf:PROC
EXTRN	___vdecl_cosf4:PROC
EXTRN	___vdecl_sinf4:PROC
EXTRN	__alloca_probe_16:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_ceil:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	?GImGui@@3PAUImGuiContext@@A:DWORD		; GImGui
EXTRN	?dll_log@@3UiSK_Logger@@A:BYTE			; dll_log
EXTRN	__fltused:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
;	COMDAT ?circle_vtx@?1??PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z@4PAU3@A
_BSS	SEGMENT
?circle_vtx@?1??PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z@4PAU3@A DQ 0cH DUP (?) ; `ImDrawList::PathArcToFast'::`2'::circle_vtx
_BSS	ENDS
;	COMDAT ?$TSS0@?1??PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z@4HA
_BSS	SEGMENT
?$TSS0@?1??PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z@4HA DD 01H DUP (?) ; TSS0<`template-parameter-2',ImDrawList::thArcToFast,unsigned char * const,void,ImVec2 const &,float,int,int>
_BSS	ENDS
;	COMDAT ?circle_vtx_builds@?1??PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z@4_NA
_BSS	SEGMENT
?circle_vtx_builds@?1??PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z@4_NA DB 01H DUP (?) ; `ImDrawList::PathArcToFast'::`2'::circle_vtx_builds
_BSS	ENDS
;	COMDAT ?full_ranges_unpacked@?1??GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ@4_NA
_BSS	SEGMENT
?full_ranges_unpacked@?1??GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ@4_NA DB 01H DUP (?) ; `ImFontAtlas::GetGlyphRangesJapanese'::`2'::full_ranges_unpacked
_BSS	ENDS
;	COMDAT ?full_ranges@?1??GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ@4PAGA
_BSS	SEGMENT
?full_ranges@?1??GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ@4PAGA DW 0f3dH DUP (?) ; `ImFontAtlas::GetGlyphRangesJapanese'::`2'::full_ranges
_BSS	ENDS
;	COMDAT ?unprintable_chars@?DL@??RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z@4V?$unordered_set@GU?$hash@G@std@@U?$equal_to@G@2@V?$allocator@G@2@@std@@A
_BSS	SEGMENT
?unprintable_chars@?DL@??RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z@4V?$unordered_set@GU?$hash@G@std@@U?$equal_to@G@2@V?$allocator@G@2@@std@@A DB 020H DUP (?) ; `ImFont::RenderText'::`59'::unprintable_chars
_BSS	ENDS
;	COMDAT ?$TSS0@?DL@??RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z@4HA
_BSS	SEGMENT
?$TSS0@?DL@??RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z@4HA DD 01H DUP (?) ; TSS0<`template-parameter-59',ImFont::derText,unsigned char const * const,void,ImDrawList *,float,ImVec2,unsigned int,ImVec4 const &,char const *,ImDrawList *,float,bool>
_BSS	ENDS
_BSS	SEGMENT
?stb__barrier@@3PAEA DD 01H DUP (?)			; stb__barrier
?stb__barrier2@@3PAEA DD 01H DUP (?)			; stb__barrier2
?stb__barrier3@@3PAEA DD 01H DUP (?)			; stb__barrier3
?stb__barrier4@@3PAEA DD 01H DUP (?)			; stb__barrier4
?stb__dout@@3PAEA DD 01H DUP (?)			; stb__dout
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@7fffffffffffffff7fffffffffffffff
CONST	SEGMENT
__xmm@7fffffffffffffff7fffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __xmm@7fffffff7fffffff7fffffff7fffffff
CONST	SEGMENT
__xmm@7fffffff7fffffff7fffffff7fffffff DB 0ffH, 0ffH, 0ffH, 07fH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 07fH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __xmm@413000004130000041b8000041b80000
CONST	SEGMENT
__xmm@413000004130000041b8000041b80000 DB 00H, 00H, 0b8H, 'A', 00H, 00H, 0b8H
	DB	'A', 00H, 00H, '0A', 00H, 00H, '0A'
CONST	ENDS
;	COMDAT __xmm@4130000040a0000041b8000041100000
CONST	SEGMENT
__xmm@4130000040a0000041b8000041100000 DB 00H, 00H, 010H, 'A', 00H, 00H, 0b8H
	DB	'A', 00H, 00H, 0a0H, '@', 00H, 00H, '0A'
CONST	ENDS
;	COMDAT __xmm@41100000411000004188000041880000
CONST	SEGMENT
__xmm@41100000411000004188000041880000 DB 00H, 00H, 088H, 'A', 00H, 00H, 088H
	DB	'A', 00H, 00H, 010H, 'A', 00H, 00H, 010H, 'A'
CONST	ENDS
;	COMDAT __xmm@41000000408000004180000040e00000
CONST	SEGMENT
__xmm@41000000408000004180000040e00000 DB 00H, 00H, 0e0H, '@', 00H, 00H, 080H
	DB	'A', 00H, 00H, 080H, '@', 00H, 00H, 00H, 'A'
CONST	ENDS
;	COMDAT __xmm@40a00000413000004110000041b80000
CONST	SEGMENT
__xmm@40a00000413000004110000041b80000 DB 00H, 00H, 0b8H, 'A', 00H, 00H, 010H
	DB	'A', 00H, 00H, '0A', 00H, 00H, 0a0H, '@'
CONST	ENDS
;	COMDAT __xmm@40490fdb40490fdb40490fdb40490fdb
CONST	SEGMENT
__xmm@40490fdb40490fdb40490fdb40490fdb DB 0dbH, 0fH, 'I@', 0dbH, 0fH, 'I@'
	DB	0dbH, 0fH, 'I@', 0dbH, 0fH, 'I@'
CONST	ENDS
;	COMDAT __xmm@40000000400000004000000040000000
CONST	SEGMENT
__xmm@40000000400000004000000040000000 DB 00H, 00H, 00H, '@', 00H, 00H, 00H
	DB	'@', 00H, 00H, 00H, '@', 00H, 00H, 00H, '@'
CONST	ENDS
;	COMDAT __xmm@3f80000000000000000000003f800000
CONST	SEGMENT
__xmm@3f80000000000000000000003f800000 DB 00H, 00H, 080H, '?', 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@3daaaaab3daaaaab3daaaaab3daaaaab
CONST	SEGMENT
__xmm@3daaaaab3daaaaab3daaaaab3daaaaab DB 0abH, 0aaH, 0aaH, '=', 0abH, 0aaH
	DB	0aaH, '=', 0abH, 0aaH, 0aaH, '=', 0abH, 0aaH, 0aaH, '='
CONST	ENDS
;	COMDAT __xmm@00000008000000080000000800000008
CONST	SEGMENT
__xmm@00000008000000080000000800000008 DB 08H, 00H, 00H, 00H, 08H, 00H, 00H
	DB	00H, 08H, 00H, 00H, 00H, 08H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000003000000020000000100000000
CONST	SEGMENT
__xmm@00000003000000020000000100000000 DB 00H, 00H, 00H, 00H, 01H, 00H, 00H
	DB	00H, 02H, 00H, 00H, 00H, 03H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000000000000004198000041400000
CONST	SEGMENT
__xmm@00000000000000004198000041400000 DB 00H, 00H, '@A', 00H, 00H, 098H, 'A'
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@8000000000000000
CONST	SEGMENT
__real@8000000000000000 DQ 08000000000000000r	; -0
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@4330000000000000
CONST	SEGMENT
__real@4330000000000000 DQ 04330000000000000r	; 4.5036e+15
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42b60000
CONST	SEGMENT
__real@42b60000 DD 042b60000r			; 91
CONST	ENDS
;	COMDAT __real@42920000
CONST	SEGMENT
__real@42920000 DD 042920000r			; 73
CONST	ENDS
;	COMDAT __real@425c0000
CONST	SEGMENT
__real@425c0000 DD 0425c0000r			; 55
CONST	ENDS
;	COMDAT __real@41f80000
CONST	SEGMENT
__real@41f80000 DD 041f80000r			; 31
CONST	ENDS
;	COMDAT __real@41b80000
CONST	SEGMENT
__real@41b80000 DD 041b80000r			; 23
CONST	ENDS
;	COMDAT __real@41a80000
CONST	SEGMENT
__real@41a80000 DD 041a80000r			; 21
CONST	ENDS
;	COMDAT __real@41980000
CONST	SEGMENT
__real@41980000 DD 041980000r			; 19
CONST	ENDS
;	COMDAT __real@41900000
CONST	SEGMENT
__real@41900000 DD 041900000r			; 18
CONST	ENDS
;	COMDAT __real@41880000
CONST	SEGMENT
__real@41880000 DD 041880000r			; 17
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@41500000
CONST	SEGMENT
__real@41500000 DD 041500000r			; 13
CONST	ENDS
;	COMDAT __real@41400000
CONST	SEGMENT
__real@41400000 DD 041400000r			; 12
CONST	ENDS
;	COMDAT __real@41100000
CONST	SEGMENT
__real@41100000 DD 041100000r			; 9
CONST	ENDS
;	COMDAT __real@40e00000
CONST	SEGMENT
__real@40e00000 DD 040e00000r			; 7
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@3ffeb852
CONST	SEGMENT
__real@3ffeb852 DD 03ffeb852r			; 1.99
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@38800000
CONST	SEGMENT
__real@38800000 DD 038800000r			; 6.10352e-05
CONST	ENDS
;	COMDAT __real@37800000
CONST	SEGMENT
__real@37800000 DD 037800000r			; 1.52588e-05
CONST	ENDS
;	COMDAT __real@358637bd
CONST	SEGMENT
__real@358637bd DD 0358637bdr			; 1e-06
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ DB 'list<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?ranges@?1??GetGlyphRangesThai@ImFontAtlas@@QAEPBGXZ@4QBGB
CONST	SEGMENT
?ranges@?1??GetGlyphRangesThai@ImFontAtlas@@QAEPBGXZ@4QBGB DW 020H ; `ImFontAtlas::GetGlyphRangesThai'::`2'::ranges
	DW	0ffH
	DW	0e00H
	DW	0e7fH
	DW	00H
CONST	ENDS
;	COMDAT ?ranges@?1??GetGlyphRangesCyrillic@ImFontAtlas@@QAEPBGXZ@4QBGB
CONST	SEGMENT
?ranges@?1??GetGlyphRangesCyrillic@ImFontAtlas@@QAEPBGXZ@4QBGB DW 020H ; `ImFontAtlas::GetGlyphRangesCyrillic'::`2'::ranges
	DW	0ffH
	DW	0400H
	DW	052fH
	DW	02de0H
	DW	02dffH
	DW	0a640H
	DW	0a69fH
	DW	00H
CONST	ENDS
;	COMDAT ?base_ranges@?1??GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ@4PAGA
_DATA	SEGMENT
?base_ranges@?1??GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ@4PAGA DW 020H ; `ImFontAtlas::GetGlyphRangesJapanese'::`2'::base_ranges
	DW	0ffH
	DW	03000H
	DW	030ffH
	DW	031f0H
	DW	031ffH
	DW	0ff00H
	DW	0ffefH
_DATA	ENDS
;	COMDAT ?offsets_from_0x4E00@?1??GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ@4QBFB
CONST	SEGMENT
?offsets_from_0x4E00@?1??GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ@4QBFB DW 0ffffH ; `ImFontAtlas::GetGlyphRangesJapanese'::`2'::offsets_from_0x4E00
	DW	00H
	DW	01H
	DW	03H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	01H
	DW	00H
	DW	05H
	DW	01H
	DW	01H
	DW	00H
	DW	07H
	DW	04H
	DW	06H
	DW	0aH
	DW	00H
	DW	01H
	DW	09H
	DW	09H
	DW	07H
	DW	01H
	DW	03H
	DW	013H
	DW	01H
	DW	0aH
	DW	07H
	DW	01H
	DW	00H
	DW	01H
	DW	00H
	DW	05H
	DW	01H
	DW	00H
	DW	06H
	DW	04H
	DW	02H
	DW	06H
	DW	00H
	DW	00H
	DW	0cH
	DW	06H
	DW	08H
	DW	00H
	DW	03H
	DW	05H
	DW	00H
	DW	01H
	DW	00H
	DW	09H
	DW	00H
	DW	00H
	DW	08H
	DW	01H
	DW	01H
	DW	03H
	DW	04H
	DW	05H
	DW	0dH
	DW	00H
	DW	00H
	DW	08H
	DW	02H
	DW	011H
	DW	04H
	DW	03H
	DW	01H
	DW	01H
	DW	09H
	DW	06H
	DW	00H
	DW	00H
	DW	00H
	DW	02H
	DW	01H
	DW	03H
	DW	02H
	DW	016H
	DW	01H
	DW	09H
	DW	0bH
	DW	01H
	DW	0dH
	DW	01H
	DW	03H
	DW	0cH
	DW	00H
	DW	05H
	DW	09H
	DW	02H
	DW	00H
	DW	06H
	DW	0cH
	DW	05H
	DW	03H
	DW	0cH
	DW	04H
	DW	01H
	DW	02H
	DW	010H
	DW	01H
	DW	01H
	DW	04H
	DW	06H
	DW	05H
	DW	03H
	DW	00H
	DW	06H
	DW	0dH
	DW	0fH
	DW	05H
	DW	0cH
	DW	08H
	DW	0eH
	DW	00H
	DW	00H
	DW	06H
	DW	0fH
	DW	03H
	DW	06H
	DW	00H
	DW	012H
	DW	08H
	DW	01H
	DW	06H
	DW	0eH
	DW	01H
	DW	05H
	DW	04H
	DW	0cH
	DW	018H
	DW	03H
	DW	0dH
	DW	0cH
	DW	0aH
	DW	018H
	DW	00H
	DW	00H
	DW	00H
	DW	01H
	DW	00H
	DW	01H
	DW	01H
	DW	02H
	DW	09H
	DW	0aH
	DW	02H
	DW	02H
	DW	00H
	DW	00H
	DW	03H
	DW	03H
	DW	01H
	DW	00H
	DW	03H
	DW	08H
	DW	00H
	DW	03H
	DW	02H
	DW	04H
	DW	04H
	DW	01H
	DW	06H
	DW	0bH
	DW	0aH
	DW	0eH
	DW	06H
	DW	0fH
	DW	03H
	DW	04H
	DW	0fH
	DW	01H
	DW	00H
	DW	00H
	DW	05H
	DW	02H
	DW	02H
	DW	00H
	DW	00H
	DW	01H
	DW	06H
	DW	05H
	DW	05H
	DW	06H
	DW	00H
	DW	03H
	DW	06H
	DW	05H
	DW	00H
	DW	00H
	DW	01H
	DW	00H
	DW	0bH
	DW	02H
	DW	02H
	DW	08H
	DW	04H
	DW	07H
	DW	00H
	DW	0aH
	DW	00H
	DW	01H
	DW	02H
	DW	011H
	DW	013H
	DW	03H
	DW	00H
	DW	02H
	DW	05H
	DW	00H
	DW	06H
	DW	02H
	DW	04H
	DW	04H
	DW	06H
	DW	01H
	DW	01H
	DW	0bH
	DW	02H
	DW	00H
	DW	03H
	DW	01H
	DW	02H
	DW	01H
	DW	02H
	DW	0aH
	DW	07H
	DW	06H
	DW	03H
	DW	010H
	DW	00H
	DW	08H
	DW	018H
	DW	00H
	DW	00H
	DW	03H
	DW	01H
	DW	01H
	DW	03H
	DW	00H
	DW	01H
	DW	06H
	DW	00H
	DW	00H
	DW	00H
	DW	02H
	DW	00H
	DW	01H
	DW	05H
	DW	0fH
	DW	00H
	DW	01H
	DW	00H
	DW	00H
	DW	02H
	DW	0bH
	DW	013H
	DW	01H
	DW	04H
	DW	013H
	DW	07H
	DW	06H
	DW	05H
	DW	01H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	05H
	DW	01H
	DW	00H
	DW	01H
	DW	09H
	DW	00H
	DW	00H
	DW	05H
	DW	00H
	DW	02H
	DW	00H
	DW	01H
	DW	00H
	DW	03H
	DW	00H
	DW	0bH
	DW	03H
	DW	00H
	DW	02H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	09H
	DW	03H
	DW	06H
	DW	04H
	DW	0cH
	DW	00H
	DW	0eH
	DW	00H
	DW	00H
	DW	01dH
	DW	0aH
	DW	08H
	DW	00H
	DW	0eH
	DW	025H
	DW	0dH
	DW	00H
	DW	01fH
	DW	010H
	DW	013H
	DW	00H
	DW	08H
	DW	01eH
	DW	01H
	DW	014H
	DW	08H
	DW	03H
	DW	030H
	DW	015H
	DW	01H
	DW	00H
	DW	0cH
	DW	00H
	DW	0aH
	DW	02cH
	DW	022H
	DW	02aH
	DW	036H
	DW	0bH
	DW	012H
	DW	052H
	DW	00H
	DW	02H
	DW	01H
	DW	02H
	DW	0cH
	DW	01H
	DW	00H
	DW	06H
	DW	02H
	DW	011H
	DW	02H
	DW	0cH
	DW	07H
	DW	00H
	DW	07H
	DW	011H
	DW	04H
	DW	02H
	DW	06H
	DW	018H
	DW	017H
	DW	08H
	DW	017H
	DW	027H
	DW	02H
	DW	010H
	DW	017H
	DW	01H
	DW	00H
	DW	05H
	DW	01H
	DW	02H
	DW	0fH
	DW	0eH
	DW	05H
	DW	06H
	DW	02H
	DW	0bH
	DW	00H
	DW	08H
	DW	06H
	DW	02H
	DW	02H
	DW	02H
	DW	0eH
	DW	014H
	DW	04H
	DW	0fH
	DW	03H
	DW	04H
	DW	0bH
	DW	0aH
	DW	0aH
	DW	02H
	DW	05H
	DW	02H
	DW	01H
	DW	01eH
	DW	02H
	DW	01H
	DW	00H
	DW	00H
	DW	016H
	DW	05H
	DW	05H
	DW	00H
	DW	03H
	DW	01H
	DW	05H
	DW	04H
	DW	01H
	DW	00H
	DW	00H
	DW	02H
	DW	02H
	DW	015H
	DW	01H
	DW	05H
	DW	01H
	DW	02H
	DW	010H
	DW	02H
	DW	01H
	DW	03H
	DW	04H
	DW	00H
	DW	08H
	DW	04H
	DW	00H
	DW	00H
	DW	05H
	DW	0eH
	DW	0bH
	DW	02H
	DW	010H
	DW	01H
	DW	0dH
	DW	01H
	DW	07H
	DW	00H
	DW	016H
	DW	0fH
	DW	03H
	DW	01H
	DW	016H
	DW	07H
	DW	0eH
	DW	016H
	DW	013H
	DW	0bH
	DW	018H
	DW	012H
	DW	02eH
	DW	0aH
	DW	014H
	DW	040H
	DW	02dH
	DW	03H
	DW	02H
	DW	00H
	DW	04H
	DW	05H
	DW	00H
	DW	01H
	DW	04H
	DW	019H
	DW	01H
	DW	00H
	DW	00H
	DW	02H
	DW	0aH
	DW	00H
	DW	00H
	DW	00H
	DW	01H
	DW	00H
	DW	01H
	DW	02H
	DW	00H
	DW	00H
	DW	09H
	DW	01H
	DW	02H
	DW	00H
	DW	00H
	DW	00H
	DW	02H
	DW	05H
	DW	02H
	DW	01H
	DW	01H
	DW	05H
	DW	05H
	DW	08H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	01H
	DW	04H
	DW	09H
	DW	01H
	DW	03H
	DW	00H
	DW	01H
	DW	00H
	DW	01H
	DW	01H
	DW	02H
	DW	00H
	DW	00H
	DW	02H
	DW	00H
	DW	01H
	DW	08H
	DW	016H
	DW	08H
	DW	01H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	04H
	DW	02H
	DW	01H
	DW	00H
	DW	09H
	DW	08H
	DW	05H
	DW	00H
	DW	09H
	DW	01H
	DW	01eH
	DW	018H
	DW	02H
	DW	06H
	DW	04H
	DW	027H
	DW	00H
	DW	0eH
	DW	05H
	DW	010H
	DW	06H
	DW	01aH
	DW	0b3H
	DW	00H
	DW	02H
	DW	01H
	DW	01H
	DW	00H
	DW	00H
	DW	00H
	DW	05H
	DW	02H
	DW	09H
	DW	06H
	DW	00H
	DW	02H
	DW	05H
	DW	010H
	DW	07H
	DW	05H
	DW	01H
	DW	01H
	DW	00H
	DW	02H
	DW	04H
	DW	04H
	DW	07H
	DW	0fH
	DW	0dH
	DW	0eH
	DW	00H
	DW	00H
	DW	03H
	DW	00H
	DW	01H
	DW	00H
	DW	00H
	DW	00H
	DW	02H
	DW	01H
	DW	06H
	DW	04H
	DW	05H
	DW	01H
	DW	04H
	DW	09H
	DW	00H
	DW	03H
	DW	01H
	DW	08H
	DW	00H
	DW	00H
	DW	0aH
	DW	05H
	DW	00H
	DW	02bH
	DW	00H
	DW	02H
	DW	06H
	DW	08H
	DW	04H
	DW	00H
	DW	02H
	DW	00H
	DW	00H
	DW	09H
	DW	06H
	DW	00H
	DW	09H
	DW	03H
	DW	01H
	DW	06H
	DW	014H
	DW	0eH
	DW	06H
	DW	01H
	DW	04H
	DW	00H
	DW	07H
	DW	02H
	DW	03H
	DW	00H
	DW	02H
	DW	00H
	DW	05H
	DW	00H
	DW	03H
	DW	01H
	DW	00H
	DW	03H
	DW	09H
	DW	07H
	DW	00H
	DW	03H
	DW	04H
	DW	00H
	DW	04H
	DW	09H
	DW	01H
	DW	06H
	DW	00H
	DW	09H
	DW	00H
	DW	00H
	DW	02H
	DW	03H
	DW	0aH
	DW	09H
	DW	01cH
	DW	03H
	DW	06H
	DW	02H
	DW	04H
	DW	01H
	DW	02H
	DW	020H
	DW	04H
	DW	01H
	DW	012H
	DW	02H
	DW	00H
	DW	03H
	DW	01H
	DW	05H
	DW	01eH
	DW	0aH
	DW	00H
	DW	02H
	DW	02H
	DW	02H
	DW	00H
	DW	07H
	DW	09H
	DW	08H
	DW	0bH
	DW	0aH
	DW	0bH
	DW	07H
	DW	02H
	DW	0dH
	DW	07H
	DW	05H
	DW	0aH
	DW	00H
	DW	03H
	DW	028H
	DW	02H
	DW	00H
	DW	01H
	DW	06H
	DW	0cH
	DW	00H
	DW	04H
	DW	05H
	DW	01H
	DW	05H
	DW	0bH
	DW	0bH
	DW	015H
	DW	04H
	DW	08H
	DW	03H
	DW	07H
	DW	08H
	DW	08H
	DW	021H
	DW	05H
	DW	017H
	DW	00H
	DW	00H
	DW	013H
	DW	08H
	DW	08H
	DW	02H
	DW	03H
	DW	00H
	DW	06H
	DW	01H
	DW	01H
	DW	01H
	DW	05H
	DW	01H
	DW	01bH
	DW	04H
	DW	02H
	DW	05H
	DW	00H
	DW	03H
	DW	05H
	DW	06H
	DW	03H
	DW	01H
	DW	00H
	DW	03H
	DW	01H
	DW	0cH
	DW	05H
	DW	03H
	DW	03H
	DW	02H
	DW	00H
	DW	07H
	DW	07H
	DW	02H
	DW	01H
	DW	00H
	DW	04H
	DW	00H
	DW	01H
	DW	01H
	DW	02H
	DW	00H
	DW	0aH
	DW	0aH
	DW	06H
	DW	02H
	DW	05H
	DW	09H
	DW	07H
	DW	05H
	DW	0fH
	DW	0fH
	DW	015H
	DW	06H
	DW	0bH
	DW	05H
	DW	014H
	DW	04H
	DW	03H
	DW	05H
	DW	05H
	DW	02H
	DW	05H
	DW	00H
	DW	02H
	DW	01H
	DW	00H
	DW	01H
	DW	07H
	DW	01cH
	DW	00H
	DW	09H
	DW	00H
	DW	05H
	DW	0cH
	DW	05H
	DW	05H
	DW	012H
	DW	01eH
	DW	00H
	DW	0cH
	DW	03H
	DW	03H
	DW	015H
	DW	010H
	DW	019H
	DW	020H
	DW	09H
	DW	03H
	DW	0eH
	DW	0bH
	DW	018H
	DW	05H
	DW	042H
	DW	09H
	DW	01H
	DW	02H
	DW	00H
	DW	05H
	DW	09H
	DW	01H
	DW	05H
	DW	01H
	DW	08H
	DW	00H
	DW	08H
	DW	03H
	DW	03H
	DW	00H
	DW	01H
	DW	0fH
	DW	01H
	DW	04H
	DW	08H
	DW	01H
	DW	02H
	DW	07H
	DW	00H
	DW	07H
	DW	02H
	DW	08H
	DW	03H
	DW	07H
	DW	05H
	DW	03H
	DW	07H
	DW	0aH
	DW	02H
	DW	01H
	DW	00H
	DW	00H
	DW	02H
	DW	019H
	DW	00H
	DW	06H
	DW	04H
	DW	00H
	DW	0aH
	DW	00H
	DW	04H
	DW	02H
	DW	04H
	DW	01H
	DW	0cH
	DW	05H
	DW	026H
	DW	04H
	DW	00H
	DW	04H
	DW	01H
	DW	0aH
	DW	05H
	DW	09H
	DW	04H
	DW	00H
	DW	0eH
	DW	04H
	DW	02H
	DW	05H
	DW	012H
	DW	014H
	DW	015H
	DW	01H
	DW	03H
	DW	00H
	DW	05H
	DW	00H
	DW	07H
	DW	00H
	DW	03H
	DW	07H
	DW	01H
	DW	03H
	DW	01H
	DW	01H
	DW	08H
	DW	01H
	DW	00H
	DW	00H
	DW	00H
	DW	03H
	DW	02H
	DW	05H
	DW	02H
	DW	0bH
	DW	06H
	DW	00H
	DW	0dH
	DW	01H
	DW	03H
	DW	09H
	DW	01H
	DW	0cH
	DW	00H
	DW	010H
	DW	06H
	DW	02H
	DW	01H
	DW	00H
	DW	02H
	DW	01H
	DW	0cH
	DW	06H
	DW	0dH
	DW	0bH
	DW	02H
	DW	00H
	DW	01cH
	DW	01H
	DW	07H
	DW	08H
	DW	0eH
	DW	0dH
	DW	08H
	DW	0dH
	DW	00H
	DW	02H
	DW	00H
	DW	05H
	DW	04H
	DW	08H
	DW	0aH
	DW	02H
	DW	025H
	DW	02aH
	DW	013H
	DW	06H
	DW	06H
	DW	07H
	DW	04H
	DW	0eH
	DW	0bH
	DW	012H
	DW	0eH
	DW	050H
	DW	07H
	DW	06H
	DW	00H
	DW	04H
	DW	048H
	DW	0cH
	DW	024H
	DW	01bH
	DW	07H
	DW	07H
	DW	00H
	DW	0eH
	DW	011H
	DW	013H
	DW	0a4H
	DW	01bH
	DW	00H
	DW	05H
	DW	0aH
	DW	07H
	DW	03H
	DW	0dH
	DW	06H
	DW	0eH
	DW	00H
	DW	02H
	DW	02H
	DW	05H
	DW	03H
	DW	00H
	DW	06H
	DW	0dH
	DW	00H
	DW	00H
	DW	0aH
	DW	01dH
	DW	00H
	DW	04H
	DW	00H
	DW	03H
	DW	0dH
	DW	00H
	DW	03H
	DW	01H
	DW	06H
	DW	033H
	DW	01H
	DW	05H
	DW	01cH
	DW	02H
	DW	00H
	DW	08H
	DW	00H
	DW	014H
	DW	02H
	DW	04H
	DW	00H
	DW	019H
	DW	02H
	DW	0aH
	DW	0dH
	DW	0aH
	DW	00H
	DW	010H
	DW	04H
	DW	00H
	DW	01H
	DW	00H
	DW	02H
	DW	01H
	DW	07H
	DW	00H
	DW	01H
	DW	08H
	DW	0bH
	DW	00H
	DW	00H
	DW	01H
	DW	02H
	DW	07H
	DW	02H
	DW	017H
	DW	0bH
	DW	06H
	DW	06H
	DW	04H
	DW	010H
	DW	02H
	DW	02H
	DW	02H
	DW	00H
	DW	016H
	DW	09H
	DW	03H
	DW	03H
	DW	05H
	DW	02H
	DW	00H
	DW	0fH
	DW	010H
	DW	015H
	DW	02H
	DW	09H
	DW	014H
	DW	0fH
	DW	0fH
	DW	05H
	DW	03H
	DW	09H
	DW	01H
	DW	00H
	DW	00H
	DW	01H
	DW	07H
	DW	07H
	DW	05H
	DW	04H
	DW	02H
	DW	02H
	DW	02H
	DW	026H
	DW	018H
	DW	0eH
	DW	00H
	DW	00H
	DW	0fH
	DW	05H
	DW	06H
	DW	018H
	DW	0eH
	DW	05H
	DW	05H
	DW	0bH
	DW	00H
	DW	015H
	DW	0cH
	DW	00H
	DW	03H
	DW	08H
	DW	04H
	DW	0bH
	DW	01H
	DW	08H
	DW	00H
	DW	0bH
	DW	01bH
	DW	07H
	DW	02H
	DW	04H
	DW	09H
	DW	015H
	DW	03bH
	DW	00H
	DW	01H
	DW	027H
	DW	03H
	DW	03cH
	DW	03eH
	DW	03H
	DW	00H
	DW	0cH
	DW	0bH
	DW	00H
	DW	03H
	DW	01eH
	DW	0bH
	DW	00H
	DW	0dH
	DW	058H
	DW	04H
	DW	0fH
	DW	05H
	DW	01cH
	DW	0dH
	DW	01H
	DW	04H
	DW	030H
	DW	011H
	DW	011H
	DW	04H
	DW	01cH
	DW	020H
	DW	02eH
	DW	00H
	DW	010H
	DW	00H
	DW	012H
	DW	0bH
	DW	01H
	DW	08H
	DW	06H
	DW	026H
	DW	0bH
	DW	02H
	DW	06H
	DW	0bH
	DW	026H
	DW	02H
	DW	00H
	DW	02dH
	DW	03H
	DW	0bH
	DW	02H
	DW	07H
	DW	08H
	DW	04H
	DW	01eH
	DW	0eH
	DW	011H
	DW	02H
	DW	01H
	DW	01H
	DW	041H
	DW	012H
	DW	0cH
	DW	010H
	DW	04H
	DW	02H
	DW	02dH
	DW	07bH
	DW	0cH
	DW	038H
	DW	021H
	DW	01H
	DW	04H
	DW	03H
	DW	04H
	DW	07H
	DW	00H
	DW	00H
	DW	00H
	DW	03H
	DW	02H
	DW	00H
	DW	010H
	DW	04H
	DW	02H
	DW	04H
	DW	02H
	DW	00H
	DW	07H
	DW	04H
	DW	05H
	DW	02H
	DW	01aH
	DW	02H
	DW	019H
	DW	06H
	DW	0bH
	DW	06H
	DW	01H
	DW	010H
	DW	02H
	DW	06H
	DW	011H
	DW	04dH
	DW	0fH
	DW	03H
	DW	023H
	DW	00H
	DW	01H
	DW	00H
	DW	05H
	DW	01H
	DW	00H
	DW	026H
	DW	010H
	DW	06H
	DW	03H
	DW	0cH
	DW	03H
	DW	03H
	DW	03H
	DW	00H
	DW	09H
	DW	03H
	DW	01H
	DW	03H
	DW	05H
	DW	02H
	DW	09H
	DW	00H
	DW	012H
	DW	00H
	DW	019H
	DW	01H
	DW	03H
	DW	020H
	DW	01H
	DW	048H
	DW	02eH
	DW	06H
	DW	02H
	DW	07H
	DW	01H
	DW	03H
	DW	0eH
	DW	011H
	DW	00H
	DW	01cH
	DW	01H
	DW	028H
	DW	0dH
	DW	00H
	DW	014H
	DW	0fH
	DW	028H
	DW	06H
	DW	026H
	DW	018H
	DW	0cH
	DW	02bH
	DW	01H
	DW	01H
	DW	09H
	DW	00H
	DW	0cH
	DW	06H
	DW	00H
	DW	06H
	DW	02H
	DW	04H
	DW	013H
	DW	03H
	DW	07H
	DW	01H
	DW	030H
	DW	00H
	DW	09H
	DW	05H
	DW	00H
	DW	05H
	DW	06H
	DW	09H
	DW	06H
	DW	0aH
	DW	0fH
	DW	02H
	DW	0bH
	DW	013H
	DW	03H
	DW	09H
	DW	02H
	DW	00H
	DW	01H
	DW	0aH
	DW	01H
	DW	01bH
	DW	08H
	DW	01H
	DW	03H
	DW	06H
	DW	01H
	DW	0eH
	DW	00H
	DW	01aH
	DW	00H
	DW	01bH
	DW	010H
	DW	03H
	DW	04H
	DW	09H
	DW	06H
	DW	02H
	DW	017H
	DW	09H
	DW	0aH
	DW	05H
	DW	019H
	DW	02H
	DW	01H
	DW	06H
	DW	01H
	DW	01H
	DW	030H
	DW	0fH
	DW	09H
	DW	0fH
	DW	0eH
	DW	03H
	DW	04H
	DW	01aH
	DW	03cH
	DW	01dH
	DW	0dH
	DW	025H
	DW	015H
	DW	01H
	DW	06H
	DW	04H
	DW	00H
	DW	02H
	DW	0bH
	DW	016H
	DW	017H
	DW	010H
	DW	010H
	DW	02H
	DW	02H
	DW	01H
	DW	03H
	DW	00H
	DW	05H
	DW	01H
	DW	06H
	DW	04H
	DW	00H
	DW	00H
	DW	04H
	DW	00H
	DW	00H
	DW	08H
	DW	03H
	DW	00H
	DW	02H
	DW	05H
	DW	00H
	DW	07H
	DW	01H
	DW	07H
	DW	03H
	DW	0dH
	DW	02H
	DW	04H
	DW	0aH
	DW	03H
	DW	00H
	DW	02H
	DW	01fH
	DW	00H
	DW	012H
	DW	03H
	DW	00H
	DW	0cH
	DW	0aH
	DW	04H
	DW	01H
	DW	00H
	DW	07H
	DW	05H
	DW	07H
	DW	00H
	DW	05H
	DW	04H
	DW	0cH
	DW	02H
	DW	016H
	DW	0aH
	DW	04H
	DW	02H
	DW	0fH
	DW	02H
	DW	08H
	DW	09H
	DW	00H
	DW	017H
	DW	02H
	DW	0c5H
	DW	033H
	DW	03H
	DW	01H
	DW	01H
	DW	04H
	DW	0dH
	DW	04H
	DW	03H
	DW	015H
	DW	04H
	DW	013H
	DW	03H
	DW	0aH
	DW	05H
	DW	028H
	DW	00H
	DW	04H
	DW	01H
	DW	01H
	DW	0aH
	DW	04H
	DW	01H
	DW	01bH
	DW	022H
	DW	07H
	DW	015H
	DW	02H
	DW	011H
	DW	02H
	DW	09H
	DW	06H
	DW	04H
	DW	02H
	DW	03H
	DW	00H
	DW	04H
	DW	02H
	DW	07H
	DW	08H
	DW	02H
	DW	05H
	DW	01H
	DW	0fH
	DW	015H
	DW	03H
	DW	04H
	DW	04H
	DW	02H
	DW	02H
	DW	011H
	DW	016H
	DW	01H
	DW	05H
	DW	016H
	DW	04H
	DW	01aH
	DW	07H
	DW	00H
	DW	020H
	DW	01H
	DW	0bH
	DW	02aH
	DW	0fH
	DW	04H
	DW	01H
	DW	02H
	DW	05H
	DW	00H
	DW	013H
	DW	03H
	DW	01H
	DW	08H
	DW	06H
	DW	00H
	DW	0aH
	DW	01H
	DW	09H
	DW	02H
	DW	0dH
	DW	01eH
	DW	08H
	DW	02H
	DW	018H
	DW	011H
	DW	013H
	DW	01H
	DW	04H
	DW	04H
	DW	019H
	DW	0dH
	DW	00H
	DW	0aH
	DW	010H
	DW	0bH
	DW	027H
	DW	012H
	DW	08H
	DW	05H
	DW	01eH
	DW	052H
	DW	01H
	DW	06H
	DW	08H
	DW	012H
	DW	04dH
	DW	0bH
	DW	0dH
	DW	014H
	DW	04bH
	DW	0bH
	DW	070H
	DW	04eH
	DW	021H
	DW	03H
	DW	00H
	DW	00H
	DW	03cH
	DW	011H
	DW	054H
	DW	09H
	DW	01H
	DW	01H
	DW	0cH
	DW	01eH
	DW	0aH
	DW	031H
	DW	05H
	DW	020H
	DW	09eH
	DW	0b2H
	DW	05H
	DW	05H
	DW	06H
	DW	03H
	DW	03H
	DW	01H
	DW	03H
	DW	01H
	DW	04H
	DW	07H
	DW	06H
	DW	013H
	DW	01fH
	DW	015H
	DW	00H
	DW	02H
	DW	09H
	DW	05H
	DW	06H
	DW	01bH
	DW	04H
	DW	09H
	DW	08H
	DW	01H
	DW	04cH
	DW	012H
	DW	0cH
	DW	01H
	DW	04H
	DW	00H
	DW	03H
	DW	03H
	DW	06H
	DW	03H
	DW	0cH
	DW	02H
	DW	08H
	DW	01eH
	DW	010H
	DW	02H
	DW	019H
	DW	01H
	DW	05H
	DW	05H
	DW	04H
	DW	03H
	DW	00H
	DW	06H
	DW	0aH
	DW	02H
	DW	03H
	DW	01H
	DW	00H
	DW	05H
	DW	01H
	DW	013H
	DW	03H
	DW	00H
	DW	08H
	DW	01H
	DW	05H
	DW	02H
	DW	06H
	DW	00H
	DW	00H
	DW	00H
	DW	013H
	DW	01H
	DW	02H
	DW	00H
	DW	05H
	DW	01H
	DW	02H
	DW	05H
	DW	01H
	DW	03H
	DW	07H
	DW	00H
	DW	04H
	DW	0cH
	DW	07H
	DW	03H
	DW	0aH
	DW	016H
	DW	00H
	DW	09H
	DW	05H
	DW	01H
	DW	00H
	DW	02H
	DW	014H
	DW	01H
	DW	01H
	DW	03H
	DW	017H
	DW	01eH
	DW	03H
	DW	09H
	DW	09H
	DW	01H
	DW	04H
	DW	0bfH
	DW	0eH
	DW	03H
	DW	0fH
	DW	06H
	DW	08H
	DW	032H
	DW	00H
	DW	01H
	DW	00H
	DW	00H
	DW	04H
	DW	00H
	DW	00H
	DW	01H
	DW	00H
	DW	02H
	DW	04H
	DW	02H
	DW	00H
	DW	02H
	DW	03H
	DW	00H
	DW	02H
	DW	00H
	DW	02H
	DW	02H
	DW	08H
	DW	07H
	DW	00H
	DW	01H
	DW	01H
	DW	01H
	DW	03H
	DW	03H
	DW	011H
	DW	0bH
	DW	05bH
	DW	01H
	DW	09H
	DW	03H
	DW	02H
	DW	0dH
	DW	04H
	DW	018H
	DW	0fH
	DW	029H
	DW	03H
	DW	0dH
	DW	03H
	DW	01H
	DW	014H
	DW	04H
	DW	07dH
	DW	01dH
	DW	01eH
	DW	01H
	DW	00H
	DW	04H
	DW	0cH
	DW	02H
	DW	015H
	DW	04H
	DW	05H
	DW	05H
	DW	013H
	DW	0bH
	DW	00H
	DW	0dH
	DW	0bH
	DW	056H
	DW	02H
	DW	012H
	DW	00H
	DW	07H
	DW	01H
	DW	08H
	DW	08H
	DW	02H
	DW	02H
	DW	016H
	DW	01H
	DW	02H
	DW	06H
	DW	05H
	DW	02H
	DW	00H
	DW	01H
	DW	02H
	DW	08H
	DW	00H
	DW	02H
	DW	00H
	DW	05H
	DW	02H
	DW	01H
	DW	00H
	DW	02H
	DW	0aH
	DW	02H
	DW	00H
	DW	05H
	DW	09H
	DW	02H
	DW	01H
	DW	02H
	DW	00H
	DW	01H
	DW	00H
	DW	04H
	DW	00H
	DW	00H
	DW	0aH
	DW	02H
	DW	05H
	DW	03H
	DW	00H
	DW	06H
	DW	01H
	DW	00H
	DW	01H
	DW	04H
	DW	04H
	DW	021H
	DW	03H
	DW	0dH
	DW	011H
	DW	03H
	DW	012H
	DW	06H
	DW	04H
	DW	07H
	DW	01H
	DW	05H
	DW	04eH
	DW	00H
	DW	04H
	DW	01H
	DW	0dH
	DW	07H
	DW	01H
	DW	08H
	DW	01H
	DW	00H
	DW	023H
	DW	01bH
	DW	0fH
	DW	03H
	DW	00H
	DW	00H
	DW	00H
	DW	01H
	DW	0bH
	DW	05H
	DW	029H
	DW	026H
	DW	0fH
	DW	016H
	DW	06H
	DW	0eH
	DW	0eH
	DW	02H
	DW	01H
	DW	0bH
	DW	06H
	DW	014H
	DW	03fH
	DW	05H
	DW	08H
	DW	01bH
	DW	07H
	DW	0bH
	DW	02H
	DW	02H
	DW	028H
	DW	03aH
	DW	017H
	DW	032H
	DW	036H
	DW	038H
	DW	0125H
	DW	08H
	DW	08H
	DW	01H
	DW	05H
	DW	01H
	DW	0eH
	DW	00H
	DW	01H
	DW	0cH
	DW	025H
	DW	059H
	DW	08H
	DW	08H
	DW	08H
	DW	02H
	DW	0aH
	DW	06H
	DW	00H
	DW	00H
	DW	00H
	DW	04H
	DW	05H
	DW	02H
	DW	01H
	DW	00H
	DW	01H
	DW	01H
	DW	02H
	DW	07H
	DW	00H
	DW	03H
	DW	03H
	DW	00H
	DW	04H
	DW	06H
	DW	00H
	DW	03H
	DW	02H
	DW	013H
	DW	03H
	DW	08H
	DW	00H
	DW	00H
	DW	00H
	DW	04H
	DW	04H
	DW	010H
	DW	00H
	DW	04H
	DW	01H
	DW	05H
	DW	01H
	DW	03H
	DW	00H
	DW	03H
	DW	04H
	DW	06H
	DW	02H
	DW	011H
	DW	0aH
	DW	0aH
	DW	01fH
	DW	06H
	DW	04H
	DW	03H
	DW	06H
	DW	0aH
	DW	07eH
	DW	07H
	DW	03H
	DW	02H
	DW	02H
	DW	00H
	DW	09H
	DW	00H
	DW	00H
	DW	05H
	DW	014H
	DW	0dH
	DW	00H
	DW	0fH
	DW	00H
	DW	06H
	DW	00H
	DW	02H
	DW	05H
	DW	08H
	DW	040H
	DW	032H
	DW	03H
	DW	02H
	DW	0cH
	DW	02H
	DW	09H
	DW	00H
	DW	00H
	DW	0bH
	DW	08H
	DW	014H
	DW	06dH
	DW	02H
	DW	012H
	DW	017H
	DW	00H
	DW	00H
	DW	09H
	DW	03dH
	DW	03H
	DW	00H
	DW	01cH
	DW	029H
	DW	04dH
	DW	01bH
	DW	013H
	DW	011H
	DW	051H
	DW	05H
	DW	02H
	DW	0eH
	DW	05H
	DW	053H
	DW	039H
	DW	0fcH
	DW	0eH
	DW	09aH
	DW	0107H
	DW	0eH
	DW	014H
	DW	08H
	DW	0dH
	DW	06H
	DW	039H
	DW	027H
	DW	026H
CONST	ENDS
;	COMDAT ?ranges@?1??GetGlyphRangesChinese@ImFontAtlas@@QAEPBGXZ@4QBGB
CONST	SEGMENT
?ranges@?1??GetGlyphRangesChinese@ImFontAtlas@@QAEPBGXZ@4QBGB DW 020H ; `ImFontAtlas::GetGlyphRangesChinese'::`2'::ranges
	DW	0ffH
	DW	03000H
	DW	030ffH
	DW	031f0H
	DW	031ffH
	DW	0f900H
	DW	0faffH
	DW	0ff00H
	DW	0ffefH
	DW	00H
CONST	ENDS
;	COMDAT ?ranges@?1??GetGlyphRangesKorean@ImFontAtlas@@QAEPBGXZ@4QBGB
CONST	SEGMENT
?ranges@?1??GetGlyphRangesKorean@ImFontAtlas@@QAEPBGXZ@4QBGB DW 020H ; `ImFontAtlas::GetGlyphRangesKorean'::`2'::ranges
	DW	0ffH
	DW	03131H
	DW	03163H
	DW	0ac00H
	DW	0d79dH
	DW	00H
CONST	ENDS
;	COMDAT ?ranges@?1??GetGlyphRangesDefault@ImFontAtlas@@QAEPBGXZ@4QBGB
CONST	SEGMENT
?ranges@?1??GetGlyphRangesDefault@ImFontAtlas@@QAEPBGXZ@4QBGB DW 020H ; `ImFontAtlas::GetGlyphRangesDefault'::`2'::ranges
	DW	0ffH
	DW	00H
CONST	ENDS
_DATA	SEGMENT
?GNullClipRect@@3UImVec4@@B DD 0c6000000r	; -8192	; GNullClipRect
	DD	0c6000000r			; -8192
	DD	046000000r			; 8192
	DD	046000000r			; 8192
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Insert@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z$91 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z$2
__tryblocktable$??$_Insert@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z$91
__unwindtable$??$_Insert@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Insert@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$_Insert@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Insert@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z$91 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z$2
__tryblocktable$??$_Insert@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z$91
__unwindtable$??$_Insert@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Insert@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$_Insert@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXI@Z$49 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXI@Z$0
__unwindtable$?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXI@Z$49
__ehfuncinfo$?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@1@ABV?$allocator@G@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@1@ABV?$allocator@G@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@1@ABV?$allocator@G@1@@Z$1
__ehfuncinfo$??0?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@1@ABV?$allocator@G@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@1@ABV?$allocator@G@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@Ustbrp_rect@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1ImGuiDrawContext@@QAE@XZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??1ImGuiDrawContext@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1ImGuiDrawContext@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@UImGuiColumnData@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@UImGuiGroupData@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@H@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@PAUImGuiWindow@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1ImGuiTextEditState@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1ImGuiTextEditState@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1ImGuiTextEditState@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@M@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@UGlyph@ImFont@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@UImFontConfig@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@PAUImFont@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z$0
__unwindtable$?AddFont@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddFont@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z$0
__unwindtable$?Build@ImFontAtlas@@QAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Build@ImFontAtlas@@QAE_NXZ$0
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__unwindtable$??1ImFontAtlas@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__unwindtable$?DeIndexAllBuffers@ImDrawData@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DeIndexAllBuffers@ImDrawData@@QAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__unwindtable$??1ImFont@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__unwindtable$??0ImFont@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ImFont@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0ImFont@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0ImFont@@QAE@XZ$2
__ehfuncinfo$?RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??1ImFont@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1ImFont@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__ehfuncinfo$??0ImFont@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0ImFont@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?Build@ImFontAtlas@@QAE_NXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Build@ImFontAtlas@@QAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?AddFont@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddFont@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??1ImFontAtlas@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1ImFontAtlas@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__ehfuncinfo$?DeIndexAllBuffers@ImDrawData@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?DeIndexAllBuffers@ImDrawData@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@UImDrawVert@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@G@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@UImDrawCmd@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@D@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@GG@?$allocator@U?$_List_node@GPAX@std@@@std@@QAEXPAG$$QAG@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@GG@?$allocator@U?$_List_node@GPAX@std@@@std@@QAEXPAG$$QAG@Z PROC ; std::allocator<std::_List_node<unsigned short,void *> >::construct<unsigned short,unsigned short>, COMDAT
; _this$ = ecx

; 839  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	ax, WORD PTR [eax]
	mov	WORD PTR [ecx], ax
$LN3@construct:

; 841  : 		}

	pop	ebp
	ret	8
??$construct@GG@?$allocator@U?$_List_node@GPAX@std@@@std@@QAEXPAG$$QAG@Z ENDP ; std::allocator<std::_List_node<unsigned short,void *> >::construct<unsigned short,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@GG@?$allocator_traits@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@GPAX@std@@@1@PAG$$QAG@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@GG@?$allocator_traits@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@GPAX@std@@@1@PAG$$QAG@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<unsigned short,void *> > >::construct<unsigned short,unsigned short>, COMDAT

; 958  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	ax, WORD PTR [eax]
	mov	WORD PTR [ecx], ax
$LN8@construct:

; 959  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 960  : 		}

	pop	ebp
	ret	0
??$construct@GG@?$allocator_traits@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@GPAX@std@@@1@PAG$$QAG@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<unsigned short,void *> > >::construct<unsigned short,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@GPAX@std@@AAPAU12@@?$allocator@U?$_List_node@GPAX@std@@@std@@QAEXPAPAU?$_List_node@GPAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_List_node@GPAX@std@@AAPAU12@@?$allocator@U?$_List_node@GPAX@std@@@std@@QAEXPAPAU?$_List_node@GPAX@1@AAPAU21@@Z PROC ; std::allocator<std::_List_node<unsigned short,void *> >::construct<std::_List_node<unsigned short,void *> *,std::_List_node<unsigned short,void *> * &>, COMDAT
; _this$ = ecx

; 839  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 841  : 		}

	pop	ebp
	ret	8
??$construct@PAU?$_List_node@GPAX@std@@AAPAU12@@?$allocator@U?$_List_node@GPAX@std@@@std@@QAEXPAPAU?$_List_node@GPAX@1@AAPAU21@@Z ENDP ; std::allocator<std::_List_node<unsigned short,void *> >::construct<std::_List_node<unsigned short,void *> *,std::_List_node<unsigned short,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Construct1@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@SAXU?$integral_constant@_N$00@1@AAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@$$QAV41@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 4
__Ptr$ = 16						; size = 4
_<_Args_0>$ = 20					; size = 4
??$_Construct1@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@SAXU?$integral_constant@_N$00@1@AAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@$$QAV41@@Z PROC ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Construct1<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >, COMDAT

; 709  : 		{	// construct _Ty(_Types...) at _Ptr, default version

	npad	2
	push	ebp
	mov	ebp, esp

; 710  : 		::new (static_cast<void *>(_Ptr))

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@Construct1
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@Construct1:

; 711  : 			_Ty(_STD forward<_Types>(_Args)...);
; 712  : 		}

	pop	ebp
	ret	0
??$_Construct1@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@SAXU?$integral_constant@_N$00@1@AAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@$$QAV41@@Z ENDP ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Construct1<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Construct1@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@ABV12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@SAXU?$integral_constant@_N$00@1@AAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@ABV41@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 4
__Ptr$ = 16						; size = 4
_<_Args_0>$ = 20					; size = 4
??$_Construct1@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@ABV12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@SAXU?$integral_constant@_N$00@1@AAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@ABV41@@Z PROC ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Construct1<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> const &>, COMDAT

; 709  : 		{	// construct _Ty(_Types...) at _Ptr, default version

	npad	2
	push	ebp
	mov	ebp, esp

; 710  : 		::new (static_cast<void *>(_Ptr))

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@Construct1
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@Construct1:

; 711  : 			_Ty(_STD forward<_Types>(_Args)...);
; 712  : 		}

	pop	ebp
	ret	0
??$_Construct1@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@ABV12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@SAXU?$integral_constant@_N$00@1@AAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@ABV41@@Z ENDP ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Construct1<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Destroy1@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@U?$integral_constant@_N$00@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Destroy1@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@U?$integral_constant@_N$00@1@@Z PROC ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Destroy1<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >, COMDAT

; 734  : 		_Ptr->~_Ty();
; 735  : 		}

	ret	0
??$_Destroy1@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@U?$integral_constant@_N$00@1@@Z ENDP ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Destroy1<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$?0G@?$allocator@U?$_List_node@GPAX@std@@@std@@QAE@ABV?$allocator@G@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0G@?$allocator@U?$_List_node@GPAX@std@@@std@@QAE@ABV?$allocator@G@1@@Z PROC ; std::allocator<std::_List_node<unsigned short,void *> >::allocator<std::_List_node<unsigned short,void *> ><unsigned short>, COMDAT
; _this$ = ecx

; 813  : 		}

	mov	eax, ecx
	ret	4
??$?0G@?$allocator@U?$_List_node@GPAX@std@@@std@@QAE@ABV?$allocator@G@1@@Z ENDP ; std::allocator<std::_List_node<unsigned short,void *> >::allocator<std::_List_node<unsigned short,void *> ><unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@GG@?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@QAEXPAG$$QAG@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@GG@?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@QAEXPAG$$QAG@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >::construct<unsigned short,unsigned short>, COMDAT
; _this$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	ax, WORD PTR [eax]
	mov	WORD PTR [ecx], ax
$LN13@construct:

; 1096 : 		_Mytraits::construct(*this, _Ptr,
; 1097 : 			_STD forward<_Types>(_Args)...);
; 1098 : 		}

	pop	ebp
	ret	8
??$construct@GG@?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@QAEXPAG$$QAG@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >::construct<unsigned short,unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ??$_Buynode_if_nil@ABG@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@ABGV21@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
__Plist$ = 16						; size = 4
??$_Buynode_if_nil@ABG@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@ABGV21@@Z PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Buynode_if_nil<unsigned short const &>, COMDAT
; _this$ = ecx

; 738  : 		{	// node exists, just return it

	npad	2
	push	ebp
	mov	ebp, esp

; 739  : 		return (_Plist);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Plist$[ebp]
	mov	DWORD PTR [eax], ecx

; 740  : 		}

	pop	ebp
	ret	12					; 0000000cH
??$_Buynode_if_nil@ABG@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@ABGV21@@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Buynode_if_nil<unsigned short const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@ABG@std@@YAABGABG@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABG@std@@YAABGABG@Z PROC			; std::forward<unsigned short const &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@ABG@std@@YAABGABG@Z ENDP			; std::forward<unsigned short const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@GPAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@GPAX@std@@@1@PAPAU?$_List_node@GPAX@1@AAPAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAU?$_List_node@GPAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@GPAX@std@@@1@PAPAU?$_List_node@GPAX@1@AAPAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<unsigned short,void *> > >::construct<std::_List_node<unsigned short,void *> *,std::_List_node<unsigned short,void *> * &>, COMDAT

; 958  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN8@construct:

; 959  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 960  : 		}

	pop	ebp
	ret	0
??$construct@PAU?$_List_node@GPAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@GPAX@std@@@1@PAPAU?$_List_node@GPAX@1@AAPAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<unsigned short,void *> > >::construct<std::_List_node<unsigned short,void *> *,std::_List_node<unsigned short,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@AAPAU?$_List_node@GPAX@std@@@std@@YAAAPAU?$_List_node@GPAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAU?$_List_node@GPAX@std@@@std@@YAAAPAU?$_List_node@GPAX@0@AAPAU10@@Z PROC ; std::forward<std::_List_node<unsigned short,void *> * &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@AAPAU?$_List_node@GPAX@std@@@std@@YAAAPAU?$_List_node@GPAX@0@AAPAU10@@Z ENDP ; std::forward<std::_List_node<unsigned short,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@$$QAV31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@$$QAV31@@Z PROC ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::construct<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >, COMDAT

; 726  : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 710  : 		::new (static_cast<void *>(_Ptr))

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN8@construct:

; 727  : 		_Construct1(_Uses_default_construct_t<_Unwrap_alloc_t<_Alloc>, _Ty *, _Types...>(),
; 728  : 			_Al, _Ptr, _STD forward<_Types>(_Args)...);
; 729  : 		}

	pop	ebp
	ret	0
??$construct@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@$$QAV31@@Z ENDP ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::construct<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA$$QAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA$$QAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@AAV10@@Z PROC ; std::forward<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA$$QAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@AAV10@@Z ENDP ; std::forward<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@ABV12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@ABV31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@ABV12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@ABV31@@Z PROC ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::construct<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> const &>, COMDAT

; 726  : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 710  : 		::new (static_cast<void *>(_Ptr))

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN8@construct:

; 727  : 		_Construct1(_Uses_default_construct_t<_Unwrap_alloc_t<_Alloc>, _Ty *, _Types...>(),
; 728  : 			_Al, _Ptr, _STD forward<_Types>(_Args)...);
; 729  : 		}

	pop	ebp
	ret	0
??$construct@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@ABV12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@ABV31@@Z ENDP ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::construct<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@ABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@ABV10@@Z PROC ; std::forward<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> const &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@ABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@ABV10@@Z ENDP ; std::forward<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z PROC ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::destroy<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >, COMDAT

; 746  : 		_Destroy1(_Al, _Ptr, _Uses_default_destroy_t<_Unwrap_alloc_t<_Alloc>, _Ty *>());
; 747  : 		}

	ret	0
??$destroy@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z ENDP ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::destroy<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$?0ABV?$allocator@G@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@QAE@ABV?$allocator@G@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0ABV?$allocator@G@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@QAE@ABV?$allocator@G@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > ><std::allocator<unsigned short> const &>, COMDAT
; _this$ = ecx

; 1054 : 		}

	mov	eax, ecx
	ret	4
??$?0ABV?$allocator@G@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@QAE@ABV?$allocator@G@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > ><std::allocator<unsigned short> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@_N@std@@YA$$QA_NAA_N@Z PROC			; std::forward<bool>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@_N@std@@YA$$QA_NAA_N@Z ENDP			; std::forward<bool>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??$_Buynode@G@?$_List_buy@GV?$allocator@G@std@@@std@@QAEPAU?$_List_node@GPAX@1@PAU21@0$$QAG@Z
_TEXT	SEGMENT
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
_<_Val_0>$ = 16						; size = 4
??$_Buynode@G@?$_List_buy@GV?$allocator@G@std@@@std@@QAEPAU?$_List_node@GPAX@1@PAU21@0$$QAG@Z PROC ; std::_List_buy<unsigned short,std::allocator<unsigned short> >::_Buynode<unsigned short>, COMDAT
; _this$ = ecx

; 847  : 		{	// allocate a node and set links and value

	npad	2
	push	ebp
	mov	ebp, esp

; 848  : 		_Nodeptr _Pnode = this->_Buynode0(_Next, _Prev);

	push	DWORD PTR __Prev$[ebp]
	push	DWORD PTR __Next$[ebp]
	call	?_Buynode0@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEPAU?$_List_node@GPAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Buynode0

; 540  : 		return ((reference)_Pnode->_Myval);

	lea	edx, DWORD PTR [eax+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edx, edx
	je	SHORT $LN36@Buynode
	mov	ecx, DWORD PTR _<_Val_0>$[ebp]
	mov	cx, WORD PTR [ecx]
	mov	WORD PTR [edx], cx
$LN36@Buynode:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 860  : 		}

	pop	ebp
	ret	12					; 0000000cH
??$_Buynode@G@?$_List_buy@GV?$allocator@G@std@@@std@@QAEPAU?$_List_node@GPAX@1@PAU21@0$$QAG@Z ENDP ; std::_List_buy<unsigned short,std::allocator<unsigned short> >::_Buynode<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ??$_Insert@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Plist$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T2 = 8							; size = 4
___$ReturnUdt$ = 8					; size = 4
tv1477 = 12						; size = 4
$T3 = 12						; size = 4
__Val$ = 12						; size = 4
__Pnode$ = 16						; size = 4
??$_Insert@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Insert<unsigned short const &,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >, COMDAT
; _this$ = ecx

; 761  : 		{	// try to insert existing node with value _Val

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	mov	edi, DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 761  : 		{	// try to insert existing node with value _Val

	mov	ebx, ecx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ebx

; 762  : 		size_type _Bucket;
; 763  : 		_Unchecked_iterator _Where;
; 764  : 
; 765  : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	movzx	eax, BYTE PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 912  : 		return (_Traitsobj(_Keyval) & _Mask);

	mov	ecx, DWORD PTR [ebx+24]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	xor	eax, -2128831035			; 811c9dc5H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	mov	esi, DWORD PTR [ebx+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 347  : 		_Val *= _FNV_prime;

	imul	edx, eax, 16777619
	movzx	eax, BYTE PTR [edi+1]
	xor	edx, eax
	imul	eax, edx, 16777619
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 912  : 		return (_Traitsobj(_Keyval) & _Mask);

	and	ecx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [esi+ecx*8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1746 : 		return (this->_Myfirst()[_Pos]);

	lea	edx, DWORD PTR [ecx*8]
	mov	DWORD PTR tv1477[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	eax, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 846  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())

	jne	SHORT $LN43@Insert

; 847  : 			return (_Unchecked_end());

	mov	esi, DWORD PTR [ebx+4]
	jmp	SHORT $LN44@Insert
$LN43@Insert:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	esi, DWORD PTR [esi+edx+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 851  : 			return (++_Ans);

	mov	esi, DWORD PTR [esi]
$LN44@Insert:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	esi, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 768  : 		for (; _Where != _Begin(_Bucket); )

	je	SHORT $LN3@Insert
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 220  : 		return (_Left == _Right);

	movzx	ecx, WORD PTR [edi]
	npad	8
$LL2@Insert:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);

	mov	esi, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 220  : 		return (_Left == _Right);

	cmp	cx, WORD PTR [esi+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 772  : 			if (_Traitsobj(_Traits::_Kfn(_Val),

	je	SHORT $LN6@Insert
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	esi, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 768  : 		for (; _Where != _Begin(_Bucket); )

	jne	SHORT $LL2@Insert
$LN3@Insert:

; 739  : 		return (_Plist);

	mov	edi, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Plist$[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);

	mov	eax, DWORD PTR [edi]

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	esi, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 799  : 		if (_Where != ++_Next)	// move element into place

	je	SHORT $LN10@Insert
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	ecx, DWORD PTR [edi+4]

; 1910 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =

	mov	DWORD PTR [ecx], eax

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	ecx, DWORD PTR [eax+4]

; 1912 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =

	mov	DWORD PTR [ecx], esi

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	ecx, DWORD PTR [esi+4]

; 1914 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =

	mov	DWORD PTR [ecx], edi

; 1915 : 			_First._Mynode();
; 1916 : 
; 1917 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());

	mov	edx, DWORD PTR [esi+4]

; 1918 : 		this->_Prevnode(_Where._Mynode()) =

	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], ecx

; 1919 : 			this->_Prevnode(_Last._Mynode());
; 1920 : 		this->_Prevnode(_Last._Mynode()) =

	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+4], ecx

; 1921 : 			this->_Prevnode(_First._Mynode());
; 1922 : 		this->_Prevnode(_First._Mynode()) = _Pnode;

	mov	DWORD PTR [edi+4], edx
	mov	edx, DWORD PTR tv1477[ebp]
$LN10@Insert:

; 86   : 		return (_Ptr == _Right._Ptr);

	mov	ecx, DWORD PTR [ebx+12]
	add	ecx, edx
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 883  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())

	jne	SHORT $LN453@Insert

; 884  : 			{	// make bucket non-empty
; 885  : 			_Vec_lo(_Bucket) = _Plist;

	mov	DWORD PTR [ecx], edi

; 886  : 			_Vec_hi(_Bucket) = _Plist;

	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR [eax+edx+4], edi

; 888  : 		else if (_Vec_lo(_Bucket) == _Where)

	jmp	SHORT $LN457@Insert
$LN6@Insert:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 96   : 		return (_Ptr);

	mov	edx, DWORD PTR __Pnode$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	push	edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	ecx, DWORD PTR [edx+4]

; 1490 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 1491 : 			this->_Nextnode(_Pnode);
; 1492 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =

	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 1493 : 			this->_Prevnode(_Pnode);
; 1494 : 
; 1495 : 		--this->_Mysize();

	dec	DWORD PTR [ebx+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	call	??3@YAXPAX@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	DWORD PTR [eax], esi

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 812  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN453@Insert:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 888  : 		else if (_Vec_lo(_Bucket) == _Where)

	jne	SHORT $LN455@Insert

; 889  : 			_Vec_lo(_Bucket) = _Plist;	// move beginning back one element

	mov	DWORD PTR [ecx], edi

; 890  : 		else if (++_Vec_hi(_Bucket) != _Plist)	// move end up one element

	jmp	SHORT $LN457@Insert
$LN455@Insert:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [ecx+4]

; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 890  : 		else if (++_Vec_hi(_Bucket) != _Plist)	// move end up one element

	je	SHORT $LN457@Insert
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1746 : 		return (this->_Myfirst()[_Pos]);

	mov	ecx, DWORD PTR [ebx+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);

	mov	eax, DWORD PTR [ecx+edx+4]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+edx+4], eax
$LN457@Insert:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 805  : 		_Check_size();

	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Check_size@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEXXZ ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Check_size
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 812  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	DWORD PTR [eax], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 812  : 		}

	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 812  : 		}

	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$??$_Insert@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z$2:

; 806  : 		_CATCH_ALL
; 807  : 		erase(_Make_iter(_Plist));

	push	DWORD PTR __Plist$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?_Make_iter@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Make_iter
	mov	ecx, DWORD PTR _this$[ebp]
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?erase@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@V32@@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::erase

; 808  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN635@Insert:
$LN634@Insert:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Insert@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Insert<unsigned short const &,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@GPAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@GPAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_List_node@GPAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@GPAX@1@AAPAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >::construct<std::_List_node<unsigned short,void *> *,std::_List_node<unsigned short,void *> * &>, COMDAT
; _this$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 1096 : 		_Mytraits::construct(*this, _Ptr,
; 1097 : 			_STD forward<_Types>(_Args)...);
; 1098 : 		}

	pop	ebp
	ret	8
??$construct@PAU?$_List_node@GPAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@GPAX@1@AAPAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >::construct<std::_List_node<unsigned short,void *> *,std::_List_node<unsigned short,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@$$QAV21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@$$QAV21@@Z PROC ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::construct<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >, COMDAT
; _this$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 710  : 		::new (static_cast<void *>(_Ptr))

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 1096 : 		_Mytraits::construct(*this, _Ptr,
; 1097 : 			_STD forward<_Types>(_Args)...);
; 1098 : 		}

	pop	ebp
	ret	8
??$construct@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@V12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@$$QAV21@@Z ENDP ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::construct<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@G@?$allocator@U?$_List_node@GPAX@std@@@std@@QAEXPAG@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@G@?$allocator@U?$_List_node@GPAX@std@@@std@@QAEXPAG@Z PROC ; std::allocator<std::_List_node<unsigned short,void *> >::destroy<unsigned short>, COMDAT
; _this$ = ecx

; 846  : 		_Ptr->~_Uty();
; 847  : 		}

	ret	4
??$destroy@G@?$allocator@U?$_List_node@GPAX@std@@@std@@QAEXPAG@Z ENDP ; std::allocator<std::_List_node<unsigned short,void *> >::destroy<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@ABV12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@ABV21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@ABV12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@ABV21@@Z PROC ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::construct<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> const &>, COMDAT
; _this$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 710  : 		::new (static_cast<void *>(_Ptr))

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 1096 : 		_Mytraits::construct(*this, _Ptr,
; 1097 : 			_STD forward<_Types>(_Args)...);
; 1098 : 		}

	pop	ebp
	ret	8
??$construct@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@ABV12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@ABV21@@Z ENDP ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::construct<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@GPAX@std@@@?$allocator@U?$_List_node@GPAX@std@@@std@@QAEXPAPAU?$_List_node@GPAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_List_node@GPAX@std@@@?$allocator@U?$_List_node@GPAX@std@@@std@@QAEXPAPAU?$_List_node@GPAX@1@@Z PROC ; std::allocator<std::_List_node<unsigned short,void *> >::destroy<std::_List_node<unsigned short,void *> *>, COMDAT
; _this$ = ecx

; 846  : 		_Ptr->~_Uty();
; 847  : 		}

	ret	4
??$destroy@PAU?$_List_node@GPAX@std@@@?$allocator@U?$_List_node@GPAX@std@@@std@@QAEXPAPAU?$_List_node@GPAX@1@@Z ENDP ; std::allocator<std::_List_node<unsigned short,void *> >::destroy<std::_List_node<unsigned short,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z PROC ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::destroy<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >, COMDAT
; _this$ = ecx

; 1103 : 		_Mytraits::destroy(*this, _Ptr);
; 1104 : 		}

	ret	4
??$destroy@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z ENDP ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::destroy<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0ABV?$allocator@G@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@G@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@G@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@G@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@G@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@G@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >,std::_List_val<std::_List_simple_types<unsigned short> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >,std::_List_val<std::_List_simple_types<unsigned short> >,1><std::allocator<unsigned short> const &>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 523  : 		: _Myhead(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 524  : 		_Mysize(0)

	mov	DWORD PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	ret	8
??$?0ABV?$allocator@G@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@G@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@G@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >,std::_List_val<std::_List_simple_types<unsigned short> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >,std::_List_val<std::_List_simple_types<unsigned short> >,1><std::allocator<unsigned short> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$?0ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > ><std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > const &>, COMDAT
; _this$ = ecx

; 1054 : 		}

	mov	eax, ecx
	ret	4
??$?0ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > ><std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ??$_Buynode_if_nil@AAG@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@AAGV21@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
__Plist$ = 16						; size = 4
??$_Buynode_if_nil@AAG@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@AAGV21@@Z PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Buynode_if_nil<unsigned short &>, COMDAT
; _this$ = ecx

; 738  : 		{	// node exists, just return it

	npad	2
	push	ebp
	mov	ebp, esp

; 739  : 		return (_Plist);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Plist$[ebp]
	mov	DWORD PTR [eax], ecx

; 740  : 		}

	pop	ebp
	ret	12					; 0000000cH
??$_Buynode_if_nil@AAG@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@AAGV21@@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Buynode_if_nil<unsigned short &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@AAG@std@@YAAAGAAG@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAG@std@@YAAAGAAG@Z PROC			; std::forward<unsigned short &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@AAG@std@@YAAAGAAG@Z ENDP			; std::forward<unsigned short &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
;	COMDAT ??$?0V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_NX$0A@@?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_NX$0A@@?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >,bool>::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >,bool><std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >,bool,void,0>, COMDAT
; _this$ = ecx

; 189  : 		{	// construct from moved values

	npad	2
	push	ebp
	mov	ebp, esp

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[ebp]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+4], al

; 190  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??$?0V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_NX$0A@@?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >,bool>::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >,bool><std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >,bool,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??$_Insert@G@?$list@GV?$allocator@G@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@$$QAG@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Insert@G@?$list@GV?$allocator@G@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@$$QAG@Z PROC ; std::list<unsigned short,std::allocator<unsigned short> >::_Insert<unsigned short>, COMDAT
; _this$ = ecx

; 1082 : 		{	// insert element at _Where

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 535  : 		return ((_Nodepref)_Pnode->_Prev);

	mov	esi, DWORD PTR __Where$[ebp]
	push	edi

; 1083 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1084 : 		_Nodeptr _Newnode =
; 1085 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),

	push	DWORD PTR _<_Val_0>$[ebp]
	mov	edi, ecx
	push	DWORD PTR [esi+4]
	push	esi
	call	??$_Buynode@G@?$_List_buy@GV?$allocator@G@std@@@std@@QAEPAU?$_List_node@GPAX@1@PAU21@0$$QAG@Z ; std::_List_buy<unsigned short,std::allocator<unsigned short> >::_Buynode<unsigned short>
	mov	edx, eax

; 1950 : 		if (max_size() - this->_Mysize() - 1 < _Count)

	mov	ecx, 357913940				; 15555554H
	mov	eax, DWORD PTR [edi+4]
	sub	ecx, eax
	cmp	ecx, 1
	jae	SHORT $LN13@Insert

; 1951 : 			_Xlength_error("list<T> too long");

	push	OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN66@Insert:
$LN13@Insert:

; 1952 : 		this->_Mysize() += _Count;

	inc	eax
	mov	DWORD PTR [edi+4], eax

; 1086 : 				_STD forward<_Valty>(_Val)...);
; 1087 : 		_Incsize(1);
; 1088 : 		this->_Prevnode(_Pnode) = _Newnode;

	mov	DWORD PTR [esi+4], edx

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [edx+4]
	pop	edi
	pop	esi

; 1089 : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;

	mov	DWORD PTR [eax], edx

; 1090 : 		}

	pop	ebp
	ret	8
$LN65@Insert:
??$_Insert@G@?$list@GV?$allocator@G@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@$$QAG@Z ENDP ; std::list<unsigned short,std::allocator<unsigned short> >::_Insert<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Rechecked@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@PAV12@@std@@YAAAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@AAPAV10@PAV10@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@PAV12@@std@@YAAAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@AAPAV10@PAV10@@Z PROC ; std::_Rechecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *>, COMDAT

; 480  : 	{	// reset checked from unchecked, generic

	npad	2
	push	ebp
	mov	ebp, esp

; 481  : 	_Dest = _Src;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Src$[ebp]
	mov	DWORD PTR [eax], ecx

; 482  : 	return (_Dest);
; 483  : 	}

	pop	ebp
	ret	0
??$_Rechecked@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@PAV12@@std@@YAAAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@AAPAV10@PAV10@@Z ENDP ; std::_Rechecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0U?$integral_constant@_N$0A@@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$0A@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$integral_constant@_N$0A@@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$0A@@1@@Z PROC ; std::_Any_tag::_Any_tag<std::integral_constant<bool,0> >, COMDAT
; _this$ = ecx

; 556  : 		constexpr _Any_tag(_Ty&&) _NOEXCEPT {}

	mov	eax, ecx
	ret	4
??$?0U?$integral_constant@_N$0A@@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$0A@@1@@Z ENDP ; std::_Any_tag::_Any_tag<std::integral_constant<bool,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_move_al_unchecked@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >, COMDAT

; 135  : 	{	// move [_First, _Last) to raw _Dest, using _Al, no special optimization

	npad	2
	push	ebp
	mov	ebp, esp

; 139  : 	for (; _First != _Last; ++_Dest, (void)++_First)

	mov	eax, DWORD PTR __Dest$[ebp]
	xor	ecx, ecx
	push	esi
	mov	esi, DWORD PTR __Last$[ebp]
	xor	edx, edx
	push	edi
	mov	edi, DWORD PTR __First$[ebp]
	sub	esi, edi
	add	esi, 3
	shr	esi, 2
	cmp	edi, DWORD PTR __Last$[ebp]
	cmova	esi, ecx
	test	esi, esi
	je	SHORT $LN3@Uninitiali
	sub	edi, eax
$LL4@Uninitiali:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 710  : 		::new (static_cast<void *>(_Ptr))

	test	eax, eax
	je	SHORT $LN2@Uninitiali
	mov	ecx, DWORD PTR [edi+eax]
	mov	DWORD PTR [eax], ecx
$LN2@Uninitiali:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 139  : 	for (; _First != _Last; ++_Dest, (void)++_First)

	inc	edx
	add	eax, 4
	cmp	edx, esi
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	edi
	pop	esi

; 140  : 		{
; 141  : 		_Al.construct(_Unfancy(_Dest), _STD move(*_First));
; 142  : 		}
; 143  : 
; 144  : 	_CATCH_ALL
; 145  : 	_Destroy_range(_Next, _Dest, _Al);
; 146  : 	_RERAISE;
; 147  : 	_CATCH_END
; 148  : 
; 149  : 	return (_Dest);
; 150  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_move_al_unchecked@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$move@AAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA$$QAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA$$QAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@AAV10@@Z PROC ; std::move<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> &>, COMDAT

; 1350 : 	{	// forward _Arg as movable

	npad	2
	push	ebp
	mov	ebp, esp

; 1351 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1352 : 	}

	pop	ebp
	ret	0
??$move@AAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@YA$$QAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@AAV10@@Z ENDP ; std::move<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Ptr_move_cat@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YA?AU_Trivially_copyable_ptr_iterator_tag@0@ABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Ptr_move_cat@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YA?AU_Trivially_copyable_ptr_iterator_tag@0@ABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@0@Z PROC ; std::_Ptr_move_cat<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >, COMDAT

; 892  : 	{	// return pointer move optimization category for pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 893  : 	return {};

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 894  : 	}

	pop	ebp
	ret	0
??$_Ptr_move_cat@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YA?AU_Trivially_copyable_ptr_iterator_tag@0@ABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@0@Z ENDP ; std::_Ptr_move_cat<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Unchecked@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@PAV10@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@PAV10@@Z PROC ; std::_Unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *>, COMDAT

; 450  : 	{	// construct unchecked from checked, generic

	npad	2
	push	ebp
	mov	ebp, esp

; 451  : 	return (_Src);

	mov	eax, DWORD PTR __Src$[ebp]

; 452  : 	}

	pop	ebp
	ret	0
??$_Unchecked@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@PAV10@@Z ENDP ; std::_Unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@G@?$allocator_traits@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@GPAX@std@@@1@PAG@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@G@?$allocator_traits@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@GPAX@std@@@1@PAG@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<unsigned short,void *> > >::destroy<unsigned short>, COMDAT

; 965  : 		_Al.destroy(_Ptr);
; 966  : 		}

	ret	0
??$destroy@G@?$allocator_traits@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@GPAX@std@@@1@PAG@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<unsigned short,void *> > >::destroy<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninit_alloc_fill_n1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@IU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@PAV10@IABV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_alloc_fill_n1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@IU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@PAV10@IABV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Uninit_alloc_fill_n1<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,unsigned int,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >, COMDAT

; 184  : 	{	// copy _Count copies of _Val to raw _First, using _Al, no special optimization

	npad	2
	push	ebp
	mov	ebp, esp

; 188  : 	for (; 0 < _Count; --_Count, (void)++_First)

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	test	edx, edx
	je	SHORT $LN3@Uninit_all
	push	esi
	mov	esi, DWORD PTR __Val$[ebp]
$LL4@Uninit_all:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 710  : 		::new (static_cast<void *>(_Ptr))

	test	eax, eax
	je	SHORT $LN2@Uninit_all
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx
$LN2@Uninit_all:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 188  : 	for (; 0 < _Count; --_Count, (void)++_First)

	add	eax, 4
	sub	edx, 1
	jne	SHORT $LL4@Uninit_all
	pop	esi
$LN3@Uninit_all:

; 189  : 		{
; 190  : 		_Al.construct(_Unfancy(_First), _Val);
; 191  : 		}
; 192  : 
; 193  : 	_CATCH_ALL
; 194  : 	_Destroy_range(_Next, _First, _Al);
; 195  : 	_RERAISE;
; 196  : 	_CATCH_END
; 197  : 
; 198  : 	return (_First);
; 199  : 	}

	pop	ebp
	ret	0
??$_Uninit_alloc_fill_n1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@IU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@PAV10@IABV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Uninit_alloc_fill_n1<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,unsigned int,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$_Unfancy@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@PAV10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@PAV10@@Z PROC ; std::_Unfancy<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >, COMDAT

; 642  : 	{	// do nothing for plain pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 644  : 	}

	pop	ebp
	ret	0
??$_Unfancy@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@PAV10@@Z ENDP ; std::_Unfancy<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@GPAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@GPAX@std@@@1@PAPAU?$_List_node@GPAX@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAU?$_List_node@GPAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@GPAX@std@@@1@PAPAU?$_List_node@GPAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<unsigned short,void *> > >::destroy<std::_List_node<unsigned short,void *> *>, COMDAT

; 965  : 		_Al.destroy(_Ptr);
; 966  : 		}

	ret	0
??$destroy@PAU?$_List_node@GPAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@GPAX@std@@@1@PAPAU?$_List_node@GPAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<unsigned short,void *> > >::destroy<std::_List_node<unsigned short,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Fill_unchecked1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@0ABV10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
tv278 = 12						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_unchecked1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@0ABV10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Fill_unchecked1<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >, COMDAT

; 2688 : 	{	// copy _Val through [_First, _Last), no special optimization

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR __Last$[ebp]
	xor	edx, edx
	push	ebx
	mov	ebx, DWORD PTR __First$[ebp]
	sub	ecx, ebx
	add	ecx, 3
	shr	ecx, 2
	push	esi
	xor	esi, esi
	cmp	ebx, DWORD PTR __Last$[ebp]
	cmova	ecx, esi
	mov	DWORD PTR tv278[ebp], ecx

; 2689 : 	for (; _First != _Last; ++_First)

	test	ecx, ecx
	je	SHORT $LN3@Fill_unche

; 2690 : 		*_First = _Val;

	mov	esi, DWORD PTR __Val$[ebp]
	push	edi
	cmp	ecx, 4
	jb	SHORT $LN9@Fill_unche
	mov	edi, DWORD PTR [esi]
	cmp	ebx, esi
	ja	SHORT $LN10@Fill_unche
	lea	eax, DWORD PTR [ebx-4]
	lea	eax, DWORD PTR [eax+ecx*4]
	cmp	eax, esi
	jae	SHORT $LN9@Fill_unche
$LN10@Fill_unche:
	and	ecx, -4					; fffffffcH
$LL4@Fill_unche:

; 2689 : 	for (; _First != _Last; ++_First)

	add	edx, 4
	cmp	edx, ecx
	jne	SHORT $LL4@Fill_unche

; 2690 : 		*_First = _Val;

	lea	esi, DWORD PTR [ecx+3]
	mov	eax, edi
	and	esi, -4					; fffffffcH
	mov	edi, ebx
	shl	esi, 2
	mov	ecx, esi
	shr	ecx, 2
	add	ebx, esi
	mov	esi, DWORD PTR __Val$[ebp]
	rep stosd
	mov	ecx, DWORD PTR tv278[ebp]
$LN9@Fill_unche:

; 2689 : 	for (; _First != _Last; ++_First)

	pop	edi
	cmp	edx, ecx
	je	SHORT $LN3@Fill_unche
	npad	6
$LL8@Fill_unche:

; 2690 : 		*_First = _Val;

	mov	eax, DWORD PTR [esi]
	lea	ebx, DWORD PTR [ebx+4]
	inc	edx
	mov	DWORD PTR [ebx-4], eax
	cmp	edx, ecx
	jne	SHORT $LL8@Fill_unche
$LN3@Fill_unche:
	pop	esi
	pop	ebx

; 2691 : 	}

	pop	ebp
	ret	0
??$_Fill_unchecked1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@0ABV10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Fill_unchecked1<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Fill_memset_is_safe@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YA?AU?$integral_constant@_N$0A@@0@ABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@ABV20@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Fill_memset_is_safe@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YA?AU?$integral_constant@_N$0A@@0@ABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@ABV20@@Z PROC ; std::_Fill_memset_is_safe<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >, COMDAT

; 2682 : 	return {};

	xor	al, al

; 2683 : 	}

	ret	0
??$_Fill_memset_is_safe@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YA?AU?$integral_constant@_N$0A@@0@ABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@ABV20@@Z ENDP ; std::_Fill_memset_is_safe<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Destroy_range1@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@0AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range1@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@0AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Destroy_range1<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *>, COMDAT

; 1200 : 	for (; _First != _Last; ++_First)
; 1201 : 		_Al.destroy(_Unfancy(_First));
; 1202 : 	}

	ret	0
??$_Destroy_range1@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@0AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Destroy_range1<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??$?0ABV?$allocator@G@std@@X@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@ABV?$allocator@G@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0ABV?$allocator@G@std@@X@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@ABV?$allocator@G@1@@Z PROC ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > ><std::allocator<unsigned short> const &,void>, COMDAT
; _this$ = ecx

; 605  : 		{	// construct head node, allocator from _Al

	npad	2
	push	esi
	mov	esi, ecx

; 731  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

	push	0
	push	0

; 523  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 524  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 731  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

	call	?_Buynode0@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEPAU?$_List_node@GPAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Buynode0

; 606  : 		_Myhead() = _Buyheadnode();

	mov	DWORD PTR [esi], eax

; 607  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??$?0ABV?$allocator@G@std@@X@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@ABV?$allocator@G@1@@Z ENDP ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > ><std::allocator<unsigned short> const &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >,1><std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > const &>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	ret	8
??$?0ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >,1><std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@YAABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@0@ABU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@YAABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@0@ABU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > const &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@YAABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@0@ABU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0AAU?$equal_to@G@std@@M@?$_Compressed_pair@U?$equal_to@G@std@@M$00@std@@QAE@U_One_then_variadic_args_t@1@AAU?$equal_to@G@1@$$QAM@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
_<_Val2_0>$ = 16					; size = 4
??$?0AAU?$equal_to@G@std@@M@?$_Compressed_pair@U?$equal_to@G@std@@M$00@std@@QAE@U_One_then_variadic_args_t@1@AAU?$equal_to@G@1@$$QAM@Z PROC ; std::_Compressed_pair<std::equal_to<unsigned short>,float,1>::_Compressed_pair<std::equal_to<unsigned short>,float,1><std::equal_to<unsigned short> &,float>, COMDAT
; _this$ = ecx

; 312  : 		{	// construct from forwarded values

	npad	2
	push	ebp
	mov	ebp, esp

; 311  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

	mov	eax, DWORD PTR _<_Val2_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 313  : 		}

	mov	eax, ecx
	pop	ebp
	ret	12					; 0000000cH
??$?0AAU?$equal_to@G@std@@M@?$_Compressed_pair@U?$equal_to@G@std@@M$00@std@@QAE@U_One_then_variadic_args_t@1@AAU?$equal_to@G@1@$$QAM@Z ENDP ; std::_Compressed_pair<std::equal_to<unsigned short>,float,1>::_Compressed_pair<std::equal_to<unsigned short>,float,1><std::equal_to<unsigned short> &,float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@M@std@@YA$$QAMAAM@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@M@std@@YA$$QAMAAM@Z PROC			; std::forward<float>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@M@std@@YA$$QAMAAM@Z ENDP			; std::forward<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@AAU?$equal_to@G@std@@@std@@YAAAU?$equal_to@G@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU?$equal_to@G@std@@@std@@YAAAU?$equal_to@G@0@AAU10@@Z PROC ; std::forward<std::equal_to<unsigned short> &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@AAU?$equal_to@G@std@@@std@@YAAAU?$equal_to@G@0@AAU10@@Z ENDP ; std::forward<std::equal_to<unsigned short> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@U_One_then_variadic_args_t@std@@@std@@YA$$QAU_One_then_variadic_args_t@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_One_then_variadic_args_t@std@@@std@@YA$$QAU_One_then_variadic_args_t@0@AAU10@@Z PROC ; std::forward<std::_One_then_variadic_args_t>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@U_One_then_variadic_args_t@std@@@std@@YA$$QAU_One_then_variadic_args_t@0@AAU10@@Z ENDP ; std::forward<std::_One_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@AAU?$hash@G@std@@@std@@YAAAU?$hash@G@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU?$hash@G@std@@@std@@YAAAU?$hash@G@0@AAU10@@Z PROC ; std::forward<std::hash<unsigned short> &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@AAU?$hash@G@std@@@std@@YAAAU?$hash@G@0@AAU10@@Z ENDP ; std::forward<std::hash<unsigned short> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$?0G@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAE@ABV?$allocator@G@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0G@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAE@ABV?$allocator@G@1@@Z PROC ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> ><unsigned short>, COMDAT
; _this$ = ecx

; 813  : 		}

	mov	eax, ecx
	ret	4
??$?0G@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAE@ABV?$allocator@G@1@@Z ENDP ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> ><unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@G@std@@@std@@YAABV?$allocator@G@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@G@std@@@std@@YAABV?$allocator@G@0@ABV10@@Z PROC ; std::forward<std::allocator<unsigned short> const &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@ABV?$allocator@G@std@@@std@@YAABV?$allocator@G@0@ABV10@@Z ENDP ; std::forward<std::allocator<unsigned short> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@@std@@YA$$QAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@@std@@YA$$QAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > > >, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@@std@@YA$$QAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Distance1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@@std@@YAHV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@0@0Uinput_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Distance1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@@std@@YAHV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@0@0Uinput_iterator_tag@0@@Z PROC ; std::_Distance1<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > > >, COMDAT

; 1094 : 	{	// return distance between iterators; input

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 297  : 		return (this->_Ptr == _Right._Ptr);

	mov	ecx, DWORD PTR __First$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1095 : 	_Iter_diff_t<_InIt> _Off = 0;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 297  : 		return (this->_Ptr == _Right._Ptr);

	mov	edx, DWORD PTR __Last$[ebp]
	cmp	ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1096 : 	for (; _First != _Last; ++_First)

	je	SHORT $LN3@Distance1
$LL4@Distance1:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 242  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	ecx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1097 : 		++_Off;

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 242  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	DWORD PTR __First$[ebp], ecx

; 297  : 		return (this->_Ptr == _Right._Ptr);

	cmp	ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1096 : 	for (; _First != _Last; ++_First)

	jne	SHORT $LL4@Distance1
$LN3@Distance1:

; 1098 : 
; 1099 : 	return (_Off);
; 1100 : 	}

	pop	ebp
	ret	0
??$_Distance1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@@std@@YAHV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@0@0Uinput_iterator_tag@0@@Z ENDP ; std::_Distance1<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ??$_Insert@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Plist$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T2 = 8							; size = 4
___$ReturnUdt$ = 8					; size = 4
tv1477 = 12						; size = 4
$T3 = 12						; size = 4
__Val$ = 12						; size = 4
__Pnode$ = 16						; size = 4
??$_Insert@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Insert<unsigned short &,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >, COMDAT
; _this$ = ecx

; 761  : 		{	// try to insert existing node with value _Val

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	mov	edi, DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 761  : 		{	// try to insert existing node with value _Val

	mov	ebx, ecx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ebx

; 762  : 		size_type _Bucket;
; 763  : 		_Unchecked_iterator _Where;
; 764  : 
; 765  : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	movzx	eax, BYTE PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 912  : 		return (_Traitsobj(_Keyval) & _Mask);

	mov	ecx, DWORD PTR [ebx+24]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	xor	eax, -2128831035			; 811c9dc5H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	mov	esi, DWORD PTR [ebx+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 347  : 		_Val *= _FNV_prime;

	imul	edx, eax, 16777619
	movzx	eax, BYTE PTR [edi+1]
	xor	edx, eax
	imul	eax, edx, 16777619
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 912  : 		return (_Traitsobj(_Keyval) & _Mask);

	and	ecx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [esi+ecx*8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1746 : 		return (this->_Myfirst()[_Pos]);

	lea	edx, DWORD PTR [ecx*8]
	mov	DWORD PTR tv1477[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	eax, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 846  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())

	jne	SHORT $LN43@Insert

; 847  : 			return (_Unchecked_end());

	mov	esi, DWORD PTR [ebx+4]
	jmp	SHORT $LN44@Insert
$LN43@Insert:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	esi, DWORD PTR [esi+edx+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 851  : 			return (++_Ans);

	mov	esi, DWORD PTR [esi]
$LN44@Insert:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	esi, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 768  : 		for (; _Where != _Begin(_Bucket); )

	je	SHORT $LN3@Insert
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 220  : 		return (_Left == _Right);

	movzx	ecx, WORD PTR [edi]
	npad	8
$LL2@Insert:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);

	mov	esi, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 220  : 		return (_Left == _Right);

	cmp	cx, WORD PTR [esi+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 772  : 			if (_Traitsobj(_Traits::_Kfn(_Val),

	je	SHORT $LN6@Insert
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	esi, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 768  : 		for (; _Where != _Begin(_Bucket); )

	jne	SHORT $LL2@Insert
$LN3@Insert:

; 739  : 		return (_Plist);

	mov	edi, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Plist$[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);

	mov	eax, DWORD PTR [edi]

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	esi, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 799  : 		if (_Where != ++_Next)	// move element into place

	je	SHORT $LN10@Insert
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	ecx, DWORD PTR [edi+4]

; 1910 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =

	mov	DWORD PTR [ecx], eax

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	ecx, DWORD PTR [eax+4]

; 1912 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =

	mov	DWORD PTR [ecx], esi

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	ecx, DWORD PTR [esi+4]

; 1914 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =

	mov	DWORD PTR [ecx], edi

; 1915 : 			_First._Mynode();
; 1916 : 
; 1917 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());

	mov	edx, DWORD PTR [esi+4]

; 1918 : 		this->_Prevnode(_Where._Mynode()) =

	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], ecx

; 1919 : 			this->_Prevnode(_Last._Mynode());
; 1920 : 		this->_Prevnode(_Last._Mynode()) =

	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+4], ecx

; 1921 : 			this->_Prevnode(_First._Mynode());
; 1922 : 		this->_Prevnode(_First._Mynode()) = _Pnode;

	mov	DWORD PTR [edi+4], edx
	mov	edx, DWORD PTR tv1477[ebp]
$LN10@Insert:

; 86   : 		return (_Ptr == _Right._Ptr);

	mov	ecx, DWORD PTR [ebx+12]
	add	ecx, edx
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 883  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())

	jne	SHORT $LN453@Insert

; 884  : 			{	// make bucket non-empty
; 885  : 			_Vec_lo(_Bucket) = _Plist;

	mov	DWORD PTR [ecx], edi

; 886  : 			_Vec_hi(_Bucket) = _Plist;

	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR [eax+edx+4], edi

; 888  : 		else if (_Vec_lo(_Bucket) == _Where)

	jmp	SHORT $LN457@Insert
$LN6@Insert:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 96   : 		return (_Ptr);

	mov	edx, DWORD PTR __Pnode$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	push	edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	ecx, DWORD PTR [edx+4]

; 1490 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 1491 : 			this->_Nextnode(_Pnode);
; 1492 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =

	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 1493 : 			this->_Prevnode(_Pnode);
; 1494 : 
; 1495 : 		--this->_Mysize();

	dec	DWORD PTR [ebx+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	call	??3@YAXPAX@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	DWORD PTR [eax], esi

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 812  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN453@Insert:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 888  : 		else if (_Vec_lo(_Bucket) == _Where)

	jne	SHORT $LN455@Insert

; 889  : 			_Vec_lo(_Bucket) = _Plist;	// move beginning back one element

	mov	DWORD PTR [ecx], edi

; 890  : 		else if (++_Vec_hi(_Bucket) != _Plist)	// move end up one element

	jmp	SHORT $LN457@Insert
$LN455@Insert:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [ecx+4]

; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 890  : 		else if (++_Vec_hi(_Bucket) != _Plist)	// move end up one element

	je	SHORT $LN457@Insert
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1746 : 		return (this->_Myfirst()[_Pos]);

	mov	ecx, DWORD PTR [ebx+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);

	mov	eax, DWORD PTR [ecx+edx+4]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+edx+4], eax
$LN457@Insert:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 805  : 		_Check_size();

	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Check_size@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEXXZ ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Check_size
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 812  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	DWORD PTR [eax], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 812  : 		}

	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 812  : 		}

	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$??$_Insert@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z$2:

; 806  : 		_CATCH_ALL
; 807  : 		erase(_Make_iter(_Plist));

	push	DWORD PTR __Plist$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?_Make_iter@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Make_iter
	mov	ecx, DWORD PTR _this$[ebp]
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?erase@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@V32@@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::erase

; 808  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN635@Insert:
$LN634@Insert:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Insert@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Insert<unsigned short &,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??$emplace_front@G@?$list@GV?$allocator@G@std@@@std@@QAEX$$QAG@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_front@G@?$list@GV?$allocator@G@std@@@std@@QAEX$$QAG@Z PROC ; std::list<unsigned short,std::allocator<unsigned short> >::emplace_front<unsigned short>, COMDAT
; _this$ = ecx

; 1055 : 		{	// insert element at beginning

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 1085 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),

	push	DWORD PTR _<_Val_0>$[ebp]

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [esi]

; 96   : 		return (_Ptr);

	mov	edi, DWORD PTR [eax]

; 1085 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),

	push	DWORD PTR [edi+4]
	push	edi
	call	??$_Buynode@G@?$_List_buy@GV?$allocator@G@std@@@std@@QAEPAU?$_List_node@GPAX@1@PAU21@0$$QAG@Z ; std::_List_buy<unsigned short,std::allocator<unsigned short> >::_Buynode<unsigned short>
	mov	edx, eax

; 1950 : 		if (max_size() - this->_Mysize() - 1 < _Count)

	mov	ecx, 357913940				; 15555554H
	mov	eax, DWORD PTR [esi+4]
	sub	ecx, eax
	cmp	ecx, 1
	jae	SHORT $LN48@emplace_fr

; 1951 : 			_Xlength_error("list<T> too long");

	push	OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN102@emplace_fr:
$LN48@emplace_fr:

; 1952 : 		this->_Mysize() += _Count;

	inc	eax
	mov	DWORD PTR [esi+4], eax

; 1088 : 		this->_Prevnode(_Pnode) = _Newnode;

	mov	DWORD PTR [edi+4], edx

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [edx+4]
	pop	edi
	pop	esi

; 1089 : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;

	mov	DWORD PTR [eax], edx

; 1056 : 		_Insert(_Unchecked_begin(), _STD forward<_Valty>(_Val)...);
; 1057 : 		}

	pop	ebp
	ret	4
$LN101@emplace_fr:
??$emplace_front@G@?$list@GV?$allocator@G@std@@@std@@QAEX$$QAG@Z ENDP ; std::list<unsigned short,std::allocator<unsigned short> >::emplace_front<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@G@std@@YA$$QAGAAG@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@G@std@@YA$$QAGAAG@Z PROC			; std::forward<unsigned short>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@G@std@@YA$$QAGAAG@Z ENDP			; std::forward<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
$T1 = 16						; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >, COMDAT

; 166  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 167  : 		// note: only called internally from elsewhere in the STL, debug checks
; 168  : 		// and deprecation warnings omitted
; 169  : 	const auto _UFirst = _Unchecked(_First);
; 170  : 	const auto _ULast = _Unchecked(_Last);
; 171  : 	const auto _UDest = _Unchecked(_Dest);
; 172  : 	return (_Rechecked(_Dest,

	push	ecx
	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Al$[ebp]
	push	DWORD PTR __Dest$[ebp]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp]
	call	??$_Uninitialized_move_al_unchecked@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >
	add	esp, 24					; 00000018H

; 173  : 		_Uninitialized_move_al_unchecked(_UFirst, _ULast, _UDest, _Al,
; 174  : 			_Ptr_move_cat(_UFirst, _UDest),
; 175  : 			_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_UDest)), decltype(_STD move(*_UFirst))>())));
; 176  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_move@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@_Alloc_max_size@std@@SAIHABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Al$ = 12						; size = 4
??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@_Alloc_max_size@std@@SAIHABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@@Z PROC ; std::_Alloc_max_size::_Fn<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >, COMDAT

; 622  : 		return (_Al.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 623  : 		}

	ret	0
??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@_Alloc_max_size@std@@SAIHABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@@Z ENDP ; std::_Alloc_max_size::_Fn<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@G@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@G@std@@@0@AAV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<unsigned short> > >, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@G@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<unsigned short> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@G@?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@QAEXPAG@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@G@?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@QAEXPAG@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >::destroy<unsigned short>, COMDAT
; _this$ = ecx

; 1103 : 		_Mytraits::destroy(*this, _Ptr);
; 1104 : 		}

	ret	4
??$destroy@G@?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@QAEXPAG@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >::destroy<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@G@std@@YAPAGAAG@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@G@std@@YAPAGAAG@Z PROC			; std::addressof<unsigned short>, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@G@std@@YAPAGAAG@Z ENDP			; std::addressof<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_fill_n@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@IU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@PAV10@IABV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@IU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@PAV10@IABV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_fill_n<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,unsigned int,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >, COMDAT

; 216  : 	{	// copy _Count copies of _Val to raw _First, using _Al

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 217  : 	return (_Uninit_alloc_fill_n1(_First, _Count, _Val, _Al,

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Al$[ebp]
	push	DWORD PTR __Val$[ebp]
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __First$[ebp]
	call	??$_Uninit_alloc_fill_n1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@IU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@PAV10@IABV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninit_alloc_fill_n1<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,unsigned int,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >
	add	esp, 20					; 00000014H

; 218  : 		_Conjunction_t<decltype(_Fill_memset_is_safe(_First, _Val)),
; 219  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First)), decltype(_Val)>>()));
; 220  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_fill_n@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@IU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@PAV10@IABV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_fill_n<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,unsigned int,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QAE@PAU?$_List_node@GPAX@1@PBV?$_List_val@U?$_List_simple_types@G@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QAE@PAU?$_List_node@GPAX@1@PBV?$_List_val@U?$_List_simple_types@G@std@@@1@@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >, COMDAT
; _this$ = ecx

; 124  : 		{	// construct with node pointer _Pnode

	npad	2
	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], eax

; 125  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QAE@PAU?$_List_node@GPAX@1@PBV?$_List_val@U?$_List_simple_types@G@std@@@1@@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@YAPBV?$_List_val@U?$_List_simple_types@G@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@YAPBV?$_List_val@U?$_List_simple_types@G@std@@@0@ABV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<unsigned short> > const >, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@YAPBV?$_List_val@U?$_List_simple_types@G@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<unsigned short> > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@GPAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@GPAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_List_node@GPAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@GPAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >::destroy<std::_List_node<unsigned short,void *> *>, COMDAT
; _this$ = ecx

; 1103 : 		_Mytraits::destroy(*this, _Ptr);
; 1104 : 		}

	ret	4
??$destroy@PAU?$_List_node@GPAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@GPAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >::destroy<std::_List_node<unsigned short,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@PAU?$_List_node@GPAX@std@@@std@@YAPAPAU?$_List_node@GPAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAU?$_List_node@GPAX@std@@@std@@YAPAPAU?$_List_node@GPAX@0@AAPAU10@@Z PROC ; std::addressof<std::_List_node<unsigned short,void *> *>, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@PAU?$_List_node@GPAX@std@@@std@@YAPAPAU?$_List_node@GPAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_List_node<unsigned short,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Fill_unchecked@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@0ABV10@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill_unchecked@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@0ABV10@@Z PROC ; std::_Fill_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >, COMDAT

; 2703 : 	{	// copy _Val through [_First, _Last), choose optimization

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 2682 : 	return {};

	mov	BYTE PTR $T1[ebp], 0

; 2704 : 	_Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Val$[ebp]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp]
	call	??$_Fill_unchecked1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@0ABV10@U?$integral_constant@_N$0A@@0@@Z ; std::_Fill_unchecked1<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
	add	esp, 16					; 00000010H

; 2705 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Fill_unchecked@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@0ABV10@@Z ENDP ; std::_Fill_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@0AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@0AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *>, COMDAT

; 1215 : 		// note that this is an optimization for debug mode codegen;
; 1216 : 		// in release mode the BE removes all of this
; 1217 : 	typedef typename _Alloc::value_type _Val;
; 1218 : 	_Destroy_range1(_First, _Last, _Al, _Conjunction_t<
; 1219 : 		is_trivially_destructible<_Val>,
; 1220 : 		_Uses_default_destroy<_Alloc, _Val *>>());
; 1221 : 	}

	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@0AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QBEAAGXZ
_TEXT	SEGMENT
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QBEAAGXZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >::operator*, COMDAT
; _this$ = ecx

; 540  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR [ecx]
	add	eax, 8

; 362  : 		return ((reference)**(_Mybase *)this);
; 363  : 		}

	ret	0
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QBEAAGXZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QAE@PAU?$_List_node@GPAX@1@PBV?$_List_val@U?$_List_simple_types@G@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QAE@PAU?$_List_node@GPAX@1@PBV?$_List_val@U?$_List_simple_types@G@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >::_List_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >, COMDAT
; _this$ = ecx

; 344  : 		{	// construct with node pointer _Pnode

	npad	2
	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], eax

; 345  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QAE@PAU?$_List_node@GPAX@1@PBV?$_List_val@U?$_List_simple_types@G@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >::_List_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??$?0ABV?$allocator@G@std@@X@?$_List_buy@GV?$allocator@G@std@@@std@@QAE@ABV?$allocator@G@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 4
??$?0ABV?$allocator@G@std@@X@?$_List_buy@GV?$allocator@G@std@@@std@@QAE@ABV?$allocator@G@1@@Z PROC ; std::_List_buy<unsigned short,std::allocator<unsigned short> >::_List_buy<unsigned short,std::allocator<unsigned short> ><std::allocator<unsigned short> const &,void>, COMDAT
; _this$ = ecx

; 841  : 		{	// construct from allocator

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 731  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

	push	0
	push	0

; 841  : 		{	// construct from allocator

	mov	DWORD PTR _this$[ebp], esi

; 523  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 524  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 731  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

	call	?_Buynode0@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEPAU?$_List_node@GPAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Buynode0

; 606  : 		_Myhead() = _Buyheadnode();

	mov	DWORD PTR [esi], eax

; 842  : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0ABV?$allocator@G@std@@X@?$_List_buy@GV?$allocator@G@std@@@std@@QAE@ABV?$allocator@G@1@@Z ENDP ; std::_List_buy<unsigned short,std::allocator<unsigned short> >::_List_buy<unsigned short,std::allocator<unsigned short> ><std::allocator<unsigned short> const &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$?0ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > ><std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > const &,void>, COMDAT
; _this$ = ecx

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 517  : 		}

	mov	eax, ecx

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 517  : 		}

	ret	4
??$?0ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > ><std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > const &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0AAU?$hash@G@std@@U_One_then_variadic_args_t@1@AAU?$equal_to@G@1@M@?$_Compressed_pair@U?$hash@G@std@@V?$_Compressed_pair@U?$equal_to@G@std@@M$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@AAU?$hash@G@1@$$QAU21@AAU?$equal_to@G@1@$$QAM@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
_<_Val2_0>$ = 16					; size = 4
_<_Val2_1>$ = 20					; size = 4
_<_Val2_2>$ = 24					; size = 4
??$?0AAU?$hash@G@std@@U_One_then_variadic_args_t@1@AAU?$equal_to@G@1@M@?$_Compressed_pair@U?$hash@G@std@@V?$_Compressed_pair@U?$equal_to@G@std@@M$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@AAU?$hash@G@1@$$QAU21@AAU?$equal_to@G@1@$$QAM@Z PROC ; std::_Compressed_pair<std::hash<unsigned short>,std::_Compressed_pair<std::equal_to<unsigned short>,float,1>,1>::_Compressed_pair<std::hash<unsigned short>,std::_Compressed_pair<std::equal_to<unsigned short>,float,1>,1><std::hash<unsigned short> &,std::_One_then_variadic_args_t,std::equal_to<unsigned short> &,float>, COMDAT
; _this$ = ecx

; 312  : 		{	// construct from forwarded values

	npad	2
	push	ebp
	mov	ebp, esp

; 311  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

	mov	eax, DWORD PTR _<_Val2_2>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 313  : 		}

	mov	eax, ecx
	pop	ebp
	ret	20					; 00000014H
??$?0AAU?$hash@G@std@@U_One_then_variadic_args_t@1@AAU?$equal_to@G@1@M@?$_Compressed_pair@U?$hash@G@std@@V?$_Compressed_pair@U?$equal_to@G@std@@M$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@AAU?$hash@G@1@$$QAU21@AAU?$equal_to@G@1@$$QAM@Z ENDP ; std::_Compressed_pair<std::hash<unsigned short>,std::_Compressed_pair<std::equal_to<unsigned short>,float,1>,1>::_Compressed_pair<std::hash<unsigned short>,std::_Compressed_pair<std::equal_to<unsigned short>,float,1>,1><std::hash<unsigned short> &,std::_One_then_variadic_args_t,std::equal_to<unsigned short> &,float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$?0ABV?$allocator@G@std@@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QAE@ABV?$allocator@G@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0ABV?$allocator@G@std@@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QAE@ABV?$allocator@G@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > ><std::allocator<unsigned short> const &>, COMDAT
; _this$ = ecx

; 1054 : 		}

	mov	eax, ecx
	ret	4
??$?0ABV?$allocator@G@std@@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QAE@ABV?$allocator@G@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > ><std::allocator<unsigned short> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
;	COMDAT ??$?0V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@V01@X$0A@@?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@V12@@std@@QAE@$$QAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@1@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@V01@X$0A@@?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@V12@@std@@QAE@$$QAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@1@0@Z PROC ; std::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >,std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > > >::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >,std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > > ><std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >,std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >,void,0>, COMDAT
; _this$ = ecx

; 189  : 		{	// construct from moved values

	npad	2
	push	ebp
	mov	ebp, esp

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax

; 190  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??$?0V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@V01@X$0A@@?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@V12@@std@@QAE@$$QAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@1@0@Z ENDP ; std::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >,std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > > >::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >,std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > > ><std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >,std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$distance@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@@std@@YAHV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$distance@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@@std@@YAHV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@0@0@Z PROC ; std::distance<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > > >, COMDAT

; 1112 : 	{	// return distance between iterators

	npad	2
	push	ebp
	mov	ebp, esp

; 1113 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));

	mov	ecx, DWORD PTR __First$[ebp]

; 1095 : 	_Iter_diff_t<_InIt> _Off = 0;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 297  : 		return (this->_Ptr == _Right._Ptr);

	mov	edx, DWORD PTR __Last$[ebp]
	cmp	ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1096 : 	for (; _First != _Last; ++_First)

	je	SHORT $LN5@distance
$LL6@distance:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 242  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	ecx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1097 : 		++_Off;

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 297  : 		return (this->_Ptr == _Right._Ptr);

	cmp	ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1096 : 	for (; _First != _Last; ++_First)

	jne	SHORT $LL6@distance
$LN5@distance:

; 1114 : 	}

	pop	ebp
	ret	0
??$distance@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@@std@@YAHV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@0@0@Z ENDP ; std::distance<std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_i$1$ = -16						; size = 4
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_blocklen$1$ = -4					; size = 4
tv601 = 8						; size = 4
_adler32$ = 8						; size = 4
_buffer$ = 12						; size = 4
_buflen$ = 16						; size = 4
?stb_adler32@@YAIIPAEI@Z PROC				; stb_adler32

; 2258 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi

; 2259 :     const unsigned long ADLER_MOD = 65521;
; 2260 :     unsigned long s1 = adler32 & 0xffff, s2 = adler32 >> 16;
; 2261 :     unsigned long blocklen, i;
; 2262 : 
; 2263 :     blocklen = buflen % 5552;

	mov	esi, DWORD PTR _buflen$[ebp]
	mov	eax, 1584310703				; 5e6ea9afH
	mul	esi
	push	edi
	mov	edi, DWORD PTR _adler32$[ebp]
	shr	edx, 11					; 0000000bH
	imul	eax, edx, 5552
	mov	edx, esi
	movzx	ecx, di
	shr	edi, 16					; 00000010H
	mov	DWORD PTR _adler32$[ebp], edi
	sub	edx, eax
	mov	DWORD PTR _blocklen$1$[ebp], edx

; 2264 :     while (buflen) {

	test	esi, esi
	je	$LN3@stb_adler3
	mov	esi, DWORD PTR _buffer$[ebp]
	push	ebx
	npad	4
$LL2@stb_adler3:

; 2265 :         for (i=0; i + 7 < blocklen; i += 8) {

	xor	ebx, ebx
	cmp	edx, 7
	jbe	SHORT $LN5@stb_adler3
	mov	eax, 7
	sub	eax, esi
	mov	DWORD PTR tv601[ebp], eax
$LL6@stb_adler3:

; 2266 :             s1 += buffer[0], s2 += s1;

	movzx	eax, BYTE PTR [esi]
	add	ebx, 8
	add	ecx, eax

; 2267 :             s1 += buffer[1], s2 += s1;

	movzx	eax, BYTE PTR [esi+1]
	add	edi, ecx
	add	ecx, eax

; 2268 :             s1 += buffer[2], s2 += s1;

	movzx	eax, BYTE PTR [esi+2]
	add	edi, ecx
	add	ecx, eax

; 2269 :             s1 += buffer[3], s2 += s1;

	movzx	eax, BYTE PTR [esi+3]
	add	edi, ecx
	add	ecx, eax

; 2270 :             s1 += buffer[4], s2 += s1;

	movzx	eax, BYTE PTR [esi+4]
	add	edi, ecx
	add	ecx, eax

; 2271 :             s1 += buffer[5], s2 += s1;

	movzx	eax, BYTE PTR [esi+5]
	add	edi, ecx
	add	ecx, eax

; 2272 :             s1 += buffer[6], s2 += s1;

	movzx	eax, BYTE PTR [esi+6]
	add	edi, ecx
	add	ecx, eax

; 2273 :             s1 += buffer[7], s2 += s1;

	movzx	eax, BYTE PTR [esi+7]
	add	edi, ecx

; 2274 : 
; 2275 :             buffer += 8;

	add	esi, 8
	add	ecx, eax
	mov	eax, DWORD PTR tv601[ebp]
	add	eax, esi
	add	edi, ecx
	cmp	eax, edx
	jb	SHORT $LL6@stb_adler3
	mov	DWORD PTR _adler32$[ebp], edi
$LN5@stb_adler3:
	mov	eax, DWORD PTR _blocklen$1$[ebp]
	xor	edx, edx
	mov	DWORD PTR $T2[ebp], edx
	mov	DWORD PTR $T1[ebp], edx
	cmp	ebx, eax
	jae	SHORT $LN20@stb_adler3
	sub	eax, ebx

; 2276 :         }
; 2277 : 
; 2278 :         for (; i < blocklen; ++i)

	cmp	eax, 2
	jb	SHORT $LC21@stb_adler3
	mov	edx, DWORD PTR _blocklen$1$[ebp]
	sub	edx, ebx
	sub	edx, 2
	shr	edx, 1
	inc	edx
	lea	ebx, DWORD PTR [ebx+edx*2]
	mov	DWORD PTR _i$1$[ebp], ebx
	mov	ebx, DWORD PTR $T2[ebp]
	mov	edi, ebx
	npad	2
$LL23@stb_adler3:

; 2279 :             s1 += *buffer++, s2 += s1;

	movzx	eax, BYTE PTR [esi]
	add	ecx, eax
	movzx	eax, BYTE PTR [esi+1]
	add	ebx, ecx
	add	esi, 2
	add	ecx, eax
	add	edi, ecx
	sub	edx, 1
	jne	SHORT $LL23@stb_adler3
	mov	DWORD PTR $T2[ebp], ebx
	mov	ebx, DWORD PTR _i$1$[ebp]
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T1[ebp], edi
	mov	edi, DWORD PTR _adler32$[ebp]
$LC21@stb_adler3:

; 2276 :         }
; 2277 : 
; 2278 :         for (; i < blocklen; ++i)

	cmp	ebx, DWORD PTR _blocklen$1$[ebp]
	jae	SHORT $LN22@stb_adler3

; 2279 :             s1 += *buffer++, s2 += s1;

	movzx	eax, BYTE PTR [esi]
	add	ecx, eax
	add	edi, ecx
	inc	esi
$LN22@stb_adler3:
	mov	eax, DWORD PTR $T1[ebp]
	add	eax, edx
	add	edi, eax
$LN20@stb_adler3:

; 2280 : 
; 2281 :         s1 %= ADLER_MOD, s2 %= ADLER_MOD;

	mov	eax, -2146992015			; 80078071H
	mul	ecx
	shr	edx, 15					; 0000000fH
	imul	eax, edx, -65521
	add	ecx, eax
	mov	eax, -2146992015			; 80078071H
	mul	edi
	shr	edx, 15					; 0000000fH
	imul	eax, edx, -65521

; 2282 :         buflen -= blocklen;

	mov	edx, DWORD PTR _blocklen$1$[ebp]
	add	edi, eax
	sub	DWORD PTR _buflen$[ebp], edx

; 2283 :         blocklen = 5552;

	mov	edx, 5552				; 000015b0H
	mov	DWORD PTR _adler32$[ebp], edi
	mov	DWORD PTR _blocklen$1$[ebp], edx
	jne	$LL2@stb_adler3
	pop	ebx
$LN3@stb_adler3:

; 2284 :     }
; 2285 :     return (unsigned int)(s2 << 16) + (unsigned int)s1;

	shl	edi, 16					; 00000010H
	lea	eax, DWORD PTR [ecx+edi]
	pop	edi
	pop	esi

; 2286 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?stb_adler32@@YAIIPAEI@Z ENDP				; stb_adler32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_i$ = 8							; size = 4
?stb_decompress_token@@YAPAEPAE@Z PROC			; stb_decompress_token

; 2241 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 2242 :     if (*i >= 0x20) { // use fewer if's for cases that expand small

	mov	esi, DWORD PTR _i$[ebp]
	mov	dl, BYTE PTR [esi]
	cmp	dl, 32					; 00000020H
	jb	$LN2@stb_decomp

; 2243 :         if (*i >= 0x80)       stb__match(stb__dout-i[1]-1, i[0] - 0x80 + 1), i += 2;

	cmp	dl, 128					; 00000080H
	jb	SHORT $LN4@stb_decomp
	mov	ecx, DWORD PTR ?stb__dout@@3PAEA
	movzx	eax, dl
	sub	eax, 127				; 0000007fH
	push	eax
	movzx	eax, BYTE PTR [esi+1]
	sub	ecx, eax
	dec	ecx
	push	ecx
	call	?stb__match@@YAXPAEI@Z			; stb__match
	add	esp, 8
	add	esi, 2

; 2253 :     }
; 2254 :     return i;

	mov	eax, esi
	pop	esi

; 2255 : }

	pop	ebp
	ret	0
$LN4@stb_decomp:

; 2244 :         else if (*i >= 0x40)  stb__match(stb__dout-(stb__in2(0) - 0x4000 + 1), i[2]+1), i += 3;

	cmp	dl, 64					; 00000040H
	jb	SHORT $LN6@stb_decomp
	movzx	eax, BYTE PTR [esi+2]
	mov	ecx, DWORD PTR ?stb__dout@@3PAEA
	inc	eax
	push	eax
	movzx	eax, dl
	shl	eax, 8
	sub	ecx, eax
	movzx	eax, BYTE PTR [esi+1]
	sub	ecx, eax
	add	ecx, 16383				; 00003fffH
	push	ecx
	call	?stb__match@@YAXPAEI@Z			; stb__match
	add	esp, 8
	add	esi, 3

; 2253 :     }
; 2254 :     return i;

	mov	eax, esi
	pop	esi

; 2255 : }

	pop	ebp
	ret	0
$LN6@stb_decomp:

; 2245 :         else /* *i >= 0x20 */ stb__lit(i+1, i[0] - 0x20 + 1), i += 1 + (i[0] - 0x20 + 1);

	movzx	eax, dl
	sub	eax, 31					; 0000001fH
	push	eax
	lea	eax, DWORD PTR [esi+1]
	push	eax
	call	?stb__lit@@YAXPAEI@Z			; stb__lit
	movzx	eax, BYTE PTR [esi]
	add	esp, 8
	add	esi, -30				; ffffffe2H
	add	esi, eax

; 2253 :     }
; 2254 :     return i;

	mov	eax, esi
	pop	esi

; 2255 : }

	pop	ebp
	ret	0
$LN2@stb_decomp:

; 2246 :     } else { // more ifs for cases that expand large, since overhead is amortized
; 2247 :         if (*i >= 0x18)       stb__match(stb__dout-(stb__in3(0) - 0x180000 + 1), i[3]+1), i += 4;

	cmp	dl, 24					; 00000018H
	jb	SHORT $LN8@stb_decomp
	movzx	eax, BYTE PTR [esi+3]
	mov	ecx, DWORD PTR ?stb__dout@@3PAEA
	inc	eax
	push	eax
	movzx	eax, BYTE PTR [esi+1]
	shl	eax, 8
	sub	ecx, eax
	movzx	eax, dl
	shl	eax, 16					; 00000010H
	sub	ecx, eax
	movzx	eax, BYTE PTR [esi+2]
	sub	ecx, eax
	add	ecx, 1572863				; 0017ffffH
	push	ecx
	call	?stb__match@@YAXPAEI@Z			; stb__match
	add	esp, 8
	add	esi, 4

; 2253 :     }
; 2254 :     return i;

	mov	eax, esi
	pop	esi

; 2255 : }

	pop	ebp
	ret	0
$LN8@stb_decomp:

; 2248 :         else if (*i >= 0x10)  stb__match(stb__dout-(stb__in3(0) - 0x100000 + 1), stb__in2(3)+1), i += 5;

	cmp	dl, 16					; 00000010H
	jb	SHORT $LN10@stb_decomp
	movzx	ecx, BYTE PTR [esi+3]
	movzx	eax, BYTE PTR [esi+4]
	shl	ecx, 8
	inc	eax
	add	eax, ecx
	mov	ecx, DWORD PTR ?stb__dout@@3PAEA
	push	eax
	movzx	eax, BYTE PTR [esi+1]
	shl	eax, 8
	sub	ecx, eax
	movzx	eax, dl
	shl	eax, 16					; 00000010H
	sub	ecx, eax
	movzx	eax, BYTE PTR [esi+2]
	sub	ecx, eax
	add	ecx, 1048575				; 000fffffH
	push	ecx
	call	?stb__match@@YAXPAEI@Z			; stb__match
	add	esp, 8
	add	esi, 5

; 2253 :     }
; 2254 :     return i;

	mov	eax, esi
	pop	esi

; 2255 : }

	pop	ebp
	ret	0
$LN10@stb_decomp:

; 2249 :         else if (*i >= 0x08)  stb__lit(i+2, stb__in2(0) - 0x0800 + 1), i += 2 + (stb__in2(0) - 0x0800 + 1);

	cmp	dl, 8
	jb	SHORT $LN12@stb_decomp
	movzx	eax, BYTE PTR [esi+1]
	movzx	ecx, dl
	add	eax, -2047				; fffff801H
	shl	ecx, 8
	add	eax, ecx
	push	eax
	lea	eax, DWORD PTR [esi+2]
	push	eax
	call	?stb__lit@@YAXPAEI@Z			; stb__lit
	movzx	ecx, BYTE PTR [esi]
	add	esp, 8
	movzx	eax, BYTE PTR [esi+1]
	shl	ecx, 8
	add	eax, esi
	lea	esi, DWORD PTR [ecx-2045]
	add	esi, eax

; 2253 :     }
; 2254 :     return i;

	mov	eax, esi
	pop	esi

; 2255 : }

	pop	ebp
	ret	0
$LN12@stb_decomp:

; 2250 :         else if (*i == 0x07)  stb__lit(i+3, stb__in2(1) + 1), i += 3 + (stb__in2(1) + 1);

	cmp	dl, 7
	jne	SHORT $LN14@stb_decomp
	movzx	ecx, BYTE PTR [esi+1]
	movzx	eax, BYTE PTR [esi+2]
	inc	eax
	shl	ecx, 8
	add	eax, ecx
	push	eax
	lea	eax, DWORD PTR [esi+3]
	push	eax
	call	?stb__lit@@YAXPAEI@Z			; stb__lit
	movzx	ecx, BYTE PTR [esi+1]
	add	esp, 8
	movzx	eax, BYTE PTR [esi+2]
	shl	ecx, 8
	add	eax, esi
	lea	esi, DWORD PTR [ecx+4]
	add	esi, eax

; 2253 :     }
; 2254 :     return i;

	mov	eax, esi
	pop	esi

; 2255 : }

	pop	ebp
	ret	0
$LN14@stb_decomp:

; 2251 :         else if (*i == 0x06)  stb__match(stb__dout-(stb__in3(1)+1), i[4]+1), i += 5;

	cmp	dl, 6
	jne	SHORT $LN16@stb_decomp
	movzx	eax, BYTE PTR [esi+4]
	mov	ecx, DWORD PTR ?stb__dout@@3PAEA
	inc	eax
	push	eax
	movzx	eax, BYTE PTR [esi+1]
	shl	eax, 16					; 00000010H
	sub	ecx, eax
	movzx	eax, BYTE PTR [esi+2]
	shl	eax, 8
	sub	ecx, eax
	movzx	eax, BYTE PTR [esi+3]
	sub	ecx, eax
	dec	ecx
	push	ecx
	call	?stb__match@@YAXPAEI@Z			; stb__match
	add	esp, 8
	add	esi, 5

; 2253 :     }
; 2254 :     return i;

	mov	eax, esi
	pop	esi

; 2255 : }

	pop	ebp
	ret	0
$LN16@stb_decomp:

; 2252 :         else if (*i == 0x04)  stb__match(stb__dout-(stb__in3(1)+1), stb__in2(4)+1), i += 6;

	cmp	dl, 4
	jne	SHORT $LN18@stb_decomp
	movzx	ecx, BYTE PTR [esi+4]
	movzx	eax, BYTE PTR [esi+5]
	mov	edx, DWORD PTR ?stb__dout@@3PAEA
	inc	eax
	shl	ecx, 8
	add	eax, ecx
	movzx	ecx, BYTE PTR [esi+3]
	push	eax
	movzx	eax, BYTE PTR [esi+1]
	shl	eax, 16					; 00000010H
	sub	edx, eax
	movzx	eax, BYTE PTR [esi+2]
	shl	eax, 8
	sub	edx, eax
	sub	edx, ecx
	dec	edx
	push	edx
	call	?stb__match@@YAXPAEI@Z			; stb__match
	add	esp, 8
	add	esi, 6
$LN18@stb_decomp:

; 2253 :     }
; 2254 :     return i;

	mov	eax, esi
	pop	esi

; 2255 : }

	pop	ebp
	ret	0
?stb_decompress_token@@YAPAEPAE@Z ENDP			; stb_decompress_token
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_data$ = 8						; size = 4
_length$ = 12						; size = 4
?stb__lit@@YAXPAEI@Z PROC				; stb__lit

; 2228 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2229 :     IM_ASSERT (stb__dout + length <= stb__barrier);
; 2230 :     if (stb__dout + length > stb__barrier) { stb__dout += length; return; }

	mov	ecx, DWORD PTR ?stb__dout@@3PAEA
	mov	edx, DWORD PTR _length$[ebp]
	mov	eax, DWORD PTR ?stb__barrier@@3PAEA
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	cmp	esi, eax
	jbe	SHORT $LN2@stb__lit
	mov	DWORD PTR ?stb__dout@@3PAEA, esi
	pop	esi

; 2234 : }

	pop	ebp
	ret	0
$LN2@stb__lit:
	push	edi

; 2231 :     if (data < stb__barrier2) { stb__dout = stb__barrier+1; return; }

	mov	edi, DWORD PTR _data$[ebp]
	cmp	edi, DWORD PTR ?stb__barrier2@@3PAEA
	jae	SHORT $LN3@stb__lit
	inc	eax
	pop	edi
	mov	DWORD PTR ?stb__dout@@3PAEA, eax
	pop	esi

; 2234 : }

	pop	ebp
	ret	0
$LN3@stb__lit:

; 2232 :     memcpy(stb__dout, data, length);

	push	edx
	push	edi
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2233 :     stb__dout += length;

	mov	DWORD PTR ?stb__dout@@3PAEA, esi
	pop	edi
	pop	esi

; 2234 : }

	pop	ebp
	ret	0
?stb__lit@@YAXPAEI@Z ENDP				; stb__lit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_data$ = 8						; size = 4
_length$ = 12						; size = 4
?stb__match@@YAXPAEI@Z PROC				; stb__match

; 2219 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2220 :     // INVERSE of memmove... write each byte before copying the next...
; 2221 :     IM_ASSERT (stb__dout + length <= stb__barrier);
; 2222 :     if (stb__dout + length > stb__barrier) { stb__dout += length; return; }

	mov	eax, DWORD PTR ?stb__dout@@3PAEA
	mov	edx, DWORD PTR _length$[ebp]
	push	edi
	mov	edi, DWORD PTR ?stb__barrier@@3PAEA
	lea	ecx, DWORD PTR [eax+edx]
	cmp	ecx, edi
	jbe	SHORT $LN4@stb__match
	mov	DWORD PTR ?stb__dout@@3PAEA, ecx
	pop	edi

; 2225 : }

	pop	ebp
	ret	0
$LN4@stb__match:
	push	esi

; 2223 :     if (data < stb__barrier4) { stb__dout = stb__barrier+1; return; }

	mov	esi, DWORD PTR _data$[ebp]
	cmp	esi, DWORD PTR ?stb__barrier4@@3PAEA
	jae	SHORT $LN7@stb__match
	lea	eax, DWORD PTR [edi+1]
	pop	esi

; 2224 :     while (length--) *stb__dout++ = *data++;

	mov	DWORD PTR ?stb__dout@@3PAEA, eax
	pop	edi

; 2225 : }

	pop	ebp
	ret	0
$LN7@stb__match:

; 2224 :     while (length--) *stb__dout++ = *data++;

	test	edx, edx
	je	SHORT $LN12@stb__match
	sub	esi, eax
$LL2@stb__match:
	mov	cl, BYTE PTR [esi+eax]
	mov	BYTE PTR [eax], cl
	inc	eax
	sub	edx, 1
	jne	SHORT $LL2@stb__match
	mov	DWORD PTR ?stb__dout@@3PAEA, eax
$LN12@stb__match:
	pop	esi
	pop	edi

; 2225 : }

	pop	ebp
	ret	0
?stb__match@@YAXPAEI@Z ENDP				; stb__match
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >::operator!=, COMDAT
; _this$ = ecx

; 301  : 		{	// test for iterator inequality

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 302  : 		return (!(*this == _Right));
; 303  : 		}

	pop	ebp
	ret	4
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >::operator==, COMDAT
; _this$ = ecx

; 286  : 		{	// test for iterator equality

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 287  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 288  : 		if (this->_Getcont() != _Right._Getcont())
; 289  : 			{	// report error
; 290  : 			_DEBUG_ERROR("list iterators incompatible");
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 295  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 296  : 
; 297  : 		return (this->_Ptr == _Right._Ptr);
; 298  : 		}

	pop	ebp
	ret	4
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >::operator++, COMDAT
; _this$ = ecx

; 247  : 		{	// postincrement

	npad	2
	push	ebp
	mov	ebp, esp

; 248  : 		_Myiter _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx

; 242  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], edx

; 249  : 		++*this;
; 250  : 		return (_Tmp);
; 251  : 		}

	pop	ebp
	ret	8
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >::operator++, COMDAT
; _this$ = ecx

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [ecx]

; 226  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 227  : 		const auto _Mycont = static_cast<const _Mylist *>(this->_Getcont());
; 228  : 		if (_Mycont == 0
; 229  : 			|| this->_Ptr == nullptr_t{}
; 230  : 			|| this->_Ptr == _Mycont->_Myhead)
; 231  : 			{	// report error
; 232  : 			_DEBUG_ERROR("list iterator not incrementable");
; 233  : 			}
; 234  : 
; 235  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 236  : 		_SCL_SECURE_VALIDATE(this->_Ptr != nullptr_t{});
; 237  : 		const auto _Mycont = static_cast<const _Mylist *>(this->_Getcont());
; 238  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 239  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr != _Mycont->_Myhead);
; 240  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 241  : 
; 242  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 243  : 		return (*this);

	mov	eax, ecx

; 244  : 		}

	ret	0
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QBEABGXZ
_TEXT	SEGMENT
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QBEABGXZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >::operator*, COMDAT
; _this$ = ecx

; 540  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR [ecx]
	add	eax, 8

; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		const auto _Mycont = static_cast<const _Mylist *>(this->_Getcont());
; 207  : 		if (_Mycont == 0
; 208  : 			|| this->_Ptr == nullptr_t{}
; 209  : 			|| this->_Ptr == _Mycont->_Myhead)
; 210  : 			{	// report error
; 211  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Ptr != nullptr_t{});
; 216  : 		const auto _Mycont = static_cast<const _Mylist *>(this->_Getcont());
; 217  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 218  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr != _Mycont->_Myhead);
; 219  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 220  : 
; 221  : 		return (_Mylist::_Myval(this->_Ptr));
; 222  : 		}

	ret	0
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QBEABGXZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Unchecked@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >::_Unchecked, COMDAT
; _this$ = ecx

; 199  : 		{	// make an unchecked iterator

	npad	2
	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 200  : 		return (_Unchecked_type(this->_Ptr, static_cast<const _Mylist *>(this->_Getcont())));
; 201  : 		}

	pop	ebp
	ret	4
?_Unchecked@?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QAE@PAU?$_List_node@GPAX@1@PBV?$_List_val@U?$_List_simple_types@G@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QAE@PAU?$_List_node@GPAX@1@PBV?$_List_val@U?$_List_simple_types@G@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >, COMDAT
; _this$ = ecx

; 187  : 		{	// construct with node pointer _Pnode

	npad	2
	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], eax

; 188  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@QAE@PAU?$_List_node@GPAX@1@PBV?$_List_val@U?$_List_simple_types@G@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >::_List_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@GPAX@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@GPAX@2@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 96   : 		return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 97   : 		}

	ret	0
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@GPAX@2@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>::operator!=, COMDAT
; _this$ = ecx

; 90   : 		{	// test for iterator inequality

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 91   : 		return (!(*this == _Right));
; 92   : 		}

	pop	ebp
	ret	4
??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>::operator==, COMDAT
; _this$ = ecx

; 85   : 		{	// test for iterator equality

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 86   : 		return (_Ptr == _Right._Ptr);
; 87   : 		}

	pop	ebp
	ret	4
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx], eax

; 74   : 		return (*this);

	mov	eax, ecx

; 75   : 		}

	ret	0
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [ecx]

; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 61   : 		return (*this);

	mov	eax, ecx

; 62   : 		}

	ret	0
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@QBEABGXZ
_TEXT	SEGMENT
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@QBEABGXZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>::operator*, COMDAT
; _this$ = ecx

; 540  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR [ecx]
	add	eax, 8

; 50   : 		return (_Mylist::_Myval(_Ptr));
; 51   : 		}

	ret	0
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@QBEABGXZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@GPAX@1@PBV?$_List_val@U?$_List_simple_types@G@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@GPAX@1@PBV?$_List_val@U?$_List_simple_types@G@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 44   : 		{	// construct with node pointer _Pnode

	npad	2
	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@GPAX@1@PBV?$_List_val@U?$_List_simple_types@G@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 38   : 		: _Ptr()

	mov	DWORD PTR [ecx], 0

; 40   : 		}

	mov	eax, ecx
	ret	0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ??$emplace@G@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@$$QAG@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_<_Val_0>$ = 12						; size = 4
??$emplace@G@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@$$QAG@Z PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::emplace<unsigned short>, COMDAT
; _this$ = ecx

; 294  : 		{	// try to insert value_type(_Val...)

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ebx, ecx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 1085 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),

	push	DWORD PTR _<_Val_0>$[ebp]

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [ebx+4]

; 1085 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),

	lea	ecx, DWORD PTR [ebx+4]

; 96   : 		return (_Ptr);

	mov	edi, DWORD PTR [eax]

; 1085 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),

	push	DWORD PTR [edi+4]
	push	edi
	call	??$_Buynode@G@?$_List_buy@GV?$allocator@G@std@@@std@@QAEPAU?$_List_node@GPAX@1@PAU21@0$$QAG@Z ; std::_List_buy<unsigned short,std::allocator<unsigned short> >::_Buynode<unsigned short>
	mov	edx, eax

; 1950 : 		if (max_size() - this->_Mysize() - 1 < _Count)

	mov	ecx, 357913940				; 15555554H
	mov	eax, DWORD PTR [ebx+8]
	sub	ecx, eax
	cmp	ecx, 1
	jae	SHORT $LN53@emplace

; 1951 : 			_Xlength_error("list<T> too long");

	push	OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN181@emplace:
$LN53@emplace:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 296  : 		return (_Insert(_List.front(), _Unchecked_begin()));

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 1952 : 		this->_Mysize() += _Count;

	inc	eax
	mov	DWORD PTR [ebx+8], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 296  : 		return (_Insert(_List.front(), _Unchecked_begin()));

	mov	ecx, ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 1088 : 		this->_Prevnode(_Pnode) = _Newnode;

	mov	DWORD PTR [edi+4], edx

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [edx+4]

; 1089 : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;

	mov	DWORD PTR [eax], edx

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 347  : 		return (_List._Unchecked_begin());

	mov	eax, DWORD PTR [eax]

; 296  : 		return (_Insert(_List.front(), _Unchecked_begin()));

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 540  : 		return ((reference)_Pnode->_Myval);

	add	eax, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 296  : 		return (_Insert(_List.front(), _Unchecked_begin()));

	push	eax
	push	esi
	call	??$_Insert@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@AAGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Insert<unsigned short &,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 297  : 		}

	pop	ebp
	ret	8
$LN180@emplace:
??$emplace@G@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@$$QAG@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::emplace<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Funprintable_chars@?DL@??RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z@YAXXZ
text$yd	SEGMENT
??__Funprintable_chars@?DL@??RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z@YAXXZ PROC ; `ImFont::RenderText'::`59'::`dynamic atexit destructor for 'unprintable_chars'', COMDAT
	mov	ecx, OFFSET ?unprintable_chars@?DL@??RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z@4V?$unordered_set@GU?$hash@G@std@@U?$equal_to@G@2@V?$allocator@G@2@@std@@A
	jmp	??1?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE@XZ ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::~_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >
??__Funprintable_chars@?DL@??RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z@YAXXZ ENDP ; `ImFont::RenderText'::`59'::`dynamic atexit destructor for 'unprintable_chars''
text$yd	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$unordered_set@GU?$hash@G@std@@U?$equal_to@G@2@V?$allocator@G@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$unordered_set@GU?$hash@G@std@@U?$equal_to@G@2@V?$allocator@G@2@@std@@QAE@XZ PROC ; std::unordered_set<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short>,std::allocator<unsigned short> >::~unordered_set<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short>,std::allocator<unsigned short> >, COMDAT
; _this$ = ecx
	jmp	??1?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE@XZ ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::~_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >
??1?$unordered_set@GU?$hash@G@std@@U?$equal_to@G@2@V?$allocator@G@2@@std@@QAE@XZ ENDP ; std::unordered_set<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short>,std::allocator<unsigned short> >::~unordered_set<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short>,std::allocator<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_set
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_set
;	COMDAT ??0?$unordered_set@GU?$hash@G@std@@U?$equal_to@G@2@V?$allocator@G@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -8						; size = 4
$T2 = -1						; size = 1
??0?$unordered_set@GU?$hash@G@std@@U?$equal_to@G@2@V?$allocator@G@2@@std@@QAE@XZ PROC ; std::unordered_set<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short>,std::allocator<unsigned short> >::unordered_set<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short>,std::allocator<unsigned short> >, COMDAT
; _this$ = ecx

; 91   : 		{	// construct empty set from defaults

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 90   : 		: _Mybase(key_compare(), allocator_type())

	lea	eax, DWORD PTR $T2[ebp]

; 91   : 		{	// construct empty set from defaults

	mov	esi, ecx
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _this$[ebp], esi
	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 311  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

	mov	DWORD PTR $T1[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_set

; 90   : 		: _Mybase(key_compare(), allocator_type())

	call	??0?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@1@ABV?$allocator@G@1@@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >

; 92   : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$unordered_set@GU?$hash@G@std@@U?$equal_to@G@2@V?$allocator@G@2@@std@@QAE@XZ ENDP ; std::unordered_set<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short>,std::allocator<unsigned short> >::unordered_set<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short>,std::allocator<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Xlength@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Xlength, COMDAT

; 1962 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlength:
$LN3@Xlength:
	int	3
?_Xlength@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Tidy@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXXZ PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Tidy, COMDAT
; _this$ = ecx

; 1946 : 		{	// free all storage

	npad	2
	push	esi
	mov	esi, ecx

; 1947 : 		this->_Orphan_all();
; 1948 : 
; 1949 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:
	pop	esi

; 1957 : 			}
; 1958 : 		}

	ret	0
?_Tidy@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXXZ ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Change_array@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@II@Z PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Change_array, COMDAT
; _this$ = ecx

; 1931 : 		{	// orphan all iterators, discard old array, acquire new array

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 1932 : 		this->_Orphan_all();
; 1933 : 
; 1934 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Change_arr

; 1937 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1937 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN2@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1940 : 		this->_Myfirst() = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[ebp]

; 1941 : 		this->_Mylast() = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1942 : 		this->_Myend() = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1943 : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Change_array@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@II@Z ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Buy@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAE_NI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?_Buy@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAE_NI@Z PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Buy, COMDAT
; _this$ = ecx

; 1908 : 		{	// allocate array with _Newcapacity elements

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 1909 : 		this->_Myfirst() = pointer();
; 1910 : 		this->_Mylast() = pointer();
; 1911 : 		this->_Myend() = pointer();
; 1912 : 
; 1913 : 		if (_Newcapacity == 0)

	mov	edi, DWORD PTR __Newcapacity$[ebp]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	test	edi, edi
	jne	SHORT $LN2@Buy

; 1914 : 			{
; 1915 : 			return (false);

	pop	edi
	xor	al, al
	pop	esi

; 1928 : 		}

	pop	ebp
	ret	4
$LN2@Buy:

; 1916 : 			}
; 1917 : 
; 1918 : 		if (_Newcapacity > max_size())

	cmp	edi, 1073741823				; 3fffffffH
	ja	SHORT $LN115@Buy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1077 : 		return (_Mybase::allocate(_Count));

	push	edi
	call	?allocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >::allocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1923 : 		this->_Myfirst() = this->_Getal().allocate(_Newcapacity);

	mov	DWORD PTR [esi], eax

; 1924 : 		this->_Mylast() = this->_Myfirst();

	mov	DWORD PTR [esi+4], eax

; 1925 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

	mov	eax, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+8], eax

; 1926 : 
; 1927 : 		return (true);

	mov	al, 1
	pop	edi
	pop	esi

; 1928 : 		}

	pop	ebp
	ret	4
$LN115@Buy:

; 1919 : 			{
; 1920 : 			_Xlength();

	call	?_Xlength@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Xlength
$LN117@Buy:
$LN114@Buy:
	int	3
?_Buy@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAE_NI@Z ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Calculate_growth@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@ABEII@Z PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1889 : 		{	// given _Oldcapacity and _Newsize, calculate geometric growth

	npad	2
	push	ebp
	mov	ebp, esp

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	edx, DWORD PTR [ecx+8]

; 1890 : 		const size_type _Oldcapacity = capacity();
; 1891 : 
; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	eax, 1073741823				; 3fffffffH

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sub	edx, DWORD PTR [ecx]
	sar	edx, 2

; 1890 : 		const size_type _Oldcapacity = capacity();
; 1891 : 
; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	ecx, edx
	shr	ecx, 1
	sub	eax, ecx
	cmp	edx, eax
	jbe	SHORT $LN2@Calculate_

; 1893 : 			{
; 1894 : 			return (_Newsize);	// geometric growth would overflow

	mov	eax, DWORD PTR __Newsize$[ebp]

; 1900 : 			{
; 1901 : 			return (_Newsize);	// geometric growth would be insufficient
; 1902 : 			}
; 1903 : 
; 1904 : 		return (_Geometric);	// geometric growth is sufficient
; 1905 : 		}

	pop	ebp
	ret	4
$LN2@Calculate_:

; 1895 : 			}
; 1896 : 
; 1897 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [ecx+edx]

; 1898 : 
; 1899 : 		if (_Geometric < _Newsize)

	cmp	eax, DWORD PTR __Newsize$[ebp]
	cmovb	eax, DWORD PTR __Newsize$[ebp]

; 1900 : 			{
; 1901 : 			return (_Newsize);	// geometric growth would be insufficient
; 1902 : 			}
; 1903 : 
; 1904 : 		return (_Geometric);	// geometric growth is sufficient
; 1905 : 		}

	pop	ebp
	ret	4
?_Calculate_growth@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@ABEII@Z ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Destroy@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@0@Z PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Destroy, COMDAT
; _this$ = ecx

; 1885 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1886 : 		}

	ret	8
?_Destroy@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@0@Z ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
$T1 = 16						; size = 1
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@00@Z PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Umove_if_noexcept, COMDAT
; _this$ = ecx

; 1878 : 		{	// move_if_noexcept [_First, _Last) to raw _Dest, using allocator

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 172  : 	return (_Rechecked(_Dest,

	push	ecx
	push	DWORD PTR $T1[ebp]
	push	ecx
	push	DWORD PTR __Dest$[ebp]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp]
	call	??$_Uninitialized_move_al_unchecked@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >
	add	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1881 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@00@Z ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
$T1 = 16						; size = 1
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Umove_if_noexcept1, COMDAT
; _this$ = ecx

; 1868 : 		{	// move [_First, _Last) to raw _Dest, using allocator

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 172  : 	return (_Rechecked(_Dest,

	push	ecx
	push	DWORD PTR $T1[ebp]
	push	ecx
	push	DWORD PTR __Dest$[ebp]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp]
	call	??$_Uninitialized_move_al_unchecked@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >
	add	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1870 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Ufill@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@PAV32@IABV32@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
$T1 = 16						; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@PAV32@IABV32@@Z PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Ufill, COMDAT
; _this$ = ecx

; 1852 : 		{	// fill raw _Dest with _Count copies of _Val, using allocator

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 217  : 	return (_Uninit_alloc_fill_n1(_First, _Count, _Val, _Al,

	push	DWORD PTR $T1[ebp]
	push	ecx
	push	DWORD PTR __Val$[ebp]
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Dest$[ebp]
	call	??$_Uninit_alloc_fill_n1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@IU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@PAV10@IABV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninit_alloc_fill_n1<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,unsigned int,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >
	add	esp, 20					; 00000014H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1854 : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@PAV32@IABV32@@Z ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Ufill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??A?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QBEABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QBEABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@I@Z PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::operator[], COMDAT
; _this$ = ecx

; 1750 : 		{	// subscript nonmutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 1751 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1752 : 		if (size() <= _Pos)
; 1753 : 			{	// report error
; 1754 : 			_DEBUG_ERROR("vector subscript out of range");
; 1755 : 			}
; 1756 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1757 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1758 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1759 : 
; 1760 : 		return (this->_Myfirst()[_Pos]);

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]

; 1761 : 		}

	pop	ebp
	ret	4
??A?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QBEABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@I@Z ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??A?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QAEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QAEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@I@Z PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::operator[], COMDAT
; _this$ = ecx

; 1736 : 		{	// subscript mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 1737 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1738 : 		if (size() <= _Pos)
; 1739 : 			{	// report error
; 1740 : 			_DEBUG_ERROR("vector subscript out of range");
; 1741 : 			}
; 1742 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1743 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1744 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1745 : 
; 1746 : 		return (this->_Myfirst()[_Pos]);

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]

; 1747 : 		}

	pop	ebp
	ret	4
??A?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QAEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@I@Z ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?capacity@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::capacity, COMDAT
; _this$ = ecx

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1721 : 		}

	ret	0
?capacity@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?max_size@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::max_size, COMDAT
; _this$ = ecx

; 1715 : 		return (this->_Getal().max_size());

	mov	eax, 1073741823				; 3fffffffH

; 1716 : 		}

	ret	0
?max_size@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?size@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::size, COMDAT
; _this$ = ecx

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1711 : 		}

	ret	0
?size@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?reserve@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?reserve@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QAEXI@Z PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::reserve, COMDAT
; _this$ = ecx

; 1528 : 		{	// increase capacity to _Newcapacity (without geometric growth), provide strong guarantee

	npad	2
	push	ebp
	mov	ebp, esp

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]

; 1529 : 		if (_Newcapacity > capacity())

	mov	edx, DWORD PTR __Newcapacity$[ebp]

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sar	eax, 2

; 1529 : 		if (_Newcapacity > capacity())

	cmp	edx, eax
	jbe	SHORT $LN2@reserve

; 1530 : 			{	// something to do (reserve() never shrinks)
; 1531 : 			if (_Newcapacity > max_size())

	cmp	edx, 1073741823				; 3fffffffH
	ja	SHORT $LN55@reserve

; 1534 : 				}
; 1535 : 
; 1536 : 			_Reallocate_exactly(_Newcapacity);

	mov	DWORD PTR __Newcapacity$[ebp], edx

; 1537 : 			}
; 1538 : 		}

	pop	ebp

; 1534 : 				}
; 1535 : 
; 1536 : 			_Reallocate_exactly(_Newcapacity);

	jmp	?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXI@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Reallocate_exactly
$LN2@reserve:

; 1537 : 			}
; 1538 : 		}

	pop	ebp
	ret	4
$LN55@reserve:

; 1532 : 				{
; 1533 : 				_Xlength();

	call	?_Xlength@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Xlength
$LN57@reserve:
$LN54@reserve:
	int	3
?reserve@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QAEXI@Z ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXI@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Newvec$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T2 = 8							; size = 1
__Newcapacity$ = 8					; size = 4
?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXI@Z PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Reallocate_exactly, COMDAT
; _this$ = ecx

; 1511 : 		{	// set capacity to _Newcapacity (without geometric growth), provide strong guarantee

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1077 : 		return (_Mybase::allocate(_Count));

	push	DWORD PTR __Newcapacity$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ebx, DWORD PTR [esi+4]
	sub	ebx, DWORD PTR [esi]

; 1511 : 		{	// set capacity to _Newcapacity (without geometric growth), provide strong guarantee

	mov	DWORD PTR _this$[ebp], esi

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	sar	ebx, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1077 : 		return (_Mybase::allocate(_Count));

	call	?allocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >::allocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 172  : 	return (_Rechecked(_Dest,

	push	ecx
	push	DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1514 : 		const pointer _Newvec = this->_Getal().allocate(_Newcapacity);

	mov	edi, eax

; 1515 : 
; 1516 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 172  : 	return (_Rechecked(_Dest,

	push	esi
	push	edi
	push	DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1514 : 		const pointer _Newvec = this->_Getal().allocate(_Newcapacity);

	mov	DWORD PTR __Newvec$[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 172  : 	return (_Rechecked(_Dest,

	push	DWORD PTR [esi]
	call	??$_Uninitialized_move_al_unchecked@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1934 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 172  : 	return (_Rechecked(_Dest,

	add	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1934 : 		if (this->_Myfirst() != pointer())

	test	ecx, ecx
	je	SHORT $LN83@Reallocate

; 1937 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1937 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN83@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1524 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]

; 1941 : 		this->_Mylast() = _Newvec + _Newsize;

	lea	eax, DWORD PTR [edi+ebx*4]
	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+4], eax

; 1942 : 		this->_Myend() = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	lea	eax, DWORD PTR [edi+eax*4]

; 1524 : 		}

	pop	edi

; 1942 : 		this->_Myend() = _Newvec + _Newcapacity;

	mov	DWORD PTR [esi+8], eax

; 1524 : 		}

	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXI@Z$0:

; 1517 : 		_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);
; 1518 : 		_CATCH_ALL
; 1519 : 		this->_Getal().deallocate(_Newvec, _Newcapacity);

	push	DWORD PTR __Newcapacity$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	DWORD PTR __Newvec$[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::deallocate

; 1520 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN180@Reallocate:
$LN179@Reallocate:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXI@Z ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Reallocate_exactly
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?assign@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QAEXIABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@@Z
_TEXT	SEGMENT
__Oldsize$1$ = -4					; size = 4
$T1 = 8							; size = 1
__Newsize$ = 8						; size = 4
$T2 = 12						; size = 1
$T3 = 12						; size = 1
__Val$ = 12						; size = 4
?assign@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QAEXIABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@@Z PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::assign, COMDAT
; _this$ = ecx

; 1287 : 		{	// assign _Newsize * _Val

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	mov	ebx, ecx
	push	esi
	push	edi

; 1288 : 		this->_Orphan_all();
; 1289 : 
; 1290 : 		const size_type _Oldsize = size();
; 1291 : 		const size_type _Oldcapacity = capacity();
; 1292 : 
; 1293 : 		if (_Newsize > _Oldcapacity)

	mov	edi, DWORD PTR __Newsize$[ebp]

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	edx, DWORD PTR [ebx]

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	ecx, DWORD PTR [ebx+8]

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [ebx+4]

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sub	ecx, edx

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	sub	eax, edx

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sar	ecx, 2

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	sar	eax, 2
	mov	DWORD PTR __Oldsize$1$[ebp], eax

; 1288 : 		this->_Orphan_all();
; 1289 : 
; 1290 : 		const size_type _Oldsize = size();
; 1291 : 		const size_type _Oldcapacity = capacity();
; 1292 : 
; 1293 : 		if (_Newsize > _Oldcapacity)

	cmp	edi, ecx
	jbe	SHORT $LN2@assign

; 1294 : 			{	// reallocate
; 1295 : 			if (_Newsize > max_size())

	cmp	edi, 1073741823				; 3fffffffH
	ja	$LN297@assign

; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	esi, ecx
	mov	eax, 1073741823				; 3fffffffH
	shr	esi, 1
	sub	eax, esi
	cmp	ecx, eax
	jbe	SHORT $LN79@assign

; 1893 : 			{
; 1894 : 			return (_Newsize);	// geometric growth would overflow

	mov	esi, edi
	jmp	SHORT $LN80@assign
$LN79@assign:

; 1895 : 			}
; 1896 : 
; 1897 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	add	esi, ecx

; 1898 : 
; 1899 : 		if (_Geometric < _Newsize)

	cmp	esi, edi
	cmovb	esi, edi
$LN80@assign:

; 1298 : 				}
; 1299 : 
; 1300 : 			const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1301 : 
; 1302 : 			if (this->_Myfirst() != pointer())

	test	edx, edx
	je	SHORT $LN5@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	ecx
	push	edx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN5@assign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1308 : 			_Buy(_Newcapacity);

	push	esi
	mov	ecx, ebx
	call	?_Buy@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAE_NI@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Buy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 217  : 	return (_Uninit_alloc_fill_n1(_First, _Count, _Val, _Al,

	push	DWORD PTR $T3[ebp]
	push	ebx
	push	DWORD PTR __Val$[ebp]
	push	edi
	push	DWORD PTR [ebx]
	call	??$_Uninit_alloc_fill_n1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@IU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@PAV10@IABV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninit_alloc_fill_n1<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,unsigned int,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >
	add	esp, 20					; 00000014H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1310 : 			this->_Mylast() = _Ufill(this->_Myfirst(), _Newsize, _Val);

	mov	DWORD PTR [ebx+4], eax
	pop	edi
	pop	esi
	pop	ebx

; 1323 : 			}
; 1324 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN2@assign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2682 : 	return {};

	mov	BYTE PTR $T1[ebp], 0

; 2704 : 	_Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));

	push	DWORD PTR $T1[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1312 : 		else if (_Newsize > _Oldsize)

	cmp	edi, eax
	jbe	SHORT $LN6@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2704 : 	_Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));

	mov	esi, DWORD PTR __Val$[ebp]
	push	esi
	push	DWORD PTR [ebx+4]
	push	edx
	call	??$_Fill_unchecked1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@0ABV10@U?$integral_constant@_N$0A@@0@@Z ; std::_Fill_unchecked1<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 217  : 	return (_Uninit_alloc_fill_n1(_First, _Count, _Val, _Al,

	push	DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1315 : 			this->_Mylast() = _Ufill(this->_Mylast(), _Newsize - _Oldsize, _Val);

	sub	edi, DWORD PTR __Oldsize$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 217  : 	return (_Uninit_alloc_fill_n1(_First, _Count, _Val, _Al,

	push	ebx
	push	esi
	push	edi
	push	DWORD PTR [ebx+4]
	call	??$_Uninit_alloc_fill_n1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@IU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@PAV10@IABV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninit_alloc_fill_n1<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,unsigned int,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >
	add	esp, 36					; 00000024H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1315 : 			this->_Mylast() = _Ufill(this->_Mylast(), _Newsize - _Oldsize, _Val);

	mov	DWORD PTR [ebx+4], eax
	pop	edi
	pop	esi
	pop	ebx

; 1323 : 			}
; 1324 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN6@assign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2704 : 	_Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));

	push	DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1319 : 			const pointer _Newlast = this->_Myfirst() + _Newsize;

	lea	esi, DWORD PTR [edx+edi*4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2704 : 	_Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));

	push	esi
	push	edx
	call	??$_Fill_unchecked1@PAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@V12@@std@@YAXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@0@0ABV10@U?$integral_constant@_N$0A@@0@@Z ; std::_Fill_unchecked1<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> *,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1322 : 			this->_Mylast() = _Newlast;

	mov	DWORD PTR [ebx+4], esi
	pop	edi
	pop	esi
	pop	ebx

; 1323 : 			}
; 1324 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN297@assign:

; 1296 : 				{
; 1297 : 				_Xlength();

	call	?_Xlength@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Xlength
$LN299@assign:
$LN296@assign:
	int	3
?assign@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QAEXIABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@@Z ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??1?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::~vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >, COMDAT
; _this$ = ecx

; 891  : 		{	// destroy the object

	npad	2
	push	esi
	mov	esi, ecx

; 1949 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 892  : 		_Tidy();
; 893  : 		}

	ret	0
??1?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::~vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??0?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@@Z PROC ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >, COMDAT
; _this$ = ecx

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 728  : 		}

	mov	eax, ecx

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 728  : 		}

	ret	4
??0?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@1@@Z ENDP ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 343  : 		return (_Myval2);

	mov	eax, ecx

; 344  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 338  : 		return (_Myval2);

	mov	eax, ecx

; 339  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 323  : 		return (*this);

	mov	eax, ecx

; 324  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 318  : 		return (*this);

	mov	eax, ecx

; 319  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >, COMDAT
; _this$ = ecx

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 480  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >::_Vector_val<std::_Simple_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QBEABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QBEABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Myend, COMDAT
; _this$ = ecx

; 676  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 677  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QBEABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QAEAAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QAEAAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Myend, COMDAT
; _this$ = ecx

; 671  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 672  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QAEAAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QBEABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QBEABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Mylast, COMDAT
; _this$ = ecx

; 666  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 667  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QBEABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QAEAAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QAEAAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Mylast, COMDAT
; _this$ = ecx

; 661  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 662  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QAEAAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QBEABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QBEABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Myfirst, COMDAT
; _this$ = ecx

; 656  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 657  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QBEABQAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QAEAAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QAEAAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Myfirst, COMDAT
; _this$ = ecx

; 651  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 652  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QAEAAPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Get_data, COMDAT
; _this$ = ecx

; 646  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 647  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Get_data, COMDAT
; _this$ = ecx

; 641  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 642  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QBEABU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QBEABU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Getal, COMDAT
; _this$ = ecx

; 636  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 637  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QBEABU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Getal, COMDAT
; _this$ = ecx

; 631  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 632  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Orphan_all, COMDAT
; _this$ = ecx

; 621  : 		_Get_data()._Orphan_all();
; 622  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::max_size, COMDAT
; _this$ = ecx

; 1108 : 		return (_Mytraits::max_size(*this));

	mov	eax, 1073741823				; 3fffffffH

; 1109 : 		}

	ret	4
?max_size@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z PROC ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::deallocate, COMDAT
; _this$ = ecx

; 1087 : 		{	// deallocate object at _Ptr, ignore size

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 1088 : 		_Mybase::deallocate(_Ptr, _Count);
; 1089 : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z ENDP ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z PROC ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::allocate, COMDAT
; _this$ = ecx

; 1076 : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 1078 : 		}

	pop	ebp

; 1077 : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >::allocate
?allocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z ENDP ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@SAIABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@SAIABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@Z PROC ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::max_size, COMDAT

; 751  : 		return (_Alloc_max_size::_Fn(0, _Al));

	mov	eax, 1073741823				; 3fffffffH

; 752  : 		}

	ret	0
?max_size@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@@std@@SAIABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@Z ENDP ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >::max_size, COMDAT
; _this$ = ecx

; 1108 : 		return (_Mytraits::max_size(*this));

	mov	eax, 1073741823				; 3fffffffH

; 1109 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >::deallocate, COMDAT
; _this$ = ecx

; 1087 : 		{	// deallocate object at _Ptr, ignore size

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 1088 : 		_Mybase::deallocate(_Ptr, _Count);
; 1089 : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >::allocate, COMDAT
; _this$ = ecx

; 1076 : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 1078 : 		}

	pop	ebp

; 1077 : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >::allocate
?allocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QAE@ABU01@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >, COMDAT
; _this$ = ecx

; 1043 : 		}

	mov	eax, ecx
	ret	4
??0?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@QAE@ABU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@SAIABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@SAIABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >::max_size, COMDAT

; 970  : 		return (_Al.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 971  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@std@@SAIABV?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@QBEIXZ PROC ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >::max_size, COMDAT
; _this$ = ecx

; 851  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 1073741823				; 3fffffffH

; 852  : 		}

	ret	0
?max_size@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z PROC ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >::allocate, COMDAT
; _this$ = ecx

; 827  : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 53   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN5@allocate

; 58   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 2

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 69   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN9@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@allocate:
$LN9@allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 87   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@allocate:
$LN14@allocate:
	int	3
?allocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAEPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z ENDP ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z PROC ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >::deallocate, COMDAT
; _this$ = ecx

; 822  : 		{	// deallocate object at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 824  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAEXPAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z ENDP ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >, COMDAT
; _this$ = ecx

; 807  : 		{	// construct by copying (do nothing)
; 808  : 		}

	mov	eax, ecx
	ret	4
??0?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IBEABMXZ
_TEXT	SEGMENT
?_Max_bucket_size@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IBEABMXZ PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Max_bucket_size, COMDAT
; _this$ = ecx

; 960  : 		return (_Traitsobj._Get_max_bucket_size());

	mov	eax, ecx

; 961  : 		}

	ret	0
?_Max_bucket_size@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IBEABMXZ ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Max_bucket_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEAAMXZ
_TEXT	SEGMENT
?_Max_bucket_size@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEAAMXZ PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Max_bucket_size, COMDAT
; _this$ = ecx

; 955  : 		return (_Traitsobj._Get_max_bucket_size());

	mov	eax, ecx

; 956  : 		}

	ret	0
?_Max_bucket_size@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEAAMXZ ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Max_bucket_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Reinsert@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -8						; size = 8
?_Reinsert@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Reinsert, COMDAT
; _this$ = ecx

; 940  : 		{	// insert elements in [begin(), end())

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	mov	ebx, ecx

; 357  : 		return (_List._Unchecked_end());

	mov	eax, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	DWORD PTR [eax], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 942  : 		if (_Unchecked_begin() != _Last)

	je	SHORT $LN115@Reinsert
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);

	mov	edi, DWORD PTR [eax+4]
$LL2@Reinsert:

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	esi, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 947  : 				_Insert(*_First, _First);

	mov	ecx, ebx

; 347  : 		return (_List._Unchecked_begin());

	mov	esi, DWORD PTR [esi]

; 947  : 				_Insert(*_First, _First);

	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 540  : 		return ((reference)_Pnode->_Myval);

	lea	eax, DWORD PTR [esi+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 947  : 				_Insert(*_First, _First);

	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??$_Insert@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Insert<unsigned short const &,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	esi, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 948  : 				if (_Done)

	jne	SHORT $LL2@Reinsert
	pop	edi
	pop	esi
$LN115@Reinsert:
	pop	ebx

; 949  : 					break;
; 950  : 				}
; 951  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Reinsert@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Reinsert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Check_size@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -8						; size = 8
?_Check_size@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Check_size, COMDAT
; _this$ = ecx

; 924  : 		{	// grow table as needed

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	mov	ebx, ecx

; 494  : 		return ((float)size() / (float)bucket_count());

	mov	eax, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR [ebx+28]
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	eax, ecx
	shr	eax, 31					; 0000001fH
	cvtpd2ps xmm1, xmm0
	movd	xmm0, ecx
	cvtdq2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	divss	xmm1, xmm0

; 925  : 		if (max_load_factor() < load_factor())

	comiss	xmm1, DWORD PTR [ebx]
	jbe	SHORT $LN187@Check_size

; 926  : 
; 927  : 			{	// rehash to bigger table
; 928  : 			size_type _Newsize = bucket_count();
; 929  : 
; 930  : 			if (_Newsize < 512)

	cmp	ecx, 512				; 00000200H
	jae	SHORT $LN3@Check_size

; 931  : 				_Newsize *= 8;	// multiply by 8

	shl	ecx, 3
	jmp	SHORT $LN5@Check_size
$LN3@Check_size:

; 932  : 			else if (_Newsize < _Vec.max_size() / 2)

	cmp	ecx, 536870911				; 1fffffffH
	jae	SHORT $LN5@Check_size

; 933  : 				_Newsize *= 2;	// multiply safely by 2

	add	ecx, ecx
$LN5@Check_size:
	push	edi

; 934  : 			_Init(_Newsize);

	push	ecx
	mov	ecx, ebx
	call	?_Init@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEXI@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Init

; 357  : 		return (_List._Unchecked_end());

	mov	edi, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	DWORD PTR [edi], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 942  : 		if (_Unchecked_begin() != _Last)

	je	SHORT $LN190@Check_size
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);

	mov	edi, DWORD PTR [edi+4]
	push	esi
$LL74@Check_size:

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	esi, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 947  : 				_Insert(*_First, _First);

	mov	ecx, ebx

; 347  : 		return (_List._Unchecked_begin());

	mov	esi, DWORD PTR [esi]

; 947  : 				_Insert(*_First, _First);

	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 540  : 		return ((reference)_Pnode->_Myval);

	lea	eax, DWORD PTR [esi+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 947  : 				_Insert(*_First, _First);

	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??$_Insert@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@ABGV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@1@@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Insert<unsigned short const &,std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> >
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	esi, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 948  : 				if (_Done)

	jne	SHORT $LL74@Check_size
	pop	esi
$LN190@Check_size:
	pop	edi
$LN187@Check_size:
	pop	ebx

; 935  : 			_Reinsert();
; 936  : 			}
; 937  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Check_size@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Check_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Init@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Buckets$ = 8						; size = 4
?_Init@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEXI@Z PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Init, COMDAT
; _this$ = ecx

; 916  : 		{	// initialize hash table with _Buckets buckets, leave list alone

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	mov	ebx, ecx
	push	esi

; 917  : 		_Vec.reserve(2 * _Buckets);	// avoid curdling _Vec if exception occurs

	mov	esi, DWORD PTR __Buckets$[ebp]
	add	esi, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [ebx+20]
	sub	eax, DWORD PTR [ebx+12]
	sar	eax, 2
	push	edi

; 1529 : 		if (_Newcapacity > capacity())

	cmp	esi, eax
	jbe	SHORT $LN4@Init

; 1530 : 			{	// something to do (reserve() never shrinks)
; 1531 : 			if (_Newcapacity > max_size())

	cmp	esi, 1073741823				; 3fffffffH
	ja	SHORT $LN85@Init

; 1534 : 				}
; 1535 : 
; 1536 : 			_Reallocate_exactly(_Newcapacity);

	push	esi
	lea	ecx, DWORD PTR [ebx+12]
	call	?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXI@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Reallocate_exactly
$LN4@Init:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 357  : 		return (_List._Unchecked_end());

	mov	eax, DWORD PTR [ebx+4]

; 918  : 		_Vec.assign(2 * _Buckets, _Unchecked_end());

	lea	ecx, DWORD PTR [ebx+12]

; 357  : 		return (_List._Unchecked_end());

	mov	DWORD PTR $T1[ebp], eax

; 918  : 		_Vec.assign(2 * _Buckets, _Unchecked_end());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	push	esi
	call	?assign@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QAEXIABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::assign

; 919  : 		_Mask = _Buckets - 1;

	mov	ecx, DWORD PTR __Buckets$[ebp]
	pop	edi
	pop	esi

; 920  : 		_Maxidx = _Buckets;

	mov	DWORD PTR [ebx+28], ecx
	lea	eax, DWORD PTR [ecx-1]
	mov	DWORD PTR [ebx+24], eax
	pop	ebx

; 921  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN85@Init:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1533 : 				_Xlength();

	call	?_Xlength@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Xlength
$LN87@Init:
$LN84@Init:
	int	3
?_Init@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEXI@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Hashval@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IBEIABG@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Hashval@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IBEIABG@Z PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Hashval, COMDAT
; _this$ = ecx

; 911  : 		{	// return hash value, masked to current table size

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	mov	esi, DWORD PTR __Keyval$[ebp]
	movzx	eax, BYTE PTR [esi]
	xor	eax, -2128831035			; 811c9dc5H

; 347  : 		_Val *= _FNV_prime;

	imul	edx, eax, 16777619
	movzx	eax, BYTE PTR [esi+1]
	pop	esi

; 346  : 		_Val ^= (size_t)_First[_Next];

	xor	edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 912  : 		return (_Traitsobj(_Keyval) & _Mask);

	mov	eax, DWORD PTR [ecx+24]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 347  : 		_Val *= _FNV_prime;

	imul	edx, edx, 16777619
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 912  : 		return (_Traitsobj(_Keyval) & _Mask);

	and	eax, edx

; 913  : 		}

	pop	ebp
	ret	4
?_Hashval@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IBEIABG@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Hashval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Insert_bucket@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@0I@Z
_TEXT	SEGMENT
__Plist$ = 8						; size = 4
__Where$ = 12						; size = 4
__Bucket$ = 16						; size = 4
?_Insert_bucket@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@0I@Z PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Insert_bucket, COMDAT
; _this$ = ecx

; 882  : 		{	// fix iterators after inserting _Plist before _Where

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1746 : 		return (this->_Myfirst()[_Pos]);

	mov	eax, DWORD PTR __Bucket$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	mov	edx, DWORD PTR [ecx+12]
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1746 : 		return (this->_Myfirst()[_Pos]);

	lea	esi, DWORD PTR [eax*8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [edx+esi]
	add	edx, esi
	cmp	eax, DWORD PTR [ecx+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 883  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())

	jne	SHORT $LN2@Insert_buc

; 884  : 			{	// make bucket non-empty
; 885  : 			_Vec_lo(_Bucket) = _Plist;

	mov	eax, DWORD PTR __Plist$[ebp]
	mov	DWORD PTR [edx], eax

; 886  : 			_Vec_hi(_Bucket) = _Plist;

	mov	ecx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR __Plist$[ebp]
	mov	DWORD PTR [esi+ecx+4], eax
	pop	esi

; 892  : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN2@Insert_buc:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	eax, DWORD PTR __Where$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 888  : 		else if (_Vec_lo(_Bucket) == _Where)

	jne	SHORT $LN4@Insert_buc

; 889  : 			_Vec_lo(_Bucket) = _Plist;	// move beginning back one element

	mov	eax, DWORD PTR __Plist$[ebp]
	mov	DWORD PTR [edx], eax
	pop	esi

; 892  : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN4@Insert_buc:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [edx+4]

; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx+4], eax

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	eax, DWORD PTR __Plist$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 890  : 		else if (++_Vec_hi(_Bucket) != _Plist)	// move end up one element

	je	SHORT $LN6@Insert_buc
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1746 : 		return (this->_Myfirst()[_Pos]);

	mov	ecx, DWORD PTR [ecx+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);

	mov	eax, DWORD PTR [ecx+esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+esi+4], eax
$LN6@Insert_buc:
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 892  : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Insert_bucket@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@0I@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Insert_bucket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Erase_bucket@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEXV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@I@Z
_TEXT	SEGMENT
__Plist_arg$ = 8					; size = 4
__Bucket$ = 12						; size = 4
?_Erase_bucket@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEXV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@I@Z PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Erase_bucket, COMDAT
; _this$ = ecx

; 866  : 		{	// fix iterators before erasing _Plist before _Where

	npad	2
	push	ebp
	mov	ebp, esp

; 868  : 		if (_Vec_hi(_Bucket) == _Plist)

	mov	eax, DWORD PTR __Bucket$[ebp]
	push	esi
	mov	esi, ecx
	push	edi
	lea	edi, DWORD PTR [eax*8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __Plist_arg$[ebp]
	mov	edx, DWORD PTR [esi+12]
	add	edx, edi
	cmp	DWORD PTR [edx+4], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 868  : 		if (_Vec_hi(_Bucket) == _Plist)

	jne	SHORT $LN2@Erase_buck
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	DWORD PTR [edx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 869  : 			if (_Vec_lo(_Bucket) == _Plist)

	jne	SHORT $LN4@Erase_buck

; 870  : 				{	// make bucket empty
; 871  : 				_Vec_lo(_Bucket) = _Unchecked_end();

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edx], eax

; 872  : 				_Vec_hi(_Bucket) = _Unchecked_end();

	mov	ecx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+ecx+4], eax
	pop	edi
	pop	esi

; 878  : 		}

	pop	ebp
	ret	8
$LN4@Erase_buck:

; 873  : 				}
; 874  : 			else
; 875  : 				_Vec_hi(_Bucket) = --_Plist;	// move end back one element

	mov	eax, DWORD PTR [eax+4]
	pop	edi
	mov	DWORD PTR [edx+4], eax
	pop	esi

; 878  : 		}

	pop	ebp
	ret	8
$LN2@Erase_buck:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	DWORD PTR [edx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 876  : 		else if (_Vec_lo(_Bucket) == _Plist)

	jne	SHORT $LN6@Erase_buck

; 877  : 			_Vec_lo(_Bucket) = ++_Plist;	// move beginning up one element

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
$LN6@Erase_buck:
	pop	edi
	pop	esi

; 878  : 		}

	pop	ebp
	ret	8
?_Erase_bucket@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEXV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@I@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Erase_bucket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_End@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Bucket$ = 12						; size = 4
?_End@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_End, COMDAT
; _this$ = ecx

; 855  : 		{	// return end iterator for bucket _Bucket

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR __Bucket$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+eax*8]
	cmp	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 856  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())

	je	SHORT $LN89@End
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 861  : 			return (++_Ans);

	mov	ecx, DWORD PTR [eax]
$LN89@End:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 862  : 			}
; 863  : 		}

	pop	ebp
	ret	8
?_End@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_End
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_End@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Bucket$ = 12						; size = 4
?_End@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_End, COMDAT
; _this$ = ecx

; 845  : 		{	// return end iterator for bucket _Bucket

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR __Bucket$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+eax*8]
	cmp	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 846  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())

	je	SHORT $LN93@End
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 851  : 			return (++_Ans);

	mov	ecx, DWORD PTR [eax]
$LN93@End:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 852  : 			}
; 853  : 		}

	pop	ebp
	ret	8
?_End@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_End
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Begin@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Bucket$ = 12						; size = 4
?_Begin@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Begin, COMDAT
; _this$ = ecx

; 840  : 		{	// return begin iterator for bucket _Bucket

	npad	2
	push	ebp
	mov	ebp, esp

; 841  : 		return (_Vec_lo(_Bucket));

	mov	eax, DWORD PTR __Bucket$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 842  : 		}

	pop	ebp
	ret	8
?_Begin@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Begin@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Bucket$ = 12						; size = 4
?_Begin@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Begin, COMDAT
; _this$ = ecx

; 835  : 		{	// return begin iterator for bucket _Bucket

	npad	2
	push	ebp
	mov	ebp, esp

; 836  : 		return (_Vec_lo(_Bucket));

	mov	eax, DWORD PTR __Bucket$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 837  : 		}

	pop	ebp
	ret	8
?_Begin@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Vec_hi@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IBEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z
_TEXT	SEGMENT
__Bucket$ = 8						; size = 4
?_Vec_hi@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IBEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Vec_hi, COMDAT
; _this$ = ecx

; 830  : 		{	// return reference to end()-1 for _Bucket

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1760 : 		return (this->_Myfirst()[_Pos]);

	mov	eax, DWORD PTR __Bucket$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [eax*8+4]
	add	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 832  : 		}

	pop	ebp
	ret	4
?_Vec_hi@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IBEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Vec_hi
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Vec_hi@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z
_TEXT	SEGMENT
__Bucket$ = 8						; size = 4
?_Vec_hi@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Vec_hi, COMDAT
; _this$ = ecx

; 825  : 		{	// return reference to end()-1 for _Bucket

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1746 : 		return (this->_Myfirst()[_Pos]);

	mov	eax, DWORD PTR __Bucket$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [eax*8+4]
	add	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 827  : 		}

	pop	ebp
	ret	4
?_Vec_hi@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Vec_hi
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Vec_lo@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IBEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z
_TEXT	SEGMENT
__Bucket$ = 8						; size = 4
?_Vec_lo@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IBEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Vec_lo, COMDAT
; _this$ = ecx

; 820  : 		{	// return reference to begin() for _Bucket

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1760 : 		return (this->_Myfirst()[_Pos]);

	mov	ecx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR __Bucket$[ebp]
	lea	eax, DWORD PTR [ecx+eax*8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 822  : 		}

	pop	ebp
	ret	4
?_Vec_lo@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IBEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Vec_lo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Vec_lo@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z
_TEXT	SEGMENT
__Bucket$ = 8						; size = 4
?_Vec_lo@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Vec_lo, COMDAT
; _this$ = ecx

; 815  : 		{	// return reference to begin() for _Bucket

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1746 : 		return (this->_Myfirst()[_Pos]);

	mov	ecx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR __Bucket$[ebp]
	lea	eax, DWORD PTR [ecx+eax*8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 817  : 		}

	pop	ebp
	ret	4
?_Vec_lo@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@I@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Vec_lo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Destroy_if_not_nil@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@@Z
_TEXT	SEGMENT
__Plist$ = 8						; size = 4
?_Destroy_if_not_nil@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@@Z PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Destroy_if_not_nil, COMDAT
; _this$ = ecx

; 750  : 		{	// node exists, destroy it

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 96   : 		return (_Ptr);

	mov	esi, DWORD PTR __Plist$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
	push	1
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	edx, DWORD PTR [esi+4]

; 1490 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edx], eax

; 1491 : 			this->_Nextnode(_Pnode);
; 1492 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edx+4], eax

; 1493 : 			this->_Prevnode(_Pnode);
; 1494 : 
; 1495 : 		--this->_Mysize();

	dec	DWORD PTR [ecx+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 752  : 		}

	pop	ebp
	ret	4
?_Destroy_if_not_nil@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@IAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Destroy_if_not_nil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?equal_range@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@V12@@2@ABG@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
tv883 = 12						; size = 4
__Keyval$ = 12						; size = 4
?equal_range@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@V12@@2@ABG@Z PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::equal_range, COMDAT
; _this$ = ecx

; 703  : 		{	// find range equivalent to _Keyval in nonmutable hash table

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	mov	ecx, DWORD PTR __Keyval$[ebp]
	movzx	eax, BYTE PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1760 : 		return (this->_Myfirst()[_Pos]);

	mov	esi, DWORD PTR [edi+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	xor	eax, -2128831035			; 811c9dc5H

; 347  : 		_Val *= _FNV_prime;

	imul	edx, eax, 16777619
	movzx	eax, BYTE PTR [ecx+1]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 912  : 		return (_Traitsobj(_Keyval) & _Mask);

	mov	ecx, DWORD PTR [edi+24]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	xor	edx, eax

; 347  : 		_Val *= _FNV_prime;

	imul	eax, edx, 16777619
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 912  : 		return (_Traitsobj(_Keyval) & _Mask);

	and	ecx, eax

; 841  : 		return (_Vec_lo(_Bucket));

	mov	eax, DWORD PTR [esi+ecx*8]

; 821  : 		return ((_Unchecked_const_iterator&)_Vec[2 * _Bucket]);

	lea	edx, DWORD PTR [ecx+ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 1183 : 		return (_Unchecked_const_iterator(this->_Myhead(),

	mov	ecx, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1760 : 		return (this->_Myfirst()[_Pos]);

	lea	edi, DWORD PTR [esi+edx*4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	mov	ebx, DWORD PTR [esi+edx*4]
	mov	esi, DWORD PTR __Keyval$[ebp]
$LL4@equal_rang:
	cmp	ebx, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 856  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())

	jne	SHORT $LN49@equal_rang

; 857  : 			return (_Unchecked_end());

	mov	edx, ecx
	jmp	SHORT $LN50@equal_rang
$LN49@equal_rang:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	edx, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 861  : 			return (++_Ans);

	mov	edx, DWORD PTR [edx]
$LN50@equal_rang:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 706  : 			_Where != _End(_Bucket); ++_Where)

	je	SHORT $LN3@equal_rang
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 220  : 		return (_Left == _Right);

	mov	dx, WORD PTR [eax+8]
	cmp	dx, WORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 707  : 			if (!_Traitsobj(_Traits::_Kfn(*_Where), _Keyval))

	je	SHORT $LN399@equal_rang
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LL4@equal_rang
$LN399@equal_rang:
	movzx	esi, WORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 709  : 				_Unchecked_const_iterator _First = _Where;

	mov	edx, eax
	mov	DWORD PTR tv883[ebp], esi
$LL7@equal_rang:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	ebx, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 856  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())

	jne	SHORT $LN164@equal_rang

; 857  : 			return (_Unchecked_end());

	mov	esi, ecx
	jmp	SHORT $LN165@equal_rang
$LN164@equal_rang:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	esi, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 861  : 			return (++_Ans);

	mov	esi, DWORD PTR [esi]
$LN165@equal_rang:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 710  : 				for (; _Where != _End(_Bucket); ++_Where)

	je	SHORT $LN400@equal_rang
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 220  : 		return (_Left == _Right);

	mov	esi, DWORD PTR tv883[ebp]
	cmp	si, WORD PTR [eax+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 711  : 					if (_Traitsobj(_Keyval, _Traits::_Kfn(*_Where)))

	jne	SHORT $LN400@equal_rang
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LL7@equal_rang
$LN400@equal_rang:

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 713  : 				if (_First == _Where)

	je	SHORT $LN3@equal_rang
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	DWORD PTR [ecx+4], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 715  : 				return (_Paircc(_Make_iter(_First),

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	DWORD PTR [ecx], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 719  : 		}

	pop	ebp
	ret	8
$LN3@equal_rang:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR [eax], ecx

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	DWORD PTR [eax+4], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 719  : 		}

	pop	ebp
	ret	8
?equal_range@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@V12@@2@ABG@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::equal_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?count@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBEIABG@Z
_TEXT	SEGMENT
__Ans$ = -8						; size = 8
__Keyval$ = 8						; size = 4
?count@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBEIABG@Z PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::count, COMDAT
; _this$ = ecx

; 634  : 		{	// count all elements that match _Keyval

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 635  : 		_Paircc _Ans = equal_range(_Keyval);

	push	DWORD PTR __Keyval$[ebp]
	lea	eax, DWORD PTR __Ans$[ebp]
	push	eax
	call	?equal_range@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@V12@@2@ABG@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::equal_range
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1113 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));

	mov	ecx, DWORD PTR __Ans$[ebp]

; 1095 : 	_Iter_diff_t<_InIt> _Off = 0;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 297  : 		return (this->_Ptr == _Right._Ptr);

	mov	edx, DWORD PTR __Ans$[ebp+4]
	cmp	ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1096 : 	for (; _First != _Last; ++_First)

	je	SHORT $LN7@count
$LL8@count:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 242  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	ecx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1097 : 		++_Off;

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 297  : 		return (this->_Ptr == _Right._Ptr);

	cmp	ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1096 : 	for (; _First != _Last; ++_First)

	jne	SHORT $LL8@count
$LN7@count:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?count@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBEIABG@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::count
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?erase@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@V32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Plist$ = 12						; size = 4
?erase@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@V32@@Z PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::erase, COMDAT
; _this$ = ecx

; 586  : 		{	// erase element at _Plist

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 540  : 		return ((reference)_Pnode->_Myval);

	mov	edi, DWORD PTR __Plist$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 586  : 		{	// erase element at _Plist

	mov	ebx, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	movzx	eax, BYTE PTR [edi+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 912  : 		return (_Traitsobj(_Keyval) & _Mask);

	mov	ecx, DWORD PTR [ebx+24]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	xor	eax, -2128831035			; 811c9dc5H

; 347  : 		_Val *= _FNV_prime;

	imul	edx, eax, 16777619
	movzx	eax, BYTE PTR [edi+9]
	xor	edx, eax
	imul	eax, edx, 16777619
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 912  : 		return (_Traitsobj(_Keyval) & _Mask);

	and	ecx, eax

; 868  : 		if (_Vec_hi(_Bucket) == _Plist)

	lea	edx, DWORD PTR [ecx*8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	mov	ecx, DWORD PTR [ebx+12]
	add	ecx, edx
	cmp	DWORD PTR [ecx+4], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 868  : 		if (_Vec_hi(_Bucket) == _Plist)

	jne	SHORT $LN49@erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	DWORD PTR [ecx], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 869  : 			if (_Vec_lo(_Bucket) == _Plist)

	jne	SHORT $LN51@erase

; 870  : 				{	// make bucket empty
; 871  : 				_Vec_lo(_Bucket) = _Unchecked_end();

	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [ecx], eax

; 872  : 				_Vec_hi(_Bucket) = _Unchecked_end();

	mov	ecx, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [edx+ecx+4], eax

; 873  : 				}
; 874  : 			else

	jmp	SHORT $LN346@erase
$LN51@erase:

; 875  : 				_Vec_hi(_Bucket) = --_Plist;	// move end back one element

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx+4], eax

; 876  : 		else if (_Vec_lo(_Bucket) == _Plist)

	jmp	SHORT $LN346@erase
$LN49@erase:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	DWORD PTR [ecx], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 876  : 		else if (_Vec_lo(_Bucket) == _Plist)

	jne	SHORT $LN53@erase

; 877  : 			_Vec_lo(_Bucket) = ++_Plist;	// move beginning up one element

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ecx], eax
$LN346@erase:
	mov	edi, DWORD PTR __Plist$[ebp]
$LN53@erase:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [edi+4]

; 242  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	esi, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
	push	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 1490 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =

	mov	DWORD PTR [eax], esi

; 1492 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 1492 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =

	mov	DWORD PTR [ecx+4], eax

; 1493 : 			this->_Prevnode(_Pnode);
; 1494 : 
; 1495 : 		--this->_Mysize();

	dec	DWORD PTR [ebx+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 590  : 		return (_List.erase(_Plist));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 590  : 		return (_List.erase(_Plist));

	mov	DWORD PTR [eax], esi
	pop	esi
	pop	ebx

; 591  : 		}

	pop	ebp
	ret	8
?erase@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@V32@@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?max_load_factor@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBEMXZ
_TEXT	SEGMENT
?max_load_factor@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBEMXZ PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::max_load_factor, COMDAT
; _this$ = ecx

; 499  : 		return (_Max_bucket_size());

	fld	DWORD PTR [ecx]

; 500  : 		}

	ret	0
?max_load_factor@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBEMXZ ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::max_load_factor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?load_factor@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBEMXZ
_TEXT	SEGMENT
tv72 = -4						; size = 4
?load_factor@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBEMXZ PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::load_factor, COMDAT
; _this$ = ecx

; 493  : 		{	// return elements per bucket

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 494  : 		return ((float)size() / (float)bucket_count());

	mov	eax, DWORD PTR [ecx+8]
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	eax, DWORD PTR [ecx+28]
	cvtpd2ps xmm1, xmm0
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	divss	xmm1, xmm0
	movss	DWORD PTR tv72[ebp], xmm1
	fld	DWORD PTR tv72[ebp]

; 495  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?load_factor@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBEMXZ ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::load_factor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?bucket_count@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?bucket_count@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::bucket_count, COMDAT
; _this$ = ecx

; 421  : 		return (_Maxidx);

	mov	eax, DWORD PTR [ecx+28]

; 422  : 		}

	ret	0
?bucket_count@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::bucket_count
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?size@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::size, COMDAT
; _this$ = ecx

; 387  : 		return (_List.size());

	mov	eax, DWORD PTR [ecx+8]

; 388  : 		}

	ret	0
?size@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Make_iter@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@V32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@V32@@Z PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Make_iter, COMDAT
; _this$ = ecx

; 371  : 		{	// make iterator from const_iterator

	npad	2
	push	ebp
	mov	ebp, esp

; 372  : 		return (_List._Make_iter(_Where));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [eax], ecx

; 373  : 		}

	pop	ebp
	ret	8
?_Make_iter@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@V32@@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Make_iter@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@@Z PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Make_iter, COMDAT
; _this$ = ecx

; 366  : 		{	// make iterator from _Unchecked_const_iterator

	npad	2
	push	ebp
	mov	ebp, esp

; 367  : 		return (_List._Make_iter(_Where));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [eax], ecx

; 368  : 		}

	pop	ebp
	ret	8
?_Make_iter@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Unchecked_end@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_end@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Unchecked_end, COMDAT
; _this$ = ecx

; 361  : 		{	// return iterator for end of nonmutable sequence

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 363  : 		}

	pop	ebp
	ret	4
?_Unchecked_end@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Unchecked_end@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_end@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Unchecked_end, COMDAT
; _this$ = ecx

; 356  : 		{	// return iterator for end of mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 357  : 		return (_List._Unchecked_end());

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 358  : 		}

	pop	ebp
	ret	4
?_Unchecked_end@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Unchecked_begin@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_begin@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Unchecked_begin, COMDAT
; _this$ = ecx

; 346  : 		{	// return iterator for beginning of mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [ecx+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 347  : 		return (_List._Unchecked_begin());

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 348  : 		}

	pop	ebp
	ret	4
?_Unchecked_begin@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?end@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::end, COMDAT
; _this$ = ecx

; 341  : 		{	// return iterator for end of nonmutable sequence

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 343  : 		}

	pop	ebp
	ret	4
?end@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ??1?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::~_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >, COMDAT
; _this$ = ecx

; 307  : 		{	// destroy hash table

	npad	2
	push	edi
	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1949 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [edi+12]
	test	ecx, ecx
	je	SHORT $LN7@Hash

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [edi+20]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [edi+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [edi+16], 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR [edi+20], 0
$LN7@Hash:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [edi+4]

; 1539 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead());

	mov	ecx, DWORD PTR [eax]

; 1540 : 		this->_Nextnode(this->_Myhead()) = this->_Myhead();

	mov	DWORD PTR [eax], eax

; 535  : 		return ((_Nodepref)_Pnode->_Prev);

	mov	eax, DWORD PTR [edi+4]

; 1541 : 		this->_Prevnode(this->_Myhead()) = this->_Myhead();

	mov	DWORD PTR [eax+4], eax

; 1542 : 		this->_Mysize() = 0;

	mov	DWORD PTR [edi+8], 0

; 1544 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead(); _Pnode = _Pnext)

	cmp	ecx, DWORD PTR [edi+4]
	je	SHORT $LN109@Hash
	push	esi
	npad	1
$LL110@Hash:

; 1545 : 			{	// delete an element
; 1546 : 			_Pnext = this->_Nextnode(_Pnode);

	mov	esi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 1544 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead(); _Pnode = _Pnext)

	mov	ecx, esi
	cmp	esi, DWORD PTR [edi+4]
	jne	SHORT $LL110@Hash
	pop	esi
$LN109@Hash:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
	push	1
	push	DWORD PTR [edi+4]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 309  : 		}

	ret	0
??1?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::~_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_set
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_set
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ??0?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@1@ABV?$allocator@G@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T2 = 8							; size = 4
_this$ = 8						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@1@ABV?$allocator@G@1@@Z PROC ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >, COMDAT
; _this$ = ecx

; 197  : 		{	// construct empty hash table

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@1@ABV?$allocator@G@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	lea	ebx, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_set

; 36   : 		: _Tr(_Traits)

	mov	eax, DWORD PTR __Parg$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 731  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

	mov	ecx, ebx
	push	edi
	push	0
	push	0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_set

; 36   : 		: _Tr(_Traits)

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 195  : 			_List(_Al),

	mov	DWORD PTR _this$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 523  : 		: _Myhead(),

	mov	DWORD PTR [ebx], 0

; 524  : 		_Mysize(0)

	mov	DWORD PTR [ebx+4], 0

; 731  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

	call	?_Buynode0@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEPAU?$_List_node@GPAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Buynode0

; 606  : 		_Myhead() = _Buyheadnode();

	mov	DWORD PTR [ebx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 195  : 			_List(_Al),

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [esi+12], 0

; 477  : 		_Mylast(),

	mov	DWORD PTR [esi+16], 0

; 478  : 		_Myend()

	mov	DWORD PTR [esi+20], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 198  : 		_Max_bucket_size() = _Bucket_size;

	mov	DWORD PTR [esi], 1065353216		; 3f800000H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+20]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 196  : 			_Vec(_Al)

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1529 : 		if (_Newcapacity > capacity())

	cmp	eax, 16					; 00000010H
	jae	SHORT $LN69@Hash

; 1530 : 			{	// something to do (reserve() never shrinks)
; 1531 : 			if (_Newcapacity > max_size())
; 1532 : 				{
; 1533 : 				_Xlength();
; 1534 : 				}
; 1535 : 
; 1536 : 			_Reallocate_exactly(_Newcapacity);

	push	16					; 00000010H
	lea	ecx, DWORD PTR [esi+12]
	call	?_Reallocate_exactly@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@AAEXI@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::_Reallocate_exactly
$LN69@Hash:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 357  : 		return (_List._Unchecked_end());

	mov	eax, DWORD PTR [ebx]

; 918  : 		_Vec.assign(2 * _Buckets, _Unchecked_end());

	lea	ecx, DWORD PTR [esi+12]

; 357  : 		return (_List._Unchecked_end());

	mov	DWORD PTR $T2[ebp], eax

; 918  : 		_Vec.assign(2 * _Buckets, _Unchecked_end());

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	push	16					; 00000010H
	call	?assign@?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QAEXIABV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::assign

; 199  : 		_Init();
; 200  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi

; 919  : 		_Mask = _Buckets - 1;

	mov	DWORD PTR [esi+24], 7

; 920  : 		_Maxidx = _Buckets;

	mov	DWORD PTR [esi+28], 8
	pop	esi
	pop	ebx

; 199  : 		_Init();
; 200  : 		}

	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@1@ABV?$allocator@G@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$list@GV?$allocator@G@std@@@std@@QAE@XZ ; std::list<unsigned short,std::allocator<unsigned short> >::~list<unsigned short,std::allocator<unsigned short> >
__unwindfunclet$??0?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@1@ABV?$allocator@G@1@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$vector@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@std@@@std@@@2@@std@@QAE@XZ ; std::vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >::~vector<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0>,std::_Wrap_alloc<std::allocator<std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<unsigned short> >,std::_Iterator_base0> > > >
__ehhandler$??0?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@1@ABV?$allocator@G@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@1@ABV?$allocator@G@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@1@ABV?$allocator@G@1@@Z ENDP ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Incsize@?$list@GV?$allocator@G@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Incsize@?$list@GV?$allocator@G@std@@@std@@QAEXI@Z PROC ; std::list<unsigned short,std::allocator<unsigned short> >::_Incsize, COMDAT
; _this$ = ecx

; 1949 : 		{	// alter element count, with checking

	npad	2
	push	ebp
	mov	ebp, esp

; 1950 : 		if (max_size() - this->_Mysize() - 1 < _Count)

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, 357913940				; 15555554H
	push	esi
	mov	esi, DWORD PTR __Count$[ebp]
	sub	eax, edx
	cmp	eax, esi
	jae	SHORT $LN2@Incsize

; 1951 : 			_Xlength_error("list<T> too long");

	push	OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN42@Incsize:
$LN2@Incsize:

; 1952 : 		this->_Mysize() += _Count;

	lea	eax, DWORD PTR [edx+esi]
	mov	DWORD PTR [ecx+4], eax
	pop	esi

; 1953 : 		}

	pop	ebp
	ret	4
$LN41@Incsize:
?_Incsize@?$list@GV?$allocator@G@std@@@std@@QAEXI@Z ENDP ; std::list<unsigned short,std::allocator<unsigned short> >::_Incsize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Tidy@?$list@GV?$allocator@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy@?$list@GV?$allocator@G@std@@@std@@QAEXXZ PROC	; std::list<unsigned short,std::allocator<unsigned short> >::_Tidy, COMDAT
; _this$ = ecx

; 1926 : 		{	// free all storage

	npad	2
	push	edi
	mov	edi, ecx

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	edx, DWORD PTR [edi]

; 1539 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead());

	mov	eax, DWORD PTR [edx]

; 1540 : 		this->_Nextnode(this->_Myhead()) = this->_Myhead();

	mov	DWORD PTR [edx], edx

; 535  : 		return ((_Nodepref)_Pnode->_Prev);

	mov	edx, DWORD PTR [edi]

; 1541 : 		this->_Prevnode(this->_Myhead()) = this->_Myhead();

	mov	DWORD PTR [edx+4], edx

; 1542 : 		this->_Mysize() = 0;

	mov	DWORD PTR [edi+4], 0

; 1544 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead(); _Pnode = _Pnext)

	cmp	eax, DWORD PTR [edi]
	je	SHORT $LN5@Tidy
	push	esi
	npad	4
$LL6@Tidy:

; 1545 : 			{	// delete an element
; 1546 : 			_Pnext = this->_Nextnode(_Pnode);

	mov	esi, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 1544 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead(); _Pnode = _Pnext)

	mov	eax, esi
	cmp	esi, DWORD PTR [edi]
	jne	SHORT $LL6@Tidy
	pop	esi
$LN5@Tidy:
	pop	edi

; 1927 : 		clear();
; 1928 : 		}

	ret	0
?_Tidy@?$list@GV?$allocator@G@std@@@std@@QAEXXZ ENDP	; std::list<unsigned short,std::allocator<unsigned short> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Unchecked_splice@?$list@GV?$allocator@G@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@00@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?_Unchecked_splice@?$list@GV?$allocator@G@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@00@Z PROC ; std::list<unsigned short,std::allocator<unsigned short> >::_Unchecked_splice, COMDAT
; _this$ = ecx

; 1909 : 		{	// splice [_First, _Last) before _Where

	npad	2
	push	ebp
	mov	ebp, esp

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+4]

; 1910 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =

	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR [ecx], eax

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR [eax+4]

; 1911 : 			_Last._Mynode();
; 1912 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [ecx], eax

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, DWORD PTR [eax+4]

; 1913 : 			_Where._Mynode();
; 1914 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], eax

; 535  : 		return ((_Nodepref)_Pnode->_Prev);

	mov	ecx, DWORD PTR __Where$[ebp]

; 1915 : 			_First._Mynode();
; 1916 : 
; 1917 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1918 : 		this->_Prevnode(_Where._Mynode()) =

	mov	eax, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], eax

; 1919 : 			this->_Prevnode(_Last._Mynode());
; 1920 : 		this->_Prevnode(_Last._Mynode()) =

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1921 : 			this->_Prevnode(_First._Mynode());
; 1922 : 		this->_Prevnode(_First._Mynode()) = _Pnode;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [eax+4], edx

; 1923 : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Unchecked_splice@?$list@GV?$allocator@G@std@@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@00@Z ENDP ; std::list<unsigned short,std::allocator<unsigned short> >::_Unchecked_splice
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?clear@?$list@GV?$allocator@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$list@GV?$allocator@G@std@@@std@@QAEXXZ PROC	; std::list<unsigned short,std::allocator<unsigned short> >::clear, COMDAT
; _this$ = ecx

; 1534 : 		{	// erase all

	npad	2
	push	edi
	mov	edi, ecx

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	edx, DWORD PTR [edi]

; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 
; 1537 : 		this->_Orphan_ptr(nullptr);
; 1538 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead());

	mov	eax, DWORD PTR [edx]

; 1540 : 		this->_Nextnode(this->_Myhead()) = this->_Myhead();

	mov	DWORD PTR [edx], edx

; 535  : 		return ((_Nodepref)_Pnode->_Prev);

	mov	edx, DWORD PTR [edi]

; 1541 : 		this->_Prevnode(this->_Myhead()) = this->_Myhead();

	mov	DWORD PTR [edx+4], edx

; 1542 : 		this->_Mysize() = 0;

	mov	DWORD PTR [edi+4], 0

; 1544 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead(); _Pnode = _Pnext)

	cmp	eax, DWORD PTR [edi]
	je	SHORT $LN3@clear
	push	esi
	npad	4
$LL4@clear:

; 1545 : 			{	// delete an element
; 1546 : 			_Pnext = this->_Nextnode(_Pnode);

	mov	esi, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 1544 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead(); _Pnode = _Pnext)

	mov	eax, esi
	cmp	esi, DWORD PTR [edi]
	jne	SHORT $LL4@clear
	pop	esi
$LN3@clear:
	pop	edi

; 1547 : 			this->_Freenode(_Pnode);
; 1548 : 			}
; 1549 : 		}

	ret	0
?clear@?$list@GV?$allocator@G@std@@@std@@QAEXXZ ENDP	; std::list<unsigned short,std::allocator<unsigned short> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?erase@?$list@GV?$allocator@G@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$list@GV?$allocator@G@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@@Z PROC ; std::list<unsigned short,std::allocator<unsigned short> >::erase, COMDAT
; _this$ = ecx

; 1500 : 		{	// erase element at _Where

	npad	2
	push	ebp
	mov	ebp, esp

; 248  : 		_Myiter _Tmp = *this;

	mov	eax, DWORD PTR __Where$[ebp]
	push	esi
	push	edi

; 1500 : 		{	// erase element at _Where

	mov	edi, ecx

; 242  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Where$[ebp], edx

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	esi, DWORD PTR [eax+4]

; 1490 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =

	mov	edx, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
	push	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 1490 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =

	mov	DWORD PTR [esi], edx

; 1492 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 1492 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =

	mov	DWORD PTR [edx+4], ecx

; 1493 : 			this->_Prevnode(_Pnode);
; 1494 : 
; 1495 : 		--this->_Mysize();

	dec	DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR __Where$[ebp]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 1501 : 		_Nodeptr _Pnode = _Unlinknode(_Where++);
; 1502 : 		this->_Freenode(_Pnode);
; 1503 : 		return (_Make_iter(_Where));
; 1504 : 		}

	pop	ebp
	ret	8
?erase@?$list@GV?$allocator@G@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@@Z ENDP ; std::list<unsigned short,std::allocator<unsigned short> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Unlinknode@?$list@GV?$allocator@G@std@@@std@@QAEPAU?$_List_node@GPAX@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
?_Unlinknode@?$list@GV?$allocator@G@std@@@std@@QAEPAU?$_List_node@GPAX@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@@Z PROC ; std::list<unsigned short,std::allocator<unsigned short> >::_Unlinknode, COMDAT
; _this$ = ecx

; 1475 : 		{	// unlink node at _Where from the list

	npad	2
	push	ebp
	mov	ebp, esp

; 96   : 		return (_Ptr);

	mov	eax, DWORD PTR __Where$[ebp]
	push	esi

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	esi, DWORD PTR [eax+4]

; 1476 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1477 : 		if (_Where._Getcont() != _STD addressof(this->_Get_data())
; 1478 : 			|| _Where._Ptr == this->_Myhead())
; 1479 : 			{
; 1480 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1481 : 			}
; 1482 : 
; 1483 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1484 : 		_Orphan_ptr(_Pnode);
; 1485 : 
; 1486 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1487 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1488 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1489 : 
; 1490 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =

	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [esi], edx

; 1491 : 			this->_Nextnode(_Pnode);
; 1492 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =

	mov	esi, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], edx

; 1493 : 			this->_Prevnode(_Pnode);
; 1494 : 
; 1495 : 		--this->_Mysize();

	dec	DWORD PTR [ecx+4]
	pop	esi

; 1496 : 		return (_Pnode);
; 1497 : 		}

	pop	ebp
	ret	4
?_Unlinknode@?$list@GV?$allocator@G@std@@@std@@QAEPAU?$_List_node@GPAX@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@@Z ENDP ; std::list<unsigned short,std::allocator<unsigned short> >::_Unlinknode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?front@?$list@GV?$allocator@G@std@@@std@@QAEAAGXZ
_TEXT	SEGMENT
?front@?$list@GV?$allocator@G@std@@@std@@QAEAAGXZ PROC	; std::list<unsigned short,std::allocator<unsigned short> >::front, COMDAT
; _this$ = ecx

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [ecx]

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [eax]

; 540  : 		return ((reference)_Pnode->_Myval);

	add	eax, 8

; 1288 : 		return (*begin());
; 1289 : 		}

	ret	0
?front@?$list@GV?$allocator@G@std@@@std@@QAEAAGXZ ENDP	; std::list<unsigned short,std::allocator<unsigned short> >::front
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?max_size@?$list@GV?$allocator@G@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$list@GV?$allocator@G@std@@@std@@QBEIXZ PROC	; std::list<unsigned short,std::allocator<unsigned short> >::max_size, COMDAT
; _this$ = ecx

; 1272 : 		return (this->_Getal().max_size());

	mov	eax, 357913941				; 15555555H

; 1273 : 		}

	ret	0
?max_size@?$list@GV?$allocator@G@std@@@std@@QBEIXZ ENDP	; std::list<unsigned short,std::allocator<unsigned short> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?size@?$list@GV?$allocator@G@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$list@GV?$allocator@G@std@@@std@@QBEIXZ PROC	; std::list<unsigned short,std::allocator<unsigned short> >::size, COMDAT
; _this$ = ecx

; 1267 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [ecx+4]

; 1268 : 		}

	ret	0
?size@?$list@GV?$allocator@G@std@@@std@@QBEIXZ ENDP	; std::list<unsigned short,std::allocator<unsigned short> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Make_iter@?$list@GV?$allocator@G@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$list@GV?$allocator@G@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@@Z PROC ; std::list<unsigned short,std::allocator<unsigned short> >::_Make_iter, COMDAT
; _this$ = ecx

; 1193 : 		{	// make iterator from _Unchecked_const_iterator

	npad	2
	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [eax], ecx

; 1194 : 		return (iterator(_Where._Ptr, _STD addressof(this->_Get_data())));
; 1195 : 		}

	pop	ebp
	ret	8
?_Make_iter@?$list@GV?$allocator@G@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@@Z ENDP ; std::list<unsigned short,std::allocator<unsigned short> >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Make_iter@?$list@GV?$allocator@G@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$list@GV?$allocator@G@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@@Z PROC ; std::list<unsigned short,std::allocator<unsigned short> >::_Make_iter, COMDAT
; _this$ = ecx

; 1188 : 		{	// make iterator from const_iterator

	npad	2
	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [eax], ecx

; 1189 : 		return (iterator(_Where._Ptr, _STD addressof(this->_Get_data())));
; 1190 : 		}

	pop	ebp
	ret	8
?_Make_iter@?$list@GV?$allocator@G@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@@Z ENDP ; std::list<unsigned short,std::allocator<unsigned short> >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Unchecked_end@?$list@GV?$allocator@G@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_end@?$list@GV?$allocator@G@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::list<unsigned short,std::allocator<unsigned short> >::_Unchecked_end, COMDAT
; _this$ = ecx

; 1182 : 		{	// return unchecked iterator for end of nonmutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1183 : 		return (_Unchecked_const_iterator(this->_Myhead(),
; 1184 : 			_STD addressof(this->_Get_data())));
; 1185 : 		}

	pop	ebp
	ret	4
?_Unchecked_end@?$list@GV?$allocator@G@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::list<unsigned short,std::allocator<unsigned short> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Unchecked_end@?$list@GV?$allocator@G@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_end@?$list@GV?$allocator@G@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@XZ PROC ; std::list<unsigned short,std::allocator<unsigned short> >::_Unchecked_end, COMDAT
; _this$ = ecx

; 1177 : 		{	// return unchecked iterator for end of mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1178 : 		return (_Unchecked_iterator(this->_Myhead(), _STD addressof(this->_Get_data())));
; 1179 : 		}

	pop	ebp
	ret	4
?_Unchecked_end@?$list@GV?$allocator@G@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@XZ ENDP ; std::list<unsigned short,std::allocator<unsigned short> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Unchecked_begin@?$list@GV?$allocator@G@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_begin@?$list@GV?$allocator@G@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@XZ PROC ; std::list<unsigned short,std::allocator<unsigned short> >::_Unchecked_begin, COMDAT
; _this$ = ecx

; 1165 : 		{	// return iterator for beginning of mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [ecx]

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 1166 : 		return (_Unchecked_iterator(this->_Nextnode(this->_Myhead()),
; 1167 : 			_STD addressof(this->_Get_data())));
; 1168 : 		}

	pop	ebp
	ret	4
?_Unchecked_begin@?$list@GV?$allocator@G@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@XZ ENDP ; std::list<unsigned short,std::allocator<unsigned short> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?end@?$list@GV?$allocator@G@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$list@GV?$allocator@G@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@XZ PROC ; std::list<unsigned short,std::allocator<unsigned short> >::end, COMDAT
; _this$ = ecx

; 1160 : 		{	// return iterator for end of nonmutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1161 : 		return (const_iterator(this->_Myhead(), _STD addressof(this->_Get_data())));
; 1162 : 		}

	pop	ebp
	ret	4
?end@?$list@GV?$allocator@G@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@XZ ENDP ; std::list<unsigned short,std::allocator<unsigned short> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?begin@?$list@GV?$allocator@G@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@GV?$allocator@G@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@XZ PROC ; std::list<unsigned short,std::allocator<unsigned short> >::begin, COMDAT
; _this$ = ecx

; 1143 : 		{	// return iterator for beginning of mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [ecx]

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 1144 : 		return (iterator(this->_Nextnode(this->_Myhead()),
; 1145 : 			_STD addressof(this->_Get_data())));
; 1146 : 		}

	pop	ebp
	ret	4
?begin@?$list@GV?$allocator@G@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@2@XZ ENDP ; std::list<unsigned short,std::allocator<unsigned short> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??1?$list@GV?$allocator@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$list@GV?$allocator@G@std@@@std@@QAE@XZ PROC	; std::list<unsigned short,std::allocator<unsigned short> >::~list<unsigned short,std::allocator<unsigned short> >, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy the object

	npad	2
	push	edi
	mov	edi, ecx

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [edi]

; 1539 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead());

	mov	edx, DWORD PTR [eax]

; 1540 : 		this->_Nextnode(this->_Myhead()) = this->_Myhead();

	mov	DWORD PTR [eax], eax

; 535  : 		return ((_Nodepref)_Pnode->_Prev);

	mov	eax, DWORD PTR [edi]

; 1541 : 		this->_Prevnode(this->_Myhead()) = this->_Myhead();

	mov	DWORD PTR [eax+4], eax

; 1542 : 		this->_Mysize() = 0;

	mov	DWORD PTR [edi+4], 0

; 1544 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead(); _Pnode = _Pnext)

	cmp	edx, DWORD PTR [edi]
	je	SHORT $LN7@list
	push	esi
	npad	4
$LL8@list:

; 1545 : 			{	// delete an element
; 1546 : 			_Pnext = this->_Nextnode(_Pnode);

	mov	esi, DWORD PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 1544 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead(); _Pnode = _Pnext)

	mov	edx, esi
	cmp	esi, DWORD PTR [edi]
	jne	SHORT $LL8@list
	pop	esi
$LN7@list:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
	push	1
	push	DWORD PTR [edi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 1120 : 		}

	ret	0
??1?$list@GV?$allocator@G@std@@@std@@QAE@XZ ENDP	; std::list<unsigned short,std::allocator<unsigned short> >::~list<unsigned short,std::allocator<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??0?$list@GV?$allocator@G@std@@@std@@QAE@ABV?$allocator@G@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 4
??0?$list@GV?$allocator@G@std@@@std@@QAE@ABV?$allocator@G@1@@Z PROC ; std::list<unsigned short,std::allocator<unsigned short> >::list<unsigned short,std::allocator<unsigned short> >, COMDAT
; _this$ = ecx

; 914  : 		{	// construct empty list, allocator

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 731  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

	push	0
	push	0

; 914  : 		{	// construct empty list, allocator

	mov	DWORD PTR _this$[ebp], esi

; 523  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 524  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 731  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

	call	?_Buynode0@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEPAU?$_List_node@GPAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Buynode0

; 606  : 		_Myhead() = _Buyheadnode();

	mov	DWORD PTR [esi], eax

; 915  : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$list@GV?$allocator@G@std@@@std@@QAE@ABV?$allocator@G@1@@Z ENDP ; std::list<unsigned short,std::allocator<unsigned short> >::list<unsigned short,std::allocator<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??1?$_List_buy@GV?$allocator@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_buy@GV?$allocator@G@std@@@std@@QAE@XZ PROC	; std::_List_buy<unsigned short,std::allocator<unsigned short> >::~_List_buy<unsigned short,std::allocator<unsigned short> >, COMDAT
; _this$ = ecx

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
	push	1
	push	DWORD PTR [ecx]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
	ret	0
??1?$_List_buy@GV?$allocator@G@std@@@std@@QAE@XZ ENDP	; std::_List_buy<unsigned short,std::allocator<unsigned short> >::~_List_buy<unsigned short,std::allocator<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Freenode@?$_List_buy@GV?$allocator@G@std@@@std@@QAEXPAU?$_List_node@GPAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freenode@?$_List_buy@GV?$allocator@G@std@@@std@@QAEXPAU?$_List_node@GPAX@2@@Z PROC ; std::_List_buy<unsigned short,std::allocator<unsigned short> >::_Freenode, COMDAT
; _this$ = ecx

; 864  : 		{	// give node back

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
	push	1
	push	DWORD PTR __Pnode$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 872  : 		}

	pop	ebp
	ret	4
?_Freenode@?$_List_buy@GV?$allocator@G@std@@@std@@QAEXPAU?$_List_node@GPAX@2@@Z ENDP ; std::_List_buy<unsigned short,std::allocator<unsigned short> >::_Freenode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@G@std@@@2@$00@std@@QBEABV?$_List_val@U?$_List_simple_types@G@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@G@std@@@2@$00@std@@QBEABV?$_List_val@U?$_List_simple_types@G@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >,std::_List_val<std::_List_simple_types<unsigned short> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 343  : 		return (_Myval2);

	mov	eax, ecx

; 344  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@G@std@@@2@$00@std@@QBEABV?$_List_val@U?$_List_simple_types@G@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >,std::_List_val<std::_List_simple_types<unsigned short> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@G@std@@@2@$00@std@@QAEAAV?$_List_val@U?$_List_simple_types@G@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@G@std@@@2@$00@std@@QAEAAV?$_List_val@U?$_List_simple_types@G@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >,std::_List_val<std::_List_simple_types<unsigned short> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 338  : 		return (_Myval2);

	mov	eax, ecx

; 339  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@G@std@@@2@$00@std@@QAEAAV?$_List_val@U?$_List_simple_types@G@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >,std::_List_val<std::_List_simple_types<unsigned short> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@G@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@G@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >,std::_List_val<std::_List_simple_types<unsigned short> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 323  : 		return (*this);

	mov	eax, ecx

; 324  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@G@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >,std::_List_val<std::_List_simple_types<unsigned short> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@G@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@G@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >,std::_List_val<std::_List_simple_types<unsigned short> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 318  : 		return (*this);

	mov	eax, ecx

; 319  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@G@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >,std::_List_val<std::_List_simple_types<unsigned short> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Myval@?$_List_val@U?$_List_simple_types@G@std@@@std@@SAAAGPAU?$_List_node@GPAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_List_val@U?$_List_simple_types@G@std@@@std@@SAAAGPAU?$_List_node@GPAX@2@@Z PROC ; std::_List_val<std::_List_simple_types<unsigned short> >::_Myval, COMDAT

; 539  : 		{	// return reference to value in node

	npad	2
	push	ebp
	mov	ebp, esp

; 540  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 8

; 541  : 		}

	pop	ebp
	ret	0
?_Myval@?$_List_val@U?$_List_simple_types@G@std@@@std@@SAAAGPAU?$_List_node@GPAX@2@@Z ENDP ; std::_List_val<std::_List_simple_types<unsigned short> >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Prevnode@?$_List_val@U?$_List_simple_types@G@std@@@std@@SAAAPAU?$_List_node@GPAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$_List_val@U?$_List_simple_types@G@std@@@std@@SAAAPAU?$_List_node@GPAX@2@PAU32@@Z PROC ; std::_List_val<std::_List_simple_types<unsigned short> >::_Prevnode, COMDAT

; 534  : 		{	// return reference to predecessor pointer in node

	npad	2
	push	ebp
	mov	ebp, esp

; 535  : 		return ((_Nodepref)_Pnode->_Prev);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 536  : 		}

	pop	ebp
	ret	0
?_Prevnode@?$_List_val@U?$_List_simple_types@G@std@@@std@@SAAAPAU?$_List_node@GPAX@2@PAU32@@Z ENDP ; std::_List_val<std::_List_simple_types<unsigned short> >::_Prevnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Nextnode@?$_List_val@U?$_List_simple_types@G@std@@@std@@SAAAPAU?$_List_node@GPAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$_List_val@U?$_List_simple_types@G@std@@@std@@SAAAPAU?$_List_node@GPAX@2@PAU32@@Z PROC ; std::_List_val<std::_List_simple_types<unsigned short> >::_Nextnode, COMDAT

; 529  : 		{	// return reference to successor pointer in node

	npad	2
	push	ebp
	mov	ebp, esp

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 531  : 		}

	pop	ebp
	ret	0
?_Nextnode@?$_List_val@U?$_List_simple_types@G@std@@@std@@SAAAPAU?$_List_node@GPAX@2@PAU32@@Z ENDP ; std::_List_val<std::_List_simple_types<unsigned short> >::_Nextnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_val@U?$_List_simple_types@G@std@@@std@@QAE@XZ PROC ; std::_List_val<std::_List_simple_types<unsigned short> >::_List_val<std::_List_simple_types<unsigned short> >, COMDAT
; _this$ = ecx

; 523  : 		: _Myhead(),

	mov	DWORD PTR [ecx], 0

; 526  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0?$_List_val@U?$_List_simple_types@G@std@@@std@@QAE@XZ ENDP ; std::_List_val<std::_List_simple_types<unsigned short> >::_List_val<std::_List_simple_types<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Mysize@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABIXZ PROC ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Mysize, COMDAT
; _this$ = ecx

; 813  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+4]

; 814  : 		}

	ret	0
?_Mysize@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABIXZ ENDP ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Mysize@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAIXZ PROC ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Mysize, COMDAT
; _this$ = ecx

; 808  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+4]

; 809  : 		}

	ret	0
?_Mysize@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Myhead@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABQAU?$_List_node@GPAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABQAU?$_List_node@GPAX@2@XZ PROC ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Myhead, COMDAT
; _this$ = ecx

; 803  : 		return (_Get_data()._Myhead);

	mov	eax, ecx

; 804  : 		}

	ret	0
?_Myhead@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABQAU?$_List_node@GPAX@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Myhead@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAPAU?$_List_node@GPAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAPAU?$_List_node@GPAX@2@XZ PROC ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Myhead, COMDAT
; _this$ = ecx

; 798  : 		return (_Get_data()._Myhead);

	mov	eax, ecx

; 799  : 		}

	ret	0
?_Myhead@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAPAU?$_List_node@GPAX@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Get_data@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABV?$_List_val@U?$_List_simple_types@G@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABV?$_List_val@U?$_List_simple_types@G@std@@@2@XZ PROC ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Get_data, COMDAT
; _this$ = ecx

; 793  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 794  : 		}

	ret	0
?_Get_data@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABV?$_List_val@U?$_List_simple_types@G@std@@@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Get_data@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAV?$_List_val@U?$_List_simple_types@G@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAV?$_List_val@U?$_List_simple_types@G@std@@@2@XZ PROC ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Get_data, COMDAT
; _this$ = ecx

; 788  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 789  : 		}

	ret	0
?_Get_data@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAV?$_List_val@U?$_List_simple_types@G@std@@@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Getal@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@2@XZ PROC ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Getal, COMDAT
; _this$ = ecx

; 783  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 784  : 		}

	ret	0
?_Getal@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Getal@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@2@XZ PROC ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Getal, COMDAT
; _this$ = ecx

; 778  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 779  : 		}

	ret	0
?_Getal@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Buynode0@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEPAU?$_List_node@GPAX@2@PAU32@0@Z
_TEXT	SEGMENT
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
?_Buynode0@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEPAU?$_List_node@GPAX@2@PAU32@0@Z PROC ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Buynode0, COMDAT
; _this$ = ecx

; 745  : 		{	// allocate a node and set links

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN26@Buynode0
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN98@Buynode0:
$LN26@Buynode0:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 748  : 		if (_Next == _Nodeptr())

	mov	ecx, DWORD PTR __Next$[ebp]
	test	ecx, ecx
	jne	SHORT $LN95@Buynode0

; 749  : 			{	// point at self
; 750  : 			_Next = _Pnode;

	mov	ecx, eax

; 751  : 			_Prev = _Pnode;

	mov	edx, eax
	jmp	SHORT $LN2@Buynode0
$LN95@Buynode0:
	mov	edx, DWORD PTR __Prev$[ebp]
$LN2@Buynode0:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 535  : 		return ((_Nodepref)_Pnode->_Prev);

	lea	ecx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN4@Buynode0
	mov	DWORD PTR [ecx], edx
$LN4@Buynode0:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 764  : 		}

	pop	ebp
	ret	8
$LN97@Buynode0:
?_Buynode0@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEPAU?$_List_node@GPAX@2@PAU32@0@Z ENDP ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Buynode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Freeheadnode@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEXPAU?$_List_node@GPAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freeheadnode@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEXPAU?$_List_node@GPAX@2@@Z PROC ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Freeheadnode, COMDAT
; _this$ = ecx

; 735  : 		{	// free head node using current allocator

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
	push	1
	push	DWORD PTR __Pnode$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 741  : 		}

	pop	ebp
	ret	4
?_Freeheadnode@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEXPAU?$_List_node@GPAX@2@@Z ENDP ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Buyheadnode@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEPAU?$_List_node@GPAX@2@XZ
_TEXT	SEGMENT
?_Buyheadnode@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEPAU?$_List_node@GPAX@2@XZ PROC ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Buyheadnode, COMDAT
; _this$ = ecx

; 731  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

	push	0
	push	0
	call	?_Buynode0@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEPAU?$_List_node@GPAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Buynode0

; 732  : 		}

	ret	0
?_Buyheadnode@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAEPAU?$_List_node@GPAX@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Buyheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??1?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@XZ PROC ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::~_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
	push	1
	push	DWORD PTR [ecx]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 612  : 		}

	ret	0
??1?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::~_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Myval@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@SAAAGPAU?$_List_node@GPAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@SAAAGPAU?$_List_node@GPAX@2@@Z PROC ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Myval, COMDAT

; 589  : 		{	// return reference to value in node

	npad	2
	push	ebp
	mov	ebp, esp

; 540  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 8

; 590  : 		return (_List_val<_Val_types>::_Myval(_Pnode));
; 591  : 		}

	pop	ebp
	ret	0
?_Myval@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@SAAAGPAU?$_List_node@GPAX@2@@Z ENDP ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Prevnode@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@SAAAPAU?$_List_node@GPAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@SAAAPAU?$_List_node@GPAX@2@PAU32@@Z PROC ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Prevnode, COMDAT

; 584  : 		{	// return reference to predecessor pointer in node

	npad	2
	push	ebp
	mov	ebp, esp

; 535  : 		return ((_Nodepref)_Pnode->_Prev);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 585  : 		return (_List_val<_Val_types>::_Prevnode(_Pnode));
; 586  : 		}

	pop	ebp
	ret	0
?_Prevnode@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@SAAAPAU?$_List_node@GPAX@2@PAU32@@Z ENDP ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Prevnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Nextnode@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@SAAAPAU?$_List_node@GPAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@SAAAPAU?$_List_node@GPAX@2@PAU32@@Z PROC ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Nextnode, COMDAT

; 579  : 		{	// return reference to successor pointer in node

	npad	2
	push	ebp
	mov	ebp, esp

; 580  : 		return (_List_val<_Val_types>::_Nextnode(_Pnode));

	mov	eax, DWORD PTR __Pnode$[ebp]

; 581  : 		}

	pop	ebp
	ret	0
?_Nextnode@?$_List_alloc@U?$_List_base_types@GV?$allocator@G@std@@@std@@@std@@SAAAPAU?$_List_node@GPAX@2@PAU32@@Z ENDP ; std::_List_alloc<std::_List_base_types<unsigned short,std::allocator<unsigned short> > >::_Nextnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >::max_size, COMDAT
; _this$ = ecx

; 1108 : 		return (_Mytraits::max_size(*this));

	mov	eax, 357913941				; 15555555H

; 1109 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@QAEXPAU?$_List_node@GPAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@QAEXPAU?$_List_node@GPAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >::deallocate, COMDAT
; _this$ = ecx

; 1087 : 		{	// deallocate object at _Ptr, ignore size

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 1088 : 		_Mybase::deallocate(_Ptr, _Count);
; 1089 : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@QAEXPAU?$_List_node@GPAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@QAEPAU?$_List_node@GPAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@QAEPAU?$_List_node@GPAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >::allocate, COMDAT
; _this$ = ecx

; 1076 : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 1078 : 		}

	pop	ebp

; 1077 : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@U?$_List_node@GPAX@std@@@std@@QAEPAU?$_List_node@GPAX@2@I@Z ; std::allocator<std::_List_node<unsigned short,void *> >::allocate
?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@QAEPAU?$_List_node@GPAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<unsigned short,void *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@GPAX@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@GPAX@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<unsigned short,void *> > >::max_size, COMDAT

; 970  : 		return (_Al.max_size());

	mov	eax, 357913941				; 15555555H

; 971  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@U?$_List_node@GPAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@GPAX@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<unsigned short,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator@U?$_List_node@GPAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$_List_node@GPAX@std@@@std@@QBEIXZ PROC ; std::allocator<std::_List_node<unsigned short,void *> >::max_size, COMDAT
; _this$ = ecx

; 851  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 357913941				; 15555555H

; 852  : 		}

	ret	0
?max_size@?$allocator@U?$_List_node@GPAX@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_List_node<unsigned short,void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_List_node@GPAX@std@@@std@@QAEPAU?$_List_node@GPAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$_List_node@GPAX@std@@@std@@QAEPAU?$_List_node@GPAX@2@I@Z PROC ; std::allocator<std::_List_node<unsigned short,void *> >::allocate, COMDAT
; _this$ = ecx

; 827  : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 53   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 357913941				; 15555555H
	jbe	SHORT $LN5@allocate

; 58   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 69   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN9@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@allocate:
$LN9@allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 87   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@allocate:
$LN14@allocate:
	int	3
?allocate@?$allocator@U?$_List_node@GPAX@std@@@std@@QAEPAU?$_List_node@GPAX@2@I@Z ENDP ; std::allocator<std::_List_node<unsigned short,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_List_node@GPAX@std@@@std@@QAEXPAU?$_List_node@GPAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U?$_List_node@GPAX@std@@@std@@QAEXPAU?$_List_node@GPAX@2@I@Z PROC ; std::allocator<std::_List_node<unsigned short,void *> >::deallocate, COMDAT
; _this$ = ecx

; 822  : 		{	// deallocate object at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	12					; 0000000cH
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 824  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@U?$_List_node@GPAX@std@@@std@@QAEXPAU?$_List_node@GPAX@2@I@Z ENDP ; std::allocator<std::_List_node<unsigned short,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@G@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@G@std@@QAE@XZ PROC			; std::allocator<unsigned short>::allocator<unsigned short>, COMDAT
; _this$ = ecx

; 803  : 		{	// construct default allocator (do nothing)
; 804  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@G@std@@QAE@XZ ENDP			; std::allocator<unsigned short>::allocator<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_set
;	COMDAT ?_Kfn@?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@SAABGABG@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@SAABGABG@Z PROC ; std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0>::_Kfn, COMDAT

; 43   : 		{	// return entire value as key

	npad	2
	push	ebp
	mov	ebp, esp

; 44   : 		return (_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 45   : 		}

	pop	ebp
	ret	0
?_Kfn@?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@SAABGABG@Z ENDP ; std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0>::_Kfn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_set
;	COMDAT ??0?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@QAE@ABV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@1@@Z
_TEXT	SEGMENT
__Traits$ = 8						; size = 4
??0?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@QAE@ABV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@1@@Z PROC ; std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0>::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0>, COMDAT
; _this$ = ecx

; 37   : 		{	// construct with specified comparator

	npad	2
	push	ebp
	mov	ebp, esp

; 36   : 		: _Tr(_Traits)

	mov	eax, DWORD PTR __Traits$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 38   : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??0?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@QAE@ABV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@1@@Z ENDP ; std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0>::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$hash@G@std@@V?$_Compressed_pair@U?$equal_to@G@std@@M$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$equal_to@G@std@@M$00@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$hash@G@std@@V?$_Compressed_pair@U?$equal_to@G@std@@M$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$equal_to@G@std@@M$00@2@XZ PROC ; std::_Compressed_pair<std::hash<unsigned short>,std::_Compressed_pair<std::equal_to<unsigned short>,float,1>,1>::_Get_second, COMDAT
; _this$ = ecx

; 343  : 		return (_Myval2);

	mov	eax, ecx

; 344  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$hash@G@std@@V?$_Compressed_pair@U?$equal_to@G@std@@M$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$equal_to@G@std@@M$00@2@XZ ENDP ; std::_Compressed_pair<std::hash<unsigned short>,std::_Compressed_pair<std::equal_to<unsigned short>,float,1>,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$hash@G@std@@V?$_Compressed_pair@U?$equal_to@G@std@@M$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$equal_to@G@std@@M$00@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$hash@G@std@@V?$_Compressed_pair@U?$equal_to@G@std@@M$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$equal_to@G@std@@M$00@2@XZ PROC ; std::_Compressed_pair<std::hash<unsigned short>,std::_Compressed_pair<std::equal_to<unsigned short>,float,1>,1>::_Get_second, COMDAT
; _this$ = ecx

; 338  : 		return (_Myval2);

	mov	eax, ecx

; 339  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$hash@G@std@@V?$_Compressed_pair@U?$equal_to@G@std@@M$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$equal_to@G@std@@M$00@2@XZ ENDP ; std::_Compressed_pair<std::hash<unsigned short>,std::_Compressed_pair<std::equal_to<unsigned short>,float,1>,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$hash@G@std@@V?$_Compressed_pair@U?$equal_to@G@std@@M$00@2@$00@std@@QBEABU?$hash@G@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$hash@G@std@@V?$_Compressed_pair@U?$equal_to@G@std@@M$00@2@$00@std@@QBEABU?$hash@G@2@XZ PROC ; std::_Compressed_pair<std::hash<unsigned short>,std::_Compressed_pair<std::equal_to<unsigned short>,float,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 323  : 		return (*this);

	mov	eax, ecx

; 324  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$hash@G@std@@V?$_Compressed_pair@U?$equal_to@G@std@@M$00@2@$00@std@@QBEABU?$hash@G@2@XZ ENDP ; std::_Compressed_pair<std::hash<unsigned short>,std::_Compressed_pair<std::equal_to<unsigned short>,float,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$equal_to@G@std@@M$00@std@@QBEABMXZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$equal_to@G@std@@M$00@std@@QBEABMXZ PROC ; std::_Compressed_pair<std::equal_to<unsigned short>,float,1>::_Get_second, COMDAT
; _this$ = ecx

; 343  : 		return (_Myval2);

	mov	eax, ecx

; 344  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$equal_to@G@std@@M$00@std@@QBEABMXZ ENDP ; std::_Compressed_pair<std::equal_to<unsigned short>,float,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$equal_to@G@std@@M$00@std@@QAEAAMXZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$equal_to@G@std@@M$00@std@@QAEAAMXZ PROC ; std::_Compressed_pair<std::equal_to<unsigned short>,float,1>::_Get_second, COMDAT
; _this$ = ecx

; 338  : 		return (_Myval2);

	mov	eax, ecx

; 339  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$equal_to@G@std@@M$00@std@@QAEAAMXZ ENDP ; std::_Compressed_pair<std::equal_to<unsigned short>,float,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$equal_to@G@std@@M$00@std@@QBEABU?$equal_to@G@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$equal_to@G@std@@M$00@std@@QBEABU?$equal_to@G@2@XZ PROC ; std::_Compressed_pair<std::equal_to<unsigned short>,float,1>::_Get_first, COMDAT
; _this$ = ecx

; 323  : 		return (*this);

	mov	eax, ecx

; 324  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$equal_to@G@std@@M$00@std@@QBEABU?$equal_to@G@2@XZ ENDP ; std::_Compressed_pair<std::equal_to<unsigned short>,float,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??R?$equal_to@G@std@@QBE_NABG0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$equal_to@G@std@@QBE_NABG0@Z PROC			; std::equal_to<unsigned short>::operator(), COMDAT
; _this$ = ecx

; 219  : 		{	// apply operator== to operands

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Left$[ebp]
	mov	cx, WORD PTR [eax]
	mov	eax, DWORD PTR __Right$[ebp]
	cmp	cx, WORD PTR [eax]
	sete	al

; 220  : 		return (_Left == _Right);
; 221  : 		}

	pop	ebp
	ret	8
??R?$equal_to@G@std@@QBE_NABG0@Z ENDP			; std::equal_to<unsigned short>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Get_max_bucket_size@?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@QBEABMXZ
_TEXT	SEGMENT
?_Get_max_bucket_size@?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@QBEABMXZ PROC ; std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >::_Get_max_bucket_size, COMDAT
; _this$ = ecx

; 138  : 		return (_Mypair._Get_second()._Get_second());

	mov	eax, ecx

; 139  : 		}

	ret	0
?_Get_max_bucket_size@?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@QBEABMXZ ENDP ; std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >::_Get_max_bucket_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Get_max_bucket_size@?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@QAEAAMXZ
_TEXT	SEGMENT
?_Get_max_bucket_size@?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@QAEAAMXZ PROC ; std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >::_Get_max_bucket_size, COMDAT
; _this$ = ecx

; 133  : 		return (_Mypair._Get_second()._Get_second());

	mov	eax, ecx

; 134  : 		}

	ret	0
?_Get_max_bucket_size@?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@QAEAAMXZ ENDP ; std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >::_Get_max_bucket_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Getkeyeq@?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@QBEABU?$equal_to@G@2@XZ
_TEXT	SEGMENT
?_Getkeyeq@?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@QBEABU?$equal_to@G@2@XZ PROC ; std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >::_Getkeyeq, COMDAT
; _this$ = ecx

; 128  : 		return (_Mypair._Get_second()._Get_first());

	mov	eax, ecx

; 129  : 		}

	ret	0
?_Getkeyeq@?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@QBEABU?$equal_to@G@2@XZ ENDP ; std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >::_Getkeyeq
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Gethash@?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@QBEABU?$hash@G@2@XZ
_TEXT	SEGMENT
?_Gethash@?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@QBEABU?$hash@G@2@XZ PROC ; std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >::_Gethash, COMDAT
; _this$ = ecx

; 123  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 124  : 		}

	ret	0
?_Gethash@?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@QBEABU?$hash@G@2@XZ ENDP ; std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >::_Gethash
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ??R?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@QBE_NABG0@Z
_TEXT	SEGMENT
__Keyval1$ = 8						; size = 4
__Keyval2$ = 12						; size = 4
??R?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@QBE_NABG0@Z PROC ; std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >::operator(), COMDAT
; _this$ = ecx

; 117  : 		{	// test if _Keyval1 NOT equal to _Keyval2

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Keyval1$[ebp]
	mov	cx, WORD PTR [eax]
	mov	eax, DWORD PTR __Keyval2$[ebp]
	cmp	cx, WORD PTR [eax]
	setne	al

; 118  : 		return (!_Getkeyeq()(_Keyval1, _Keyval2));
; 119  : 		}

	pop	ebp
	ret	8
??R?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@QBE_NABG0@Z ENDP ; std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ??R?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@QBEIABG@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
??R?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@QBEIABG@Z PROC ; std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >::operator(), COMDAT
; _this$ = ecx

; 112  : 		{	// hash _Keyval to size_t value

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	mov	edx, DWORD PTR __Keyval$[ebp]
	movzx	eax, BYTE PTR [edx]
	xor	eax, -2128831035			; 811c9dc5H

; 347  : 		_Val *= _FNV_prime;

	imul	ecx, eax, 16777619
	movzx	eax, BYTE PTR [edx+1]
	xor	ecx, eax
	imul	eax, ecx, 16777619
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 114  : 		}

	pop	ebp
	ret	4
??R?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@QBEIABG@Z ENDP ; std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ??0?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@QAE@U?$hash@G@1@U?$equal_to@G@1@@Z
_TEXT	SEGMENT
__Hasharg$ = 8						; size = 1
__Keyeqarg$ = 12					; size = 1
??0?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@QAE@U?$hash@G@1@U?$equal_to@G@1@@Z PROC ; std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 311  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 109  : 		}

	mov	eax, ecx
	ret	8
??0?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@QAE@U?$hash@G@1@U?$equal_to@G@1@@Z ENDP ; std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 96   : 	{	// deallocate storage for _Count elements of size _Sz

	npad	2
	push	ebp
	mov	ebp, esp

; 97   :  #if defined(_M_IX86) || defined(_M_X64)
; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	or	eax, -1
	mov	ecx, DWORD PTR __Count$[ebp]
	xor	edx, edx
	div	DWORD PTR __Sz$[ebp]
	cmp	ecx, eax
	jbe	SHORT $LN2@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2@Deallocate:

; 99   : 	const size_t _User_size = _Count * _Sz;

	imul	ecx, DWORD PTR __Sz$[ebp]

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN9@Deallocate

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	al, 31					; 0000001fH
	je	SHORT $LN4@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4@Deallocate:

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	ecx, DWORD PTR [eax-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	ecx, eax
	jb	SHORT $LN5@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN5@Deallocate:

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	eax, ecx
	cmp	eax, 4
	jae	SHORT $LN6@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN6@Deallocate:

; 126  : 			<= _Ptr_user - _Ptr_container);
; 127  :  #endif /* _DEBUG */
; 128  : 
; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	eax, 35					; 00000023H
	jbe	SHORT $LN3@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 130  : 			<= _NON_USER_SIZE);
; 131  : 
; 132  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 133  : 		}
; 134  : 
; 135  :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 136  : 	static_cast<void>(_Count);
; 137  : 	static_cast<void>(_Sz);
; 138  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 139  : 
; 140  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 	}

	pop	ebp
	ret	0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 50   : 	{	// allocate storage for _Count elements of size _Sz

	npad	2
	push	ebp
	mov	ebp, esp

; 51   : 	void *_Ptr = 0;
; 52   : 
; 53   : 	if (_Count == 0)

	mov	ecx, DWORD PTR __Count$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@Allocate

; 54   : 		return (_Ptr);

	xor	eax, eax
$LN1@Allocate:

; 89   : 		}
; 90   : 	return (_Ptr);
; 91   : 	}

	pop	ebp
	ret	0
$LN2@Allocate:

; 55   : 
; 56   : 	// check overflow of multiply
; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Sz$[ebp]
	cmp	eax, ecx
	jae	SHORT $LN3@Allocate

; 58   : 		_Xbad_alloc();	// report no memory

	jmp	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN3@Allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	imul	ecx, DWORD PTR __Sz$[ebp]

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	BYTE PTR __Try_aligned_allocation$[ebp], 0
	je	SHORT $LN4@Allocate
	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN4@Allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	eax, DWORD PTR [ecx+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	eax, ecx
	ja	SHORT $LN6@Allocate

; 69   : 			_Xbad_alloc();	// report no memory

	jmp	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN6@Allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	eax
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN7@Allocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN7@Allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 89   : 		}
; 90   : 	return (_Ptr);
; 91   : 	}

	pop	ebp
	ret	0
$LN4@Allocate:

; 76   : 
; 77   :  #ifdef _DEBUG
; 78   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 79   :  #endif /* _DEBUG */
; 80   : 		}
; 81   : 	else
; 82   :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 83   : 	static_cast<void>(_Try_aligned_allocation);
; 84   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 85   : 
; 86   : 		{	// allocate normal block
; 87   : 		_Ptr = ::operator new(_User_size);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN1@Allocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ
_TEXT	SEGMENT
?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ PROC ; std::_Iterator_base0::_Getcont, COMDAT
; _this$ = ecx

; 79   : 		return (0);

	xor	eax, eax

; 80   : 		}

	ret	0
?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ ENDP ; std::_Iterator_base0::_Getcont
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 75   : 		}

	ret	4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 64   : 		}

	ret	0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 91   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 92   :         (void)_Size;
; 93   :         return _Where;

	mov	eax, DWORD PTR __Where$[ebp]

; 94   :     }

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??R?$_Bitwise_hash@G@std@@QBEIABG@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
??R?$_Bitwise_hash@G@std@@QBEIABG@Z PROC		; std::_Bitwise_hash<unsigned short>::operator(), COMDAT
; _this$ = ecx

; 360  : 		{	// hash _Keyval to size_t value by pseudorandomizing transform

	npad	2
	push	ebp
	mov	ebp, esp

; 346  : 		_Val ^= (size_t)_First[_Next];

	mov	edx, DWORD PTR __Keyval$[ebp]
	movzx	eax, BYTE PTR [edx]
	xor	eax, -2128831035			; 811c9dc5H

; 347  : 		_Val *= _FNV_prime;

	imul	ecx, eax, 16777619
	movzx	eax, BYTE PTR [edx+1]
	xor	ecx, eax
	imul	eax, ecx, 16777619

; 361  : 		return (_Hash_seq((const unsigned char *)&_Keyval, sizeof (_Kty)));
; 362  : 		}

	pop	ebp
	ret	4
??R?$_Bitwise_hash@G@std@@QBEIABG@Z ENDP		; std::_Bitwise_hash<unsigned short>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ?_Hash_seq@std@@YAIPBEI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
?_Hash_seq@std@@YAIPBEI@Z PROC				; std::_Hash_seq, COMDAT

; 331  : 	{	// FNV-1a hash function for bytes in [_First, _First + _Count)

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 332  :  #if defined(_WIN64)
; 333  : 	static_assert(sizeof(size_t) == 8, "This code is for 64-bit size_t.");
; 334  : 	const size_t _FNV_offset_basis = 14695981039346656037ULL;
; 335  : 	const size_t _FNV_prime = 1099511628211ULL;
; 336  : 
; 337  :  #else /* defined(_WIN64) */
; 338  : 	static_assert(sizeof(size_t) == 4, "This code is for 32-bit size_t.");
; 339  : 	const size_t _FNV_offset_basis = 2166136261U;
; 340  : 	const size_t _FNV_prime = 16777619U;
; 341  :  #endif /* defined(_WIN64) */
; 342  : 
; 343  : 	size_t _Val = _FNV_offset_basis;
; 344  : 	for (size_t _Next = 0; _Next < _Count; ++_Next)

	mov	esi, DWORD PTR __Count$[ebp]
	xor	ecx, ecx
	mov	edx, -2128831035			; 811c9dc5H
	test	esi, esi
	je	SHORT $LN12@Hash_seq
	push	edi
	mov	edi, DWORD PTR __First$[ebp]
$LL8@Hash_seq:

; 345  : 		{	// fold in another byte
; 346  : 		_Val ^= (size_t)_First[_Next];

	movzx	eax, BYTE PTR [ecx+edi]
	inc	ecx
	xor	eax, edx

; 347  : 		_Val *= _FNV_prime;

	imul	edx, eax, 16777619
	cmp	ecx, esi
	jb	SHORT $LL8@Hash_seq
	pop	edi
$LN12@Hash_seq:

; 348  : 		}
; 349  : 	return (_Val);

	mov	eax, edx
	pop	esi

; 350  : 	}

	pop	ebp
	ret	0
?_Hash_seq@std@@YAIPBEI@Z ENDP				; std::_Hash_seq
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@Ustbrp_rect@@@@QAEXABUstbrp_rect@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?push_back@?$ImVector@Ustbrp_rect@@@@QAEXABUstbrp_rect@@@Z PROC ; ImVector<stbrp_rect>::push_back, COMDAT
; _this$ = ecx

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jne	SHORT $LN8@push_back
	inc	edi

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, edi
	cmovg	edi, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	edi, ecx
	jle	SHORT $LN8@push_back

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	mov	eax, edi
	shl	eax, 4
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN10@push_back

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 4
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@push_back:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN8@push_back:

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR _v$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR [esi+8]
	pop	edi
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	inc	DWORD PTR [esi]
	pop	esi
	pop	ebp
	ret	4
?push_back@?$ImVector@Ustbrp_rect@@@@QAEXABUstbrp_rect@@@Z ENDP ; ImVector<stbrp_rect>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@Ustbrp_rect@@@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@Ustbrp_rect@@@@QAEXH@Z PROC		; ImVector<stbrp_rect>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	mov	eax, edi
	shl	eax, 4
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 4
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@Ustbrp_rect@@@@QAEXH@Z ENDP		; ImVector<stbrp_rect>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@Ustbrp_rect@@@@QAEHH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?_grow_capacity@?$ImVector@Ustbrp_rect@@@@QAEHH@Z PROC	; ImVector<stbrp_rect>::_grow_capacity, COMDAT
; _this$ = ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@grow_capac
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _new_size$[ebp]
	sar	ecx, 1
	add	ecx, esi
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
$LN3@grow_capac:
	mov	eax, DWORD PTR _new_size$[ebp]
	mov	ecx, 8
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
?_grow_capacity@?$ImVector@Ustbrp_rect@@@@QAEHH@Z ENDP	; ImVector<stbrp_rect>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@Ustbrp_rect@@@@QAEAAUstbrp_rect@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@Ustbrp_rect@@@@QAEAAUstbrp_rect@@H@Z PROC	; ImVector<stbrp_rect>::operator[], COMDAT
; _this$ = ecx

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR [ecx+8]
	pop	ebp
	ret	4
??A?$ImVector@Ustbrp_rect@@@@QAEAAUstbrp_rect@@H@Z ENDP	; ImVector<stbrp_rect>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@Ustbrp_rect@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@Ustbrp_rect@@@@QAE@XZ PROC		; ImVector<stbrp_rect>::~ImVector<stbrp_rect>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@Ustbrp_rect@@@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@Ustbrp_rect@@@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@Ustbrp_rect@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@Ustbrp_rect@@@@QAE@XZ ENDP		; ImVector<stbrp_rect>::~ImVector<stbrp_rect>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@Ustbrp_rect@@@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@Ustbrp_rect@@@@QAE@XZ PROC		; ImVector<stbrp_rect>::ImVector<stbrp_rect>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@Ustbrp_rect@@@@QAE@XZ ENDP		; ImVector<stbrp_rect>::ImVector<stbrp_rect>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
?Decode85@@YAXPBEPAE@Z PROC				; Decode85

; 1174 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1175 :     while (*src)

	mov	edx, DWORD PTR _src$[ebp]
	push	ebx
	mov	bl, BYTE PTR [edx]
	test	bl, bl
	je	SHORT $LN3@Decode85
	push	esi
	mov	esi, DWORD PTR _dst$[ebp]
	add	esi, 2
	add	edx, 3
	npad	7
$LL2@Decode85:

; 1176 :     {
; 1177 :         unsigned int tmp = Decode85Byte(src[0]) + 85*(Decode85Byte(src[1]) + 85*(Decode85Byte(src[2]) + 85*(Decode85Byte(src[3]) + 85*Decode85Byte(src[4]))));

	movzx	eax, BYTE PTR [edx+1]
	push	eax
	call	?Decode85Byte@@YAID@Z			; Decode85Byte
	imul	ecx, eax, 85
	movzx	eax, BYTE PTR [edx]
	push	eax
	call	?Decode85Byte@@YAID@Z			; Decode85Byte
	add	ecx, eax
	movzx	eax, BYTE PTR [edx-1]
	push	eax
	imul	ecx, ecx, 85
	call	?Decode85Byte@@YAID@Z			; Decode85Byte
	add	ecx, eax
	movzx	eax, BYTE PTR [edx-2]
	push	eax
	imul	ecx, ecx, 85
	call	?Decode85Byte@@YAID@Z			; Decode85Byte
	add	ecx, eax
	push	ebx
	imul	ecx, ecx, 85
	call	?Decode85Byte@@YAID@Z			; Decode85Byte
	add	ecx, eax

; 1178 :         dst[0] = ((tmp >> 0) & 0xFF); dst[1] = ((tmp >> 8) & 0xFF); dst[2] = ((tmp >> 16) & 0xFF); dst[3] = ((tmp >> 24) & 0xFF);   // We can't assume little-endianness.
; 1179 :         src += 5;

	lea	edx, DWORD PTR [edx+5]
	mov	eax, ecx
	mov	BYTE PTR [esi-2], cl
	shr	eax, 8

; 1180 :         dst += 4;

	lea	esi, DWORD PTR [esi+4]
	mov	BYTE PTR [esi-5], al
	add	esp, 20					; 00000014H
	mov	eax, ecx
	shr	ecx, 24					; 00000018H
	shr	eax, 16					; 00000010H
	mov	BYTE PTR [esi-4], al
	mov	BYTE PTR [esi-3], cl
	mov	al, BYTE PTR [edx-3]
	mov	bl, al
	test	al, al
	jne	SHORT $LL2@Decode85
	pop	esi
$LN3@Decode85:
	pop	ebx

; 1181 :     }
; 1182 : }

	pop	ebp
	ret	0
?Decode85@@YAXPBEPAE@Z ENDP				; Decode85
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_c$ = 8							; size = 1
?Decode85Byte@@YAID@Z PROC				; Decode85Byte

; 1172 : static unsigned int Decode85Byte(char c)                                    { return c >= '\\' ? c-36 : c-35; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	al, BYTE PTR _c$[ebp]
	cmp	al, 92					; 0000005cH
	movsx	eax, al
	jl	SHORT $LN3@Decode85By
	sub	eax, 36					; 00000024H
	pop	ebp
	ret	0
$LN3@Decode85By:
	sub	eax, 35					; 00000023H
	pop	ebp
	ret	0
?Decode85Byte@@YAID@Z ENDP				; Decode85Byte
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
?GetDefaultCompressedFontDataTTFBase85@@YAPBDXZ PROC	; GetDefaultCompressedFontDataTTFBase85

; 2421 :     return proggy_clean_ttf_compressed_data_base85;

	mov	eax, OFFSET ?proggy_clean_ttf_compressed_data_base85@@3QBDB

; 2422 : }

	ret	0
?GetDefaultCompressedFontDataTTFBase85@@YAPBDXZ ENDP	; GetDefaultCompressedFontDataTTFBase85
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_output$ = 8						; size = 4
_olen$1$ = 12						; size = 4
_i$ = 12						; size = 4
_length$ = 16						; size = 4
?stb_decompress@@YAIPAE0I@Z PROC			; stb_decompress

; 2289 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 2290 :     unsigned int olen;
; 2291 :     if (stb__in4(0) != 0x57bC0000) return 0;

	mov	esi, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [esi]
	movzx	eax, BYTE PTR [esi+1]
	shl	ecx, 8
	add	ecx, eax
	movzx	eax, BYTE PTR [esi+2]
	shl	ecx, 8
	add	ecx, eax
	movzx	eax, BYTE PTR [esi+3]
	shl	ecx, 8
	add	ecx, eax
	cmp	ecx, 1471938560				; 57bc0000H
	je	SHORT $LN5@stb_decomp
$LN22@stb_decomp:
	xor	eax, eax
	pop	esi

; 2318 :             return 0;
; 2319 :     }
; 2320 : }

	pop	ebp
	ret	0
$LN5@stb_decomp:

; 2292 :     if (stb__in4(4) != 0)          return 0; // error! stream is > 4GB

	movzx	ecx, BYTE PTR [esi+4]
	movzx	eax, BYTE PTR [esi+5]
	shl	ecx, 8
	add	ecx, eax
	movzx	eax, BYTE PTR [esi+6]
	shl	ecx, 8
	add	ecx, eax
	movzx	eax, BYTE PTR [esi+7]
	shl	ecx, 8
	add	ecx, eax
	jne	SHORT $LN22@stb_decomp

; 2293 :     olen = stb_decompress_length(i);

	push	ebx
	push	edi
	push	esi
	call	?stb_decompress_length@@YAIPAE@Z	; stb_decompress_length

; 2294 :     stb__barrier2 = i;
; 2295 :     stb__barrier3 = i+length;

	mov	ecx, DWORD PTR _length$[ebp]
	add	ecx, esi
	mov	DWORD PTR ?stb__barrier2@@3PAEA, esi
	mov	DWORD PTR ?stb__barrier3@@3PAEA, ecx

; 2296 :     stb__barrier = output + olen;
; 2297 :     stb__barrier4 = output;
; 2298 :     i += 16;

	add	esi, 16					; 00000010H
	mov	ecx, DWORD PTR _output$[ebp]

; 2303 :         i = stb_decompress_token(i);

	push	esi
	mov	DWORD PTR _olen$1$[ebp], eax
	mov	DWORD PTR ?stb__barrier4@@3PAEA, ecx
	lea	ebx, DWORD PTR [eax+ecx]
	mov	DWORD PTR ?stb__dout@@3PAEA, ecx
	mov	DWORD PTR ?stb__barrier@@3PAEA, ebx
	call	?stb_decompress_token@@YAPAEPAE@Z	; stb_decompress_token
	mov	edi, eax
	add	esp, 8

; 2304 :         if (i == old_i) {

	cmp	edi, esi
	je	SHORT $LN16@stb_decomp
	npad	5
$LL2@stb_decomp:

; 2314 :             }
; 2315 :         }
; 2316 :         IM_ASSERT(stb__dout <= output + olen);
; 2317 :         if (stb__dout > output + olen)

	cmp	DWORD PTR ?stb__dout@@3PAEA, ebx
	ja	SHORT $LN8@stb_decomp

; 2299 : 
; 2300 :     stb__dout = output;
; 2301 :     for (;;) {
; 2302 :         unsigned char *old_i = i;

	push	edi
	mov	esi, edi

; 2303 :         i = stb_decompress_token(i);

	call	?stb_decompress_token@@YAPAEPAE@Z	; stb_decompress_token
	mov	edi, eax
	add	esp, 4

; 2304 :         if (i == old_i) {

	cmp	edi, esi
	jne	SHORT $LL2@stb_decomp
$LN16@stb_decomp:

; 2305 :             if (*i == 0x05 && i[1] == 0xfa) {

	cmp	BYTE PTR [edi], 5
	jne	SHORT $LN8@stb_decomp
	cmp	BYTE PTR [edi+1], 250			; 000000faH
	jne	SHORT $LN8@stb_decomp

; 2306 :                 IM_ASSERT(stb__dout == output + olen);
; 2307 :                 if (stb__dout != output + olen) return 0;

	cmp	DWORD PTR ?stb__dout@@3PAEA, ebx
	jne	SHORT $LN8@stb_decomp

; 2308 :                 if (stb_adler32(1, output, olen) != (unsigned int) stb__in4(2))

	mov	ebx, DWORD PTR _olen$1$[ebp]
	push	ebx
	push	DWORD PTR _output$[ebp]
	push	1
	call	?stb_adler32@@YAIIPAEI@Z		; stb_adler32
	movzx	edx, BYTE PTR [edi+2]
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [edi+3]
	shl	edx, 8
	add	edx, ecx
	movzx	ecx, BYTE PTR [edi+4]
	shl	edx, 8
	add	edx, ecx
	movzx	ecx, BYTE PTR [edi+5]
	shl	edx, 8
	add	edx, ecx
	xor	ecx, ecx
	cmp	eax, edx
	pop	edi
	cmovne	ebx, ecx
	mov	eax, ebx
	pop	ebx
	pop	esi

; 2318 :             return 0;
; 2319 :     }
; 2320 : }

	pop	ebp
	ret	0
$LN8@stb_decomp:
	pop	edi
	pop	ebx

; 2309 :                     return 0;
; 2310 :                 return olen;
; 2311 :             } else {
; 2312 :                 IM_ASSERT(0); /* NOTREACHED */
; 2313 :                 return 0;

	xor	eax, eax
	pop	esi

; 2318 :             return 0;
; 2319 :     }
; 2320 : }

	pop	ebp
	ret	0
?stb_decompress@@YAIPAE0I@Z ENDP			; stb_decompress
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_input$ = 8						; size = 4
?stb_decompress_length@@YAIPAE@Z PROC			; stb_decompress_length

; 2212 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2213 :     return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];

	mov	edx, DWORD PTR _input$[ebp]
	movzx	eax, BYTE PTR [edx+8]
	movzx	ecx, BYTE PTR [edx+9]
	shl	eax, 8
	add	eax, ecx
	movzx	ecx, BYTE PTR [edx+10]
	shl	eax, 8
	add	eax, ecx
	movzx	ecx, BYTE PTR [edx+11]
	shl	eax, 8
	add	eax, ecx

; 2214 : }

	pop	ebp
	ret	0
?stb_decompress_length@@YAIPAE@Z ENDP			; stb_decompress_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 8
_x1234$1$ = -8						; size = 4
_y1234$1$ = -4						; size = 4
_path$ = 8						; size = 4
_x1$ = 12						; size = 4
_y1$ = 16						; size = 4
_x2$ = 20						; size = 4
_y2$ = 24						; size = 4
_x3$ = 28						; size = 4
_y3$ = 32						; size = 4
_x4$ = 36						; size = 4
_y4$ = 40						; size = 4
_tess_tol$ = 44						; size = 4
_level$ = 48						; size = 4
?PathBezierToCasteljau@@YAXPAV?$ImVector@UImVec2@@@@MMMMMMMMMH@Z PROC ; PathBezierToCasteljau

; 731  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 732  :     float dx = x4 - x1;

	movss	xmm6, DWORD PTR _x4$[ebp]
	sub	esp, 12					; 0000000cH

; 733  :     float dy = y4 - y1;

	movss	xmm7, DWORD PTR _y4$[ebp]
	movaps	xmm4, xmm6

; 734  :     float d2 = ((x2 - x4) * dy - (y2 - y4) * dx);

	movss	xmm0, DWORD PTR _y2$[ebp]
	movaps	xmm3, xmm7
	subss	xmm3, DWORD PTR _y1$[ebp]
	subss	xmm4, DWORD PTR _x1$[ebp]
	movss	xmm2, DWORD PTR _x2$[ebp]
	subss	xmm0, xmm7

; 735  :     float d3 = ((x3 - x4) * dy - (y3 - y4) * dx);

	movss	xmm1, DWORD PTR _x3$[ebp]
	subss	xmm2, xmm6
	subss	xmm1, xmm6
	push	esi
	push	edi
	mulss	xmm0, xmm4

; 736  :     d2 = (d2 >= 0) ? d2 : -d2;
; 737  :     d3 = (d3 >= 0) ? d3 : -d3;
; 738  :     if ((d2+d3) * (d2+d3) < tess_tol * (dx*dx + dy*dy))

	mov	edi, DWORD PTR _path$[ebp]
	mulss	xmm2, xmm3
	mulss	xmm1, xmm3
	subss	xmm2, xmm0
	mulss	xmm3, xmm3
	movss	xmm0, DWORD PTR _y3$[ebp]
	subss	xmm0, xmm7
	andps	xmm2, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
	mulss	xmm0, xmm4
	mulss	xmm4, xmm4
	subss	xmm1, xmm0
	addss	xmm3, xmm4
	andps	xmm1, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
	addss	xmm2, xmm1
	mulss	xmm3, DWORD PTR _tess_tol$[ebp]
	mulss	xmm2, xmm2
	comiss	xmm3, xmm2
	ja	$LN10@PathBezier
	movss	xmm2, DWORD PTR __real@3f000000
	mov	esi, DWORD PTR _level$[ebp]
	npad	2
$LL8@PathBezier:

; 741  :     }
; 742  :     else if (level < 10)

	cmp	esi, 10					; 0000000aH
	jge	$LN4@PathBezier

; 743  :     {
; 744  :         float x12 = (x1+x2)*0.5f,       y12 = (y1+y2)*0.5f;

	movss	xmm0, DWORD PTR _y2$[ebp]

; 745  :         float x23 = (x2+x3)*0.5f,       y23 = (y2+y3)*0.5f;
; 746  :         float x34 = (x3+x4)*0.5f,       y34 = (y3+y4)*0.5f;
; 747  :         float x123 = (x12+x23)*0.5f,    y123 = (y12+y23)*0.5f;
; 748  :         float x234 = (x23+x34)*0.5f,    y234 = (y23+y34)*0.5f;
; 749  :         float x1234 = (x123+x234)*0.5f, y1234 = (y123+y234)*0.5f;
; 750  : 
; 751  :         PathBezierToCasteljau(path, x1,y1,        x12,y12,    x123,y123,  x1234,y1234, tess_tol, level+1);

	inc	esi
	movss	xmm4, DWORD PTR _y1$[ebp]
	mulss	xmm0, xmm2
	push	esi
	movss	xmm1, DWORD PTR _y3$[ebp]
	sub	esp, 36					; 00000024H
	movss	xmm3, DWORD PTR _x2$[ebp]
	movss	xmm5, DWORD PTR _x1$[ebp]
	movss	DWORD PTR _y2$[ebp], xmm0
	mulss	xmm4, xmm2
	mulss	xmm6, xmm2
	addss	xmm4, xmm0
	mulss	xmm1, xmm2
	movss	xmm0, DWORD PTR _x3$[ebp]
	mulss	xmm0, xmm2
	mulss	xmm3, xmm2
	addss	xmm6, xmm0
	mulss	xmm5, xmm2
	addss	xmm0, xmm3
	addss	xmm5, xmm3
	movss	DWORD PTR _x3$[ebp], xmm6
	movaps	xmm6, xmm7
	movss	xmm7, DWORD PTR _x3$[ebp]
	mulss	xmm6, xmm2
	mulss	xmm0, xmm2
	movaps	xmm3, xmm5
	addss	xmm6, xmm1
	mulss	xmm3, xmm2
	addss	xmm1, DWORD PTR _y2$[ebp]
	addss	xmm3, xmm0
	movss	DWORD PTR _y3$[ebp], xmm6
	movss	xmm6, DWORD PTR __real@3f000000
	mulss	xmm7, xmm6
	mulss	xmm1, xmm2
	movaps	xmm2, xmm4
	addss	xmm7, xmm0
	mulss	xmm2, xmm6
	movss	xmm0, DWORD PTR _y3$[ebp]
	mulss	xmm0, xmm6
	addss	xmm2, xmm1
	movss	DWORD PTR _x2$[ebp], xmm7
	addss	xmm0, xmm1
	movaps	xmm1, xmm7
	addss	xmm1, xmm3
	movss	DWORD PTR _y2$[ebp], xmm0
	addss	xmm0, xmm2
	mulss	xmm1, xmm6
	mulss	xmm0, xmm6
	movss	xmm6, DWORD PTR _tess_tol$[ebp]
	movss	DWORD PTR [esp+32], xmm6
	movss	DWORD PTR [esp+28], xmm0
	movss	DWORD PTR [esp+24], xmm1
	movss	DWORD PTR [esp+20], xmm2
	movss	DWORD PTR [esp+16], xmm3
	movss	DWORD PTR [esp+12], xmm4
	movss	DWORD PTR _y1234$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [esp+8], xmm5
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _x1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	edi
	movss	DWORD PTR _x1234$1$[ebp], xmm1
	call	?PathBezierToCasteljau@@YAXPAV?$ImVector@UImVec2@@@@MMMMMMMMMH@Z ; PathBezierToCasteljau
	movss	xmm7, DWORD PTR _y4$[ebp]
	add	esp, 44					; 0000002cH

; 752  :         PathBezierToCasteljau(path, x1234,y1234,  x234,y234,  x34,y34,    x4,y4,       tess_tol, level+1);

	movss	xmm0, DWORD PTR _y1234$1$[ebp]
	movaps	xmm3, xmm7
	movss	xmm6, DWORD PTR _x4$[ebp]
	subss	xmm3, xmm0
	movss	xmm2, DWORD PTR _x2$[ebp]
	movaps	xmm4, xmm6
	movss	xmm1, DWORD PTR _x1234$1$[ebp]
	subss	xmm2, xmm6
	movss	DWORD PTR _y1$[ebp], xmm0
	subss	xmm4, xmm1
	movss	xmm0, DWORD PTR _y2$[ebp]
	movss	DWORD PTR _x1$[ebp], xmm1
	subss	xmm0, xmm7
	mulss	xmm2, xmm3

; 734  :     float d2 = ((x2 - x4) * dy - (y2 - y4) * dx);

	movss	xmm1, DWORD PTR _x3$[ebp]
	mulss	xmm0, xmm4

; 735  :     float d3 = ((x3 - x4) * dy - (y3 - y4) * dx);

	subss	xmm1, xmm6
	subss	xmm2, xmm0
	movss	xmm0, DWORD PTR _y3$[ebp]
	subss	xmm0, xmm7
	mulss	xmm1, xmm3

; 736  :     d2 = (d2 >= 0) ? d2 : -d2;
; 737  :     d3 = (d3 >= 0) ? d3 : -d3;
; 738  :     if ((d2+d3) * (d2+d3) < tess_tol * (dx*dx + dy*dy))

	mulss	xmm3, xmm3
	andps	xmm2, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
	mulss	xmm0, xmm4
	mulss	xmm4, xmm4
	subss	xmm1, xmm0
	addss	xmm3, xmm4
	andps	xmm1, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
	addss	xmm2, xmm1
	mulss	xmm3, DWORD PTR _tess_tol$[ebp]
	mulss	xmm2, xmm2
	comiss	xmm3, xmm2
	movss	xmm2, DWORD PTR __real@3f000000
	jbe	$LL8@PathBezier
$LN10@PathBezier:

; 740  :         path->push_back(ImVec2(x4, y4));

	lea	eax, DWORD PTR $T1[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm6
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 740  :         path->push_back(ImVec2(x4, y4));

	push	eax
	mov	ecx, edi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm7
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 740  :         path->push_back(ImVec2(x4, y4));

	call	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back
$LN4@PathBezier:
	pop	edi
	pop	esi

; 753  :     }
; 754  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PathBezierToCasteljau@@YAXPAV?$ImVector@UImVec2@@@@MMMMMMMMMH@Z ENDP ; PathBezierToCasteljau
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
tv140 = 8						; size = 4
_oversample$ = 8					; size = 4
?stbtt__oversample_shift@@YAMH@Z PROC			; stbtt__oversample_shift

; 3562 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 3563 :    if (!oversample)

	mov	ecx, DWORD PTR _oversample$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@stbtt__ove

; 3564 :       return 0.0f;

	fldz

; 3571 : }

	pop	ebp
	ret	0
$LN2@stbtt__ove:

; 3565 : 
; 3566 :    // The prefilter is a box filter of width "oversample",
; 3567 :    // which shifts phase by (oversample - 1)/2 pixels in
; 3568 :    // oversampled space. We want to shift in the opposite
; 3569 :    // direction to counter this.
; 3570 :    return (float)-(oversample - 1) / (2.0f * (float)oversample);

	mov	eax, 1
	movd	xmm1, ecx
	sub	eax, ecx
	cvtdq2ps xmm1, xmm1
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	addss	xmm1, xmm1
	divss	xmm0, xmm1
	movss	DWORD PTR tv140[ebp], xmm0
	fld	DWORD PTR tv140[ebp]

; 3571 : }

	pop	ebp
	ret	0
?stbtt__oversample_shift@@YAMH@Z ENDP			; stbtt__oversample_shift
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_buffer$ = -12						; size = 8
tv665 = -4						; size = 4
tv662 = -4						; size = 4
tv659 = -4						; size = 4
tv657 = -4						; size = 4
tv655 = -4						; size = 4
_pixels$ = 8						; size = 4
_w$ = 12						; size = 4
_h$ = 16						; size = 4
_stride_in_bytes$ = 20					; size = 4
_safe_h$1$ = 24						; size = 4
_kernel_width$ = 24					; size = 4
?stbtt__v_prefilter@@YAXPAEHHHI@Z PROC			; stbtt__v_prefilter

; 3500 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx

; 3501 :    unsigned char buffer[STBTT_MAX_OVERSAMPLE];
; 3502 :    int safe_h = h - kernel_width;

	mov	ebx, DWORD PTR _h$[ebp]
	xorps	xmm0, xmm0
	push	edi
	mov	edi, DWORD PTR _kernel_width$[ebp]
	sub	ebx, edi

; 3503 :    int j;
; 3504 :    STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze
; 3505 :    for (j=0; j < w; ++j) {

	cmp	DWORD PTR _w$[ebp], 0
	mov	DWORD PTR _safe_h$1$[ebp], ebx
	movq	QWORD PTR _buffer$[ebp], xmm0
	jle	$LN3@stbtt__v_p
	push	esi
$LL4@stbtt__v_p:

; 3506 :       int i;
; 3507 :       unsigned int total;
; 3508 :       STBTT_memset(buffer, 0, kernel_width);

	push	edi
	lea	eax, DWORD PTR _buffer$[ebp]
	push	0
	push	eax
	call	_memset

; 3509 : 
; 3510 :       total = 0;
; 3511 : 
; 3512 :       // make kernel_width a constant in common cases so compiler can optimize out the divide
; 3513 :       switch (kernel_width) {

	lea	eax, DWORD PTR [edi-2]
	add	esp, 12					; 0000000cH
	xor	esi, esi
	cmp	eax, 3
	ja	$LN29@stbtt__v_p
	jmp	DWORD PTR $LN66@stbtt__v_p[eax*4]
$LN25@stbtt__v_p:

; 3514 :          case 2:
; 3515 :             for (i=0; i <= safe_h; ++i) {

	xor	ecx, ecx
	test	ebx, ebx
	js	$LN63@stbtt__v_p
	mov	edx, DWORD PTR _pixels$[ebp]
	mov	DWORD PTR tv665[ebp], edx
	npad	4
$LL9@stbtt__v_p:

; 3516 :                total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];

	mov	bl, BYTE PTR [edx]
	mov	eax, ecx
	and	eax, 7
	movzx	edx, bl
	movzx	eax, BYTE PTR _buffer$[ebp+eax]
	sub	edx, eax

; 3517 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];

	lea	eax, DWORD PTR [ecx+edi]
	and	eax, 7
	add	esi, edx

; 3518 :                pixels[i*stride_in_bytes] = (unsigned char) (total / 2);

	mov	edx, DWORD PTR tv665[ebp]
	inc	ecx
	mov	BYTE PTR _buffer$[ebp+eax], bl
	mov	eax, esi
	shr	eax, 1
	mov	BYTE PTR [edx], al
	mov	eax, DWORD PTR _stride_in_bytes$[ebp]
	add	edx, eax
	mov	DWORD PTR tv665[ebp], edx
	cmp	ecx, DWORD PTR _safe_h$1$[ebp]
	jle	SHORT $LL9@stbtt__v_p

; 3519 :             }
; 3520 :             break;

	jmp	$LN20@stbtt__v_p
$LN26@stbtt__v_p:

; 3521 :          case 3:
; 3522 :             for (i=0; i <= safe_h; ++i) {

	xor	ecx, ecx
	test	ebx, ebx
	js	$LN63@stbtt__v_p
	mov	ebx, DWORD PTR _pixels$[ebp]
	mov	DWORD PTR tv662[ebp], ebx
	npad	7
$LL12@stbtt__v_p:

; 3523 :                total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];

	mov	bl, BYTE PTR [ebx]
	mov	eax, ecx
	and	eax, 7
	movzx	edx, bl
	movzx	eax, BYTE PTR _buffer$[ebp+eax]
	sub	edx, eax

; 3524 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];

	lea	eax, DWORD PTR [ecx+edi]
	and	eax, 7
	add	esi, edx
	inc	ecx
	mov	BYTE PTR _buffer$[ebp+eax], bl

; 3525 :                pixels[i*stride_in_bytes] = (unsigned char) (total / 3);

	mov	eax, -1431655765			; aaaaaaabH
	mov	ebx, DWORD PTR tv662[ebp]
	mul	esi
	mov	eax, DWORD PTR _stride_in_bytes$[ebp]
	shr	edx, 1
	mov	BYTE PTR [ebx], dl
	add	ebx, eax
	mov	DWORD PTR tv662[ebp], ebx
	cmp	ecx, DWORD PTR _safe_h$1$[ebp]
	jle	SHORT $LL12@stbtt__v_p

; 3526 :             }
; 3527 :             break;

	jmp	$LN20@stbtt__v_p
$LN27@stbtt__v_p:

; 3528 :          case 4:
; 3529 :             for (i=0; i <= safe_h; ++i) {

	xor	ecx, ecx
	test	ebx, ebx
	js	$LN63@stbtt__v_p
	mov	edx, DWORD PTR _pixels$[ebp]
	mov	DWORD PTR tv659[ebp], edx
	npad	2
$LL15@stbtt__v_p:

; 3530 :                total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];

	mov	bl, BYTE PTR [edx]
	mov	eax, ecx
	and	eax, 7
	movzx	edx, bl
	movzx	eax, BYTE PTR _buffer$[ebp+eax]
	sub	edx, eax

; 3531 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];

	lea	eax, DWORD PTR [ecx+edi]
	and	eax, 7
	add	esi, edx

; 3532 :                pixels[i*stride_in_bytes] = (unsigned char) (total / 4);

	mov	edx, DWORD PTR tv659[ebp]
	inc	ecx
	mov	BYTE PTR _buffer$[ebp+eax], bl
	mov	eax, esi
	shr	eax, 2
	mov	BYTE PTR [edx], al
	mov	eax, DWORD PTR _stride_in_bytes$[ebp]
	add	edx, eax
	mov	DWORD PTR tv659[ebp], edx
	cmp	ecx, DWORD PTR _safe_h$1$[ebp]
	jle	SHORT $LL15@stbtt__v_p

; 3533 :             }
; 3534 :             break;

	jmp	$LN20@stbtt__v_p
$LN28@stbtt__v_p:

; 3535 :          case 5:
; 3536 :             for (i=0; i <= safe_h; ++i) {

	xor	ecx, ecx
	test	ebx, ebx
	js	$LN63@stbtt__v_p
	mov	ebx, DWORD PTR _pixels$[ebp]
	mov	DWORD PTR tv657[ebp], ebx
	npad	6
$LL18@stbtt__v_p:

; 3537 :                total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];

	mov	bl, BYTE PTR [ebx]
	mov	eax, ecx
	and	eax, 7
	movzx	edx, bl
	movzx	eax, BYTE PTR _buffer$[ebp+eax]
	sub	edx, eax

; 3538 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];

	lea	eax, DWORD PTR [ecx+edi]
	and	eax, 7
	add	esi, edx
	inc	ecx
	mov	BYTE PTR _buffer$[ebp+eax], bl

; 3539 :                pixels[i*stride_in_bytes] = (unsigned char) (total / 5);

	mov	eax, -858993459				; cccccccdH
	mov	ebx, DWORD PTR tv657[ebp]
	mul	esi
	mov	eax, DWORD PTR _stride_in_bytes$[ebp]
	shr	edx, 2
	mov	BYTE PTR [ebx], dl
	add	ebx, eax
	mov	DWORD PTR tv657[ebp], ebx
	cmp	ecx, DWORD PTR _safe_h$1$[ebp]
	jle	SHORT $LL18@stbtt__v_p

; 3540 :             }
; 3541 :             break;

	jmp	SHORT $LN20@stbtt__v_p
$LN29@stbtt__v_p:

; 3542 :          default:
; 3543 :             for (i=0; i <= safe_h; ++i) {

	xor	ecx, ecx
	test	ebx, ebx
	js	SHORT $LN63@stbtt__v_p
	mov	edx, DWORD PTR _pixels$[ebp]
	mov	DWORD PTR tv655[ebp], edx
$LL21@stbtt__v_p:

; 3544 :                total += pixels[i*stride_in_bytes] - buffer[i & STBTT__OVER_MASK];

	mov	bl, BYTE PTR [edx]
	mov	eax, ecx
	and	eax, 7
	movzx	edx, bl
	movzx	eax, BYTE PTR _buffer$[ebp+eax]
	sub	edx, eax

; 3545 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i*stride_in_bytes];

	lea	eax, DWORD PTR [ecx+edi]
	and	eax, 7
	add	esi, edx

; 3546 :                pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);

	xor	edx, edx
	inc	ecx
	mov	BYTE PTR _buffer$[ebp+eax], bl
	mov	eax, esi
	div	edi
	mov	edx, DWORD PTR tv655[ebp]
	mov	BYTE PTR [edx], al
	mov	eax, DWORD PTR _stride_in_bytes$[ebp]
	add	edx, eax
	mov	DWORD PTR tv655[ebp], edx
	cmp	ecx, DWORD PTR _safe_h$1$[ebp]
	jle	SHORT $LL21@stbtt__v_p
	jmp	SHORT $LN20@stbtt__v_p
$LN63@stbtt__v_p:
	mov	eax, DWORD PTR _stride_in_bytes$[ebp]
$LN20@stbtt__v_p:

; 3547 :             }
; 3548 :             break;
; 3549 :       }
; 3550 : 
; 3551 :       for (; i < h; ++i) {

	cmp	ecx, DWORD PTR _h$[ebp]
	jge	SHORT $LN23@stbtt__v_p
	mov	ebx, ecx
	imul	ebx, eax
	add	ebx, DWORD PTR _pixels$[ebp]
$LL24@stbtt__v_p:

; 3552 :          STBTT_assert(pixels[i*stride_in_bytes] == 0);
; 3553 :          total -= buffer[i & STBTT__OVER_MASK];

	mov	eax, ecx

; 3554 :          pixels[i*stride_in_bytes] = (unsigned char) (total / kernel_width);

	xor	edx, edx
	and	eax, 7
	inc	ecx
	movzx	eax, BYTE PTR _buffer$[ebp+eax]
	sub	esi, eax
	mov	eax, esi
	div	edi
	mov	BYTE PTR [ebx], al
	add	ebx, DWORD PTR _stride_in_bytes$[ebp]
	cmp	ecx, DWORD PTR _h$[ebp]
	jl	SHORT $LL24@stbtt__v_p
$LN23@stbtt__v_p:

; 3555 :       }
; 3556 : 
; 3557 :       pixels += 1;

	inc	DWORD PTR _pixels$[ebp]
	sub	DWORD PTR _w$[ebp], 1
	mov	ebx, DWORD PTR _safe_h$1$[ebp]
	jne	$LL4@stbtt__v_p
	pop	esi
$LN3@stbtt__v_p:
	pop	edi
	pop	ebx

; 3558 :    }
; 3559 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN66@stbtt__v_p:
	DD	$LN25@stbtt__v_p
	DD	$LN26@stbtt__v_p
	DD	$LN27@stbtt__v_p
	DD	$LN28@stbtt__v_p
?stbtt__v_prefilter@@YAXPAEHHHI@Z ENDP			; stbtt__v_prefilter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_buffer$ = -28						; size = 8
tv619 = -20						; size = 4
tv633 = -16						; size = 4
tv629 = -12						; size = 4
tv624 = -12						; size = 4
tv622 = -12						; size = 4
_safe_w$1$ = -8						; size = 4
tv620 = -4						; size = 4
_pixels$ = 8						; size = 4
_w$ = 12						; size = 4
_h$ = 16						; size = 4
_stride_in_bytes$ = 20					; size = 4
_kernel_width$ = 24					; size = 4
?stbtt__h_prefilter@@YAXPAEHHHI@Z PROC			; stbtt__h_prefilter

; 3438 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 3439 :    unsigned char buffer[STBTT_MAX_OVERSAMPLE];
; 3440 :    int safe_w = w - kernel_width;

	mov	eax, DWORD PTR _kernel_width$[ebp]
	xorps	xmm0, xmm0
	push	edi
	mov	edi, DWORD PTR _w$[ebp]
	sub	edi, eax

; 3441 :    int j;
; 3442 :    STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze

	movq	QWORD PTR _buffer$[ebp], xmm0

; 3443 :    for (j=0; j < h; ++j) {

	cmp	DWORD PTR _h$[ebp], 0
	mov	DWORD PTR _safe_w$1$[ebp], edi
	jle	$LN3@stbtt__h_p

; 3439 :    unsigned char buffer[STBTT_MAX_OVERSAMPLE];
; 3440 :    int safe_w = w - kernel_width;

	lea	ecx, DWORD PTR [eax-2]
	push	ebx
	mov	DWORD PTR tv633[ebp], ecx
	mov	ebx, eax
	mov	ecx, DWORD PTR _stride_in_bytes$[ebp]
	neg	ecx
	sub	ebx, DWORD PTR _pixels$[ebp]
	push	esi
	mov	DWORD PTR tv619[ebp], ecx
	mov	DWORD PTR tv620[ebp], ebx
	npad	2
$LL4@stbtt__h_p:

; 3444 :       int i;
; 3445 :       unsigned int total;
; 3446 :       STBTT_memset(buffer, 0, kernel_width);

	push	eax
	lea	eax, DWORD PTR _buffer$[ebp]
	push	0
	push	eax
	call	_memset

; 3447 : 
; 3448 :       total = 0;
; 3449 : 
; 3450 :       // make kernel_width a constant in common cases so compiler can optimize out the divide
; 3451 :       switch (kernel_width) {

	mov	eax, DWORD PTR tv633[ebp]
	add	esp, 12					; 0000000cH
	xor	esi, esi
	cmp	eax, 3
	ja	$LN29@stbtt__h_p
	jmp	DWORD PTR $LN61@stbtt__h_p[eax*4]
$LN25@stbtt__h_p:

; 3452 :          case 2:
; 3453 :             for (i=0; i <= safe_w; ++i) {

	xor	ecx, ecx
	test	edi, edi
	js	$LN20@stbtt__h_p
	mov	edi, DWORD PTR _pixels$[ebp]
$LL9@stbtt__h_p:

; 3454 :                total += pixels[i] - buffer[i & STBTT__OVER_MASK];

	mov	bl, BYTE PTR [edi]
	mov	eax, ecx
	and	eax, 7
	movzx	edx, bl
	inc	ecx
	movzx	eax, BYTE PTR _buffer$[ebp+eax]
	sub	edx, eax
	mov	eax, DWORD PTR tv620[ebp]
	add	eax, edi
	add	esi, edx

; 3455 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];

	and	eax, 7
	mov	BYTE PTR _buffer$[ebp+eax], bl

; 3456 :                pixels[i] = (unsigned char) (total / 2);

	mov	eax, esi
	shr	eax, 1
	mov	BYTE PTR [edi], al
	inc	edi
	cmp	ecx, DWORD PTR _safe_w$1$[ebp]
	jle	SHORT $LL9@stbtt__h_p

; 3457 :             }
; 3458 :             break;

	mov	edi, DWORD PTR _safe_w$1$[ebp]
	jmp	$LN59@stbtt__h_p
$LN26@stbtt__h_p:

; 3459 :          case 3:
; 3460 :             for (i=0; i <= safe_w; ++i) {

	xor	ecx, ecx
	test	edi, edi
	js	$LN20@stbtt__h_p
	mov	eax, DWORD PTR _pixels$[ebp]
	mov	DWORD PTR tv629[ebp], eax
$LL12@stbtt__h_p:

; 3461 :                total += pixels[i] - buffer[i & STBTT__OVER_MASK];

	mov	bl, BYTE PTR [eax]
	mov	eax, ecx
	and	eax, 7
	movzx	edx, bl
	inc	ecx
	movzx	eax, BYTE PTR _buffer$[ebp+eax]
	sub	edx, eax
	mov	eax, DWORD PTR tv620[ebp]
	add	eax, DWORD PTR tv629[ebp]
	add	esi, edx

; 3462 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];

	and	eax, 7
	mov	BYTE PTR _buffer$[ebp+eax], bl

; 3463 :                pixels[i] = (unsigned char) (total / 3);

	mov	eax, -1431655765			; aaaaaaabH
	mul	esi
	mov	eax, DWORD PTR tv629[ebp]
	shr	edx, 1
	mov	BYTE PTR [eax], dl
	inc	eax
	mov	DWORD PTR tv629[ebp], eax
	cmp	ecx, edi
	jle	SHORT $LL12@stbtt__h_p

; 3464 :             }
; 3465 :             break;

	jmp	$LN59@stbtt__h_p
$LN27@stbtt__h_p:

; 3466 :          case 4:
; 3467 :             for (i=0; i <= safe_w; ++i) {

	xor	ecx, ecx
	test	edi, edi
	js	$LN20@stbtt__h_p
	mov	edi, DWORD PTR _pixels$[ebp]
	npad	2
$LL15@stbtt__h_p:

; 3468 :                total += pixels[i] - buffer[i & STBTT__OVER_MASK];

	mov	bl, BYTE PTR [edi]
	mov	eax, ecx
	and	eax, 7
	movzx	edx, bl
	inc	ecx
	movzx	eax, BYTE PTR _buffer$[ebp+eax]
	sub	edx, eax
	mov	eax, DWORD PTR tv620[ebp]
	add	eax, edi
	add	esi, edx

; 3469 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];

	and	eax, 7
	mov	BYTE PTR _buffer$[ebp+eax], bl

; 3470 :                pixels[i] = (unsigned char) (total / 4);

	mov	eax, esi
	shr	eax, 2
	mov	BYTE PTR [edi], al
	inc	edi
	cmp	ecx, DWORD PTR _safe_w$1$[ebp]
	jle	SHORT $LL15@stbtt__h_p

; 3471 :             }
; 3472 :             break;

	mov	edi, DWORD PTR _safe_w$1$[ebp]
	jmp	$LN59@stbtt__h_p
$LN28@stbtt__h_p:

; 3473 :          case 5:
; 3474 :             for (i=0; i <= safe_w; ++i) {

	xor	ecx, ecx
	test	edi, edi
	js	$LN20@stbtt__h_p
	mov	eax, DWORD PTR _pixels$[ebp]
	mov	DWORD PTR tv624[ebp], eax
$LL18@stbtt__h_p:

; 3475 :                total += pixels[i] - buffer[i & STBTT__OVER_MASK];

	mov	bl, BYTE PTR [eax]
	mov	eax, ecx
	and	eax, 7
	movzx	edx, bl
	inc	ecx
	movzx	eax, BYTE PTR _buffer$[ebp+eax]
	sub	edx, eax
	mov	eax, DWORD PTR tv620[ebp]
	add	eax, DWORD PTR tv624[ebp]
	add	esi, edx

; 3476 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];

	and	eax, 7
	mov	BYTE PTR _buffer$[ebp+eax], bl

; 3477 :                pixels[i] = (unsigned char) (total / 5);

	mov	eax, -858993459				; cccccccdH
	mul	esi
	mov	eax, DWORD PTR tv624[ebp]
	shr	edx, 2
	mov	BYTE PTR [eax], dl
	inc	eax
	mov	DWORD PTR tv624[ebp], eax
	cmp	ecx, edi
	jle	SHORT $LL18@stbtt__h_p

; 3478 :             }
; 3479 :             break;

	jmp	SHORT $LN59@stbtt__h_p
$LN29@stbtt__h_p:

; 3480 :          default:
; 3481 :             for (i=0; i <= safe_w; ++i) {

	xor	ecx, ecx
	test	edi, edi
	js	SHORT $LN20@stbtt__h_p
	mov	edx, DWORD PTR _pixels$[ebp]
	mov	DWORD PTR tv622[ebp], edx
	npad	5
$LL21@stbtt__h_p:

; 3482 :                total += pixels[i] - buffer[i & STBTT__OVER_MASK];

	mov	bl, BYTE PTR [edx]
	mov	eax, ecx
	and	eax, 7
	movzx	edx, bl
	inc	ecx
	movzx	eax, BYTE PTR _buffer$[ebp+eax]
	sub	edx, eax
	mov	eax, DWORD PTR tv620[ebp]
	add	eax, DWORD PTR tv622[ebp]
	add	esi, edx

; 3483 :                buffer[(i+kernel_width) & STBTT__OVER_MASK] = pixels[i];

	and	eax, 7

; 3484 :                pixels[i] = (unsigned char) (total / kernel_width);

	xor	edx, edx
	mov	BYTE PTR _buffer$[ebp+eax], bl
	mov	eax, esi
	div	DWORD PTR _kernel_width$[ebp]
	mov	edx, DWORD PTR tv622[ebp]
	mov	BYTE PTR [edx], al
	inc	edx
	mov	DWORD PTR tv622[ebp], edx
	cmp	ecx, edi
	jle	SHORT $LL21@stbtt__h_p
$LN59@stbtt__h_p:
	mov	ebx, DWORD PTR tv620[ebp]
$LN20@stbtt__h_p:

; 3485 :             }
; 3486 :             break;
; 3487 :       }
; 3488 : 
; 3489 :       for (; i < w; ++i) {

	cmp	ecx, DWORD PTR _w$[ebp]
	jge	SHORT $LN23@stbtt__h_p
	mov	edi, DWORD PTR _pixels$[ebp]
$LL24@stbtt__h_p:

; 3490 :          STBTT_assert(pixels[i] == 0);
; 3491 :          total -= buffer[i & STBTT__OVER_MASK];

	mov	eax, ecx

; 3492 :          pixels[i] = (unsigned char) (total / kernel_width);

	xor	edx, edx
	and	eax, 7
	movzx	eax, BYTE PTR _buffer$[ebp+eax]
	sub	esi, eax
	mov	eax, esi
	div	DWORD PTR _kernel_width$[ebp]
	mov	BYTE PTR [ecx+edi], al
	inc	ecx
	cmp	ecx, DWORD PTR _w$[ebp]
	jl	SHORT $LL24@stbtt__h_p
	mov	edi, DWORD PTR _safe_w$1$[ebp]
$LN23@stbtt__h_p:

; 3493 :       }
; 3494 : 
; 3495 :       pixels += stride_in_bytes;

	mov	eax, DWORD PTR _stride_in_bytes$[ebp]
	add	DWORD PTR _pixels$[ebp], eax
	add	ebx, DWORD PTR tv619[ebp]
	sub	DWORD PTR _h$[ebp], 1
	mov	eax, DWORD PTR _kernel_width$[ebp]
	mov	DWORD PTR tv620[ebp], ebx
	jne	$LL4@stbtt__h_p
	pop	esi
	pop	ebx
$LN3@stbtt__h_p:
	pop	edi

; 3496 :    }
; 3497 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN61@stbtt__h_p:
	DD	$LN25@stbtt__h_p
	DD	$LN26@stbtt__h_p
	DD	$LN27@stbtt__h_p
	DD	$LN28@stbtt__h_p
?stbtt__h_prefilter@@YAXPAEHHHI@Z ENDP			; stbtt__h_prefilter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_x$1$ = -20						; size = 4
_pass$1$ = -16						; size = 4
_start$1$ = -12						; size = 4
_points$1$ = -8						; size = 4
_num_points$ = -4					; size = 4
_vertices$ = 8						; size = 4
_num_verts$ = 12					; size = 4
_objspace_flatness$ = 16				; size = 4
_contour_lengths$ = 20					; size = 4
_num_contours$ = 24					; size = 4
_userdata$ = 28						; size = 4
?stbtt_FlattenCurves@@YAPAUstbtt__point@@PAUstbtt_vertex@@HMPAPAHPAHPAX@Z PROC ; stbtt_FlattenCurves

; 3056 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 3057 :    stbtt__point *points=0;
; 3058 :    int num_points=0;
; 3059 : 
; 3060 :    float objspace_flatness_squared = objspace_flatness * objspace_flatness;

	movss	xmm0, DWORD PTR _objspace_flatness$[ebp]
	xor	eax, eax
	push	esi
	mulss	xmm0, xmm0

; 3061 :    int i,n=0,start=0, pass;

	xor	edx, edx
	push	edi

; 3062 : 
; 3063 :    // count how many "moves" there are to get the contour count
; 3064 :    for (i=0; i < num_verts; ++i)

	mov	edi, DWORD PTR _num_verts$[ebp]
	mov	DWORD PTR _points$1$[ebp], eax
	mov	DWORD PTR _num_points$[ebp], eax
	movss	DWORD PTR _objspace_flatness$[ebp], xmm0
	mov	DWORD PTR _start$1$[ebp], eax
	test	edi, edi
	jle	SHORT $LN3@stbtt_Flat
	mov	esi, DWORD PTR _vertices$[ebp]
	add	esi, 12					; 0000000cH
$LL32@stbtt_Flat:

; 3065 :       if (vertices[i].type == STBTT_vmove)

	mov	al, BYTE PTR [esi]
	lea	ecx, DWORD PTR [edx+1]
	cmp	al, 1
	lea	esi, DWORD PTR [esi+14]
	cmovne	ecx, edx
	mov	edx, ecx
	sub	edi, 1
	jne	SHORT $LL32@stbtt_Flat
	mov	edi, DWORD PTR _num_verts$[ebp]
$LN3@stbtt_Flat:

; 3066 :          ++n;
; 3067 : 
; 3068 :    *num_contours = n;

	mov	esi, DWORD PTR _num_contours$[ebp]
	mov	DWORD PTR [esi], edx

; 3069 :    if (n == 0) return 0;

	test	edx, edx
	je	SHORT $LN46@stbtt_Flat

; 3070 : 
; 3071 :    *contour_lengths = (int *) STBTT_malloc(sizeof(**contour_lengths) * n, userdata);

	lea	eax, DWORD PTR [edx*4]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ecx, DWORD PTR _contour_lengths$[ebp]
	add	esp, 4
	mov	DWORD PTR [ecx], eax

; 3072 : 
; 3073 :    if (*contour_lengths == 0) {

	test	eax, eax
	jne	SHORT $LN15@stbtt_Flat

; 3074 :       *num_contours = 0;

	mov	DWORD PTR [esi], eax
$LN46@stbtt_Flat:
	pop	edi

; 3075 :       return 0;

	xor	eax, eax
	pop	esi

; 3130 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@stbtt_Flat:

; 3076 :    }
; 3077 : 
; 3078 :    // make two passes through the points so we don't need to realloc
; 3079 :    for (pass=0; pass < 2; ++pass) {

	xor	eax, eax
	mov	DWORD PTR _pass$1$[ebp], eax
	push	ebx
	npad	5
$LL7@stbtt_Flat:

; 3080 :       float x=0,y=0;

	xorps	xmm1, xmm1
	xorps	xmm2, xmm2
	movss	DWORD PTR _x$1$[ebp], xmm1

; 3081 :       if (pass == 1) {

	cmp	eax, 1
	jne	SHORT $LN42@stbtt_Flat

; 3082 :          points = (stbtt__point *) STBTT_malloc(num_points * sizeof(points[0]), userdata);

	mov	eax, DWORD PTR _num_points$[ebp]
	shl	eax, 3
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR _points$1$[ebp], edx

; 3083 :          if (points == NULL) goto error;

	test	edx, edx
	je	$error$49
	movss	xmm1, DWORD PTR _x$1$[ebp]
	xorps	xmm2, xmm2
	jmp	SHORT $LN17@stbtt_Flat
$LN42@stbtt_Flat:
	mov	edx, DWORD PTR _points$1$[ebp]
$LN17@stbtt_Flat:

; 3084 :       }
; 3085 :       num_points = 0;

	xor	ecx, ecx

; 3086 :       n= -1;

	or	ebx, -1
	mov	DWORD PTR _num_points$[ebp], ecx

; 3087 :       for (i=0; i < num_verts; ++i) {

	test	edi, edi
	jle	$LN9@stbtt_Flat

; 3084 :       }
; 3085 :       num_points = 0;

	mov	esi, DWORD PTR _vertices$[ebp]
	add	esi, 10					; 0000000aH
	npad	1
$LL10@stbtt_Flat:

; 3088 :          switch (vertices[i].type) {

	movzx	eax, BYTE PTR [esi+2]
	dec	eax
	cmp	eax, 3
	ja	$LN8@stbtt_Flat
	jmp	DWORD PTR $LN48@stbtt_Flat[eax*4]
$LN19@stbtt_Flat:

; 3089 :             case STBTT_vmove:
; 3090 :                // start the next contour
; 3091 :                if (n >= 0)

	test	ebx, ebx
	js	SHORT $LN20@stbtt_Flat

; 3092 :                   (*contour_lengths)[n] = num_points - start;

	mov	eax, DWORD PTR _contour_lengths$[ebp]
	sub	ecx, DWORD PTR _start$1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [eax+ebx*4], ecx
	mov	ecx, DWORD PTR _num_points$[ebp]
$LN20@stbtt_Flat:

; 3093 :                ++n;

	inc	ebx

; 3094 :                start = num_points;

	mov	DWORD PTR _start$1$[ebp], ecx
$LN21@stbtt_Flat:

; 3095 : 
; 3096 :                x = vertices[i].x, y = vertices[i].y;

	movsx	eax, WORD PTR [esi-10]

; 3097 :                stbtt__add_point(points, num_points++, x,y);

	sub	esp, 8
	movd	xmm1, eax
	movsx	eax, WORD PTR [esi-8]
	cvtdq2ps xmm1, xmm1
	movd	xmm2, eax
	mov	eax, ecx
	cvtdq2ps xmm2, xmm2
	inc	ecx
	mov	DWORD PTR _num_points$[ebp], ecx
	movss	DWORD PTR [esp+4], xmm2
	movss	DWORD PTR [esp], xmm1
	push	eax
	push	edx
	call	?stbtt__add_point@@YAXPAUstbtt__point@@HMM@Z ; stbtt__add_point
	add	esp, 16					; 00000010H

; 3098 :                break;

	jmp	$LN44@stbtt_Flat
$LN22@stbtt_Flat:

; 3099 :             case STBTT_vline:
; 3100 :                x = vertices[i].x, y = vertices[i].y;
; 3101 :                stbtt__add_point(points, num_points++, x, y);
; 3102 :                break;
; 3103 :             case STBTT_vcurve:
; 3104 :                stbtt__tesselate_curve(points, &num_points, x,y,

	movsx	eax, WORD PTR [esi-8]
	movss	xmm0, DWORD PTR _objspace_flatness$[ebp]
	push	0
	sub	esp, 28					; 0000001cH
	movss	DWORD PTR [esp+24], xmm0
	movd	xmm0, eax
	movsx	eax, WORD PTR [esi-10]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [esp+20], xmm0
	movd	xmm0, eax
	movsx	eax, WORD PTR [esi-4]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [esp+16], xmm0
	movd	xmm0, eax
	movsx	eax, WORD PTR [esi-6]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [esp+12], xmm0
	movd	xmm0, eax
	lea	eax, DWORD PTR _num_points$[ebp]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [esp+8], xmm0
	movss	DWORD PTR [esp+4], xmm2
	movss	DWORD PTR [esp], xmm1
	push	eax
	push	edx
	call	?stbtt__tesselate_curve@@YAHPAUstbtt__point@@PAHMMMMMMMH@Z ; stbtt__tesselate_curve
	add	esp, 40					; 00000028H

; 3105 :                                         vertices[i].cx, vertices[i].cy,
; 3106 :                                         vertices[i].x,  vertices[i].y,
; 3107 :                                         objspace_flatness_squared, 0);
; 3108 :                x = vertices[i].x, y = vertices[i].y;
; 3109 :                break;

	jmp	$LN45@stbtt_Flat
$LN23@stbtt_Flat:

; 3110 :             case STBTT_vcubic:
; 3111 :                stbtt__tesselate_cubic(points, &num_points, x,y,

	movsx	eax, WORD PTR [esi-8]
	movss	xmm0, DWORD PTR _objspace_flatness$[ebp]
	push	0
	sub	esp, 36					; 00000024H
	movss	DWORD PTR [esp+32], xmm0
	movd	xmm0, eax
	movsx	eax, WORD PTR [esi-10]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [esp+28], xmm0
	movd	xmm0, eax
	movsx	eax, WORD PTR [esi]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [esp+24], xmm0
	movd	xmm0, eax
	movsx	eax, WORD PTR [esi-2]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [esp+20], xmm0
	movd	xmm0, eax
	movsx	eax, WORD PTR [esi-4]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [esp+16], xmm0
	movd	xmm0, eax
	movsx	eax, WORD PTR [esi-6]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [esp+12], xmm0
	movd	xmm0, eax
	lea	eax, DWORD PTR _num_points$[ebp]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [esp+8], xmm0
	movss	DWORD PTR [esp+4], xmm2
	movss	DWORD PTR [esp], xmm1
	push	eax
	push	edx
	call	?stbtt__tesselate_cubic@@YAXPAUstbtt__point@@PAHMMMMMMMMMH@Z ; stbtt__tesselate_cubic
	add	esp, 48					; 00000030H
$LN45@stbtt_Flat:

; 3112 :                                         vertices[i].cx, vertices[i].cy,
; 3113 :                                         vertices[i].cx1, vertices[i].cy1,
; 3114 :                                         vertices[i].x,  vertices[i].y,
; 3115 :                                         objspace_flatness_squared, 0);
; 3116 :                x = vertices[i].x, y = vertices[i].y;

	movsx	eax, WORD PTR [esi-10]
	movd	xmm1, eax
	movsx	eax, WORD PTR [esi-8]
	cvtdq2ps xmm1, xmm1
	movd	xmm2, eax
	cvtdq2ps xmm2, xmm2
$LN44@stbtt_Flat:
	mov	ecx, DWORD PTR _num_points$[ebp]
$LN8@stbtt_Flat:

; 3087 :       for (i=0; i < num_verts; ++i) {

	mov	edx, DWORD PTR _points$1$[ebp]
	add	esi, 14					; 0000000eH
	sub	edi, 1
	jne	$LL10@stbtt_Flat
	mov	edi, DWORD PTR _num_verts$[ebp]
$LN9@stbtt_Flat:

; 3117 :                break;
; 3118 :          }
; 3119 :       }
; 3120 :       (*contour_lengths)[n] = num_points - start;

	mov	eax, DWORD PTR _contour_lengths$[ebp]
	sub	ecx, DWORD PTR _start$1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [eax+ebx*4], ecx
	mov	eax, DWORD PTR _pass$1$[ebp]
	inc	eax
	mov	DWORD PTR _pass$1$[ebp], eax
	cmp	eax, 2
	jl	$LL7@stbtt_Flat

; 3121 :    }
; 3122 : 
; 3123 :    return points;

	mov	eax, DWORD PTR _points$1$[ebp]
	pop	ebx
	pop	edi
	pop	esi

; 3130 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$error$49:

; 3124 : error:
; 3125 :    STBTT_free(points, userdata);

	push	0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 3126 :    STBTT_free(*contour_lengths, userdata);

	mov	ebx, DWORD PTR _contour_lengths$[ebp]
	push	DWORD PTR [ebx]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 3127 :    *contour_lengths = 0;
; 3128 :    *num_contours = 0;

	mov	eax, DWORD PTR _num_contours$[ebp]
	add	esp, 8
	mov	DWORD PTR [ebx], 0
	pop	ebx
	pop	edi
	mov	DWORD PTR [eax], 0

; 3129 :    return NULL;

	xor	eax, eax
	pop	esi

; 3130 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN48@stbtt_Flat:
	DD	$LN19@stbtt_Flat
	DD	$LN21@stbtt_Flat
	DD	$LN22@stbtt_Flat
	DD	$LN23@stbtt_Flat
?stbtt_FlattenCurves@@YAPAUstbtt__point@@PAUstbtt_vertex@@HMPAPAHPAHPAX@Z ENDP ; stbtt_FlattenCurves
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_mx$1$ = -4						; size = 4
_points$ = 8						; size = 4
_num_points$ = 12					; size = 4
_x0$ = 16						; size = 4
_y0$ = 20						; size = 4
_x1$ = 24						; size = 4
_y1$ = 28						; size = 4
_x2$ = 32						; size = 4
_y2$ = 36						; size = 4
_x3$ = 40						; size = 4
_y3$ = 44						; size = 4
_objspace_flatness_squared$ = 48			; size = 4
_my$1$ = 52						; size = 4
_n$ = 52						; size = 4
?stbtt__tesselate_cubic@@YAXPAUstbtt__point@@PAHMMMMMMMMMH@Z PROC ; stbtt__tesselate_cubic

; 3013 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 3014 :    // @TODO this "flatness" calculation is just made-up nonsense that seems to work well enough
; 3015 :    float dx0 = x1-x0;
; 3016 :    float dy0 = y1-y0;
; 3017 :    float dx1 = x2-x1;

	movss	xmm1, DWORD PTR _x2$[ebp]
	subss	xmm1, DWORD PTR _x1$[ebp]

; 3018 :    float dy1 = y2-y1;

	movss	xmm0, DWORD PTR _y2$[ebp]
	subss	xmm0, DWORD PTR _y1$[ebp]
	movss	xmm7, DWORD PTR _x1$[ebp]
	movss	xmm6, DWORD PTR _y1$[ebp]
	subss	xmm6, DWORD PTR _y0$[ebp]
	subss	xmm7, DWORD PTR _x0$[ebp]

; 3022 :    float dy = y3-y0;
; 3023 :    float longlen = (float) (STBTT_sqrt(dx0*dx0+dy0*dy0)+STBTT_sqrt(dx1*dx1+dy1*dy1)+STBTT_sqrt(dx2*dx2+dy2*dy2));

	mulss	xmm0, xmm0
	push	ebx
	mulss	xmm1, xmm1

; 3025 :    float flatness_squared = longlen*longlen-shortlen*shortlen;
; 3026 : 
; 3027 :    if (n > 16) // 65536 segments on one curve better be enough!

	mov	ebx, DWORD PTR _n$[ebp]
	mulss	xmm6, xmm6
	mulss	xmm7, xmm7
	addss	xmm0, xmm1
	movss	xmm3, DWORD PTR _x3$[ebp]
	xorps	xmm1, xmm1
	movss	xmm2, DWORD PTR _y3$[ebp]
	movss	xmm5, DWORD PTR _x3$[ebp]
	addss	xmm6, xmm7
	movss	xmm4, DWORD PTR _y3$[ebp]
	cvtps2pd xmm0, xmm0
	subss	xmm2, DWORD PTR _y2$[ebp]
	sqrtsd	xmm1, xmm0
	mulss	xmm2, xmm2
	cvtps2pd xmm0, xmm6
	subss	xmm3, DWORD PTR _x2$[ebp]
	sqrtsd	xmm0, xmm0
	mulss	xmm3, xmm3
	addsd	xmm1, xmm0
	subss	xmm4, DWORD PTR _y0$[ebp]
	addss	xmm2, xmm3
	subss	xmm5, DWORD PTR _x0$[ebp]
	mulss	xmm4, xmm4
	mulss	xmm5, xmm5
	cvtps2pd xmm0, xmm2
	addss	xmm4, xmm5
	sqrtsd	xmm0, xmm0
	addsd	xmm1, xmm0
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm4
	cvtpd2ps xmm1, xmm1
	mulss	xmm0, xmm0
	mulss	xmm1, xmm1
	subss	xmm1, xmm0
	cmp	ebx, 16					; 00000010H
	jg	$LN4@stbtt__tes
	movss	xmm7, DWORD PTR __real@3f000000
	push	esi
	mov	esi, DWORD PTR _num_points$[ebp]
	push	edi
	mov	edi, DWORD PTR _points$[ebp]
	npad	6
$LL6@stbtt__tes:

; 3028 :       return;
; 3029 : 
; 3030 :    if (flatness_squared > objspace_flatness_squared) {

	comiss	xmm1, DWORD PTR _objspace_flatness_squared$[ebp]

; 3031 :       float x01 = (x0+x1)/2;
; 3032 :       float y01 = (y0+y1)/2;
; 3033 :       float x12 = (x1+x2)/2;
; 3034 :       float y12 = (y1+y2)/2;
; 3035 :       float x23 = (x2+x3)/2;

	movss	xmm2, DWORD PTR _x3$[ebp]
	jbe	$LN3@stbtt__tes

; 3036 :       float y23 = (y2+y3)/2;
; 3037 : 
; 3038 :       float xa = (x01+x12)/2;
; 3039 :       float ya = (y01+y12)/2;
; 3040 :       float xb = (x12+x23)/2;
; 3041 :       float yb = (y12+y23)/2;
; 3042 : 
; 3043 :       float mx = (xa+xb)/2;
; 3044 :       float my = (ya+yb)/2;
; 3045 : 
; 3046 :       stbtt__tesselate_cubic(points, num_points, x0,y0, x01,y01, xa,ya, mx,my, objspace_flatness_squared,n+1);

	movss	xmm0, DWORD PTR _x2$[ebp]
	inc	ebx
	movss	xmm3, DWORD PTR _x1$[ebp]
	movss	xmm5, DWORD PTR _x0$[ebp]
	movss	xmm1, DWORD PTR _y2$[ebp]
	movss	xmm6, DWORD PTR _y1$[ebp]
	movss	xmm4, DWORD PTR _y0$[ebp]
	mulss	xmm0, xmm7
	push	ebx
	mulss	xmm2, xmm7
	sub	esp, 36					; 00000024H
	mulss	xmm3, xmm7
	addss	xmm2, xmm0
	mulss	xmm5, xmm7
	addss	xmm0, xmm3
	mulss	xmm1, xmm7
	mulss	xmm6, xmm7
	addss	xmm5, xmm3
	movss	DWORD PTR _x2$[ebp], xmm2
	movss	xmm2, DWORD PTR _y3$[ebp]
	mulss	xmm2, xmm7
	mulss	xmm4, xmm7
	movaps	xmm3, xmm5
	addss	xmm2, xmm1
	mulss	xmm0, xmm7
	addss	xmm1, xmm6
	mulss	xmm3, xmm7
	addss	xmm4, xmm6
	movss	xmm6, DWORD PTR _x2$[ebp]
	mulss	xmm6, xmm7
	addss	xmm3, xmm0
	movss	DWORD PTR _y2$[ebp], xmm2
	mulss	xmm1, xmm7
	addss	xmm6, xmm0
	movaps	xmm2, xmm4
	movss	xmm0, DWORD PTR _y2$[ebp]
	mulss	xmm0, xmm7
	mulss	xmm2, xmm7
	addss	xmm0, xmm1
	movss	DWORD PTR _x1$[ebp], xmm6
	addss	xmm2, xmm1
	movaps	xmm1, xmm6
	movss	xmm6, DWORD PTR _objspace_flatness_squared$[ebp]
	addss	xmm1, xmm3
	movss	DWORD PTR [esp+32], xmm6
	movss	DWORD PTR _y1$[ebp], xmm0
	addss	xmm0, xmm2
	mulss	xmm1, xmm7
	mulss	xmm0, xmm7
	movss	DWORD PTR _mx$1$[ebp], xmm1
	movss	DWORD PTR [esp+28], xmm0
	movss	DWORD PTR [esp+24], xmm1
	movss	DWORD PTR [esp+20], xmm2
	movss	DWORD PTR [esp+16], xmm3
	movss	DWORD PTR [esp+12], xmm4
	movss	DWORD PTR _my$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _y0$[ebp]
	movss	DWORD PTR [esp+8], xmm5
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _x0$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	esi
	push	edi
	call	?stbtt__tesselate_cubic@@YAXPAUstbtt__point@@PAHMMMMMMMMMH@Z ; stbtt__tesselate_cubic

; 3047 :       stbtt__tesselate_cubic(points, num_points, mx,my, xb,yb, x23,y23, x3,y3, objspace_flatness_squared,n+1);

	movss	xmm0, DWORD PTR _my$1$[ebp]
	add	esp, 48					; 00000030H
	movss	xmm4, DWORD PTR _y1$[ebp]
	movss	xmm7, DWORD PTR _x3$[ebp]
	subss	xmm4, xmm0
	movss	xmm5, DWORD PTR _mx$1$[ebp]
	movaps	xmm3, xmm7
	movss	xmm6, DWORD PTR _x1$[ebp]
	movss	xmm1, DWORD PTR _x2$[ebp]
	subss	xmm6, xmm5
	subss	xmm1, DWORD PTR _x1$[ebp]
	subss	xmm3, DWORD PTR _x2$[ebp]
	movss	xmm2, DWORD PTR _y3$[ebp]
	movss	DWORD PTR _y0$[ebp], xmm0
	movss	xmm0, DWORD PTR _y2$[ebp]
	subss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR _x0$[ebp], xmm5

; 3019 :    float dx2 = x3-x2;
; 3020 :    float dy2 = y3-y2;
; 3021 :    float dx = x3-x0;

	mulss	xmm0, xmm0
	subss	xmm7, xmm5

; 3022 :    float dy = y3-y0;
; 3023 :    float longlen = (float) (STBTT_sqrt(dx0*dx0+dy0*dy0)+STBTT_sqrt(dx1*dx1+dy1*dy1)+STBTT_sqrt(dx2*dx2+dy2*dy2));

	mulss	xmm1, xmm1
	mulss	xmm4, xmm4
	mulss	xmm6, xmm6
	addss	xmm0, xmm1
	mulss	xmm3, xmm3
	xorps	xmm1, xmm1
	movss	xmm5, DWORD PTR _y3$[ebp]
	addss	xmm4, xmm6

; 3024 :    float shortlen = (float) STBTT_sqrt(dx*dx+dy*dy);

	mulss	xmm7, xmm7
	cvtps2pd xmm0, xmm0
	subss	xmm2, DWORD PTR _y2$[ebp]
	sqrtsd	xmm1, xmm0
	mulss	xmm2, xmm2
	cvtps2pd xmm0, xmm4
	addss	xmm2, xmm3
	sqrtsd	xmm0, xmm0
	subss	xmm5, DWORD PTR _my$1$[ebp]
	addsd	xmm1, xmm0
	cvtps2pd xmm0, xmm2
	mulss	xmm5, xmm5
	sqrtsd	xmm0, xmm0
	addss	xmm5, xmm7

; 3025 :    float flatness_squared = longlen*longlen-shortlen*shortlen;
; 3026 : 
; 3027 :    if (n > 16) // 65536 segments on one curve better be enough!

	movss	xmm7, DWORD PTR __real@3f000000
	addsd	xmm1, xmm0
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm5
	cvtpd2ps xmm1, xmm1
	mulss	xmm0, xmm0
	mulss	xmm1, xmm1
	subss	xmm1, xmm0
	cmp	ebx, 16					; 00000010H
	jle	$LL6@stbtt__tes
	pop	edi
	pop	esi
	pop	ebx

; 3051 :    }
; 3052 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@stbtt__tes:

; 3048 :    } else {
; 3049 :       stbtt__add_point(points, *num_points,x3,y3);

	movss	xmm0, DWORD PTR _y3$[ebp]
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	movss	DWORD PTR [esp], xmm2
	push	DWORD PTR [esi]
	push	edi
	call	?stbtt__add_point@@YAXPAUstbtt__point@@HMM@Z ; stbtt__add_point
	add	esp, 16					; 00000010H

; 3050 :       *num_points = *num_points+1;

	inc	DWORD PTR [esi]
	pop	edi
	pop	esi
$LN4@stbtt__tes:
	pop	ebx

; 3051 :    }
; 3052 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?stbtt__tesselate_cubic@@YAXPAUstbtt__point@@PAHMMMMMMMMMH@Z ENDP ; stbtt__tesselate_cubic
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_mx$1$ = -20						; size = 4
_my$1$ = -16						; size = 4
tv210 = -12						; size = 4
tv204 = -8						; size = 4
tv203 = -4						; size = 4
_points$ = 8						; size = 4
_num_points$ = 12					; size = 4
_x0$ = 16						; size = 4
_y0$ = 20						; size = 4
_x1$ = 24						; size = 4
_y1$ = 28						; size = 4
_x2$ = 32						; size = 4
_y2$ = 36						; size = 4
_objspace_flatness_squared$ = 40			; size = 4
_n$ = 44						; size = 4
?stbtt__tesselate_curve@@YAHPAUstbtt__point@@PAHMMMMMMMH@Z PROC ; stbtt__tesselate_curve

; 2993 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2994 :    // midpoint
; 2995 :    float mx = (x0 + 2*x1 + x2)/4;

	movss	xmm1, DWORD PTR __real@3e800000
	movss	xmm0, DWORD PTR _x1$[ebp]
	movaps	xmm2, xmm0
	movss	xmm5, DWORD PTR _x2$[ebp]
	mulss	xmm0, xmm1
	push	ebx
	mulss	xmm2, xmm1

; 2996 :    float my = (y0 + 2*y1 + y2)/4;
; 2997 :    // versus directly drawn line
; 2998 :    float dx = (x0+x2)/2 - mx;
; 2999 :    float dy = (y0+y2)/2 - my;
; 3000 :    if (n > 16) // 65536 segments on one curve better be enough!

	mov	ebx, DWORD PTR _n$[ebp]
	movss	xmm6, DWORD PTR _y2$[ebp]
	movss	xmm4, DWORD PTR __real@3f000000
	movss	xmm7, DWORD PTR _x0$[ebp]
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR _x0$[ebp]
	mulss	xmm0, xmm1
	mulss	xmm7, xmm4
	addss	xmm2, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm1
	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR _y1$[ebp]
	movaps	xmm3, xmm0
	mulss	xmm0, xmm1
	mulss	xmm3, xmm1
	movss	DWORD PTR _mx$1$[ebp], xmm2
	addss	xmm3, xmm0
	movss	xmm0, DWORD PTR _y0$[ebp]
	mulss	xmm0, xmm1
	addss	xmm3, xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm1
	addss	xmm3, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm4
	movss	DWORD PTR tv210[ebp], xmm0
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR _y0$[ebp]
	addss	xmm1, xmm7
	mulss	xmm0, xmm4
	movss	DWORD PTR _my$1$[ebp], xmm3
	movss	DWORD PTR tv203[ebp], xmm0
	movaps	xmm0, xmm6
	mulss	xmm0, xmm4
	subss	xmm1, xmm2
	movss	DWORD PTR tv204[ebp], xmm0
	addss	xmm0, DWORD PTR tv203[ebp]
	subss	xmm0, xmm3
	cmp	ebx, 16					; 00000010H
	jg	$LN4@stbtt__tes

; 3001 :       return 1;
; 3002 :    if (dx*dx+dy*dy > objspace_flatness_squared) { // half-pixel error allowed... need to be smaller if AA

	mulss	xmm0, xmm0
	mulss	xmm1, xmm1
	addss	xmm0, xmm1
	comiss	xmm0, DWORD PTR _objspace_flatness_squared$[ebp]
	jbe	$LN3@stbtt__tes

; 3003 :       stbtt__tesselate_curve(points, num_points, x0,y0, (x0+x1)/2.0f,(y0+y1)/2.0f, mx,my, objspace_flatness_squared,n+1);

	movss	xmm0, DWORD PTR _y1$[ebp]
	inc	ebx
	movss	xmm1, DWORD PTR _x1$[ebp]
	mulss	xmm0, xmm4
	push	ebx
	sub	esp, 28					; 0000001cH
	mulss	xmm1, xmm4
	movss	xmm4, DWORD PTR _objspace_flatness_squared$[ebp]
	movss	DWORD PTR _y1$[ebp], xmm0
	addss	xmm0, DWORD PTR tv203[ebp]
	movss	DWORD PTR [esp+24], xmm4
	movss	DWORD PTR [esp+20], xmm3
	movss	DWORD PTR [esp+16], xmm2
	movss	DWORD PTR _x1$[ebp], xmm1
	movss	DWORD PTR [esp+12], xmm0
	movaps	xmm0, xmm1
	addss	xmm0, xmm7
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _y0$[ebp]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _x0$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _num_points$[ebp]
	push	DWORD PTR _points$[ebp]
	call	?stbtt__tesselate_curve@@YAHPAUstbtt__point@@PAHMMMMMMMH@Z ; stbtt__tesselate_curve

; 3004 :       stbtt__tesselate_curve(points, num_points, mx,my, (x1+x2)/2.0f,(y1+y2)/2.0f, x2,y2, objspace_flatness_squared,n+1);

	movss	xmm0, DWORD PTR _objspace_flatness_squared$[ebp]
	add	esp, 40					; 00000028H
	push	ebx
	sub	esp, 28					; 0000001cH
	movss	DWORD PTR [esp+24], xmm0
	movss	xmm0, DWORD PTR _y2$[ebp]
	movss	DWORD PTR [esp+20], xmm0
	movss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR [esp+16], xmm0
	movss	xmm0, DWORD PTR _y1$[ebp]
	addss	xmm0, DWORD PTR tv204[ebp]
	movss	DWORD PTR [esp+12], xmm0
	movss	xmm0, DWORD PTR _x1$[ebp]
	addss	xmm0, DWORD PTR tv210[ebp]
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _my$1$[ebp]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _mx$1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _num_points$[ebp]
	push	DWORD PTR _points$[ebp]
	call	?stbtt__tesselate_curve@@YAHPAUstbtt__point@@PAHMMMMMMMH@Z ; stbtt__tesselate_curve
	add	esp, 40					; 00000028H

; 3008 :    }
; 3009 :    return 1;

	mov	eax, 1
	pop	ebx

; 3010 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@stbtt__tes:

; 3005 :    } else {
; 3006 :       stbtt__add_point(points, *num_points,x2,y2);

	mov	edx, DWORD PTR _num_points$[ebp]
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm6
	movss	DWORD PTR [esp], xmm5
	push	DWORD PTR [edx]
	push	DWORD PTR _points$[ebp]
	call	?stbtt__add_point@@YAXPAUstbtt__point@@HMM@Z ; stbtt__add_point
	add	esp, 16					; 00000010H

; 3007 :       *num_points = *num_points+1;

	inc	DWORD PTR [edx]
$LN4@stbtt__tes:

; 3008 :    }
; 3009 :    return 1;

	mov	eax, 1
	pop	ebx

; 3010 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?stbtt__tesselate_curve@@YAHPAUstbtt__point@@PAHMMMMMMMH@Z ENDP ; stbtt__tesselate_curve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_points$ = 8						; size = 4
_n$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
?stbtt__add_point@@YAXPAUstbtt__point@@HMM@Z PROC	; stbtt__add_point

; 2985 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2986 :    if (!points) return; // during first pass, it's unallocated

	mov	ecx, DWORD PTR _points$[ebp]
	test	ecx, ecx
	je	SHORT $LN1@stbtt__add

; 2987 :    points[n].x = x;

	mov	eax, DWORD PTR _n$[ebp]
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [ecx+eax*8], xmm0

; 2988 :    points[n].y = y;

	movss	xmm0, DWORD PTR _y$[ebp]
	movss	DWORD PTR [ecx+eax*8+4], xmm0
$LN1@stbtt__add:

; 2989 : }

	pop	ebp
	ret	0
?stbtt__add_point@@YAXPAUstbtt__point@@HMM@Z ENDP	; stbtt__add_point
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_m$1$ = -28						; size = 4
_y_scale_inv$1$ = -24					; size = 4
_a$1$ = -20						; size = 4
_e$1$ = -16						; size = 4
_n$2$ = -12						; size = 4
tv851 = -8						; size = 4
_p$1$ = -4						; size = 4
_n$1$ = -4						; size = 4
_result$ = 8						; size = 4
_pts$ = 12						; size = 4
_wcount$ = 16						; size = 4
_windings$ = 20						; size = 4
_scale_x$ = 24						; size = 4
_scale_y$ = 28						; size = 4
_shift_x$ = 32						; size = 4
_shift_y$ = 36						; size = 4
_off_x$ = 40						; size = 4
_off_y$ = 44						; size = 4
_invert$ = 48						; size = 4
_userdata$ = 52						; size = 4
?stbtt__rasterize@@YAXPAUstbtt__bitmap@@PAUstbtt__point@@PAHHMMMMHHHPAX@Z PROC ; stbtt__rasterize

; 2928 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2929 :    float y_scale_inv = invert ? -scale_y : scale_y;

	movss	xmm0, DWORD PTR _scale_y$[ebp]
	sub	esp, 28					; 0000001cH
	cmp	DWORD PTR _invert$[ebp], 0
	je	SHORT $LN15@stbtt__ras
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
$LN15@stbtt__ras:

; 2930 :    stbtt__edge *e;
; 2931 :    int n,i,j,k,m;
; 2932 : #if STBTT_RASTERIZER_VERSION == 1
; 2933 :    int vsubsample = result->h < 8 ? 15 : 5;
; 2934 : #elif STBTT_RASTERIZER_VERSION == 2
; 2935 :    int vsubsample = 1;
; 2936 : #else
; 2937 :    #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
; 2938 : #endif
; 2939 :    // vsubsample should divide 255 evenly; otherwise we won't reach full opacity
; 2940 : 
; 2941 :    // now we have to blow out the windings into explicit edge lists
; 2942 :    n = 0;
; 2943 :    for (i=0; i < windings; ++i)

	mov	eax, DWORD PTR _windings$[ebp]
	xor	ecx, ecx
	movss	DWORD PTR _y_scale_inv$1$[ebp], xmm0
	mov	DWORD PTR _n$1$[ebp], 0
	push	esi
	push	edi
	test	eax, eax
	jle	SHORT $LN41@stbtt__ras
	cmp	eax, 8
	jb	SHORT $LN41@stbtt__ras
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN43@stbtt__ras
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN43@stbtt__ras:
	mov	edx, DWORD PTR _windings$[ebp]
	xorps	xmm2, xmm2
	mov	esi, DWORD PTR _wcount$[ebp]
	sub	edx, eax
	xorps	xmm1, xmm1
$LL4@stbtt__ras:
	movups	xmm0, XMMWORD PTR [esi+ecx*4]
	paddd	xmm2, xmm0
	movups	xmm0, XMMWORD PTR [esi+ecx*4+16]
	add	ecx, 8
	paddd	xmm1, xmm0
	cmp	ecx, edx
	jl	SHORT $LL4@stbtt__ras

; 2944 :       n += wcount[i];

	mov	eax, DWORD PTR _windings$[ebp]
	paddd	xmm1, xmm2
	movaps	xmm0, xmm1
	psrldq	xmm0, 8
	paddd	xmm1, xmm0
	movups	xmm0, xmm1
	psrldq	xmm0, 4
	paddd	xmm1, xmm0
	movd	DWORD PTR _n$1$[ebp], xmm1
	jmp	SHORT $LN26@stbtt__ras
$LN41@stbtt__ras:
	mov	esi, DWORD PTR _wcount$[ebp]
$LN26@stbtt__ras:
	xor	edx, edx
	xor	edi, edi
	cmp	ecx, eax
	jge	SHORT $LN42@stbtt__ras
	sub	eax, ecx

; 2930 :    stbtt__edge *e;
; 2931 :    int n,i,j,k,m;
; 2932 : #if STBTT_RASTERIZER_VERSION == 1
; 2933 :    int vsubsample = result->h < 8 ? 15 : 5;
; 2934 : #elif STBTT_RASTERIZER_VERSION == 2
; 2935 :    int vsubsample = 1;
; 2936 : #else
; 2937 :    #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
; 2938 : #endif
; 2939 :    // vsubsample should divide 255 evenly; otherwise we won't reach full opacity
; 2940 : 
; 2941 :    // now we have to blow out the windings into explicit edge lists
; 2942 :    n = 0;
; 2943 :    for (i=0; i < windings; ++i)

	cmp	eax, 2
	jl	SHORT $LC33@stbtt__ras
	mov	eax, DWORD PTR _windings$[ebp]
	dec	eax
$LL35@stbtt__ras:

; 2944 :       n += wcount[i];

	add	edx, DWORD PTR [esi+ecx*4]
	add	edi, DWORD PTR [esi+ecx*4+4]
	add	ecx, 2
	cmp	ecx, eax
	jl	SHORT $LL35@stbtt__ras
$LC33@stbtt__ras:

; 2930 :    stbtt__edge *e;
; 2931 :    int n,i,j,k,m;
; 2932 : #if STBTT_RASTERIZER_VERSION == 1
; 2933 :    int vsubsample = result->h < 8 ? 15 : 5;
; 2934 : #elif STBTT_RASTERIZER_VERSION == 2
; 2935 :    int vsubsample = 1;
; 2936 : #else
; 2937 :    #error "Unrecognized value of STBTT_RASTERIZER_VERSION"
; 2938 : #endif
; 2939 :    // vsubsample should divide 255 evenly; otherwise we won't reach full opacity
; 2940 : 
; 2941 :    // now we have to blow out the windings into explicit edge lists
; 2942 :    n = 0;
; 2943 :    for (i=0; i < windings; ++i)

	cmp	ecx, DWORD PTR _windings$[ebp]
	jge	SHORT $LN34@stbtt__ras

; 2944 :       n += wcount[i];

	mov	eax, DWORD PTR _n$1$[ebp]
	add	eax, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR _n$1$[ebp], eax
$LN34@stbtt__ras:
	mov	ecx, DWORD PTR _n$1$[ebp]
	lea	eax, DWORD PTR [edi+edx]
	add	ecx, eax
	jmp	SHORT $LN32@stbtt__ras
$LN42@stbtt__ras:
	mov	ecx, DWORD PTR _n$1$[ebp]
$LN32@stbtt__ras:

; 2945 : 
; 2946 :    e = (stbtt__edge *) STBTT_malloc(sizeof(*e) * (n+1), userdata); // add an extra one as a sentinel

	lea	ecx, DWORD PTR [ecx+1]
	lea	eax, DWORD PTR [ecx+ecx*4]
	shl	eax, 2
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	add	esp, 4
	mov	DWORD PTR _e$1$[ebp], eax

; 2947 :    if (e == 0) return;

	test	eax, eax
	je	$LN1@stbtt__ras

; 2948 :    n = 0;

	xor	edi, edi

; 2949 : 
; 2950 :    m=0;

	xor	ecx, ecx
	mov	DWORD PTR _n$2$[ebp], edi

; 2951 :    for (i=0; i < windings; ++i) {

	cmp	DWORD PTR _windings$[ebp], ecx
	jle	$LN6@stbtt__ras

; 2948 :    n = 0;

	movss	xmm2, DWORD PTR _shift_y$[ebp]
	movss	xmm3, DWORD PTR _shift_x$[ebp]
	movss	xmm4, DWORD PTR _scale_x$[ebp]
	npad	7
$LL7@stbtt__ras:

; 2952 :       stbtt__point *p = pts + m;

	mov	eax, DWORD PTR _pts$[ebp]

; 2953 :       m += wcount[i];
; 2954 :       j = wcount[i]-1;
; 2955 :       for (k=0; k < wcount[i]; j=k++) {

	xor	edx, edx
	lea	eax, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR _p$1$[ebp], eax
	mov	eax, DWORD PTR [esi]
	add	ecx, eax
	mov	DWORD PTR _m$1$[ebp], ecx
	lea	ecx, DWORD PTR [eax-1]
	test	eax, eax
	jle	$LN5@stbtt__ras

; 2952 :       stbtt__point *p = pts + m;

	mov	esi, DWORD PTR _e$1$[ebp]
	lea	eax, DWORD PTR [edi+edi*4]
	lea	esi, DWORD PTR [esi+eax*4]
	mov	eax, DWORD PTR _p$1$[ebp]
	add	esi, 16					; 00000010H
	lea	edi, DWORD PTR [eax+4]
	mov	DWORD PTR tv851[ebp], edi
$LL10@stbtt__ras:

; 2956 :          int a=k,b=j;
; 2957 :          // skip the edge if horizontal
; 2958 :          if (p[j].y == p[k].y)

	mov	edi, DWORD PTR tv851[ebp]
	movss	xmm0, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR _a$1$[ebp], edx
	ucomiss	xmm0, DWORD PTR [edi]
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN8@stbtt__ras

; 2959 :             continue;
; 2960 :          // add edge from j to k to the list
; 2961 :          e[n].invert = 0;
; 2962 :          if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {

	cmp	DWORD PTR _invert$[ebp], 0
	mov	DWORD PTR [esi], 0
	je	SHORT $LN17@stbtt__ras
	mov	eax, DWORD PTR _p$1$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx*8+4]
	xor	eax, eax
	comiss	xmm0, DWORD PTR [edi]
	jmp	SHORT $LN44@stbtt__ras
$LN17@stbtt__ras:
	movss	xmm0, DWORD PTR [edi]
	xor	eax, eax
	mov	edi, DWORD PTR _p$1$[ebp]
	comiss	xmm0, DWORD PTR [edi+ecx*8+4]
$LN44@stbtt__ras:
	seta	al
	test	eax, eax
	je	SHORT $LN13@stbtt__ras

; 2963 :             e[n].invert = 1;
; 2964 :             a=j,b=k;

	mov	DWORD PTR _a$1$[ebp], ecx
	mov	ecx, edx
	mov	DWORD PTR [esi], 1
$LN13@stbtt__ras:

; 2965 :          }
; 2966 :          e[n].x0 = p[a].x * scale_x + shift_x;

	mov	eax, DWORD PTR _p$1$[ebp]
	movaps	xmm0, xmm4
	mov	edi, DWORD PTR _a$1$[ebp]

; 2967 :          e[n].y0 = (p[a].y * y_scale_inv + shift_y) * vsubsample;
; 2968 :          e[n].x1 = p[b].x * scale_x + shift_x;
; 2969 :          e[n].y1 = (p[b].y * y_scale_inv + shift_y) * vsubsample;
; 2970 :          ++n;

	inc	DWORD PTR _n$2$[ebp]
	mulss	xmm0, DWORD PTR [eax+edi*8]
	addss	xmm0, xmm3
	movss	DWORD PTR [esi-16], xmm0
	movss	xmm0, DWORD PTR [eax+edi*8+4]
	mulss	xmm0, DWORD PTR _y_scale_inv$1$[ebp]
	mov	edi, DWORD PTR tv851[ebp]
	addss	xmm0, xmm2
	movss	DWORD PTR [esi-12], xmm0
	movss	xmm0, DWORD PTR [eax+ecx*8]
	mulss	xmm0, xmm4
	addss	xmm0, xmm3
	movss	DWORD PTR [esi-8], xmm0
	movss	xmm0, DWORD PTR [eax+ecx*8+4]
	mulss	xmm0, DWORD PTR _y_scale_inv$1$[ebp]
	addss	xmm0, xmm2
	movss	DWORD PTR [esi-4], xmm0
	add	esi, 20					; 00000014H
$LN8@stbtt__ras:

; 2953 :       m += wcount[i];
; 2954 :       j = wcount[i]-1;
; 2955 :       for (k=0; k < wcount[i]; j=k++) {

	mov	eax, DWORD PTR _wcount$[ebp]
	mov	ecx, edx
	inc	edx
	add	edi, 8
	mov	DWORD PTR tv851[ebp], edi
	cmp	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR _p$1$[ebp]
	jl	$LL10@stbtt__ras
	mov	esi, DWORD PTR _wcount$[ebp]
	mov	edi, DWORD PTR _n$2$[ebp]
$LN5@stbtt__ras:

; 2951 :    for (i=0; i < windings; ++i) {

	mov	ecx, DWORD PTR _m$1$[ebp]
	add	esi, 4
	sub	DWORD PTR _windings$[ebp], 1
	mov	DWORD PTR _wcount$[ebp], esi
	jne	$LL7@stbtt__ras
	mov	eax, DWORD PTR _e$1$[ebp]
$LN6@stbtt__ras:

; 2971 :       }
; 2972 :    }
; 2973 : 
; 2974 :    // now sort the edges by their highest point (should snap to integer, and then by x)
; 2975 :    //STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);
; 2976 :    stbtt__sort_edges(e, n);

	push	edi
	push	eax
	call	?stbtt__sort_edges@@YAXPAUstbtt__edge@@H@Z ; stbtt__sort_edges

; 2977 : 
; 2978 :    // now, traverse the scanlines and find the intersections on each scanline, use xor winding rule
; 2979 :    stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata);

	push	DWORD PTR _userdata$[ebp]
	mov	esi, DWORD PTR _e$1$[ebp]
	push	DWORD PTR _off_y$[ebp]
	push	DWORD PTR _off_x$[ebp]
	push	1
	push	edi
	push	esi
	push	DWORD PTR _result$[ebp]
	call	?stbtt__rasterize_sorted_edges@@YAXPAUstbtt__bitmap@@PAUstbtt__edge@@HHHHPAX@Z ; stbtt__rasterize_sorted_edges

; 2980 : 
; 2981 :    STBTT_free(e, userdata);

	push	esi
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 40					; 00000028H
$LN1@stbtt__ras:
	pop	edi
	pop	esi

; 2982 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?stbtt__rasterize@@YAXPAUstbtt__bitmap@@PAUstbtt__point@@PAHHMMMMHHHPAX@Z ENDP ; stbtt__rasterize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$ = 12						; size = 4
?stbtt__sort_edges@@YAXPAUstbtt__edge@@H@Z PROC		; stbtt__sort_edges

; 2917 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2918 :    stbtt__sort_edges_quicksort(p, n);

	push	DWORD PTR _n$[ebp]
	push	DWORD PTR _p$[ebp]
	call	?stbtt__sort_edges_quicksort@@YAXPAUstbtt__edge@@H@Z ; stbtt__sort_edges_quicksort
	add	esp, 8

; 2920 : }

	pop	ebp

; 2919 :    stbtt__sort_edges_ins_sort(p, n);

	jmp	?stbtt__sort_edges_ins_sort@@YAXPAUstbtt__edge@@H@Z ; stbtt__sort_edges_ins_sort
?stbtt__sort_edges@@YAXPAUstbtt__edge@@H@Z ENDP		; stbtt__sort_edges
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_p$ = 8							; size = 4
_n$ = 12						; size = 4
?stbtt__sort_edges_quicksort@@YAXPAUstbtt__edge@@H@Z PROC ; stbtt__sort_edges_quicksort

; 2855 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2856 :    /* threshhold for transitioning to insertion sort */
; 2857 :    while (n > 12) {

	mov	edx, DWORD PTR _n$[ebp]
	cmp	edx, 12					; 0000000cH
	jle	$LN3@stbtt__sor
	push	ebx
	push	esi
	mov	esi, DWORD PTR _p$[ebp]
	push	edi
$LL2@stbtt__sor:

; 2858 :       stbtt__edge t;
; 2859 :       int c01,c12,c,m,i,j;
; 2860 : 
; 2861 :       /* compute median of three */
; 2862 :       m = n >> 1;
; 2863 :       c01 = STBTT__COMPARE(&p[0],&p[m]);

	movss	xmm1, DWORD PTR [esi+4]
	mov	eax, edx
	sar	eax, 1

; 2864 :       c12 = STBTT__COMPARE(&p[m],&p[n-1]);

	xor	ebx, ebx
	lea	edi, DWORD PTR [eax+eax*4]
	movss	xmm0, DWORD PTR [esi+edi*4+4]
	lea	eax, DWORD PTR [edx+edx*4]
	movss	xmm2, DWORD PTR [esi+eax*4-16]
	comiss	xmm2, xmm0
	seta	bl
	xor	eax, eax
	comiss	xmm0, xmm1
	seta	al
	cmp	eax, ebx

; 2865 :       /* if 0 >= mid >= end, or 0 < mid < end, then use mid */
; 2866 :       if (c01 != c12) {

	je	SHORT $LN13@stbtt__sor

; 2867 :          /* otherwise, we'll need to swap something else to middle */
; 2868 :          int z;
; 2869 :          c = STBTT__COMPARE(&p[0],&p[n-1]);

	mov	eax, DWORD PTR _n$[ebp]
	xor	edx, edx

; 2870 :          /* 0>mid && mid<n:  0>n => n; 0<n => 0 */
; 2871 :          /* 0<mid && mid>n:  0>n => 0; 0<n => n */
; 2872 :          z = (c == c12) ? 0 : n-1;
; 2873 :          t = p[z];
; 2874 :          p[z] = p[m];

	movups	xmm0, XMMWORD PTR [esi+edi*4]
	comiss	xmm2, xmm1
	seta	dl
	dec	eax
	xor	ecx, ecx
	cmp	edx, ebx
	cmovne	ecx, eax
	lea	ecx, DWORD PTR [ecx+ecx*4]
	mov	edx, DWORD PTR [esi+ecx*4+16]
	movups	xmm1, XMMWORD PTR [esi+ecx*4]
	movups	XMMWORD PTR [esi+ecx*4], xmm0
	mov	eax, DWORD PTR [esi+edi*4+16]
	mov	DWORD PTR [esi+ecx*4+16], eax

; 2875 :          p[m] = t;

	movups	XMMWORD PTR [esi+edi*4], xmm1
	mov	DWORD PTR [esi+edi*4+16], edx
	mov	edx, DWORD PTR _n$[ebp]
$LN13@stbtt__sor:

; 2876 :       }
; 2877 :       /* now p[m] is the median-of-three */
; 2878 :       /* swap it to the beginning so it won't move around */
; 2879 :       t = p[0];
; 2880 :       p[0] = p[m];

	movups	xmm0, XMMWORD PTR [esi+edi*4]
	mov	ecx, DWORD PTR [esi+16]

; 2881 :       p[m] = t;
; 2882 : 
; 2883 :       /* partition loop */
; 2884 :       i=1;
; 2885 :       j=n-1;

	lea	ebx, DWORD PTR [edx-1]
	movups	xmm1, XMMWORD PTR [esi]
	movups	XMMWORD PTR [esi], xmm0
	mov	eax, DWORD PTR [esi+edi*4+16]
	mov	DWORD PTR [esi+16], eax
	movups	XMMWORD PTR [esi+edi*4], xmm1
	mov	DWORD PTR [esi+edi*4+16], ecx
	mov	edi, 1
	npad	13
$LL4@stbtt__sor:

; 2890 :             if (!STBTT__COMPARE(&p[i], &p[0])) break;

	movss	xmm1, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [edi*4+1]
	add	eax, edi
	comiss	xmm1, DWORD PTR [esi+eax*4]
	lea	eax, DWORD PTR [esi+eax*4]
	jbe	SHORT $LN28@stbtt__sor
$LL9@stbtt__sor:

; 2886 :       for(;;) {
; 2887 :          /* handling of equality is crucial here */
; 2888 :          /* for sentinels & efficiency with duplicates */
; 2889 :          for (;;++i) {

	lea	eax, DWORD PTR [eax+20]
	inc	edi

; 2890 :             if (!STBTT__COMPARE(&p[i], &p[0])) break;

	comiss	xmm1, DWORD PTR [eax]
	ja	SHORT $LL9@stbtt__sor
$LN28@stbtt__sor:

; 2891 :          }
; 2892 :          for (;;--j) {
; 2893 :             if (!STBTT__COMPARE(&p[0], &p[j])) break;

	lea	eax, DWORD PTR [ebx*4+1]
	add	eax, ebx
	movss	xmm0, DWORD PTR [esi+eax*4]
	lea	eax, DWORD PTR [esi+eax*4]
	comiss	xmm0, xmm1
	jbe	SHORT $LN29@stbtt__sor
$LL12@stbtt__sor:
	movss	xmm0, DWORD PTR [eax-20]
	lea	eax, DWORD PTR [eax-20]
	dec	ebx
	comiss	xmm0, xmm1
	ja	SHORT $LL12@stbtt__sor
$LN29@stbtt__sor:

; 2894 :          }
; 2895 :          /* make sure we haven't crossed */
; 2896 :          if (i >= j) break;

	cmp	edi, ebx
	jge	SHORT $LN30@stbtt__sor

; 2897 :          t = p[i];
; 2898 :          p[i] = p[j];

	mov	eax, DWORD PTR _p$[ebp]
	lea	ecx, DWORD PTR [ebx+ebx*4]
	lea	edx, DWORD PTR [edi+edi*4]

; 2899 :          p[j] = t;
; 2900 : 
; 2901 :          ++i;

	inc	edi
	movups	xmm1, XMMWORD PTR [esi+edx*4]
	mov	esi, DWORD PTR [esi+edx*4+16]
	movups	xmm0, XMMWORD PTR [eax+ecx*4]
	movups	XMMWORD PTR [eax+edx*4], xmm0
	mov	eax, DWORD PTR [eax+ecx*4+16]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx+edx*4+16], eax
	lea	ecx, DWORD PTR [ebx+ebx*4]
	mov	eax, DWORD PTR _p$[ebp]

; 2902 :          --j;

	dec	ebx
	movups	XMMWORD PTR [eax+ecx*4], xmm1
	mov	DWORD PTR [eax+ecx*4+16], esi
	mov	esi, eax
	jmp	SHORT $LL4@stbtt__sor
$LN30@stbtt__sor:

; 2903 :       }
; 2904 :       /* recurse on smaller side, iterate on larger */
; 2905 :       if (j < (n-i)) {

	mov	edx, DWORD PTR _n$[ebp]
	sub	edx, edi
	mov	DWORD PTR _n$[ebp], edx
	cmp	ebx, edx
	jge	SHORT $LN17@stbtt__sor

; 2906 :          stbtt__sort_edges_quicksort(p,j);

	push	ebx
	push	esi
	call	?stbtt__sort_edges_quicksort@@YAXPAUstbtt__edge@@H@Z ; stbtt__sort_edges_quicksort

; 2907 :          p = p+i;
; 2908 :          n = n-i;
; 2909 :       } else {

	mov	edx, DWORD PTR _n$[ebp]
	lea	eax, DWORD PTR [edi+edi*4]
	lea	esi, DWORD PTR [esi+eax*4]
	mov	DWORD PTR _p$[ebp], esi
	jmp	SHORT $LN41@stbtt__sor
$LN17@stbtt__sor:

; 2910 :          stbtt__sort_edges_quicksort(p+i, n-i);

	lea	eax, DWORD PTR [edi+edi*4]
	push	edx
	lea	eax, DWORD PTR [esi+eax*4]
	push	eax
	call	?stbtt__sort_edges_quicksort@@YAXPAUstbtt__edge@@H@Z ; stbtt__sort_edges_quicksort

; 2911 :          n = j;

	mov	edx, ebx
	mov	DWORD PTR _n$[ebp], ebx
$LN41@stbtt__sor:

; 2856 :    /* threshhold for transitioning to insertion sort */
; 2857 :    while (n > 12) {

	add	esp, 8
	cmp	edx, 12					; 0000000cH
	jg	$LL2@stbtt__sor
	pop	edi
	pop	esi
	pop	ebx
$LN3@stbtt__sor:

; 2912 :       }
; 2913 :    }
; 2914 : }

	pop	ebp
	ret	0
?stbtt__sort_edges_quicksort@@YAXPAUstbtt__edge@@H@Z ENDP ; stbtt__sort_edges_quicksort
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_t$1 = -20						; size = 20
_p$ = 8							; size = 4
_t$3$ = 12						; size = 4
_n$ = 12						; size = 4
?stbtt__sort_edges_ins_sort@@YAXPAUstbtt__edge@@H@Z PROC ; stbtt__sort_edges_ins_sort

; 2837 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	ebx

; 2838 :    int i,j;
; 2839 :    for (i=1; i < n; ++i) {

	mov	ebx, DWORD PTR _n$[ebp]
	push	esi
	mov	esi, 1
	cmp	ebx, esi
	jle	SHORT $LN3@stbtt__sor
	push	edi
	mov	edi, DWORD PTR _p$[ebp]
	add	edi, 20					; 00000014H
	npad	3
$LL4@stbtt__sor:

; 2840 :       stbtt__edge t = p[i], *a = &t;

	mov	eax, DWORD PTR [edi+16]

; 2841 :       j = i;

	mov	edx, esi
	mov	DWORD PTR _t$3$[ebp], eax
	movups	xmm2, XMMWORD PTR [edi]
	movups	XMMWORD PTR _t$1[ebp], xmm2

; 2842 :       while (j > 0) {

	test	esi, esi
	jle	SHORT $LN2@stbtt__sor

; 2843 :          stbtt__edge *b = &p[j-1];

	movss	xmm1, DWORD PTR _t$1[ebp+4]
	lea	ecx, DWORD PTR [edi-20]
	npad	5
$LL5@stbtt__sor:

; 2844 :          int c = STBTT__COMPARE(a,b);

	movss	xmm0, DWORD PTR [ecx+4]
	comiss	xmm0, xmm1

; 2845 :          if (!c) break;

	jbe	SHORT $LN12@stbtt__sor

; 2846 :          p[j] = p[j-1];

	movups	xmm0, XMMWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+16]

; 2847 :          --j;

	dec	edx
	movups	XMMWORD PTR [ecx+20], xmm0
	mov	DWORD PTR [ecx+36], eax
	sub	ecx, 20					; 00000014H
	test	edx, edx
	jg	SHORT $LL5@stbtt__sor
$LN12@stbtt__sor:

; 2848 :       }
; 2849 :       if (i != j)

	cmp	esi, edx
	je	SHORT $LN2@stbtt__sor

; 2850 :          p[j] = t;

	mov	ecx, DWORD PTR _p$[ebp]
	lea	eax, DWORD PTR [edx+edx*4]
	mov	edx, DWORD PTR _t$3$[ebp]
	movups	XMMWORD PTR [ecx+eax*4], xmm2
	mov	DWORD PTR [ecx+eax*4+16], edx
$LN2@stbtt__sor:

; 2838 :    int i,j;
; 2839 :    for (i=1; i < n; ++i) {

	inc	esi
	add	edi, 20					; 00000014H
	cmp	esi, ebx
	jl	SHORT $LL4@stbtt__sor
	pop	edi
$LN3@stbtt__sor:
	pop	esi
	pop	ebx

; 2851 :    }
; 2852 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?stbtt__sort_edges_ins_sort@@YAXPAUstbtt__edge@@H@Z ENDP ; stbtt__sort_edges_ins_sort
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_scanline_data$ = -548					; size = 516
_hh$ = -32						; size = 12
_scan_y_bottom$1$ = -20					; size = 4
_j$1$ = -16						; size = 4
_scanline2$1$ = -12					; size = 4
_scanline$1$ = -8					; size = 4
_active$ = -4						; size = 4
_result$ = 8						; size = 4
_e$ = 12						; size = 4
_scan_y_top$1$ = 16					; size = 4
tv443 = 16						; size = 4
_n$ = 16						; size = 4
_vsubsample$ = 20					; size = 4
_off_x$ = 24						; size = 4
_off_y$ = 28						; size = 4
_userdata$ = 32						; size = 4
?stbtt__rasterize_sorted_edges@@YAXPAUstbtt__bitmap@@PAUstbtt__edge@@HHHHPAX@Z PROC ; stbtt__rasterize_sorted_edges

; 2741 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 548				; 00000224H

; 2742 :    stbtt__hheap hh = { 0, 0, 0 };
; 2743 :    stbtt__active_edge *active = NULL;
; 2744 :    int y,j=0, i;
; 2745 :    float scanline_data[129], *scanline, *scanline2;
; 2746 : 
; 2747 :    STBTT__NOTUSED(vsubsample);
; 2748 : 
; 2749 :    if (result->w > 64)

	mov	edx, DWORD PTR _result$[ebp]
	push	esi
	push	edi
	xor	edi, edi
	mov	DWORD PTR _hh$[ebp], 0
	mov	eax, DWORD PTR [edx]
	xor	esi, esi
	mov	DWORD PTR _hh$[ebp+4], 0
	mov	DWORD PTR _hh$[ebp+8], 0
	mov	DWORD PTR _active$[ebp], edi
	mov	DWORD PTR _j$1$[ebp], esi
	cmp	eax, 64					; 00000040H
	jle	SHORT $LN13@stbtt__ras

; 2750 :       scanline = (float *) STBTT_malloc((result->w*2+1) * sizeof(float), userdata);

	lea	eax, DWORD PTR [eax*8+4]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 2751 :    else

	mov	edx, DWORD PTR _result$[ebp]
	add	esp, 4
	mov	ecx, eax
	mov	DWORD PTR _scanline$1$[ebp], eax
	jmp	SHORT $LN14@stbtt__ras
$LN13@stbtt__ras:

; 2752 :       scanline = scanline_data;

	lea	ecx, DWORD PTR _scanline_data$[ebp]
	mov	DWORD PTR _scanline$1$[ebp], ecx
$LN14@stbtt__ras:

; 2753 : 
; 2754 :    scanline2 = scanline + result->w;

	mov	eax, DWORD PTR [edx]

; 2755 : 
; 2756 :    y = off_y;
; 2757 :    e[n].y0 = (float) (off_y + result->h) + 1;

	movss	xmm1, DWORD PTR __real@3f800000
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR _e$[ebp]
	mov	DWORD PTR _scanline2$1$[ebp], eax
	mov	eax, DWORD PTR [edx+4]
	add	eax, DWORD PTR _off_y$[ebp]
	movd	xmm0, eax
	mov	eax, DWORD PTR _n$[ebp]
	cvtdq2ps xmm0, xmm0
	lea	eax, DWORD PTR [eax+eax*4]
	addss	xmm0, xmm1
	movss	DWORD PTR [ecx+eax*4+4], xmm0

; 2758 : 
; 2759 :    while (j < result->h) {

	cmp	DWORD PTR [edx+4], esi
	jle	$LN3@stbtt__ras
$LL2@stbtt__ras:

; 2760 :       // find center of pixel for this scanline
; 2761 :       float scan_y_top    = y + 0.0f;

	mov	eax, DWORD PTR _off_y$[ebp]
	add	eax, esi

; 2762 :       float scan_y_bottom = y + 1.0f;
; 2763 :       stbtt__active_edge **step = &active;

	lea	esi, DWORD PTR _active$[ebp]
	movd	xmm0, eax

; 2764 : 
; 2765 :       STBTT_memset(scanline , 0, result->w*sizeof(scanline[0]));

	mov	eax, DWORD PTR [edx]
	cvtdq2ps xmm0, xmm0
	shl	eax, 2
	push	eax
	push	0
	push	DWORD PTR _scanline$1$[ebp]
	movss	DWORD PTR _scan_y_top$1$[ebp], xmm0
	addss	xmm0, xmm1
	movss	DWORD PTR _scan_y_bottom$1$[ebp], xmm0
	call	_memset

; 2766 :       STBTT_memset(scanline2, 0, (result->w+1)*sizeof(scanline[0]));

	mov	eax, DWORD PTR _result$[ebp]
	mov	eax, DWORD PTR [eax]
	lea	eax, DWORD PTR [eax*4+4]
	push	eax
	push	0
	push	DWORD PTR _scanline2$1$[ebp]
	call	_memset
	movss	xmm1, DWORD PTR _scan_y_top$1$[ebp]
	add	esp, 24					; 00000018H

; 2767 : 
; 2768 :       // update all active edges;
; 2769 :       // remove all active edges that terminate before the top of this scanline
; 2770 :       while (*step) {

	test	edi, edi
	je	SHORT $LN25@stbtt__ras
$LL4@stbtt__ras:

; 2771 :          stbtt__active_edge * z = *step;

	mov	ecx, DWORD PTR [esi]

; 2772 :          if (z->ey <= scan_y_top) {

	comiss	xmm1, DWORD PTR [ecx+24]
	jb	SHORT $LN15@stbtt__ras

; 2773 :             *step = z->next; // delete from list

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi], eax

; 2774 :             STBTT_assert(z->direction);
; 2775 :             z->direction = 0;
; 2776 :             stbtt__hheap_free(&hh, z);

	lea	eax, DWORD PTR _hh$[ebp]
	push	ecx
	push	eax
	mov	DWORD PTR [ecx+16], 0
	call	?stbtt__hheap_free@@YAXPAUstbtt__hheap@@PAX@Z ; stbtt__hheap_free
	add	esp, 8

; 2777 :          } else {

	jmp	SHORT $LN16@stbtt__ras
$LN15@stbtt__ras:

; 2778 :             step = &((*step)->next); // advance through list

	mov	esi, ecx
$LN16@stbtt__ras:

; 2767 : 
; 2768 :       // update all active edges;
; 2769 :       // remove all active edges that terminate before the top of this scanline
; 2770 :       while (*step) {

	cmp	DWORD PTR [esi], 0
	jne	SHORT $LL4@stbtt__ras
	mov	edi, DWORD PTR _active$[ebp]
$LN25@stbtt__ras:

; 2779 :          }
; 2780 :       }
; 2781 : 
; 2782 :       // insert all edges that start before the bottom of this scanline
; 2783 :       while (e->y0 <= scan_y_bottom) {

	mov	esi, DWORD PTR _e$[ebp]
	movss	xmm2, DWORD PTR _scan_y_bottom$1$[ebp]
	movss	xmm0, DWORD PTR [esi+4]
	comiss	xmm2, xmm0
	jb	SHORT $LN7@stbtt__ras
$LL6@stbtt__ras:

; 2784 :          if (e->y0 != e->y1) {

	ucomiss	xmm0, DWORD PTR [esi+12]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN18@stbtt__ras

; 2785 :             stbtt__active_edge *z = stbtt__new_active(&hh, e, off_x, scan_y_top, userdata);

	push	DWORD PTR _userdata$[ebp]
	lea	eax, DWORD PTR _hh$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm1
	push	DWORD PTR _off_x$[ebp]
	push	esi
	push	eax
	call	?stbtt__new_active@@YAPAUstbtt__active_edge@@PAUstbtt__hheap@@PAUstbtt__edge@@HMPAX@Z ; stbtt__new_active
	add	esp, 20					; 00000014H

; 2786 :             if (z != NULL) {

	test	eax, eax
	je	SHORT $LN18@stbtt__ras

; 2787 :                STBTT_assert(z->ey >= scan_y_top);
; 2788 :                // insert at front
; 2789 :                z->next = active;

	mov	DWORD PTR [eax], edi

; 2790 :                active = z;

	mov	edi, eax
$LN18@stbtt__ras:

; 2791 :             }
; 2792 :          }
; 2793 :          ++e;

	movss	xmm1, DWORD PTR _scan_y_bottom$1$[ebp]
	add	esi, 20					; 00000014H
	movss	xmm0, DWORD PTR [esi+4]
	comiss	xmm1, xmm0
	movss	xmm1, DWORD PTR _scan_y_top$1$[ebp]
	jae	SHORT $LL6@stbtt__ras

; 2790 :                active = z;

	mov	DWORD PTR _active$[ebp], edi
	mov	DWORD PTR _e$[ebp], esi
$LN7@stbtt__ras:

; 2794 :       }
; 2795 : 
; 2796 :       // now process all active edges
; 2797 :       if (active)

	test	edi, edi
	je	SHORT $LN19@stbtt__ras

; 2798 :          stbtt__fill_active_edges_new(scanline, scanline2+1, result->w, active, scan_y_top);

	movss	xmm0, DWORD PTR _scan_y_top$1$[ebp]
	mov	eax, DWORD PTR _result$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	edi
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR _scanline2$1$[ebp]
	add	eax, 4
	push	eax
	push	DWORD PTR _scanline$1$[ebp]
	call	?stbtt__fill_active_edges_new@@YAXPAM0HPAUstbtt__active_edge@@M@Z ; stbtt__fill_active_edges_new
	add	esp, 20					; 00000014H
$LN19@stbtt__ras:

; 2799 : 
; 2800 :       {
; 2801 :          float sum = 0;
; 2802 :          for (i=0; i < result->w; ++i) {

	mov	edx, DWORD PTR _result$[ebp]
	xor	esi, esi
	xorps	xmm1, xmm1
	cmp	DWORD PTR [edx], esi
	jle	SHORT $LN9@stbtt__ras
	mov	eax, DWORD PTR _scanline2$1$[ebp]
	mov	edi, DWORD PTR _scanline$1$[ebp]
	sub	eax, edi
	movss	xmm2, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
	movss	xmm3, DWORD PTR __real@437f0000
	movss	xmm4, DWORD PTR __real@3f000000
	mov	DWORD PTR tv443[ebp], eax
	npad	2
$LL10@stbtt__ras:

; 2803 :             float k;
; 2804 :             int m;
; 2805 :             sum += scanline2[i];

	addss	xmm1, DWORD PTR [eax+edi]

; 2806 :             k = scanline[i] + sum;
; 2807 :             k = (float) STBTT_fabs(k)*255 + 0.5f;
; 2808 :             m = (int) k;
; 2809 :             if (m > 255) m = 255;

	mov	eax, 255				; 000000ffH
	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR [edi]
	andps	xmm0, xmm2
	mulss	xmm0, xmm3
	addss	xmm0, xmm4
	cvttss2si edx, xmm0
	cmp	edx, 255				; 000000ffH
	cmovg	edx, eax

; 2810 :             result->pixels[j*result->stride + i] = (unsigned char) m;

	mov	eax, DWORD PTR _result$[ebp]
	add	edi, 4
	mov	ecx, DWORD PTR [eax+8]
	imul	ecx, DWORD PTR _j$1$[ebp]
	mov	eax, DWORD PTR [eax+12]
	add	ecx, esi
	inc	esi
	mov	BYTE PTR [ecx+eax], dl
	mov	edx, DWORD PTR _result$[ebp]
	mov	eax, DWORD PTR tv443[ebp]
	cmp	esi, DWORD PTR [edx]
	jl	SHORT $LL10@stbtt__ras
	mov	edi, DWORD PTR _active$[ebp]
$LN9@stbtt__ras:

; 2811 :          }
; 2812 :       }
; 2813 :       // advance all the edges
; 2814 :       step = &active;

	lea	ecx, DWORD PTR _active$[ebp]

; 2815 :       while (*step) {

	test	edi, edi
	je	SHORT $LN12@stbtt__ras
	mov	eax, edi
	npad	11
$LL11@stbtt__ras:

; 2816 :          stbtt__active_edge *z = *step;
; 2817 :          z->fx += z->fdx; // advance to position for current scanline

	movss	xmm0, DWORD PTR [eax+8]
	addss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [eax+4], xmm0

; 2818 :          step = &((*step)->next); // advance through list

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jne	SHORT $LL11@stbtt__ras
$LN12@stbtt__ras:

; 2819 :       }
; 2820 : 
; 2821 :       ++y;
; 2822 :       ++j;

	mov	esi, DWORD PTR _j$1$[ebp]
	movss	xmm1, DWORD PTR __real@3f800000
	inc	esi
	mov	DWORD PTR _j$1$[ebp], esi
	cmp	esi, DWORD PTR [edx+4]
	jl	$LL2@stbtt__ras
$LN3@stbtt__ras:

; 2823 :    }
; 2824 : 
; 2825 :    stbtt__hheap_cleanup(&hh, userdata);

	push	DWORD PTR _userdata$[ebp]
	lea	eax, DWORD PTR _hh$[ebp]
	push	eax
	call	?stbtt__hheap_cleanup@@YAXPAUstbtt__hheap@@PAX@Z ; stbtt__hheap_cleanup

; 2826 : 
; 2827 :    if (scanline != scanline_data)

	mov	eax, DWORD PTR _scanline$1$[ebp]
	lea	ecx, DWORD PTR _scanline_data$[ebp]
	add	esp, 8
	pop	edi
	pop	esi
	cmp	eax, ecx
	je	SHORT $LN21@stbtt__ras

; 2828 :       STBTT_free(scanline, userdata);

	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN21@stbtt__ras:

; 2829 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?stbtt__rasterize_sorted_edges@@YAXPAUstbtt__bitmap@@PAUstbtt__edge@@HHHHPAX@Z ENDP ; stbtt__rasterize_sorted_edges
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_y_crossing$1$ = -28					; size = 4
_x0$1$ = -28						; size = 4
_x1$1$ = -24						; size = 4
tv994 = -20						; size = 4
_x2$1$ = -20						; size = 4
_y2$1$ = -16						; size = 4
_sign$1$ = -16						; size = 4
_y1$1$ = -12						; size = 4
_dy$1$ = -12						; size = 4
_sy0$1$ = -8						; size = 4
tv1000 = -8						; size = 4
_y_bottom$1$ = -4					; size = 4
_scanline$ = 8						; size = 4
_scanline_fill$ = 12					; size = 4
_len$ = 16						; size = 4
_step$1$ = 20						; size = 4
_xb$1$ = 20						; size = 4
_x0$1$ = 20						; size = 4
_e$ = 20						; size = 4
_y_top$ = 24						; size = 4
?stbtt__fill_active_edges_new@@YAXPAM0HPAUstbtt__active_edge@@M@Z PROC ; stbtt__fill_active_edges_new

; 2578 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 2579 :    float y_bottom = y_top+1;

	movss	xmm6, DWORD PTR _y_top$[ebp]
	movaps	xmm7, xmm6
	addss	xmm7, DWORD PTR __real@3f800000
	push	edi

; 2580 : 
; 2581 :    while (e) {

	mov	edi, DWORD PTR _e$[ebp]
	movss	DWORD PTR _y_bottom$1$[ebp], xmm7
	test	edi, edi
	je	$LN3@stbtt__fil
	mov	ecx, DWORD PTR _len$[ebp]
	xorps	xmm3, xmm3
	push	esi
$LL2@stbtt__fil:

; 2582 :       // brute force every pixel
; 2583 : 
; 2584 :       // compute intersection points with top & bottom
; 2585 :       STBTT_assert(e->ey >= y_top);
; 2586 : 
; 2587 :       if (e->fdx == 0) {

	movss	xmm2, DWORD PTR [edi+8]
	ucomiss	xmm2, xmm3
	lahf
	test	ah, 68					; 00000044H
	jp	$LN10@stbtt__fil

; 2588 :          float x0 = e->fx;

	movss	xmm1, DWORD PTR [edi+4]
	movd	xmm0, ecx

; 2589 :          if (x0 < len) {

	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR _x0$1$[ebp], xmm1
	comiss	xmm0, xmm1
	jbe	$LN8@stbtt__fil

; 2590 :             if (x0 >= 0) {
; 2591 :                stbtt__handle_clipped_edge(scanline,(int) x0,e, x0,y_top, x0,y_bottom);

	sub	esp, 16					; 00000010H
	comiss	xmm1, xmm3
	movss	DWORD PTR [esp+12], xmm7
	movss	DWORD PTR [esp+8], xmm1
	movss	DWORD PTR [esp+4], xmm6
	movss	DWORD PTR [esp], xmm1
	push	edi
	jb	SHORT $LN13@stbtt__fil
	cvttss2si esi, xmm1
	push	esi
	push	DWORD PTR _scanline$[ebp]
	call	?stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 2592 :                stbtt__handle_clipped_edge(scanline_fill-1,(int) x0+1,e, x0,y_top, x0,y_bottom);

	movss	xmm0, DWORD PTR _y_bottom$1$[ebp]
	lea	eax, DWORD PTR [esi+1]
	movss	xmm1, DWORD PTR _x0$1$[ebp]
	add	esp, 12					; 0000000cH
	movss	DWORD PTR [esp+12], xmm0
	movss	xmm0, DWORD PTR _y_top$[ebp]
	movss	DWORD PTR [esp+8], xmm1
	movss	DWORD PTR [esp+4], xmm0
	movss	DWORD PTR [esp], xmm1
	push	edi
	push	eax
	mov	eax, DWORD PTR _scanline_fill$[ebp]
	add	eax, -4					; fffffffcH
	push	eax
	call	?stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 2593 :             } else {

	movss	xmm7, DWORD PTR _y_bottom$1$[ebp]
	add	esp, 28					; 0000001cH
	mov	ecx, DWORD PTR _len$[ebp]
	jmp	$LN60@stbtt__fil
$LN13@stbtt__fil:

; 2594 :                stbtt__handle_clipped_edge(scanline_fill-1,0,e, x0,y_top, x0,y_bottom);

	mov	eax, DWORD PTR _scanline_fill$[ebp]
	add	eax, -4					; fffffffcH
	push	0
	push	eax
	call	?stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 2595 :             }
; 2596 :          }
; 2597 :       } else {

	movss	xmm7, DWORD PTR _y_bottom$1$[ebp]
	add	esp, 28					; 0000001cH
	mov	ecx, DWORD PTR _len$[ebp]
	jmp	$LN60@stbtt__fil
$LN10@stbtt__fil:

; 2598 :          float x0 = e->fx;

	movss	xmm0, DWORD PTR [edi+4]

; 2599 :          float dx = e->fdx;
; 2600 :          float xb = x0 + dx;

	movaps	xmm3, xmm2

; 2601 :          float x_top, x_bottom;
; 2602 :          float sy0,sy1;
; 2603 :          float dy = e->fdy;
; 2604 :          STBTT_assert(e->sy <= y_bottom && e->ey >= y_top);
; 2605 : 
; 2606 :          // compute endpoints of line segment clipped to this scanline (if the
; 2607 :          // line segment starts on this scanline. x0 is the intersection of the
; 2608 :          // line with y_top, but that may be off the line segment.
; 2609 :          if (e->sy > y_top) {

	movss	xmm4, DWORD PTR [edi+20]
	addss	xmm3, xmm0
	comiss	xmm4, xmm6
	movss	xmm1, DWORD PTR [edi+12]
	movss	DWORD PTR _x0$1$[ebp], xmm0
	movss	DWORD PTR _xb$1$[ebp], xmm3
	movss	DWORD PTR _dy$1$[ebp], xmm1
	movss	DWORD PTR _sy0$1$[ebp], xmm4
	jbe	SHORT $LN15@stbtt__fil

; 2610 :             x_top = x0 + dx * (e->sy - y_top);

	movaps	xmm1, xmm4
	subss	xmm1, xmm6
	mulss	xmm1, xmm2
	addss	xmm1, xmm0

; 2611 :             sy0 = e->sy;
; 2612 :          } else {

	jmp	SHORT $LN16@stbtt__fil
$LN15@stbtt__fil:

; 2613 :             x_top = x0;

	movaps	xmm1, xmm0

; 2614 :             sy0 = y_top;

	movss	DWORD PTR _sy0$1$[ebp], xmm6
$LN16@stbtt__fil:

; 2615 :          }
; 2616 :          if (e->ey < y_bottom) {

	movss	xmm5, DWORD PTR [edi+24]
	comiss	xmm7, xmm5
	jbe	SHORT $LN17@stbtt__fil

; 2617 :             x_bottom = x0 + dx * (e->ey - y_top);

	movaps	xmm4, xmm5
	subss	xmm4, xmm6
	mulss	xmm4, xmm2
	addss	xmm4, xmm0

; 2618 :             sy1 = e->ey;
; 2619 :          } else {

	jmp	SHORT $LN18@stbtt__fil
$LN17@stbtt__fil:

; 2620 :             x_bottom = xb;

	movaps	xmm4, xmm3

; 2621 :             sy1 = y_bottom;

	movaps	xmm5, xmm7
$LN18@stbtt__fil:

; 2622 :          }
; 2623 : 
; 2624 :          if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {

	comiss	xmm1, DWORD PTR __real@00000000
	jb	$LN19@stbtt__fil
	comiss	xmm4, DWORD PTR __real@00000000
	jb	$LN19@stbtt__fil
	movd	xmm6, DWORD PTR _len$[ebp]
	cvtdq2ps xmm6, xmm6
	comiss	xmm6, xmm1
	movss	xmm6, DWORD PTR _y_top$[ebp]
	jbe	$LN19@stbtt__fil
	movd	xmm7, DWORD PTR _len$[ebp]
	cvtdq2ps xmm7, xmm7
	comiss	xmm7, xmm4
	movss	xmm7, DWORD PTR _y_bottom$1$[ebp]
	jbe	$LN19@stbtt__fil

; 2625 :             // from here on, we don't have to range check x values
; 2626 : 
; 2627 :             if ((int) x_top == (int) x_bottom) {

	cvttss2si ecx, xmm1
	cvttss2si eax, xmm4
	cmp	ecx, eax
	jne	SHORT $LN21@stbtt__fil

; 2628 :                float height;
; 2629 :                // simple case, only spans one pixel
; 2630 :                int x = (int) x_top;
; 2631 :                height = sy1 - sy0;

	subss	xmm5, DWORD PTR _sy0$1$[ebp]
	movd	xmm0, ecx

; 2632 :                STBTT_assert(x >= 0 && x < len);
; 2633 :                scanline[x] += e->direction * (1-((x_top - x) + (x_bottom-x))/2)  * height;

	cvtdq2ps xmm0, xmm0
	mov	eax, DWORD PTR _scanline$[ebp]
	subss	xmm4, xmm0
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	addss	xmm4, xmm1
	mulss	xmm4, DWORD PTR __real@3f000000
	subss	xmm0, xmm4
	mulss	xmm0, DWORD PTR [edi+16]
	mulss	xmm0, xmm5
	addss	xmm0, DWORD PTR [eax+ecx*4]
	movss	DWORD PTR [eax+ecx*4], xmm0

; 2634 :                scanline_fill[x] += e->direction * height; // everything right of this pixel is filled

	mulss	xmm5, DWORD PTR [edi+16]
	mov	eax, DWORD PTR _scanline_fill$[ebp]
	addss	xmm5, DWORD PTR [eax+ecx*4]
	movss	DWORD PTR [eax+ecx*4], xmm5

; 2635 :             } else {

	mov	ecx, DWORD PTR _len$[ebp]
	jmp	$LN56@stbtt__fil
$LN21@stbtt__fil:

; 2636 :                int x,x1,x2;
; 2637 :                float y_crossing, step, sign, area;
; 2638 :                // covers 2+ pixels
; 2639 :                if (x_top > x_bottom) {

	comiss	xmm1, xmm4

; 2640 :                   // flip scanline vertically; signed area is the same
; 2641 :                   float t;
; 2642 :                   sy0 = y_bottom - (sy0 - y_top);

	movss	xmm2, DWORD PTR _sy0$1$[ebp]
	jbe	SHORT $LN23@stbtt__fil
	subss	xmm2, xmm6
	movaps	xmm0, xmm7

; 2643 :                   sy1 = y_bottom - (sy1 - y_top);

	subss	xmm5, xmm6
	subss	xmm0, xmm2
	movaps	xmm2, xmm7
	subss	xmm2, xmm5

; 2644 :                   t = sy0, sy0 = sy1, sy1 = t;

	movaps	xmm5, xmm0

; 2645 :                   t = x_bottom, x_bottom = x_top, x_top = t;

	movaps	xmm0, xmm4
	movaps	xmm4, xmm1
	movss	DWORD PTR _sy0$1$[ebp], xmm2
	movaps	xmm1, xmm0

; 2646 :                   dx = -dx;
; 2647 :                   dy = -dy;

	movss	xmm0, DWORD PTR _dy$1$[ebp]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR _dy$1$[ebp], xmm0

; 2648 :                   t = x0, x0 = xb, xb = t;

	movaps	xmm0, xmm3
$LN23@stbtt__fil:

; 2649 :                }
; 2650 : 
; 2651 :                x1 = (int) x_top;

	cvttss2si eax, xmm1

; 2652 :                x2 = (int) x_bottom;
; 2653 :                // compute intersection with y axis at x1+1
; 2654 :                y_crossing = (x1+1 - x0) * dy + y_top;
; 2655 : 
; 2656 :                sign = e->direction;
; 2657 :                // area of the rectangle covered from y0..y_crossing
; 2658 :                area = sign * (y_crossing-sy0);
; 2659 :                // area of the triangle (x_top,y0), (x+1,y0), (x+1,y_crossing)
; 2660 :                scanline[x1] += area * (1-((x_top - x1)+(x1+1-x1))/2);

	mov	ecx, DWORD PTR _scanline$[ebp]
	cvttss2si esi, xmm4
	mov	DWORD PTR _x1$1$[ebp], eax
	lea	edx, DWORD PTR [eax+1]
	movd	xmm3, edx
	mov	DWORD PTR _x2$1$[ebp], esi
	cvtdq2ps xmm3, xmm3
	subss	xmm3, xmm0
	movss	xmm0, DWORD PTR [edi+16]
	movss	DWORD PTR _sign$1$[ebp], xmm0
	mulss	xmm3, DWORD PTR _dy$1$[ebp]
	addss	xmm3, xmm6
	movss	DWORD PTR _y_crossing$1$[ebp], xmm3
	subss	xmm3, xmm2
	movss	xmm2, DWORD PTR __real@3f000000
	mulss	xmm3, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	subss	xmm1, xmm0
	movaps	xmm0, xmm2
	mulss	xmm1, xmm2
	subss	xmm0, xmm1

; 2661 : 
; 2662 :                step = sign * dy;

	movss	xmm1, DWORD PTR _sign$1$[ebp]
	mulss	xmm1, DWORD PTR _dy$1$[ebp]
	mulss	xmm0, xmm3
	movss	DWORD PTR _step$1$[ebp], xmm1
	addss	xmm0, DWORD PTR [ecx+eax*4]
	movss	DWORD PTR [ecx+eax*4], xmm0
	cmp	edx, esi
	jge	$LN48@stbtt__fil

; 2663 :                for (x = x1+1; x < x2; ++x) {

	mov	eax, esi
	sub	eax, edx
	cmp	eax, 4
	jl	$LC49@stbtt__fil
	sub	esi, edx
	lea	eax, DWORD PTR [ecx+8]
	sub	esi, 4
	lea	eax, DWORD PTR [eax+edx*4]
	shr	esi, 2
	movaps	xmm7, xmm1
	inc	esi
	movaps	xmm6, xmm7
	mulss	xmm6, xmm2
	lea	edx, DWORD PTR [edx+esi*4]
	npad	8
$LL50@stbtt__fil:

; 2664 :                   scanline[x] += area + step/2;

	movaps	xmm0, xmm6

; 2665 :                   area += step;

	movaps	xmm2, xmm7
	addss	xmm0, xmm3
	movaps	xmm1, xmm7
	addss	xmm2, xmm3
	movaps	xmm3, xmm7
	addss	xmm0, DWORD PTR [eax-8]
	addss	xmm1, xmm2
	movss	DWORD PTR [eax-8], xmm0
	movaps	xmm0, xmm6
	addss	xmm0, xmm2
	movaps	xmm2, xmm7
	addss	xmm2, xmm1
	addss	xmm0, DWORD PTR [eax-4]
	addss	xmm3, xmm2
	movss	DWORD PTR [eax-4], xmm0
	movaps	xmm0, xmm6
	addss	xmm0, xmm1
	addss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [eax], xmm0
	movaps	xmm0, xmm6
	addss	xmm0, xmm2
	addss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [eax+4], xmm0
	add	eax, 16					; 00000010H
	sub	esi, 1
	jne	SHORT $LL50@stbtt__fil
	movss	xmm6, DWORD PTR _y_top$[ebp]
	movss	xmm7, DWORD PTR _y_bottom$1$[ebp]
	movss	xmm1, DWORD PTR _step$1$[ebp]
	mov	esi, DWORD PTR _x2$1$[ebp]
$LC49@stbtt__fil:

; 2663 :                for (x = x1+1; x < x2; ++x) {

	cmp	edx, esi
	jge	SHORT $LN48@stbtt__fil
	movaps	xmm2, xmm1
	mulss	xmm2, DWORD PTR __real@3f000000
	npad	9
$LC43@stbtt__fil:

; 2664 :                   scanline[x] += area + step/2;

	movaps	xmm0, xmm2
	addss	xmm0, xmm3
	addss	xmm0, DWORD PTR [ecx+edx*4]
	movss	DWORD PTR [ecx+edx*4], xmm0
	inc	edx

; 2665 :                   area += step;

	movaps	xmm0, xmm1
	addss	xmm3, xmm0
	cmp	edx, esi
	jl	SHORT $LC43@stbtt__fil
$LN48@stbtt__fil:

; 2666 :                }
; 2667 :                y_crossing += dy * (x2 - (x1+1));
; 2668 : 
; 2669 :                STBTT_assert(STBTT_fabs(area) <= 1.01f);
; 2670 : 
; 2671 :                scanline[x2] += area + sign * (1-((x2-x2)+(x_bottom-x2))/2) * (sy1-y_crossing);

	mov	eax, esi
	movaps	xmm1, xmm5
	sub	eax, DWORD PTR _x1$1$[ebp]
	dec	eax

; 2672 : 
; 2673 :                scanline_fill[x2] += sign * (sy1-sy0);

	subss	xmm5, DWORD PTR _sy0$1$[ebp]
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mov	eax, DWORD PTR _scanline_fill$[ebp]
	mulss	xmm5, DWORD PTR _sign$1$[ebp]
	mulss	xmm0, DWORD PTR _dy$1$[ebp]
	addss	xmm0, DWORD PTR _y_crossing$1$[ebp]
	subss	xmm1, xmm0
	movd	xmm0, esi
	cvtdq2ps xmm0, xmm0
	subss	xmm4, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm4, DWORD PTR __real@3f000000
	subss	xmm0, xmm4
	mulss	xmm0, DWORD PTR _sign$1$[ebp]
	mulss	xmm1, xmm0
	addss	xmm1, xmm3
	addss	xmm1, DWORD PTR [ecx+esi*4]
	movss	DWORD PTR [ecx+esi*4], xmm1
	addss	xmm5, DWORD PTR [eax+esi*4]

; 2674 :             }
; 2675 :          } else {

	mov	ecx, DWORD PTR _len$[ebp]
	movss	DWORD PTR [eax+esi*4], xmm5
	jmp	$LN56@stbtt__fil
$LN19@stbtt__fil:

; 2676 :             // if edge goes outside of box we're drawing, we require
; 2677 :             // clipping logic. since this does not match the intended use
; 2678 :             // of this library, we use a different, very slow brute
; 2679 :             // force implementation
; 2680 :             int x;
; 2681 :             for (x=0; x < len; ++x) {

	xor	esi, esi
	test	ecx, ecx
	jle	$LN56@stbtt__fil
	movss	xmm5, DWORD PTR __real@3f800000
	divss	xmm5, xmm2
	movss	DWORD PTR tv994[ebp], xmm5
	npad	5
$LL9@stbtt__fil:
	movd	xmm2, esi

; 2682 :                // cases:
; 2683 :                //
; 2684 :                // there can be up to two intersections with the pixel. any intersection
; 2685 :                // with left or right edges can be handled by splitting into two (or three)
; 2686 :                // regions. intersections with top & bottom do not necessitate case-wise logic.
; 2687 :                //
; 2688 :                // the old way of doing this found the intersections with the left & right edges,
; 2689 :                // then used some simple logic to produce up to three segments in sorted order
; 2690 :                // from top-to-bottom. however, this had a problem: if an x edge was epsilon
; 2691 :                // across the x border, then the corresponding y position might not be distinct
; 2692 :                // from the other y segment, and it might ignored as an empty segment. to avoid
; 2693 :                // that, we need to explicitly produce segments based on x positions.
; 2694 : 
; 2695 :                // rename variables to clear pairs
; 2696 :                float y0 = y_top;
; 2697 :                float x1 = (float) (x);
; 2698 :                float x2 = (float) (x+1);

	lea	eax, DWORD PTR [esi+1]
	cvtdq2ps xmm2, xmm2
	mov	DWORD PTR tv1000[ebp], eax
	movd	xmm1, eax

; 2699 :                float x3 = xb;
; 2700 :                float y3 = y_bottom;
; 2701 :                float y1,y2;
; 2702 : 
; 2703 :                // x = e->x + e->dx * (y-y_top)
; 2704 :                // (y-y_top) = (x - e->x) / e->dx
; 2705 :                // y = (x - e->x) / e->dx + y_top
; 2706 :                y1 = (x - x0) / dx + y_top;
; 2707 :                y2 = (x+1 - x0) / dx + y_top;
; 2708 : 
; 2709 :                if (x0 < x1 && x3 > x2) {         // three segments descending down-right

	comiss	xmm2, xmm0
	movaps	xmm4, xmm2
	subss	xmm4, xmm0
	cvtdq2ps xmm1, xmm1
	mulss	xmm4, xmm5
	movaps	xmm5, xmm1
	subss	xmm5, xmm0
	addss	xmm4, xmm6
	mulss	xmm5, DWORD PTR tv994[ebp]
	movss	DWORD PTR _y1$1$[ebp], xmm4
	addss	xmm5, xmm6
	movss	DWORD PTR _y2$1$[ebp], xmm5
	jbe	$LN24@stbtt__fil
	comiss	xmm3, xmm1
	jbe	$LN24@stbtt__fil

; 2710 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);

	sub	esp, 16					; 00000010H
	movss	DWORD PTR [esp+12], xmm4
	movss	DWORD PTR [esp+8], xmm2
	movss	DWORD PTR [esp+4], xmm6
	movss	DWORD PTR [esp], xmm0
	push	edi
	push	esi
	push	DWORD PTR _scanline$[ebp]
	call	?stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 2711 :                   stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x2,y2);

	mov	eax, DWORD PTR tv1000[ebp]
	add	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR _y2$1$[ebp]
	movss	DWORD PTR [esp+12], xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _y1$1$[ebp]
	movss	DWORD PTR [esp+4], xmm0
	movd	xmm0, esi
	cvtdq2ps xmm0, xmm0
$LN58@stbtt__fil:
	movss	DWORD PTR [esp], xmm0
	push	edi
	push	esi
	push	DWORD PTR _scanline$[ebp]
	call	?stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 2712 :                   stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);

	movss	xmm0, DWORD PTR _y_bottom$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR tv1000[ebp]
	movss	DWORD PTR [esp+12], xmm0
	movss	xmm0, DWORD PTR _xb$1$[ebp]
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _y2$1$[ebp]
	movss	DWORD PTR [esp+4], xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	jmp	$LN57@stbtt__fil
$LN24@stbtt__fil:

; 2713 :                } else if (x3 < x1 && x0 > x2) {  // three segments descending down-left

	comiss	xmm2, xmm3
	jbe	$LN26@stbtt__fil
	comiss	xmm0, xmm1
	jbe	$LN26@stbtt__fil

; 2714 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);

	sub	esp, 16					; 00000010H
	movss	DWORD PTR [esp+12], xmm5
	movss	DWORD PTR [esp+8], xmm1
	movss	DWORD PTR [esp+4], xmm6
	movss	DWORD PTR [esp], xmm0
	push	edi
	push	esi
	push	DWORD PTR _scanline$[ebp]
	call	?stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 2715 :                   stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x1,y1);

	movss	xmm0, DWORD PTR _y1$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR tv1000[ebp]
	movss	DWORD PTR [esp+12], xmm0
	movd	xmm0, esi
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _y2$1$[ebp]
	movss	DWORD PTR [esp+4], xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
$LN59@stbtt__fil:
	movss	DWORD PTR [esp], xmm0
	push	edi
	push	esi
	push	DWORD PTR _scanline$[ebp]
	call	?stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge

; 2716 :                   stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);

	movss	xmm0, DWORD PTR _y_bottom$1$[ebp]
	add	esp, 12					; 0000000cH
	movss	DWORD PTR [esp+12], xmm0
	movss	xmm0, DWORD PTR _xb$1$[ebp]
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _y1$1$[ebp]
	movss	DWORD PTR [esp+4], xmm0
	movd	xmm0, esi
	cvtdq2ps xmm0, xmm0
	jmp	SHORT $LN57@stbtt__fil
$LN26@stbtt__fil:

; 2717 :                } else if (x0 < x1 && x3 > x1) {  // two segments across x, down-right

	comiss	xmm2, xmm0
	jbe	SHORT $LN28@stbtt__fil
	comiss	xmm3, xmm2
	jbe	SHORT $LN28@stbtt__fil
$LN62@stbtt__fil:

; 2718 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);

	sub	esp, 16					; 00000010H
	movss	DWORD PTR [esp+12], xmm4
	movss	DWORD PTR [esp+8], xmm2
	movss	DWORD PTR [esp+4], xmm6

; 2719 :                   stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);

	jmp	SHORT $LN59@stbtt__fil
$LN28@stbtt__fil:

; 2720 :                } else if (x3 < x1 && x0 > x1) {  // two segments across x, down-left

	comiss	xmm2, xmm3
	jbe	SHORT $LN30@stbtt__fil
	comiss	xmm0, xmm2
	ja	SHORT $LN62@stbtt__fil
$LN30@stbtt__fil:

; 2721 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x1,y1);
; 2722 :                   stbtt__handle_clipped_edge(scanline,x,e, x1,y1, x3,y3);
; 2723 :                } else if (x0 < x2 && x3 > x2) {  // two segments across x+1, down-right

	comiss	xmm1, xmm0
	jbe	SHORT $LN32@stbtt__fil
	comiss	xmm3, xmm1
	jbe	SHORT $LN32@stbtt__fil
$LN61@stbtt__fil:

; 2724 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);

	sub	esp, 16					; 00000010H
	movss	DWORD PTR [esp+12], xmm5
	movss	DWORD PTR [esp+8], xmm1
	movss	DWORD PTR [esp+4], xmm6

; 2725 :                   stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);

	jmp	$LN58@stbtt__fil
$LN32@stbtt__fil:

; 2726 :                } else if (x3 < x2 && x0 > x2) {  // two segments across x+1, down-left

	comiss	xmm1, xmm3
	jbe	SHORT $LN34@stbtt__fil
	comiss	xmm0, xmm1
	ja	SHORT $LN61@stbtt__fil
$LN34@stbtt__fil:

; 2727 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x2,y2);
; 2728 :                   stbtt__handle_clipped_edge(scanline,x,e, x2,y2, x3,y3);
; 2729 :                } else {  // one segment
; 2730 :                   stbtt__handle_clipped_edge(scanline,x,e, x0,y0, x3,y3);

	sub	esp, 16					; 00000010H
	movss	DWORD PTR [esp+12], xmm7
	movss	DWORD PTR [esp+8], xmm3
	movss	DWORD PTR [esp+4], xmm6
$LN57@stbtt__fil:
	movss	DWORD PTR [esp], xmm0
	push	edi
	push	esi
	push	DWORD PTR _scanline$[ebp]
	call	?stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z ; stbtt__handle_clipped_edge
	mov	esi, DWORD PTR tv1000[ebp]
	add	esp, 28					; 0000001cH
	mov	ecx, DWORD PTR _len$[ebp]
	movss	xmm0, DWORD PTR _x0$1$[ebp]
	movss	xmm3, DWORD PTR _xb$1$[ebp]
	movss	xmm6, DWORD PTR _y_top$[ebp]
	movss	xmm7, DWORD PTR _y_bottom$1$[ebp]
	movss	xmm5, DWORD PTR tv994[ebp]
	cmp	esi, ecx
	jl	$LL9@stbtt__fil
$LN60@stbtt__fil:
	movss	xmm6, DWORD PTR _y_top$[ebp]
$LN56@stbtt__fil:
	xorps	xmm3, xmm3
$LN8@stbtt__fil:

; 2731 :                }
; 2732 :             }
; 2733 :          }
; 2734 :       }
; 2735 :       e = e->next;

	mov	edi, DWORD PTR [edi]
	test	edi, edi
	jne	$LL2@stbtt__fil
	pop	esi
$LN3@stbtt__fil:
	pop	edi

; 2736 :    }
; 2737 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?stbtt__fill_active_edges_new@@YAXPAM0HPAUstbtt__active_edge@@M@Z ENDP ; stbtt__fill_active_edges_new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_scanline$ = 8						; size = 4
_x$ = 12						; size = 4
_e$ = 16						; size = 4
_x0$ = 20						; size = 4
_y0$ = 24						; size = 4
_x1$ = 28						; size = 4
_y1$ = 32						; size = 4
?stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z PROC ; stbtt__handle_clipped_edge

; 2541 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2542 :    if (y0 == y1) return;

	movss	xmm4, DWORD PTR _y0$[ebp]
	movss	xmm2, DWORD PTR _y1$[ebp]
	ucomiss	xmm4, xmm2
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN18@stbtt__han

; 2543 :    STBTT_assert(y0 < y1);
; 2544 :    STBTT_assert(e->sy <= e->ey);
; 2545 :    if (y0 > e->ey) return;

	mov	edx, DWORD PTR _e$[ebp]
	movss	xmm7, DWORD PTR [edx+24]
	comiss	xmm4, xmm7
	ja	$LN18@stbtt__han

; 2546 :    if (y1 < e->sy) return;

	movss	xmm6, DWORD PTR [edx+20]
	comiss	xmm6, xmm2
	ja	$LN18@stbtt__han

; 2547 :    if (y0 < e->sy) {

	comiss	xmm6, xmm4
	movss	xmm5, DWORD PTR _x1$[ebp]
	jbe	SHORT $LN20@stbtt__han

; 2548 :       x0 += (x1-x0) * (e->sy - y0) / (y1-y0);

	movaps	xmm0, xmm5
	movaps	xmm3, xmm6
	subss	xmm0, DWORD PTR _x0$[ebp]
	subss	xmm3, xmm4
	mulss	xmm3, xmm0
	movaps	xmm0, xmm2
	subss	xmm0, xmm4

; 2549 :       y0 = e->sy;

	movaps	xmm4, xmm6
	divss	xmm3, xmm0
	addss	xmm3, DWORD PTR _x0$[ebp]
	jmp	SHORT $LN5@stbtt__han
$LN20@stbtt__han:
	movss	xmm3, DWORD PTR _x0$[ebp]
$LN5@stbtt__han:

; 2550 :    }
; 2551 :    if (y1 > e->ey) {

	comiss	xmm2, xmm7
	jbe	SHORT $LN6@stbtt__han

; 2552 :       x1 += (x1-x0) * (e->ey - y1) / (y1-y0);

	movaps	xmm0, xmm5
	movaps	xmm1, xmm7
	subss	xmm1, xmm2
	subss	xmm0, xmm3
	subss	xmm2, xmm4
	mulss	xmm1, xmm0
	divss	xmm1, xmm2

; 2553 :       y1 = e->ey;

	movaps	xmm2, xmm7
	addss	xmm5, xmm1
$LN6@stbtt__han:

; 2554 :    }
; 2555 : 
; 2556 :    if (x0 == x)
; 2557 :       STBTT_assert(x1 <= x+1);
; 2558 :    else if (x0 == x+1)
; 2559 :       STBTT_assert(x1 >= x);
; 2560 :    else if (x0 <= x)
; 2561 :       STBTT_assert(x1 <= x);
; 2562 :    else if (x0 >= x+1)
; 2563 :       STBTT_assert(x1 >= x+1);
; 2564 :    else
; 2565 :       STBTT_assert(x1 >= x && x1 <= x+1);
; 2566 : 
; 2567 :    if (x0 <= x && x1 <= x)

	mov	ecx, DWORD PTR _x$[ebp]
	movd	xmm0, ecx
	cvtdq2ps xmm0, xmm0
	comiss	xmm0, xmm3
	jb	SHORT $LN15@stbtt__han
	comiss	xmm0, xmm5
	jb	SHORT $LN15@stbtt__han

; 2568 :       scanline[x] += e->direction * (y1-y0);

	mov	eax, DWORD PTR _scanline$[ebp]
	subss	xmm2, xmm4
	mulss	xmm2, DWORD PTR [edx+16]
	addss	xmm2, DWORD PTR [eax+ecx*4]
	movss	DWORD PTR [eax+ecx*4], xmm2

; 2574 :    }
; 2575 : }

	pop	ebp
	ret	0
$LN15@stbtt__han:

; 2569 :    else if (x0 >= x+1 && x1 >= x+1)

	lea	eax, DWORD PTR [ecx+1]
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	comiss	xmm3, xmm1
	jb	SHORT $LN17@stbtt__han
	comiss	xmm5, xmm1
	jae	SHORT $LN18@stbtt__han
$LN17@stbtt__han:

; 2570 :       ;
; 2571 :    else {
; 2572 :       STBTT_assert(x0 >= x && x0 <= x+1 && x1 >= x && x1 <= x+1);
; 2573 :       scanline[x] += e->direction * (y1-y0) * (1-((x0-x)+(x1-x))/2); // coverage = 1 - average x position

	mov	eax, DWORD PTR _scanline$[ebp]
	subss	xmm3, xmm0
	subss	xmm5, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm2, xmm4
	addss	xmm3, xmm5
	mulss	xmm2, DWORD PTR [edx+16]
	mulss	xmm3, DWORD PTR __real@3f000000
	subss	xmm0, xmm3
	mulss	xmm0, xmm2
	addss	xmm0, DWORD PTR [eax+ecx*4]
	movss	DWORD PTR [eax+ecx*4], xmm0
$LN18@stbtt__han:

; 2574 :    }
; 2575 : }

	pop	ebp
	ret	0
?stbtt__handle_clipped_edge@@YAXPAMHPAUstbtt__active_edge@@MMMM@Z ENDP ; stbtt__handle_clipped_edge
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_hh$ = 8						; size = 4
_e$ = 12						; size = 4
_off_x$ = 16						; size = 4
_start_point$ = 20					; size = 4
_userdata$ = 24						; size = 4
?stbtt__new_active@@YAPAUstbtt__active_edge@@PAUstbtt__hheap@@PAUstbtt__edge@@HMPAX@Z PROC ; stbtt__new_active

; 2370 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2371 :    stbtt__active_edge *z = (stbtt__active_edge *) stbtt__hheap_alloc(hh, sizeof(*z), userdata);

	push	DWORD PTR _userdata$[ebp]
	push	28					; 0000001cH
	push	DWORD PTR _hh$[ebp]
	call	?stbtt__hheap_alloc@@YAPAXPAUstbtt__hheap@@IPAX@Z ; stbtt__hheap_alloc

; 2372 :    float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);

	mov	edx, DWORD PTR _e$[ebp]
	mov	ecx, eax
	add	esp, 12					; 0000000cH
	movss	xmm2, DWORD PTR [edx+8]
	movss	xmm0, DWORD PTR [edx+12]
	subss	xmm2, DWORD PTR [edx]
	subss	xmm0, DWORD PTR [edx+4]
	divss	xmm2, xmm0

; 2373 :    STBTT_assert(z != NULL);
; 2374 :    //STBTT_assert(e->y0 <= start_point);
; 2375 :    if (!z) return z;

	test	ecx, ecx
	jne	SHORT $LN2@stbtt__new

; 2385 : }

	pop	ebp
	ret	0
$LN2@stbtt__new:

; 2376 :    z->fdx = dxdy;
; 2377 :    z->fdy = dxdy != 0.0f ? (1.0f/dxdy) : 0.0f;

	movss	xmm3, DWORD PTR __real@3f800000
	xorps	xmm0, xmm0
	ucomiss	xmm2, xmm0
	movss	DWORD PTR [ecx+8], xmm2
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN4@stbtt__new
	movaps	xmm0, xmm3
	divss	xmm0, xmm2
$LN4@stbtt__new:

; 2378 :    z->fx = e->x0 + dxdy * (start_point - e->y0);

	movss	xmm1, DWORD PTR _start_point$[ebp]
	movss	DWORD PTR [ecx+12], xmm0
	subss	xmm1, DWORD PTR [edx+4]
	movd	xmm0, DWORD PTR _off_x$[ebp]

; 2379 :    z->fx -= off_x;

	cvtdq2ps xmm0, xmm0
	mulss	xmm1, xmm2
	addss	xmm1, DWORD PTR [edx]
	subss	xmm1, xmm0
	movss	DWORD PTR [ecx+4], xmm1

; 2380 :    z->direction = e->invert ? 1.0f : -1.0f;

	cmp	DWORD PTR [edx+16], 0
	jne	SHORT $LN7@stbtt__new
	movss	xmm3, DWORD PTR __real@bf800000
$LN7@stbtt__new:
	movss	DWORD PTR [ecx+16], xmm3

; 2381 :    z->sy = e->y0;

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+20], eax

; 2382 :    z->ey = e->y1;

	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+24], eax

; 2383 :    z->next = 0;
; 2384 :    return z;

	mov	eax, ecx
	mov	DWORD PTR [ecx], 0

; 2385 : }

	pop	ebp
	ret	0
?stbtt__new_active@@YAPAUstbtt__active_edge@@PAUstbtt__hheap@@PAUstbtt__edge@@HMPAX@Z ENDP ; stbtt__new_active
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_hh$ = 8						; size = 4
_userdata$ = 12						; size = 4
?stbtt__hheap_cleanup@@YAXPAUstbtt__hheap@@PAX@Z PROC	; stbtt__hheap_cleanup

; 2310 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2311 :    stbtt__hheap_chunk *c = hh->head;

	mov	eax, DWORD PTR _hh$[ebp]
	mov	eax, DWORD PTR [eax]

; 2312 :    while (c) {

	test	eax, eax
	je	SHORT $LN3@stbtt__hhe
	push	esi
	npad	1
$LL2@stbtt__hhe:

; 2313 :       stbtt__hheap_chunk *n = c->next;

	mov	esi, DWORD PTR [eax]

; 2314 :       STBTT_free(c, userdata);

	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 2315 :       c = n;

	mov	eax, esi
	test	esi, esi
	jne	SHORT $LL2@stbtt__hhe
	pop	esi
$LN3@stbtt__hhe:

; 2316 :    }
; 2317 : }

	pop	ebp
	ret	0
?stbtt__hheap_cleanup@@YAXPAUstbtt__hheap@@PAX@Z ENDP	; stbtt__hheap_cleanup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_hh$ = 8						; size = 4
_p$ = 12						; size = 4
?stbtt__hheap_free@@YAXPAUstbtt__hheap@@PAX@Z PROC	; stbtt__hheap_free

; 2304 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2305 :    *(void **) p = hh->first_free;

	mov	edx, DWORD PTR _hh$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax

; 2306 :    hh->first_free = p;

	mov	DWORD PTR [edx+4], ecx

; 2307 : }

	pop	ebp
	ret	0
?stbtt__hheap_free@@YAXPAUstbtt__hheap@@PAX@Z ENDP	; stbtt__hheap_free
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_hh$ = 8						; size = 4
_size$ = 12						; size = 4
_userdata$ = 16						; size = 4
?stbtt__hheap_alloc@@YAPAXPAUstbtt__hheap@@IPAX@Z PROC	; stbtt__hheap_alloc

; 2283 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 2284 :    if (hh->first_free) {

	mov	esi, DWORD PTR _hh$[ebp]
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN2@stbtt__hhe

; 2285 :       void *p = hh->first_free;
; 2286 :       hh->first_free = * (void **) p;

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi+4], ecx
	pop	esi

; 2300 :    }
; 2301 : }

	pop	ebp
	ret	0
$LN2@stbtt__hhe:

; 2287 :       return p;
; 2288 :    } else {
; 2289 :       if (hh->num_remaining_in_head_chunk == 0) {

	cmp	DWORD PTR [esi+8], 0
	push	ebx
	mov	ebx, DWORD PTR _size$[ebp]
	push	edi
	jne	SHORT $LN4@stbtt__hhe

; 2290 :          int count = (size < 32 ? 2000 : size < 128 ? 800 : 100);

	cmp	ebx, 32					; 00000020H
	jae	SHORT $LN7@stbtt__hhe
	mov	edi, 2000				; 000007d0H
	jmp	SHORT $LN8@stbtt__hhe
$LN7@stbtt__hhe:
	cmp	ebx, 128				; 00000080H
	sbb	edi, edi
	and	edi, 700				; 000002bcH
	add	edi, 100				; 00000064H
$LN8@stbtt__hhe:

; 2291 :          stbtt__hheap_chunk *c = (stbtt__hheap_chunk *) STBTT_malloc(sizeof(stbtt__hheap_chunk) + size * count, userdata);

	mov	eax, edi
	imul	eax, ebx
	add	eax, 4
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ecx, eax
	add	esp, 4

; 2292 :          if (c == NULL)

	test	ecx, ecx
	jne	SHORT $LN5@stbtt__hhe
	pop	edi
	pop	ebx
	pop	esi

; 2300 :    }
; 2301 : }

	pop	ebp
	ret	0
$LN5@stbtt__hhe:

; 2293 :             return NULL;
; 2294 :          c->next = hh->head;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax

; 2295 :          hh->head = c;

	mov	DWORD PTR [esi], ecx

; 2296 :          hh->num_remaining_in_head_chunk = count;

	mov	DWORD PTR [esi+8], edi
$LN4@stbtt__hhe:

; 2297 :       }
; 2298 :       --hh->num_remaining_in_head_chunk;

	dec	DWORD PTR [esi+8]
	mov	eax, DWORD PTR [esi+8]

; 2299 :       return (char *) (hh->head) + size * hh->num_remaining_in_head_chunk;

	imul	eax, ebx
	pop	edi
	pop	ebx
	add	eax, DWORD PTR [esi]
	pop	esi

; 2300 :    }
; 2301 : }

	pop	ebp
	ret	0
?stbtt__hheap_alloc@@YAPAXPAUstbtt__hheap@@IPAX@Z ENDP	; stbtt__hheap_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_count_ctx$ = -96					; size = 48
_output_ctx$ = -48					; size = 48
_info$ = 8						; size = 4
_glyph_index$ = 12					; size = 4
_pvertices$ = 16					; size = 4
?stbtt__GetGlyphShapeT2@@YAHPBUstbtt_fontinfo@@HPAPAUstbtt_vertex@@@Z PROC ; stbtt__GetGlyphShapeT2

; 2105 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	esi

; 2106 :    // runs the charstring twice, once to count and once to output (to avoid realloc)
; 2107 :    stbtt__csctx count_ctx = STBTT__CSCTX_INIT(1);
; 2108 :    stbtt__csctx output_ctx = STBTT__CSCTX_INIT(0);
; 2109 :    if (stbtt__run_charstring(info, glyph_index, &count_ctx)) {

	lea	eax, DWORD PTR _count_ctx$[ebp]
	mov	DWORD PTR _count_ctx$[ebp], 1
	push	eax
	push	DWORD PTR _glyph_index$[ebp]
	xorps	xmm0, xmm0
	mov	DWORD PTR _count_ctx$[ebp+4], 0
	push	DWORD PTR _info$[ebp]
	movups	XMMWORD PTR _count_ctx$[ebp+8], xmm0
	mov	DWORD PTR _count_ctx$[ebp+40], 0
	movups	XMMWORD PTR _count_ctx$[ebp+24], xmm0
	mov	DWORD PTR _count_ctx$[ebp+44], 0
	mov	DWORD PTR _output_ctx$[ebp], 0
	mov	DWORD PTR _output_ctx$[ebp+4], 0
	movups	XMMWORD PTR _output_ctx$[ebp+8], xmm0
	mov	DWORD PTR _output_ctx$[ebp+40], 0
	movups	XMMWORD PTR _output_ctx$[ebp+24], xmm0
	mov	DWORD PTR _output_ctx$[ebp+44], 0
	call	?stbtt__run_charstring@@YAHPBUstbtt_fontinfo@@HPAUstbtt__csctx@@@Z ; stbtt__run_charstring
	mov	esi, DWORD PTR _pvertices$[ebp]
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN3@stbtt__Get

; 2110 :       *pvertices = (stbtt_vertex*)STBTT_malloc(count_ctx.num_vertices*sizeof(stbtt_vertex), info->userdata);

	mov	eax, DWORD PTR _count_ctx$[ebp+44]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	add	ecx, ecx
	push	ecx
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	DWORD PTR [esi], eax

; 2111 :       output_ctx.pvertices = *pvertices;

	mov	DWORD PTR _output_ctx$[ebp+40], eax

; 2112 :       if (stbtt__run_charstring(info, glyph_index, &output_ctx)) {

	lea	eax, DWORD PTR _output_ctx$[ebp]
	push	eax
	push	DWORD PTR _glyph_index$[ebp]
	push	DWORD PTR _info$[ebp]
	call	?stbtt__run_charstring@@YAHPBUstbtt_fontinfo@@HPAUstbtt__csctx@@@Z ; stbtt__run_charstring
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN3@stbtt__Get

; 2113 :          STBTT_assert(output_ctx.num_vertices == count_ctx.num_vertices);
; 2114 :          return output_ctx.num_vertices;

	mov	eax, DWORD PTR _output_ctx$[ebp+44]
	pop	esi

; 2119 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@stbtt__Get:

; 2115 :       }
; 2116 :    }
; 2117 :    *pvertices = NULL;

	mov	DWORD PTR [esi], 0

; 2118 :    return 0;

	xor	eax, eax
	pop	esi

; 2119 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?stbtt__GetGlyphShapeT2@@YAHPBUstbtt_fontinfo@@HPAPAUstbtt_vertex@@@Z ENDP ; stbtt__GetGlyphShapeT2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_subr_stack$ = -392					; size = 120
$T1 = -272						; size = 12
$T2 = -260						; size = 12
$T3 = -260						; size = 12
_subrs$ = -248						; size = 12
_s$ = -236						; size = 192
_has_subrs$1$ = -44					; size = 4
_b$ = -40						; size = 12
_subr_stack_height$1$ = -28				; size = 4
_in_header$1$ = -24					; size = 4
_maskbits$1$ = -20					; size = 4
tv1164 = -16						; size = 4
tv1148 = -16						; size = 4
tv1147 = -16						; size = 4
tv1162 = -12						; size = 4
tv1154 = -12						; size = 4
tv1149 = -12						; size = 4
tv1146 = -12						; size = 4
tv1140 = -12						; size = 4
_clear_stack$1$ = -8					; size = 4
_sp$1$ = -4						; size = 4
_info$ = 8						; size = 4
_glyph_index$ = 12					; size = 4
_c$ = 16						; size = 4
?stbtt__run_charstring@@YAHPBUstbtt_fontinfo@@HPAUstbtt__csctx@@@Z PROC ; stbtt__run_charstring

; 1846 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 392				; 00000188H

; 1847 :    int in_header = 1, maskbits = 0, subr_stack_height = 0, sp = 0, v, i, b0;
; 1848 :    int has_subrs = 0, clear_stack;
; 1849 :    float s[48];
; 1850 :    stbtt__buf subr_stack[10], subrs = info->subrs, b;

	mov	edx, DWORD PTR _info$[ebp]
	xor	eax, eax
	push	esi
	push	edi

; 1851 :    float f;
; 1852 : 
; 1853 : #define STBTT__CSERR(s) (0)
; 1854 : 
; 1855 :    // this currently ignores the initial width value, which isn't needed if we have hmtx
; 1856 :    b = stbtt__cff_index_get(info->charstrings, glyph_index);

	push	DWORD PTR _glyph_index$[ebp]
	movq	xmm0, QWORD PTR [edx+84]
	xor	edi, edi
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _subr_stack_height$1$[ebp], eax
	mov	ecx, esp
	mov	DWORD PTR _has_subrs$1$[ebp], eax
	mov	eax, DWORD PTR [edx+92]
	movq	QWORD PTR _subrs$[ebp], xmm0
	movq	xmm0, QWORD PTR [edx+60]
	mov	DWORD PTR _subrs$[ebp+8], eax
	mov	eax, DWORD PTR [edx+68]
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	mov	DWORD PTR _in_header$1$[ebp], 1
	mov	DWORD PTR _maskbits$1$[ebp], 0
	mov	DWORD PTR _sp$1$[ebp], edi
	call	?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z ; stbtt__cff_index_get
	movss	xmm6, DWORD PTR _s$[ebp]
	add	esp, 20					; 00000014H
	movss	xmm7, DWORD PTR _s$[ebp+8]
	movq	xmm0, QWORD PTR [eax]
	mov	eax, DWORD PTR [eax+8]
	movq	QWORD PTR _b$[ebp], xmm0
	mov	DWORD PTR _b$[ebp+8], eax
	npad	10
$LL2@stbtt__run:

; 1857 :    while (b.cursor < b.size) {

	mov	eax, DWORD PTR _b$[ebp+4]
	cmp	eax, DWORD PTR _b$[ebp+8]
	jge	$LN3@stbtt__run

; 1858 :       i = 0;
; 1859 :       clear_stack = 1;
; 1860 :       b0 = stbtt__buf_get8(&b);

	lea	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _clear_stack$1$[ebp], 1
	push	eax
	xor	esi, esi
	call	?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z	; stbtt__buf_get8
	movzx	edx, al
	add	esp, 4
	mov	DWORD PTR tv1164[ebp], edx

; 1861 :       switch (b0) {

	lea	eax, DWORD PTR [edx-1]
	cmp	eax, 30					; 0000001eH
	ja	$LN89@stbtt__run
	movzx	eax, BYTE PTR $LN154@stbtt__run[eax]
	jmp	DWORD PTR $LN169@stbtt__run[eax*4]
$LN29@stbtt__run:

; 1862 :       // @TODO implement hinting
; 1863 :       case 0x13: // hintmask
; 1864 :       case 0x14: // cntrmask
; 1865 :          if (in_header)

	cmp	DWORD PTR _in_header$1$[ebp], esi

; 1866 :             maskbits += (sp / 2); // implicit "vstem"

	mov	esi, DWORD PTR _maskbits$1$[ebp]
	je	SHORT $LN30@stbtt__run
	mov	eax, edi
	cdq
	sub	eax, edx
	sar	eax, 1
	add	esi, eax
	mov	DWORD PTR _maskbits$1$[ebp], esi
$LN30@stbtt__run:

; 1867 :          in_header = 0;
; 1868 :          stbtt__buf_skip(&b, (maskbits + 7) / 8);

	lea	eax, DWORD PTR [esi+7]
	mov	DWORD PTR _in_header$1$[ebp], 0
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	push	eax
	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	?stbtt__buf_skip@@YAXPAUstbtt__buf@@H@Z	; stbtt__buf_skip

; 1869 :          break;

	mov	ecx, DWORD PTR _clear_stack$1$[ebp]
	xor	eax, eax
	add	esp, 8
	test	ecx, ecx
	cmove	eax, edi
	mov	edi, eax
	mov	DWORD PTR _sp$1$[ebp], edi

; 2094 :          clear_stack = 0;
; 2095 :          break;
; 2096 :       }
; 2097 :       if (clear_stack) sp = 0;
; 2098 :    }

	jmp	$LL2@stbtt__run
$LN31@stbtt__run:

; 1870 : 
; 1871 :       case 0x01: // hstem
; 1872 :       case 0x03: // vstem
; 1873 :       case 0x12: // hstemhm
; 1874 :       case 0x17: // vstemhm
; 1875 :          maskbits += (sp / 2);
; 1876 :          break;

	mov	ecx, DWORD PTR _clear_stack$1$[ebp]
	mov	eax, edi
	cdq
	sub	eax, edx
	sar	eax, 1
	add	DWORD PTR _maskbits$1$[ebp], eax
	xor	eax, eax
	test	ecx, ecx
	cmove	eax, edi
	mov	edi, eax
	mov	DWORD PTR _sp$1$[ebp], edi

; 2094 :          clear_stack = 0;
; 2095 :          break;
; 2096 :       }
; 2097 :       if (clear_stack) sp = 0;
; 2098 :    }

	jmp	$LL2@stbtt__run
$LN32@stbtt__run:

; 1877 : 
; 1878 :       case 0x15: // rmoveto
; 1879 :          in_header = 0;

	mov	DWORD PTR _in_header$1$[ebp], esi

; 1880 :          if (sp < 2) return STBTT__CSERR("rmoveto stack");

	cmp	edi, 2
	jl	$LN3@stbtt__run

; 1881 :          stbtt__csctx_rmove_to(c, s[sp-2], s[sp-1]);

	movss	xmm0, DWORD PTR _s$[ebp+edi*4-4]
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _s$[ebp+edi*4-8]
$LN164@stbtt__run:
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _c$[ebp]
	call	?stbtt__csctx_rmove_to@@YAXPAUstbtt__csctx@@MM@Z ; stbtt__csctx_rmove_to
$LN166@stbtt__run:
	add	esp, 12					; 0000000cH
$LN165@stbtt__run:

; 1882 :          break;

	mov	ecx, DWORD PTR _clear_stack$1$[ebp]
	xor	eax, eax
	test	ecx, ecx
	cmove	eax, edi
	mov	edi, eax
	mov	DWORD PTR _sp$1$[ebp], edi

; 2094 :          clear_stack = 0;
; 2095 :          break;
; 2096 :       }
; 2097 :       if (clear_stack) sp = 0;
; 2098 :    }

	jmp	$LL2@stbtt__run
$LN34@stbtt__run:

; 1883 :       case 0x04: // vmoveto
; 1884 :          in_header = 0;

	mov	DWORD PTR _in_header$1$[ebp], esi

; 1885 :          if (sp < 1) return STBTT__CSERR("vmoveto stack");

	cmp	edi, 1
	jl	$LN3@stbtt__run

; 1886 :          stbtt__csctx_rmove_to(c, 0, s[sp-1]);

	movss	xmm0, DWORD PTR _s$[ebp+edi*4-4]
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], esi
	push	DWORD PTR _c$[ebp]
	call	?stbtt__csctx_rmove_to@@YAXPAUstbtt__csctx@@MM@Z ; stbtt__csctx_rmove_to

; 1887 :          break;

	mov	ecx, DWORD PTR _clear_stack$1$[ebp]
	xor	eax, eax
	add	esp, 12					; 0000000cH
	test	ecx, ecx
	cmove	eax, edi
	mov	edi, eax
	mov	DWORD PTR _sp$1$[ebp], edi

; 2094 :          clear_stack = 0;
; 2095 :          break;
; 2096 :       }
; 2097 :       if (clear_stack) sp = 0;
; 2098 :    }

	jmp	$LL2@stbtt__run
$LN36@stbtt__run:

; 1888 :       case 0x16: // hmoveto
; 1889 :          in_header = 0;

	mov	DWORD PTR _in_header$1$[ebp], esi

; 1890 :          if (sp < 1) return STBTT__CSERR("hmoveto stack");

	cmp	edi, 1
	jl	$LN3@stbtt__run

; 1891 :          stbtt__csctx_rmove_to(c, s[sp-1], 0);

	movss	xmm0, DWORD PTR _s$[ebp+edi*4-4]
	sub	esp, 8
	mov	DWORD PTR [esp+4], esi

; 1892 :          break;

	jmp	$LN164@stbtt__run
$LN38@stbtt__run:

; 1893 : 
; 1894 :       case 0x05: // rlineto
; 1895 :          if (sp < 2) return STBTT__CSERR("rlineto stack");

	mov	eax, DWORD PTR _sp$1$[ebp]
	cmp	eax, 2
	jl	$LN3@stbtt__run

; 1896 :          for (; i + 1 < sp; i += 2)

	mov	edi, eax
	cmp	eax, 1
	jle	$LN165@stbtt__run
	mov	esi, DWORD PTR _c$[ebp]
	lea	eax, DWORD PTR _s$[ebp]
	mov	DWORD PTR tv1149[ebp], 1
	mov	DWORD PTR tv1148[ebp], eax
	npad	3
$LL8@stbtt__run:

; 1897 :             stbtt__csctx_rline_to(c, s[i], s[i+1]);

	movss	xmm0, DWORD PTR [eax+4]
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [esp], xmm0
	push	esi
	call	?stbtt__csctx_rline_to@@YAXPAUstbtt__csctx@@MM@Z ; stbtt__csctx_rline_to
	mov	ecx, DWORD PTR tv1149[ebp]
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR tv1148[ebp]
	add	ecx, 2
	add	eax, 8
	mov	DWORD PTR tv1149[ebp], ecx
	mov	DWORD PTR tv1148[ebp], eax
	cmp	ecx, edi
	jl	SHORT $LL8@stbtt__run

; 2094 :          clear_stack = 0;
; 2095 :          break;
; 2096 :       }
; 2097 :       if (clear_stack) sp = 0;
; 2098 :    }

	mov	ecx, DWORD PTR _clear_stack$1$[ebp]
	xor	eax, eax
	test	ecx, ecx
	cmove	eax, edi
	mov	edi, eax
	mov	DWORD PTR _sp$1$[ebp], edi
	jmp	$LL2@stbtt__run
$LN40@stbtt__run:

; 1898 :          break;
; 1899 : 
; 1900 :       // hlineto/vlineto and vhcurveto/hvcurveto alternate horizontal and vertical
; 1901 :       // starting from a different place.
; 1902 : 
; 1903 :       case 0x07: // vlineto
; 1904 :          if (sp < 1) return STBTT__CSERR("vlineto stack");

	mov	eax, DWORD PTR _sp$1$[ebp]
	cmp	eax, 1
	jl	SHORT $LN3@stbtt__run

; 1905 :          goto vlineto;

	mov	edi, DWORD PTR _c$[ebp]
	jmp	SHORT $vlineto$171
$LN43@stbtt__run:

; 1906 :       case 0x06: // hlineto
; 1907 :          if (sp < 1) return STBTT__CSERR("hlineto stack");

	mov	eax, DWORD PTR _sp$1$[ebp]
	cmp	eax, 1
	jl	SHORT $LN3@stbtt__run
	mov	edi, DWORD PTR _c$[ebp]
$LN9@stbtt__run:

; 1908 :          for (;;) {
; 1909 :             if (i >= sp) break;

	cmp	esi, eax
	jge	$LN156@stbtt__run

; 1910 :             stbtt__csctx_rline_to(c, s[i], 0);

	movss	xmm0, DWORD PTR _s$[ebp+esi*4]
	sub	esp, 8
	mov	DWORD PTR [esp+4], 0
	movss	DWORD PTR [esp], xmm0
	push	edi
	call	?stbtt__csctx_rline_to@@YAXPAUstbtt__csctx@@MM@Z ; stbtt__csctx_rline_to
	mov	eax, DWORD PTR _sp$1$[ebp]
	add	esp, 12					; 0000000cH

; 1911 :             i++;

	inc	esi
$vlineto$171:

; 1912 :       vlineto:
; 1913 :             if (i >= sp) break;

	cmp	esi, eax
	jge	$LN156@stbtt__run

; 1914 :             stbtt__csctx_rline_to(c, 0, s[i]);

	movss	xmm0, DWORD PTR _s$[ebp+esi*4]
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 0
	push	edi
	call	?stbtt__csctx_rline_to@@YAXPAUstbtt__csctx@@MM@Z ; stbtt__csctx_rline_to

; 1915 :             i++;
; 1916 :          }

	mov	eax, DWORD PTR _sp$1$[ebp]
	add	esp, 12					; 0000000cH
	inc	esi
	jmp	SHORT $LN9@stbtt__run
$LN47@stbtt__run:

; 1917 :          break;
; 1918 : 
; 1919 :       case 0x1F: // hvcurveto
; 1920 :          if (sp < 4) return STBTT__CSERR("hvcurveto stack");

	cmp	edi, 4
	jge	SHORT $hvcurveto$172
$LN3@stbtt__run:

; 2099 :    return STBTT__CSERR("no endchar");

	xor	eax, eax

; 2100 : 
; 2101 : #undef STBTT__CSERR
; 2102 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN50@stbtt__run:

; 1921 :          goto hvcurveto;
; 1922 :       case 0x1E: // vhcurveto
; 1923 :          if (sp < 4) return STBTT__CSERR("vhcurveto stack");

	cmp	edi, 4
	jl	SHORT $LN3@stbtt__run
$LN12@stbtt__run:

; 1924 :          for (;;) {
; 1925 :             if (i + 3 >= sp) break;

	lea	eax, DWORD PTR [esi+3]
	cmp	eax, edi
	jge	$LN165@stbtt__run

; 1926 :             stbtt__csctx_rccurve_to(c, 0, s[i], s[i+1], s[i+2], s[i+3], (sp - i == 5) ? s[i + 4] : 0.0f);

	mov	eax, edi
	sub	eax, esi
	cmp	eax, 5
	jne	SHORT $LN97@stbtt__run
	movss	xmm0, DWORD PTR _s$[ebp+esi*4+16]
	jmp	SHORT $LN98@stbtt__run
$LN97@stbtt__run:
	xorps	xmm0, xmm0
$LN98@stbtt__run:
	sub	esp, 24					; 00000018H
	movss	DWORD PTR [esp+20], xmm0
	movups	xmm0, XMMWORD PTR _s$[ebp+esi*4]
	movups	XMMWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 0
	push	DWORD PTR _c$[ebp]
	call	?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
	add	esp, 28					; 0000001cH

; 1927 :             i += 4;

	add	esi, 4
$hvcurveto$172:

; 1928 :       hvcurveto:
; 1929 :             if (i + 3 >= sp) break;

	lea	eax, DWORD PTR [esi+3]
	cmp	eax, edi
	jge	$LN165@stbtt__run

; 1930 :             stbtt__csctx_rccurve_to(c, s[i], 0, s[i+1], s[i+2], (sp - i == 5) ? s[i+4] : 0.0f, s[i+3]);

	mov	eax, edi
	sub	eax, esi
	cmp	eax, 5
	jne	SHORT $LN99@stbtt__run
	movss	xmm1, DWORD PTR _s$[ebp+esi*4+16]
	jmp	SHORT $LN100@stbtt__run
$LN99@stbtt__run:
	xorps	xmm1, xmm1
$LN100@stbtt__run:
	movss	xmm0, DWORD PTR _s$[ebp+esi*4+12]
	sub	esp, 24					; 00000018H
	movss	DWORD PTR [esp+20], xmm0
	movss	xmm0, DWORD PTR _s$[ebp+esi*4+8]
	movss	DWORD PTR [esp+16], xmm1
	movss	DWORD PTR [esp+12], xmm0
	movss	xmm0, DWORD PTR _s$[ebp+esi*4+4]
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _s$[ebp+esi*4]
	mov	DWORD PTR [esp+4], 0
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _c$[ebp]
	call	?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
	add	esp, 28					; 0000001cH

; 1931 :             i += 4;

	add	esi, 4

; 1932 :          }

	jmp	$LN12@stbtt__run
$LN54@stbtt__run:

; 1933 :          break;
; 1934 : 
; 1935 :       case 0x08: // rrcurveto
; 1936 :          if (sp < 6) return STBTT__CSERR("rcurveline stack");

	mov	eax, DWORD PTR _sp$1$[ebp]
	cmp	eax, 6
	jl	$LN3@stbtt__run

; 1937 :          for (; i + 5 < sp; i += 6)

	mov	edi, eax
	cmp	eax, 5
	jle	$LN165@stbtt__run
	mov	esi, DWORD PTR _c$[ebp]
	lea	eax, DWORD PTR _s$[ebp+16]
	mov	DWORD PTR tv1147[ebp], 5
	mov	DWORD PTR tv1146[ebp], eax
	npad	6
$LL17@stbtt__run:

; 1938 :             stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);

	movups	xmm0, XMMWORD PTR [eax-8]
	sub	esp, 24					; 00000018H
	movups	XMMWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR [eax-12]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR [eax-16]
	movss	DWORD PTR [esp], xmm0
	push	esi
	call	?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
	mov	ecx, DWORD PTR tv1147[ebp]
	add	esp, 28					; 0000001cH
	mov	eax, DWORD PTR tv1146[ebp]
	add	ecx, 6
	add	eax, 24					; 00000018H
	mov	DWORD PTR tv1147[ebp], ecx
	mov	DWORD PTR tv1146[ebp], eax
	cmp	ecx, edi
	jl	SHORT $LL17@stbtt__run

; 2094 :          clear_stack = 0;
; 2095 :          break;
; 2096 :       }
; 2097 :       if (clear_stack) sp = 0;
; 2098 :    }

	mov	ecx, DWORD PTR _clear_stack$1$[ebp]
	xor	eax, eax
	test	ecx, ecx
	cmove	eax, edi
	mov	edi, eax
	mov	DWORD PTR _sp$1$[ebp], edi
	jmp	$LL2@stbtt__run
$LN56@stbtt__run:

; 1939 :          break;
; 1940 : 
; 1941 :       case 0x18: // rcurveline
; 1942 :          if (sp < 8) return STBTT__CSERR("rcurveline stack");

	cmp	edi, 8
	jl	$LN3@stbtt__run

; 1943 :          for (; i + 5 < sp - 2; i += 6)

	lea	eax, DWORD PTR [edi-2]
	mov	DWORD PTR tv1162[ebp], eax
	cmp	eax, 5
	jle	SHORT $LN19@stbtt__run
	mov	edi, 5
	npad	3
$LL20@stbtt__run:

; 1944 :             stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);

	movups	xmm0, XMMWORD PTR _s$[ebp+esi*4+8]
	sub	esp, 24					; 00000018H
	movups	XMMWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _s$[ebp+esi*4+4]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _s$[ebp+esi*4]
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _c$[ebp]
	call	?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
	add	edi, 6
	add	esp, 28					; 0000001cH
	add	esi, 6
	cmp	edi, DWORD PTR tv1162[ebp]
	jl	SHORT $LL20@stbtt__run
	mov	edi, DWORD PTR _sp$1$[ebp]
$LN19@stbtt__run:

; 1945 :          if (i + 1 >= sp) return STBTT__CSERR("rcurveline stack");

	lea	eax, DWORD PTR [esi+1]
	cmp	eax, edi
	jge	$LN3@stbtt__run

; 1946 :          stbtt__csctx_rline_to(c, s[i], s[i+1]);

	movss	xmm0, DWORD PTR _s$[ebp+esi*4+4]
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _s$[ebp+esi*4]
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _c$[ebp]
	call	?stbtt__csctx_rline_to@@YAXPAUstbtt__csctx@@MM@Z ; stbtt__csctx_rline_to

; 1947 :          break;

	jmp	$LN166@stbtt__run
$LN59@stbtt__run:

; 1948 : 
; 1949 :       case 0x19: // rlinecurve
; 1950 :          if (sp < 8) return STBTT__CSERR("rlinecurve stack");

	cmp	edi, 8
	jl	$LN3@stbtt__run

; 1951 :          for (; i + 1 < sp - 6; i += 2)

	lea	eax, DWORD PTR [edi-6]
	mov	DWORD PTR tv1154[ebp], eax
	cmp	eax, 1
	jle	SHORT $LN22@stbtt__run
	mov	edi, 1
	npad	9
$LL23@stbtt__run:

; 1952 :             stbtt__csctx_rline_to(c, s[i], s[i+1]);

	movss	xmm0, DWORD PTR _s$[ebp+esi*4+4]
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _s$[ebp+esi*4]
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _c$[ebp]
	call	?stbtt__csctx_rline_to@@YAXPAUstbtt__csctx@@MM@Z ; stbtt__csctx_rline_to
	add	edi, 2
	add	esp, 12					; 0000000cH
	add	esi, 2
	cmp	edi, DWORD PTR tv1154[ebp]
	jl	SHORT $LL23@stbtt__run
	mov	edi, DWORD PTR _sp$1$[ebp]
$LN22@stbtt__run:

; 1953 :          if (i + 5 >= sp) return STBTT__CSERR("rlinecurve stack");

	lea	eax, DWORD PTR [esi+5]
	cmp	eax, edi
	jge	$LN3@stbtt__run

; 1954 :          stbtt__csctx_rccurve_to(c, s[i], s[i+1], s[i+2], s[i+3], s[i+4], s[i+5]);

	movups	xmm0, XMMWORD PTR _s$[ebp+esi*4+8]
	sub	esp, 24					; 00000018H
	movups	XMMWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _s$[ebp+esi*4+4]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _s$[ebp+esi*4]
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _c$[ebp]
	call	?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
	mov	ecx, DWORD PTR _clear_stack$1$[ebp]
	xor	eax, eax
	add	esp, 28					; 0000001cH
	test	ecx, ecx
	cmove	eax, edi
	mov	edi, eax
	mov	DWORD PTR _sp$1$[ebp], edi

; 2094 :          clear_stack = 0;
; 2095 :          break;
; 2096 :       }
; 2097 :       if (clear_stack) sp = 0;
; 2098 :    }

	jmp	$LL2@stbtt__run
$LN62@stbtt__run:

; 1955 :          break;
; 1956 : 
; 1957 :       case 0x1A: // vvcurveto
; 1958 :       case 0x1B: // hhcurveto
; 1959 :          if (sp < 4) return STBTT__CSERR("(vv|hh)curveto stack");

	mov	eax, DWORD PTR _sp$1$[ebp]
	cmp	eax, 4
	jl	$LN3@stbtt__run

; 1960 :          f = 0.0;
; 1961 :          if (sp & 1) { f = s[i]; i++; }

	xorps	xmm1, xmm1
	test	al, 1
	je	SHORT $LN64@stbtt__run
	movaps	xmm1, xmm6
	mov	esi, 1
$LN64@stbtt__run:

; 1962 :          for (; i + 3 < sp; i += 4) {

	lea	ecx, DWORD PTR [esi+3]
	mov	DWORD PTR tv1140[ebp], ecx
	cmp	ecx, eax
	jge	$LN156@stbtt__run
	lea	edi, DWORD PTR _s$[ebp+8]
	lea	esi, DWORD PTR [edi+esi*4]
	mov	edi, DWORD PTR _sp$1$[ebp]
$LL26@stbtt__run:

; 1963 :             if (b0 == 0x1B)
; 1964 :                stbtt__csctx_rccurve_to(c, s[i], f, s[i+1], s[i+2], s[i+3], 0.0);

	movss	xmm0, DWORD PTR [esi+4]
	sub	esp, 24					; 00000018H
	cmp	edx, 27					; 0000001bH
	jne	SHORT $LN65@stbtt__run
	mov	DWORD PTR [esp+20], 0
	movss	DWORD PTR [esp+16], xmm0
	movss	xmm0, DWORD PTR [esi]
	movss	DWORD PTR [esp+12], xmm0
	movss	xmm0, DWORD PTR [esi-4]
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR [esi-8]
	movss	DWORD PTR [esp+4], xmm1
	movss	DWORD PTR [esp], xmm0

; 1965 :             else

	jmp	SHORT $LN162@stbtt__run
$LN65@stbtt__run:

; 1966 :                stbtt__csctx_rccurve_to(c, f, s[i], s[i+1], s[i+2], 0.0, s[i+3]);

	movss	DWORD PTR [esp+20], xmm0
	movss	xmm0, DWORD PTR [esi]
	mov	DWORD PTR [esp+16], 0
	movss	DWORD PTR [esp+12], xmm0
	movss	xmm0, DWORD PTR [esi-4]
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR [esi-8]
	movss	DWORD PTR [esp+4], xmm0
	movss	DWORD PTR [esp], xmm1
$LN162@stbtt__run:
	push	DWORD PTR _c$[ebp]
	call	?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
	mov	ecx, DWORD PTR tv1140[ebp]
	add	esp, 28					; 0000001cH
	mov	edx, DWORD PTR tv1164[ebp]
	add	ecx, 4
	add	esi, 16					; 00000010H
	mov	DWORD PTR tv1140[ebp], ecx
	xorps	xmm1, xmm1
	cmp	ecx, edi
	jl	$LL26@stbtt__run

; 2094 :          clear_stack = 0;
; 2095 :          break;
; 2096 :       }
; 2097 :       if (clear_stack) sp = 0;
; 2098 :    }

	mov	ecx, DWORD PTR _clear_stack$1$[ebp]
	xor	eax, eax
	test	ecx, ecx
	cmove	eax, edi
	mov	edi, eax
	mov	DWORD PTR _sp$1$[ebp], edi
	jmp	$LL2@stbtt__run
$LN156@stbtt__run:

; 1882 :          break;

	mov	ecx, DWORD PTR _clear_stack$1$[ebp]
	xor	eax, eax
	mov	edi, DWORD PTR _sp$1$[ebp]
	test	ecx, ecx
	cmove	eax, edi
	mov	edi, eax
	mov	DWORD PTR _sp$1$[ebp], edi

; 2094 :          clear_stack = 0;
; 2095 :          break;
; 2096 :       }
; 2097 :       if (clear_stack) sp = 0;
; 2098 :    }

	jmp	$LL2@stbtt__run
$LN67@stbtt__run:

; 1967 :             f = 0.0;
; 1968 :          }
; 1969 :          break;
; 1970 : 
; 1971 :       case 0x0A: // callsubr
; 1972 :          if (!has_subrs) {

	cmp	DWORD PTR _has_subrs$1$[ebp], esi
	jne	SHORT $LN68@stbtt__run

; 1973 :             if (info->fdselect.size)

	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax+116], esi
	je	SHORT $LN69@stbtt__run

; 1974 :                subrs = stbtt__cid_get_glyph_subrs(info, glyph_index);

	push	DWORD PTR _glyph_index$[ebp]
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PBUstbtt_fontinfo@@H@Z ; stbtt__cid_get_glyph_subrs
	mov	edx, DWORD PTR tv1164[ebp]
	add	esp, 12					; 0000000cH
	movq	xmm0, QWORD PTR [eax]
	mov	eax, DWORD PTR [eax+8]
	movq	QWORD PTR _subrs$[ebp], xmm0
	mov	DWORD PTR _subrs$[ebp+8], eax
$LN69@stbtt__run:

; 1975 :             has_subrs = 1;

	mov	DWORD PTR _has_subrs$1$[ebp], 1
$LN68@stbtt__run:

; 1976 :          }
; 1977 :          // fallthrough
; 1978 :       case 0x1D: // callgsubr
; 1979 :          if (sp < 1) return STBTT__CSERR("call(g|)subr stack");

	cmp	edi, 1
	jl	$LN3@stbtt__run

; 1980 :          v = (int) s[--sp];
; 1981 :          if (subr_stack_height >= 10) return STBTT__CSERR("recursion limit");

	mov	eax, DWORD PTR _subr_stack_height$1$[ebp]
	dec	edi
	cvttss2si esi, DWORD PTR _s$[ebp+edi*4]
	cmp	eax, 10					; 0000000aH
	jge	$LN3@stbtt__run

; 1982 :          subr_stack[subr_stack_height++] = b;

	movq	xmm0, QWORD PTR _b$[ebp]
	lea	ecx, DWORD PTR [eax+eax*2]
	inc	DWORD PTR _subr_stack_height$1$[ebp]
	mov	eax, DWORD PTR _b$[ebp+8]
	movq	QWORD PTR _subr_stack$[ebp+ecx*4], xmm0
	mov	DWORD PTR _subr_stack$[ebp+ecx*4+8], eax
	cmp	edx, 10					; 0000000aH

; 1983 :          b = stbtt__get_subr(b0 == 0x0A ? subrs : info->gsubrs, v);

	jne	SHORT $LN101@stbtt__run
	lea	eax, DWORD PTR _subrs$[ebp]
	jmp	SHORT $LN102@stbtt__run
$LN101@stbtt__run:
	mov	eax, DWORD PTR _info$[ebp]
	add	eax, 72					; 00000048H
$LN102@stbtt__run:
	movq	xmm0, QWORD PTR [eax]
	mov	eax, DWORD PTR [eax+8]
	push	esi
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z ; stbtt__get_subr
	add	esp, 20					; 00000014H
	movq	xmm0, QWORD PTR [eax]
	mov	eax, DWORD PTR [eax+8]
	movq	QWORD PTR _b$[ebp], xmm0
	mov	DWORD PTR _b$[ebp+8], eax

; 1984 :          if (b.size == 0) return STBTT__CSERR("subr not found");

	test	eax, eax
	je	$LN3@stbtt__run

; 1985 :          b.cursor = 0;

	xor	ecx, ecx
	mov	DWORD PTR _b$[ebp+4], 0
	xor	eax, eax
	test	ecx, ecx
	cmove	eax, edi
	mov	edi, eax
	mov	DWORD PTR _sp$1$[ebp], edi

; 2094 :          clear_stack = 0;
; 2095 :          break;
; 2096 :       }
; 2097 :       if (clear_stack) sp = 0;
; 2098 :    }

	jmp	$LL2@stbtt__run
$LN74@stbtt__run:

; 1986 :          clear_stack = 0;
; 1987 :          break;
; 1988 : 
; 1989 :       case 0x0B: // return
; 1990 :          if (subr_stack_height <= 0) return STBTT__CSERR("return outside subr");

	mov	esi, DWORD PTR _subr_stack_height$1$[ebp]
	test	esi, esi
	jle	$LN3@stbtt__run

; 1991 :          b = subr_stack[--subr_stack_height];

	dec	esi
	xor	ecx, ecx
	mov	DWORD PTR _subr_stack_height$1$[ebp], esi
	lea	eax, DWORD PTR [esi+esi*2]
	movq	xmm0, QWORD PTR _subr_stack$[ebp+eax*4]
	mov	eax, DWORD PTR _subr_stack$[ebp+eax*4+8]
	mov	DWORD PTR _b$[ebp+8], eax
	xor	eax, eax
	test	ecx, ecx
	movq	QWORD PTR _b$[ebp], xmm0
	cmove	eax, edi
	mov	edi, eax
	mov	DWORD PTR _sp$1$[ebp], edi

; 2094 :          clear_stack = 0;
; 2095 :          break;
; 2096 :       }
; 2097 :       if (clear_stack) sp = 0;
; 2098 :    }

	jmp	$LL2@stbtt__run
$LN77@stbtt__run:

; 1998 : 
; 1999 :       case 0x0C: { // two-byte escape
; 2000 :          float dx1, dx2, dx3, dx4, dx5, dx6, dy1, dy2, dy3, dy4, dy5, dy6;
; 2001 :          float dx, dy;
; 2002 :          int b1 = stbtt__buf_get8(&b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z	; stbtt__buf_get8
	movzx	eax, al
	add	esp, 4

; 2003 :          switch (b1) {

	add	eax, -34				; ffffffdeH
	cmp	eax, 3
	ja	$LN3@stbtt__run
	jmp	DWORD PTR $LN170@stbtt__run[eax*4]
$LN78@stbtt__run:

; 2004 :          // @TODO These "flex" implementations ignore the flex-depth and resolution,
; 2005 :          // and always draw beziers.
; 2006 :          case 0x22: // hflex
; 2007 :             if (sp < 7) return STBTT__CSERR("hflex stack");

	cmp	edi, 7
	jl	$LN3@stbtt__run

; 2008 :             dx1 = s[0];
; 2009 :             dx2 = s[1];
; 2010 :             dy2 = s[2];
; 2011 :             dx3 = s[3];
; 2012 :             dx4 = s[4];
; 2013 :             dx5 = s[5];
; 2014 :             dx6 = s[6];
; 2015 :             stbtt__csctx_rccurve_to(c, dx1, 0, dx2, dy2, dx3, 0);

	movss	xmm0, DWORD PTR _s$[ebp+12]
	sub	esp, 24					; 00000018H
	mov	DWORD PTR [esp+20], esi
	movss	DWORD PTR [esp+16], xmm0
	movss	xmm0, DWORD PTR _s$[ebp+4]
	movss	DWORD PTR [esp+12], xmm7
	movss	DWORD PTR [esp+8], xmm0
	mov	DWORD PTR [esp+4], esi
	mov	esi, DWORD PTR _c$[ebp]
	movss	DWORD PTR [esp], xmm6
	push	esi
	call	?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2016 :             stbtt__csctx_rccurve_to(c, dx4, 0, dx5, -dy2, dx6, 0);

	movss	xmm0, DWORD PTR _s$[ebp+24]
	add	esp, 4
	mov	DWORD PTR [esp+20], 0
	movss	DWORD PTR [esp+16], xmm0
	movaps	xmm0, xmm7
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esp+12], xmm0
	movss	xmm0, DWORD PTR _s$[ebp+20]
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _s$[ebp+16]
	mov	DWORD PTR [esp+4], 0
	movss	DWORD PTR [esp], xmm0
	push	esi
	call	?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
	mov	ecx, DWORD PTR _clear_stack$1$[ebp]
	xor	eax, eax
	add	esp, 28					; 0000001cH
	test	ecx, ecx
	cmove	eax, edi
	mov	edi, eax
	mov	DWORD PTR _sp$1$[ebp], edi

; 2094 :          clear_stack = 0;
; 2095 :          break;
; 2096 :       }
; 2097 :       if (clear_stack) sp = 0;
; 2098 :    }

	jmp	$LL2@stbtt__run
$LN80@stbtt__run:

; 2017 :             break;
; 2018 : 
; 2019 :          case 0x23: // flex
; 2020 :             if (sp < 13) return STBTT__CSERR("flex stack");

	cmp	edi, 13					; 0000000dH
	jl	$LN3@stbtt__run

; 2021 :             dx1 = s[0];
; 2022 :             dy1 = s[1];
; 2023 :             dx2 = s[2];
; 2024 :             dy2 = s[3];
; 2025 :             dx3 = s[4];
; 2026 :             dy3 = s[5];
; 2027 :             dx4 = s[6];
; 2028 :             dy4 = s[7];
; 2029 :             dx5 = s[8];
; 2030 :             dy5 = s[9];
; 2031 :             dx6 = s[10];
; 2032 :             dy6 = s[11];
; 2033 :             //fd is s[12]
; 2034 :             stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);

	movss	xmm0, DWORD PTR _s$[ebp+20]
	sub	esp, 24					; 00000018H
	mov	esi, DWORD PTR _c$[ebp]
	movss	DWORD PTR [esp+20], xmm0
	movss	xmm0, DWORD PTR _s$[ebp+16]
	movss	DWORD PTR [esp+16], xmm0
	movss	xmm0, DWORD PTR _s$[ebp+12]
	movss	DWORD PTR [esp+12], xmm0
	movss	xmm0, DWORD PTR _s$[ebp+4]
	movss	DWORD PTR [esp+8], xmm7
	movss	DWORD PTR [esp+4], xmm0
	movss	DWORD PTR [esp], xmm6
	push	esi
	call	?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2035 :             stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);

	movups	xmm0, XMMWORD PTR _s$[ebp+32]
	add	esp, 4
	movups	XMMWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _s$[ebp+28]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _s$[ebp+24]
	movss	DWORD PTR [esp], xmm0
	push	esi
	call	?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
	mov	ecx, DWORD PTR _clear_stack$1$[ebp]
	xor	eax, eax
	add	esp, 28					; 0000001cH
	test	ecx, ecx
	cmove	eax, edi
	mov	edi, eax
	mov	DWORD PTR _sp$1$[ebp], edi

; 2094 :          clear_stack = 0;
; 2095 :          break;
; 2096 :       }
; 2097 :       if (clear_stack) sp = 0;
; 2098 :    }

	jmp	$LL2@stbtt__run
$LN82@stbtt__run:

; 2036 :             break;
; 2037 : 
; 2038 :          case 0x24: // hflex1
; 2039 :             if (sp < 9) return STBTT__CSERR("hflex1 stack");

	cmp	edi, 9
	jl	$LN3@stbtt__run

; 2040 :             dx1 = s[0];
; 2041 :             dy1 = s[1];
; 2042 :             dx2 = s[2];
; 2043 :             dy2 = s[3];
; 2044 :             dx3 = s[4];
; 2045 :             dx4 = s[5];
; 2046 :             dx5 = s[6];
; 2047 :             dy5 = s[7];
; 2048 :             dx6 = s[8];
; 2049 :             stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, 0);

	movss	xmm0, DWORD PTR _s$[ebp+16]
	sub	esp, 24					; 00000018H
	mov	DWORD PTR [esp+20], esi
	mov	esi, DWORD PTR _c$[ebp]
	movss	DWORD PTR [esp+16], xmm0
	movss	xmm0, DWORD PTR _s$[ebp+12]
	movss	DWORD PTR [esp+12], xmm0
	movss	xmm0, DWORD PTR _s$[ebp+4]
	movss	DWORD PTR [esp+8], xmm7
	movss	DWORD PTR [esp+4], xmm0
	movss	DWORD PTR [esp], xmm6
	push	esi
	call	?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2050 :             stbtt__csctx_rccurve_to(c, dx4, 0, dx5, dy5, dx6, -(dy1+dy2+dy5));

	movss	xmm0, DWORD PTR _s$[ebp+12]
	add	esp, 4
	addss	xmm0, DWORD PTR _s$[ebp+4]
	movss	xmm1, DWORD PTR _s$[ebp+28]
	addss	xmm0, xmm1
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esp+20], xmm0
	movss	xmm0, DWORD PTR _s$[ebp+32]
	movss	DWORD PTR [esp+16], xmm0
	movss	xmm0, DWORD PTR _s$[ebp+24]
	movss	DWORD PTR [esp+12], xmm1
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _s$[ebp+20]
	mov	DWORD PTR [esp+4], 0
	movss	DWORD PTR [esp], xmm0
	push	esi
	call	?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
	mov	ecx, DWORD PTR _clear_stack$1$[ebp]
	xor	eax, eax
	add	esp, 28					; 0000001cH
	test	ecx, ecx
	cmove	eax, edi
	mov	edi, eax
	mov	DWORD PTR _sp$1$[ebp], edi

; 2094 :          clear_stack = 0;
; 2095 :          break;
; 2096 :       }
; 2097 :       if (clear_stack) sp = 0;
; 2098 :    }

	jmp	$LL2@stbtt__run
$LN84@stbtt__run:

; 2051 :             break;
; 2052 : 
; 2053 :          case 0x25: // flex1
; 2054 :             if (sp < 11) return STBTT__CSERR("flex1 stack");

	cmp	edi, 11					; 0000000bH
	jl	$LN3@stbtt__run

; 2055 :             dx1 = s[0];
; 2056 :             dy1 = s[1];
; 2057 :             dx2 = s[2];
; 2058 :             dy2 = s[3];
; 2059 :             dx3 = s[4];
; 2060 :             dy3 = s[5];
; 2061 :             dx4 = s[6];
; 2062 :             dy4 = s[7];
; 2063 :             dx5 = s[8];
; 2064 :             dy5 = s[9];
; 2065 :             dx6 = dy6 = s[10];
; 2066 :             dx = dx1+dx2+dx3+dx4+dx5;

	movss	xmm4, DWORD PTR _s$[ebp]
	movss	xmm5, DWORD PTR _s$[ebp+8]
	movaps	xmm2, xmm4

; 2067 :             dy = dy1+dy2+dy3+dy4+dy5;

	movss	xmm3, DWORD PTR _s$[ebp+12]
	addss	xmm2, xmm5
	addss	xmm3, DWORD PTR _s$[ebp+4]
	movss	xmm6, DWORD PTR _s$[ebp+40]
	movaps	xmm7, xmm6
	addss	xmm2, DWORD PTR _s$[ebp+16]
	addss	xmm3, DWORD PTR _s$[ebp+20]
	addss	xmm2, DWORD PTR _s$[ebp+24]
	addss	xmm3, DWORD PTR _s$[ebp+28]
	addss	xmm2, DWORD PTR _s$[ebp+32]
	addss	xmm3, DWORD PTR _s$[ebp+36]

; 2068 :             if (STBTT_fabs(dx) > STBTT_fabs(dy))

	cvtps2pd xmm1, xmm2
	cvtps2pd xmm0, xmm3
	andps	xmm1, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	andps	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	comisd	xmm1, xmm0
	jbe	SHORT $LN86@stbtt__run

; 2069 :                dy6 = -dy;

	movaps	xmm6, xmm3
	xorps	xmm6, DWORD PTR __xmm@80000000800000008000000080000000

; 2070 :             else

	jmp	SHORT $LN87@stbtt__run
$LN86@stbtt__run:

; 2071 :                dx6 = -dx;

	movaps	xmm7, xmm2
	xorps	xmm7, DWORD PTR __xmm@80000000800000008000000080000000
$LN87@stbtt__run:

; 2072 :             stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);

	movss	xmm0, DWORD PTR _s$[ebp+20]
	sub	esp, 24					; 00000018H
	mov	esi, DWORD PTR _c$[ebp]
	movss	DWORD PTR [esp+20], xmm0
	movss	xmm0, DWORD PTR _s$[ebp+16]
	movss	DWORD PTR [esp+16], xmm0
	movss	xmm0, DWORD PTR _s$[ebp+12]
	movss	DWORD PTR [esp+12], xmm0
	movss	xmm0, DWORD PTR _s$[ebp+4]
	movss	DWORD PTR [esp+8], xmm5
	movss	DWORD PTR [esp+4], xmm0
	movss	DWORD PTR [esp], xmm4
	push	esi
	call	?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to

; 2073 :             stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);

	movups	xmm0, XMMWORD PTR _s$[ebp+24]
	add	esp, 4
	movss	DWORD PTR [esp+20], xmm6
	movss	DWORD PTR [esp+16], xmm7
	movups	XMMWORD PTR [esp], xmm0
	push	esi
	call	?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z ; stbtt__csctx_rccurve_to
	mov	ecx, DWORD PTR _clear_stack$1$[ebp]
	xor	eax, eax

; 2074 :             break;
; 2075 : 
; 2076 :          default:
; 2077 :             return STBTT__CSERR("unimplemented");
; 2078 :          }
; 2079 :       } break;

	movss	xmm6, DWORD PTR _s$[ebp]
	add	esp, 28					; 0000001cH
	movss	xmm7, DWORD PTR _s$[ebp+8]
	test	ecx, ecx
	cmove	eax, edi
	mov	edi, eax
	mov	DWORD PTR _sp$1$[ebp], edi

; 2094 :          clear_stack = 0;
; 2095 :          break;
; 2096 :       }
; 2097 :       if (clear_stack) sp = 0;
; 2098 :    }

	jmp	$LL2@stbtt__run
$LN89@stbtt__run:
	cmp	edx, 255				; 000000ffH

; 2080 : 
; 2081 :       default:
; 2082 :          if (b0 != 255 && b0 != 28 && (b0 < 32 || b0 > 254))

	je	SHORT $LN153@stbtt__run
	cmp	edx, 28					; 0000001cH
	je	SHORT $LN92@stbtt__run
	cmp	edx, 32					; 00000020H
	jb	$LN3@stbtt__run
	cmp	edx, 254				; 000000feH
	ja	$LN3@stbtt__run
$LN92@stbtt__run:

; 2088 :          } else {
; 2089 :             stbtt__buf_skip(&b, -1);

	lea	eax, DWORD PTR _b$[ebp]
	push	-1
	push	eax
	call	?stbtt__buf_skip@@YAXPAUstbtt__buf@@H@Z	; stbtt__buf_skip

; 2090 :             f = (float)(stbtt_int16)stbtt__cff_int(&b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	?stbtt__cff_int@@YAIPAUstbtt__buf@@@Z	; stbtt__cff_int
	cwde
	add	esp, 12					; 0000000cH
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	jmp	SHORT $LN93@stbtt__run
$LN153@stbtt__run:

; 2083 :             return STBTT__CSERR("reserved operator");
; 2084 : 
; 2085 :          // push immediate
; 2086 :          if (b0 == 255) {
; 2087 :             f = (float)stbtt__buf_get32(&b) / 0x10000;

	lea	eax, DWORD PTR _b$[ebp]
	push	4
	push	eax
	call	?stbtt__buf_get@@YAIPAUstbtt__buf@@H@Z	; stbtt__buf_get
	add	esp, 8
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@37800000
$LN93@stbtt__run:

; 2091 :          }
; 2092 :          if (sp >= 48) return STBTT__CSERR("push stack overflow");

	cmp	edi, 48					; 00000030H
	jge	$LN3@stbtt__run

; 2093 :          s[sp++] = f;

	movss	DWORD PTR _s$[ebp+edi*4], xmm0
	xor	ecx, ecx
	movss	xmm6, DWORD PTR _s$[ebp]
	inc	edi
	movss	xmm7, DWORD PTR _s$[ebp+8]
	xor	eax, eax
	test	ecx, ecx
	cmove	eax, edi
	mov	edi, eax
	mov	DWORD PTR _sp$1$[ebp], edi

; 2094 :          clear_stack = 0;
; 2095 :          break;
; 2096 :       }
; 2097 :       if (clear_stack) sp = 0;
; 2098 :    }

	jmp	$LL2@stbtt__run
$LN76@stbtt__run:

; 1992 :          clear_stack = 0;
; 1993 :          break;
; 1994 : 
; 1995 :       case 0x0E: // endchar
; 1996 :          stbtt__csctx_close_shape(c);

	push	DWORD PTR _c$[ebp]
	call	?stbtt__csctx_close_shape@@YAXPAUstbtt__csctx@@@Z ; stbtt__csctx_close_shape
	add	esp, 4

; 1997 :          return 1;

	mov	eax, 1

; 2100 : 
; 2101 : #undef STBTT__CSERR
; 2102 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN169@stbtt__run:
	DD	$LN31@stbtt__run
	DD	$LN34@stbtt__run
	DD	$LN38@stbtt__run
	DD	$LN43@stbtt__run
	DD	$LN40@stbtt__run
	DD	$LN54@stbtt__run
	DD	$LN67@stbtt__run
	DD	$LN74@stbtt__run
	DD	$LN77@stbtt__run
	DD	$LN76@stbtt__run
	DD	$LN29@stbtt__run
	DD	$LN32@stbtt__run
	DD	$LN36@stbtt__run
	DD	$LN56@stbtt__run
	DD	$LN59@stbtt__run
	DD	$LN62@stbtt__run
	DD	$LN68@stbtt__run
	DD	$LN50@stbtt__run
	DD	$LN47@stbtt__run
	DD	$LN89@stbtt__run
$LN154@stbtt__run:
	DB	0
	DB	19					; 00000013H
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	19					; 00000013H
	DB	6
	DB	7
	DB	8
	DB	19					; 00000013H
	DB	9
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	19					; 00000013H
	DB	0
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	0
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	19					; 00000013H
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	18					; 00000012H
	npad	1
$LN170@stbtt__run:
	DD	$LN78@stbtt__run
	DD	$LN80@stbtt__run
	DD	$LN82@stbtt__run
	DD	$LN84@stbtt__run
?stbtt__run_charstring@@YAHPBUstbtt_fontinfo@@HPAUstbtt__csctx@@@Z ENDP ; stbtt__run_charstring
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
$T1 = -32						; size = 12
$T2 = -20						; size = 12
_fdselect$ = -20					; size = 12
_v$1$ = -8						; size = 4
_nranges$1$ = -4					; size = 4
$T3 = 8							; size = 4
_info$ = 12						; size = 4
_glyph_index$ = 16					; size = 4
?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PBUstbtt_fontinfo@@H@Z PROC ; stbtt__cid_get_glyph_subrs

; 1818 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	ebx

; 1819 :    stbtt__buf fdselect = info->fdselect;

	mov	ebx, DWORD PTR _info$[ebp]
	push	esi
	push	edi

; 1820 :    int nranges, start, end, v, fmt, fdselector = -1, i;
; 1821 : 
; 1822 :    stbtt__buf_seek(&fdselect, 0);

	push	0
	mov	eax, DWORD PTR [ebx+116]
	movq	xmm0, QWORD PTR [ebx+108]
	mov	DWORD PTR _fdselect$[ebp+8], eax
	lea	eax, DWORD PTR _fdselect$[ebp]
	push	eax
	movq	QWORD PTR _fdselect$[ebp], xmm0
	call	?stbtt__buf_seek@@YAXPAUstbtt__buf@@H@Z	; stbtt__buf_seek

; 1823 :    fmt = stbtt__buf_get8(&fdselect);

	lea	eax, DWORD PTR _fdselect$[ebp]
	push	eax
	call	?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z	; stbtt__buf_get8
	movzx	eax, al
	add	esp, 12					; 0000000cH
	test	eax, eax

; 1824 :    if (fmt == 0) {

	jne	SHORT $LN5@stbtt__cid

; 1825 :       // untested
; 1826 :       stbtt__buf_skip(&fdselect, glyph_index);

	push	DWORD PTR _glyph_index$[ebp]
	lea	eax, DWORD PTR _fdselect$[ebp]
	push	eax
	call	?stbtt__buf_skip@@YAXPAUstbtt__buf@@H@Z	; stbtt__buf_skip

; 1827 :       fdselector = stbtt__buf_get8(&fdselect);

	lea	eax, DWORD PTR _fdselect$[ebp]
	push	eax
	call	?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z	; stbtt__buf_get8
	add	esp, 12					; 0000000cH
	movzx	eax, al
	jmp	SHORT $LN16@stbtt__cid
$LN5@stbtt__cid:
	cmp	eax, 3

; 1828 :    } else if (fmt == 3) {

	jne	SHORT $LN19@stbtt__cid

; 1829 :       nranges = stbtt__buf_get16(&fdselect);

	lea	eax, DWORD PTR _fdselect$[ebp]
	push	2
	push	eax
	call	?stbtt__buf_get@@YAIPAUstbtt__buf@@H@Z	; stbtt__buf_get
	mov	edi, eax

; 1830 :       start = stbtt__buf_get16(&fdselect);

	lea	eax, DWORD PTR _fdselect$[ebp]
	push	2
	push	eax
	mov	DWORD PTR _nranges$1$[ebp], edi
	call	?stbtt__buf_get@@YAIPAUstbtt__buf@@H@Z	; stbtt__buf_get
	add	esp, 16					; 00000010H

; 1831 :       for (i = 0; i < nranges; i++) {

	xor	esi, esi
	mov	ebx, eax
	test	edi, edi
	jle	SHORT $LN18@stbtt__cid
	mov	edi, DWORD PTR _glyph_index$[ebp]
$LL4@stbtt__cid:

; 1832 :          v = stbtt__buf_get8(&fdselect);

	lea	eax, DWORD PTR _fdselect$[ebp]
	push	eax
	call	?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z	; stbtt__buf_get8
	movzx	eax, al
	mov	DWORD PTR _v$1$[ebp], eax

; 1833 :          end = stbtt__buf_get16(&fdselect);

	lea	eax, DWORD PTR _fdselect$[ebp]
	push	2
	push	eax
	call	?stbtt__buf_get@@YAIPAUstbtt__buf@@H@Z	; stbtt__buf_get
	add	esp, 12					; 0000000cH

; 1834 :          if (glyph_index >= start && glyph_index < end) {

	cmp	edi, ebx
	jl	SHORT $LN8@stbtt__cid
	cmp	edi, eax
	jl	SHORT $LN12@stbtt__cid
$LN8@stbtt__cid:

; 1831 :       for (i = 0; i < nranges; i++) {

	inc	esi

; 1836 :             break;
; 1837 :          }
; 1838 :          start = end;

	mov	ebx, eax
	cmp	esi, DWORD PTR _nranges$1$[ebp]
	jl	SHORT $LL4@stbtt__cid
$LN18@stbtt__cid:
	mov	ebx, DWORD PTR _info$[ebp]
$LN19@stbtt__cid:
	or	eax, -1
$LN16@stbtt__cid:

; 1839 :       }
; 1840 :    }
; 1841 :    if (fdselector == -1) stbtt__new_buf(NULL, 0);
; 1842 :    return stbtt__get_subrs(info->cff, stbtt__cff_index_get(info->fontdicts, fdselector));

	movq	xmm0, QWORD PTR [ebx+96]
	push	eax
	mov	eax, DWORD PTR [ebx+104]
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z ; stbtt__cff_index_get
	add	esp, 8
	mov	ecx, esp
	sub	esp, 12					; 0000000cH
	movq	xmm0, QWORD PTR [eax]
	mov	eax, DWORD PTR [eax+8]
	movq	QWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR [ebx+48]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	eax, DWORD PTR [ebx+56]
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z ; stbtt__get_subrs
	mov	edx, DWORD PTR $T3[ebp]
	add	esp, 28					; 0000001cH
	movq	xmm0, QWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, edx

; 1843 : }

	pop	edi
	pop	esi
	movq	QWORD PTR [edx], xmm0
	mov	DWORD PTR [edx+8], ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@stbtt__cid:

; 1835 :             fdselector = v;

	mov	eax, DWORD PTR _v$1$[ebp]
	mov	ebx, DWORD PTR _info$[ebp]
	jmp	SHORT $LN16@stbtt__cid
?stbtt__cid_get_glyph_subrs@@YA?AUstbtt__buf@@PBUstbtt_fontinfo@@H@Z ENDP ; stbtt__cid_get_glyph_subrs
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
$T1 = -12						; size = 12
$T2 = -12						; size = 12
$T3 = 8							; size = 4
_idx$ = 12						; size = 12
_n$ = 24						; size = 4
?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z PROC		; stbtt__get_subr

; 1804 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1805 :    int count = stbtt__cff_index_count(&idx);

	lea	eax, DWORD PTR _idx$[ebp]
	push	eax
	call	?stbtt__cff_index_count@@YAHPAUstbtt__buf@@@Z ; stbtt__cff_index_count
	mov	edx, eax
	add	esp, 4

; 1806 :    int bias = 107;

	mov	ecx, 107				; 0000006bH

; 1807 :    if (count >= 33900)

	cmp	edx, 33900				; 0000846cH
	jl	SHORT $LN2@stbtt__get

; 1808 :       bias = 32768;

	mov	ecx, 32768				; 00008000H
	jmp	SHORT $LN4@stbtt__get
$LN2@stbtt__get:

; 1809 :    else if (count >= 1240)

	cmp	edx, 1240				; 000004d8H
	mov	eax, 1131				; 0000046bH
	cmovge	ecx, eax
$LN4@stbtt__get:

; 1810 :       bias = 1131;
; 1811 :    n += bias;

	mov	eax, DWORD PTR _n$[ebp]
	add	eax, ecx

; 1812 :    if (n < 0 || n >= count)

	js	SHORT $LN6@stbtt__get
	cmp	eax, edx
	jge	SHORT $LN6@stbtt__get

; 1814 :    return stbtt__cff_index_get(idx, n);

	movq	xmm0, QWORD PTR _idx$[ebp]
	push	eax
	mov	eax, DWORD PTR _idx$[ebp+8]
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z ; stbtt__cff_index_get
	add	esp, 20					; 00000014H
	jmp	SHORT $LN8@stbtt__get
$LN6@stbtt__get:

; 1813 :       return stbtt__new_buf(NULL, 0);

	push	0
	lea	eax, DWORD PTR $T2[ebp]
	push	0
	push	eax
	call	?stbtt__new_buf@@YA?AUstbtt__buf@@PBXI@Z ; stbtt__new_buf
	add	esp, 12					; 0000000cH
$LN8@stbtt__get:
	mov	edx, DWORD PTR $T3[ebp]
	movq	xmm0, QWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, edx
	movq	QWORD PTR [edx], xmm0
	mov	DWORD PTR [edx+8], ecx

; 1815 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?stbtt__get_subr@@YA?AUstbtt__buf@@U1@H@Z ENDP		; stbtt__get_subr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_dx1$ = 12						; size = 4
_dy1$ = 16						; size = 4
_dx2$ = 20						; size = 4
_dy2$ = 24						; size = 4
_dx3$ = 28						; size = 4
_dy3$ = 32						; size = 4
?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z PROC ; stbtt__csctx_rccurve_to

; 1793 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1794 :    float cx1 = ctx->x + dx1;

	mov	ecx, DWORD PTR _ctx$[ebp]

; 1795 :    float cy1 = ctx->y + dy1;

	movss	xmm4, DWORD PTR _dy1$[ebp]
	movss	xmm5, DWORD PTR _dx1$[ebp]
	addss	xmm4, DWORD PTR [ecx+20]
	addss	xmm5, DWORD PTR [ecx+16]

; 1796 :    float cx2 = cx1 + dx2;
; 1797 :    float cy2 = cy1 + dy2;

	movaps	xmm0, xmm4
	addss	xmm0, DWORD PTR _dy2$[ebp]
	movaps	xmm2, xmm5
	addss	xmm2, DWORD PTR _dx2$[ebp]

; 1798 :    ctx->x = cx2 + dx3;
; 1799 :    ctx->y = cy2 + dy3;
; 1800 :    stbtt__csctx_v(ctx, STBTT_vcubic, (int)ctx->x, (int)ctx->y, (int)cx1, (int)cy1, (int)cx2, (int)cy2);

	cvttss2si eax, xmm0
	movaps	xmm1, xmm0
	movaps	xmm3, xmm2
	push	eax
	addss	xmm1, DWORD PTR _dy3$[ebp]
	cvttss2si eax, xmm2
	addss	xmm3, DWORD PTR _dx3$[ebp]
	push	eax
	cvttss2si eax, xmm4
	movss	DWORD PTR [ecx+16], xmm3
	push	eax
	cvttss2si eax, xmm5
	movss	DWORD PTR [ecx+20], xmm1
	push	eax
	cvttss2si eax, xmm1
	push	eax
	cvttss2si eax, xmm3
	push	eax
	push	4
	push	ecx
	call	?stbtt__csctx_v@@YAXPAUstbtt__csctx@@EHHHHHH@Z ; stbtt__csctx_v
	add	esp, 32					; 00000020H

; 1801 : }

	pop	ebp
	ret	0
?stbtt__csctx_rccurve_to@@YAXPAUstbtt__csctx@@MMMMMM@Z ENDP ; stbtt__csctx_rccurve_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_dx$ = 12						; size = 4
_dy$ = 16						; size = 4
?stbtt__csctx_rline_to@@YAXPAUstbtt__csctx@@MM@Z PROC	; stbtt__csctx_rline_to

; 1786 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1787 :    ctx->x += dx;

	mov	ecx, DWORD PTR _ctx$[ebp]

; 1788 :    ctx->y += dy;

	movss	xmm0, DWORD PTR _dy$[ebp]
	movss	xmm1, DWORD PTR _dx$[ebp]

; 1789 :    stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);

	push	0
	addss	xmm0, DWORD PTR [ecx+20]
	addss	xmm1, DWORD PTR [ecx+16]
	push	0
	push	0
	push	0
	cvttss2si eax, xmm0
	movss	DWORD PTR [ecx+16], xmm1
	push	eax
	cvttss2si eax, xmm1
	movss	DWORD PTR [ecx+20], xmm0
	push	eax
	push	2
	push	ecx
	call	?stbtt__csctx_v@@YAXPAUstbtt__csctx@@EHHHHHH@Z ; stbtt__csctx_v
	add	esp, 32					; 00000020H

; 1790 : }

	pop	ebp
	ret	0
?stbtt__csctx_rline_to@@YAXPAUstbtt__csctx@@MM@Z ENDP	; stbtt__csctx_rline_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
_dx$ = 12						; size = 4
_dy$ = 16						; size = 4
?stbtt__csctx_rmove_to@@YAXPAUstbtt__csctx@@MM@Z PROC	; stbtt__csctx_rmove_to

; 1778 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 1779 :    stbtt__csctx_close_shape(ctx);

	mov	esi, DWORD PTR _ctx$[ebp]
	push	esi
	call	?stbtt__csctx_close_shape@@YAXPAUstbtt__csctx@@@Z ; stbtt__csctx_close_shape

; 1780 :    ctx->first_x = ctx->x = ctx->x + dx;
; 1781 :    ctx->first_y = ctx->y = ctx->y + dy;

	movss	xmm0, DWORD PTR [esi+20]
	addss	xmm0, DWORD PTR _dy$[ebp]
	movss	xmm1, DWORD PTR _dx$[ebp]
	addss	xmm1, DWORD PTR [esi+16]

; 1782 :    stbtt__csctx_v(ctx, STBTT_vmove, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);

	push	0
	push	0
	cvttss2si eax, xmm0
	push	0
	push	0
	movss	DWORD PTR [esi+16], xmm1
	push	eax
	cvttss2si eax, xmm1
	movss	DWORD PTR [esi+8], xmm1
	push	eax
	push	1
	push	esi
	movss	DWORD PTR [esi+20], xmm0
	movss	DWORD PTR [esi+12], xmm0
	call	?stbtt__csctx_v@@YAXPAUstbtt__csctx@@EHHHHHH@Z ; stbtt__csctx_v
	add	esp, 36					; 00000024H
	pop	esi

; 1783 : }

	pop	ebp
	ret	0
?stbtt__csctx_rmove_to@@YAXPAUstbtt__csctx@@MM@Z ENDP	; stbtt__csctx_rmove_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
?stbtt__csctx_close_shape@@YAXPAUstbtt__csctx@@@Z PROC	; stbtt__csctx_close_shape

; 1772 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1773 :    if (ctx->first_x != ctx->x || ctx->first_y != ctx->y)

	mov	ecx, DWORD PTR _ctx$[ebp]
	movss	xmm1, DWORD PTR [ecx+8]
	ucomiss	xmm1, DWORD PTR [ecx+16]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@stbtt__csc
	movss	xmm0, DWORD PTR [ecx+12]
	ucomiss	xmm0, DWORD PTR [ecx+20]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@stbtt__csc
$LN3@stbtt__csc:

; 1774 :       stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->first_x, (int)ctx->first_y, 0, 0, 0, 0);

	cvttss2si eax, DWORD PTR [ecx+12]
	push	0
	push	0
	push	0
	push	0
	push	eax
	cvttss2si eax, xmm1
	push	eax
	push	2
	push	ecx
	call	?stbtt__csctx_v@@YAXPAUstbtt__csctx@@EHHHHHH@Z ; stbtt__csctx_v
	add	esp, 32					; 00000020H
$LN2@stbtt__csc:

; 1775 : }

	pop	ebp
	ret	0
?stbtt__csctx_close_shape@@YAXPAUstbtt__csctx@@@Z ENDP	; stbtt__csctx_close_shape
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_c$ = 8							; size = 4
_type$ = 12						; size = 1
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_cx$ = 24						; size = 4
_cy$ = 28						; size = 4
_cx1$ = 32						; size = 4
_cy1$ = 36						; size = 4
?stbtt__csctx_v@@YAXPAUstbtt__csctx@@EHHHHHH@Z PROC	; stbtt__csctx_v

; 1756 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 1757 :    if (c->bounds) {

	mov	esi, DWORD PTR _c$[ebp]
	cmp	DWORD PTR [esi], 0
	je	SHORT $LN2@stbtt__csc

; 1758 :       stbtt__track_vertex(c, x, y);

	push	DWORD PTR _y$[ebp]
	push	DWORD PTR _x$[ebp]
	push	esi
	call	?stbtt__track_vertex@@YAXPAUstbtt__csctx@@HH@Z ; stbtt__track_vertex
	add	esp, 12					; 0000000cH

; 1759 :       if (type == STBTT_vcubic) {

	cmp	BYTE PTR _type$[ebp], 4
	jne	SHORT $LN6@stbtt__csc

; 1760 :          stbtt__track_vertex(c, cx, cy);

	push	DWORD PTR _cy$[ebp]
	push	DWORD PTR _cx$[ebp]
	push	esi
	call	?stbtt__track_vertex@@YAXPAUstbtt__csctx@@HH@Z ; stbtt__track_vertex

; 1761 :          stbtt__track_vertex(c, cx1, cy1);

	push	DWORD PTR _cy1$[ebp]
	push	DWORD PTR _cx1$[ebp]
	push	esi
	call	?stbtt__track_vertex@@YAXPAUstbtt__csctx@@HH@Z ; stbtt__track_vertex

; 1762 :       }
; 1763 :    } else {
; 1764 :       stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);

	add	esp, 24					; 00000018H

; 1767 :    }
; 1768 :    c->num_vertices++;

	inc	DWORD PTR [esi+44]
	pop	esi

; 1769 : }

	pop	ebp
	ret	0
$LN2@stbtt__csc:

; 1762 :       }
; 1763 :    } else {
; 1764 :       stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);

	push	DWORD PTR _cy$[ebp]
	mov	eax, DWORD PTR [esi+44]
	push	DWORD PTR _cx$[ebp]
	push	DWORD PTR _y$[ebp]
	lea	ecx, DWORD PTR [eax*8]
	push	DWORD PTR _x$[ebp]
	sub	ecx, eax
	mov	eax, DWORD PTR [esi+40]
	push	DWORD PTR _type$[ebp]
	lea	eax, DWORD PTR [eax+ecx*2]
	push	eax
	call	?stbtt_setvertex@@YAXPAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex

; 1765 :       c->pvertices[c->num_vertices].cx1 = (stbtt_int16) cx1;

	mov	eax, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR [esi+40]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	ax, WORD PTR _cx1$[ebp]
	mov	WORD PTR [ecx+edx*2+8], ax

; 1766 :       c->pvertices[c->num_vertices].cy1 = (stbtt_int16) cy1;

	mov	eax, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR [esi+40]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	ax, WORD PTR _cy1$[ebp]
	add	esp, 24					; 00000018H
	mov	WORD PTR [ecx+edx*2+10], ax
$LN6@stbtt__csc:

; 1767 :    }
; 1768 :    c->num_vertices++;

	inc	DWORD PTR [esi+44]
	pop	esi

; 1769 : }

	pop	ebp
	ret	0
?stbtt__csctx_v@@YAXPAUstbtt__csctx@@EHHHHHH@Z ENDP	; stbtt__csctx_v
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_c$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
?stbtt__track_vertex@@YAXPAUstbtt__csctx@@HH@Z PROC	; stbtt__track_vertex

; 1747 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1748 :    if (x > c->max_x || !c->started) c->max_x = x;

	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	cmp	ecx, DWORD PTR [eax+28]
	jg	SHORT $LN3@stbtt__tra
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN2@stbtt__tra
$LN3@stbtt__tra:
	mov	DWORD PTR [eax+28], ecx
$LN2@stbtt__tra:

; 1749 :    if (y > c->max_y || !c->started) c->max_y = y;

	mov	edx, DWORD PTR _y$[ebp]
	cmp	edx, DWORD PTR [eax+36]
	jg	SHORT $LN5@stbtt__tra
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN4@stbtt__tra
$LN5@stbtt__tra:
	mov	DWORD PTR [eax+36], edx
$LN4@stbtt__tra:

; 1750 :    if (x < c->min_x || !c->started) c->min_x = x;

	cmp	ecx, DWORD PTR [eax+24]
	jl	SHORT $LN7@stbtt__tra
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN6@stbtt__tra
$LN7@stbtt__tra:
	mov	DWORD PTR [eax+24], ecx
$LN6@stbtt__tra:

; 1751 :    if (y < c->min_y || !c->started) c->min_y = y;

	cmp	edx, DWORD PTR [eax+32]
	jl	SHORT $LN9@stbtt__tra
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN12@stbtt__tra
$LN9@stbtt__tra:
	mov	DWORD PTR [eax+32], edx
$LN12@stbtt__tra:

; 1752 :    c->started = 1;

	mov	DWORD PTR [eax+4], 1

; 1753 : }

	pop	ebp
	ret	0
?stbtt__track_vertex@@YAXPAUstbtt__csctx@@HH@Z ENDP	; stbtt__track_vertex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_mtx$1 = -84						; size = 24
_m$1$ = -60						; size = 4
_tmp$1$ = -60						; size = 4
_next_move$1$ = -60					; size = 4
_data$1$ = -60						; size = 4
_n$1$ = -56						; size = 4
tv1725 = -56						; size = 4
tv1718 = -56						; size = 4
_flags$1$ = -52						; size = 4
_start_off$1$ = -52					; size = 4
_gidx$1$ = -48						; size = 4
_comp_num_verts$1$ = -48				; size = 4
_scx$1$ = -48						; size = 4
_g$1$ = -48						; size = 4
_scy$1$ = -44						; size = 4
_j$1$ = -40						; size = 4
_x$2$ = -36						; size = 4
_comp_verts$2 = -36					; size = 4
_mtx$3$ = -32						; size = 4
_sx$1$ = -32						; size = 4
_mtx$4$ = -28						; size = 4
_cx$1$ = -28						; size = 4
_mtx$5$ = -24						; size = 4
_cy$1$ = -24						; size = 4
_mtx$6$ = -20						; size = 4
_i$1$ = -20						; size = 4
_mtx$1$ = -16						; size = 4
_y$2$ = -16						; size = 4
_mtx$2$ = -12						; size = 4
_was_off$1$ = -12					; size = 4
_vertices$1$ = -8					; size = 4
_n$1$ = -4						; size = 4
_off$1$ = 8						; size = 4
_info$ = 8						; size = 4
_flags$4$ = 11						; size = 1
_glyph_index$ = 12					; size = 4
_pvertices$ = 16					; size = 4
?stbtt__GetGlyphShapeTT@@YAHPBUstbtt_fontinfo@@HPAPAUstbtt_vertex@@@Z PROC ; stbtt__GetGlyphShapeTT

; 1507 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H

; 1508 :    stbtt_int16 numberOfContours;
; 1509 :    stbtt_uint8 *endPtsOfContours;
; 1510 :    stbtt_uint8 *data = info->data;

	mov	eax, DWORD PTR _info$[ebp]
	push	ebx
	push	esi
	push	edi

; 1511 :    stbtt_vertex *vertices=0;
; 1512 :    int num_vertices=0;
; 1513 :    int g = stbtt__GetGlyfOffset(info, glyph_index);

	push	DWORD PTR _glyph_index$[ebp]
	mov	esi, DWORD PTR [eax+4]
	xor	ebx, ebx
	push	eax
	mov	DWORD PTR _data$1$[ebp], esi
	xor	edi, edi
	call	?stbtt__GetGlyfOffset@@YAHPBUstbtt_fontinfo@@H@Z ; stbtt__GetGlyfOffset

; 1514 : 
; 1515 :    *pvertices = NULL;

	mov	ecx, DWORD PTR _pvertices$[ebp]
	add	esp, 8
	mov	DWORD PTR _g$1$[ebp], eax
	mov	DWORD PTR [ecx], ebx

; 1516 : 
; 1517 :    if (g < 0) return 0;

	test	eax, eax
	js	$LN58@stbtt__Get

; 1518 : 
; 1519 :    numberOfContours = ttSHORT(data + g);

	add	esi, eax
	push	esi
	mov	DWORD PTR tv1725[ebp], esi
	call	?ttSHORT@@YAFPAE@Z			; ttSHORT
	movzx	eax, ax
	add	esp, 4

; 1520 : 
; 1521 :    if (numberOfContours > 0) {

	test	ax, ax
	jle	$LN20@stbtt__Get

; 1522 :       stbtt_uint8 flags=0,flagcount;
; 1523 :       stbtt_int32 ins, i,j=0,m,n, next_move, was_off=0, off, start_off=0;

	mov	DWORD PTR _j$1$[ebp], edi
	xor	bl, bl
	mov	DWORD PTR _was_off$1$[ebp], edi
	mov	DWORD PTR _start_off$1$[ebp], edi

; 1524 :       stbtt_int32 x,y,cx,cy,sx,sy, scx,scy;
; 1525 :       stbtt_uint8 *points;
; 1526 :       endPtsOfContours = (data + g + 10);
; 1527 :       ins = ttUSHORT(data + g + 10 + numberOfContours * 2);

	mov	edi, DWORD PTR _data$1$[ebp]
	movsx	esi, ax
	lea	eax, DWORD PTR [edi+10]
	lea	eax, DWORD PTR [eax+esi*2]
	add	eax, DWORD PTR _g$1$[ebp]
	push	eax
	call	?ttUSHORT@@YAGPAE@Z			; ttUSHORT
	movzx	eax, ax

; 1528 :       points = data + g + 10 + numberOfContours * 2 + 2 + ins;

	add	edi, 12					; 0000000cH
	add	edi, eax

; 1529 : 
; 1530 :       n = 1+ttUSHORT(endPtsOfContours + numberOfContours*2-2);

	mov	eax, DWORD PTR tv1725[ebp]
	lea	eax, DWORD PTR [eax+esi*2]
	add	eax, 8
	lea	edi, DWORD PTR [edi+esi*2]
	add	edi, DWORD PTR _g$1$[ebp]
	push	eax
	call	?ttUSHORT@@YAGPAE@Z			; ttUSHORT
	movzx	eax, ax
	inc	eax
	mov	DWORD PTR _n$1$[ebp], eax

; 1531 : 
; 1532 :       m = n + 2*numberOfContours;  // a loose bound on how many vertices we might need

	lea	esi, DWORD PTR [eax+esi*2]

; 1533 :       vertices = (stbtt_vertex *) STBTT_malloc(m * sizeof(vertices[0]), info->userdata);

	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi
	add	eax, eax
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	edx, eax
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _vertices$1$[ebp], edx

; 1534 :       if (vertices == 0)

	test	edx, edx
	je	$LN58@stbtt__Get

; 1538 :       flagcount=0;
; 1539 : 
; 1540 :       // in first pass, we load uninterpreted data into the allocated array
; 1541 :       // above, shifted to the end of the array so we won't overwrite it when
; 1542 :       // we create our final data starting from the front
; 1543 : 
; 1544 :       off = m - n; // starting offset for uninterpreted data, regardless of how m ends up being calculated

	mov	eax, DWORD PTR _n$1$[ebp]
	xor	cl, cl
	sub	esi, eax
	mov	DWORD PTR _next_move$1$[ebp], 0
	mov	DWORD PTR _off$1$[ebp], esi
	test	eax, eax

; 1545 : 
; 1546 :       // first load flags
; 1547 : 
; 1548 :       for (i=0; i < n; ++i) {

	je	SHORT $LN3@stbtt__Get

; 1535 :          return 0;
; 1536 : 
; 1537 :       next_move = 0;

	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi
	mov	esi, DWORD PTR _n$1$[ebp]
	add	eax, 6
	lea	eax, DWORD PTR [edx+eax*2]
	npad	3
$LL4@stbtt__Get:

; 1549 :          if (flagcount == 0) {

	test	cl, cl
	jne	SHORT $LN23@stbtt__Get

; 1550 :             flags = *points++;

	mov	bl, BYTE PTR [edi]
	inc	edi

; 1551 :             if (flags & 8)

	test	bl, 8
	je	SHORT $LN24@stbtt__Get

; 1552 :                flagcount = *points++;

	mov	cl, BYTE PTR [edi]
	inc	edi

; 1553 :          } else

	jmp	SHORT $LN24@stbtt__Get
$LN23@stbtt__Get:

; 1554 :             --flagcount;

	dec	cl
$LN24@stbtt__Get:

; 1555 :          vertices[off+i].type = flags;

	mov	BYTE PTR [eax], bl
	add	eax, 14					; 0000000eH
	sub	esi, 1
	jne	SHORT $LL4@stbtt__Get
	mov	eax, DWORD PTR _n$1$[ebp]
$LN3@stbtt__Get:

; 1556 :       }
; 1557 : 
; 1558 :       // now load x coordinates
; 1559 :       x=0;

	xor	esi, esi
	test	eax, eax

; 1560 :       for (i=0; i < n; ++i) {

	je	SHORT $LN6@stbtt__Get

; 1556 :       }
; 1557 : 
; 1558 :       // now load x coordinates
; 1559 :       x=0;

	mov	ecx, DWORD PTR _off$1$[ebp]
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	ebx, DWORD PTR [edx+eax*2]
	mov	edx, DWORD PTR _n$1$[ebp]
$LL7@stbtt__Get:

; 1561 :          flags = vertices[off+i].type;

	mov	cl, BYTE PTR [ebx+12]

; 1562 :          if (flags & 2) {

	test	cl, 2
	je	SHORT $LN26@stbtt__Get

; 1563 :             stbtt_int16 dx = *points++;

	movzx	eax, BYTE PTR [edi]
	inc	edi

; 1564 :             x += (flags & 16) ? dx : -dx; // ???

	test	cl, 16					; 00000010H
	jne	SHORT $LN65@stbtt__Get
	neg	eax
$LN65@stbtt__Get:
	add	esi, eax

; 1565 :          } else {

	jmp	SHORT $LN28@stbtt__Get
$LN26@stbtt__Get:

; 1566 :             if (!(flags & 16)) {

	test	cl, 16					; 00000010H
	jne	SHORT $LN28@stbtt__Get

; 1567 :                x = x + (stbtt_int16) (points[0]*256 + points[1]);

	movzx	ecx, BYTE PTR [edi]
	mov	eax, 256				; 00000100H
	cwde
	movsx	ecx, cx
	imul	ecx, eax
	movzx	eax, BYTE PTR [edi+1]
	add	cx, ax
	movsx	eax, cx
	add	esi, eax

; 1568 :                points += 2;

	add	edi, 2
$LN28@stbtt__Get:

; 1569 :             }
; 1570 :          }
; 1571 :          vertices[off+i].x = (stbtt_int16) x;

	mov	WORD PTR [ebx], si
	add	ebx, 14					; 0000000eH
	sub	edx, 1
	jne	SHORT $LL7@stbtt__Get
	mov	edx, DWORD PTR _vertices$1$[ebp]
	mov	eax, DWORD PTR _n$1$[ebp]
$LN6@stbtt__Get:

; 1572 :       }
; 1573 : 
; 1574 :       // now load y coordinates
; 1575 :       y=0;

	xor	esi, esi
	test	eax, eax

; 1576 :       for (i=0; i < n; ++i) {

	je	SHORT $LN9@stbtt__Get

; 1572 :       }
; 1573 : 
; 1574 :       // now load y coordinates
; 1575 :       y=0;

	mov	ecx, DWORD PTR _off$1$[ebp]
	mov	ebx, DWORD PTR _n$1$[ebp]
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	edx, DWORD PTR [edx+eax*2]
	add	edx, 2
	npad	2
$LL10@stbtt__Get:

; 1577 :          flags = vertices[off+i].type;

	mov	cl, BYTE PTR [edx+10]

; 1578 :          if (flags & 4) {

	test	cl, 4
	je	SHORT $LN29@stbtt__Get

; 1579 :             stbtt_int16 dy = *points++;

	movzx	eax, BYTE PTR [edi]
	inc	edi

; 1580 :             y += (flags & 32) ? dy : -dy; // ???

	test	cl, 32					; 00000020H
	jne	SHORT $LN67@stbtt__Get
	neg	eax
$LN67@stbtt__Get:
	add	esi, eax

; 1581 :          } else {

	jmp	SHORT $LN31@stbtt__Get
$LN29@stbtt__Get:

; 1582 :             if (!(flags & 32)) {

	test	cl, 32					; 00000020H
	jne	SHORT $LN31@stbtt__Get

; 1583 :                y = y + (stbtt_int16) (points[0]*256 + points[1]);

	movzx	ecx, BYTE PTR [edi]
	mov	eax, 256				; 00000100H
	cwde
	movsx	ecx, cx
	imul	ecx, eax
	movzx	eax, BYTE PTR [edi+1]
	add	cx, ax
	movsx	eax, cx
	add	esi, eax

; 1584 :                points += 2;

	add	edi, 2
$LN31@stbtt__Get:

; 1585 :             }
; 1586 :          }
; 1587 :          vertices[off+i].y = (stbtt_int16) y;

	mov	WORD PTR [edx], si
	add	edx, 14					; 0000000eH
	sub	ebx, 1
	jne	SHORT $LL10@stbtt__Get
$LN9@stbtt__Get:

; 1592 :       sx = sy = cx = cy = scx = scy = 0;

	xor	eax, eax
	xor	esi, esi
	xor	ecx, ecx
	mov	DWORD PTR _scy$1$[ebp], esi
	xor	edx, edx
	mov	DWORD PTR _scx$1$[ebp], esi
	xor	ebx, ebx
	mov	DWORD PTR _cy$1$[ebp], eax
	mov	DWORD PTR _cx$1$[ebp], ecx
	mov	DWORD PTR _sx$1$[ebp], edx

; 1593 :       for (i=0; i < n; ++i) {

	mov	DWORD PTR _i$1$[ebp], eax
	cmp	DWORD PTR _n$1$[ebp], eax
	jbe	$LN12@stbtt__Get

; 1588 :       }
; 1589 : 
; 1590 :       // now convert them to our format
; 1591 :       num_vertices=0;

	mov	ecx, DWORD PTR _off$1$[ebp]
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	mov	ecx, DWORD PTR _vertices$1$[ebp]
	lea	edi, DWORD PTR [ecx+eax*2]
	npad	4
$LL13@stbtt__Get:

; 1594 :          flags = vertices[off+i].type;

	mov	al, BYTE PTR [edi+12]
	mov	BYTE PTR _flags$4$[ebp], al

; 1595 :          x     = (stbtt_int16) vertices[off+i].x;

	movsx	eax, WORD PTR [edi]
	mov	DWORD PTR _x$2$[ebp], eax

; 1596 :          y     = (stbtt_int16) vertices[off+i].y;

	movsx	eax, WORD PTR [edi+2]
	mov	DWORD PTR _y$2$[ebp], eax

; 1597 : 
; 1598 :          if (next_move == i) {

	mov	eax, DWORD PTR _next_move$1$[ebp]
	cmp	eax, DWORD PTR _i$1$[ebp]
	mov	eax, DWORD PTR _x$2$[ebp]
	jne	$LN32@stbtt__Get

; 1599 :             if (i != 0)

	cmp	DWORD PTR _i$1$[ebp], 0
	je	SHORT $LN34@stbtt__Get

; 1600 :                num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);

	push	DWORD PTR _cy$1$[ebp]
	push	DWORD PTR _cx$1$[ebp]
	push	DWORD PTR _scy$1$[ebp]
	push	DWORD PTR _scx$1$[ebp]
	push	ebx
	push	edx
	push	DWORD PTR _start_off$1$[ebp]
	push	DWORD PTR _was_off$1$[ebp]
	push	esi
	push	ecx
	call	?stbtt__close_shape@@YAHPAUstbtt_vertex@@HHHHHHHHH@Z ; stbtt__close_shape
	mov	ecx, DWORD PTR _vertices$1$[ebp]
	mov	esi, eax
	mov	eax, DWORD PTR _x$2$[ebp]
	add	esp, 40					; 00000028H
$LN34@stbtt__Get:

; 1601 : 
; 1602 :             // now start the new one               
; 1603 :             start_off = !(flags & 1);

	movzx	edx, BYTE PTR _flags$4$[ebp]
	not	edx
	and	edx, 1
	mov	DWORD PTR _start_off$1$[ebp], edx

; 1604 :             if (start_off) {

	je	SHORT $LN35@stbtt__Get

; 1605 :                // if we start off with an off-curve point, then when we need to find a point on the curve
; 1606 :                // where we can start, and we need to save some state for when we wraparound.
; 1607 :                scx = x;
; 1608 :                scy = y;
; 1609 :                if (!(vertices[off+i+1].type & 1)) {

	test	BYTE PTR [edi+26], 1
	mov	edx, DWORD PTR _y$2$[ebp]

; 1610 :                   // next point is also a curve point, so interpolate an on-point curve
; 1611 :                   sx = (x + (stbtt_int32) vertices[off+i+1].x) >> 1;
; 1612 :                   sy = (y + (stbtt_int32) vertices[off+i+1].y) >> 1;

	movsx	ebx, WORD PTR [edi+16]
	mov	DWORD PTR _scx$1$[ebp], eax
	movsx	eax, WORD PTR [edi+14]
	mov	DWORD PTR _scy$1$[ebp], edx
	jne	SHORT $LN37@stbtt__Get
	add	eax, DWORD PTR _x$2$[ebp]
	add	ebx, edx
	sar	eax, 1
	sar	ebx, 1

; 1613 :                } else {

	jmp	SHORT $LN96@stbtt__Get
$LN37@stbtt__Get:

; 1614 :                   // otherwise just use the next point as our start point
; 1615 :                   sx = (stbtt_int32) vertices[off+i+1].x;
; 1616 :                   sy = (stbtt_int32) vertices[off+i+1].y;
; 1617 :                   ++i; // we're using point i+1 as the starting point, so skip it

	inc	DWORD PTR _i$1$[ebp]
	add	edi, 14					; 0000000eH

; 1618 :                }
; 1619 :             } else {

	jmp	SHORT $LN96@stbtt__Get
$LN35@stbtt__Get:

; 1620 :                sx = x;
; 1621 :                sy = y;

	mov	ebx, DWORD PTR _y$2$[ebp]
$LN96@stbtt__Get:

; 1622 :             }
; 1623 :             stbtt_setvertex(&vertices[num_vertices++], STBTT_vmove,sx,sy,0,0);

	push	0
	push	0
	push	ebx
	push	eax
	mov	DWORD PTR _sx$1$[ebp], eax
	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi
	push	1
	lea	eax, DWORD PTR [ecx+eax*2]
	push	eax
	call	?stbtt_setvertex@@YAXPAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex

; 1624 :             was_off = 0;
; 1625 :             next_move = 1 + ttUSHORT(endPtsOfContours+j*2);

	mov	ecx, DWORD PTR tv1725[ebp]
	inc	esi
	mov	eax, DWORD PTR _j$1$[ebp]
	add	ecx, 10					; 0000000aH
	mov	DWORD PTR _was_off$1$[ebp], 0
	lea	eax, DWORD PTR [ecx+eax*2]
	push	eax
	call	?ttUSHORT@@YAGPAE@Z			; ttUSHORT

; 1626 :             ++j;
; 1627 :          } else {

	mov	edx, DWORD PTR _sx$1$[ebp]
	add	esp, 28					; 0000001cH
	movzx	eax, ax
	inc	eax
	inc	DWORD PTR _j$1$[ebp]
	mov	DWORD PTR _next_move$1$[ebp], eax
	jmp	$LN11@stbtt__Get
$LN32@stbtt__Get:

; 1628 :             if (!(flags & 1)) { // if it's a curve

	test	BYTE PTR _flags$4$[ebp], 1
	jne	SHORT $LN39@stbtt__Get
	cmp	DWORD PTR _was_off$1$[ebp], 0

; 1629 :                if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint

	je	SHORT $LN41@stbtt__Get

; 1630 :                   stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+x)>>1, (cy+y)>>1, cx, cy);

	push	DWORD PTR _cy$1$[ebp]
	mov	eax, DWORD PTR _y$2$[ebp]
	add	eax, DWORD PTR _cy$1$[ebp]
	push	DWORD PTR _cx$1$[ebp]
	sar	eax, 1
	push	eax
	mov	eax, DWORD PTR _x$2$[ebp]
	add	eax, DWORD PTR _cx$1$[ebp]
	sar	eax, 1
	push	eax
	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi
	push	3
	lea	eax, DWORD PTR [ecx+eax*2]
	push	eax
	call	?stbtt_setvertex@@YAXPAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex
	mov	edx, DWORD PTR _sx$1$[ebp]
	add	esp, 24					; 00000018H
	mov	eax, DWORD PTR _x$2$[ebp]
	inc	esi
$LN41@stbtt__Get:

; 1631 :                cx = x;

	mov	DWORD PTR _cx$1$[ebp], eax

; 1632 :                cy = y;

	mov	eax, DWORD PTR _y$2$[ebp]
	mov	DWORD PTR _cy$1$[ebp], eax

; 1633 :                was_off = 1;

	mov	DWORD PTR _was_off$1$[ebp], 1

; 1634 :             } else {

	jmp	SHORT $LN11@stbtt__Get
$LN39@stbtt__Get:
	cmp	DWORD PTR _was_off$1$[ebp], 0

; 1635 :                if (was_off)

	je	SHORT $LN42@stbtt__Get

; 1636 :                   stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, x,y, cx, cy);

	push	DWORD PTR _cy$1$[ebp]
	push	DWORD PTR _cx$1$[ebp]
	push	DWORD PTR _y$2$[ebp]
	push	eax
	push	3

; 1637 :                else

	jmp	SHORT $LN97@stbtt__Get
$LN42@stbtt__Get:

; 1638 :                   stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, x,y,0,0);

	push	0
	push	0
	push	DWORD PTR _y$2$[ebp]
	push	eax
	push	2
$LN97@stbtt__Get:
	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi
	lea	eax, DWORD PTR [ecx+eax*2]
	push	eax
	call	?stbtt_setvertex@@YAXPAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex
	add	esp, 24					; 00000018H

; 1639 :                was_off = 0;

	mov	DWORD PTR _was_off$1$[ebp], 0
	inc	esi
$LN11@stbtt__Get:

; 1593 :       for (i=0; i < n; ++i) {

	mov	eax, DWORD PTR _i$1$[ebp]
	add	edi, 14					; 0000000eH
	mov	ecx, DWORD PTR _vertices$1$[ebp]
	inc	eax
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	eax, DWORD PTR _n$1$[ebp]
	jl	$LL13@stbtt__Get
	mov	eax, DWORD PTR _cy$1$[ebp]
	mov	ecx, DWORD PTR _cx$1$[ebp]
$LN12@stbtt__Get:

; 1640 :             }
; 1641 :          }
; 1642 :       }
; 1643 :       num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx,sy,scx,scy,cx,cy);

	push	eax
	push	ecx
	push	DWORD PTR _scy$1$[ebp]
	push	DWORD PTR _scx$1$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _vertices$1$[ebp]
	push	edx
	push	DWORD PTR _start_off$1$[ebp]
	push	DWORD PTR _was_off$1$[ebp]
	push	esi
	push	ebx
	call	?stbtt__close_shape@@YAHPAUstbtt_vertex@@HHHHHHHHH@Z ; stbtt__close_shape
	add	esp, 40					; 00000028H
	mov	edi, eax
$LN94@stbtt__Get:

; 1720 :       }
; 1721 :    } else if (numberOfContours < 0) {
; 1722 :       // @TODO other compound variations?
; 1723 :       STBTT_assert(0);
; 1724 :    } else {
; 1725 :       // numberOfCounters == 0, do nothing
; 1726 :    }
; 1727 : 
; 1728 :    *pvertices = vertices;

	mov	eax, DWORD PTR _pvertices$[ebp]
	mov	DWORD PTR [eax], ebx

; 1729 :    return num_vertices;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 1730 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@stbtt__Get:

; 1644 :    } else if (numberOfContours == -1) {

	cmp	ax, -1
	jne	SHORT $LN94@stbtt__Get

; 1645 :       // Compound shapes.
; 1646 :       int more = 1;
; 1647 :       stbtt_uint8 *comp = data + g + 10;

	add	esi, 10					; 0000000aH

; 1648 :       num_vertices = 0;

	xor	edi, edi

; 1649 :       vertices = 0;

	xor	ebx, ebx
	mov	DWORD PTR _vertices$1$[ebp], ebx
$LN101@stbtt__Get:
	movaps	xmm0, XMMWORD PTR __xmm@3f80000000000000000000003f800000
	movss	xmm1, DWORD PTR __real@38800000
	movups	XMMWORD PTR _mtx$1[ebp], xmm0

; 1651 :          stbtt_uint16 flags, gidx;
; 1652 :          int comp_num_verts = 0, i;
; 1653 :          stbtt_vertex *comp_verts = 0, *tmp = 0;

	mov	DWORD PTR _comp_verts$2[ebp], 0
	xorps	xmm0, xmm0

; 1654 :          float mtx[6] = {1,0,0,1,0,0}, m, n;
; 1655 :          
; 1656 :          flags = ttSHORT(comp); comp+=2;

	push	esi
	movss	DWORD PTR _mtx$1$[ebp], xmm0
	movss	DWORD PTR _mtx$2$[ebp], xmm0
	call	?ttSHORT@@YAFPAE@Z			; ttSHORT
	movzx	eax, ax
	add	esi, 2

; 1657 :          gidx = ttSHORT(comp); comp+=2;

	push	esi
	mov	DWORD PTR _flags$1$[ebp], eax
	call	?ttSHORT@@YAFPAE@Z			; ttSHORT

; 1658 : 
; 1659 :          if (flags & 2) { // XY values

	mov	ecx, DWORD PTR _flags$1$[ebp]
	add	esp, 8
	movzx	eax, ax
	add	esi, 2
	mov	DWORD PTR _gidx$1$[ebp], eax
	test	cl, 2
	je	SHORT $LN49@stbtt__Get

; 1660 :             if (flags & 1) { // shorts

	test	cl, 1
	je	SHORT $LN48@stbtt__Get

; 1661 :                mtx[4] = ttSHORT(comp); comp+=2;

	push	esi
	call	?ttSHORT@@YAFPAE@Z			; ttSHORT
	cwde
	add	esi, 2

; 1662 :                mtx[5] = ttSHORT(comp); comp+=2;

	push	esi
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR _mtx$1$[ebp], xmm0
	call	?ttSHORT@@YAFPAE@Z			; ttSHORT

; 1663 :             } else {

	mov	ecx, DWORD PTR _flags$1$[ebp]
	add	esp, 8
	cwde
	jmp	SHORT $LN98@stbtt__Get
$LN48@stbtt__Get:

; 1664 :                mtx[4] = ttCHAR(comp); comp+=1;

	movsx	eax, BYTE PTR [esi]
	movd	xmm0, eax

; 1665 :                mtx[5] = ttCHAR(comp); comp+=1;

	movsx	eax, BYTE PTR [esi+1]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR _mtx$1$[ebp], xmm0
$LN98@stbtt__Get:
	movd	xmm0, eax
	add	esi, 2
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR _mtx$2$[ebp], xmm0
$LN49@stbtt__Get:

; 1666 :             }
; 1667 :          }
; 1668 :          else {
; 1669 :             // @TODO handle matching point
; 1670 :             STBTT_assert(0);
; 1671 :          }
; 1672 :          if (flags & (1<<3)) { // WE_HAVE_A_SCALE

	test	cl, 8
	je	SHORT $LN50@stbtt__Get

; 1673 :             mtx[0] = mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;

	push	esi
	call	?ttSHORT@@YAFPAE@Z			; ttSHORT
	cwde
	add	esp, 4
	add	esi, 2
	xorps	xmm4, xmm4
	xorps	xmm0, xmm0
	movd	xmm2, eax
	cvtdq2ps xmm2, xmm2
	mulss	xmm2, xmm1
	movaps	xmm3, xmm2

; 1674 :             mtx[1] = mtx[2] = 0;

	jmp	$LN99@stbtt__Get
$LN50@stbtt__Get:

; 1675 :          } else if (flags & (1<<6)) { // WE_HAVE_AN_X_AND_YSCALE

	test	cl, 64					; 00000040H
	je	SHORT $LN52@stbtt__Get

; 1676 :             mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;

	push	esi
	call	?ttSHORT@@YAFPAE@Z			; ttSHORT
	cwde
	add	esi, 2
	xorps	xmm4, xmm4
	xorps	xmm0, xmm0

; 1677 :             mtx[1] = mtx[2] = 0;
; 1678 :             mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;

	push	esi
	movss	DWORD PTR _mtx$5$[ebp], xmm4
	movd	xmm3, eax
	cvtdq2ps xmm3, xmm3
	movss	DWORD PTR _mtx$6$[ebp], xmm0
	mulss	xmm3, xmm1
	movss	DWORD PTR _mtx$4$[ebp], xmm3
	call	?ttSHORT@@YAFPAE@Z			; ttSHORT
	cwde
	add	esp, 8
	add	esi, 2
	movd	xmm2, eax
	cvtdq2ps xmm2, xmm2
	mulss	xmm2, xmm1
	jmp	$LN100@stbtt__Get
$LN52@stbtt__Get:

; 1679 :          } else if (flags & (1<<7)) { // WE_HAVE_A_TWO_BY_TWO

	test	cl, cl
	jns	SHORT $LN95@stbtt__Get

; 1680 :             mtx[0] = ttSHORT(comp)/16384.0f; comp+=2;

	push	esi
	call	?ttSHORT@@YAFPAE@Z			; ttSHORT
	cwde
	add	esi, 2

; 1681 :             mtx[1] = ttSHORT(comp)/16384.0f; comp+=2;

	push	esi
	movd	xmm3, eax
	cvtdq2ps xmm3, xmm3
	mulss	xmm3, xmm1
	movss	DWORD PTR _mtx$4$[ebp], xmm3
	call	?ttSHORT@@YAFPAE@Z			; ttSHORT
	cwde
	add	esi, 2

; 1682 :             mtx[2] = ttSHORT(comp)/16384.0f; comp+=2;

	push	esi
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	movss	DWORD PTR _mtx$6$[ebp], xmm0
	call	?ttSHORT@@YAFPAE@Z			; ttSHORT
	cwde
	add	esi, 2

; 1683 :             mtx[3] = ttSHORT(comp)/16384.0f; comp+=2;

	push	esi
	movd	xmm4, eax
	cvtdq2ps xmm4, xmm4
	mulss	xmm4, xmm1
	movss	DWORD PTR _mtx$5$[ebp], xmm4
	call	?ttSHORT@@YAFPAE@Z			; ttSHORT
	cwde
	add	esp, 16					; 00000010H
	add	esi, 2
	movd	xmm2, eax
	cvtdq2ps xmm2, xmm2
	mulss	xmm2, xmm1
	jmp	SHORT $LN100@stbtt__Get
$LN95@stbtt__Get:
	movss	xmm2, DWORD PTR _mtx$1[ebp+12]
	movss	xmm4, DWORD PTR _mtx$1[ebp+8]
	movss	xmm0, DWORD PTR _mtx$1[ebp+4]
	movss	xmm3, DWORD PTR _mtx$1[ebp]
$LN99@stbtt__Get:
	movss	DWORD PTR _mtx$4$[ebp], xmm3
	movss	DWORD PTR _mtx$6$[ebp], xmm0
	movss	DWORD PTR _mtx$5$[ebp], xmm4
$LN100@stbtt__Get:

; 1684 :          }
; 1685 :          
; 1686 :          // Find transformation scales.
; 1687 :          m = (float) STBTT_sqrt(mtx[0]*mtx[0] + mtx[1]*mtx[1]);

	movaps	xmm1, xmm0
	movss	DWORD PTR _mtx$3$[ebp], xmm2
	mulss	xmm1, xmm0

; 1688 :          n = (float) STBTT_sqrt(mtx[2]*mtx[2] + mtx[3]*mtx[3]);
; 1689 : 
; 1690 :          // Get indexed glyph.
; 1691 :          comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);

	lea	eax, DWORD PTR _comp_verts$2[ebp]
	push	eax
	movaps	xmm0, xmm3
	mov	eax, DWORD PTR _gidx$1$[ebp]
	mulss	xmm0, xmm3
	movzx	eax, ax
	push	eax
	push	DWORD PTR _info$[ebp]
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm1
	movaps	xmm1, xmm2
	mulss	xmm1, xmm2
	movss	DWORD PTR _m$1$[ebp], xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm4
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
	sqrtss	xmm0, xmm1
	movss	DWORD PTR _n$1$[ebp], xmm0
	call	_stbtt_GetGlyphShape
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _comp_num_verts$1$[ebp], eax

; 1692 :          if (comp_num_verts > 0) {

	test	eax, eax
	jle	$LN55@stbtt__Get

; 1693 :             // Transform vertices.
; 1694 :             for (i = 0; i < comp_num_verts; ++i) {
; 1695 :                stbtt_vertex* v = &comp_verts[i];

	movss	xmm4, DWORD PTR _mtx$3$[ebp]
	xor	edx, edx
	movss	xmm5, DWORD PTR _mtx$4$[ebp]
	mov	ebx, eax
	movss	xmm6, DWORD PTR _mtx$5$[ebp]
	movss	xmm7, DWORD PTR _mtx$6$[ebp]
	npad	7
$LL18@stbtt__Get:
	mov	ecx, DWORD PTR _comp_verts$2[ebp]

; 1696 :                stbtt_vertex_type x,y;
; 1697 :                x=v->x; y=v->y;
; 1698 :                v->x = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));

	movaps	xmm1, xmm5
	movaps	xmm0, xmm6
	movsx	eax, WORD PTR [edx+ecx+2]
	movd	xmm3, eax
	movsx	eax, WORD PTR [edx+ecx]
	cvtdq2ps xmm3, xmm3
	movd	xmm2, eax
	cvtdq2ps xmm2, xmm2
	mulss	xmm0, xmm3
	mulss	xmm1, xmm2
	addss	xmm1, xmm0

; 1699 :                v->y = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));

	movaps	xmm0, xmm4
	mulss	xmm0, xmm3
	addss	xmm1, DWORD PTR _mtx$1$[ebp]
	mulss	xmm1, DWORD PTR _m$1$[ebp]
	cvttss2si eax, xmm1
	movaps	xmm1, xmm7
	mulss	xmm1, xmm2
	mov	WORD PTR [edx+ecx], ax
	addss	xmm1, xmm0

; 1700 :                x=v->cx; y=v->cy;
; 1701 :                v->cx = (stbtt_vertex_type)(m * (mtx[0]*x + mtx[2]*y + mtx[4]));

	movaps	xmm0, xmm6
	addss	xmm1, DWORD PTR _mtx$2$[ebp]
	mulss	xmm1, DWORD PTR _n$1$[ebp]
	cvttss2si eax, xmm1
	movaps	xmm1, xmm5
	mov	WORD PTR [edx+ecx+2], ax
	movsx	eax, WORD PTR [edx+ecx+6]
	movd	xmm3, eax
	movsx	eax, WORD PTR [edx+ecx+4]
	cvtdq2ps xmm3, xmm3
	movd	xmm2, eax
	cvtdq2ps xmm2, xmm2
	mulss	xmm0, xmm3
	mulss	xmm1, xmm2
	addss	xmm1, xmm0

; 1702 :                v->cy = (stbtt_vertex_type)(n * (mtx[1]*x + mtx[3]*y + mtx[5]));

	movaps	xmm0, xmm4
	mulss	xmm0, xmm3
	addss	xmm1, DWORD PTR _mtx$1$[ebp]
	mulss	xmm1, DWORD PTR _m$1$[ebp]
	cvttss2si eax, xmm1
	movaps	xmm1, xmm7
	mulss	xmm1, xmm2
	mov	WORD PTR [edx+ecx+4], ax
	addss	xmm1, xmm0
	addss	xmm1, DWORD PTR _mtx$2$[ebp]
	mulss	xmm1, DWORD PTR _n$1$[ebp]
	cvttss2si eax, xmm1
	mov	WORD PTR [edx+ecx+6], ax
	add	edx, 14					; 0000000eH
	sub	ebx, 1
	jne	$LL18@stbtt__Get

; 1703 :             }
; 1704 :             // Append vertices.
; 1705 :             tmp = (stbtt_vertex*)STBTT_malloc((num_vertices+comp_num_verts)*sizeof(stbtt_vertex), info->userdata);

	mov	ecx, DWORD PTR _comp_num_verts$1$[ebp]
	mov	ebx, DWORD PTR _vertices$1$[ebp]
	add	ecx, edi
	mov	DWORD PTR tv1718[ebp], ecx
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	add	eax, eax
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	add	esp, 4
	mov	DWORD PTR _tmp$1$[ebp], eax

; 1706 :             if (!tmp) {

	test	eax, eax
	je	SHORT $LN74@stbtt__Get

; 1710 :             }
; 1711 :             if (num_vertices > 0) STBTT_memcpy(tmp, vertices, num_vertices*sizeof(stbtt_vertex));

	test	edi, edi
	jle	SHORT $LN59@stbtt__Get
	lea	ecx, DWORD PTR [edi*8]
	sub	ecx, edi
	add	ecx, ecx
	push	ecx
	push	ebx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN59@stbtt__Get:

; 1712 :             STBTT_memcpy(tmp+num_vertices, comp_verts, comp_num_verts*sizeof(stbtt_vertex));

	mov	ecx, DWORD PTR _comp_num_verts$1$[ebp]
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	add	eax, eax
	push	eax
	push	DWORD PTR _comp_verts$2[ebp]
	lea	eax, DWORD PTR [edi*8]
	sub	eax, edi
	mov	edi, DWORD PTR _tmp$1$[ebp]
	lea	eax, DWORD PTR [edi+eax*2]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1713 :             if (vertices) STBTT_free(vertices, info->userdata);

	test	ebx, ebx
	je	SHORT $LN60@stbtt__Get
	push	ebx
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN60@stbtt__Get:

; 1714 :             vertices = tmp;
; 1715 :             STBTT_free(comp_verts, info->userdata);

	push	DWORD PTR _comp_verts$2[ebp]
	mov	ebx, edi
	mov	DWORD PTR _vertices$1$[ebp], ebx
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 1716 :             num_vertices += comp_num_verts;

	mov	edi, DWORD PTR tv1718[ebp]
	add	esp, 4
$LN55@stbtt__Get:

; 1717 :          }
; 1718 :          // More components ?
; 1719 :          more = flags & (1<<5);

	mov	eax, DWORD PTR _flags$1$[ebp]
	test	al, 32					; 00000020H
	je	$LN94@stbtt__Get

; 1650 :       while (more) {

	jmp	$LN101@stbtt__Get
$LN74@stbtt__Get:

; 1707 :                if (vertices) STBTT_free(vertices, info->userdata);

	test	ebx, ebx
	je	SHORT $LN57@stbtt__Get
	push	ebx
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN57@stbtt__Get:

; 1708 :                if (comp_verts) STBTT_free(comp_verts, info->userdata);

	mov	eax, DWORD PTR _comp_verts$2[ebp]
	test	eax, eax
	je	SHORT $LN58@stbtt__Get
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN58@stbtt__Get:

; 1709 :                return 0;

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 1730 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?stbtt__GetGlyphShapeTT@@YAHPBUstbtt_fontinfo@@HPAPAUstbtt_vertex@@@Z ENDP ; stbtt__GetGlyphShapeTT
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_vertices$ = 8						; size = 4
_num_vertices$ = 12					; size = 4
_was_off$ = 16						; size = 4
_start_off$ = 20					; size = 4
_sx$ = 24						; size = 4
_sy$ = 28						; size = 4
_scx$ = 32						; size = 4
_scy$ = 36						; size = 4
_cx$ = 40						; size = 4
_cy$ = 44						; size = 4
?stbtt__close_shape@@YAHPAUstbtt_vertex@@HHHHHHHHH@Z PROC ; stbtt__close_shape

; 1492 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1493 :    if (start_off) {

	cmp	DWORD PTR _start_off$[ebp], 0

; 1495 :          stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);

	mov	edx, DWORD PTR _num_vertices$[ebp]
	je	SHORT $LN2@stbtt__clo

; 1494 :       if (was_off)

	cmp	DWORD PTR _was_off$[ebp], 0
	push	ebx
	mov	ebx, DWORD PTR _vertices$[ebp]
	push	esi
	mov	esi, DWORD PTR _scy$[ebp]
	push	edi
	mov	edi, DWORD PTR _scx$[ebp]
	je	SHORT $LN4@stbtt__clo

; 1495 :          stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx+scx)>>1, (cy+scy)>>1, cx,cy);

	mov	eax, DWORD PTR _cy$[ebp]
	mov	ecx, DWORD PTR _cx$[ebp]
	push	eax
	add	eax, esi
	sar	eax, 1
	push	ecx
	push	eax
	lea	eax, DWORD PTR [edi+ecx]
	sar	eax, 1
	push	eax
	lea	eax, DWORD PTR [edx*8]
	sub	eax, edx
	push	3
	lea	eax, DWORD PTR [ebx+eax*2]
	push	eax
	call	?stbtt_setvertex@@YAXPAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex
	add	esp, 24					; 00000018H
	inc	edx
$LN4@stbtt__clo:

; 1496 :       stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx,sy,scx,scy);

	push	esi
	push	edi
	push	DWORD PTR _sy$[ebp]
	lea	eax, DWORD PTR [edx*8]
	push	DWORD PTR _sx$[ebp]
	sub	eax, edx
	push	3
	lea	eax, DWORD PTR [ebx+eax*2]
	push	eax
	call	?stbtt_setvertex@@YAXPAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex
	add	esp, 24					; 00000018H
	lea	eax, DWORD PTR [edx+1]
	pop	edi
	pop	esi
	pop	ebx

; 1502 :    }
; 1503 :    return num_vertices;
; 1504 : }

	pop	ebp
	ret	0
$LN2@stbtt__clo:

; 1497 :    } else {
; 1498 :       if (was_off)
; 1499 :          stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve,sx,sy,cx,cy);

	mov	eax, DWORD PTR _vertices$[ebp]
	lea	ecx, DWORD PTR [edx*8]
	sub	ecx, edx
	cmp	DWORD PTR _was_off$[ebp], 0
	lea	eax, DWORD PTR [eax+ecx*2]
	je	SHORT $LN5@stbtt__clo
	push	DWORD PTR _cy$[ebp]
	push	DWORD PTR _cx$[ebp]
	push	DWORD PTR _sy$[ebp]
	push	DWORD PTR _sx$[ebp]
	push	3

; 1500 :       else
; 1501 :          stbtt_setvertex(&vertices[num_vertices++], STBTT_vline,sx,sy,0,0);

	push	eax
	call	?stbtt_setvertex@@YAXPAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex
	add	esp, 24					; 00000018H
	lea	eax, DWORD PTR [edx+1]

; 1502 :    }
; 1503 :    return num_vertices;
; 1504 : }

	pop	ebp
	ret	0
$LN5@stbtt__clo:

; 1500 :       else
; 1501 :          stbtt_setvertex(&vertices[num_vertices++], STBTT_vline,sx,sy,0,0);

	push	0
	push	0
	push	DWORD PTR _sy$[ebp]
	push	DWORD PTR _sx$[ebp]
	push	2
	push	eax
	call	?stbtt_setvertex@@YAXPAUstbtt_vertex@@EHHHH@Z ; stbtt_setvertex
	add	esp, 24					; 00000018H
	lea	eax, DWORD PTR [edx+1]

; 1502 :    }
; 1503 :    return num_vertices;
; 1504 : }

	pop	ebp
	ret	0
?stbtt__close_shape@@YAHPAUstbtt_vertex@@HHHHHHHHH@Z ENDP ; stbtt__close_shape
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_c$ = -48						; size = 48
_info$ = 8						; size = 4
_glyph_index$ = 12					; size = 4
_x0$ = 16						; size = 4
_y0$ = 20						; size = 4
_x1$ = 24						; size = 4
_y1$ = 28						; size = 4
?stbtt__GetGlyphInfoT2@@YAHPBUstbtt_fontinfo@@HPAH111@Z PROC ; stbtt__GetGlyphInfoT2

; 2122 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 2123 :    stbtt__csctx c = STBTT__CSCTX_INIT(1);
; 2124 :    int r = stbtt__run_charstring(info, glyph_index, &c);

	lea	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _c$[ebp], 1
	push	eax
	push	DWORD PTR _glyph_index$[ebp]
	xorps	xmm0, xmm0
	mov	DWORD PTR _c$[ebp+4], 0
	push	DWORD PTR _info$[ebp]
	movups	XMMWORD PTR _c$[ebp+8], xmm0
	mov	DWORD PTR _c$[ebp+40], 0
	movups	XMMWORD PTR _c$[ebp+24], xmm0
	mov	DWORD PTR _c$[ebp+44], 0
	call	?stbtt__run_charstring@@YAHPBUstbtt_fontinfo@@HPAUstbtt__csctx@@@Z ; stbtt__run_charstring
	mov	edx, eax
	add	esp, 12					; 0000000cH

; 2125 :    if (x0) {

	mov	eax, DWORD PTR _x0$[ebp]
	test	eax, eax
	je	SHORT $LN2@stbtt__Get

; 2126 :       *x0 = r ? c.min_x : 0;

	xor	ecx, ecx
	test	edx, edx
	cmovne	ecx, DWORD PTR _c$[ebp+24]
	mov	DWORD PTR [eax], ecx

; 2127 :       *y0 = r ? c.min_y : 0;

	xor	ecx, ecx
	mov	eax, DWORD PTR _y0$[ebp]
	test	edx, edx
	cmovne	ecx, DWORD PTR _c$[ebp+32]
	mov	DWORD PTR [eax], ecx

; 2128 :       *x1 = r ? c.max_x : 0;

	xor	ecx, ecx
	mov	eax, DWORD PTR _x1$[ebp]
	test	edx, edx
	cmovne	ecx, DWORD PTR _c$[ebp+28]
	mov	DWORD PTR [eax], ecx

; 2129 :       *y1 = r ? c.max_y : 0;

	xor	ecx, ecx
	mov	eax, DWORD PTR _y1$[ebp]
	test	edx, edx
	cmovne	ecx, DWORD PTR _c$[ebp+36]
	mov	DWORD PTR [eax], ecx
$LN2@stbtt__Get:

; 2130 :    }
; 2131 :    return r ? c.num_vertices : 0;

	xor	eax, eax
	test	edx, edx
	cmovne	eax, DWORD PTR _c$[ebp+44]

; 2132 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?stbtt__GetGlyphInfoT2@@YAHPBUstbtt_fontinfo@@HPAH111@Z ENDP ; stbtt__GetGlyphInfoT2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_info$ = 8						; size = 4
_glyph_index$ = 12					; size = 4
?stbtt__GetGlyfOffset@@YAHPBUstbtt_fontinfo@@H@Z PROC	; stbtt__GetGlyfOffset

; 1436 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1437 :    int g1,g2;
; 1438 : 
; 1439 :    STBTT_assert(!info->cff.size);
; 1440 : 
; 1441 :    if (glyph_index >= info->numGlyphs) return -1; // glyph index out of range

	mov	ecx, DWORD PTR _glyph_index$[ebp]
	push	edi
	mov	edi, DWORD PTR _info$[ebp]
	cmp	ecx, DWORD PTR [edi+12]
	jl	SHORT $LN2@stbtt__Get
$LN7@stbtt__Get:
	or	eax, -1
	pop	edi

; 1453 : }

	pop	ebp
	ret	0
$LN2@stbtt__Get:

; 1442 :    if (info->indexToLocFormat >= 2)    return -1; // unknown index->glyph map format

	mov	eax, DWORD PTR [edi+44]
	cmp	eax, 2
	jge	SHORT $LN7@stbtt__Get

; 1443 : 
; 1444 :    if (info->indexToLocFormat == 0) {

	push	ebx
	test	eax, eax

; 1445 :       g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;

	mov	eax, DWORD PTR [edi+16]
	push	esi
	jne	SHORT $LN4@stbtt__Get
	add	eax, DWORD PTR [edi+4]
	mov	edi, DWORD PTR [edi+24]
	lea	esi, DWORD PTR [eax+ecx*2]
	push	esi
	call	?ttUSHORT@@YAGPAE@Z			; ttUSHORT
	movzx	eax, ax
	lea	ebx, DWORD PTR [edi+eax*2]

; 1446 :       g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;

	lea	eax, DWORD PTR [esi+2]
	push	eax
	call	?ttUSHORT@@YAGPAE@Z			; ttUSHORT
	movzx	eax, ax
	add	esp, 8

; 1450 :    }
; 1451 : 
; 1452 :    return g1==g2 ? -1 : g1; // if length is 0, return -1

	or	ecx, -1
	lea	eax, DWORD PTR [edi+eax*2]
	cmp	ebx, eax
	pop	esi
	cmove	ebx, ecx
	mov	eax, ebx
	pop	ebx
	pop	edi

; 1453 : }

	pop	ebp
	ret	0
$LN4@stbtt__Get:

; 1447 :    } else {
; 1448 :       g1 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4);

	add	eax, DWORD PTR [edi+4]
	mov	edi, DWORD PTR [edi+24]
	lea	esi, DWORD PTR [eax+ecx*4]
	push	esi
	call	?ttULONG@@YAIPAE@Z			; ttULONG

; 1449 :       g2 = info->glyf + ttULONG (info->data + info->loca + glyph_index * 4 + 4);

	lea	ecx, DWORD PTR [esi+4]
	push	ecx
	lea	ebx, DWORD PTR [edi+eax]
	call	?ttULONG@@YAIPAE@Z			; ttULONG
	add	esp, 8
	add	eax, edi

; 1450 :    }
; 1451 : 
; 1452 :    return g1==g2 ? -1 : g1; // if length is 0, return -1

	or	ecx, -1
	cmp	ebx, eax
	cmove	ebx, ecx
	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	edi

; 1453 : }

	pop	ebp
	ret	0
?stbtt__GetGlyfOffset@@YAHPBUstbtt_fontinfo@@H@Z ENDP	; stbtt__GetGlyfOffset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_v$ = 8							; size = 4
_type$ = 12						; size = 1
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_cx$ = 24						; size = 4
_cy$ = 28						; size = 4
?stbtt_setvertex@@YAXPAUstbtt_vertex@@EHHHH@Z PROC	; stbtt_setvertex

; 1427 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1428 :    v->type = type;

	mov	ecx, DWORD PTR _v$[ebp]
	mov	al, BYTE PTR _type$[ebp]
	mov	BYTE PTR [ecx+12], al

; 1429 :    v->x = (stbtt_int16) x;

	mov	ax, WORD PTR _x$[ebp]
	mov	WORD PTR [ecx], ax

; 1430 :    v->y = (stbtt_int16) y;

	mov	ax, WORD PTR _y$[ebp]
	mov	WORD PTR [ecx+2], ax

; 1431 :    v->cx = (stbtt_int16) cx;

	mov	ax, WORD PTR _cx$[ebp]
	mov	WORD PTR [ecx+4], ax

; 1432 :    v->cy = (stbtt_int16) cy;

	mov	ax, WORD PTR _cy$[ebp]
	mov	WORD PTR [ecx+6], ax

; 1433 : }

	pop	ebp
	ret	0
?stbtt_setvertex@@YAXPAUstbtt_vertex@@EHHHH@Z ENDP	; stbtt_setvertex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
$T1 = -56						; size = 12
$T2 = -56						; size = 12
$T3 = -56						; size = 12
$T4 = -56						; size = 12
$T5 = -56						; size = 12
$T6 = -56						; size = 12
$T7 = -56						; size = 12
_topdict$8 = -44					; size = 12
$T9 = -44						; size = 12
$T10 = -44						; size = 12
$T11 = -44						; size = 12
$T12 = -44						; size = 12
$T13 = -44						; size = 12
$T14 = -44						; size = 12
_b$15 = -32						; size = 12
tv391 = -20						; size = 4
tv387 = -16						; size = 4
_fdarrayoff$16 = -16					; size = 4
tv390 = -12						; size = 4
_cstype$17 = -12					; size = 4
_cmap$1$ = -8						; size = 4
tv392 = -4						; size = 4
_charstrings$18 = -4					; size = 4
tv388 = 8						; size = 4
_fdselectoff$19 = 8					; size = 4
_info$ = 8						; size = 4
_data$ = 12						; size = 4
_numTables$1$ = 16					; size = 4
_fontstart$ = 16					; size = 4
?stbtt_InitFont_internal@@YAHPAUstbtt_fontinfo@@PAEH@Z PROC ; stbtt_InitFont_internal

; 1219 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 1220 :    stbtt_uint32 cmap, t;
; 1221 :    stbtt_int32 i,numTables;
; 1222 : 
; 1223 :    info->data = data;
; 1224 :    info->fontstart = fontstart;

	mov	edx, DWORD PTR _fontstart$[ebp]

; 1225 :    info->cff = stbtt__new_buf(NULL, 0);

	lea	eax, DWORD PTR $T14[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _info$[ebp]
	push	edi
	mov	edi, DWORD PTR _data$[ebp]
	push	0
	push	0
	push	eax
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edx
	call	?stbtt__new_buf@@YA?AUstbtt__buf@@PBXI@Z ; stbtt__new_buf

; 1226 : 
; 1227 :    cmap = stbtt__find_table(data, fontstart, "cmap");       // required

	push	OFFSET $SG13070
	push	edx
	push	edi
	movq	xmm0, QWORD PTR [eax]
	mov	eax, DWORD PTR [eax+8]
	movq	QWORD PTR [esi+48], xmm0
	mov	DWORD PTR [esi+56], eax
	call	?stbtt__find_table@@YAIPAEIPBD@Z	; stbtt__find_table

; 1228 :    info->loca = stbtt__find_table(data, fontstart, "loca"); // required

	push	OFFSET $SG13071
	push	DWORD PTR _fontstart$[ebp]
	mov	ebx, eax
	push	edi
	mov	DWORD PTR _cmap$1$[ebp], ebx
	call	?stbtt__find_table@@YAIPAEIPBD@Z	; stbtt__find_table

; 1229 :    info->head = stbtt__find_table(data, fontstart, "head"); // required

	push	OFFSET $SG13072
	push	DWORD PTR _fontstart$[ebp]
	mov	DWORD PTR tv392[ebp], eax
	push	edi
	mov	DWORD PTR [esi+16], eax
	call	?stbtt__find_table@@YAIPAEIPBD@Z	; stbtt__find_table

; 1230 :    info->glyf = stbtt__find_table(data, fontstart, "glyf"); // required

	push	OFFSET $SG13073
	push	DWORD PTR _fontstart$[ebp]
	mov	DWORD PTR tv391[ebp], eax
	push	edi
	mov	DWORD PTR [esi+20], eax
	call	?stbtt__find_table@@YAIPAEIPBD@Z	; stbtt__find_table

; 1231 :    info->hhea = stbtt__find_table(data, fontstart, "hhea"); // required

	push	OFFSET $SG13074
	push	DWORD PTR _fontstart$[ebp]
	mov	DWORD PTR tv390[ebp], eax
	push	edi
	mov	DWORD PTR [esi+24], eax
	call	?stbtt__find_table@@YAIPAEIPBD@Z	; stbtt__find_table
	add	esp, 72					; 00000048H
	mov	DWORD PTR tv388[ebp], eax
	mov	DWORD PTR [esi+28], eax

; 1232 :    info->hmtx = stbtt__find_table(data, fontstart, "hmtx"); // required

	push	OFFSET $SG13075
	push	DWORD PTR _fontstart$[ebp]
	push	edi
	call	?stbtt__find_table@@YAIPAEIPBD@Z	; stbtt__find_table

; 1233 :    info->kern = stbtt__find_table(data, fontstart, "kern"); // not required

	push	OFFSET $SG13076
	push	DWORD PTR _fontstart$[ebp]
	mov	DWORD PTR tv387[ebp], eax
	push	edi
	mov	DWORD PTR [esi+32], eax
	call	?stbtt__find_table@@YAIPAEIPBD@Z	; stbtt__find_table
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi+36], eax

; 1234 : 
; 1235 :    if (!cmap || !info->head || !info->hhea || !info->hmtx)

	test	ebx, ebx
	je	SHORT $LN10@stbtt_Init
	cmp	DWORD PTR tv391[ebp], 0
	je	SHORT $LN10@stbtt_Init
	cmp	DWORD PTR tv388[ebp], 0
	je	SHORT $LN10@stbtt_Init
	cmp	DWORD PTR tv387[ebp], 0
	je	SHORT $LN10@stbtt_Init

; 1237 :    if (info->glyf) {

	cmp	DWORD PTR tv390[ebp], 0
	je	SHORT $LN11@stbtt_Init

; 1238 :       // required for truetype
; 1239 :       if (!info->loca) return 0;

	cmp	DWORD PTR tv392[ebp], 0
	jne	$LN12@stbtt_Init
$LN10@stbtt_Init:

; 1236 :       return 0;

	xor	eax, eax

; 1326 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@stbtt_Init:

; 1240 :    } else {
; 1241 :       // initialization for CFF / Type2 fonts (OTF)
; 1242 :       stbtt__buf b, topdict, topdictidx;
; 1243 :       stbtt_uint32 cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;
; 1244 :       stbtt_uint32 cff;
; 1245 : 
; 1246 :       cff = stbtt__find_table(data, fontstart, "CFF ");

	push	OFFSET $SG13082
	push	DWORD PTR _fontstart$[ebp]
	mov	DWORD PTR _cstype$17[ebp], 2
	push	edi
	mov	DWORD PTR _charstrings$18[ebp], 0
	mov	DWORD PTR _fdarrayoff$16[ebp], 0
	mov	DWORD PTR _fdselectoff$19[ebp], 0
	call	?stbtt__find_table@@YAIPAEIPBD@Z	; stbtt__find_table
	mov	edx, eax
	add	esp, 12					; 0000000cH

; 1247 :       if (!cff) return 0;

	test	edx, edx
	je	SHORT $LN10@stbtt_Init

; 1248 : 
; 1249 :       info->fontdicts = stbtt__new_buf(NULL, 0);

	push	0
	lea	eax, DWORD PTR $T13[ebp]
	push	0
	push	eax
	call	?stbtt__new_buf@@YA?AUstbtt__buf@@PBXI@Z ; stbtt__new_buf

; 1250 :       info->fdselect = stbtt__new_buf(NULL, 0);

	push	0
	push	0
	movq	xmm0, QWORD PTR [eax]
	mov	eax, DWORD PTR [eax+8]
	movq	QWORD PTR [esi+96], xmm0
	mov	DWORD PTR [esi+104], eax
	lea	eax, DWORD PTR $T12[ebp]
	push	eax
	call	?stbtt__new_buf@@YA?AUstbtt__buf@@PBXI@Z ; stbtt__new_buf

; 1251 : 
; 1252 :       // @TODO this should use size from table (not 512MB)
; 1253 :       info->cff = stbtt__new_buf(data+cff, 512*1024*1024);

	push	536870912				; 20000000H
	movq	xmm0, QWORD PTR [eax]
	mov	eax, DWORD PTR [eax+8]
	movq	QWORD PTR [esi+108], xmm0
	mov	DWORD PTR [esi+116], eax
	lea	eax, DWORD PTR [edx+edi]
	push	eax
	lea	eax, DWORD PTR $T11[ebp]
	push	eax
	call	?stbtt__new_buf@@YA?AUstbtt__buf@@PBXI@Z ; stbtt__new_buf

; 1254 :       b = info->cff;
; 1255 : 
; 1256 :       // read the header
; 1257 :       stbtt__buf_skip(&b, 2);

	push	2
	movq	xmm0, QWORD PTR [eax]
	mov	eax, DWORD PTR [eax+8]
	movq	QWORD PTR [esi+48], xmm0
	mov	DWORD PTR [esi+56], eax
	mov	DWORD PTR _b$15[ebp+8], eax
	lea	eax, DWORD PTR _b$15[ebp]
	push	eax
	movq	QWORD PTR _b$15[ebp], xmm0
	call	?stbtt__buf_skip@@YAXPAUstbtt__buf@@H@Z	; stbtt__buf_skip

; 1258 :       stbtt__buf_seek(&b, stbtt__buf_get8(&b)); // hdrsize

	lea	eax, DWORD PTR _b$15[ebp]
	push	eax
	call	?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z	; stbtt__buf_get8
	movzx	eax, al
	push	eax
	lea	eax, DWORD PTR _b$15[ebp]
	push	eax
	call	?stbtt__buf_seek@@YAXPAUstbtt__buf@@H@Z	; stbtt__buf_seek

; 1259 : 
; 1260 :       // @TODO the name INDEX could list multiple fonts,
; 1261 :       // but we just use the first one.
; 1262 :       stbtt__cff_get_index(&b);  // name INDEX

	lea	eax, DWORD PTR _b$15[ebp]
	push	eax
	lea	eax, DWORD PTR $T10[ebp]
	push	eax
	call	?stbtt__cff_get_index@@YA?AUstbtt__buf@@PAU1@@Z ; stbtt__cff_get_index
	add	esp, 64					; 00000040H

; 1263 :       topdictidx = stbtt__cff_get_index(&b);

	lea	eax, DWORD PTR _b$15[ebp]
	push	eax
	lea	eax, DWORD PTR $T9[ebp]
	push	eax
	call	?stbtt__cff_get_index@@YA?AUstbtt__buf@@PAU1@@Z ; stbtt__cff_get_index
	add	esp, 8

; 1264 :       topdict = stbtt__cff_index_get(topdictidx, 0);

	movq	xmm0, QWORD PTR [eax]
	mov	eax, DWORD PTR [eax+8]
	push	0
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	call	?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z ; stbtt__cff_index_get
	movq	xmm0, QWORD PTR [eax]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _topdict$8[ebp+8], eax

; 1265 :       stbtt__cff_get_index(&b);  // string INDEX

	lea	eax, DWORD PTR _b$15[ebp]
	push	eax
	lea	eax, DWORD PTR $T6[ebp]
	movq	QWORD PTR _topdict$8[ebp], xmm0
	push	eax
	call	?stbtt__cff_get_index@@YA?AUstbtt__buf@@PAU1@@Z ; stbtt__cff_get_index

; 1266 :       info->gsubrs = stbtt__cff_get_index(&b);

	lea	eax, DWORD PTR _b$15[ebp]
	push	eax
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	?stbtt__cff_get_index@@YA?AUstbtt__buf@@PAU1@@Z ; stbtt__cff_get_index
	movq	xmm0, QWORD PTR [eax]
	mov	eax, DWORD PTR [eax+8]
	movq	QWORD PTR [esi+72], xmm0
	mov	DWORD PTR [esi+80], eax

; 1267 : 
; 1268 :       stbtt__dict_get_ints(&topdict, 17, 1, &charstrings);

	lea	eax, DWORD PTR _charstrings$18[ebp]
	push	eax
	push	1
	lea	eax, DWORD PTR _topdict$8[ebp]
	push	17					; 00000011H
	push	eax
	call	?stbtt__dict_get_ints@@YAXPAUstbtt__buf@@HHPAI@Z ; stbtt__dict_get_ints

; 1269 :       stbtt__dict_get_ints(&topdict, 0x100 | 6, 1, &cstype);

	lea	eax, DWORD PTR _cstype$17[ebp]
	push	eax
	push	1
	lea	eax, DWORD PTR _topdict$8[ebp]
	push	262					; 00000106H
	push	eax
	call	?stbtt__dict_get_ints@@YAXPAUstbtt__buf@@HHPAI@Z ; stbtt__dict_get_ints
	add	esp, 68					; 00000044H

; 1270 :       stbtt__dict_get_ints(&topdict, 0x100 | 36, 1, &fdarrayoff);

	lea	eax, DWORD PTR _fdarrayoff$16[ebp]
	push	eax
	push	1
	lea	eax, DWORD PTR _topdict$8[ebp]
	push	292					; 00000124H
	push	eax
	call	?stbtt__dict_get_ints@@YAXPAUstbtt__buf@@HHPAI@Z ; stbtt__dict_get_ints

; 1271 :       stbtt__dict_get_ints(&topdict, 0x100 | 37, 1, &fdselectoff);

	lea	eax, DWORD PTR _fdselectoff$19[ebp]
	push	eax
	push	1
	lea	eax, DWORD PTR _topdict$8[ebp]
	push	293					; 00000125H
	push	eax
	call	?stbtt__dict_get_ints@@YAXPAUstbtt__buf@@HHPAI@Z ; stbtt__dict_get_ints

; 1272 :       info->subrs = stbtt__get_subrs(b, topdict);

	movq	xmm0, QWORD PTR _topdict$8[ebp]
	add	esp, 20					; 00000014H
	mov	eax, DWORD PTR _topdict$8[ebp+8]
	mov	ecx, esp
	sub	esp, 12					; 0000000cH
	movq	QWORD PTR [ecx], xmm0
	movq	xmm0, QWORD PTR _b$15[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	eax, DWORD PTR _b$15[ebp+8]
	movq	QWORD PTR [ecx], xmm0
	mov	DWORD PTR [ecx+8], eax
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z ; stbtt__get_subrs
	add	esp, 28					; 0000001cH

; 1273 : 
; 1274 :       // we only support Type 2 charstrings
; 1275 :       if (cstype != 2) return 0;

	cmp	DWORD PTR _cstype$17[ebp], 2
	movq	xmm0, QWORD PTR [eax]
	mov	eax, DWORD PTR [eax+8]
	movq	QWORD PTR [esi+84], xmm0
	mov	DWORD PTR [esi+92], eax
	jne	$LN10@stbtt_Init

; 1276 :       if (charstrings == 0) return 0;

	mov	eax, DWORD PTR _charstrings$18[ebp]
	test	eax, eax
	je	$LN10@stbtt_Init

; 1277 : 
; 1278 :       if (fdarrayoff) {

	mov	ecx, DWORD PTR _fdarrayoff$16[ebp]
	test	ecx, ecx
	je	SHORT $LN17@stbtt_Init

; 1279 :          // looks like a CID font
; 1280 :          if (!fdselectoff) return 0;

	cmp	DWORD PTR _fdselectoff$19[ebp], 0
	je	$LN10@stbtt_Init

; 1281 :          stbtt__buf_seek(&b, fdarrayoff);

	push	ecx
	lea	eax, DWORD PTR _b$15[ebp]
	push	eax
	call	?stbtt__buf_seek@@YAXPAUstbtt__buf@@H@Z	; stbtt__buf_seek

; 1282 :          info->fontdicts = stbtt__cff_get_index(&b);

	lea	eax, DWORD PTR _b$15[ebp]
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?stbtt__cff_get_index@@YA?AUstbtt__buf@@PAU1@@Z ; stbtt__cff_get_index

; 1283 :          info->fdselect = stbtt__buf_range(&b, fdselectoff, b.size-fdselectoff);

	mov	ecx, DWORD PTR _fdselectoff$19[ebp]
	movq	xmm0, QWORD PTR [eax]
	mov	eax, DWORD PTR [eax+8]
	movq	QWORD PTR [esi+96], xmm0
	mov	DWORD PTR [esi+104], eax
	mov	eax, DWORD PTR _b$15[ebp+8]
	sub	eax, ecx
	push	eax
	push	ecx
	lea	eax, DWORD PTR _b$15[ebp]
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?stbtt__buf_range@@YA?AUstbtt__buf@@PBU1@HH@Z ; stbtt__buf_range
	add	esp, 32					; 00000020H
	movq	xmm0, QWORD PTR [eax]
	mov	eax, DWORD PTR [eax+8]
	movq	QWORD PTR [esi+108], xmm0
	mov	DWORD PTR [esi+116], eax
	mov	eax, DWORD PTR _charstrings$18[ebp]
$LN17@stbtt_Init:

; 1284 :       }
; 1285 : 
; 1286 :       stbtt__buf_seek(&b, charstrings);

	push	eax
	lea	eax, DWORD PTR _b$15[ebp]
	push	eax
	call	?stbtt__buf_seek@@YAXPAUstbtt__buf@@H@Z	; stbtt__buf_seek

; 1287 :       info->charstrings = stbtt__cff_get_index(&b);

	lea	eax, DWORD PTR _b$15[ebp]
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?stbtt__cff_get_index@@YA?AUstbtt__buf@@PAU1@@Z ; stbtt__cff_get_index
	add	esp, 16					; 00000010H
	movq	xmm0, QWORD PTR [eax]
	mov	eax, DWORD PTR [eax+8]
	movq	QWORD PTR [esi+60], xmm0
	mov	DWORD PTR [esi+68], eax
$LN12@stbtt_Init:

; 1288 :    }
; 1289 : 
; 1290 :    t = stbtt__find_table(data, fontstart, "maxp");

	push	OFFSET $SG13088
	push	DWORD PTR _fontstart$[ebp]
	push	edi
	call	?stbtt__find_table@@YAIPAEIPBD@Z	; stbtt__find_table
	add	esp, 12					; 0000000cH

; 1291 :    if (t)

	test	eax, eax
	je	SHORT $LN19@stbtt_Init

; 1292 :       info->numGlyphs = ttUSHORT(data+t+4);

	add	eax, 4
	add	eax, edi
	push	eax
	call	?ttUSHORT@@YAGPAE@Z			; ttUSHORT
	movzx	eax, ax
	add	esp, 4
	mov	DWORD PTR [esi+12], eax

; 1293 :    else

	jmp	SHORT $LN20@stbtt_Init
$LN19@stbtt_Init:

; 1294 :       info->numGlyphs = 0xffff;

	mov	DWORD PTR [esi+12], 65535		; 0000ffffH
$LN20@stbtt_Init:

; 1295 : 
; 1296 :    // find a cmap encoding table we understand *now* to avoid searching
; 1297 :    // later. (todo: could make this installable)
; 1298 :    // the same regardless of glyph.
; 1299 :    numTables = ttUSHORT(data + cmap + 2);

	lea	eax, DWORD PTR [edi+2]
	add	eax, ebx
	push	eax
	call	?ttUSHORT@@YAGPAE@Z			; ttUSHORT
	movzx	eax, ax
	add	esp, 4

; 1300 :    info->index_map = 0;
; 1301 :    for (i=0; i < numTables; ++i) {

	xor	ebx, ebx
	mov	DWORD PTR _numTables$1$[ebp], eax
	mov	DWORD PTR [esi+40], 0
	test	eax, eax
	je	SHORT $LN3@stbtt_Init
$LL4@stbtt_Init:

; 1302 :       stbtt_uint32 encoding_record = cmap + 4 + 8 * i;

	mov	eax, DWORD PTR _cmap$1$[ebp]
	lea	eax, DWORD PTR [eax+ebx*8]
	add	eax, 4

; 1303 :       // find an encoding we understand:
; 1304 :       switch(ttUSHORT(data+encoding_record)) {

	add	edi, eax
	push	edi
	call	?ttUSHORT@@YAGPAE@Z			; ttUSHORT
	movzx	eax, ax
	add	esp, 4
	test	eax, eax
	je	SHORT $LN23@stbtt_Init
	cmp	eax, 3
	jne	SHORT $LN2@stbtt_Init

; 1305 :          case STBTT_PLATFORM_ID_MICROSOFT:
; 1306 :             switch (ttUSHORT(data+encoding_record+2)) {

	lea	eax, DWORD PTR [edi+2]
	push	eax
	call	?ttUSHORT@@YAGPAE@Z			; ttUSHORT
	movzx	eax, ax
	add	esp, 4
	sub	eax, 1
	je	SHORT $LN23@stbtt_Init
	sub	eax, 9
	jne	SHORT $LN2@stbtt_Init
$LN23@stbtt_Init:

; 1307 :                case STBTT_MS_EID_UNICODE_BMP:
; 1308 :                case STBTT_MS_EID_UNICODE_FULL:
; 1309 :                   // MS/Unicode
; 1310 :                   info->index_map = cmap + ttULONG(data+encoding_record+4);
; 1311 :                   break;
; 1312 :             }
; 1313 :             break;
; 1314 :         case STBTT_PLATFORM_ID_UNICODE:
; 1315 :             // Mac/iOS has these
; 1316 :             // all the encodingIDs are unicode, so we don't bother to check it
; 1317 :             info->index_map = cmap + ttULONG(data+encoding_record+4);

	lea	eax, DWORD PTR [edi+4]
	push	eax
	call	?ttULONG@@YAIPAE@Z			; ttULONG
	add	esp, 4
	add	eax, DWORD PTR _cmap$1$[ebp]
	mov	DWORD PTR [esi+40], eax
$LN2@stbtt_Init:

; 1300 :    info->index_map = 0;
; 1301 :    for (i=0; i < numTables; ++i) {

	mov	edi, DWORD PTR _data$[ebp]
	inc	ebx
	cmp	ebx, DWORD PTR _numTables$1$[ebp]
	jl	SHORT $LL4@stbtt_Init
$LN3@stbtt_Init:

; 1318 :             break;
; 1319 :       }
; 1320 :    }
; 1321 :    if (info->index_map == 0)

	cmp	DWORD PTR [esi+40], 0
	je	$LN10@stbtt_Init

; 1322 :       return 0;
; 1323 : 
; 1324 :    info->indexToLocFormat = ttUSHORT(data+info->head + 50);

	mov	eax, DWORD PTR tv391[ebp]
	add	eax, 50					; 00000032H
	add	eax, edi
	push	eax
	call	?ttUSHORT@@YAGPAE@Z			; ttUSHORT
	add	esp, 4
	movzx	eax, ax
	mov	DWORD PTR [esi+44], eax

; 1325 :    return 1;

	mov	eax, 1

; 1326 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?stbtt_InitFont_internal@@YAHPAUstbtt_fontinfo@@PAEH@Z ENDP ; stbtt_InitFont_internal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
$T1 = -28						; size = 12
$T2 = -28						; size = 12
$T3 = -28						; size = 12
_pdict$ = -16						; size = 12
_private_loc$ = -12					; size = 8
_subrsoff$ = -4						; size = 4
$T4 = 8							; size = 4
_cff$ = 12						; size = 12
_fontdict$ = 24						; size = 12
?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z PROC		; stbtt__get_subrs

; 1206 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi

; 1207 :    stbtt_uint32 subrsoff = 0, private_loc[2] = { 0, 0 };
; 1208 :    stbtt__buf pdict;
; 1209 :    stbtt__dict_get_ints(&fontdict, 18, 2, private_loc);

	lea	eax, DWORD PTR _private_loc$[ebp]
	mov	DWORD PTR _subrsoff$[ebp], 0
	push	eax
	push	2
	lea	eax, DWORD PTR _fontdict$[ebp]
	mov	DWORD PTR _private_loc$[ebp], 0
	push	18					; 00000012H
	push	eax
	mov	DWORD PTR _private_loc$[ebp+4], 0
	call	?stbtt__dict_get_ints@@YAXPAUstbtt__buf@@HHPAI@Z ; stbtt__dict_get_ints

; 1210 :    if (!private_loc[1] || !private_loc[0]) return stbtt__new_buf(NULL, 0);

	mov	esi, DWORD PTR _private_loc$[ebp+4]
	add	esp, 16					; 00000010H
	test	esi, esi
	je	SHORT $LN3@stbtt__get
	mov	eax, DWORD PTR _private_loc$[ebp]
	test	eax, eax
	je	SHORT $LN3@stbtt__get

; 1211 :    pdict = stbtt__buf_range(&cff, private_loc[1], private_loc[0]);

	push	eax
	push	esi
	lea	eax, DWORD PTR _cff$[ebp]
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?stbtt__buf_range@@YA?AUstbtt__buf@@PBU1@HH@Z ; stbtt__buf_range
	movq	xmm0, QWORD PTR [eax]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _pdict$[ebp+8], eax

; 1212 :    stbtt__dict_get_ints(&pdict, 19, 1, &subrsoff);

	lea	eax, DWORD PTR _subrsoff$[ebp]
	push	eax
	push	1
	lea	eax, DWORD PTR _pdict$[ebp]
	movq	QWORD PTR _pdict$[ebp], xmm0
	push	19					; 00000013H
	push	eax
	call	?stbtt__dict_get_ints@@YAXPAUstbtt__buf@@HHPAI@Z ; stbtt__dict_get_ints

; 1213 :    if (!subrsoff) return stbtt__new_buf(NULL, 0);

	mov	eax, DWORD PTR _subrsoff$[ebp]
	add	esp, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN3@stbtt__get

; 1214 :    stbtt__buf_seek(&cff, private_loc[1]+subrsoff);

	add	eax, esi
	push	eax
	lea	eax, DWORD PTR _cff$[ebp]
	push	eax
	call	?stbtt__buf_seek@@YAXPAUstbtt__buf@@H@Z	; stbtt__buf_seek

; 1215 :    return stbtt__cff_get_index(&cff);

	lea	eax, DWORD PTR _cff$[ebp]
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?stbtt__cff_get_index@@YA?AUstbtt__buf@@PAU1@@Z ; stbtt__cff_get_index
	add	esp, 16					; 00000010H
	jmp	SHORT $LN6@stbtt__get
$LN3@stbtt__get:

; 1210 :    if (!private_loc[1] || !private_loc[0]) return stbtt__new_buf(NULL, 0);

	push	0
	lea	eax, DWORD PTR $T3[ebp]
	push	0
	push	eax
	call	?stbtt__new_buf@@YA?AUstbtt__buf@@PBXI@Z ; stbtt__new_buf
	add	esp, 12					; 0000000cH
$LN6@stbtt__get:
	mov	edx, DWORD PTR $T4[ebp]
	movq	xmm0, QWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, edx
	pop	esi
	movq	QWORD PTR [edx], xmm0
	mov	DWORD PTR [edx+8], ecx

; 1216 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?stbtt__get_subrs@@YA?AUstbtt__buf@@U1@0@Z ENDP		; stbtt__get_subrs
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_font_collection$ = 8					; size = 4
_index$ = 12						; size = 4
?stbtt_GetFontOffsetForIndex_internal@@YAHPAEH@Z PROC	; stbtt_GetFontOffsetForIndex_internal

; 1171 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 1172 :    // if it's just a font, there's only one valid index
; 1173 :    if (stbtt__isfont(font_collection))

	mov	esi, DWORD PTR _font_collection$[ebp]
	push	esi
	call	?stbtt__isfont@@YAHPAE@Z		; stbtt__isfont
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@stbtt_GetF

; 1174 :       return index == 0 ? 0 : -1;

	mov	eax, DWORD PTR _index$[ebp]
	neg	eax
	pop	esi
	sbb	eax, eax

; 1187 : }

	pop	ebp
	ret	0
$LN2@stbtt_GetF:

; 1175 : 
; 1176 :    // check if it's a TTC
; 1177 :    if (stbtt_tag(font_collection, "ttcf")) {

	cmp	BYTE PTR [esi], 116			; 00000074H
	push	edi
	jne	SHORT $LN4@stbtt_GetF
	cmp	BYTE PTR [esi+1], 116			; 00000074H
	jne	SHORT $LN4@stbtt_GetF
	cmp	BYTE PTR [esi+2], 99			; 00000063H
	jne	SHORT $LN4@stbtt_GetF
	cmp	BYTE PTR [esi+3], 102			; 00000066H
	jne	SHORT $LN4@stbtt_GetF

; 1178 :       // version 1?
; 1179 :       if (ttULONG(font_collection+4) == 0x00010000 || ttULONG(font_collection+4) == 0x00020000) {

	lea	edi, DWORD PTR [esi+4]
	push	edi
	call	?ttULONG@@YAIPAE@Z			; ttULONG
	add	esp, 4
	cmp	eax, 65536				; 00010000H
	je	SHORT $LN5@stbtt_GetF
	push	edi
	call	?ttULONG@@YAIPAE@Z			; ttULONG
	add	esp, 4
	cmp	eax, 131072				; 00020000H
	jne	SHORT $LN4@stbtt_GetF
$LN5@stbtt_GetF:

; 1180 :          stbtt_int32 n = ttLONG(font_collection+8);

	lea	eax, DWORD PTR [esi+8]
	push	eax
	call	?ttLONG@@YAHPAE@Z			; ttLONG

; 1181 :          if (index >= n)

	mov	ecx, DWORD PTR _index$[ebp]
	add	esp, 4
	cmp	ecx, eax
	jge	SHORT $LN4@stbtt_GetF

; 1182 :             return -1;
; 1183 :          return ttULONG(font_collection+12+index*4);

	add	ecx, 3
	lea	eax, DWORD PTR [esi+ecx*4]
	push	eax
	call	?ttULONG@@YAIPAE@Z			; ttULONG
	add	esp, 4
	pop	edi
	pop	esi

; 1187 : }

	pop	ebp
	ret	0
$LN4@stbtt_GetF:
	pop	edi

; 1184 :       }
; 1185 :    }
; 1186 :    return -1;

	or	eax, -1
	pop	esi

; 1187 : }

	pop	ebp
	ret	0
?stbtt_GetFontOffsetForIndex_internal@@YAHPAEH@Z ENDP	; stbtt_GetFontOffsetForIndex_internal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_num_tables$1$ = -8					; size = 4
tv417 = -4						; size = 4
_data$ = 8						; size = 4
tv398 = 12						; size = 4
_fontstart$ = 12					; size = 4
_tag$ = 16						; size = 4
?stbtt__find_table@@YAIPAEIPBD@Z PROC			; stbtt__find_table

; 1158 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1159 :    stbtt_int32 num_tables = ttUSHORT(data+fontstart+4);

	mov	eax, DWORD PTR _data$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _fontstart$[ebp]
	add	eax, esi
	mov	DWORD PTR tv417[ebp], eax
	add	eax, 4
	push	edi
	push	eax
	call	?ttUSHORT@@YAGPAE@Z			; ttUSHORT
	movzx	eax, ax
	add	esp, 4

; 1160 :    stbtt_uint32 tabledir = fontstart + 12;
; 1161 :    stbtt_int32 i;
; 1162 :    for (i=0; i < num_tables; ++i) {

	xor	edi, edi
	mov	DWORD PTR _num_tables$1$[ebp], eax
	test	eax, eax
	je	SHORT $LN12@stbtt__fin

; 1163 :       stbtt_uint32 loc = tabledir + 16*i;
; 1164 :       if (stbtt_tag(data+loc+0, tag))

	mov	ebx, DWORD PTR _tag$[ebp]
	add	esi, 12					; 0000000cH
	mov	eax, DWORD PTR tv417[ebp]
	add	eax, 12					; 0000000cH
	movsx	edx, BYTE PTR [ebx]
	mov	DWORD PTR tv398[ebp], edx
$LL4@stbtt__fin:
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, edx
	jne	SHORT $LN2@stbtt__fin
	mov	ecx, DWORD PTR _data$[ebp]
	movzx	edx, BYTE PTR [esi+ecx+1]
	movsx	ecx, BYTE PTR [ebx+1]
	cmp	edx, ecx
	jne	SHORT $LN15@stbtt__fin
	mov	ecx, DWORD PTR _data$[ebp]
	movzx	edx, BYTE PTR [esi+ecx+2]
	movsx	ecx, BYTE PTR [ebx+2]
	cmp	edx, ecx
	jne	SHORT $LN15@stbtt__fin
	movzx	edx, BYTE PTR [eax+3]
	movsx	ecx, BYTE PTR [ebx+3]
	cmp	edx, ecx
	je	SHORT $LN8@stbtt__fin
$LN15@stbtt__fin:
	mov	edx, DWORD PTR tv398[ebp]
$LN2@stbtt__fin:

; 1160 :    stbtt_uint32 tabledir = fontstart + 12;
; 1161 :    stbtt_int32 i;
; 1162 :    for (i=0; i < num_tables; ++i) {

	inc	edi
	add	esi, 16					; 00000010H
	add	eax, 16					; 00000010H
	cmp	edi, DWORD PTR _num_tables$1$[ebp]
	jl	SHORT $LL4@stbtt__fin
$LN12@stbtt__fin:
	pop	edi
	pop	esi

; 1166 :    }
; 1167 :    return 0;

	xor	eax, eax
	pop	ebx

; 1168 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@stbtt__fin:

; 1165 :          return ttULONG(data+loc+8);

	add	eax, 8
	push	eax
	call	?ttULONG@@YAIPAE@Z			; ttULONG
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 1168 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?stbtt__find_table@@YAIPAEIPBD@Z ENDP			; stbtt__find_table
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_font$ = 8						; size = 4
?stbtt__isfont@@YAHPAE@Z PROC				; stbtt__isfont

; 1146 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1147 :    // check the version number
; 1148 :    if (stbtt_tag4(font, '1',0,0,0))  return 1; // TrueType 1

	mov	eax, DWORD PTR _font$[ebp]
	mov	cl, BYTE PTR [eax]
	cmp	cl, 49					; 00000031H
	jne	SHORT $LN2@stbtt__isf
	cmp	BYTE PTR [eax+1], 0
	jne	SHORT $LN2@stbtt__isf
	cmp	BYTE PTR [eax+2], 0
	jne	SHORT $LN2@stbtt__isf
	cmp	BYTE PTR [eax+3], 0
	jne	SHORT $LN2@stbtt__isf
$LN8@stbtt__isf:
	mov	eax, 1

; 1154 : }

	pop	ebp
	ret	0
$LN2@stbtt__isf:

; 1149 :    if (stbtt_tag(font, "typ1"))   return 1; // TrueType with type 1 font -- we don't support this!

	movzx	edx, cl
	cmp	edx, 116				; 00000074H
	jne	SHORT $LN3@stbtt__isf
	cmp	BYTE PTR [eax+1], 121			; 00000079H
	jne	SHORT $LN3@stbtt__isf
	cmp	BYTE PTR [eax+2], 112			; 00000070H
	jne	SHORT $LN3@stbtt__isf
	cmp	BYTE PTR [eax+3], 49			; 00000031H
	je	SHORT $LN8@stbtt__isf
$LN3@stbtt__isf:

; 1150 :    if (stbtt_tag(font, "OTTO"))   return 1; // OpenType with CFF

	cmp	edx, 79					; 0000004fH
	jne	SHORT $LN4@stbtt__isf
	cmp	BYTE PTR [eax+1], 84			; 00000054H
	jne	SHORT $LN4@stbtt__isf
	cmp	BYTE PTR [eax+2], 84			; 00000054H
	jne	SHORT $LN4@stbtt__isf
	cmp	BYTE PTR [eax+3], dl
	je	SHORT $LN8@stbtt__isf
$LN4@stbtt__isf:

; 1151 :    if (stbtt_tag4(font, 0,1,0,0)) return 1; // OpenType 1.0

	test	cl, cl
	jne	SHORT $LN5@stbtt__isf
	cmp	BYTE PTR [eax+1], 1
	jne	SHORT $LN5@stbtt__isf
	cmp	BYTE PTR [eax+2], cl
	jne	SHORT $LN5@stbtt__isf
	cmp	BYTE PTR [eax+3], cl
	je	SHORT $LN8@stbtt__isf
$LN5@stbtt__isf:

; 1152 :    if (stbtt_tag(font, "true"))   return 1; // Apple specification for TrueType fonts

	cmp	edx, 116				; 00000074H
	jne	SHORT $LN6@stbtt__isf
	cmp	BYTE PTR [eax+1], 114			; 00000072H
	jne	SHORT $LN6@stbtt__isf
	cmp	BYTE PTR [eax+2], 117			; 00000075H
	jne	SHORT $LN6@stbtt__isf
	cmp	BYTE PTR [eax+3], 101			; 00000065H
	je	SHORT $LN8@stbtt__isf
$LN6@stbtt__isf:

; 1153 :    return 0;

	xor	eax, eax

; 1154 : }

	pop	ebp
	ret	0
?stbtt__isfont@@YAHPAE@Z ENDP				; stbtt__isfont
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_p$ = 8							; size = 4
?ttLONG@@YAHPAE@Z PROC					; ttLONG

; 1140 : static stbtt_int32 ttLONG(stbtt_uint8 *p)    { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, BYTE PTR [edx]
	movzx	ecx, BYTE PTR [edx+1]
	shl	eax, 8
	add	eax, ecx
	movzx	ecx, BYTE PTR [edx+2]
	shl	eax, 8
	add	eax, ecx
	movzx	ecx, BYTE PTR [edx+3]
	shl	eax, 8
	add	eax, ecx
	pop	ebp
	ret	0
?ttLONG@@YAHPAE@Z ENDP					; ttLONG
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_p$ = 8							; size = 4
?ttULONG@@YAIPAE@Z PROC					; ttULONG

; 1139 : static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, BYTE PTR [edx]
	movzx	ecx, BYTE PTR [edx+1]
	shl	eax, 8
	add	eax, ecx
	movzx	ecx, BYTE PTR [edx+2]
	shl	eax, 8
	add	eax, ecx
	movzx	ecx, BYTE PTR [edx+3]
	shl	eax, 8
	add	eax, ecx
	pop	ebp
	ret	0
?ttULONG@@YAIPAE@Z ENDP					; ttULONG
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_p$ = 8							; size = 4
?ttSHORT@@YAFPAE@Z PROC					; ttSHORT

; 1138 : static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _p$[ebp]
	mov	ecx, 256				; 00000100H
	movsx	ecx, cx
	movzx	eax, BYTE PTR [edx]
	cwde
	imul	eax, ecx
	movzx	ecx, BYTE PTR [edx+1]
	add	ax, cx
	pop	ebp
	ret	0
?ttSHORT@@YAFPAE@Z ENDP					; ttSHORT
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_p$ = 8							; size = 4
?ttUSHORT@@YAGPAE@Z PROC				; ttUSHORT

; 1137 : static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _p$[ebp]
	mov	ecx, 256				; 00000100H
	movzx	eax, BYTE PTR [edx]
	imul	eax, ecx
	movzx	ecx, BYTE PTR [edx+1]
	add	ax, cx
	pop	ebp
	ret	0
?ttUSHORT@@YAGPAE@Z ENDP				; ttUSHORT
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
$T1 = -12						; size = 12
$T2 = 8							; size = 4
_b$ = 12						; size = 12
_i$ = 24						; size = 4
?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z PROC	; stbtt__cff_index_get

; 1112 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1113 :    int count, offsize, start, end;
; 1114 :    stbtt__buf_seek(&b, 0);

	lea	eax, DWORD PTR _b$[ebp]
	push	ebx
	push	esi
	push	edi
	push	0
	push	eax
	call	?stbtt__buf_seek@@YAXPAUstbtt__buf@@H@Z	; stbtt__buf_seek

; 1115 :    count = stbtt__buf_get16(&b);

	lea	eax, DWORD PTR _b$[ebp]
	push	2
	push	eax
	call	?stbtt__buf_get@@YAIPAUstbtt__buf@@H@Z	; stbtt__buf_get
	mov	ebx, eax

; 1116 :    offsize = stbtt__buf_get8(&b);

	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	call	?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z	; stbtt__buf_get8
	movzx	edi, al

; 1117 :    STBTT_assert(i >= 0 && i < count);
; 1118 :    STBTT_assert(offsize >= 1 && offsize <= 4);
; 1119 :    stbtt__buf_skip(&b, i*offsize);

	lea	eax, DWORD PTR _b$[ebp]
	mov	ecx, edi
	imul	ecx, DWORD PTR _i$[ebp]
	push	ecx
	push	eax
	call	?stbtt__buf_skip@@YAXPAUstbtt__buf@@H@Z	; stbtt__buf_skip

; 1120 :    start = stbtt__buf_get(&b, offsize);

	lea	eax, DWORD PTR _b$[ebp]
	push	edi
	push	eax
	call	?stbtt__buf_get@@YAIPAUstbtt__buf@@H@Z	; stbtt__buf_get
	mov	esi, eax

; 1121 :    end = stbtt__buf_get(&b, offsize);

	lea	eax, DWORD PTR _b$[ebp]
	push	edi
	push	eax
	call	?stbtt__buf_get@@YAIPAUstbtt__buf@@H@Z	; stbtt__buf_get

; 1122 :    return stbtt__buf_range(&b, 2+(count+1)*offsize+start, end - start);

	sub	eax, esi
	add	esi, 2
	push	eax
	lea	eax, DWORD PTR [ebx+1]
	imul	eax, edi
	add	eax, esi
	push	eax
	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?stbtt__buf_range@@YA?AUstbtt__buf@@PBU1@HH@Z ; stbtt__buf_range
	mov	edx, DWORD PTR $T2[ebp]
	add	esp, 60					; 0000003cH
	movq	xmm0, QWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, edx
	pop	edi
	pop	esi
	movq	QWORD PTR [edx], xmm0
	mov	DWORD PTR [edx+8], ecx
	pop	ebx

; 1123 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?stbtt__cff_index_get@@YA?AUstbtt__buf@@U1@H@Z ENDP	; stbtt__cff_index_get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_b$ = 8							; size = 4
?stbtt__cff_index_count@@YAHPAUstbtt__buf@@@Z PROC	; stbtt__cff_index_count

; 1106 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1107 :    stbtt__buf_seek(b, 0);

	push	0
	push	DWORD PTR _b$[ebp]
	call	?stbtt__buf_seek@@YAXPAUstbtt__buf@@H@Z	; stbtt__buf_seek

; 1108 :    return stbtt__buf_get16(b);

	push	2
	push	DWORD PTR _b$[ebp]
	call	?stbtt__buf_get@@YAIPAUstbtt__buf@@H@Z	; stbtt__buf_get
	add	esp, 16					; 00000010H

; 1109 : }

	pop	ebp
	ret	0
?stbtt__cff_index_count@@YAHPAUstbtt__buf@@@Z ENDP	; stbtt__cff_index_count
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
$T1 = -24						; size = 12
_operands$ = -12					; size = 12
_b$ = 8							; size = 4
_key$ = 12						; size = 4
_outcount$ = 16						; size = 4
_out$ = 20						; size = 4
?stbtt__dict_get_ints@@YAXPAUstbtt__buf@@HHPAI@Z PROC	; stbtt__dict_get_ints

; 1098 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi

; 1099 :    int i;
; 1100 :    stbtt__buf operands = stbtt__dict_get(b, key);

	push	DWORD PTR _key$[ebp]
	lea	eax, DWORD PTR $T1[ebp]
	push	DWORD PTR _b$[ebp]
	push	eax
	call	?stbtt__dict_get@@YA?AUstbtt__buf@@PAU1@H@Z ; stbtt__dict_get

; 1101 :    for (i = 0; i < outcount && operands.cursor < operands.size; i++)

	mov	ebx, DWORD PTR _outcount$[ebp]
	add	esp, 12					; 0000000cH
	xor	esi, esi
	movq	xmm0, QWORD PTR [eax]
	mov	eax, DWORD PTR [eax+8]
	movq	QWORD PTR _operands$[ebp], xmm0
	mov	DWORD PTR _operands$[ebp+8], eax
	test	ebx, ebx
	jle	SHORT $LN13@stbtt__dic
	push	edi
	mov	edi, DWORD PTR _out$[ebp]
$LL4@stbtt__dic:
	cmp	DWORD PTR _operands$[ebp+4], eax
	jge	SHORT $LN14@stbtt__dic

; 1102 :       out[i] = stbtt__cff_int(&operands);

	lea	eax, DWORD PTR _operands$[ebp]
	push	eax
	call	?stbtt__cff_int@@YAIPAUstbtt__buf@@@Z	; stbtt__cff_int
	mov	DWORD PTR [edi+esi*4], eax
	add	esp, 4
	inc	esi
	cmp	esi, ebx
	jge	SHORT $LN14@stbtt__dic

; 1101 :    for (i = 0; i < outcount && operands.cursor < operands.size; i++)

	mov	eax, DWORD PTR _operands$[ebp+8]
	jmp	SHORT $LL4@stbtt__dic
$LN14@stbtt__dic:
	pop	edi
$LN13@stbtt__dic:
	pop	esi
	pop	ebx

; 1103 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?stbtt__dict_get_ints@@YAXPAUstbtt__buf@@HHPAI@Z ENDP	; stbtt__dict_get_ints
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
$T1 = -12						; size = 12
$T2 = 8							; size = 4
_b$ = 12						; size = 4
_key$ = 16						; size = 4
?stbtt__dict_get@@YA?AUstbtt__buf@@PAU1@H@Z PROC	; stbtt__dict_get

; 1083 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 1084 :    stbtt__buf_seek(b, 0);

	mov	esi, DWORD PTR _b$[ebp]
	push	edi
	push	0
	push	esi
	call	?stbtt__buf_seek@@YAXPAUstbtt__buf@@H@Z	; stbtt__buf_seek

; 1085 :    while (b->cursor < b->size) {

	mov	edi, DWORD PTR [esi+4]
	add	esp, 8
	cmp	edi, DWORD PTR [esi+8]
	jge	SHORT $LN3@stbtt__dic
$LL2@stbtt__dic:

; 1086 :       int start = b->cursor, end, op;
; 1087 :       while (stbtt__buf_peek8(b) >= 28)

	push	esi
	call	?stbtt__buf_peek8@@YAEPAUstbtt__buf@@@Z	; stbtt__buf_peek8
	add	esp, 4
	cmp	al, 28					; 0000001cH
	jb	SHORT $LN5@stbtt__dic
	npad	2
$LL4@stbtt__dic:

; 1088 :          stbtt__cff_skip_operand(b);

	push	esi
	call	?stbtt__cff_skip_operand@@YAXPAUstbtt__buf@@@Z ; stbtt__cff_skip_operand
	push	esi
	call	?stbtt__buf_peek8@@YAEPAUstbtt__buf@@@Z	; stbtt__buf_peek8
	add	esp, 8
	cmp	al, 28					; 0000001cH
	jae	SHORT $LL4@stbtt__dic
$LN5@stbtt__dic:

; 1089 :       end = b->cursor;

	mov	ebx, DWORD PTR [esi+4]

; 1090 :       op = stbtt__buf_get8(b);

	push	esi
	call	?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z	; stbtt__buf_get8
	movzx	eax, al
	add	esp, 4
	cmp	eax, 12					; 0000000cH

; 1091 :       if (op == 12)  op = stbtt__buf_get8(b) | 0x100;

	jne	SHORT $LN6@stbtt__dic
	push	esi
	call	?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z	; stbtt__buf_get8
	movzx	eax, al
	add	esp, 4
	or	eax, 256				; 00000100H
$LN6@stbtt__dic:

; 1092 :       if (op == key) return stbtt__buf_range(b, start, end-start);

	cmp	eax, DWORD PTR _key$[ebp]
	je	SHORT $LN11@stbtt__dic

; 1085 :    while (b->cursor < b->size) {

	mov	edi, DWORD PTR [esi+4]
	cmp	edi, DWORD PTR [esi+8]
	jl	SHORT $LL2@stbtt__dic
$LN3@stbtt__dic:

; 1093 :    }
; 1094 :    return stbtt__buf_range(b, 0, 0);

	push	0
	push	0
$LN17@stbtt__dic:
	lea	eax, DWORD PTR $T1[ebp]
	push	esi
	push	eax
	call	?stbtt__buf_range@@YA?AUstbtt__buf@@PBU1@HH@Z ; stbtt__buf_range
	mov	edx, DWORD PTR $T2[ebp]
	add	esp, 16					; 00000010H
	movq	xmm0, QWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, edx
	pop	edi
	pop	esi
	movq	QWORD PTR [edx], xmm0
	mov	DWORD PTR [edx+8], ecx
	pop	ebx

; 1095 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@stbtt__dic:

; 1092 :       if (op == key) return stbtt__buf_range(b, start, end-start);

	sub	ebx, edi
	push	ebx
	push	edi
	jmp	SHORT $LN17@stbtt__dic
?stbtt__dict_get@@YA?AUstbtt__buf@@PAU1@H@Z ENDP	; stbtt__dict_get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_b$ = 8							; size = 4
?stbtt__cff_skip_operand@@YAXPAUstbtt__buf@@@Z PROC	; stbtt__cff_skip_operand

; 1067 : static void stbtt__cff_skip_operand(stbtt__buf *b) {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 1068 :    int v, b0 = stbtt__buf_peek8(b);

	mov	esi, DWORD PTR _b$[ebp]
	push	esi
	call	?stbtt__buf_peek8@@YAEPAUstbtt__buf@@@Z	; stbtt__buf_peek8
	add	esp, 4

; 1069 :    STBTT_assert(b0 >= 28);
; 1070 :    if (b0 == 30) {

	cmp	al, 30					; 0000001eH
	jne	SHORT $LN4@stbtt__cff

; 1071 :       stbtt__buf_skip(b, 1);

	push	1
	push	esi
	call	?stbtt__buf_skip@@YAXPAUstbtt__buf@@H@Z	; stbtt__buf_skip

; 1072 :       while (b->cursor < b->size) {

	mov	eax, DWORD PTR [esi+4]
	add	esp, 8
	cmp	eax, DWORD PTR [esi+8]
	jge	SHORT $LN5@stbtt__cff
	npad	7
$LL2@stbtt__cff:

; 1073 :          v = stbtt__buf_get8(b);

	push	esi
	call	?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z	; stbtt__buf_get8
	movzx	ecx, al
	add	esp, 4

; 1074 :          if ((v & 0xF) == 0xF || (v >> 4) == 0xF)

	mov	eax, ecx
	and	eax, 15					; 0000000fH
	cmp	al, 15					; 0000000fH
	je	SHORT $LN5@stbtt__cff
	and	ecx, -16				; fffffff0H
	cmp	ecx, 240				; 000000f0H
	je	SHORT $LN5@stbtt__cff

; 1072 :       while (b->cursor < b->size) {

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, DWORD PTR [esi+8]
	jl	SHORT $LL2@stbtt__cff
	pop	esi

; 1079 :    }
; 1080 : }

	pop	ebp
	ret	0
$LN4@stbtt__cff:

; 1075 :             break;
; 1076 :       }
; 1077 :    } else {
; 1078 :       stbtt__cff_int(b);

	push	esi
	call	?stbtt__cff_int@@YAIPAUstbtt__buf@@@Z	; stbtt__cff_int
	add	esp, 4
$LN5@stbtt__cff:
	pop	esi

; 1079 :    }
; 1080 : }

	pop	ebp
	ret	0
?stbtt__cff_skip_operand@@YAXPAUstbtt__buf@@@Z ENDP	; stbtt__cff_skip_operand
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_b$ = 8							; size = 4
?stbtt__cff_int@@YAIPAUstbtt__buf@@@Z PROC		; stbtt__cff_int

; 1056 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 1057 :    int b0 = stbtt__buf_get8(b);

	mov	edi, DWORD PTR _b$[ebp]
	push	edi
	call	?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z	; stbtt__buf_get8
	movzx	esi, al
	add	esp, 4
	lea	eax, DWORD PTR [esi-32]
	cmp	eax, 214				; 000000d6H

; 1058 :    if (b0 >= 32 && b0 <= 246)       return b0 - 139;

	ja	SHORT $LN2@stbtt__cff
	pop	edi
	lea	eax, DWORD PTR [esi-139]
	pop	esi

; 1065 : }

	pop	ebp
	ret	0
$LN2@stbtt__cff:
	cmp	esi, 247				; 000000f7H

; 1059 :    else if (b0 >= 247 && b0 <= 250) return (b0 - 247)*256 + stbtt__buf_get8(b) + 108;

	jb	SHORT $LN4@stbtt__cff
	cmp	esi, 250				; 000000faH
	ja	SHORT $LN4@stbtt__cff
	push	edi
	call	?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z	; stbtt__buf_get8
	add	esp, 4
	movzx	eax, al
	shl	esi, 8
	add	eax, -63124				; ffff096cH
	add	eax, esi
	pop	edi
	pop	esi

; 1065 : }

	pop	ebp
	ret	0
$LN4@stbtt__cff:
	cmp	esi, 251				; 000000fbH

; 1060 :    else if (b0 >= 251 && b0 <= 254) return -(b0 - 251)*256 - stbtt__buf_get8(b) - 108;

	jb	SHORT $LN6@stbtt__cff
	cmp	esi, 254				; 000000feH
	ja	SHORT $LN6@stbtt__cff
	push	edi
	call	?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z	; stbtt__buf_get8
	add	esp, 4
	movzx	ecx, al
	shl	esi, 8
	mov	eax, 64148				; 0000fa94H
	sub	eax, esi
	sub	eax, ecx
	pop	edi
	pop	esi

; 1065 : }

	pop	ebp
	ret	0
$LN6@stbtt__cff:
	cmp	esi, 28					; 0000001cH

; 1061 :    else if (b0 == 28)               return stbtt__buf_get16(b);

	jne	SHORT $LN8@stbtt__cff
	push	2
	push	edi
	call	?stbtt__buf_get@@YAIPAUstbtt__buf@@H@Z	; stbtt__buf_get
	add	esp, 8
	pop	edi
	pop	esi

; 1065 : }

	pop	ebp
	ret	0
$LN8@stbtt__cff:
	cmp	esi, 29					; 0000001dH

; 1062 :    else if (b0 == 29)               return stbtt__buf_get32(b);

	jne	SHORT $LN10@stbtt__cff
	push	4
	push	edi
	call	?stbtt__buf_get@@YAIPAUstbtt__buf@@H@Z	; stbtt__buf_get
	add	esp, 8
	pop	edi
	pop	esi

; 1065 : }

	pop	ebp
	ret	0
$LN10@stbtt__cff:
	pop	edi

; 1063 :    STBTT_assert(0);
; 1064 :    return 0;

	xor	eax, eax
	pop	esi

; 1065 : }

	pop	ebp
	ret	0
?stbtt__cff_int@@YAIPAUstbtt__buf@@@Z ENDP		; stbtt__cff_int
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
$T1 = -12						; size = 12
$T2 = 8							; size = 4
_start$1$ = 12						; size = 4
_b$ = 12						; size = 4
?stbtt__cff_get_index@@YA?AUstbtt__buf@@PAU1@@Z PROC	; stbtt__cff_get_index

; 1042 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi

; 1043 :    int count, start, offsize;
; 1044 :    start = b->cursor;

	mov	edi, DWORD PTR _b$[ebp]

; 1045 :    count = stbtt__buf_get16(b);

	push	2
	push	edi
	mov	esi, DWORD PTR [edi+4]
	mov	DWORD PTR _start$1$[ebp], esi
	call	?stbtt__buf_get@@YAIPAUstbtt__buf@@H@Z	; stbtt__buf_get
	mov	ebx, eax
	add	esp, 8

; 1046 :    if (count) {

	test	ebx, ebx
	je	SHORT $LN2@stbtt__cff

; 1047 :       offsize = stbtt__buf_get8(b);

	push	edi
	call	?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z	; stbtt__buf_get8
	movzx	esi, al

; 1048 :       STBTT_assert(offsize >= 1 && offsize <= 4);
; 1049 :       stbtt__buf_skip(b, offsize * count);

	mov	ecx, esi
	imul	ecx, ebx
	push	ecx
	push	edi
	call	?stbtt__buf_skip@@YAXPAUstbtt__buf@@H@Z	; stbtt__buf_skip

; 1050 :       stbtt__buf_skip(b, stbtt__buf_get(b, offsize) - 1);

	push	esi
	push	edi
	call	?stbtt__buf_get@@YAIPAUstbtt__buf@@H@Z	; stbtt__buf_get
	dec	eax
	push	eax
	push	edi
	call	?stbtt__buf_skip@@YAXPAUstbtt__buf@@H@Z	; stbtt__buf_skip
	mov	esi, DWORD PTR _start$1$[ebp]
	add	esp, 28					; 0000001cH
$LN2@stbtt__cff:

; 1051 :    }
; 1052 :    return stbtt__buf_range(b, start, b->cursor - start);

	mov	eax, DWORD PTR [edi+4]
	sub	eax, esi
	push	eax
	push	esi
	lea	eax, DWORD PTR $T1[ebp]
	push	edi
	push	eax
	call	?stbtt__buf_range@@YA?AUstbtt__buf@@PBU1@HH@Z ; stbtt__buf_range
	mov	edx, DWORD PTR $T2[ebp]
	add	esp, 16					; 00000010H
	movq	xmm0, QWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, edx
	pop	edi
	pop	esi
	movq	QWORD PTR [edx], xmm0
	mov	DWORD PTR [edx+8], ecx
	pop	ebx

; 1053 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?stbtt__cff_get_index@@YA?AUstbtt__buf@@PAU1@@Z ENDP	; stbtt__cff_get_index
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
$T1 = -12						; size = 12
$T2 = 8							; size = 4
_b$ = 12						; size = 4
_o$ = 16						; size = 4
_s$ = 20						; size = 4
?stbtt__buf_range@@YA?AUstbtt__buf@@PBU1@HH@Z PROC	; stbtt__buf_range

; 1033 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1034 :    stbtt__buf r = stbtt__new_buf(NULL, 0);

	lea	eax, DWORD PTR $T1[ebp]
	push	esi
	push	edi
	push	0
	push	0
	push	eax
	call	?stbtt__new_buf@@YA?AUstbtt__buf@@PBXI@Z ; stbtt__new_buf
	mov	edx, DWORD PTR $T2[ebp]
	add	esp, 12					; 0000000cH

; 1035 :    if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;

	mov	edi, DWORD PTR _o$[ebp]
	movq	xmm0, QWORD PTR [eax]
	mov	eax, DWORD PTR [eax+8]
	movq	QWORD PTR [edx], xmm0
	mov	DWORD PTR [edx+8], eax
	test	edi, edi
	js	SHORT $LN3@stbtt__buf
	mov	esi, DWORD PTR _s$[ebp]
	test	esi, esi
	js	SHORT $LN3@stbtt__buf
	mov	ecx, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	cmp	edi, eax
	jg	SHORT $LN3@stbtt__buf
	sub	eax, edi
	cmp	esi, eax
	jg	SHORT $LN3@stbtt__buf

; 1036 :    r.data = b->data + o;

	mov	ecx, DWORD PTR [ecx]
	add	ecx, edi

; 1037 :    r.size = s;

	mov	DWORD PTR [edx+8], esi
	mov	DWORD PTR [edx], ecx
$LN3@stbtt__buf:

; 1035 :    if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;

	pop	edi
	mov	eax, edx
	pop	esi

; 1038 :    return r;
; 1039 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?stbtt__buf_range@@YA?AUstbtt__buf@@PBU1@HH@Z ENDP	; stbtt__buf_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
$T1 = 8							; size = 4
_p$ = 12						; size = 4
_size$ = 16						; size = 4
?stbtt__new_buf@@YA?AUstbtt__buf@@PBXI@Z PROC		; stbtt__new_buf

; 1020 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1021 :    stbtt__buf r;
; 1022 :    STBTT_assert(size < 0x40000000);
; 1023 :    r.data = (stbtt_uint8*) p;

	mov	eax, DWORD PTR $T1[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], ecx

; 1024 :    r.size = (int) size;

	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1025 :    r.cursor = 0;

	mov	DWORD PTR [eax+4], 0

; 1026 :    return r;
; 1027 : }

	pop	ebp
	ret	0
?stbtt__new_buf@@YA?AUstbtt__buf@@PBXI@Z ENDP		; stbtt__new_buf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_b$ = 8							; size = 4
_n$ = 12						; size = 4
?stbtt__buf_get@@YAIPAUstbtt__buf@@H@Z PROC		; stbtt__buf_get

; 1010 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 1012 :    int i;
; 1013 :    STBTT_assert(n >= 1 && n <= 4);
; 1014 :    for (i = 0; i < n; i++)

	mov	edi, DWORD PTR _n$[ebp]
	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN10@stbtt__buf

; 1011 :    stbtt_uint32 v = 0;

	push	ebx
	mov	ebx, DWORD PTR _b$[ebp]
$LL4@stbtt__buf:

; 1015 :       v = (v << 8) | stbtt__buf_get8(b);

	push	ebx
	call	?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z	; stbtt__buf_get8
	shl	esi, 8
	add	esp, 4
	movzx	eax, al
	or	esi, eax
	sub	edi, 1
	jne	SHORT $LL4@stbtt__buf
	pop	ebx
$LN10@stbtt__buf:
	pop	edi

; 1016 :    return v;

	mov	eax, esi
	pop	esi

; 1017 : }

	pop	ebp
	ret	0
?stbtt__buf_get@@YAIPAUstbtt__buf@@H@Z ENDP		; stbtt__buf_get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_b$ = 8							; size = 4
_o$ = 12						; size = 4
?stbtt__buf_skip@@YAXPAUstbtt__buf@@H@Z PROC		; stbtt__buf_skip

; 1005 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1006 :    stbtt__buf_seek(b, b->cursor + o);

	mov	ecx, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	add	DWORD PTR _o$[ebp], eax
	mov	DWORD PTR _b$[ebp], ecx

; 1007 : }

	pop	ebp

; 1006 :    stbtt__buf_seek(b, b->cursor + o);

	jmp	?stbtt__buf_seek@@YAXPAUstbtt__buf@@H@Z	; stbtt__buf_seek
?stbtt__buf_skip@@YAXPAUstbtt__buf@@H@Z ENDP		; stbtt__buf_skip
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_b$ = 8							; size = 4
_o$ = 12						; size = 4
?stbtt__buf_seek@@YAXPAUstbtt__buf@@H@Z PROC		; stbtt__buf_seek

; 999  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1000 :    STBTT_assert(!(o > b->size || o < 0));
; 1001 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	mov	ecx, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR _o$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	eax, edx
	jg	SHORT $LN3@stbtt__buf
	test	eax, eax
	js	SHORT $LN3@stbtt__buf
	mov	DWORD PTR [ecx+4], eax

; 1002 : }

	pop	ebp
	ret	0
$LN3@stbtt__buf:

; 1000 :    STBTT_assert(!(o > b->size || o < 0));
; 1001 :    b->cursor = (o > b->size || o < 0) ? b->size : o;

	mov	DWORD PTR [ecx+4], edx

; 1002 : }

	pop	ebp
	ret	0
?stbtt__buf_seek@@YAXPAUstbtt__buf@@H@Z ENDP		; stbtt__buf_seek
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_b$ = 8							; size = 4
?stbtt__buf_peek8@@YAEPAUstbtt__buf@@@Z PROC		; stbtt__buf_peek8

; 992  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 993  :    if (b->cursor >= b->size)

	mov	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR [eax+8]
	jl	SHORT $LN2@stbtt__buf

; 994  :       return 0;

	xor	al, al

; 996  : }

	pop	ebp
	ret	0
$LN2@stbtt__buf:

; 995  :    return b->data[b->cursor];

	mov	eax, DWORD PTR [eax]
	mov	al, BYTE PTR [ecx+eax]

; 996  : }

	pop	ebp
	ret	0
?stbtt__buf_peek8@@YAEPAUstbtt__buf@@@Z ENDP		; stbtt__buf_peek8
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_b$ = 8							; size = 4
?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z PROC		; stbtt__buf_get8

; 985  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 986  :    if (b->cursor >= b->size)

	mov	edx, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [edx+8]
	jl	SHORT $LN2@stbtt__buf

; 987  :       return 0;

	xor	al, al

; 989  : }

	pop	ebp
	ret	0
$LN2@stbtt__buf:

; 988  :    return b->data[b->cursor++];

	mov	eax, DWORD PTR [edx]
	mov	al, BYTE PTR [ecx+eax]
	inc	ecx
	mov	DWORD PTR [edx+4], ecx

; 989  : }

	pop	ebp
	ret	0
?stbtt__buf_get8@@YAEPAUstbtt__buf@@@Z ENDP		; stbtt__buf_get8
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_winding_lengths$ = -8					; size = 4
_winding_count$ = -4					; size = 4
_result$ = 8						; size = 4
_flatness_in_pixels$ = 12				; size = 4
_vertices$ = 16						; size = 4
_num_verts$ = 20					; size = 4
_scale_x$ = 24						; size = 4
_scale_y$ = 28						; size = 4
_shift_x$ = 32						; size = 4
_shift_y$ = 36						; size = 4
_x_off$ = 40						; size = 4
_y_off$ = 44						; size = 4
_invert$ = 48						; size = 4
_userdata$ = 52						; size = 4
_stbtt_Rasterize PROC

; 3133 : {

	npad	2
	push	ebp
	mov	ebp, esp
	movss	xmm1, DWORD PTR _scale_x$[ebp]

; 3134 :    float scale = scale_x > scale_y ? scale_y : scale_x;
; 3135 :    int winding_count, *winding_lengths;
; 3136 :    stbtt__point *windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);

	lea	eax, DWORD PTR _winding_count$[ebp]
	minss	xmm1, DWORD PTR _scale_y$[ebp]
	movss	xmm0, DWORD PTR _flatness_in_pixels$[ebp]
	sub	esp, 8
	divss	xmm0, xmm1
	push	esi
	mov	esi, DWORD PTR _userdata$[ebp]
	push	edi
	push	esi
	push	eax
	lea	eax, DWORD PTR _winding_lengths$[ebp]
	push	eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _num_verts$[ebp]
	push	DWORD PTR _vertices$[ebp]
	call	?stbtt_FlattenCurves@@YAPAUstbtt__point@@PAUstbtt_vertex@@HMPAPAHPAHPAX@Z ; stbtt_FlattenCurves
	mov	edi, eax
	add	esp, 24					; 00000018H

; 3137 :    if (windings) {

	test	edi, edi
	je	SHORT $LN2@stbtt_Rast

; 3138 :       stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);

	movss	xmm0, DWORD PTR _shift_y$[ebp]
	push	esi
	push	DWORD PTR _invert$[ebp]
	mov	esi, DWORD PTR _winding_lengths$[ebp]
	push	DWORD PTR _y_off$[ebp]
	push	DWORD PTR _x_off$[ebp]
	sub	esp, 16					; 00000010H
	movss	DWORD PTR [esp+12], xmm0
	movss	xmm0, DWORD PTR _shift_x$[ebp]
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _scale_y$[ebp]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _scale_x$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _winding_count$[ebp]
	push	esi
	push	edi
	push	DWORD PTR _result$[ebp]
	call	?stbtt__rasterize@@YAXPAUstbtt__bitmap@@PAUstbtt__point@@PAHHMMMMHHHPAX@Z ; stbtt__rasterize

; 3139 :       STBTT_free(winding_lengths, userdata);

	push	esi
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 3140 :       STBTT_free(windings, userdata);

	push	edi
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 56					; 00000038H
$LN2@stbtt_Rast:
	pop	edi
	pop	esi

; 3141 :    }
; 3142 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_stbtt_Rasterize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
tv297 = -20						; size = 8
tv287 = -20						; size = 8
_x1$ = -16						; size = 4
_y1$ = -12						; size = 4
_y0$ = -8						; size = 4
_x0$ = -4						; size = 4
_font$ = 8						; size = 4
_glyph$ = 12						; size = 4
_scale_x$ = 16						; size = 4
_scale_y$ = 20						; size = 4
_shift_x$ = 24						; size = 4
_shift_y$ = 28						; size = 4
_ix0$ = 32						; size = 4
_iy0$ = 36						; size = 4
_ix1$ = 40						; size = 4
_iy1$ = 44						; size = 4
_stbtt_GetGlyphBitmapBoxSubpixel PROC

; 2234 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2235 :    int x0=0,y0=0,x1,y1; // =0 suppresses compiler warning
; 2236 :    if (!stbtt_GetGlyphBox(font, glyph, &x0,&y0,&x1,&y1)) {

	lea	eax, DWORD PTR _y1$[ebp]
	mov	DWORD PTR _x0$[ebp], 0
	push	eax
	lea	eax, DWORD PTR _x1$[ebp]
	mov	DWORD PTR _y0$[ebp], 0
	push	eax
	lea	eax, DWORD PTR _y0$[ebp]
	push	eax
	lea	eax, DWORD PTR _x0$[ebp]
	push	eax
	push	DWORD PTR _glyph$[ebp]
	push	DWORD PTR _font$[ebp]
	call	_stbtt_GetGlyphBox
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	SHORT $LN2@stbtt_GetG

; 2237 :       // e.g. space character
; 2238 :       if (ix0) *ix0 = 0;

	mov	eax, DWORD PTR _ix0$[ebp]
	test	eax, eax
	je	SHORT $LN4@stbtt_GetG
	mov	DWORD PTR [eax], 0
$LN4@stbtt_GetG:

; 2239 :       if (iy0) *iy0 = 0;

	mov	eax, DWORD PTR _iy0$[ebp]
	test	eax, eax
	je	SHORT $LN5@stbtt_GetG
	mov	DWORD PTR [eax], 0
$LN5@stbtt_GetG:

; 2240 :       if (ix1) *ix1 = 0;

	mov	eax, DWORD PTR _ix1$[ebp]
	test	eax, eax
	je	SHORT $LN6@stbtt_GetG
	mov	DWORD PTR [eax], 0
$LN6@stbtt_GetG:

; 2241 :       if (iy1) *iy1 = 0;

	mov	eax, DWORD PTR _iy1$[ebp]
	test	eax, eax
	je	$LN11@stbtt_GetG
	mov	DWORD PTR [eax], 0

; 2248 :    }
; 2249 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@stbtt_GetG:

; 2242 :    } else {
; 2243 :       // move to integral bboxes (treating pixels as little squares, what pixels get touched)?
; 2244 :       if (ix0) *ix0 = STBTT_ifloor( x0 * scale_x + shift_x);

	mov	ecx, DWORD PTR _ix0$[ebp]
	movss	xmm6, DWORD PTR _shift_x$[ebp]
	movss	xmm7, DWORD PTR _scale_x$[ebp]
	movsd	xmm4, QWORD PTR __real@8000000000000000
	movsd	xmm5, QWORD PTR __real@4330000000000000
	test	ecx, ecx
	je	SHORT $LN8@stbtt_GetG
	movd	xmm0, DWORD PTR _x0$[ebp]
	movaps	xmm1, xmm5
	cvtdq2ps xmm0, xmm0
	movsd	xmm3, QWORD PTR __real@8000000000000000
	mulss	xmm0, xmm7
	addss	xmm0, xmm6
	cvtps2pd xmm4, xmm0
	andps	xmm3, xmm4
	movaps	xmm0, xmm4
	xorps	xmm0, xmm3
	movaps	xmm2, xmm4
	cmpltsd	xmm0, xmm5
	andps	xmm1, xmm0
	orps	xmm1, xmm3
	addsd	xmm2, xmm1
	subsd	xmm2, xmm1
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	movaps	xmm0, xmm2
	subsd	xmm0, xmm4
	movsd	xmm4, QWORD PTR __real@8000000000000000
	cmpnlesd xmm0, xmm3
	andps	xmm0, xmm1
	subsd	xmm2, xmm0
	cvttsd2si eax, xmm2
	mov	DWORD PTR [ecx], eax
$LN8@stbtt_GetG:

; 2245 :       if (iy0) *iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);

	mov	ecx, DWORD PTR _iy0$[ebp]
	movss	xmm3, DWORD PTR _scale_y$[ebp]
	test	ecx, ecx
	je	SHORT $LN9@stbtt_GetG
	movd	xmm1, DWORD PTR _y1$[ebp]
	movss	xmm0, DWORD PTR _shift_y$[ebp]
	cvtdq2ps xmm1, xmm1
	mulss	xmm1, xmm3
	subss	xmm0, xmm1
	cvtps2pd xmm2, xmm0
	andps	xmm4, xmm2
	movaps	xmm0, xmm2
	xorps	xmm0, xmm4
	movaps	xmm1, xmm2
	cmpltsd	xmm0, xmm5
	andps	xmm5, xmm0
	orps	xmm5, xmm4
	addsd	xmm1, xmm5
	subsd	xmm1, xmm5
	movaps	xmm0, xmm1
	subsd	xmm0, xmm2
	movsd	xmm2, QWORD PTR __real@3ff0000000000000
	cmpnlesd xmm0, xmm4
	andps	xmm0, xmm2
	subsd	xmm1, xmm0
	cvttsd2si eax, xmm1
	mov	DWORD PTR [ecx], eax
$LN9@stbtt_GetG:

; 2246 :       if (ix1) *ix1 = STBTT_iceil ( x1 * scale_x + shift_x);

	push	esi
	mov	esi, DWORD PTR _ix1$[ebp]
	test	esi, esi
	je	SHORT $LN10@stbtt_GetG
	movd	xmm0, DWORD PTR _x1$[ebp]
	sub	esp, 8
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm7
	addss	xmm0, xmm6
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR tv287[ebp], xmm0
	fld	QWORD PTR tv287[ebp]
	fstp	QWORD PTR [esp]
	call	_ceil
	add	esp, 8
	call	__ftol2_sse
	movss	xmm3, DWORD PTR _scale_y$[ebp]
	mov	DWORD PTR [esi], eax
$LN10@stbtt_GetG:

; 2247 :       if (iy1) *iy1 = STBTT_iceil (-y0 * scale_y + shift_y);

	mov	esi, DWORD PTR _iy1$[ebp]
	test	esi, esi
	je	SHORT $LN13@stbtt_GetG
	movd	xmm0, DWORD PTR _y0$[ebp]
	sub	esp, 8
	movss	xmm1, DWORD PTR _shift_y$[ebp]
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm3
	subss	xmm1, xmm0
	cvtps2pd xmm0, xmm1
	movsd	QWORD PTR tv297[ebp], xmm0
	fld	QWORD PTR tv297[ebp]
	fstp	QWORD PTR [esp]
	call	_ceil
	add	esp, 8
	call	__ftol2_sse
	mov	DWORD PTR [esi], eax
$LN13@stbtt_GetG:
	pop	esi
$LN11@stbtt_GetG:

; 2248 :    }
; 2249 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_stbtt_GetGlyphBitmapBoxSubpixel ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_font$ = 8						; size = 4
_glyph$ = 12						; size = 4
_scale_x$ = 16						; size = 4
_scale_y$ = 20						; size = 4
_ix0$ = 24						; size = 4
_iy0$ = 28						; size = 4
_ix1$ = 32						; size = 4
_iy1$ = 36						; size = 4
_stbtt_GetGlyphBitmapBox PROC

; 2252 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2253 :    stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y,0.0f,0.0f, ix0, iy0, ix1, iy1);

	push	DWORD PTR _iy1$[ebp]
	movss	xmm0, DWORD PTR _scale_y$[ebp]
	push	DWORD PTR _ix1$[ebp]
	push	DWORD PTR _iy0$[ebp]
	push	DWORD PTR _ix0$[ebp]
	sub	esp, 16					; 00000010H
	mov	DWORD PTR [esp+12], 0
	mov	DWORD PTR [esp+8], 0
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _scale_x$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _glyph$[ebp]
	push	DWORD PTR _font$[ebp]
	call	_stbtt_GetGlyphBitmapBoxSubpixel
	add	esp, 40					; 00000028H

; 2254 : }

	pop	ebp
	ret	0
_stbtt_GetGlyphBitmapBox ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_gbm$ = -28						; size = 16
_ix0$ = -12						; size = 4
_iy0$ = -8						; size = 4
_vertices$ = -4						; size = 4
_info$ = 8						; size = 4
_output$ = 12						; size = 4
_out_w$ = 16						; size = 4
_out_h$ = 20						; size = 4
_out_stride$ = 24					; size = 4
_scale_x$ = 28						; size = 4
_scale_y$ = 32						; size = 4
_shift_x$ = 36						; size = 4
_shift_y$ = 40						; size = 4
_glyph$ = 44						; size = 4
_stbtt_MakeGlyphBitmapSubpixel PROC

; 3195 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi

; 3196 :    int ix0,iy0;
; 3197 :    stbtt_vertex *vertices;
; 3198 :    int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);

	mov	esi, DWORD PTR _glyph$[ebp]
	lea	eax, DWORD PTR _vertices$[ebp]
	push	edi
	mov	edi, DWORD PTR _info$[ebp]
	push	eax
	push	esi
	push	edi
	call	_stbtt_GetGlyphShape

; 3199 :    stbtt__bitmap gbm;   
; 3200 : 
; 3201 :    stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0,&iy0,0,0);

	movss	xmm0, DWORD PTR _shift_y$[ebp]
	add	esp, 12					; 0000000cH
	mov	ebx, eax
	lea	eax, DWORD PTR _iy0$[ebp]
	push	0
	push	0
	push	eax
	lea	eax, DWORD PTR _ix0$[ebp]
	push	eax
	sub	esp, 16					; 00000010H
	movss	DWORD PTR [esp+12], xmm0
	movss	xmm0, DWORD PTR _shift_x$[ebp]
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _scale_y$[ebp]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _scale_x$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	esi
	push	edi
	call	_stbtt_GetGlyphBitmapBoxSubpixel

; 3202 :    gbm.pixels = output;

	mov	eax, DWORD PTR _output$[ebp]
	add	esp, 40					; 00000028H

; 3203 :    gbm.w = out_w;

	mov	ecx, DWORD PTR _out_w$[ebp]

; 3204 :    gbm.h = out_h;

	mov	edx, DWORD PTR _out_h$[ebp]

; 3205 :    gbm.stride = out_stride;
; 3206 : 
; 3207 :    if (gbm.w && gbm.h)

	mov	esi, DWORD PTR _vertices$[ebp]
	mov	DWORD PTR _gbm$[ebp+12], eax
	mov	eax, DWORD PTR _out_stride$[ebp]
	mov	DWORD PTR _gbm$[ebp], ecx
	mov	DWORD PTR _gbm$[ebp+4], edx
	mov	DWORD PTR _gbm$[ebp+8], eax
	test	ecx, ecx
	je	SHORT $LN2@stbtt_Make
	test	edx, edx
	je	SHORT $LN2@stbtt_Make

; 3208 :       stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0,iy0, 1, info->userdata);

	push	DWORD PTR [edi]
	movss	xmm0, DWORD PTR _shift_y$[ebp]
	lea	eax, DWORD PTR _gbm$[ebp]
	push	1
	push	DWORD PTR _iy0$[ebp]
	push	DWORD PTR _ix0$[ebp]
	sub	esp, 16					; 00000010H
	movss	DWORD PTR [esp+12], xmm0
	movss	xmm0, DWORD PTR _shift_x$[ebp]
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _scale_y$[ebp]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _scale_x$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ebx
	push	esi
	push	ecx
	mov	DWORD PTR [esp], 1051931443		; 3eb33333H
	push	eax
	call	_stbtt_Rasterize
	add	esp, 48					; 00000030H
$LN2@stbtt_Make:

; 3209 : 
; 3210 :    STBTT_free(vertices, info->userdata);

	push	esi
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 3211 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_stbtt_MakeGlyphBitmapSubpixel ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_info$ = 8						; size = 4
_glyph_index$ = 12					; size = 4
_pvertices$ = 16					; size = 4
_stbtt_GetGlyphShape PROC

; 2135 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2136 :    if (!info->cff.size)

	mov	eax, DWORD PTR _info$[ebp]
	cmp	DWORD PTR [eax+56], 0
	jne	SHORT $LN2@stbtt_GetG

; 2137 :       return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);

	mov	DWORD PTR _info$[ebp], eax

; 2140 : }

	pop	ebp

; 2137 :       return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);

	jmp	?stbtt__GetGlyphShapeTT@@YAHPBUstbtt_fontinfo@@HPAPAUstbtt_vertex@@@Z ; stbtt__GetGlyphShapeTT
$LN2@stbtt_GetG:

; 2138 :    else
; 2139 :       return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);

	mov	DWORD PTR _info$[ebp], eax

; 2140 : }

	pop	ebp

; 2138 :    else
; 2139 :       return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);

	jmp	?stbtt__GetGlyphShapeT2@@YAHPBUstbtt_fontinfo@@HPAPAUstbtt_vertex@@@Z ; stbtt__GetGlyphShapeT2
_stbtt_GetGlyphShape ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_info$ = 8						; size = 4
_glyph_index$ = 12					; size = 4
_x0$ = 16						; size = 4
_y0$ = 20						; size = 4
_x1$ = 24						; size = 4
_y1$ = 28						; size = 4
_stbtt_GetGlyphBox PROC

; 1458 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 1459 :    if (info->cff.size) {

	mov	esi, DWORD PTR _info$[ebp]
	push	edi
	cmp	DWORD PTR [esi+56], 0
	je	SHORT $LN2@stbtt_GetG

; 1460 :       stbtt__GetGlyphInfoT2(info, glyph_index, x0, y0, x1, y1);

	push	DWORD PTR _y1$[ebp]
	push	DWORD PTR _x1$[ebp]
	push	DWORD PTR _y0$[ebp]
	push	DWORD PTR _x0$[ebp]
	push	DWORD PTR _glyph_index$[ebp]
	push	esi
	call	?stbtt__GetGlyphInfoT2@@YAHPBUstbtt_fontinfo@@HPAH111@Z ; stbtt__GetGlyphInfoT2
	add	esp, 24					; 00000018H

; 1469 :    }
; 1470 :    return 1;

	mov	eax, 1
	pop	edi
	pop	esi

; 1471 : }

	pop	ebp
	ret	0
$LN2@stbtt_GetG:

; 1461 :    } else {
; 1462 :       int g = stbtt__GetGlyfOffset(info, glyph_index);

	push	DWORD PTR _glyph_index$[ebp]
	push	esi
	call	?stbtt__GetGlyfOffset@@YAHPBUstbtt_fontinfo@@H@Z ; stbtt__GetGlyfOffset
	mov	edi, eax
	add	esp, 8

; 1463 :       if (g < 0) return 0;

	test	edi, edi
	jns	SHORT $LN4@stbtt_GetG
	pop	edi
	xor	eax, eax
	pop	esi

; 1471 : }

	pop	ebp
	ret	0
$LN4@stbtt_GetG:
	push	ebx

; 1464 : 
; 1465 :       if (x0) *x0 = ttSHORT(info->data + g + 2);

	mov	ebx, DWORD PTR _x0$[ebp]
	test	ebx, ebx
	je	SHORT $LN5@stbtt_GetG
	mov	eax, DWORD PTR [esi+4]
	add	eax, 2
	add	eax, edi
	push	eax
	call	?ttSHORT@@YAFPAE@Z			; ttSHORT
	cwde
	add	esp, 4
	mov	DWORD PTR [ebx], eax
$LN5@stbtt_GetG:

; 1466 :       if (y0) *y0 = ttSHORT(info->data + g + 4);

	mov	ebx, DWORD PTR _y0$[ebp]
	test	ebx, ebx
	je	SHORT $LN6@stbtt_GetG
	mov	eax, DWORD PTR [esi+4]
	add	eax, 4
	add	eax, edi
	push	eax
	call	?ttSHORT@@YAFPAE@Z			; ttSHORT
	cwde
	add	esp, 4
	mov	DWORD PTR [ebx], eax
$LN6@stbtt_GetG:

; 1467 :       if (x1) *x1 = ttSHORT(info->data + g + 6);

	mov	ebx, DWORD PTR _x1$[ebp]
	test	ebx, ebx
	je	SHORT $LN7@stbtt_GetG
	mov	eax, DWORD PTR [esi+4]
	add	eax, 6
	add	eax, edi
	push	eax
	call	?ttSHORT@@YAFPAE@Z			; ttSHORT
	cwde
	add	esp, 4
	mov	DWORD PTR [ebx], eax
$LN7@stbtt_GetG:

; 1468 :       if (y1) *y1 = ttSHORT(info->data + g + 8);

	mov	ebx, DWORD PTR _y1$[ebp]
	test	ebx, ebx
	je	SHORT $LN10@stbtt_GetG
	mov	eax, DWORD PTR [esi+4]
	add	eax, 8
	add	eax, edi
	push	eax
	call	?ttSHORT@@YAFPAE@Z			; ttSHORT
	cwde
	add	esp, 4
	mov	DWORD PTR [ebx], eax
$LN10@stbtt_GetG:

; 1469 :    }
; 1470 :    return 1;

	pop	ebx
	pop	edi
	mov	eax, 1
	pop	esi

; 1471 : }

	pop	ebp
	ret	0
_stbtt_GetGlyphBox ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
tv201 = 8						; size = 4
_info$ = 8						; size = 4
_glyph_index$ = 12					; size = 4
_advanceWidth$ = 16					; size = 4
_leftSideBearing$ = 20					; size = 4
_stbtt_GetGlyphHMetrics PROC

; 2143 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 2144 :    stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data+info->hhea + 34);

	mov	esi, DWORD PTR _info$[ebp]
	push	edi
	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+28]
	add	ecx, 34					; 00000022H
	add	eax, ecx
	push	eax
	call	?ttUSHORT@@YAGPAE@Z			; ttUSHORT

; 2145 :    if (glyph_index < numOfLongHorMetrics) {

	mov	ebx, DWORD PTR _glyph_index$[ebp]
	add	esp, 4

; 2146 :       if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*glyph_index);

	mov	edi, DWORD PTR _advanceWidth$[ebp]
	movzx	ecx, ax
	mov	DWORD PTR tv201[ebp], ecx
	cmp	ebx, ecx
	jge	SHORT $LN2@stbtt_GetG
	test	edi, edi
	je	SHORT $LN4@stbtt_GetG
	mov	eax, DWORD PTR [esi+32]
	lea	eax, DWORD PTR [eax+ebx*4]
	add	eax, DWORD PTR [esi+4]
	push	eax
	call	?ttSHORT@@YAFPAE@Z			; ttSHORT
	cwde
	add	esp, 4
	mov	DWORD PTR [edi], eax
$LN4@stbtt_GetG:

; 2147 :       if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*glyph_index + 2);

	mov	edi, DWORD PTR _leftSideBearing$[ebp]
	test	edi, edi
	je	SHORT $LN7@stbtt_GetG
	mov	eax, DWORD PTR [esi+32]
	lea	ecx, DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR [esi+4]
	add	eax, 2
	add	eax, ecx

; 2150 :       if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*numOfLongHorMetrics + 2*(glyph_index - numOfLongHorMetrics));

	push	eax
	call	?ttSHORT@@YAFPAE@Z			; ttSHORT
	add	esp, 4
	cwde
	mov	DWORD PTR [edi], eax
	pop	edi
	pop	esi
	pop	ebx

; 2151 :    }
; 2152 : }

	pop	ebp
	ret	0
$LN2@stbtt_GetG:

; 2148 :    } else {
; 2149 :       if (advanceWidth)     *advanceWidth    = ttSHORT(info->data + info->hmtx + 4*(numOfLongHorMetrics-1));

	test	edi, edi
	je	SHORT $LN6@stbtt_GetG
	mov	eax, DWORD PTR [esi+32]
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR [esi+4]
	add	ecx, -4					; fffffffcH
	add	eax, ecx
	push	eax
	call	?ttSHORT@@YAFPAE@Z			; ttSHORT
	mov	ecx, DWORD PTR tv201[ebp]
	add	esp, 4
	cwde
	mov	DWORD PTR [edi], eax
$LN6@stbtt_GetG:

; 2150 :       if (leftSideBearing)  *leftSideBearing = ttSHORT(info->data + info->hmtx + 4*numOfLongHorMetrics + 2*(glyph_index - numOfLongHorMetrics));

	mov	edi, DWORD PTR _leftSideBearing$[ebp]
	test	edi, edi
	je	SHORT $LN7@stbtt_GetG
	mov	eax, DWORD PTR [esi+32]
	add	ecx, ebx
	lea	eax, DWORD PTR [eax+ecx*2]
	add	eax, DWORD PTR [esi+4]
	push	eax
	call	?ttSHORT@@YAFPAE@Z			; ttSHORT
	cwde
	add	esp, 4
	mov	DWORD PTR [edi], eax
$LN7@stbtt_GetG:
	pop	edi
	pop	esi
	pop	ebx

; 2151 :    }
; 2152 : }

	pop	ebp
	ret	0
_stbtt_GetGlyphHMetrics ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_info$ = 8						; size = 4
_ascent$ = 12						; size = 4
_descent$ = 16						; size = 4
_lineGap$ = 20						; size = 4
_stbtt_GetFontVMetrics PROC

; 2197 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 2198 :    if (ascent ) *ascent  = ttSHORT(info->data+info->hhea + 4);

	mov	esi, DWORD PTR _info$[ebp]
	push	edi
	mov	edi, DWORD PTR _ascent$[ebp]
	test	edi, edi
	je	SHORT $LN2@stbtt_GetF
	mov	ecx, DWORD PTR [esi+28]
	mov	eax, DWORD PTR [esi+4]
	add	ecx, 4
	add	eax, ecx
	push	eax
	call	?ttSHORT@@YAFPAE@Z			; ttSHORT
	cwde
	add	esp, 4
	mov	DWORD PTR [edi], eax
$LN2@stbtt_GetF:

; 2199 :    if (descent) *descent = ttSHORT(info->data+info->hhea + 6);

	mov	edi, DWORD PTR _descent$[ebp]
	test	edi, edi
	je	SHORT $LN3@stbtt_GetF
	mov	ecx, DWORD PTR [esi+28]
	mov	eax, DWORD PTR [esi+4]
	add	ecx, 6
	add	eax, ecx
	push	eax
	call	?ttSHORT@@YAFPAE@Z			; ttSHORT
	cwde
	add	esp, 4
	mov	DWORD PTR [edi], eax
$LN3@stbtt_GetF:

; 2200 :    if (lineGap) *lineGap = ttSHORT(info->data+info->hhea + 8);

	mov	edi, DWORD PTR _lineGap$[ebp]
	test	edi, edi
	je	SHORT $LN4@stbtt_GetF
	mov	ecx, DWORD PTR [esi+28]
	mov	eax, DWORD PTR [esi+4]
	add	ecx, 8
	add	eax, ecx
	push	eax
	call	?ttSHORT@@YAFPAE@Z			; ttSHORT
	cwde
	add	esp, 4
	mov	DWORD PTR [edi], eax
$LN4@stbtt_GetF:
	pop	edi
	pop	esi

; 2201 : }

	pop	ebp
	ret	0
_stbtt_GetFontVMetrics ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
tv134 = 8						; size = 4
_info$ = 8						; size = 4
_pixels$ = 12						; size = 4
_stbtt_ScaleForMappingEmToPixels PROC

; 2218 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2219 :    int unitsPerEm = ttUSHORT(info->data + info->head + 18);

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [eax+4]
	add	ecx, 18					; 00000012H
	add	eax, ecx
	push	eax
	call	?ttUSHORT@@YAGPAE@Z			; ttUSHORT

; 2220 :    return pixels / unitsPerEm;

	movss	xmm1, DWORD PTR _pixels$[ebp]
	add	esp, 4
	movzx	eax, ax
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	divss	xmm1, xmm0
	movss	DWORD PTR tv134[ebp], xmm1
	fld	DWORD PTR tv134[ebp]

; 2221 : }

	pop	ebp
	ret	0
_stbtt_ScaleForMappingEmToPixels ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
tv165 = 8						; size = 4
_info$ = 8						; size = 4
_height$ = 12						; size = 4
_stbtt_ScaleForPixelHeight PROC

; 2212 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2213 :    int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);

	mov	eax, DWORD PTR _info$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR [eax+4]
	mov	ebx, DWORD PTR [eax+28]
	lea	eax, DWORD PTR [edi+6]
	add	eax, ebx
	push	eax
	call	?ttSHORT@@YAFPAE@Z			; ttSHORT
	movsx	esi, ax
	lea	eax, DWORD PTR [edi+4]
	add	eax, ebx
	push	eax
	call	?ttSHORT@@YAFPAE@Z			; ttSHORT

; 2214 :    return (float) height / fheight;

	movss	xmm1, DWORD PTR _height$[ebp]
	add	esp, 8
	cwde
	sub	eax, esi
	pop	edi
	pop	esi
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	pop	ebx
	divss	xmm1, xmm0
	movss	DWORD PTR tv165[ebp], xmm1
	fld	DWORD PTR tv165[ebp]

; 2215 : }

	pop	ebp
	ret	0
_stbtt_ScaleForPixelHeight ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_search$1$ = -16					; size = 4
tv663 = -16						; size = 4
tv661 = -16						; size = 4
_segcount$1$ = -12					; size = 4
_format$1$ = -12					; size = 4
_index_map$1$ = -8					; size = 4
_entrySelector$1$ = -4					; size = 4
_start_char$1$ = -4					; size = 4
_first$1$ = 8						; size = 4
_data$1$ = 8						; size = 4
tv665 = 8						; size = 4
_searchRange$1 = 8					; size = 2
_info$ = 8						; size = 4
_searchRange$1$ = 10					; size = 2
_unicode_codepoint$ = 12				; size = 4
_stbtt_FindGlyphIndex PROC

; 1329 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1330 :    stbtt_uint8 *data = info->data;

	mov	eax, DWORD PTR _info$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	ebx, DWORD PTR [eax+4]

; 1331 :    stbtt_uint32 index_map = info->index_map;

	mov	edi, DWORD PTR [eax+40]
	mov	DWORD PTR _data$1$[ebp], ebx
	mov	DWORD PTR _index_map$1$[ebp], edi

; 1332 : 
; 1333 :    stbtt_uint16 format = ttUSHORT(data + index_map + 0);

	lea	esi, DWORD PTR [edi+ebx]
	push	esi
	call	?ttUSHORT@@YAGPAE@Z			; ttUSHORT
	movzx	eax, ax
	add	esp, 4
	mov	DWORD PTR _format$1$[ebp], eax

; 1334 :    if (format == 0) { // apple byte encoding

	test	ax, ax
	jne	SHORT $LN6@stbtt_Find

; 1335 :       stbtt_int32 bytes = ttUSHORT(data + index_map + 2);

	lea	eax, DWORD PTR [esi+2]
	push	eax
	call	?ttUSHORT@@YAGPAE@Z			; ttUSHORT

; 1336 :       if (unicode_codepoint < bytes-6)

	mov	ecx, DWORD PTR _unicode_codepoint$[ebp]
	add	esp, 4
	movzx	eax, ax
	sub	eax, 6
	cmp	ecx, eax
	jge	$LN5@stbtt_Find

; 1337 :          return ttBYTE(data + index_map + 6 + unicode_codepoint);

	movzx	eax, BYTE PTR [esi+ecx+6]
	pop	edi
	pop	esi
	pop	ebx

; 1415 :    }
; 1416 :    // @TODO
; 1417 :    STBTT_assert(0);
; 1418 :    return 0;
; 1419 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@stbtt_Find:

; 1338 :       return 0;
; 1339 :    } else if (format == 6) {

	cmp	eax, 6
	jne	SHORT $LN9@stbtt_Find

; 1340 :       stbtt_uint32 first = ttUSHORT(data + index_map + 6);

	lea	eax, DWORD PTR [esi+6]
	push	eax
	call	?ttUSHORT@@YAGPAE@Z			; ttUSHORT
	movzx	eax, ax
	add	esp, 4
	mov	DWORD PTR _first$1$[ebp], eax

; 1342 :       if ((stbtt_uint32) unicode_codepoint >= first && (stbtt_uint32) unicode_codepoint < first+count)

	cmp	DWORD PTR _unicode_codepoint$[ebp], eax
	jb	$LN5@stbtt_Find

; 1341 :       stbtt_uint32 count = ttUSHORT(data + index_map + 8);

	lea	eax, DWORD PTR [esi+8]
	push	eax
	call	?ttUSHORT@@YAGPAE@Z			; ttUSHORT

; 1342 :       if ((stbtt_uint32) unicode_codepoint >= first && (stbtt_uint32) unicode_codepoint < first+count)

	mov	edx, DWORD PTR _first$1$[ebp]
	add	esp, 4
	mov	ecx, DWORD PTR _unicode_codepoint$[ebp]
	movzx	eax, ax
	add	eax, edx
	cmp	ecx, eax
	jae	$LN5@stbtt_Find

; 1343 :          return ttUSHORT(data + index_map + 10 + (unicode_codepoint - first)*2);

	sub	ecx, edx
	add	ecx, 5
	lea	eax, DWORD PTR [edi+ecx*2]
	add	eax, ebx
	push	eax
	call	?ttUSHORT@@YAGPAE@Z			; ttUSHORT
	add	esp, 4
	movzx	eax, ax
	pop	edi
	pop	esi
	pop	ebx

; 1415 :    }
; 1416 :    // @TODO
; 1417 :    STBTT_assert(0);
; 1418 :    return 0;
; 1419 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@stbtt_Find:

; 1344 :       return 0;
; 1345 :    } else if (format == 2) {

	cmp	eax, 2
	je	$LN5@stbtt_Find

; 1346 :       STBTT_assert(0); // @TODO: high-byte mapping for japanese/chinese/korean
; 1347 :       return 0;
; 1348 :    } else if (format == 4) { // standard mapping for windows fonts: binary search collection of ranges

	cmp	eax, 4
	jne	$LN14@stbtt_Find

; 1349 :       stbtt_uint16 segcount = ttUSHORT(data+index_map+6) >> 1;

	lea	eax, DWORD PTR [esi+6]
	push	eax
	call	?ttUSHORT@@YAGPAE@Z			; ttUSHORT
	shr	ax, 1
	movzx	eax, ax
	mov	DWORD PTR _segcount$1$[ebp], eax

; 1350 :       stbtt_uint16 searchRange = ttUSHORT(data+index_map+8) >> 1;

	lea	eax, DWORD PTR [esi+8]
	push	eax
	call	?ttUSHORT@@YAGPAE@Z			; ttUSHORT
	shr	ax, 1
	movzx	eax, ax
	mov	DWORD PTR _searchRange$1[ebp], eax

; 1351 :       stbtt_uint16 entrySelector = ttUSHORT(data+index_map+10);

	lea	eax, DWORD PTR [esi+10]
	push	eax
	call	?ttUSHORT@@YAGPAE@Z			; ttUSHORT
	movzx	eax, ax
	mov	DWORD PTR _entrySelector$1$[ebp], eax

; 1352 :       stbtt_uint16 rangeShift = ttUSHORT(data+index_map+12) >> 1;

	lea	eax, DWORD PTR [esi+12]
	push	eax
	call	?ttUSHORT@@YAGPAE@Z			; ttUSHORT
	shr	ax, 1

; 1353 : 
; 1354 :       // do a binary search of the segments
; 1355 :       stbtt_uint32 endCount = index_map + 14;

	add	edi, 14					; 0000000eH
	add	esp, 16					; 00000010H
	movzx	eax, ax

; 1356 :       stbtt_uint32 search = endCount;
; 1357 : 
; 1358 :       if (unicode_codepoint > 0xffff)

	cmp	DWORD PTR _unicode_codepoint$[ebp], 65535 ; 0000ffffH
	mov	DWORD PTR _search$1$[ebp], edi
	jg	$LN5@stbtt_Find

; 1359 :          return 0;
; 1360 : 
; 1361 :       // they lie from endCount .. endCount + segCount
; 1362 :       // but searchRange is the nearest power of two, so...
; 1363 :       if (unicode_codepoint >= ttUSHORT(data + search + rangeShift*2))

	lea	esi, DWORD PTR [edi+eax*2]
	lea	eax, DWORD PTR [esi+ebx]
	push	eax
	call	?ttUSHORT@@YAGPAE@Z			; ttUSHORT
	add	esp, 4
	movzx	eax, ax
	cmp	DWORD PTR _unicode_codepoint$[ebp], eax
	cmovge	edi, esi

; 1364 :          search += rangeShift*2;
; 1365 : 
; 1366 :       // now decrement to bias correctly to find smallest
; 1367 :       search -= 2;

	sub	edi, 2

; 1368 :       while (entrySelector) {

	cmp	WORD PTR _entrySelector$1$[ebp], 0
	je	SHORT $LN3@stbtt_Find
	mov	ax, WORD PTR _searchRange$1[ebp]
$LL2@stbtt_Find:

; 1369 :          stbtt_uint16 end;
; 1370 :          searchRange >>= 1;

	shr	ax, 1
	mov	WORD PTR _searchRange$1$[ebp], ax

; 1371 :          end = ttUSHORT(data + search + searchRange*2);

	movzx	eax, ax
	lea	esi, DWORD PTR [edi+eax*2]
	lea	eax, DWORD PTR [esi+ebx]
	push	eax
	call	?ttUSHORT@@YAGPAE@Z			; ttUSHORT

; 1372 :          if (unicode_codepoint > end)

	movzx	eax, ax
	add	esp, 4
	cmp	DWORD PTR _unicode_codepoint$[ebp], eax

; 1373 :             search += searchRange*2;
; 1374 :          --entrySelector;

	mov	eax, DWORD PTR _entrySelector$1$[ebp]
	cmovg	edi, esi
	add	eax, 65535				; 0000ffffH
	mov	DWORD PTR _entrySelector$1$[ebp], eax
	test	ax, ax
	mov	ax, WORD PTR _searchRange$1$[ebp]
	jne	SHORT $LL2@stbtt_Find
$LN3@stbtt_Find:

; 1375 :       }
; 1376 :       search += 2;
; 1377 : 
; 1378 :       {
; 1379 :          stbtt_uint16 offset, start;
; 1380 :          stbtt_uint16 item = (stbtt_uint16) ((search - endCount) >> 1);

	sub	edi, DWORD PTR _search$1$[ebp]

; 1381 : 
; 1382 :          STBTT_assert(unicode_codepoint <= ttUSHORT(data + endCount + 2*item));
; 1383 :          start = ttUSHORT(data + index_map + 14 + segcount*2 + 2 + 2*item);

	mov	ecx, DWORD PTR _segcount$1$[ebp]
	add	edi, 2
	mov	esi, DWORD PTR _index_map$1$[ebp]
	shr	edi, 1
	movzx	eax, di
	mov	DWORD PTR tv665[ebp], eax
	add	eax, 8
	movzx	edi, cx
	add	eax, edi
	lea	eax, DWORD PTR [esi+eax*2]
	add	eax, ebx
	push	eax
	call	?ttUSHORT@@YAGPAE@Z			; ttUSHORT
	movzx	eax, ax
	add	esp, 4

; 1384 :          if (unicode_codepoint < start)

	mov	DWORD PTR tv663[ebp], eax
	cmp	DWORD PTR _unicode_codepoint$[ebp], eax
	jl	$LN5@stbtt_Find

; 1385 :             return 0;
; 1386 : 
; 1387 :          offset = ttUSHORT(data + index_map + 14 + segcount*6 + 2 + 2*item);

	mov	eax, DWORD PTR tv665[ebp]
	lea	edi, DWORD PTR [edi+edi*2]
	add	eax, 8
	add	eax, edi
	lea	eax, DWORD PTR [esi+eax*2]
	add	eax, ebx
	push	eax
	call	?ttUSHORT@@YAGPAE@Z			; ttUSHORT
	movzx	eax, ax
	add	esp, 4

; 1388 :          if (offset == 0)

	test	ax, ax
	jne	SHORT $LN20@stbtt_Find

; 1389 :             return (stbtt_uint16) (unicode_codepoint + ttSHORT(data + index_map + 14 + segcount*4 + 2 + 2*item));

	mov	edx, DWORD PTR _segcount$1$[ebp]
	mov	ecx, DWORD PTR tv665[ebp]
	movzx	eax, dx
	add	ecx, 8
	lea	eax, DWORD PTR [ecx+eax*2]
	lea	eax, DWORD PTR [esi+eax*2]
	add	eax, ebx
	push	eax
	call	?ttSHORT@@YAFPAE@Z			; ttSHORT
	add	esp, 4
	add	ax, WORD PTR _unicode_codepoint$[ebp]
	movzx	eax, ax
	pop	edi
	pop	esi
	pop	ebx

; 1415 :    }
; 1416 :    // @TODO
; 1417 :    STBTT_assert(0);
; 1418 :    return 0;
; 1419 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@stbtt_Find:

; 1390 : 
; 1391 :          return ttUSHORT(data + offset + (unicode_codepoint-start)*2 + index_map + 14 + segcount*6 + 2 + 2*item);

	sub	edi, DWORD PTR tv663[ebp]
	add	eax, esi
	add	edi, DWORD PTR tv665[ebp]
	add	edi, DWORD PTR _unicode_codepoint$[ebp]
	lea	eax, DWORD PTR [eax+edi*2]
	add	eax, 16					; 00000010H
	add	eax, ebx
	push	eax
	call	?ttUSHORT@@YAGPAE@Z			; ttUSHORT
	add	esp, 4
	movzx	eax, ax
	pop	edi
	pop	esi
	pop	ebx

; 1415 :    }
; 1416 :    // @TODO
; 1417 :    STBTT_assert(0);
; 1418 :    return 0;
; 1419 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@stbtt_Find:

; 1392 :       }
; 1393 :    } else if (format == 12 || format == 13) {

	cmp	eax, 12					; 0000000cH
	je	SHORT $LN22@stbtt_Find
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN5@stbtt_Find
$LN22@stbtt_Find:

; 1394 :       stbtt_uint32 ngroups = ttULONG(data+index_map+12);

	lea	eax, DWORD PTR [esi+12]

; 1395 :       stbtt_int32 low,high;
; 1396 :       low = 0; high = (stbtt_int32)ngroups;

	xor	edi, edi
	push	eax
	call	?ttULONG@@YAIPAE@Z			; ttULONG
	mov	ebx, eax
	add	esp, 4

; 1397 :       // Binary search the right group.
; 1398 :       while (low < high) {

	test	ebx, ebx
	jle	SHORT $LN5@stbtt_Find
$LL4@stbtt_Find:

; 1399 :          stbtt_int32 mid = low + ((high-low) >> 1); // rounds down, so low <= mid < high
; 1400 :          stbtt_uint32 start_char = ttULONG(data+index_map+16+mid*12);

	mov	ecx, DWORD PTR _index_map$1$[ebp]
	mov	esi, ebx
	sub	esi, edi
	sar	esi, 1
	add	esi, edi
	lea	eax, DWORD PTR [esi+esi*2]
	lea	eax, DWORD PTR [ecx+eax*4]
	add	eax, DWORD PTR _data$1$[ebp]
	mov	DWORD PTR tv661[ebp], eax
	add	eax, 16					; 00000010H
	push	eax
	call	?ttULONG@@YAIPAE@Z			; ttULONG
	add	esp, 4
	mov	DWORD PTR _start_char$1$[ebp], eax

; 1402 :          if ((stbtt_uint32) unicode_codepoint < start_char)

	cmp	DWORD PTR _unicode_codepoint$[ebp], eax
	jae	SHORT $LN23@stbtt_Find

; 1403 :             high = mid;

	mov	ebx, esi
	jmp	SHORT $LN28@stbtt_Find
$LN23@stbtt_Find:

; 1401 :          stbtt_uint32 end_char = ttULONG(data+index_map+16+mid*12+4);

	mov	eax, DWORD PTR tv661[ebp]
	add	eax, 20					; 00000014H
	push	eax
	call	?ttULONG@@YAIPAE@Z			; ttULONG

; 1404 :          else if ((stbtt_uint32) unicode_codepoint > end_char)

	mov	edi, DWORD PTR _unicode_codepoint$[ebp]
	add	esp, 4
	cmp	edi, eax
	jbe	SHORT $LN25@stbtt_Find

; 1405 :             low = mid+1;

	lea	edi, DWORD PTR [esi+1]
$LN28@stbtt_Find:

; 1397 :       // Binary search the right group.
; 1398 :       while (low < high) {

	cmp	edi, ebx
	jl	SHORT $LL4@stbtt_Find
$LN5@stbtt_Find:

; 1410 :             else // format == 13
; 1411 :                return start_glyph;
; 1412 :          }
; 1413 :       }
; 1414 :       return 0; // not found

	xor	eax, eax
$LN1@stbtt_Find:
	pop	edi
	pop	esi
	pop	ebx

; 1415 :    }
; 1416 :    // @TODO
; 1417 :    STBTT_assert(0);
; 1418 :    return 0;
; 1419 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@stbtt_Find:

; 1406 :          else {
; 1407 :             stbtt_uint32 start_glyph = ttULONG(data+index_map+16+mid*12+8);

	mov	ecx, DWORD PTR _index_map$1$[ebp]
	lea	eax, DWORD PTR [esi+2]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]
	add	eax, DWORD PTR _data$1$[ebp]
	push	eax
	call	?ttULONG@@YAIPAE@Z			; ttULONG
	add	esp, 4

; 1408 :             if (format == 12)

	cmp	WORD PTR _format$1$[ebp], 12		; 0000000cH
	jne	SHORT $LN1@stbtt_Find

; 1409 :                return start_glyph + unicode_codepoint-start_char;

	sub	eax, DWORD PTR _start_char$1$[ebp]
	add	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 1415 :    }
; 1416 :    // @TODO
; 1417 :    STBTT_assert(0);
; 1418 :    return 0;
; 1419 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_stbtt_FindGlyphIndex ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_info$ = 8						; size = 4
_data$ = 12						; size = 4
_offset$ = 16						; size = 4
_stbtt_InitFont PROC

; 3949 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 3951 : }

	pop	ebp

; 3950 :    return stbtt_InitFont_internal(info, (unsigned char *) data, offset);

	jmp	?stbtt_InitFont_internal@@YAHPAUstbtt_fontinfo@@PAEH@Z ; stbtt_InitFont_internal
_stbtt_InitFont ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_data$ = 8						; size = 4
_index$ = 12						; size = 4
_stbtt_GetFontOffsetForIndex PROC

; 3939 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 3941 : }

	pop	ebp

; 3940 :    return stbtt_GetFontOffsetForIndex_internal((unsigned char *) data, index);   

	jmp	?stbtt_GetFontOffsetForIndex_internal@@YAHPAEH@Z ; stbtt_GetFontOffsetForIndex_internal
_stbtt_GetFontOffsetForIndex ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_x1$1 = -80						; size = 4
_y1$2 = -76						; size = 4
_lsb$3 = -72						; size = 4
_old_v_over$1$ = -68					; size = 4
_old_h_over$1$ = -64					; size = 4
_sub_y$4 = -60						; size = 4
_recip_v$1$ = -56					; size = 4
_y0$5 = -52						; size = 4
_sub_x$6 = -48						; size = 4
_recip_h$1$ = -44					; size = 4
_x0$7 = -40						; size = 4
_advance$8 = -36					; size = 4
_bc$1$ = -32						; size = 4
_return_value$1$ = -28					; size = 4
tv963 = -24						; size = 4
tv976 = -20						; size = 4
_j$1$ = -16						; size = 4
tv975 = -12						; size = 4
_k$1$ = -8						; size = 4
_scale$9 = -4						; size = 4
_spc$ = 8						; size = 4
_info$ = 12						; size = 4
_ranges$ = 16						; size = 4
_num_ranges$ = 20					; size = 4
_rects$ = 24						; size = 4
_stbtt_PackFontRangesRenderIntoRects PROC

; 3604 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 3606 : 
; 3607 :    // save current values
; 3608 :    int old_h_over = spc->h_oversample;
; 3609 :    int old_v_over = spc->v_oversample;
; 3610 : 
; 3611 :    k = 0;
; 3612 :    for (i=0; i < num_ranges; ++i) {

	cmp	DWORD PTR _num_ranges$[ebp], 0
	mov	eax, 1
	push	esi
	mov	esi, DWORD PTR _spc$[ebp]
	mov	DWORD PTR _return_value$1$[ebp], eax
	mov	DWORD PTR _k$1$[ebp], 0
	mov	ecx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [esi+28]
	mov	DWORD PTR _old_h_over$1$[ebp], ecx
	mov	DWORD PTR _old_v_over$1$[ebp], edx
	jle	$LN3@stbtt_Pack

; 3605 :    int i,j,k, return_value = 1;

	mov	eax, DWORD PTR _info$[ebp]
	xorps	xmm1, xmm1
	movss	xmm2, DWORD PTR __real@3f800000
	push	edi
	mov	edi, DWORD PTR _ranges$[ebp]
	add	edi, 8
	mov	DWORD PTR tv963[ebp], edi
	npad	7
$LL4@stbtt_Pack:

; 3613 :       float fh = ranges[i].font_size;

	movss	xmm0, DWORD PTR [edi-8]

; 3614 :       float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);

	comiss	xmm0, xmm1
	push	ecx
	jbe	SHORT $LN13@stbtt_Pack
	movss	DWORD PTR [esp], xmm0
	push	eax
	call	_stbtt_ScaleForPixelHeight
	jmp	SHORT $LN25@stbtt_Pack
$LN13@stbtt_Pack:
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esp], xmm0
	push	eax
	call	_stbtt_ScaleForMappingEmToPixels
$LN25@stbtt_Pack:

; 3615 :       float recip_h,recip_v,sub_x,sub_y;
; 3616 :       spc->h_oversample = ranges[i].h_oversample;

	movzx	eax, BYTE PTR [edi+12]

; 3617 :       spc->v_oversample = ranges[i].v_oversample;
; 3618 :       recip_h = 1.0f / spc->h_oversample;

	movaps	xmm1, xmm2
	mov	ecx, eax
	mov	DWORD PTR [esi+24], eax
	movzx	edx, BYTE PTR [edi+13]
	add	esp, 8
	shr	eax, 31					; 0000001fH
	fstp	DWORD PTR _scale$9[ebp]
	movd	xmm0, ecx
	cvtdq2pd xmm0, xmm0

; 3619 :       recip_v = 1.0f / spc->v_oversample;
; 3620 :       sub_x = stbtt__oversample_shift(spc->h_oversample);

	push	ecx
	mov	DWORD PTR [esi+28], edx
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	cvtpd2ps xmm0, xmm0
	divss	xmm1, xmm0
	movd	xmm0, edx
	cvtdq2pd xmm0, xmm0
	movss	DWORD PTR _recip_h$1$[ebp], xmm1
	movaps	xmm1, xmm2
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	divss	xmm1, xmm0
	movss	DWORD PTR _recip_v$1$[ebp], xmm1
	call	?stbtt__oversample_shift@@YAMH@Z	; stbtt__oversample_shift
	fstp	DWORD PTR _sub_x$6[ebp]

; 3621 :       sub_y = stbtt__oversample_shift(spc->v_oversample);

	push	edx
	call	?stbtt__oversample_shift@@YAMH@Z	; stbtt__oversample_shift

; 3622 :       for (j=0; j < ranges[i].num_chars; ++j) {

	xor	ecx, ecx
	add	esp, 8
	fstp	DWORD PTR _sub_y$4[ebp]
	mov	DWORD PTR _j$1$[ebp], ecx
	cmp	DWORD PTR [edi+4], ecx
	jle	$LN2@stbtt_Pack

; 3615 :       float recip_h,recip_v,sub_x,sub_y;
; 3616 :       spc->h_oversample = ranges[i].h_oversample;

	mov	eax, DWORD PTR _k$1$[ebp]
	xor	edx, edx
	mov	esi, DWORD PTR _rects$[ebp]
	movss	xmm1, DWORD PTR _scale$9[ebp]
	add	esi, 8
	shl	eax, 4
	add	esi, eax
	mov	DWORD PTR tv976[ebp], edx
	mov	eax, DWORD PTR _k$1$[ebp]
	mov	DWORD PTR tv975[ebp], esi
	npad	5
$LL7@stbtt_Pack:

; 3623 :          stbrp_rect *r = &rects[k];
; 3624 :          if (r->was_packed) {

	cmp	DWORD PTR [esi+4], 0
	je	$LN8@stbtt_Pack

; 3625 :             stbtt_packedchar *bc = &ranges[i].chardata_for_range[j];

	mov	eax, DWORD PTR [edi+8]
	add	eax, edx
	mov	DWORD PTR _bc$1$[ebp], eax

; 3626 :             int advance, lsb, x0,y0,x1,y1;
; 3627 :             int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	jne	SHORT $LN15@stbtt_Pack
	mov	eax, DWORD PTR [edi-4]
	add	eax, ecx
	jmp	SHORT $LN16@stbtt_Pack
$LN15@stbtt_Pack:
	mov	eax, DWORD PTR [eax+ecx*4]
$LN16@stbtt_Pack:

; 3628 :             int glyph = stbtt_FindGlyphIndex(info, codepoint);

	push	eax
	push	DWORD PTR _info$[ebp]
	call	_stbtt_FindGlyphIndex
	mov	edi, eax

; 3629 :             stbrp_coord pad = (stbrp_coord) spc->padding;

	mov	eax, DWORD PTR _spc$[ebp]
	movzx	eax, WORD PTR [eax+20]

; 3630 : 
; 3631 :             // pad on left and top
; 3632 :             r->x += pad;

	add	WORD PTR [esi], ax

; 3633 :             r->y += pad;

	add	WORD PTR [esi+2], ax

; 3634 :             r->w -= pad;

	sub	WORD PTR [esi-4], ax

; 3635 :             r->h -= pad;

	sub	WORD PTR [esi-2], ax

; 3636 :             stbtt_GetGlyphHMetrics(info, glyph, &advance, &lsb);

	lea	eax, DWORD PTR _lsb$3[ebp]
	push	eax
	lea	eax, DWORD PTR _advance$8[ebp]
	push	eax
	push	edi
	push	DWORD PTR _info$[ebp]
	call	_stbtt_GetGlyphHMetrics

; 3637 :             stbtt_GetGlyphBitmapBox(info, glyph,

	mov	esi, DWORD PTR _spc$[ebp]
	lea	eax, DWORD PTR _y1$2[ebp]
	add	esp, 24					; 00000018H
	push	eax
	lea	eax, DWORD PTR _x1$1[ebp]
	push	eax
	lea	eax, DWORD PTR _y0$5[ebp]
	push	eax
	lea	eax, DWORD PTR _x0$7[ebp]
	push	eax
	mov	eax, DWORD PTR [esi+28]
	sub	esp, 8
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	eax, DWORD PTR [esi+24]
	cvtpd2ps xmm0, xmm0
	mulss	xmm0, xmm1
	movss	DWORD PTR [esp+4], xmm0
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	mulss	xmm0, xmm1
	movss	DWORD PTR [esp], xmm0
	push	edi
	push	DWORD PTR _info$[ebp]
	call	_stbtt_GetGlyphBitmapBox

; 3638 :                                     scale * spc->h_oversample,
; 3639 :                                     scale * spc->v_oversample,
; 3640 :                                     &x0,&y0,&x1,&y1);
; 3641 :             stbtt_MakeGlyphBitmapSubpixel(info,

	mov	ecx, DWORD PTR [esi+28]
	add	esp, 32					; 00000020H
	mov	edx, DWORD PTR [esi+24]
	mov	eax, ecx
	shr	eax, 31					; 0000001fH
	mov	esi, DWORD PTR [esi+16]
	push	edi
	sub	esp, 16					; 00000010H
	movd	xmm0, ecx
	cvtdq2pd xmm0, xmm0
	mov	edi, DWORD PTR tv975[ebp]
	mov	DWORD PTR [esp+12], 0
	mov	DWORD PTR [esp+8], 0
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	cvtpd2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR _scale$9[ebp]
	movss	DWORD PTR [esp+4], xmm0
	movd	xmm0, edx
	cvtdq2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	movzx	eax, WORD PTR [edi-2]
	sub	eax, ecx
	inc	eax
	cvtpd2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR _scale$9[ebp]
	movss	DWORD PTR [esp], xmm0
	push	esi
	push	eax
	movzx	eax, WORD PTR [edi-4]
	sub	eax, edx
	inc	eax
	push	eax
	movzx	ecx, WORD PTR [edi+2]
	imul	ecx, esi
	mov	esi, edi
	mov	edi, DWORD PTR _spc$[ebp]
	movzx	eax, WORD PTR [esi]
	add	ecx, eax
	add	ecx, DWORD PTR [edi+32]
	push	ecx
	push	DWORD PTR _info$[ebp]
	call	_stbtt_MakeGlyphBitmapSubpixel

; 3642 :                                           spc->pixels + r->x + r->y*spc->stride_in_bytes,
; 3643 :                                           r->w - spc->h_oversample+1,
; 3644 :                                           r->h - spc->v_oversample+1,
; 3645 :                                           spc->stride_in_bytes,
; 3646 :                                           scale * spc->h_oversample,
; 3647 :                                           scale * spc->v_oversample,
; 3648 :                                           0,0,
; 3649 :                                           glyph);
; 3650 : 
; 3651 :             if (spc->h_oversample > 1)

	mov	eax, DWORD PTR [edi+24]
	add	esp, 40					; 00000028H
	cmp	eax, 1
	jbe	SHORT $LN10@stbtt_Pack

; 3652 :                stbtt__h_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,

	mov	edx, DWORD PTR [edi+16]
	movzx	ecx, WORD PTR [esi+2]
	push	eax
	movzx	eax, WORD PTR [esi-2]
	push	edx
	push	eax
	movzx	eax, WORD PTR [esi-4]
	imul	ecx, edx
	push	eax
	movzx	eax, WORD PTR [esi]
	add	ecx, eax
	add	ecx, DWORD PTR [edi+32]
	push	ecx
	call	?stbtt__h_prefilter@@YAXPAEHHHI@Z	; stbtt__h_prefilter
	add	esp, 20					; 00000014H
$LN10@stbtt_Pack:

; 3653 :                                   r->w, r->h, spc->stride_in_bytes,
; 3654 :                                   spc->h_oversample);
; 3655 : 
; 3656 :             if (spc->v_oversample > 1)

	mov	eax, DWORD PTR [edi+28]
	cmp	eax, 1
	jbe	SHORT $LN11@stbtt_Pack

; 3657 :                stbtt__v_prefilter(spc->pixels + r->x + r->y*spc->stride_in_bytes,

	mov	edx, DWORD PTR [edi+16]
	movzx	ecx, WORD PTR [esi+2]
	push	eax
	movzx	eax, WORD PTR [esi-2]
	push	edx
	push	eax
	movzx	eax, WORD PTR [esi-4]
	imul	ecx, edx
	push	eax
	movzx	eax, WORD PTR [esi]
	add	ecx, eax
	add	ecx, DWORD PTR [edi+32]
	push	ecx
	call	?stbtt__v_prefilter@@YAXPAEHHHI@Z	; stbtt__v_prefilter
	add	esp, 20					; 00000014H
$LN11@stbtt_Pack:

; 3658 :                                   r->w, r->h, spc->stride_in_bytes,
; 3659 :                                   spc->v_oversample);
; 3660 : 
; 3661 :             bc->x0       = (stbtt_int16)  r->x;

	mov	edi, DWORD PTR _bc$1$[ebp]
	movzx	eax, WORD PTR [esi]
	movd	xmm0, DWORD PTR _advance$8[ebp]

; 3662 :             bc->y0       = (stbtt_int16)  r->y;
; 3663 :             bc->x1       = (stbtt_int16) (r->x + r->w);
; 3664 :             bc->y1       = (stbtt_int16) (r->y + r->h);
; 3665 :             bc->xadvance =                scale * advance;
; 3666 :             bc->xoff     =       (float)  x0 * recip_h + sub_x;

	mov	ecx, DWORD PTR _x0$7[ebp]
	cvtdq2ps xmm0, xmm0
	mov	WORD PTR [edi], ax
	movzx	eax, WORD PTR [esi+2]
	mov	WORD PTR [edi+2], ax
	movzx	eax, WORD PTR [esi]
	add	ax, WORD PTR [esi-4]
	mulss	xmm0, DWORD PTR _scale$9[ebp]

; 3667 :             bc->yoff     =       (float)  y0 * recip_v + sub_y;

	mov	edx, DWORD PTR _y0$5[ebp]
	mov	WORD PTR [edi+4], ax
	movzx	eax, WORD PTR [esi+2]
	add	ax, WORD PTR [esi-2]
	movss	DWORD PTR [edi+16], xmm0
	movd	xmm0, ecx
	cvtdq2ps xmm0, xmm0
	mov	WORD PTR [edi+6], ax

; 3668 :             bc->xoff2    =                (x0 + r->w) * recip_h + sub_x;
; 3669 :             bc->yoff2    =                (y0 + r->h) * recip_v + sub_y;
; 3670 :          } else {

	movss	xmm1, DWORD PTR _scale$9[ebp]
	mulss	xmm0, DWORD PTR _recip_h$1$[ebp]
	addss	xmm0, DWORD PTR _sub_x$6[ebp]
	movss	DWORD PTR [edi+8], xmm0
	movd	xmm0, edx
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR _recip_v$1$[ebp]
	addss	xmm0, DWORD PTR _sub_y$4[ebp]
	movss	DWORD PTR [edi+12], xmm0
	movzx	eax, WORD PTR [esi-4]
	add	eax, ecx
	mov	ecx, DWORD PTR _j$1$[ebp]
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR _recip_h$1$[ebp]
	addss	xmm0, DWORD PTR _sub_x$6[ebp]
	movss	DWORD PTR [edi+20], xmm0
	movzx	eax, WORD PTR [esi-2]
	add	eax, edx
	mov	edx, DWORD PTR tv976[ebp]
	movd	xmm0, eax
	mov	eax, DWORD PTR _k$1$[ebp]
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR _recip_v$1$[ebp]
	addss	xmm0, DWORD PTR _sub_y$4[ebp]
	movss	DWORD PTR [edi+24], xmm0
	mov	edi, DWORD PTR tv963[ebp]
	jmp	SHORT $LN9@stbtt_Pack
$LN8@stbtt_Pack:

; 3671 :             return_value = 0; // if any fail, report failure

	mov	DWORD PTR _return_value$1$[ebp], 0
$LN9@stbtt_Pack:

; 3622 :       for (j=0; j < ranges[i].num_chars; ++j) {

	inc	ecx

; 3672 :          }
; 3673 : 
; 3674 :          ++k;

	inc	eax
	add	esi, 16					; 00000010H
	mov	DWORD PTR _k$1$[ebp], eax
	add	edx, 28					; 0000001cH
	mov	DWORD PTR tv975[ebp], esi
	mov	DWORD PTR _j$1$[ebp], ecx
	mov	DWORD PTR tv976[ebp], edx
	cmp	ecx, DWORD PTR [edi+4]
	jl	$LL7@stbtt_Pack
	movss	xmm2, DWORD PTR __real@3f800000
	mov	esi, DWORD PTR _spc$[ebp]
$LN2@stbtt_Pack:

; 3606 : 
; 3607 :    // save current values
; 3608 :    int old_h_over = spc->h_oversample;
; 3609 :    int old_v_over = spc->v_oversample;
; 3610 : 
; 3611 :    k = 0;
; 3612 :    for (i=0; i < num_ranges; ++i) {

	mov	eax, DWORD PTR _info$[ebp]
	add	edi, 24					; 00000018H
	sub	DWORD PTR _num_ranges$[ebp], 1
	xorps	xmm1, xmm1
	mov	DWORD PTR tv963[ebp], edi
	jne	$LL4@stbtt_Pack
	mov	eax, DWORD PTR _return_value$1$[ebp]
	mov	ecx, DWORD PTR _old_h_over$1$[ebp]
	mov	edx, DWORD PTR _old_v_over$1$[ebp]
	pop	edi
$LN3@stbtt_Pack:

; 3675 :       }
; 3676 :    }
; 3677 : 
; 3678 :    // restore original values
; 3679 :    spc->h_oversample = old_h_over;

	mov	DWORD PTR [esi+24], ecx

; 3680 :    spc->v_oversample = old_v_over;

	mov	DWORD PTR [esi+28], edx
	pop	esi

; 3681 : 
; 3682 :    return return_value;
; 3683 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_stbtt_PackFontRangesRenderIntoRects ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_y1$1 = -28						; size = 4
_y0$2 = -24						; size = 4
_x1$3 = -20						; size = 4
_x0$4 = -16						; size = 4
tv519 = -12						; size = 4
_scale$5 = -8						; size = 4
_k$1$ = -4						; size = 4
_spc$ = 8						; size = 4
_info$ = 12						; size = 4
_ranges$ = 16						; size = 4
_num_ranges$ = 20					; size = 4
_rects$ = 24						; size = 4
_stbtt_PackFontRangesGatherRects PROC

; 3575 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 3576 :    int i,j,k;
; 3577 : 
; 3578 :    k=0;

	xor	eax, eax
	mov	DWORD PTR _k$1$[ebp], eax

; 3579 :    for (i=0; i < num_ranges; ++i) {

	cmp	DWORD PTR _num_ranges$[ebp], eax
	jle	$LN3@stbtt_Pack

; 3576 :    int i,j,k;
; 3577 : 
; 3578 :    k=0;

	mov	eax, DWORD PTR _info$[ebp]
	xorps	xmm1, xmm1
	push	esi
	mov	esi, DWORD PTR _ranges$[ebp]
	push	edi
	add	esi, 20					; 00000014H
$LL4@stbtt_Pack:

; 3580 :       float fh = ranges[i].font_size;

	movss	xmm0, DWORD PTR [esi-20]

; 3581 :       float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);

	comiss	xmm0, xmm1
	push	ecx
	jbe	SHORT $LN9@stbtt_Pack
	movss	DWORD PTR [esp], xmm0
	push	eax
	call	_stbtt_ScaleForPixelHeight
	jmp	SHORT $LN22@stbtt_Pack
$LN9@stbtt_Pack:
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [esp], xmm0
	push	eax
	call	_stbtt_ScaleForMappingEmToPixels
$LN22@stbtt_Pack:

; 3582 :       ranges[i].h_oversample = (unsigned char) spc->h_oversample;

	mov	edx, DWORD PTR _spc$[ebp]

; 3583 :       ranges[i].v_oversample = (unsigned char) spc->v_oversample;
; 3584 :       for (j=0; j < ranges[i].num_chars; ++j) {

	xor	edi, edi
	add	esp, 8
	fstp	DWORD PTR _scale$5[ebp]
	movzx	eax, BYTE PTR [edx+24]
	mov	BYTE PTR [esi], al
	movzx	eax, BYTE PTR [edx+28]
	mov	BYTE PTR [esi+1], al
	cmp	DWORD PTR [esi-8], edi
	jle	$LN2@stbtt_Pack

; 3582 :       ranges[i].h_oversample = (unsigned char) spc->h_oversample;

	mov	eax, DWORD PTR _k$1$[ebp]
	mov	ecx, DWORD PTR _rects$[ebp]
	movss	xmm1, DWORD PTR _scale$5[ebp]
	add	ecx, 6
	shl	eax, 4
	add	eax, ecx
	mov	DWORD PTR tv519[ebp], eax
$LL7@stbtt_Pack:

; 3585 :          int x0,y0,x1,y1;
; 3586 :          int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];

	mov	ecx, DWORD PTR [esi-12]
	test	ecx, ecx
	jne	SHORT $LN11@stbtt_Pack
	mov	ecx, DWORD PTR [esi-16]
	add	ecx, edi
	jmp	SHORT $LN12@stbtt_Pack
$LN11@stbtt_Pack:
	mov	ecx, DWORD PTR [ecx+edi*4]
$LN12@stbtt_Pack:

; 3587 :          int glyph = stbtt_FindGlyphIndex(info, codepoint);
; 3588 :          stbtt_GetGlyphBitmapBoxSubpixel(info,glyph,

	lea	eax, DWORD PTR _y1$1[ebp]
	push	eax
	lea	eax, DWORD PTR _x1$3[ebp]
	push	eax
	lea	eax, DWORD PTR _y0$2[ebp]
	push	eax
	lea	eax, DWORD PTR _x0$4[ebp]
	push	eax
	mov	eax, DWORD PTR [edx+28]
	sub	esp, 16					; 00000010H
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	mov	DWORD PTR [esp+12], 0
	shr	eax, 31					; 0000001fH
	mov	DWORD PTR [esp+8], 0
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	eax, DWORD PTR [edx+24]
	cvtpd2ps xmm0, xmm0
	mulss	xmm0, xmm1
	movss	DWORD PTR [esp+4], xmm0
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	mulss	xmm0, xmm1
	movss	DWORD PTR [esp], xmm0
	push	ecx
	push	DWORD PTR _info$[ebp]
	call	_stbtt_FindGlyphIndex
	add	esp, 8
	push	eax
	push	DWORD PTR _info$[ebp]
	call	_stbtt_GetGlyphBitmapBoxSubpixel

; 3589 :                                          scale * spc->h_oversample,
; 3590 :                                          scale * spc->v_oversample,
; 3591 :                                          0,0,
; 3592 :                                          &x0,&y0,&x1,&y1);
; 3593 :          rects[k].w = (stbrp_coord) (x1-x0 + spc->padding + spc->h_oversample-1);

	mov	edx, DWORD PTR _spc$[ebp]
	inc	edi
	mov	ecx, DWORD PTR tv519[ebp]
	add	esp, 40					; 00000028H

; 3594 :          rects[k].h = (stbrp_coord) (y1-y0 + spc->padding + spc->v_oversample-1);
; 3595 :          ++k;

	inc	DWORD PTR _k$1$[ebp]
	movss	xmm1, DWORD PTR _scale$5[ebp]
	movzx	eax, WORD PTR [edx+24]
	sub	ax, WORD PTR _x0$4[ebp]
	dec	ax
	add	ax, WORD PTR [edx+20]
	add	ax, WORD PTR _x1$3[ebp]
	mov	WORD PTR [ecx-2], ax
	movzx	eax, WORD PTR [edx+20]
	sub	ax, WORD PTR _y0$2[ebp]
	dec	ax
	add	ax, WORD PTR _y1$1[ebp]
	add	ax, WORD PTR [edx+28]
	mov	WORD PTR [ecx], ax
	add	ecx, 16					; 00000010H
	mov	DWORD PTR tv519[ebp], ecx
	cmp	edi, DWORD PTR [esi-8]
	jl	$LL7@stbtt_Pack
$LN2@stbtt_Pack:

; 3579 :    for (i=0; i < num_ranges; ++i) {

	mov	eax, DWORD PTR _info$[ebp]
	add	esi, 24					; 00000018H
	sub	DWORD PTR _num_ranges$[ebp], 1
	xorps	xmm1, xmm1
	jne	$LL4@stbtt_Pack

; 3596 :       }
; 3597 :    }
; 3598 : 
; 3599 :    return k;

	mov	eax, DWORD PTR _k$1$[ebp]
	pop	edi
	pop	esi
$LN3@stbtt_Pack:

; 3600 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_stbtt_PackFontRangesGatherRects ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_ipw$1$ = -4						; size = 4
_chardata$ = 8						; size = 4
_iph$1$ = 12						; size = 4
_pw$ = 12						; size = 4
_ph$ = 16						; size = 4
_char_index$ = 20					; size = 4
_xpos$ = 24						; size = 4
_ypos$ = 28						; size = 4
_q$ = 32						; size = 4
_align_to_integer$ = 36					; size = 4
_stbtt_GetPackedQuad PROC

; 3739 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	movd	xmm0, DWORD PTR _pw$[ebp]

; 3740 :    float ipw = 1.0f / pw, iph = 1.0f / ph;

	movss	xmm1, DWORD PTR __real@3f800000
	cvtdq2ps xmm0, xmm0

; 3741 :    stbtt_packedchar *b = chardata + char_index;

	mov	eax, DWORD PTR _char_index$[ebp]
	mov	edx, DWORD PTR _chardata$[ebp]
	push	esi
	push	edi
	movaps	xmm2, xmm1

; 3742 : 
; 3743 :    if (align_to_integer) {
; 3744 :       float x = (float) STBTT_ifloor((*xpos + b->xoff) + 0.5f);

	mov	edi, DWORD PTR _xpos$[ebp]
	divss	xmm2, xmm0
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	cmp	DWORD PTR _align_to_integer$[ebp], 0
	movd	xmm0, DWORD PTR _ph$[ebp]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR _ipw$1$[ebp], xmm2
	divss	xmm1, xmm0
	movss	xmm0, DWORD PTR [edx+ecx*4+8]
	addss	xmm0, DWORD PTR [edi]
	movss	DWORD PTR _iph$1$[ebp], xmm1
	je	$LN2@stbtt_GetP
	addss	xmm0, DWORD PTR __real@3f000000
	movsd	xmm3, QWORD PTR __real@8000000000000000
	movsd	xmm6, QWORD PTR __real@4330000000000000
	movsd	xmm7, QWORD PTR __real@3ff0000000000000
	movaps	xmm1, xmm6

; 3745 :       float y = (float) STBTT_ifloor((*ypos + b->yoff) + 0.5f);
; 3746 :       q->x0 = x;

	mov	esi, DWORD PTR _q$[ebp]
	cvtps2pd xmm4, xmm0
	andps	xmm3, xmm4
	movaps	xmm0, xmm4
	xorps	xmm0, xmm3
	movaps	xmm2, xmm4
	cmpltsd	xmm0, xmm6
	andps	xmm1, xmm0
	orps	xmm1, xmm3
	addsd	xmm2, xmm1
	subsd	xmm2, xmm1
	movaps	xmm0, xmm2
	subsd	xmm0, xmm4
	movsd	xmm4, QWORD PTR __real@8000000000000000
	cmpnlesd xmm0, xmm3
	andps	xmm0, xmm7
	subsd	xmm2, xmm0
	movss	xmm0, DWORD PTR [edx+ecx*4+12]
	cvttsd2si eax, xmm2
	movd	xmm3, eax
	mov	eax, DWORD PTR _ypos$[ebp]
	cvtdq2ps xmm3, xmm3
	addss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [esi], xmm3
	addss	xmm0, DWORD PTR __real@3f000000
	cvtps2pd xmm2, xmm0
	andps	xmm4, xmm2
	movaps	xmm0, xmm2
	xorps	xmm0, xmm4
	movaps	xmm1, xmm2
	cmpltsd	xmm0, xmm6
	andps	xmm6, xmm0
	orps	xmm6, xmm4
	addsd	xmm1, xmm6
	subsd	xmm1, xmm6
	movaps	xmm0, xmm1
	subsd	xmm0, xmm2

; 3747 :       q->y0 = y;
; 3748 :       q->x1 = x + b->xoff2 - b->xoff;
; 3749 :       q->y1 = y + b->yoff2 - b->yoff;
; 3750 :    } else {

	movss	xmm2, DWORD PTR _ipw$1$[ebp]
	cmpnlesd xmm0, xmm4
	andps	xmm0, xmm7
	subsd	xmm1, xmm0
	cvttsd2si eax, xmm1
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	movss	DWORD PTR [esi+4], xmm1
	movss	xmm0, DWORD PTR [edx+ecx*4+20]
	addss	xmm0, xmm3
	subss	xmm0, DWORD PTR [edx+ecx*4+8]
	movss	DWORD PTR [esi+16], xmm0
	movss	xmm0, DWORD PTR [edx+ecx*4+24]
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR _iph$1$[ebp]
	subss	xmm0, DWORD PTR [edx+ecx*4+12]
	jmp	SHORT $LN5@stbtt_GetP
$LN2@stbtt_GetP:

; 3751 :       q->x0 = *xpos + b->xoff;

	mov	esi, DWORD PTR _q$[ebp]

; 3752 :       q->y0 = *ypos + b->yoff;

	mov	eax, DWORD PTR _ypos$[ebp]
	movss	DWORD PTR [esi], xmm0
	movss	xmm0, DWORD PTR [edx+ecx*4+12]
	addss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [esi+4], xmm0

; 3753 :       q->x1 = *xpos + b->xoff2;

	movss	xmm0, DWORD PTR [edx+ecx*4+20]
	addss	xmm0, DWORD PTR [edi]
	movss	DWORD PTR [esi+16], xmm0

; 3754 :       q->y1 = *ypos + b->yoff2;

	movss	xmm0, DWORD PTR [edx+ecx*4+24]
	addss	xmm0, DWORD PTR [eax]
$LN5@stbtt_GetP:
	movss	DWORD PTR [esi+20], xmm0

; 3755 :    }
; 3756 : 
; 3757 :    q->s0 = b->x0 * ipw;

	movzx	eax, WORD PTR [edx+ecx*4]
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm2
	movss	DWORD PTR [esi+8], xmm0

; 3758 :    q->t0 = b->y0 * iph;

	movzx	eax, WORD PTR [edx+ecx*4+2]
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+12], xmm0

; 3759 :    q->s1 = b->x1 * ipw;

	movzx	eax, WORD PTR [edx+ecx*4+4]
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm2
	movss	DWORD PTR [esi+24], xmm0

; 3760 :    q->t1 = b->y1 * iph;

	movzx	eax, WORD PTR [edx+ecx*4+6]
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	movss	DWORD PTR [esi+28], xmm0

; 3761 : 
; 3762 :    *xpos += b->xadvance;

	movss	xmm0, DWORD PTR [edx+ecx*4+16]
	addss	xmm0, DWORD PTR [edi]
	movss	DWORD PTR [edi], xmm0
	pop	edi
	pop	esi

; 3763 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_stbtt_GetPackedQuad ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_spc$ = 8						; size = 4
_h_oversample$ = 12					; size = 4
_v_oversample$ = 16					; size = 4
_stbtt_PackSetOversampling PROC

; 3426 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 3427 :    STBTT_assert(h_oversample <= STBTT_MAX_OVERSAMPLE);
; 3428 :    STBTT_assert(v_oversample <= STBTT_MAX_OVERSAMPLE);
; 3429 :    if (h_oversample <= STBTT_MAX_OVERSAMPLE)

	mov	eax, DWORD PTR _h_oversample$[ebp]
	mov	ecx, DWORD PTR _spc$[ebp]
	cmp	eax, 8
	ja	SHORT $LN2@stbtt_Pack

; 3430 :       spc->h_oversample = h_oversample;

	mov	DWORD PTR [ecx+24], eax
$LN2@stbtt_Pack:

; 3431 :    if (v_oversample <= STBTT_MAX_OVERSAMPLE)

	mov	eax, DWORD PTR _v_oversample$[ebp]
	cmp	eax, 8
	ja	SHORT $LN3@stbtt_Pack

; 3432 :       spc->v_oversample = v_oversample;

	mov	DWORD PTR [ecx+28], eax
$LN3@stbtt_Pack:

; 3433 : }

	pop	ebp
	ret	0
_stbtt_PackSetOversampling ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_spc$ = 8						; size = 4
_stbtt_PackEnd PROC

; 3420 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 3421 :    STBTT_free(spc->nodes    , spc->user_allocator_context);

	mov	esi, DWORD PTR _spc$[ebp]
	push	DWORD PTR [esi+36]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 3422 :    STBTT_free(spc->pack_info, spc->user_allocator_context);

	push	DWORD PTR [esi+4]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 8
	pop	esi

; 3423 : }

	pop	ebp
	ret	0
_stbtt_PackEnd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\truetype.h
_TEXT	SEGMENT
_spc$ = 8						; size = 4
_pixels$ = 12						; size = 4
_num_nodes$1$ = 16					; size = 4
_pw$ = 16						; size = 4
_ph$ = 20						; size = 4
_stride_in_bytes$ = 24					; size = 4
_padding$ = 28						; size = 4
_alloc_context$ = 32					; size = 4
_stbtt_PackBegin PROC

; 3389 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi

; 3390 :    stbrp_context *context = (stbrp_context *) STBTT_malloc(sizeof(*context)            ,alloc_context);

	push	48					; 00000030H
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 3391 :    int            num_nodes = pw - padding;

	mov	esi, DWORD PTR _pw$[ebp]
	mov	ebx, eax
	mov	eax, esi
	sub	eax, DWORD PTR _padding$[ebp]
	mov	DWORD PTR _num_nodes$1$[ebp], eax

; 3392 :    stbrp_node    *nodes   = (stbrp_node    *) STBTT_malloc(sizeof(*nodes  ) * num_nodes,alloc_context);

	lea	ecx, DWORD PTR [eax*8]
	push	ecx
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	add	esp, 8
	mov	edi, eax

; 3393 : 
; 3394 :    if (context == NULL || nodes == NULL) {

	test	ebx, ebx
	je	$LN4@stbtt_Pack
	test	edi, edi
	je	SHORT $LN3@stbtt_Pack

; 3398 :    }
; 3399 : 
; 3400 :    spc->user_allocator_context = alloc_context;

	mov	edx, DWORD PTR _spc$[ebp]

; 3401 :    spc->width = pw;
; 3402 :    spc->height = ph;

	mov	eax, DWORD PTR _ph$[ebp]
	mov	ecx, DWORD PTR _alloc_context$[ebp]
	mov	DWORD PTR [edx+12], eax

; 3403 :    spc->pixels = pixels;

	mov	eax, DWORD PTR _pixels$[ebp]
	mov	DWORD PTR [edx+32], eax

; 3404 :    spc->pack_info = context;
; 3405 :    spc->nodes = nodes;
; 3406 :    spc->padding = padding;

	mov	eax, DWORD PTR _padding$[ebp]
	mov	DWORD PTR [edx+20], eax

; 3407 :    spc->stride_in_bytes = stride_in_bytes != 0 ? stride_in_bytes : pw;

	mov	eax, DWORD PTR _stride_in_bytes$[ebp]
	test	eax, eax
	mov	DWORD PTR [edx], ecx
	mov	ecx, esi
	cmovne	ecx, eax
	mov	DWORD PTR [edx+36], edi
	mov	DWORD PTR [edx+16], ecx

; 3408 :    spc->h_oversample = 1;
; 3409 :    spc->v_oversample = 1;
; 3410 : 
; 3411 :    stbrp_init_target(context, pw-padding, ph-padding, nodes, num_nodes);

	mov	ecx, DWORD PTR _num_nodes$1$[ebp]
	push	ecx
	push	edi
	mov	edi, DWORD PTR _ph$[ebp]
	mov	eax, edi
	sub	eax, DWORD PTR _padding$[ebp]
	push	eax
	push	ecx
	push	ebx
	mov	DWORD PTR [edx+8], esi
	mov	DWORD PTR [edx+4], ebx
	mov	DWORD PTR [edx+24], 1
	mov	DWORD PTR [edx+28], 1
	call	_stbrp_init_target

; 3412 : 
; 3413 :    if (pixels)

	mov	eax, DWORD PTR _pixels$[ebp]
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN6@stbtt_Pack

; 3414 :       STBTT_memset(pixels, 0, pw*ph); // background of 0 around pixels

	imul	esi, edi
	push	esi
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN6@stbtt_Pack:

; 3415 : 
; 3416 :    return 1;

	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx

; 3417 : }

	pop	ebp
	ret	0
$LN3@stbtt_Pack:

; 3395 :       if (context != NULL) STBTT_free(context, alloc_context);

	push	ebx

; 3396 :       if (nodes   != NULL) STBTT_free(nodes  , alloc_context);

	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 3397 :       return 0;

	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx

; 3417 : }

	pop	ebp
	ret	0
$LN4@stbtt_Pack:

; 3396 :       if (nodes   != NULL) STBTT_free(nodes  , alloc_context);

	test	edi, edi
	je	SHORT $LN5@stbtt_Pack
	push	edi
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN5@stbtt_Pack:

; 3397 :       return 0;

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 3417 : }

	pop	ebp
	ret	0
_stbtt_PackBegin ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\rect_pack.h
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
?rect_original_order@@YAHPBX0@Z PROC			; rect_original_order

; 535  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 536  :    const stbrp_rect *p = (const stbrp_rect *) a;
; 537  :    const stbrp_rect *q = (const stbrp_rect *) b;
; 538  :    return (p->was_packed < q->was_packed) ? -1 : (p->was_packed > q->was_packed);

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	ecx, edx
	jge	SHORT $LN3@rect_origi
	or	eax, -1

; 539  : }

	pop	ebp
	ret	0
$LN3@rect_origi:

; 536  :    const stbrp_rect *p = (const stbrp_rect *) a;
; 537  :    const stbrp_rect *q = (const stbrp_rect *) b;
; 538  :    return (p->was_packed < q->was_packed) ? -1 : (p->was_packed > q->was_packed);

	xor	eax, eax
	cmp	ecx, edx
	setg	al

; 539  : }

	pop	ebp
	ret	0
?rect_original_order@@YAHPBX0@Z ENDP			; rect_original_order
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\rect_pack.h
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
?rect_height_compare@@YAHPBX0@Z PROC			; rect_height_compare

; 513  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 514  :    const stbrp_rect *p = (const stbrp_rect *) a;
; 515  :    const stbrp_rect *q = (const stbrp_rect *) b;
; 516  :    if (p->h > q->h)

	mov	edx, DWORD PTR _a$[ebp]
	push	esi
	mov	esi, DWORD PTR _b$[ebp]
	movzx	eax, WORD PTR [edx+6]
	movzx	ecx, WORD PTR [esi+6]
	cmp	ax, cx
	jbe	SHORT $LN7@rect_heigh
$LN9@rect_heigh:

; 517  :       return -1;

	or	eax, -1
	pop	esi

; 521  : }

	pop	ebp
	ret	0
$LN7@rect_heigh:

; 518  :    if (p->h < q->h)

	jae	SHORT $LN3@rect_heigh

; 519  :       return  1;

	mov	eax, 1
	pop	esi

; 521  : }

	pop	ebp
	ret	0
$LN3@rect_heigh:

; 520  :    return (p->w > q->w) ? -1 : (p->w < q->w);

	movzx	eax, WORD PTR [edx+4]
	movzx	ecx, WORD PTR [esi+4]
	cmp	ax, cx
	ja	SHORT $LN9@rect_heigh
	sbb	eax, eax
	neg	eax
	pop	esi

; 521  : }

	pop	ebp
	ret	0
?rect_height_compare@@YAHPBX0@Z ENDP			; rect_height_compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\rect_pack.h
_TEXT	SEGMENT
$T1 = -12						; size = 12
tv276 = 8						; size = 4
$T2 = 8							; size = 4
_context$ = 12						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
?stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PAUstbrp_context@@HH@Z PROC ; stbrp__skyline_pack_rectangle

; 431  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 432  :    // find best position according to heuristic
; 433  :    stbrp__findresult res = stbrp__skyline_find_best_pos(context, width, height);

	lea	eax, DWORD PTR $T1[ebp]
	push	ebx
	mov	ebx, DWORD PTR _context$[ebp]
	push	esi
	mov	esi, DWORD PTR _height$[ebp]
	push	edi
	push	esi
	push	DWORD PTR _width$[ebp]
	push	ebx
	push	eax
	call	?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PAUstbrp_context@@HH@Z ; stbrp__skyline_find_best_pos
	mov	edi, DWORD PTR $T2[ebp]
	add	esp, 16					; 00000010H
	movq	xmm0, QWORD PTR [eax]
	mov	eax, DWORD PTR [eax+8]

; 434  :    stbrp_node *node, *cur;
; 435  : 
; 436  :    // bail if:
; 437  :    //    1. it failed
; 438  :    //    2. the best node doesn't fit (we don't always check this)
; 439  :    //    3. we're out of memory
; 440  :    if (res.prev_link == NULL || res.y + height > context->height || context->free_head == NULL) {

	mov	ecx, eax
	movq	QWORD PTR [edi], xmm0
	mov	DWORD PTR [edi+8], eax
	test	ecx, ecx
	je	$LN5@stbrp__sky
	mov	eax, DWORD PTR [edi+4]
	add	eax, esi
	cmp	eax, DWORD PTR [ebx+4]
	jg	SHORT $LN5@stbrp__sky
	mov	edx, DWORD PTR [ebx+28]
	test	edx, edx
	je	SHORT $LN5@stbrp__sky

; 443  :    }
; 444  : 
; 445  :    // on success, create new node
; 446  :    node = context->free_head;
; 447  :    node->x = (stbrp_coord) res.x;

	movzx	eax, WORD PTR [edi]
	mov	WORD PTR [edx], ax

; 448  :    node->y = (stbrp_coord) (res.y + height);

	mov	ax, WORD PTR [edi+4]
	add	ax, si
	mov	WORD PTR [edx+2], ax

; 449  : 
; 450  :    context->free_head = node->next;

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ebx+28], eax

; 451  : 
; 452  :    // insert the new node into the right starting point, and
; 453  :    // let 'cur' point to the remaining nodes needing to be
; 454  :    // stiched back in
; 455  : 
; 456  :    cur = *res.prev_link;

	mov	esi, DWORD PTR [ecx]

; 457  :    if (cur->x < res.x) {

	movzx	eax, WORD PTR [esi]
	cmp	eax, DWORD PTR [edi]
	jge	SHORT $LN6@stbrp__sky

; 458  :       // preserve the existing one, so start testing with the next one
; 459  :       stbrp_node *next = cur->next;

	lea	eax, DWORD PTR [esi+4]
	mov	esi, DWORD PTR [eax]

; 460  :       cur->next = node;

	mov	DWORD PTR [eax], edx

; 461  :       cur = next;
; 462  :    } else {

	jmp	SHORT $LN10@stbrp__sky
$LN6@stbrp__sky:

; 463  :       *res.prev_link = node;

	mov	DWORD PTR [ecx], edx
$LN10@stbrp__sky:

; 464  :    }
; 465  : 
; 466  :    // from here, traverse cur and free the nodes, until we get to one
; 467  :    // that shouldn't be freed
; 468  :    while (cur->next && cur->next->x <= res.x + width) {

	cmp	DWORD PTR [esi+4], 0
	je	SHORT $LN14@stbrp__sky
	mov	eax, DWORD PTR _width$[ebp]
	add	eax, DWORD PTR [edi]
	mov	DWORD PTR tv276[ebp], eax
$LL2@stbrp__sky:
	mov	ecx, DWORD PTR [esi+4]
	movzx	eax, WORD PTR [ecx]
	cmp	eax, DWORD PTR tv276[ebp]
	jg	SHORT $LN14@stbrp__sky

; 469  :       stbrp_node *next = cur->next;
; 470  :       // move the current node to the free list
; 471  :       cur->next = context->free_head;

	mov	eax, DWORD PTR [ebx+28]
	mov	DWORD PTR [esi+4], eax

; 472  :       context->free_head = cur;

	mov	DWORD PTR [ebx+28], esi

; 473  :       cur = next;

	mov	esi, ecx
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LL2@stbrp__sky
$LN14@stbrp__sky:

; 474  :    }
; 475  : 
; 476  :    // stitch the list back in
; 477  :    node->next = cur;
; 478  : 
; 479  :    if (cur->x < res.x + width)

	mov	eax, DWORD PTR _width$[ebp]
	mov	DWORD PTR [edx+4], esi
	mov	edx, DWORD PTR [edi]
	movzx	ecx, WORD PTR [esi]
	add	edx, eax
	cmp	ecx, edx
	jge	SHORT $LN8@stbrp__sky

; 480  :       cur->x = (stbrp_coord) (res.x + width);

	movzx	ecx, WORD PTR [edi]
	add	ecx, eax
	mov	eax, edi
	pop	edi
	mov	WORD PTR [esi], cx
	pop	esi
	pop	ebx

; 481  : 
; 482  : #ifdef _DEBUG
; 483  :    cur = context->active_head;
; 484  :    while (cur->x < context->width) {
; 485  :       STBRP_ASSERT(cur->x < cur->next->x);
; 486  :       cur = cur->next;
; 487  :    }
; 488  :    STBRP_ASSERT(cur->next == NULL);
; 489  : 
; 490  :    {
; 491  :       stbrp_node *L1 = NULL, *L2 = NULL;
; 492  :       int count=0;
; 493  :       cur = context->active_head;
; 494  :       while (cur) {
; 495  :          L1 = cur;
; 496  :          cur = cur->next;
; 497  :          ++count;
; 498  :       }
; 499  :       cur = context->free_head;
; 500  :       while (cur) {
; 501  :          L2 = cur;
; 502  :          cur = cur->next;
; 503  :          ++count;
; 504  :       }
; 505  :       STBRP_ASSERT(count == context->num_nodes+2);
; 506  :    }
; 507  : #endif
; 508  : 
; 509  :    return res;
; 510  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@stbrp__sky:

; 441  :       res.prev_link = NULL;

	mov	DWORD PTR [edi+8], 0
$LN8@stbrp__sky:

; 442  :       return res;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 481  : 
; 482  : #ifdef _DEBUG
; 483  :    cur = context->active_head;
; 484  :    while (cur->x < context->width) {
; 485  :       STBRP_ASSERT(cur->x < cur->next->x);
; 486  :       cur = cur->next;
; 487  :    }
; 488  :    STBRP_ASSERT(cur->next == NULL);
; 489  : 
; 490  :    {
; 491  :       stbrp_node *L1 = NULL, *L2 = NULL;
; 492  :       int count=0;
; 493  :       cur = context->active_head;
; 494  :       while (cur) {
; 495  :          L1 = cur;
; 496  :          cur = cur->next;
; 497  :          ++count;
; 498  :       }
; 499  :       cur = context->free_head;
; 500  :       while (cur) {
; 501  :          L2 = cur;
; 502  :          cur = cur->next;
; 503  :          ++count;
; 504  :       }
; 505  :       STBRP_ASSERT(count == context->num_nodes+2);
; 506  :    }
; 507  : #endif
; 508  : 
; 509  :    return res;
; 510  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PAUstbrp_context@@HH@Z ENDP ; stbrp__skyline_pack_rectangle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\rect_pack.h
_TEXT	SEGMENT
_waste$1 = -32						; size = 4
tv362 = -28						; size = 4
_waste$2 = -28						; size = 4
_prev$2$ = -24						; size = 4
_node$2$ = -20						; size = 4
_tail$1$ = -16						; size = 4
_best_x$1$ = -12					; size = 4
_best_waste$1$ = -8					; size = 4
_best$1$ = -4						; size = 4
$T3 = 8							; size = 4
_c$ = 12						; size = 4
_width$1$ = 16						; size = 4
_width$ = 16						; size = 4
_height$ = 20						; size = 4
?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PAUstbrp_context@@HH@Z PROC ; stbrp__skyline_find_best_pos

; 336  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 337  :    int best_waste = (1<<30), best_x, best_y = (1 << 30);
; 338  :    stbrp__findresult fr;
; 339  :    stbrp_node **prev, *node, *tail, **best = NULL;
; 340  : 
; 341  :    // align to multiple of c->align
; 342  :    width = (width + c->align - 1);

	mov	edx, DWORD PTR _c$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _width$[ebp]
	mov	ebx, 1073741824				; 40000000H
	mov	ecx, DWORD PTR [edx+8]
	dec	esi
	add	esi, ecx
	mov	DWORD PTR _best_waste$1$[ebp], 1073741824 ; 40000000H

; 343  :    width -= width % c->align;

	mov	eax, esi
	mov	DWORD PTR _best$1$[ebp], 0
	cdq
	idiv	ecx
	push	edi
	sub	esi, edx

; 344  :    STBRP_ASSERT(width % c->align == 0);
; 345  : 
; 346  :    node = c->active_head;

	mov	edx, DWORD PTR _c$[ebp]
	mov	edi, DWORD PTR [edx+24]
	lea	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _width$1$[ebp], esi

; 347  :    prev = &c->active_head;

	mov	esi, eax
	mov	DWORD PTR _prev$2$[ebp], eax

; 348  :    while (node->x + width <= c->width) {

	mov	eax, DWORD PTR _width$1$[ebp]
	movzx	ecx, WORD PTR [edi]
	add	eax, ecx
	cmp	eax, DWORD PTR [edx]
	jg	SHORT $LN40@stbrp__sky
	npad	2
$LL2@stbrp__sky:

; 349  :       int y,waste;
; 350  :       y = stbrp__skyline_find_min_y(c, node, node->x, width, &waste);

	lea	eax, DWORD PTR _waste$2[ebp]
	push	eax
	push	DWORD PTR _width$1$[ebp]
	push	ecx
	push	edi
	push	edx
	call	?stbrp__skyline_find_min_y@@YAHPAUstbrp_context@@PAUstbrp_node@@HHPAH@Z ; stbrp__skyline_find_min_y

; 351  :       if (c->heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight) { // actually just want to test BL

	mov	edx, DWORD PTR _c$[ebp]
	add	esp, 20					; 00000014H
	mov	ecx, eax
	cmp	DWORD PTR [edx+16], 0
	jne	SHORT $LN10@stbrp__sky

; 352  :          // bottom left
; 353  :          if (y < best_y) {

	cmp	ecx, ebx
	jge	SHORT $LN14@stbrp__sky

; 354  :             best_y = y;
; 355  :             best = prev;
; 356  :          }
; 357  :       } else {

	jmp	SHORT $LN43@stbrp__sky
$LN10@stbrp__sky:

; 358  :          // best-fit
; 359  :          if (y + height <= c->height) {

	mov	eax, DWORD PTR _height$[ebp]
	add	eax, ecx
	cmp	eax, DWORD PTR [edx+4]
	jg	SHORT $LN14@stbrp__sky

; 360  :             // can only use it if it first vertically
; 361  :             if (y < best_y || (y == best_y && waste < best_waste)) {

	mov	eax, DWORD PTR _waste$2[ebp]
	cmp	ecx, ebx
	jl	SHORT $LN15@stbrp__sky
	jne	SHORT $LN14@stbrp__sky
	cmp	eax, DWORD PTR _best_waste$1$[ebp]
	jge	SHORT $LN14@stbrp__sky
$LN15@stbrp__sky:

; 362  :                best_y = y;
; 363  :                best_waste = waste;

	mov	DWORD PTR _best_waste$1$[ebp], eax
$LN43@stbrp__sky:

; 364  :                best = prev;

	mov	DWORD PTR _best$1$[ebp], esi
	mov	ebx, ecx
$LN14@stbrp__sky:

; 365  :             }
; 366  :          }
; 367  :       }
; 368  :       prev = &node->next;

	mov	eax, DWORD PTR _width$1$[ebp]
	lea	esi, DWORD PTR [edi+4]

; 369  :       node = node->next;

	mov	edi, DWORD PTR [esi]
	movzx	ecx, WORD PTR [edi]
	add	eax, ecx
	cmp	eax, DWORD PTR [edx]
	jle	SHORT $LL2@stbrp__sky

; 370  :    }
; 371  : 
; 372  :    best_x = (best == NULL) ? 0 : (*best)->x;

	mov	eax, DWORD PTR _best$1$[ebp]
	test	eax, eax
	je	SHORT $LN40@stbrp__sky
	mov	eax, DWORD PTR [eax]
	movzx	eax, WORD PTR [eax]
	mov	DWORD PTR _best_x$1$[ebp], eax
	jmp	SHORT $LN23@stbrp__sky
$LN40@stbrp__sky:
	mov	DWORD PTR _best_x$1$[ebp], 0
$LN23@stbrp__sky:

; 373  : 
; 374  :    // if doing best-fit (BF), we also have to try aligning right edge to each node position
; 375  :    //
; 376  :    // e.g, if fitting
; 377  :    //
; 378  :    //     ____________________
; 379  :    //    |____________________|
; 380  :    //
; 381  :    //            into
; 382  :    //
; 383  :    //   |                         |
; 384  :    //   |             ____________|
; 385  :    //   |____________|
; 386  :    //
; 387  :    // then right-aligned reduces waste, but bottom-left BL is always chooses left-aligned
; 388  :    //
; 389  :    // This makes BF take about 2x the time
; 390  : 
; 391  :    if (c->heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight) {

	cmp	DWORD PTR [edx+16], 1
	jne	$LN7@stbrp__sky

; 392  :       tail = c->active_head;

	mov	esi, DWORD PTR [edx+24]

; 393  :       node = c->active_head;

	mov	ecx, esi

; 394  :       prev = &c->active_head;
; 395  :       // find first node that's admissible
; 396  :       while (tail->x < width)

	mov	edx, DWORD PTR _width$1$[ebp]
	mov	DWORD PTR _tail$1$[ebp], esi
	mov	DWORD PTR _node$2$[ebp], ecx
	movzx	eax, WORD PTR [esi]
	cmp	eax, edx
	jge	SHORT $LN41@stbrp__sky
	npad	5
$LL4@stbrp__sky:

; 397  :          tail = tail->next;

	mov	esi, DWORD PTR [esi+4]
	movzx	eax, WORD PTR [esi]
	cmp	eax, edx
	jl	SHORT $LL4@stbrp__sky
	mov	DWORD PTR _tail$1$[ebp], esi
$LN41@stbrp__sky:
	lea	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv362[ebp], edx
$LL6@stbrp__sky:

; 398  :       while (tail) {
; 399  :          int xpos = tail->x - width;
; 400  :          int y,waste;
; 401  :          STBRP_ASSERT(xpos >= 0);
; 402  :          // find the left position that matches this
; 403  :          while (node->next->x <= xpos) {

	mov	ecx, DWORD PTR [edx]
	movzx	edi, WORD PTR [esi]
	sub	edi, DWORD PTR _width$1$[ebp]
	movzx	eax, WORD PTR [ecx]
	cmp	eax, edi
	jg	SHORT $LN9@stbrp__sky
$LL8@stbrp__sky:

; 404  :             prev = &node->next;
; 405  :             node = node->next;

	mov	esi, ecx
	mov	DWORD PTR _prev$2$[ebp], edx
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR _node$2$[ebp], esi
	lea	edx, DWORD PTR [esi+4]
	movzx	eax, WORD PTR [ecx]
	cmp	eax, edi
	jle	SHORT $LL8@stbrp__sky
	mov	esi, DWORD PTR _tail$1$[ebp]
	mov	DWORD PTR tv362[ebp], edx
$LN9@stbrp__sky:

; 406  :          }
; 407  :          STBRP_ASSERT(node->next->x > xpos && node->x <= xpos);
; 408  :          y = stbrp__skyline_find_min_y(c, node, xpos, width, &waste);

	lea	eax, DWORD PTR _waste$1[ebp]
	push	eax
	push	DWORD PTR _width$1$[ebp]
	push	edi
	push	DWORD PTR _node$2$[ebp]
	push	DWORD PTR _c$[ebp]
	call	?stbrp__skyline_find_min_y@@YAHPAUstbrp_context@@PAUstbrp_node@@HHPAH@Z ; stbrp__skyline_find_min_y

; 409  :          if (y + height < c->height) {

	mov	edx, DWORD PTR _c$[ebp]
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _height$[ebp]
	add	ecx, eax
	cmp	ecx, DWORD PTR [edx+4]
	jge	SHORT $LN19@stbrp__sky

; 410  :             if (y <= best_y) {

	cmp	eax, ebx
	jg	SHORT $LN19@stbrp__sky

; 411  :                if (y < best_y || waste < best_waste || (waste==best_waste && xpos < best_x)) {

	mov	ecx, DWORD PTR _waste$1[ebp]
	jl	SHORT $LN20@stbrp__sky
	mov	edx, DWORD PTR _best_waste$1$[ebp]
	cmp	ecx, edx
	jl	SHORT $LN20@stbrp__sky
	jne	SHORT $LN19@stbrp__sky
	cmp	edi, DWORD PTR _best_x$1$[ebp]
	jge	SHORT $LN19@stbrp__sky
$LN20@stbrp__sky:

; 412  :                   best_x = xpos;
; 413  :                   STBRP_ASSERT(y <= best_y);
; 414  :                   best_y = y;

	mov	ebx, eax
	mov	DWORD PTR _best_x$1$[ebp], edi

; 415  :                   best_waste = waste;
; 416  :                   best = prev;

	mov	eax, DWORD PTR _prev$2$[ebp]
	mov	DWORD PTR _best_waste$1$[ebp], ecx
	mov	DWORD PTR _best$1$[ebp], eax
$LN19@stbrp__sky:

; 417  :                }
; 418  :             }
; 419  :          }
; 420  :          tail = tail->next;

	mov	esi, DWORD PTR [esi+4]
	mov	edx, DWORD PTR tv362[ebp]
	mov	DWORD PTR _tail$1$[ebp], esi
	test	esi, esi
	jne	SHORT $LL6@stbrp__sky
$LN7@stbrp__sky:

; 421  :       }         
; 422  :    }
; 423  : 
; 424  :    fr.prev_link = best;

	mov	eax, DWORD PTR $T3[ebp]
	mov	ecx, DWORD PTR _best$1$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax+8], ecx

; 425  :    fr.x = best_x;

	mov	ecx, DWORD PTR _best_x$1$[ebp]

; 426  :    fr.y = best_y;

	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 427  :    return fr;
; 428  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?stbrp__skyline_find_best_pos@@YA?AUstbrp__findresult@@PAUstbrp_context@@HH@Z ENDP ; stbrp__skyline_find_best_pos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\rect_pack.h
_TEXT	SEGMENT
_x1$1$ = -8						; size = 4
_waste_area$1$ = -4					; size = 4
_c$ = 8							; size = 4
_min_y$1$ = 12						; size = 4
_first$ = 12						; size = 4
_x0$ = 16						; size = 4
_width$ = 20						; size = 4
_pwaste$ = 24						; size = 4
?stbrp__skyline_find_min_y@@YAHPAUstbrp_context@@PAUstbrp_node@@HHPAH@Z PROC ; stbrp__skyline_find_min_y

; 280  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 281  :    stbrp_node *node = first;

	mov	eax, DWORD PTR _first$[ebp]

; 282  :    int x1 = x0 + width;
; 283  :    int min_y, visited_width, waste_area;
; 284  : 
; 285  :    STBRP__NOTUSED(c);
; 286  : 
; 287  :    STBRP_ASSERT(first->x <= x0);
; 288  : 
; 289  :    #if 0
; 290  :    // skip in case we're past the node
; 291  :    while (node->next->x <= x0)
; 292  :       ++node;
; 293  :    #else
; 294  :    STBRP_ASSERT(node->next->x > x0); // we ended up handling this in the caller for efficiency
; 295  :    #endif
; 296  : 
; 297  :    STBRP_ASSERT(node->x <= x0);
; 298  : 
; 299  :    min_y = 0;

	xor	edx, edx
	push	ebx
	mov	ebx, DWORD PTR _x0$[ebp]
	add	ebx, DWORD PTR _width$[ebp]

; 300  :    waste_area = 0;
; 301  :    visited_width = 0;
; 302  :    while (node->x < x1) {

	movzx	ecx, WORD PTR [eax]
	push	esi
	push	edi
	xor	edi, edi
	mov	DWORD PTR _x1$1$[ebp], ebx
	xor	esi, esi
	mov	DWORD PTR _min_y$1$[ebp], edx
	mov	DWORD PTR _waste_area$1$[ebp], edi
	cmp	ecx, ebx
	jge	SHORT $LN14@stbrp__sky
	npad	6
$LL2@stbrp__sky:

; 303  :       if (node->y > min_y) {

	movzx	ebx, WORD PTR [eax+2]

; 311  :             visited_width += node->next->x - x0;

	mov	edi, DWORD PTR [eax+4]
	cmp	ebx, edx
	jle	SHORT $LN4@stbrp__sky

; 304  :          // raise min_y higher.
; 305  :          // we've accounted for all waste up to min_y,
; 306  :          // but we'll now add more waste for everything we've visted
; 307  :          waste_area += visited_width * (node->y - min_y);

	mov	ecx, ebx
	sub	ecx, edx

; 308  :          min_y = node->y;

	mov	edx, ebx

; 309  :          // the first time through, visited_width might be reduced
; 310  :          if (node->x < x0)

	movzx	ebx, WORD PTR [eax]

; 311  :             visited_width += node->next->x - x0;

	movzx	eax, WORD PTR [edi]
	imul	ecx, esi
	mov	DWORD PTR _min_y$1$[ebp], edx
	cmp	ebx, DWORD PTR _x0$[ebp]
	jge	SHORT $LN6@stbrp__sky
	sub	eax, DWORD PTR _x0$[ebp]
	add	esi, eax

; 312  :          else

	jmp	SHORT $LN5@stbrp__sky
$LN6@stbrp__sky:

; 313  :             visited_width += node->next->x - node->x;

	sub	eax, ebx
	add	esi, eax

; 314  :       } else {

	jmp	SHORT $LN5@stbrp__sky
$LN4@stbrp__sky:

; 315  :          // add waste area
; 316  :          int under_width = node->next->x - node->x;

	movzx	eax, WORD PTR [eax]
	movzx	ecx, WORD PTR [edi]
	mov	edx, DWORD PTR _width$[ebp]
	sub	ecx, eax
	sub	edx, esi

; 317  :          if (under_width + visited_width > width)

	lea	eax, DWORD PTR [ecx+esi]
	cmp	eax, DWORD PTR _width$[ebp]
	cmovle	edx, ecx

; 318  :             under_width = width - visited_width;
; 319  :          waste_area += under_width * (min_y - node->y);

	mov	ecx, DWORD PTR _min_y$1$[ebp]

; 320  :          visited_width += under_width;

	add	esi, edx
	sub	ecx, ebx
	imul	ecx, edx
	mov	edx, DWORD PTR _min_y$1$[ebp]
$LN5@stbrp__sky:

; 321  :       }
; 322  :       node = node->next;

	mov	eax, edi
	mov	edi, DWORD PTR _waste_area$1$[ebp]
	add	edi, ecx
	mov	DWORD PTR _waste_area$1$[ebp], edi
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, DWORD PTR _x1$1$[ebp]
	jl	SHORT $LL2@stbrp__sky

; 323  :    }
; 324  : 
; 325  :    *pwaste = waste_area;

	mov	ecx, DWORD PTR _pwaste$[ebp]

; 326  :    return min_y;

	mov	eax, edx
	mov	DWORD PTR [ecx], edi
	pop	edi
	pop	esi
	pop	ebx

; 327  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@stbrp__sky:

; 323  :    }
; 324  : 
; 325  :    *pwaste = waste_area;

	mov	eax, DWORD PTR _pwaste$[ebp]
	mov	DWORD PTR [eax], edi

; 326  :    return min_y;

	mov	eax, edx
	pop	edi
	pop	esi
	pop	ebx

; 327  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?stbrp__skyline_find_min_y@@YAHPAUstbrp_context@@PAUstbrp_node@@HHPAH@Z ENDP ; stbrp__skyline_find_min_y
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\rect_pack.h
_TEXT	SEGMENT
_context$ = 8						; size = 4
_allow_out_of_mem$ = 12					; size = 4
_stbrp_setup_allow_out_of_mem PROC

; 227  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 228  :    if (allow_out_of_mem)

	cmp	DWORD PTR _allow_out_of_mem$[ebp], 0
	je	SHORT $LN2@stbrp_setu

; 229  :       // if it's ok to run out of memory, then don't bother aligning them;
; 230  :       // this gives better packing, but may fail due to OOM (even though
; 231  :       // the rectangles easily fit). @TODO a smarter approach would be to only
; 232  :       // quantize once we've hit OOM, then we could get rid of this parameter.
; 233  :       context->align = 1;

	mov	eax, DWORD PTR _context$[ebp]
	mov	DWORD PTR [eax+8], 1

; 243  :    }
; 244  : }

	pop	ebp
	ret	0
$LN2@stbrp_setu:
	push	esi

; 234  :    else {
; 235  :       // if it's not ok to run out of memory, then quantize the widths
; 236  :       // so that num_nodes is always enough nodes.
; 237  :       //
; 238  :       // I.e. num_nodes * align >= width
; 239  :       //                  align >= width / num_nodes
; 240  :       //                  align = ceil(width/num_nodes)
; 241  : 
; 242  :       context->align = (context->width + context->num_nodes-1) / context->num_nodes;

	mov	esi, DWORD PTR _context$[ebp]
	mov	eax, DWORD PTR [esi]
	dec	eax
	add	eax, DWORD PTR [esi+20]
	cdq
	idiv	DWORD PTR [esi+20]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 243  :    }
; 244  : }

	pop	ebp
	ret	0
_stbrp_setup_allow_out_of_mem ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\rect_pack.h
_TEXT	SEGMENT
_context$ = 8						; size = 4
_width$ = 12						; size = 4
_height$ = 16						; size = 4
_nodes$ = 20						; size = 4
_num_nodes$ = 24					; size = 4
_stbrp_init_target PROC

; 247  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 248  :    int i;
; 249  : #ifndef STBRP_LARGE_RECTS
; 250  :    STBRP_ASSERT(width <= 0xffff && height <= 0xffff);
; 251  : #endif
; 252  : 
; 253  :    for (i=0; i < num_nodes-1; ++i)

	mov	edx, DWORD PTR _num_nodes$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _nodes$[ebp]
	dec	edx
	push	esi
	xor	esi, esi
	push	edi
	movd	xmm0, ebx
	pshufd	xmm1, xmm0, 0
	test	edx, edx
	jle	$LN3@stbrp_init
	cmp	edx, 8
	jb	$LN9@stbrp_init
	movaps	xmm2, XMMWORD PTR __xmm@00000003000000020000000100000000
	mov	eax, edx
	and	eax, -2147483641			; 80000007H
	jns	SHORT $LN15@stbrp_init
	dec	eax
	or	eax, -8					; fffffff8H
	inc	eax
$LN15@stbrp_init:
	movaps	xmm4, XMMWORD PTR __xmm@00000008000000080000000800000008
	lea	ecx, DWORD PTR [ebx+12]
	mov	edi, edx
	sub	edi, eax
	mov	eax, 3
	movd	xmm3, eax
	npad	9
$LL4@stbrp_init:
	movd	xmm0, esi
	lea	eax, DWORD PTR [esi+4]
	pshufd	xmm0, xmm0, 0
	lea	ecx, DWORD PTR [ecx+64]
	paddd	xmm0, xmm2
	add	esi, 8
	pslld	xmm0, xmm3

; 254  :       nodes[i].next = &nodes[i+1];

	paddd	xmm0, xmm1
	paddd	xmm0, xmm4
	movd	DWORD PTR [ecx-72], xmm0
	psrldq	xmm0, 4
	movd	DWORD PTR [ecx-64], xmm0
	psrldq	xmm0, 4
	movd	DWORD PTR [ecx-56], xmm0
	psrldq	xmm0, 4
	movd	DWORD PTR [ecx-48], xmm0
	movd	xmm0, eax
	pshufd	xmm0, xmm0, 0
	paddd	xmm0, xmm2
	pslld	xmm0, xmm3
	paddd	xmm0, xmm1
	paddd	xmm0, xmm4
	movd	DWORD PTR [ecx-40], xmm0
	psrldq	xmm0, 4
	movd	DWORD PTR [ecx-32], xmm0
	psrldq	xmm0, 4
	movd	DWORD PTR [ecx-24], xmm0
	psrldq	xmm0, 4
	movd	DWORD PTR [ecx-16], xmm0
	cmp	esi, edi
	jl	$LL4@stbrp_init
$LN9@stbrp_init:

; 248  :    int i;
; 249  : #ifndef STBRP_LARGE_RECTS
; 250  :    STBRP_ASSERT(width <= 0xffff && height <= 0xffff);
; 251  : #endif
; 252  : 
; 253  :    for (i=0; i < num_nodes-1; ++i)

	cmp	esi, edx
	jge	SHORT $LN3@stbrp_init
	lea	eax, DWORD PTR [ebx+4]
	sub	edx, esi
	lea	eax, DWORD PTR [eax+esi*8]
	add	esi, edx
$LL8@stbrp_init:

; 254  :       nodes[i].next = &nodes[i+1];

	lea	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax], ecx
	lea	eax, DWORD PTR [eax+8]
	sub	edx, 1
	jne	SHORT $LL8@stbrp_init
$LN3@stbrp_init:

; 255  :    nodes[i].next = NULL;
; 256  :    context->init_mode = STBRP__INIT_skyline;

	mov	edi, DWORD PTR _context$[ebp]

; 257  :    context->heuristic = STBRP_HEURISTIC_Skyline_default;
; 258  :    context->free_head = &nodes[0];
; 259  :    context->active_head = &context->extra[0];
; 260  :    context->width = width;
; 261  :    context->height = height;

	mov	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR [ebx+esi*8+4], 0
	mov	esi, DWORD PTR _width$[ebp]
	mov	DWORD PTR [edi+4], eax
	lea	ecx, DWORD PTR [edi+32]

; 262  :    context->num_nodes = num_nodes;

	mov	eax, DWORD PTR _num_nodes$[ebp]

; 263  :    stbrp_setup_allow_out_of_mem(context, 0);

	push	0
	push	edi
	mov	DWORD PTR [edi+12], 1
	mov	DWORD PTR [edi+16], 0
	mov	DWORD PTR [edi+28], ebx
	mov	DWORD PTR [edi+24], ecx
	mov	DWORD PTR [edi], esi
	mov	DWORD PTR [edi+20], eax
	call	_stbrp_setup_allow_out_of_mem
	add	esp, 8

; 264  : 
; 265  :    // node 0 is the full width, node 1 is the sentinel (lets us not store width explicitly)
; 266  :    context->extra[0].x = 0;
; 267  :    context->extra[0].y = 0;
; 268  :    context->extra[0].next = &context->extra[1];
; 269  :    context->extra[1].x = (stbrp_coord) width;

	mov	WORD PTR [edi+40], si
	xor	eax, eax

; 270  : #ifdef STBRP_LARGE_RECTS
; 271  :    context->extra[1].y = (1<<30);
; 272  : #else
; 273  :    context->extra[1].y = 65535;
; 274  : #endif
; 275  :    context->extra[1].next = NULL;

	mov	DWORD PTR [edi+44], 0
	mov	WORD PTR [edi+34], ax
	mov	WORD PTR [ecx], ax
	lea	eax, DWORD PTR [edi+40]
	mov	DWORD PTR [edi+36], eax
	mov	eax, 65535				; 0000ffffH
	mov	WORD PTR [edi+42], ax
	pop	edi
	pop	esi
	pop	ebx

; 276  : }

	pop	ebp
	ret	0
_stbrp_init_target ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\rect_pack.h
_TEXT	SEGMENT
$T1 = -24						; size = 12
_fr$2 = -12						; size = 12
_context$ = 8						; size = 4
_rects$ = 12						; size = 4
_num_rects$ = 16					; size = 4
_stbrp_pack_rects PROC

; 548  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 549  :    int i;
; 550  : 
; 551  :    // we use the 'was_packed' field internally to allow sorting/unsorting
; 552  :    for (i=0; i < num_rects; ++i) {

	xor	eax, eax
	push	ebx
	mov	ebx, DWORD PTR _rects$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _num_rects$[ebp]
	test	edi, edi
	jle	SHORT $LN3@stbrp_pack
	lea	ecx, DWORD PTR [ebx+12]
	npad	6
$LL4@stbrp_pack:

; 553  :       rects[i].was_packed = i;

	mov	DWORD PTR [ecx], eax
	lea	ecx, DWORD PTR [ecx+16]
	inc	eax
	cmp	eax, edi
	jl	SHORT $LL4@stbrp_pack
$LN3@stbrp_pack:

; 554  :       #ifndef STBRP_LARGE_RECTS
; 555  :       STBRP_ASSERT(rects[i].w <= 0xffff && rects[i].h <= 0xffff);
; 556  :       #endif
; 557  :    }
; 558  : 
; 559  :    // sort according to heuristic
; 560  :    STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_height_compare);

	push	OFFSET ?rect_height_compare@@YAHPBX0@Z	; rect_height_compare
	push	16					; 00000010H
	push	edi
	push	ebx
	call	DWORD PTR __imp__qsort
	add	esp, 16					; 00000010H

; 561  : 
; 562  :    for (i=0; i < num_rects; ++i) {

	mov	esi, 65535				; 0000ffffH
	test	edi, edi
	jle	SHORT $LN6@stbrp_pack

; 554  :       #ifndef STBRP_LARGE_RECTS
; 555  :       STBRP_ASSERT(rects[i].w <= 0xffff && rects[i].h <= 0xffff);
; 556  :       #endif
; 557  :    }
; 558  : 
; 559  :    // sort according to heuristic
; 560  :    STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_height_compare);

	lea	esi, DWORD PTR [ebx+4]
	mov	ebx, edi
	npad	6
$LL7@stbrp_pack:

; 563  :       if (rects[i].w == 0 || rects[i].h == 0) {

	movzx	ecx, WORD PTR [esi]
	test	cx, cx
	je	SHORT $LN13@stbrp_pack
	movzx	eax, WORD PTR [esi+2]
	test	ax, ax
	je	SHORT $LN13@stbrp_pack

; 565  :       } else {
; 566  :          stbrp__findresult fr = stbrp__skyline_pack_rectangle(context, rects[i].w, rects[i].h);

	push	eax
	push	ecx
	push	DWORD PTR _context$[ebp]
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?stbrp__skyline_pack_rectangle@@YA?AUstbrp__findresult@@PAUstbrp_context@@HH@Z ; stbrp__skyline_pack_rectangle
	add	esp, 16					; 00000010H

; 567  :          if (fr.prev_link) {

	cmp	DWORD PTR [eax+8], 0
	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR _fr$2[ebp], xmm0
	je	SHORT $LN14@stbrp_pack

; 568  :             rects[i].x = (stbrp_coord) fr.x;

	movzx	eax, WORD PTR _fr$2[ebp]
	mov	WORD PTR [esi+4], ax

; 569  :             rects[i].y = (stbrp_coord) fr.y;

	movzx	eax, WORD PTR _fr$2[ebp+4]
	mov	WORD PTR [esi+6], ax

; 570  :          } else {

	jmp	SHORT $LN5@stbrp_pack
$LN14@stbrp_pack:

; 571  :             rects[i].x = rects[i].y = STBRP__MAXVAL;

	mov	DWORD PTR [esi+4], -1
	jmp	SHORT $LN5@stbrp_pack
$LN13@stbrp_pack:

; 564  :          rects[i].x = rects[i].y = 0;  // empty rect needs no space

	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
$LN5@stbrp_pack:

; 561  : 
; 562  :    for (i=0; i < num_rects; ++i) {

	add	esi, 16					; 00000010H
	sub	ebx, 1
	jne	SHORT $LL7@stbrp_pack
	mov	ebx, DWORD PTR _rects$[ebp]
	mov	esi, 65535				; 0000ffffH
$LN6@stbrp_pack:

; 572  :          }
; 573  :       }
; 574  :    }
; 575  : 
; 576  :    // unsort
; 577  :    STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_original_order);

	push	OFFSET ?rect_original_order@@YAHPBX0@Z	; rect_original_order
	push	16					; 00000010H
	push	edi
	push	ebx
	call	DWORD PTR __imp__qsort
	add	esp, 16					; 00000010H

; 578  : 
; 579  :    // set was_packed flags
; 580  :    for (i=0; i < num_rects; ++i)

	test	edi, edi
	jle	SHORT $LN9@stbrp_pack

; 572  :          }
; 573  :       }
; 574  :    }
; 575  : 
; 576  :    // unsort
; 577  :    STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_original_order);

	lea	eax, DWORD PTR [ebx+10]
	npad	6
$LL25@stbrp_pack:

; 581  :       rects[i].was_packed = !(rects[i].x == STBRP__MAXVAL && rects[i].y == STBRP__MAXVAL);

	cmp	WORD PTR [eax-2], si
	jne	SHORT $LN26@stbrp_pack
	cmp	WORD PTR [eax], si
	jne	SHORT $LN26@stbrp_pack
	xor	ecx, ecx
	jmp	SHORT $LN27@stbrp_pack
$LN26@stbrp_pack:
	mov	ecx, 1
$LN27@stbrp_pack:
	mov	DWORD PTR [eax+2], ecx
	add	eax, 16					; 00000010H
	sub	edi, 1
	jne	SHORT $LL25@stbrp_pack
$LN9@stbrp_pack:
	pop	edi
	pop	esi
	pop	ebx

; 582  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_stbrp_pack_rects ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\malloc.h
;	COMDAT __MallocaComputeSize
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__MallocaComputeSize PROC				; COMDAT

; 101  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 102  :         size_t _MarkedSize = _Size + _ALLOCA_S_MARKER_SIZE;

	mov	eax, DWORD PTR __Size$[ebp]
	lea	ecx, DWORD PTR [eax+8]

; 103  :         return _MarkedSize > _Size ? _MarkedSize : 0;

	cmp	eax, ecx
	sbb	eax, eax
	and	eax, ecx

; 104  :     }

	pop	ebp
	ret	0
__MallocaComputeSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\malloc.h
;	COMDAT __MarkAllocaS
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Marker$ = 12						; size = 4
__MarkAllocaS PROC					; COMDAT

; 91   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 92   :         if (_Ptr)

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	eax, eax
	je	SHORT $LN2@MarkAlloca

; 93   :         {
; 94   :             *((unsigned int*)_Ptr) = _Marker;

	mov	ecx, DWORD PTR __Marker$[ebp]
	mov	DWORD PTR [eax], ecx

; 95   :             _Ptr = (char*)_Ptr + _ALLOCA_S_MARKER_SIZE;

	add	eax, 8
$LN2@MarkAlloca:

; 96   :         }
; 97   :         return _Ptr;
; 98   :     }

	pop	ebp
	ret	0
__MarkAllocaS ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??4ImGuiWindow@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4ImGuiWindow@@QAEAAU0@ABU0@@Z PROC			; ImGuiWindow::operator=, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___that$[ebp]
	mov	eax, ecx
	push	edi
	mov	ecx, 167				; 000000a7H
	mov	edi, eax
	rep movsd
	pop	edi
	pop	esi
	pop	ebp
	ret	4
??4ImGuiWindow@@QAEAAU0@ABU0@@Z ENDP			; ImGuiWindow::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?MenuBarRect@ImGuiWindow@@QBE?AUImRect@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?MenuBarRect@ImGuiWindow@@QBE?AUImRect@@XZ PROC		; ImGuiWindow::MenuBarRect, COMDAT
; _this$ = ecx

; 778  :     ImRect      MenuBarRect() const                     { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }

	npad	2
	push	ebp
	mov	ebp, esp

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	mov	edx, DWORD PTR [ecx+8]
	xorps	xmm2, xmm2
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	test	dl, 1
	je	SHORT $LN5@MenuBarRec
	xorps	xmm1, xmm1
	jmp	SHORT $LN6@MenuBarRec
$LN5@MenuBarRec:
	movss	xmm0, DWORD PTR [eax+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm1, DWORD PTR [eax+6176]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm0, xmm0

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm1, DWORD PTR [ecx+620]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm1, xmm0
$LN6@MenuBarRec:

; 778  :     ImRect      MenuBarRect() const                     { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }

	movss	xmm3, DWORD PTR [ecx+28]
	addss	xmm3, xmm1

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	test	edx, 1024				; 00000400H
	je	SHORT $LN11@MenuBarRec
	movss	xmm0, DWORD PTR [eax+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm2, DWORD PTR [eax+6176]

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	addss	xmm0, xmm0

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm2, DWORD PTR [ecx+620]

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	addss	xmm2, xmm0
$LN11@MenuBarRec:

; 778  :     ImRect      MenuBarRect() const                     { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }

	movss	xmm0, DWORD PTR [ecx+24]
	addss	xmm2, xmm3
	movss	xmm1, DWORD PTR [ecx+40]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 778  :     ImRect      MenuBarRect() const                     { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }

	addss	xmm1, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax], xmm0
	movss	DWORD PTR [eax+4], xmm3
	movss	DWORD PTR [eax+8], xmm1
	movss	DWORD PTR [eax+12], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 778  :     ImRect      MenuBarRect() const                     { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }

	pop	ebp
	ret	4
?MenuBarRect@ImGuiWindow@@QBE?AUImRect@@XZ ENDP		; ImGuiWindow::MenuBarRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?MenuBarHeight@ImGuiWindow@@QBEMXZ
_TEXT	SEGMENT
tv74 = -4						; size = 4
?MenuBarHeight@ImGuiWindow@@QBEMXZ PROC			; ImGuiWindow::MenuBarHeight, COMDAT
; _this$ = ecx

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	test	DWORD PTR [ecx+8], 1024			; 00000400H
	je	SHORT $LN3@MenuBarHei
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	movss	xmm1, DWORD PTR [eax+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm0, DWORD PTR [eax+6176]

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	addss	xmm1, xmm1

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm0, DWORD PTR [ecx+620]

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	addss	xmm0, xmm1
	movss	DWORD PTR tv74[ebp], xmm0
	fld	DWORD PTR tv74[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@MenuBarHei:
	mov	DWORD PTR tv74[ebp], 0
	fld	DWORD PTR tv74[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?MenuBarHeight@ImGuiWindow@@QBEMXZ ENDP			; ImGuiWindow::MenuBarHeight
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?TitleBarRect@ImGuiWindow@@QBE?AUImRect@@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
?TitleBarRect@ImGuiWindow@@QBE?AUImRect@@XZ PROC	; ImGuiWindow::TitleBarRect, COMDAT
; _this$ = ecx

; 776  :     ImRect      TitleBarRect() const                    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, ecx
	sub	esp, 8

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	test	BYTE PTR [edx+8], 1
	je	SHORT $LN5@TitleBarRe
	xorps	xmm1, xmm1
	jmp	SHORT $LN6@TitleBarRe
$LN5@TitleBarRe:
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	movss	xmm0, DWORD PTR [eax+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm1, DWORD PTR [eax+6176]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm0, xmm0

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm1, DWORD PTR [edx+620]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm1, xmm0
$LN6@TitleBarRe:

; 776  :     ImRect      TitleBarRect() const                    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }

	movss	xmm0, DWORD PTR [edx+40]
	addss	xmm0, DWORD PTR [edx+24]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [edx+24]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 776  :     ImRect      TitleBarRect() const                    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }

	movss	xmm0, DWORD PTR [edx+28]
	addss	xmm0, xmm1

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+28]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax+8], ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	ecx, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR [eax+12], ecx

; 776  :     ImRect      TitleBarRect() const                    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }

	mov	esp, ebp
	pop	ebp
	ret	4
?TitleBarRect@ImGuiWindow@@QBE?AUImRect@@XZ ENDP	; ImGuiWindow::TitleBarRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?TitleBarHeight@ImGuiWindow@@QBEMXZ
_TEXT	SEGMENT
tv74 = -4						; size = 4
?TitleBarHeight@ImGuiWindow@@QBEMXZ PROC		; ImGuiWindow::TitleBarHeight, COMDAT
; _this$ = ecx

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	test	BYTE PTR [ecx+8], 1
	je	SHORT $LN3@TitleBarHe
	mov	DWORD PTR tv74[ebp], 0
	fld	DWORD PTR tv74[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@TitleBarHe:
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	movss	xmm1, DWORD PTR [eax+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm0, DWORD PTR [eax+6176]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm1, xmm1

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm0, DWORD PTR [ecx+620]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm0, xmm1
	movss	DWORD PTR tv74[ebp], xmm0
	fld	DWORD PTR tv74[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?TitleBarHeight@ImGuiWindow@@QBEMXZ ENDP		; ImGuiWindow::TitleBarHeight
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?CalcFontSize@ImGuiWindow@@QBEMXZ
_TEXT	SEGMENT
?CalcFontSize@ImGuiWindow@@QBEMXZ PROC			; ImGuiWindow::CalcFontSize, COMDAT
; _this$ = ecx

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	fld	DWORD PTR [eax+6176]
	fmul	DWORD PTR [ecx+620]
	ret	0
?CalcFontSize@ImGuiWindow@@QBEMXZ ENDP			; ImGuiWindow::CalcFontSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?Rect@ImGuiWindow@@QBE?AUImRect@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?Rect@ImGuiWindow@@QBE?AUImRect@@XZ PROC		; ImGuiWindow::Rect, COMDAT
; _this$ = ecx

; 773  :     ImRect      Rect() const                            { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }

	npad	2
	push	ebp
	mov	ebp, esp
	movss	xmm3, DWORD PTR [ecx+28]
	movss	xmm0, DWORD PTR [ecx+24]
	movss	xmm2, DWORD PTR [ecx+32]
	movss	xmm1, DWORD PTR [ecx+36]
	addss	xmm2, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 773  :     ImRect      Rect() const                            { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }

	addss	xmm1, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax], xmm0
	movss	DWORD PTR [eax+4], xmm3
	movss	DWORD PTR [eax+8], xmm2
	movss	DWORD PTR [eax+12], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 773  :     ImRect      Rect() const                            { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }

	pop	ebp
	ret	4
?Rect@ImGuiWindow@@QBE?AUImRect@@XZ ENDP		; ImGuiWindow::Rect
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??4ImGuiDrawContext@@QAEAAU0@$$QAU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4ImGuiDrawContext@@QAEAAU0@$$QAU0@@Z PROC		; ImGuiDrawContext::operator=, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], eax
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+24], eax
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+28], eax
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+32], eax
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+36], eax
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx+40], eax
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [ecx+44], eax
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR [ecx+48], eax
	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR [ecx+52], eax
	mov	eax, DWORD PTR [edx+56]
	mov	DWORD PTR [ecx+56], eax
	movups	xmm0, XMMWORD PTR [edx+60]
	movups	XMMWORD PTR [ecx+60], xmm0
	movzx	eax, BYTE PTR [edx+76]
	mov	BYTE PTR [ecx+76], al
	movzx	eax, BYTE PTR [edx+77]
	mov	BYTE PTR [ecx+77], al
	movzx	eax, BYTE PTR [edx+78]
	mov	BYTE PTR [ecx+78], al
	mov	eax, DWORD PTR [edx+80]
	mov	DWORD PTR [ecx+80], eax
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR [ecx+84], eax
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR [ecx+88], eax
	movzx	eax, BYTE PTR [edx+92]
	mov	BYTE PTR [ecx+92], al
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR [ecx+96], eax
	movq	xmm0, QWORD PTR [edx+100]
	movq	QWORD PTR [ecx+100], xmm0
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR [ecx+108], eax
	mov	eax, DWORD PTR [edx+112]
	mov	DWORD PTR [ecx+112], eax
	mov	eax, DWORD PTR [edx+116]
	mov	DWORD PTR [ecx+116], eax
	mov	eax, DWORD PTR [edx+120]
	mov	DWORD PTR [ecx+120], eax
	mov	eax, DWORD PTR [edx+124]
	mov	DWORD PTR [ecx+124], eax
	mov	eax, DWORD PTR [edx+128]
	mov	DWORD PTR [ecx+128], eax
	movq	xmm0, QWORD PTR [edx+132]
	movq	QWORD PTR [ecx+132], xmm0
	mov	eax, DWORD PTR [edx+140]
	mov	DWORD PTR [ecx+140], eax
	movq	xmm0, QWORD PTR [edx+144]
	movq	QWORD PTR [ecx+144], xmm0
	mov	eax, DWORD PTR [edx+152]
	mov	DWORD PTR [ecx+152], eax
	movq	xmm0, QWORD PTR [edx+156]
	movq	QWORD PTR [ecx+156], xmm0
	mov	eax, DWORD PTR [edx+164]
	mov	DWORD PTR [ecx+164], eax
	movq	xmm0, QWORD PTR [edx+168]
	movq	QWORD PTR [ecx+168], xmm0
	mov	eax, DWORD PTR [edx+176]
	mov	DWORD PTR [ecx+176], eax
	mov	eax, DWORD PTR [edx+180]
	mov	DWORD PTR [ecx+180], eax
	mov	eax, DWORD PTR [edx+184]
	mov	DWORD PTR [ecx+184], eax
	mov	eax, DWORD PTR [edx+188]
	mov	DWORD PTR [ecx+188], eax
	mov	eax, DWORD PTR [edx+192]
	mov	DWORD PTR [ecx+192], eax
	mov	eax, DWORD PTR [edx+196]
	mov	DWORD PTR [ecx+196], eax
	mov	eax, DWORD PTR [edx+200]
	mov	DWORD PTR [ecx+200], eax
	mov	eax, DWORD PTR [edx+204]
	mov	DWORD PTR [ecx+204], eax
	mov	eax, DWORD PTR [edx+208]
	mov	DWORD PTR [ecx+208], eax
	mov	eax, DWORD PTR [edx+212]
	mov	DWORD PTR [ecx+212], eax
	mov	eax, DWORD PTR [edx+216]
	mov	DWORD PTR [ecx+216], eax
	mov	eax, DWORD PTR [edx+220]
	mov	DWORD PTR [ecx+220], eax
	mov	eax, DWORD PTR [edx+224]
	mov	DWORD PTR [ecx+224], eax
	mov	eax, DWORD PTR [edx+228]
	mov	DWORD PTR [ecx+228], eax
	mov	eax, DWORD PTR [edx+232]
	mov	DWORD PTR [ecx+232], eax
	mov	eax, DWORD PTR [edx+236]
	mov	DWORD PTR [ecx+236], eax
	mov	eax, DWORD PTR [edx+240]
	mov	DWORD PTR [ecx+240], eax
	mov	eax, DWORD PTR [edx+244]
	mov	DWORD PTR [ecx+244], eax
	movzx	eax, BYTE PTR [edx+248]
	mov	BYTE PTR [ecx+248], al
	mov	eax, DWORD PTR [edx+252]
	mov	DWORD PTR [ecx+252], eax
	movq	xmm0, QWORD PTR [edx+256]
	movq	QWORD PTR [ecx+256], xmm0
	mov	eax, DWORD PTR [edx+264]
	mov	DWORD PTR [ecx+264], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??4ImGuiDrawContext@@QAEAAU0@$$QAU0@@Z ENDP		; ImGuiDrawContext::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??4ImGuiDrawContext@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4ImGuiDrawContext@@QAEAAU0@ABU0@@Z PROC		; ImGuiDrawContext::operator=, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___that$[ebp]
	mov	eax, ecx
	push	edi
	mov	ecx, 67					; 00000043H
	mov	edi, eax
	rep movsd
	pop	edi
	pop	esi
	pop	ebp
	ret	4
??4ImGuiDrawContext@@QAEAAU0@ABU0@@Z ENDP		; ImGuiDrawContext::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1ImGuiDrawContext@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1ImGuiDrawContext@@QAE@XZ PROC			; ImGuiDrawContext::~ImGuiDrawContext, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1ImGuiDrawContext@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	mov	eax, DWORD PTR [esi+264]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN4@ImGuiDrawC
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN4@ImGuiDrawC:
	mov	eax, DWORD PTR [esi+176]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	eax, eax
	je	SHORT $LN8@ImGuiDrawC
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN8@ImGuiDrawC:
	mov	eax, DWORD PTR [esi+164]
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	test	eax, eax
	je	SHORT $LN12@ImGuiDrawC
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN12@ImGuiDrawC:
	mov	eax, DWORD PTR [esi+152]
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	test	eax, eax
	je	SHORT $LN16@ImGuiDrawC
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN16@ImGuiDrawC:
	mov	eax, DWORD PTR [esi+140]
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	test	eax, eax
	je	SHORT $LN20@ImGuiDrawC
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN20@ImGuiDrawC:
	mov	eax, DWORD PTR [esi+108]
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	test	eax, eax
	je	SHORT $LN24@ImGuiDrawC
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN24@ImGuiDrawC:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1ImGuiDrawContext@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1ImGuiDrawContext@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1ImGuiDrawContext@@QAE@XZ ENDP			; ImGuiDrawContext::~ImGuiDrawContext
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ??0ImGuiDrawContext@@QAE@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 8
_this$ = -4						; size = 4
??0ImGuiDrawContext@@QAE@XZ PROC			; ImGuiDrawContext::ImGuiDrawContext, COMDAT
; _this$ = ecx

; 662  :     ImGuiDrawContext()

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	edx, ecx
	xorps	xmm0, xmm0
	mov	DWORD PTR _this$[ebp], edx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 664  :         CursorPos = CursorPosPrevLine = CursorStartPos = CursorMaxPos = ImVec2(0.0f, 0.0f);

	mov	ecx, DWORD PTR $T1[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 97   :     ImVec2() { x = y = 0.0f; }

	mov	DWORD PTR [edx+4], 0
	mov	DWORD PTR [edx], 0
	mov	DWORD PTR [edx+12], 0
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR [edx+20], 0
	mov	DWORD PTR [edx+16], 0
	mov	DWORD PTR [edx+28], 0
	mov	DWORD PTR [edx+24], 0

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR [edx+60], 2139095039		; 7f7fffffH
	mov	DWORD PTR [edx+64], 2139095039		; 7f7fffffH
	mov	DWORD PTR [edx+68], -8388609		; ff7fffffH
	mov	DWORD PTR [edx+72], -8388609		; ff7fffffH

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [edx+104], 0
	mov	DWORD PTR [edx+100], 0
	mov	DWORD PTR [edx+108], 0
	mov	DWORD PTR [edx+136], 0
	mov	DWORD PTR [edx+132], 0
	mov	DWORD PTR [edx+140], 0
	mov	DWORD PTR [edx+148], 0
	mov	DWORD PTR [edx+144], 0
	mov	DWORD PTR [edx+152], 0
	mov	DWORD PTR [edx+160], 0
	mov	DWORD PTR [edx+156], 0
	mov	DWORD PTR [edx+164], 0
	mov	DWORD PTR [edx+172], 0
	mov	DWORD PTR [edx+168], 0
	mov	DWORD PTR [edx+176], 0
	mov	DWORD PTR [edx+260], 0
	mov	DWORD PTR [edx+256], 0
	mov	DWORD PTR [edx+264], 0

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp+4], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 664  :         CursorPos = CursorPosPrevLine = CursorStartPos = CursorMaxPos = ImVec2(0.0f, 0.0f);

	mov	eax, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR [edx+28], eax
	mov	DWORD PTR [edx+20], eax
	mov	DWORD PTR [edx+12], eax
	mov	DWORD PTR [edx+4], eax

; 665  :         CurrentLineHeight = PrevLineHeight = 0.0f;
; 666  :         CurrentLineTextBaseOffset = PrevLineTextBaseOffset = 0.0f;
; 667  :         LogLinePosY = -1.0f;
; 668  :         TreeDepth = 0;
; 669  :         LastItemId = 0;
; 670  :         LastItemRect = ImRect(0.0f,0.0f,0.0f,0.0f);
; 671  :         LastItemHoveredAndUsable = LastItemHoveredRect = false;
; 672  :         NavHasScroll = false;
; 673  :         NavLayerActiveFlags = NavLayerActiveFlagsNext = 0x00;
; 674  :         NavLayerCurrent = 0;
; 675  :         MenuBarAppending = false;
; 676  :         MenuBarOffsetX = 0.0f;
; 677  :         StateStorage = NULL;
; 678  :         LayoutType = ImGuiLayoutType_Vertical;
; 679  :         ItemWidth = 0.0f;
; 680  :         ItemFlags = ImGuiItemFlags_Default_;
; 681  :         TextWrapPos = -1.0f;
; 682  :         ColorEditMode = ImGuiColorEditMode_RGB;
; 683  :         memset(StackSizesBackup, 0, sizeof(StackSizesBackup));
; 684  : 
; 685  :         IndentX = 0.0f;
; 686  :         GroupOffsetX = 0.0f;
; 687  :         ColumnsOffsetX = 0.0f;
; 688  :         ColumnsCurrent = 0;
; 689  :         ColumnsCount = 1;
; 690  :         ColumnsMinX = ColumnsMaxX = 0.0f;
; 691  :         ColumnsStartPosY = 0.0f;
; 692  :         ColumnsCellMinY = ColumnsCellMaxY = 0.0f;
; 693  :         ColumnsShowBorders = true;
; 694  :         ColumnsSetId = 0;
; 695  :     }

	mov	eax, edx
	mov	DWORD PTR [edx+24], ecx
	mov	DWORD PTR [edx+16], ecx
	mov	DWORD PTR [edx+8], ecx
	mov	DWORD PTR [edx], ecx
	mov	DWORD PTR [edx+40], 0
	mov	DWORD PTR [edx+32], 0
	mov	DWORD PTR [edx+44], 0
	mov	DWORD PTR [edx+36], 0
	mov	DWORD PTR [edx+48], -1082130432		; bf800000H
	mov	DWORD PTR [edx+52], 0
	mov	DWORD PTR [edx+56], 0
	movups	XMMWORD PTR [edx+60], xmm0
	mov	WORD PTR [edx+76], 0
	mov	BYTE PTR [edx+78], 0
	mov	DWORD PTR [edx+88], 0
	mov	DWORD PTR [edx+84], 0
	mov	DWORD PTR [edx+80], 0
	mov	BYTE PTR [edx+92], 0
	mov	DWORD PTR [edx+96], 0
	mov	DWORD PTR [edx+112], 0
	mov	DWORD PTR [edx+116], 0
	mov	DWORD PTR [edx+124], 0
	mov	DWORD PTR [edx+120], 3
	mov	DWORD PTR [edx+128], -1082130432	; bf800000H
	mov	DWORD PTR [edx+180], 0
	movups	XMMWORD PTR [edx+184], xmm0
	movq	QWORD PTR [edx+200], xmm0
	mov	DWORD PTR [edx+208], 0
	mov	DWORD PTR [edx+212], 0
	mov	DWORD PTR [edx+216], 0
	mov	DWORD PTR [edx+220], 0
	mov	DWORD PTR [edx+224], 1
	mov	DWORD PTR [edx+232], 0
	mov	DWORD PTR [edx+228], 0
	mov	DWORD PTR [edx+236], 0
	mov	DWORD PTR [edx+244], 0
	mov	DWORD PTR [edx+240], 0
	mov	BYTE PTR [edx+248], 1
	mov	DWORD PTR [edx+252], 0
	mov	esp, ebp
	pop	ebp
	ret	0
??0ImGuiDrawContext@@QAE@XZ ENDP			; ImGuiDrawContext::ImGuiDrawContext
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImGuiColumnData@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@UImGuiColumnData@@@@QAE@XZ PROC		; ImVector<ImGuiColumnData>::~ImVector<ImGuiColumnData>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@UImGuiColumnData@@@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@UImGuiColumnData@@@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@UImGuiColumnData@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@UImGuiColumnData@@@@QAE@XZ ENDP		; ImVector<ImGuiColumnData>::~ImVector<ImGuiColumnData>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImGuiColumnData@@@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@UImGuiColumnData@@@@QAE@XZ PROC		; ImVector<ImGuiColumnData>::ImVector<ImGuiColumnData>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@UImGuiColumnData@@@@QAE@XZ ENDP		; ImVector<ImGuiColumnData>::ImVector<ImGuiColumnData>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImGuiGroupData@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@UImGuiGroupData@@@@QAE@XZ PROC		; ImVector<ImGuiGroupData>::~ImVector<ImGuiGroupData>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@UImGuiGroupData@@@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@UImGuiGroupData@@@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@UImGuiGroupData@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@UImGuiGroupData@@@@QAE@XZ ENDP		; ImVector<ImGuiGroupData>::~ImVector<ImGuiGroupData>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImGuiGroupData@@@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@UImGuiGroupData@@@@QAE@XZ PROC		; ImVector<ImGuiGroupData>::ImVector<ImGuiGroupData>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@UImGuiGroupData@@@@QAE@XZ ENDP		; ImVector<ImGuiGroupData>::ImVector<ImGuiGroupData>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@H@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@H@@QAE@XZ PROC				; ImVector<int>::~ImVector<int>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@H@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@H@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@H@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@H@@QAE@XZ ENDP				; ImVector<int>::~ImVector<int>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@H@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@H@@QAE@XZ PROC				; ImVector<int>::ImVector<int>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@H@@QAE@XZ ENDP				; ImVector<int>::ImVector<int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@PAUImGuiWindow@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@PAUImGuiWindow@@@@QAE@XZ PROC		; ImVector<ImGuiWindow *>::~ImVector<ImGuiWindow *>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@PAUImGuiWindow@@@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@PAUImGuiWindow@@@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@PAUImGuiWindow@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@PAUImGuiWindow@@@@QAE@XZ ENDP		; ImVector<ImGuiWindow *>::~ImVector<ImGuiWindow *>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@PAUImGuiWindow@@@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@PAUImGuiWindow@@@@QAE@XZ PROC		; ImVector<ImGuiWindow *>::ImVector<ImGuiWindow *>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@PAUImGuiWindow@@@@QAE@XZ ENDP		; ImVector<ImGuiWindow *>::ImVector<ImGuiWindow *>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??4ImGuiTextEditState@@QAEAAU0@$$QAU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4ImGuiTextEditState@@QAEAAU0@$$QAU0@@Z PROC		; ImGuiTextEditState::operator=, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR ___that$[ebp]
	push	ebx
	mov	ebx, ecx
	mov	ecx, 805				; 00000325H
	push	esi
	mov	eax, DWORD PTR [edx]
	lea	esi, DWORD PTR [edx+56]
	push	edi
	mov	DWORD PTR [ebx], eax
	lea	edi, DWORD PTR [ebx+56]
	movq	xmm0, QWORD PTR [edx+4]
	movq	QWORD PTR [ebx+4], xmm0
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ebx+12], eax
	movq	xmm0, QWORD PTR [edx+16]
	movq	QWORD PTR [ebx+16], xmm0
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ebx+24], eax
	movq	xmm0, QWORD PTR [edx+28]
	movq	QWORD PTR [ebx+28], xmm0
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ebx+36], eax
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ebx+40], eax
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [ebx+44], eax
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR [ebx+48], eax
	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR [ebx+52], eax
	rep movsd
	mov	eax, DWORD PTR [edx+3276]
	mov	DWORD PTR [ebx+3276], eax
	movzx	eax, BYTE PTR [edx+3280]
	mov	BYTE PTR [ebx+3280], al
	movzx	eax, BYTE PTR [edx+3281]
	pop	edi
	mov	BYTE PTR [ebx+3281], al
	mov	eax, ebx
	pop	esi
	pop	ebx
	pop	ebp
	ret	4
??4ImGuiTextEditState@@QAEAAU0@$$QAU0@@Z ENDP		; ImGuiTextEditState::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??4ImGuiTextEditState@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4ImGuiTextEditState@@QAEAAU0@ABU0@@Z PROC		; ImGuiTextEditState::operator=, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___that$[ebp]
	mov	eax, ecx
	push	edi
	mov	ecx, 821				; 00000335H
	mov	edi, eax
	rep movsd
	pop	edi
	pop	esi
	pop	ebp
	ret	4
??4ImGuiTextEditState@@QAEAAU0@ABU0@@Z ENDP		; ImGuiTextEditState::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1ImGuiTextEditState@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1ImGuiTextEditState@@QAE@XZ PROC			; ImGuiTextEditState::~ImGuiTextEditState, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1ImGuiTextEditState@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN4@ImGuiTextE
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN4@ImGuiTextE:
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	eax, eax
	je	SHORT $LN8@ImGuiTextE
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN8@ImGuiTextE:
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	test	eax, eax
	je	SHORT $LN12@ImGuiTextE
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN12@ImGuiTextE:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1ImGuiTextEditState@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1ImGuiTextEditState@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1ImGuiTextEditState@@QAE@XZ ENDP			; ImGuiTextEditState::~ImGuiTextEditState
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?SelectAll@ImGuiTextEditState@@QAEXXZ
_TEXT	SEGMENT
?SelectAll@ImGuiTextEditState@@QAEXXZ PROC		; ImGuiTextEditState::SelectAll, COMDAT
; _this$ = ecx

; 346  :     void                SelectAll()                 { StbState.select_start = 0; StbState.select_end = CurLenW; StbState.cursor = StbState.select_end; StbState.has_preferred_x = false; }

	mov	eax, DWORD PTR [ecx+44]
	mov	DWORD PTR [ecx+60], 0
	mov	DWORD PTR [ecx+64], eax
	mov	DWORD PTR [ecx+56], eax
	mov	BYTE PTR [ecx+71], 0
	ret	0
?SelectAll@ImGuiTextEditState@@QAEXXZ ENDP		; ImGuiTextEditState::SelectAll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?ClearSelection@ImGuiTextEditState@@QAEXXZ
_TEXT	SEGMENT
?ClearSelection@ImGuiTextEditState@@QAEXXZ PROC		; ImGuiTextEditState::ClearSelection, COMDAT
; _this$ = ecx

; 345  :     void                ClearSelection()            { StbState.select_start = StbState.select_end = StbState.cursor; }

	mov	eax, DWORD PTR [ecx+56]
	mov	DWORD PTR [ecx+64], eax
	mov	DWORD PTR [ecx+60], eax
	ret	0
?ClearSelection@ImGuiTextEditState@@QAEXXZ ENDP		; ImGuiTextEditState::ClearSelection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?HasSelection@ImGuiTextEditState@@QBE_NXZ
_TEXT	SEGMENT
?HasSelection@ImGuiTextEditState@@QBE_NXZ PROC		; ImGuiTextEditState::HasSelection, COMDAT
; _this$ = ecx

; 344  :     bool                HasSelection() const        { return StbState.select_start != StbState.select_end; }

	mov	eax, DWORD PTR [ecx+60]
	cmp	eax, DWORD PTR [ecx+64]
	setne	al
	ret	0
?HasSelection@ImGuiTextEditState@@QBE_NXZ ENDP		; ImGuiTextEditState::HasSelection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?CursorClamp@ImGuiTextEditState@@QAEXXZ
_TEXT	SEGMENT
?CursorClamp@ImGuiTextEditState@@QAEXXZ PROC		; ImGuiTextEditState::CursorClamp, COMDAT
; _this$ = ecx

; 343  :     void                CursorClamp()               { StbState.cursor = ImMin(StbState.cursor, CurLenW); StbState.select_start = ImMin(StbState.select_start, CurLenW); StbState.select_end = ImMin(StbState.select_end, CurLenW); }

	npad	2
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+44]

; 125  : static inline int    ImMin(int lhs, int rhs)                                    { return lhs < rhs ? lhs : rhs; }

	mov	edx, esi
	cmp	DWORD PTR [edi+56], esi
	mov	ecx, esi
	cmovl	edx, DWORD PTR [edi+56]
	cmp	DWORD PTR [edi+60], esi

; 343  :     void                CursorClamp()               { StbState.cursor = ImMin(StbState.cursor, CurLenW); StbState.select_start = ImMin(StbState.select_start, CurLenW); StbState.select_end = ImMin(StbState.select_end, CurLenW); }

	mov	DWORD PTR [edi+56], edx

; 125  : static inline int    ImMin(int lhs, int rhs)                                    { return lhs < rhs ? lhs : rhs; }

	cmovl	ecx, DWORD PTR [edi+60]
	cmp	DWORD PTR [edi+64], esi

; 343  :     void                CursorClamp()               { StbState.cursor = ImMin(StbState.cursor, CurLenW); StbState.select_start = ImMin(StbState.select_start, CurLenW); StbState.select_end = ImMin(StbState.select_end, CurLenW); }

	mov	DWORD PTR [edi+60], ecx

; 125  : static inline int    ImMin(int lhs, int rhs)                                    { return lhs < rhs ? lhs : rhs; }

	cmovl	esi, DWORD PTR [edi+64]

; 343  :     void                CursorClamp()               { StbState.cursor = ImMin(StbState.cursor, CurLenW); StbState.select_start = ImMin(StbState.select_start, CurLenW); StbState.select_end = ImMin(StbState.select_end, CurLenW); }

	mov	DWORD PTR [edi+64], esi
	pop	edi
	pop	esi
	ret	0
?CursorClamp@ImGuiTextEditState@@QAEXXZ ENDP		; ImGuiTextEditState::CursorClamp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?CursorAnimReset@ImGuiTextEditState@@QAEXXZ
_TEXT	SEGMENT
?CursorAnimReset@ImGuiTextEditState@@QAEXXZ PROC	; ImGuiTextEditState::CursorAnimReset, COMDAT
; _this$ = ecx

; 342  :     void                CursorAnimReset()           { CursorAnim = -0.30f; }                                   // After a user-input the cursor stays on for a while without blinking

	mov	DWORD PTR [ecx+3276], -1097229926	; be99999aH
	ret	0
?CursorAnimReset@ImGuiTextEditState@@QAEXXZ ENDP	; ImGuiTextEditState::CursorAnimReset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ??0ImGuiTextEditState@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ImGuiTextEditState@@QAE@XZ PROC			; ImGuiTextEditState::ImGuiTextEditState, COMDAT
; _this$ = ecx

; 341  :     ImGuiTextEditState()                            { memset(this, 0, sizeof(*this)); }

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	3284					; 00000cd4H
	push	0
	push	esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+24], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 341  :     ImGuiTextEditState()                            { memset(this, 0, sizeof(*this)); }

	mov	DWORD PTR _this$[ebp], esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+36], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 341  :     ImGuiTextEditState()                            { memset(this, 0, sizeof(*this)); }

	call	_memset
	add	esp, 12					; 0000000cH
	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??0ImGuiTextEditState@@QAE@XZ ENDP			; ImGuiTextEditState::ImGuiTextEditState
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??4ImGuiSimpleColumns@@QAEAAU0@$$QAU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4ImGuiSimpleColumns@@QAEAAU0@$$QAU0@@Z PROC		; ImGuiSimpleColumns::operator=, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], eax
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+24], eax
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+28], eax
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+32], eax
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+36], eax
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx+40], eax
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [ecx+44], eax
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR [ecx+48], eax
	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR [ecx+52], eax
	mov	eax, DWORD PTR [edx+56]
	mov	DWORD PTR [ecx+56], eax
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR [ecx+60], eax
	mov	eax, DWORD PTR [edx+64]
	mov	DWORD PTR [ecx+64], eax
	mov	eax, DWORD PTR [edx+68]
	mov	DWORD PTR [ecx+68], eax
	mov	eax, DWORD PTR [edx+72]
	mov	DWORD PTR [ecx+72], eax
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR [ecx+76], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??4ImGuiSimpleColumns@@QAEAAU0@$$QAU0@@Z ENDP		; ImGuiSimpleColumns::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??4ImGuiSimpleColumns@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4ImGuiSimpleColumns@@QAEAAU0@ABU0@@Z PROC		; ImGuiSimpleColumns::operator=, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ___that$[ebp]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movups	xmm0, XMMWORD PTR [eax+16]
	movups	XMMWORD PTR [ecx+16], xmm0
	movups	xmm0, XMMWORD PTR [eax+32]
	movups	XMMWORD PTR [ecx+32], xmm0
	movups	xmm0, XMMWORD PTR [eax+48]
	movups	XMMWORD PTR [ecx+48], xmm0
	movups	xmm0, XMMWORD PTR [eax+64]
	mov	eax, ecx
	movups	XMMWORD PTR [ecx+64], xmm0
	pop	ebp
	ret	4
??4ImGuiSimpleColumns@@QAEAAU0@ABU0@@Z ENDP		; ImGuiSimpleColumns::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??4ImRect@@QAEAAU0@$$QAU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4ImRect@@QAEAAU0@$$QAU0@@Z PROC			; ImRect::operator=, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??4ImRect@@QAEAAU0@$$QAU0@@Z ENDP			; ImRect::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??4ImRect@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4ImRect@@QAEAAU0@ABU0@@Z PROC				; ImRect::operator=, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ___that$[ebp]
	movups	xmm0, XMMWORD PTR [eax]
	mov	eax, ecx
	movups	XMMWORD PTR [ecx], xmm0
	pop	ebp
	ret	4
??4ImRect@@QAEAAU0@ABU0@@Z ENDP				; ImRect::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?GetClosestPoint@ImRect@@QBE?AUImVec2@@U2@_N@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_p$ = 12						; size = 8
_on_edge$ = 20						; size = 1
?GetClosestPoint@ImRect@@QBE?AUImVec2@@U2@_N@Z PROC	; ImRect::GetClosestPoint, COMDAT
; _this$ = ecx

; 263  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 264  :         if (!on_edge && Contains(p))

	cmp	BYTE PTR _on_edge$[ebp], 0
	movss	xmm2, DWORD PTR _p$[ebp+4]
	movss	xmm1, DWORD PTR _p$[ebp]
	jne	SHORT $LN2@GetClosest

; 252  :     bool        Contains(const ImVec2& p) const { return p.x >= Min.x     && p.y >= Min.y     && p.x < Max.x     && p.y < Max.y; }

	comiss	xmm1, DWORD PTR [ecx]
	jb	SHORT $LN2@GetClosest
	comiss	xmm2, DWORD PTR [ecx+4]
	jb	SHORT $LN2@GetClosest
	movss	xmm0, DWORD PTR [ecx+8]
	comiss	xmm0, xmm1
	jbe	SHORT $LN2@GetClosest
	movss	xmm0, DWORD PTR [ecx+12]
	comiss	xmm0, xmm2
	ja	SHORT $LN8@GetClosest
$LN2@GetClosest:

; 265  :             return p;
; 266  :         if (p.x > Max.x) p.x = Max.x;

	movss	xmm0, DWORD PTR [ecx+8]
	comiss	xmm1, xmm0
	ja	SHORT $LN15@GetClosest

; 267  :         else if (p.x < Min.x) p.x = Min.x;

	movss	xmm0, DWORD PTR [ecx]
	comiss	xmm0, xmm1
	jbe	SHORT $LN5@GetClosest
$LN15@GetClosest:
	movss	DWORD PTR _p$[ebp], xmm0
$LN5@GetClosest:

; 268  :         if (p.y > Max.y) p.y = Max.y;

	movss	xmm0, DWORD PTR [ecx+12]
	comiss	xmm2, xmm0
	ja	SHORT $LN16@GetClosest

; 269  :         else if (p.y < Min.y) p.y = Min.y;

	movss	xmm0, DWORD PTR [ecx+4]
	comiss	xmm0, xmm2
	jbe	SHORT $LN8@GetClosest
$LN16@GetClosest:
	movss	DWORD PTR _p$[ebp+4], xmm0
$LN8@GetClosest:

; 270  :         return p;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _p$[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 271  :     }

	pop	ebp
	ret	16					; 00000010H
?GetClosestPoint@ImRect@@QBE?AUImVec2@@U2@_N@Z ENDP	; ImRect::GetClosestPoint
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?Floor@ImRect@@QAEXXZ
_TEXT	SEGMENT
?Floor@ImRect@@QAEXXZ PROC				; ImRect::Floor, COMDAT
; _this$ = ecx

; 261  :     void        Floor()                         { Min.x = (float)(int)Min.x; Min.y = (float)(int)Min.y; Max.x = (float)(int)Max.x; Max.y = (float)(int)Max.y; }

	cvttss2si eax, DWORD PTR [ecx]
	movd	xmm0, eax
	cvttss2si eax, DWORD PTR [ecx+4]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [ecx], xmm0
	movd	xmm0, eax
	cvttss2si eax, DWORD PTR [ecx+8]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [ecx+4], xmm0
	movd	xmm0, eax
	cvttss2si eax, DWORD PTR [ecx+12]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [ecx+8], xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [ecx+12], xmm0
	ret	0
?Floor@ImRect@@QAEXXZ ENDP				; ImRect::Floor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?Clip@ImRect@@QBEXAAU1@@Z
_TEXT	SEGMENT
_r$ = 8							; size = 4
?Clip@ImRect@@QBEXAAU1@@Z PROC				; ImRect::Clip, COMDAT
; _this$ = ecx

; 260  :     void        Clip(ImRect& r) const           { r.Min.x = ImClamp(r.Min.x, Min.x, Max.x); r.Min.y = ImClamp(r.Min.y, Min.y, Max.y); r.Max.x = ImClamp(r.Max.x, Min.x, Max.x); r.Max.y = ImClamp(r.Max.y, Min.y, Max.y); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _r$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	movss	xmm1, DWORD PTR [eax]

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm0, xmm1
	ja	SHORT $LN8@Clip
	movss	xmm0, DWORD PTR [ecx+8]
	minss	xmm0, xmm1
$LN8@Clip:

; 260  :     void        Clip(ImRect& r) const           { r.Min.x = ImClamp(r.Min.x, Min.x, Max.x); r.Min.y = ImClamp(r.Min.y, Min.y, Max.y); r.Max.x = ImClamp(r.Max.x, Min.x, Max.x); r.Max.y = ImClamp(r.Max.y, Min.y, Max.y); }

	movss	xmm1, DWORD PTR [eax+4]
	movss	DWORD PTR [eax], xmm0
	movss	xmm0, DWORD PTR [ecx+4]

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm0, xmm1
	ja	SHORT $LN14@Clip
	movss	xmm0, DWORD PTR [ecx+12]
	minss	xmm0, xmm1
$LN14@Clip:

; 260  :     void        Clip(ImRect& r) const           { r.Min.x = ImClamp(r.Min.x, Min.x, Max.x); r.Min.y = ImClamp(r.Min.y, Min.y, Max.y); r.Max.x = ImClamp(r.Max.x, Min.x, Max.x); r.Max.y = ImClamp(r.Max.y, Min.y, Max.y); }

	movss	xmm1, DWORD PTR [eax+8]
	movss	DWORD PTR [eax+4], xmm0
	movss	xmm0, DWORD PTR [ecx]

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm0, xmm1
	ja	SHORT $LN20@Clip
	movss	xmm0, DWORD PTR [ecx+8]
	minss	xmm0, xmm1
$LN20@Clip:

; 260  :     void        Clip(ImRect& r) const           { r.Min.x = ImClamp(r.Min.x, Min.x, Max.x); r.Min.y = ImClamp(r.Min.y, Min.y, Max.y); r.Max.x = ImClamp(r.Max.x, Min.x, Max.x); r.Max.y = ImClamp(r.Max.y, Min.y, Max.y); }

	movss	xmm1, DWORD PTR [eax+12]
	movss	DWORD PTR [eax+8], xmm0
	movss	xmm0, DWORD PTR [ecx+4]

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm0, xmm1
	ja	SHORT $LN27@Clip
	movss	xmm0, DWORD PTR [ecx+12]
	minss	xmm0, xmm1
$LN27@Clip:

; 260  :     void        Clip(ImRect& r) const           { r.Min.x = ImClamp(r.Min.x, Min.x, Max.x); r.Min.y = ImClamp(r.Min.y, Min.y, Max.y); r.Max.x = ImClamp(r.Max.x, Min.x, Max.x); r.Max.y = ImClamp(r.Max.y, Min.y, Max.y); }

	movss	DWORD PTR [eax+12], xmm0
	pop	ebp
	ret	4
?Clip@ImRect@@QBEXAAU1@@Z ENDP				; ImRect::Clip
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?Translate@ImRect@@QAEXABUImVec2@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?Translate@ImRect@@QAEXABUImVec2@@@Z PROC		; ImRect::Translate, COMDAT
; _this$ = ecx

; 259  :     void        Translate(const ImVec2& v)      { Min.x += v.x; Min.y += v.y; Max.x += v.x; Max.y += v.y; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR [ecx+4]
	addss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [ecx+4], xmm0
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR [ecx+8]
	movss	DWORD PTR [ecx+8], xmm0
	movss	xmm0, DWORD PTR [eax+4]
	addss	xmm0, DWORD PTR [ecx+12]
	movss	DWORD PTR [ecx+12], xmm0
	pop	ebp
	ret	4
?Translate@ImRect@@QAEXABUImVec2@@@Z ENDP		; ImRect::Translate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?Expand@ImRect@@QAEXABUImVec2@@@Z
_TEXT	SEGMENT
_amount$ = 8						; size = 4
?Expand@ImRect@@QAEXABUImVec2@@@Z PROC			; ImRect::Expand, COMDAT
; _this$ = ecx

; 258  :     void        Expand(const ImVec2& amount)    { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _amount$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	subss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR [ecx+4]
	subss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [ecx+4], xmm0
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR [ecx+8]
	movss	DWORD PTR [ecx+8], xmm0
	movss	xmm0, DWORD PTR [eax+4]
	addss	xmm0, DWORD PTR [ecx+12]
	movss	DWORD PTR [ecx+12], xmm0
	pop	ebp
	ret	4
?Expand@ImRect@@QAEXABUImVec2@@@Z ENDP			; ImRect::Expand
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?Expand@ImRect@@QAEXM@Z
_TEXT	SEGMENT
_amount$ = 8						; size = 4
?Expand@ImRect@@QAEXM@Z PROC				; ImRect::Expand, COMDAT
; _this$ = ecx

; 257  :     void        Expand(const float amount)      { Min.x -= amount;   Min.y -= amount;   Max.x += amount;   Max.y += amount; }

	npad	2
	push	ebp
	mov	ebp, esp
	movss	xmm1, DWORD PTR _amount$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	subss	xmm0, xmm1
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR [ecx+4]
	subss	xmm0, xmm1
	movss	DWORD PTR [ecx+4], xmm0
	movss	xmm0, DWORD PTR [ecx+8]
	addss	xmm0, xmm1
	movss	DWORD PTR [ecx+8], xmm0
	movss	xmm0, DWORD PTR [ecx+12]
	addss	xmm0, xmm1
	movss	DWORD PTR [ecx+12], xmm0
	pop	ebp
	ret	4
?Expand@ImRect@@QAEXM@Z ENDP				; ImRect::Expand
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?Add@ImRect@@QAEXABU1@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
?Add@ImRect@@QAEXABU1@@Z PROC				; ImRect::Add, COMDAT
; _this$ = ecx

; 256  :     void        Add(const ImRect& rhs)          { if (Min.x > rhs.Min.x) Min.x = rhs.Min.x; if (Min.y > rhs.Min.y) Min.y = rhs.Min.y; if (Max.x < rhs.Max.x) Max.x = rhs.Max.x; if (Max.y < rhs.Max.y) Max.y = rhs.Max.y; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _rhs$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	movss	xmm1, DWORD PTR [eax]
	comiss	xmm0, xmm1
	jbe	SHORT $LN2@Add
	movss	DWORD PTR [ecx], xmm1
$LN2@Add:
	movss	xmm1, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [ecx+4]
	comiss	xmm0, xmm1
	jbe	SHORT $LN3@Add
	movss	DWORD PTR [ecx+4], xmm1
$LN3@Add:
	movss	xmm0, DWORD PTR [eax+8]
	comiss	xmm0, DWORD PTR [ecx+8]
	jbe	SHORT $LN4@Add
	movss	DWORD PTR [ecx+8], xmm0
$LN4@Add:
	movss	xmm0, DWORD PTR [eax+12]
	comiss	xmm0, DWORD PTR [ecx+12]
	jbe	SHORT $LN5@Add
	movss	DWORD PTR [ecx+12], xmm0
$LN5@Add:
	pop	ebp
	ret	4
?Add@ImRect@@QAEXABU1@@Z ENDP				; ImRect::Add
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?Add@ImRect@@QAEXABUImVec2@@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
?Add@ImRect@@QAEXABUImVec2@@@Z PROC			; ImRect::Add, COMDAT
; _this$ = ecx

; 255  :     void        Add(const ImVec2& rhs)          { if (Min.x > rhs.x)     Min.x = rhs.x;     if (Min.y > rhs.y) Min.y = rhs.y;         if (Max.x < rhs.x) Max.x = rhs.x;         if (Max.y < rhs.y) Max.y = rhs.y; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _rhs$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	movss	xmm1, DWORD PTR [eax]
	comiss	xmm0, xmm1
	jbe	SHORT $LN2@Add
	movss	DWORD PTR [ecx], xmm1
$LN2@Add:
	movss	xmm1, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [ecx+4]
	comiss	xmm0, xmm1
	jbe	SHORT $LN3@Add
	movss	DWORD PTR [ecx+4], xmm1
$LN3@Add:
	movss	xmm0, DWORD PTR [eax]
	comiss	xmm0, DWORD PTR [ecx+8]
	jbe	SHORT $LN4@Add
	movss	DWORD PTR [ecx+8], xmm0
$LN4@Add:
	movss	xmm0, DWORD PTR [eax+4]
	comiss	xmm0, DWORD PTR [ecx+12]
	jbe	SHORT $LN5@Add
	movss	DWORD PTR [ecx+12], xmm0
$LN5@Add:
	pop	ebp
	ret	4
?Add@ImRect@@QAEXABUImVec2@@@Z ENDP			; ImRect::Add
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?Overlaps@ImRect@@QBE_NABU1@@Z
_TEXT	SEGMENT
_r$ = 8							; size = 4
?Overlaps@ImRect@@QBE_NABU1@@Z PROC			; ImRect::Overlaps, COMDAT
; _this$ = ecx

; 254  :     bool        Overlaps(const ImRect& r) const { return r.Min.y < Max.y  && r.Max.y > Min.y  && r.Min.x < Max.x && r.Max.x > Min.x; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _r$[ebp]
	movss	xmm0, DWORD PTR [ecx+12]
	comiss	xmm0, DWORD PTR [eax+4]
	jbe	SHORT $LN3@Overlaps
	movss	xmm0, DWORD PTR [eax+12]
	comiss	xmm0, DWORD PTR [ecx+4]
	jbe	SHORT $LN3@Overlaps
	movss	xmm0, DWORD PTR [ecx+8]
	comiss	xmm0, DWORD PTR [eax]
	jbe	SHORT $LN3@Overlaps
	movss	xmm0, DWORD PTR [eax+8]
	comiss	xmm0, DWORD PTR [ecx]
	jbe	SHORT $LN3@Overlaps
	mov	al, 1
	pop	ebp
	ret	4
$LN3@Overlaps:
	xor	al, al
	pop	ebp
	ret	4
?Overlaps@ImRect@@QBE_NABU1@@Z ENDP			; ImRect::Overlaps
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?Contains@ImRect@@QBE_NABU1@@Z
_TEXT	SEGMENT
_r$ = 8							; size = 4
?Contains@ImRect@@QBE_NABU1@@Z PROC			; ImRect::Contains, COMDAT
; _this$ = ecx

; 253  :     bool        Contains(const ImRect& r) const { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x < Max.x && r.Max.y < Max.y; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _r$[ebp]
	movss	xmm0, DWORD PTR [eax]
	comiss	xmm0, DWORD PTR [ecx]
	jb	SHORT $LN3@Contains
	movss	xmm0, DWORD PTR [eax+4]
	comiss	xmm0, DWORD PTR [ecx+4]
	jb	SHORT $LN3@Contains
	movss	xmm0, DWORD PTR [ecx+8]
	comiss	xmm0, DWORD PTR [eax+8]
	jbe	SHORT $LN3@Contains
	movss	xmm0, DWORD PTR [ecx+12]
	comiss	xmm0, DWORD PTR [eax+12]
	jbe	SHORT $LN3@Contains
	mov	al, 1
	pop	ebp
	ret	4
$LN3@Contains:
	xor	al, al
	pop	ebp
	ret	4
?Contains@ImRect@@QBE_NABU1@@Z ENDP			; ImRect::Contains
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?Contains@ImRect@@QBE_NABUImVec2@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?Contains@ImRect@@QBE_NABUImVec2@@@Z PROC		; ImRect::Contains, COMDAT
; _this$ = ecx

; 252  :     bool        Contains(const ImVec2& p) const { return p.x >= Min.x     && p.y >= Min.y     && p.x < Max.x     && p.y < Max.y; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _p$[ebp]
	movss	xmm2, DWORD PTR [eax]
	comiss	xmm2, DWORD PTR [ecx]
	jb	SHORT $LN3@Contains
	movss	xmm1, DWORD PTR [eax+4]
	comiss	xmm1, DWORD PTR [ecx+4]
	jb	SHORT $LN3@Contains
	movss	xmm0, DWORD PTR [ecx+8]
	comiss	xmm0, xmm2
	jbe	SHORT $LN3@Contains
	movss	xmm0, DWORD PTR [ecx+12]
	comiss	xmm0, xmm1
	jbe	SHORT $LN3@Contains
	mov	al, 1
	pop	ebp
	ret	4
$LN3@Contains:
	xor	al, al
	pop	ebp
	ret	4
?Contains@ImRect@@QBE_NABUImVec2@@@Z ENDP		; ImRect::Contains
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?GetBR@ImRect@@QBE?AUImVec2@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetBR@ImRect@@QBE?AUImVec2@@XZ PROC			; ImRect::GetBR, COMDAT
; _this$ = ecx

; 251  :     ImVec2      GetBR() const                   { return Max; }                   // Bottom-right

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	pop	ebp
	ret	4
?GetBR@ImRect@@QBE?AUImVec2@@XZ ENDP			; ImRect::GetBR
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?GetBL@ImRect@@QBE?AUImVec2@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetBL@ImRect@@QBE?AUImVec2@@XZ PROC			; ImRect::GetBL, COMDAT
; _this$ = ecx

; 250  :     ImVec2      GetBL() const                   { return ImVec2(Min.x, Max.y); }  // Bottom-left

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 250  :     ImVec2      GetBL() const                   { return ImVec2(Min.x, Max.y); }  // Bottom-left

	pop	ebp
	ret	4
?GetBL@ImRect@@QBE?AUImVec2@@XZ ENDP			; ImRect::GetBL
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?GetTR@ImRect@@QBE?AUImVec2@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetTR@ImRect@@QBE?AUImVec2@@XZ PROC			; ImRect::GetTR, COMDAT
; _this$ = ecx

; 249  :     ImVec2      GetTR() const                   { return ImVec2(Max.x, Min.y); }  // Top-right

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 249  :     ImVec2      GetTR() const                   { return ImVec2(Max.x, Min.y); }  // Top-right

	pop	ebp
	ret	4
?GetTR@ImRect@@QBE?AUImVec2@@XZ ENDP			; ImRect::GetTR
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?GetTL@ImRect@@QBE?AUImVec2@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetTL@ImRect@@QBE?AUImVec2@@XZ PROC			; ImRect::GetTL, COMDAT
; _this$ = ecx

; 248  :     ImVec2      GetTL() const                   { return Min; }                   // Top-left

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	pop	ebp
	ret	4
?GetTL@ImRect@@QBE?AUImVec2@@XZ ENDP			; ImRect::GetTL
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?GetHeight@ImRect@@QBEMXZ
_TEXT	SEGMENT
?GetHeight@ImRect@@QBEMXZ PROC				; ImRect::GetHeight, COMDAT
; _this$ = ecx

; 247  :     float       GetHeight() const               { return Max.y-Min.y; }

	fld	DWORD PTR [ecx+12]
	fsub	DWORD PTR [ecx+4]
	ret	0
?GetHeight@ImRect@@QBEMXZ ENDP				; ImRect::GetHeight
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?GetWidth@ImRect@@QBEMXZ
_TEXT	SEGMENT
?GetWidth@ImRect@@QBEMXZ PROC				; ImRect::GetWidth, COMDAT
; _this$ = ecx

; 246  :     float       GetWidth() const                { return Max.x-Min.x; }

	fld	DWORD PTR [ecx+8]
	fsub	DWORD PTR [ecx]
	ret	0
?GetWidth@ImRect@@QBEMXZ ENDP				; ImRect::GetWidth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?GetSize@ImRect@@QBE?AUImVec2@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetSize@ImRect@@QBE?AUImVec2@@XZ PROC			; ImRect::GetSize, COMDAT
; _this$ = ecx

; 245  :     ImVec2      GetSize() const                 { return ImVec2(Max.x-Min.x, Max.y-Min.y); }

	npad	2
	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR [ecx+8]
	subss	xmm0, DWORD PTR [ecx]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	movss	DWORD PTR [eax], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 245  :     ImVec2      GetSize() const                 { return ImVec2(Max.x-Min.x, Max.y-Min.y); }

	movss	xmm0, DWORD PTR [ecx+12]
	subss	xmm0, DWORD PTR [ecx+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 245  :     ImVec2      GetSize() const                 { return ImVec2(Max.x-Min.x, Max.y-Min.y); }

	pop	ebp
	ret	4
?GetSize@ImRect@@QBE?AUImVec2@@XZ ENDP			; ImRect::GetSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?GetCenter@ImRect@@QBE?AUImVec2@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetCenter@ImRect@@QBE?AUImVec2@@XZ PROC		; ImRect::GetCenter, COMDAT
; _this$ = ecx

; 244  :     ImVec2      GetCenter() const               { return ImVec2((Min.x+Max.x)*0.5f, (Min.y+Max.y)*0.5f); }

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR [ecx+8]
	addss	xmm0, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 244  :     ImVec2      GetCenter() const               { return ImVec2((Min.x+Max.x)*0.5f, (Min.y+Max.y)*0.5f); }

	mulss	xmm0, DWORD PTR __real@3f000000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax], xmm0
	movss	xmm0, DWORD PTR [ecx+12]
	addss	xmm0, DWORD PTR [ecx+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 244  :     ImVec2      GetCenter() const               { return ImVec2((Min.x+Max.x)*0.5f, (Min.y+Max.y)*0.5f); }

	mulss	xmm0, DWORD PTR __real@3f000000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 244  :     ImVec2      GetCenter() const               { return ImVec2((Min.x+Max.x)*0.5f, (Min.y+Max.y)*0.5f); }

	pop	ebp
	ret	4
?GetCenter@ImRect@@QBE?AUImVec2@@XZ ENDP		; ImRect::GetCenter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ??0ImRect@@QAE@MMMM@Z
_TEXT	SEGMENT
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_x2$ = 16						; size = 4
_y2$ = 20						; size = 4
??0ImRect@@QAE@MMMM@Z PROC				; ImRect::ImRect, COMDAT
; _this$ = ecx

; 242  :     ImRect(float x1, float y1, float x2, float y2)  : Min(x1, y1), Max(x2, y2)                      {}

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR _x1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 242  :     ImRect(float x1, float y1, float x2, float y2)  : Min(x1, y1), Max(x2, y2)                      {}

	mov	eax, ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	movss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR [ecx+8], xmm0
	movss	xmm0, DWORD PTR _y2$[ebp]
	movss	DWORD PTR [ecx+12], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 242  :     ImRect(float x1, float y1, float x2, float y2)  : Min(x1, y1), Max(x2, y2)                      {}

	pop	ebp
	ret	16					; 00000010H
??0ImRect@@QAE@MMMM@Z ENDP				; ImRect::ImRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ??0ImRect@@QAE@ABUImVec4@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
??0ImRect@@QAE@ABUImVec4@@@Z PROC			; ImRect::ImRect, COMDAT
; _this$ = ecx

; 241  :     ImRect(const ImVec4& v)                         : Min(v.x, v.y), Max(v.z, v.w)                  {}

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	movss	DWORD PTR [ecx+4], xmm0
	mov	eax, DWORD PTR [edx+8]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 241  :     ImRect(const ImVec4& v)                         : Min(v.x, v.y), Max(v.z, v.w)                  {}

	movss	xmm0, DWORD PTR [edx+12]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR [ecx+8], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 241  :     ImRect(const ImVec4& v)                         : Min(v.x, v.y), Max(v.z, v.w)                  {}

	mov	eax, ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [ecx+12], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 241  :     ImRect(const ImVec4& v)                         : Min(v.x, v.y), Max(v.z, v.w)                  {}

	pop	ebp
	ret	4
??0ImRect@@QAE@ABUImVec4@@@Z ENDP			; ImRect::ImRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ??0ImRect@@QAE@ABUImVec2@@0@Z
_TEXT	SEGMENT
_min$ = 8						; size = 4
_max$ = 12						; size = 4
??0ImRect@@QAE@ABUImVec2@@0@Z PROC			; ImRect::ImRect, COMDAT
; _this$ = ecx

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _min$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _max$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, ecx
	pop	ebp
	ret	8
??0ImRect@@QAE@ABUImVec2@@0@Z ENDP			; ImRect::ImRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ??0ImRect@@QAE@XZ
_TEXT	SEGMENT
??0ImRect@@QAE@XZ PROC					; ImRect::ImRect, COMDAT
; _this$ = ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR [ecx], 2139095039		; 7f7fffffH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 239  :     ImRect()                                        : Min(FLT_MAX,FLT_MAX), Max(-FLT_MAX,-FLT_MAX)  {}

	mov	eax, ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR [ecx+4], 2139095039		; 7f7fffffH
	mov	DWORD PTR [ecx+8], -8388609		; ff7fffffH
	mov	DWORD PTR [ecx+12], -8388609		; ff7fffffH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 239  :     ImRect()                                        : Min(FLT_MAX,FLT_MAX), Max(-FLT_MAX,-FLT_MAX)  {}

	ret	0
??0ImRect@@QAE@XZ ENDP					; ImRect::ImRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ??3@YAXPAXUImPlacementNewDummy@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 4
??3@YAXPAXUImPlacementNewDummy@@0@Z PROC		; operator delete, COMDAT

; 148  : inline void operator delete(void*, ImPlacementNewDummy, void*) {}

	ret	0
??3@YAXPAXUImPlacementNewDummy@@0@Z ENDP		; operator delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ??2@YAPAXIUImPlacementNewDummy@@PAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 1
_ptr$ = 16						; size = 4
??2@YAPAXIUImPlacementNewDummy@@PAX@Z PROC		; operator new, COMDAT

; 147  : inline void* operator new(size_t, ImPlacementNewDummy, void* ptr) { return ptr; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _ptr$[ebp]
	pop	ebp
	ret	0
??2@YAPAXIUImPlacementNewDummy@@PAX@Z ENDP		; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
tv129 = 8						; size = 4
_lhs$ = 8						; size = 4
_fail_value$ = 12					; size = 4
?ImInvLength@@YAMABUImVec2@@M@Z PROC			; ImInvLength

; 139  : static inline float  ImInvLength(const ImVec2& lhs, float fail_value)           { float d = lhs.x*lhs.x + lhs.y*lhs.y; if (d > 0.0f) return 1.0f / sqrtf(d); return fail_value; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _lhs$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	movss	xmm1, DWORD PTR [eax]
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm1, xmm0
	comiss	xmm1, DWORD PTR __real@00000000
	jbe	SHORT $LN2@ImInvLengt
	xorps	xmm0, xmm0
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 746  :         return (float)sqrt(_X);

	sqrtss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 139  : static inline float  ImInvLength(const ImVec2& lhs, float fail_value)           { float d = lhs.x*lhs.x + lhs.y*lhs.y; if (d > 0.0f) return 1.0f / sqrtf(d); return fail_value; }

	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm0
	movss	DWORD PTR tv129[ebp], xmm1
	fld	DWORD PTR tv129[ebp]
	pop	ebp
	ret	0
$LN2@ImInvLengt:
	fld	DWORD PTR _fail_value$[ebp]
	pop	ebp
	ret	0
?ImInvLength@@YAMABUImVec2@@M@Z ENDP			; ImInvLength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
_v$ = 8							; size = 4
tv67 = 12						; size = 4
_mn$ = 12						; size = 4
_mx$ = 16						; size = 4
?ImClamp@@YAMMMM@Z PROC					; ImClamp

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	npad	2
	push	ebp
	mov	ebp, esp
	movss	xmm1, DWORD PTR _mn$[ebp]
	movss	xmm0, DWORD PTR _v$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN5@ImClamp
	movss	DWORD PTR tv67[ebp], xmm1
	fld	DWORD PTR tv67[ebp]
	pop	ebp
	ret	0
$LN5@ImClamp:
	minss	xmm0, DWORD PTR _mx$[ebp]
	movss	DWORD PTR tv67[ebp], xmm0
	fld	DWORD PTR tv67[ebp]
	pop	ebp
	ret	0
?ImClamp@@YAMMMM@Z ENDP					; ImClamp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
tv65 = 8						; size = 4
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
?ImMax@@YAMMM@Z PROC					; ImMax

; 128  : static inline float  ImMax(float lhs, float rhs)                                { return lhs >= rhs ? lhs : rhs; }

	npad	2
	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR _lhs$[ebp]
	maxss	xmm0, DWORD PTR _rhs$[ebp]
	movss	DWORD PTR tv65[ebp], xmm0
	fld	DWORD PTR tv65[ebp]
	pop	ebp
	ret	0
?ImMax@@YAMMM@Z ENDP					; ImMax
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
tv65 = 8						; size = 4
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
?ImMin@@YAMMM@Z PROC					; ImMin

; 127  : static inline float  ImMin(float lhs, float rhs)                                { return lhs < rhs ? lhs : rhs; }

	npad	2
	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR _lhs$[ebp]
	minss	xmm0, DWORD PTR _rhs$[ebp]
	movss	DWORD PTR tv65[ebp], xmm0
	fld	DWORD PTR tv65[ebp]
	pop	ebp
	ret	0
?ImMin@@YAMMM@Z ENDP					; ImMin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
?ImMax@@YAHHH@Z PROC					; ImMax

; 126  : static inline int    ImMax(int lhs, int rhs)                                    { return lhs >= rhs ? lhs : rhs; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _rhs$[ebp]
	cmp	DWORD PTR _lhs$[ebp], eax
	cmovge	eax, DWORD PTR _lhs$[ebp]
	pop	ebp
	ret	0
?ImMax@@YAHHH@Z ENDP					; ImMax
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
?ImMin@@YAHHH@Z PROC					; ImMin

; 125  : static inline int    ImMin(int lhs, int rhs)                                    { return lhs < rhs ? lhs : rhs; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _rhs$[ebp]
	cmp	DWORD PTR _lhs$[ebp], eax
	cmovl	eax, DWORD PTR _lhs$[ebp]
	pop	ebp
	ret	0
?ImMin@@YAHHH@Z ENDP					; ImMin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
??X@YAAAUImVec2@@AAU0@M@Z PROC				; operator*=

; 120  : static inline ImVec2& operator*=(ImVec2& lhs, const float rhs)                  { lhs.x *= rhs; lhs.y *= rhs; return lhs; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _lhs$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _rhs$[ebp]
	movss	DWORD PTR [eax], xmm0
	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR _rhs$[ebp]
	movss	DWORD PTR [eax+4], xmm0
	pop	ebp
	ret	0
??X@YAAAUImVec2@@AAU0@M@Z ENDP				; operator*=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_lhs$ = 12						; size = 4
_rhs$ = 16						; size = 4
??D@YA?AUImVec2@@ABU0@0@Z PROC				; operator*

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _lhs$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [ecx]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR [ecx+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	pop	ebp
	ret	0
??D@YA?AUImVec2@@ABU0@0@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_lhs$ = 12						; size = 4
_rhs$ = 16						; size = 4
??G@YA?AUImVec2@@ABU0@0@Z PROC				; operator-

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _lhs$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [edx]
	subss	xmm0, DWORD PTR [ecx]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [edx+4]
	subss	xmm0, DWORD PTR [ecx+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	pop	ebp
	ret	0
??G@YA?AUImVec2@@ABU0@0@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_lhs$ = 12						; size = 4
_rhs$ = 16						; size = 4
??H@YA?AUImVec2@@ABU0@0@Z PROC				; operator+

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _lhs$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [edx]
	addss	xmm0, DWORD PTR [ecx]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [edx+4]
	addss	xmm0, DWORD PTR [ecx+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	pop	ebp
	ret	0
??H@YA?AUImVec2@@ABU0@0@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_lhs$ = 12						; size = 4
_rhs$ = 16						; size = 4
??D@YA?AUImVec2@@ABU0@M@Z PROC				; operator*

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR _lhs$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR _rhs$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	movss	xmm0, DWORD PTR [ecx+4]
	mulss	xmm0, DWORD PTR _rhs$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	pop	ebp
	ret	0
??D@YA?AUImVec2@@ABU0@M@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
_v$ = 8							; size = 4
?ImUpperPowerOfTwo@@YAHH@Z PROC				; ImUpperPowerOfTwo

; 97   : static inline int       ImUpperPowerOfTwo(int v)        { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return v; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR _v$[ebp]
	dec	ecx
	mov	eax, ecx
	sar	eax, 1
	or	ecx, eax
	mov	eax, ecx
	sar	eax, 2
	or	ecx, eax
	mov	eax, ecx
	sar	eax, 4
	or	ecx, eax
	mov	eax, ecx
	sar	eax, 8
	or	ecx, eax
	mov	eax, ecx
	sar	eax, 16					; 00000010H
	or	eax, ecx
	inc	eax
	pop	ebp
	ret	0
?ImUpperPowerOfTwo@@YAHH@Z ENDP				; ImUpperPowerOfTwo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
_c$ = 8							; size = 4
?ImCharIsSpace@@YA_NH@Z PROC				; ImCharIsSpace

; 96   : static inline bool      ImCharIsSpace(int c)            { return c == ' ' || c == '\t' || c == 0x3000; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _c$[ebp]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN3@ImCharIsSp
	cmp	eax, 9
	je	SHORT $LN3@ImCharIsSp
	cmp	eax, 12288				; 00003000H
	je	SHORT $LN3@ImCharIsSp
	xor	al, al
	pop	ebp
	ret	0
$LN3@ImCharIsSp:
	mov	al, 1
	pop	ebp
	ret	0
?ImCharIsSpace@@YA_NH@Z ENDP				; ImCharIsSpace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv65 = 8						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 745  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR __X$[ebp]

; 746  :         return (float)sqrt(_X);

	sqrtss	xmm0, xmm0
	movss	DWORD PTR tv65[ebp], xmm0
	fld	DWORD PTR tv65[ebp]

; 747  :     }

	pop	ebp
	ret	0
_sqrtf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
;	COMDAT _sinf
_TEXT	SEGMENT
tv65 = 8						; size = 4
__X$ = 8						; size = 4
_sinf	PROC						; COMDAT

; 735  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 736  :         return (float)sin(_X);

	movss	xmm0, DWORD PTR __X$[ebp]
	call	___libm_sse2_sinf
	movss	DWORD PTR tv65[ebp], xmm0
	fld	DWORD PTR tv65[ebp]

; 737  :     }

	pop	ebp
	ret	0
_sinf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv68 = 8						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 657  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 658  :         return (float)fabs(_X);

	movss	xmm0, DWORD PTR __X$[ebp]
	andps	xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
	movss	DWORD PTR tv68[ebp], xmm0
	fld	DWORD PTR tv68[ebp]

; 659  :     }

	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
;	COMDAT _cosf
_TEXT	SEGMENT
tv65 = 8						; size = 4
__X$ = 8						; size = 4
_cosf	PROC						; COMDAT

; 634  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 635  :         return (float)cos(_X);

	movss	xmm0, DWORD PTR __X$[ebp]
	call	___libm_sse2_cosf
	movss	DWORD PTR tv65[ebp], xmm0
	fld	DWORD PTR tv65[ebp]

; 636  :     }

	pop	ebp
	ret	0
_cosf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GImFont@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GImFont@@QAEPAXI@Z PROC				; ImFont::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1ImFont@@QAE@XZ			; ImFont::~ImFont
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	84					; 00000054H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_GImFont@@QAEPAXI@Z ENDP				; ImFont::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 2
_src$ = 12						; size = 2
_overwrite_dst$ = 16					; size = 1
?AddRemapChar@ImFont@@QAEXGG_N@Z PROC			; ImFont::AddRemapChar
; _this$ = ecx

; 1780 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 1781 :     IM_ASSERT(IndexLookup.Size > 0);    // Currently this can only be called AFTER the font has been built, aka after calling ImFontAtlas::GetTexDataAs*() function.
; 1782 :     int index_size = IndexLookup.Size;
; 1783 : 
; 1784 :     if (dst < index_size && IndexLookup.Data[dst] == (unsigned short)-1 && !overwrite_dst) // 'dst' already exists

	movzx	edi, WORD PTR _dst$[ebp]
	mov	ebx, DWORD PTR [esi+40]
	cmp	edi, ebx
	jge	SHORT $LN2@AddRemapCh
	mov	eax, DWORD PTR [esi+48]
	mov	ecx, 65535				; 0000ffffH
	cmp	WORD PTR [eax+edi*2], cx
	jne	SHORT $LN2@AddRemapCh
	cmp	BYTE PTR _overwrite_dst$[ebp], 0
	je	SHORT $LN1@AddRemapCh
$LN2@AddRemapCh:

; 1785 :         return;
; 1786 :     if (src >= index_size && dst >= index_size) // both 'dst' and 'src' don't exist -> no-op

	movzx	eax, WORD PTR _src$[ebp]
	cmp	eax, ebx
	jl	SHORT $LN3@AddRemapCh
	cmp	edi, ebx
	jge	SHORT $LN1@AddRemapCh
$LN3@AddRemapCh:

; 1787 :         return;
; 1788 : 
; 1789 :     GrowIndex(dst + 1);

	lea	eax, DWORD PTR [edi+1]
	mov	ecx, esi
	push	eax
	call	?GrowIndex@ImFont@@QAEXH@Z		; ImFont::GrowIndex

; 1790 :     IndexLookup[dst] = (src < index_size) ? IndexLookup.Data[src] : (unsigned short)-1;

	movzx	ecx, WORD PTR _src$[ebp]
	cmp	ecx, ebx
	jge	SHORT $LN5@AddRemapCh
	mov	eax, DWORD PTR [esi+48]
	movzx	edx, WORD PTR [eax+ecx*2]
	jmp	SHORT $LN6@AddRemapCh
$LN5@AddRemapCh:
	mov	edx, 65535				; 0000ffffH
$LN6@AddRemapCh:
	mov	eax, DWORD PTR [esi+48]
	mov	WORD PTR [eax+edi*2], dx

; 1791 :     IndexXAdvance[dst] = (src < index_size) ? IndexXAdvance.Data[src] : 1.0f;

	cmp	ecx, ebx
	jge	SHORT $LN7@AddRemapCh
	mov	eax, DWORD PTR [esi+36]
	movss	xmm0, DWORD PTR [eax+ecx*4]
	movss	DWORD PTR [eax+edi*4], xmm0
	pop	edi
	pop	esi
	pop	ebx

; 1792 : }

	pop	ebp
	ret	12					; 0000000cH
$LN7@AddRemapCh:

; 1791 :     IndexXAdvance[dst] = (src < index_size) ? IndexXAdvance.Data[src] : 1.0f;

	mov	eax, DWORD PTR [esi+36]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [eax+edi*4], xmm0
$LN1@AddRemapCh:
	pop	edi
	pop	esi
	pop	ebx

; 1792 : }

	pop	ebp
	ret	12					; 0000000cH
?AddRemapChar@ImFont@@QAEXGG_N@Z ENDP			; ImFont::AddRemapChar
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?GrowIndex@ImFont@@QAEXH@Z PROC				; ImFont::GrowIndex
; _this$ = ecx

; 1765 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx

; 1766 :     IM_ASSERT(IndexXAdvance.Size == IndexLookup.Size);
; 1767 :     int old_size = IndexLookup.Size;
; 1768 :     if (new_size <= old_size)

	mov	ebx, DWORD PTR _new_size$[ebp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+40]
	cmp	ebx, esi
	jle	$LN14@GrowIndex

; 1769 :         return;
; 1770 :     IndexXAdvance.resize(new_size);

	push	ebx
	lea	ecx, DWORD PTR [edi+28]
	call	?resize@?$ImVector@M@@QAEXH@Z		; ImVector<float>::resize

; 1771 :     IndexLookup.resize(new_size);

	push	ebx
	lea	ecx, DWORD PTR [edi+40]
	call	?resize@?$ImVector@G@@QAEXH@Z		; ImVector<unsigned short>::resize
	cmp	esi, ebx
	jge	$LN14@GrowIndex

; 1772 :     for (int i = old_size; i < new_size; i++)

	mov	eax, ebx
	mov	edx, 65535				; 0000ffffH
	sub	eax, esi
	cmp	eax, 4
	jl	SHORT $LC15@GrowIndex
	lea	ecx, DWORD PTR [ebx-3]
$LL16@GrowIndex:

; 1773 :     {
; 1774 :         IndexXAdvance[i] = -1.0f;

	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [eax+esi*4], -1082130432	; bf800000H

; 1775 :         IndexLookup[i] = (unsigned short)-1;

	mov	eax, DWORD PTR [edi+48]
	mov	WORD PTR [eax+esi*2], dx
	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [eax+esi*4+4], -1082130432	; bf800000H
	mov	eax, DWORD PTR [edi+48]
	mov	WORD PTR [eax+esi*2+2], dx
	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [eax+esi*4+8], -1082130432	; bf800000H
	mov	eax, DWORD PTR [edi+48]
	mov	WORD PTR [eax+esi*2+4], dx
	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [eax+esi*4+12], -1082130432	; bf800000H
	mov	eax, DWORD PTR [edi+48]
	mov	WORD PTR [eax+esi*2+6], dx
	add	esi, 4
	cmp	esi, ecx
	jl	SHORT $LL16@GrowIndex
$LC15@GrowIndex:

; 1772 :     for (int i = old_size; i < new_size; i++)

	cmp	esi, ebx
	jge	SHORT $LN14@GrowIndex
	npad	8
$LC4@GrowIndex:

; 1773 :     {
; 1774 :         IndexXAdvance[i] = -1.0f;

	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [eax+esi*4], -1082130432	; bf800000H

; 1775 :         IndexLookup[i] = (unsigned short)-1;

	mov	eax, DWORD PTR [edi+48]
	mov	WORD PTR [eax+esi*2], dx
	inc	esi
	cmp	esi, ebx
	jl	SHORT $LC4@GrowIndex
$LN14@GrowIndex:
	pop	edi
	pop	esi
	pop	ebx

; 1776 :     }
; 1777 : }

	pop	ebp
	ret	4
?GrowIndex@ImFont@@QAEXH@Z ENDP				; ImFont::GrowIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_set
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_set
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_set
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T2 = -84						; size = 8
__Ans$3 = -76						; size = 8
_idx_expected_size$1$ = -68				; size = 4
_vtx_current_idx$1$ = -64				; size = 4
_v1$1$ = -60						; size = 4
_char_width$1$ = -60					; size = 4
$T4 = -60						; size = 2
$T5 = -60						; size = 2
$T6 = -60						; size = 4
_line_height$1$ = -56					; size = 4
_idx_write$1$ = -52					; size = 4
_this$1$ = -48						; size = 4
_vtx_write$1$ = -44					; size = 4
_v2$1$ = -40						; size = 4
_glyph$1$ = -40						; size = 4
_u2$1$ = -36						; size = 4
_u1$1$ = -32						; size = 4
_y$1$ = -28						; size = 4
_c$7 = -24						; size = 4
_x$1$ = -20						; size = 4
_word_wrap_eol$1$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_draw_list$ = 8						; size = 4
_size$ = 12						; size = 4
_pos$ = 16						; size = 8
_col$ = 24						; size = 4
_clip_rect$ = 28					; size = 4
_text_begin$ = 32					; size = 4
$T8 = 35						; size = 1
_text_end$ = 36						; size = 4
_word_wrap_enabled$1$ = 39				; size = 1
_wrap_width$ = 40					; size = 4
_cpu_fine_clip$ = 44					; size = 1
?RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z PROC ; ImFont::RenderText
; _this$ = ecx

; 2017 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 72					; 00000048H
	push	ebx

; 2018 :     if (!text_end)

	mov	ebx, DWORD PTR _text_end$[ebp]
	mov	DWORD PTR _this$1$[ebp], ecx
	push	esi
	mov	esi, DWORD PTR _text_begin$[ebp]
	push	edi
	test	ebx, ebx
	jne	SHORT $LN11@RenderText

; 2019 :         text_end = text_begin + strlen(text_begin); // ImGui functions generally already provides a valid text_end, so this is merely to handle direct calls.

	mov	edx, esi
	lea	edi, DWORD PTR [edx+1]
$LL126@RenderText:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL126@RenderText
	sub	edx, edi
	lea	ebx, DWORD PTR [edx+esi]
$LN11@RenderText:

; 2020 : 
; 2021 :     // Align to be pixel perfect
; 2022 :     pos.x = (float)(int)pos.x + DisplayOffset.x;

	cvttss2si eax, DWORD PTR _pos$[ebp]
	movd	xmm0, eax

; 2023 :     pos.y = (float)(int)pos.y + DisplayOffset.y;

	cvttss2si eax, DWORD PTR _pos$[ebp+4]
	cvtdq2ps xmm0, xmm0
	addss	xmm0, DWORD PTR [ecx+8]
	movss	DWORD PTR _x$1$[ebp], xmm0
	movss	DWORD PTR _pos$[ebp], xmm0
	movd	xmm0, eax

; 2024 :     float x = pos.x;
; 2025 :     float y = pos.y;
; 2026 :     if (y > clip_rect.w)

	mov	eax, DWORD PTR _clip_rect$[ebp]
	cvtdq2ps xmm0, xmm0
	addss	xmm0, DWORD PTR [ecx+12]
	comiss	xmm0, DWORD PTR [eax+12]
	movss	DWORD PTR _y$1$[ebp], xmm0
	movss	DWORD PTR _pos$[ebp+4], xmm0
	ja	$LN1@RenderText

; 2027 :         return;
; 2028 : 
; 2029 :     const float scale = size / FontSize;

	movss	xmm2, DWORD PTR [ecx]
	movss	xmm1, DWORD PTR _size$[ebp]
	divss	xmm1, xmm2

; 2030 :     const float line_height = FontSize * scale;

	mulss	xmm2, xmm1
	movss	DWORD PTR _size$[ebp], xmm1

; 2031 :     const bool word_wrap_enabled = (wrap_width > 0.0f);

	movss	xmm1, DWORD PTR _wrap_width$[ebp]
	comiss	xmm1, DWORD PTR __real@00000000
	movss	DWORD PTR _line_height$1$[ebp], xmm2
	seta	cl

; 2032 :     const char* word_wrap_eol = NULL;

	xor	edi, edi
	mov	BYTE PTR _word_wrap_enabled$1$[ebp], cl
	mov	DWORD PTR _word_wrap_eol$1$[ebp], edi

; 2033 : 
; 2034 :     // Skip non-visible lines
; 2035 :     const char* s = text_begin;
; 2036 :     if (!word_wrap_enabled && y + line_height < clip_rect.y)

	test	cl, cl
	jne	SHORT $LN129@RenderText
	movaps	xmm1, xmm2
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [eax+4]
	comiss	xmm0, xmm1
	jbe	SHORT $LN129@RenderText

; 2037 :         while (s < text_end && *s != '\n')  // Fast-forward to next line

	cmp	esi, ebx
	jae	SHORT $LN129@RenderText
	npad	4
$LL2@RenderText:
	cmp	BYTE PTR [esi], 10			; 0000000aH
	je	SHORT $LN129@RenderText

; 2038 :             s++;

	inc	esi
	cmp	esi, ebx
	jb	SHORT $LL2@RenderText
$LN129@RenderText:

; 2039 : 
; 2040 :     // Reserve vertices for remaining worse case (over-reserving is useful and easily amortized)
; 2041 :     const int vtx_count_max = (int)(text_end - s) * 4;
; 2042 :     const int idx_count_max = (int)(text_end - s) * 6;
; 2043 :     const int idx_expected_size = draw_list->IdxBuffer.Size + idx_count_max;

	mov	edx, DWORD PTR _draw_list$[ebp]
	mov	eax, ebx
	sub	eax, esi
	mov	edi, DWORD PTR [edx+12]
	lea	ecx, DWORD PTR [eax*4]
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax

; 2044 :     draw_list->PrimReserve(idx_count_max, vtx_count_max);

	push	ecx
	add	edi, eax
	mov	ecx, edx
	push	eax
	mov	DWORD PTR _idx_expected_size$1$[ebp], edi
	call	?PrimReserve@ImDrawList@@QAEXHH@Z	; ImDrawList::PrimReserve

; 2045 : 
; 2046 :     ImDrawVert* vtx_write = draw_list->_VtxWritePtr;

	mov	ecx, DWORD PTR _draw_list$[ebp]

; 2047 :     ImDrawIdx* idx_write = draw_list->_IdxWritePtr;
; 2048 :     unsigned int vtx_current_idx = draw_list->_VtxCurrentIdx;
; 2049 : 
; 2050 :     while (s < text_end)

	mov	edi, 0
	mov	eax, DWORD PTR [ecx+44]
	mov	edx, DWORD PTR [ecx+48]
	mov	ecx, DWORD PTR [ecx+40]
	mov	DWORD PTR _vtx_write$1$[ebp], eax
	mov	DWORD PTR _idx_write$1$[ebp], edx
	mov	DWORD PTR _vtx_current_idx$1$[ebp], ecx
	cmp	esi, ebx
	jae	$LN121@RenderText
	mov	al, BYTE PTR _word_wrap_enabled$1$[ebp]
$LL4@RenderText:

; 2051 :     {
; 2052 :         if (word_wrap_enabled)

	test	al, al
	je	$LN17@RenderText

; 2053 :         {
; 2054 :             // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
; 2055 :             if (!word_wrap_eol)

	test	edi, edi
	jne	SHORT $LN127@RenderText

; 2056 :             {
; 2057 :                 word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - (x - pos.x));

	movss	xmm0, DWORD PTR _x$1$[ebp]
	subss	xmm0, DWORD PTR _pos$[ebp]
	movss	xmm1, DWORD PTR _wrap_width$[ebp]
	push	ecx
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [esp], xmm1
	push	ebx
	push	esi
	push	ecx
	mov	ecx, DWORD PTR _this$1$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?CalcWordWrapPositionA@ImFont@@QBEPBDMPBD0M@Z ; ImFont::CalcWordWrapPositionA
	mov	edi, eax
	mov	DWORD PTR _word_wrap_eol$1$[ebp], edi

; 2058 :                 if (word_wrap_eol == s) // Wrap_width is too small to fit anything. Force displaying 1 character to minimize the height discontinuity.

	cmp	esi, edi
	jne	SHORT $LN140@RenderText

; 2059 :                     word_wrap_eol++;    // +1 may not be a character start point in UTF-8 but it's ok because we use s >= word_wrap_eol below

	inc	edi
	mov	DWORD PTR _word_wrap_eol$1$[ebp], edi
$LN127@RenderText:

; 2060 :             }
; 2061 : 
; 2062 :             if (s >= word_wrap_eol)

	cmp	esi, edi
$LN140@RenderText:
	jb	SHORT $LN17@RenderText

; 2063 :             {
; 2064 :                 x = pos.x;
; 2065 :                 y += line_height;

	movss	xmm2, DWORD PTR _y$1$[ebp]

; 2066 :                 word_wrap_eol = NULL;

	xor	edi, edi
	addss	xmm2, DWORD PTR _line_height$1$[ebp]
	movss	xmm1, DWORD PTR _pos$[ebp]
	movss	DWORD PTR _x$1$[ebp], xmm1
	mov	DWORD PTR _word_wrap_eol$1$[ebp], edi
	movss	DWORD PTR _y$1$[ebp], xmm2
	npad	4
$LL6@RenderText:

; 2070 :                 {
; 2071 :                     const char c = *s;

	mov	cl, BYTE PTR [esi]

; 2072 :                     if (ImCharIsSpace(c)) { s++; } else if (c == '\n') { s++; break; } else { break; }

	movsx	eax, cl
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 96   : static inline bool      ImCharIsSpace(int c)            { return c == ' ' || c == '\t' || c == 0x3000; }

	cmp	eax, 32					; 00000020H
	je	SHORT $LN45@RenderText
	cmp	eax, 9
	je	SHORT $LN45@RenderText
	cmp	eax, 12288				; 00003000H
	jne	SHORT $LN125@RenderText
$LN45@RenderText:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 2072 :                     if (ImCharIsSpace(c)) { s++; } else if (c == '\n') { s++; break; } else { break; }

	inc	esi
	cmp	esi, ebx
	jb	SHORT $LL6@RenderText

; 2067 : 
; 2068 :                 // Wrapping skips upcoming blanks
; 2069 :                 while (s < text_end)

	jmp	$LN130@RenderText
$LN125@RenderText:

; 2073 :                 }
; 2074 :                 continue;

	mov	al, BYTE PTR _word_wrap_enabled$1$[ebp]
	cmp	cl, 10					; 0000000aH
	jne	$LN110@RenderText

; 2072 :                     if (ImCharIsSpace(c)) { s++; } else if (c == '\n') { s++; break; } else { break; }

	inc	esi

; 2073 :                 }
; 2074 :                 continue;

	jmp	$LN110@RenderText
$LN17@RenderText:

; 2075 :             }
; 2076 :         }
; 2077 : 
; 2078 :         // Decode and advance source
; 2079 :         unsigned int c = (unsigned int)*s;

	movsx	edi, BYTE PTR [esi]
	mov	DWORD PTR _c$7[ebp], edi

; 2080 :         if (c < 0x80)

	cmp	edi, 128				; 00000080H
	jae	SHORT $LN22@RenderText

; 2081 :         {
; 2082 :             s += 1;

	inc	esi

; 2083 :         }
; 2084 :         else

	jmp	SHORT $LN24@RenderText
$LN22@RenderText:

; 2085 :         {
; 2086 :             s += ImTextCharFromUtf8(&c, s, text_end);

	push	ebx
	lea	eax, DWORD PTR _c$7[ebp]
	push	esi
	push	eax
	call	?ImTextCharFromUtf8@@YAHPAIPBD1@Z	; ImTextCharFromUtf8

; 2087 :             if (c == 0) // Malformed UTF-8?

	mov	edi, DWORD PTR _c$7[ebp]
	add	esp, 12					; 0000000cH
	add	esi, eax
	test	edi, edi
	je	$LN130@RenderText
$LN24@RenderText:

; 2088 :                 break;
; 2089 :         }
; 2090 : 
; 2091 :         if (c < 32)

	cmp	edi, 32					; 00000020H
	jae	SHORT $LN29@RenderText

; 2092 :         {
; 2093 :             if (c == '\n')

	cmp	edi, 10					; 0000000aH
	jne	SHORT $LN26@RenderText

; 2094 :             {
; 2095 :                 x = pos.x;

	movss	xmm1, DWORD PTR _pos$[ebp]

; 2096 :                 y += line_height;
; 2097 : 
; 2098 :                 if (y > clip_rect.w)

	mov	ecx, DWORD PTR _clip_rect$[ebp]
	movss	DWORD PTR _x$1$[ebp], xmm1
	movss	xmm1, DWORD PTR _line_height$1$[ebp]
	movaps	xmm2, xmm1
	addss	xmm2, DWORD PTR _y$1$[ebp]
	comiss	xmm2, DWORD PTR [ecx+12]
	movss	DWORD PTR _y$1$[ebp], xmm2
	ja	$LN130@RenderText

; 2099 :                     break;
; 2100 :                 if (!word_wrap_enabled && y + line_height < clip_rect.y)

	mov	al, BYTE PTR _word_wrap_enabled$1$[ebp]
	test	al, al
	jne	$LN134@RenderText
	movss	xmm0, DWORD PTR [ecx+4]
	addss	xmm1, xmm2
	comiss	xmm0, xmm1
	jbe	$LN134@RenderText

; 2101 :                     while (s < text_end && *s != '\n')  // Fast-forward to next line

	cmp	esi, ebx
	jae	$LN130@RenderText
$LL8@RenderText:
	cmp	BYTE PTR [esi], 10			; 0000000aH
	je	$LN134@RenderText

; 2102 :                         s++;

	inc	esi
	cmp	esi, ebx
	jb	SHORT $LL8@RenderText

; 2101 :                     while (s < text_end && *s != '\n')  // Fast-forward to next line

	jmp	$LN130@RenderText
$LN26@RenderText:

; 2103 :                 continue;
; 2104 :             }
; 2105 :             if (c == '\r')

	cmp	edi, 13					; 0000000dH
	je	$LN137@RenderText
$LN29@RenderText:

; 2106 :                 continue;
; 2107 :         }
; 2108 : 
; 2109 :         float char_width = 0.0f;
; 2110 :         if (const Glyph* glyph = FindGlyph((unsigned short)c))

	mov	ecx, DWORD PTR _this$1$[ebp]
	xorps	xmm0, xmm0
	push	edi
	movss	DWORD PTR _char_width$1$[ebp], xmm0
	call	?FindGlyph@ImFont@@QBEPBUGlyph@1@G@Z	; ImFont::FindGlyph
	mov	DWORD PTR _glyph$1$[ebp], eax
	test	eax, eax
	je	$LN131@RenderText

; 2111 :         {
; 2112 :             if (glyph == FallbackGlyph)

	mov	ecx, DWORD PTR _this$1$[ebp]
	cmp	eax, DWORD PTR [ecx+52]
	jne	$LN32@RenderText

; 2114 :                 static std::unordered_set <unsigned short> unprintable_chars;

	mov	ecx, DWORD PTR fs:__tls_array
	mov	eax, DWORD PTR __tls_index
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	ecx, DWORD PTR ?$TSS0@?DL@??RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z@4HA
	cmp	ecx, DWORD PTR __Init_thread_epoch[edx]
	jle	SHORT $LN10@RenderText
	push	OFFSET ?$TSS0@?DL@??RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z@4HA
	call	__Init_thread_header
	add	esp, 4
	cmp	DWORD PTR ?$TSS0@?DL@??RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z@4HA, -1
	jne	SHORT $LN128@RenderText
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_set

; 90   : 		: _Mybase(key_compare(), allocator_type())

	lea	eax, DWORD PTR $T8[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 2114 :                 static std::unordered_set <unsigned short> unprintable_chars;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_set

; 90   : 		: _Mybase(key_compare(), allocator_type())

	push	eax
	lea	eax, DWORD PTR $T6[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 311  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

	mov	DWORD PTR $T6[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_set

; 90   : 		: _Mybase(key_compare(), allocator_type())

	push	eax
	mov	ecx, OFFSET ?unprintable_chars@?DL@??RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z@4V?$unordered_set@GU?$hash@G@std@@U?$equal_to@G@2@V?$allocator@G@2@@std@@A
	call	??0?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@1@ABV?$allocator@G@1@@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 2114 :                 static std::unordered_set <unsigned short> unprintable_chars;

	push	OFFSET ??__Funprintable_chars@?DL@??RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z@YAXXZ ; `ImFont::RenderText'::`59'::`dynamic atexit destructor for 'unprintable_chars''
	call	_atexit
	push	OFFSET ?$TSS0@?DL@??RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z@4HA
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	__Init_thread_footer
	add	esp, 8
$LN128@RenderText:
	mov	edi, DWORD PTR _c$7[ebp]
$LN10@RenderText:

; 2116 :                 if (! unprintable_chars.count ((unsigned short)c))

	movzx	eax, di
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 635  : 		_Paircc _Ans = equal_range(_Keyval);

	mov	ecx, OFFSET ?unprintable_chars@?DL@??RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z@4V?$unordered_set@GU?$hash@G@std@@U?$equal_to@G@2@V?$allocator@G@2@@std@@A
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 2116 :                 if (! unprintable_chars.count ((unsigned short)c))

	mov	DWORD PTR $T4[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 635  : 		_Paircc _Ans = equal_range(_Keyval);

	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	lea	eax, DWORD PTR __Ans$3[ebp]
	push	eax
	call	?equal_range@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QBE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@V12@@2@ABG@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::equal_range
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1113 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));

	mov	eax, DWORD PTR __Ans$3[ebp]

; 1095 : 	_Iter_diff_t<_InIt> _Off = 0;

	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 297  : 		return (this->_Ptr == _Right._Ptr);

	mov	ecx, DWORD PTR __Ans$3[ebp+4]
	cmp	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1096 : 	for (; _First != _Last; ++_First)

	je	SHORT $LN124@RenderText
$LL84@RenderText:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 242  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1097 : 		++_Off;

	inc	edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 297  : 		return (this->_Ptr == _Right._Ptr);

	cmp	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1096 : 	for (; _First != _Last; ++_First)

	jne	SHORT $LL84@RenderText
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 2116 :                 if (! unprintable_chars.count ((unsigned short)c))

	test	edx, edx
	jne	SHORT $LN133@RenderText
$LN124@RenderText:

; 2117 :                 {
; 2118 :                     unprintable_chars.emplace ((unsigned short)c);

	movzx	eax, di
	mov	ecx, OFFSET ?unprintable_chars@?DL@??RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z@4V?$unordered_set@GU?$hash@G@std@@U?$equal_to@G@2@V?$allocator@G@2@@std@@A
	mov	DWORD PTR $T5[ebp], eax
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??$emplace@G@?$_Hash@V?$_Uset_traits@GV?$_Uhash_compare@GU?$hash@G@std@@U?$equal_to@G@2@@std@@V?$allocator@G@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@G@std@@@std@@@std@@_N@1@$$QAG@Z ; std::_Hash<std::_Uset_traits<unsigned short,std::_Uhash_compare<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short> >,std::allocator<unsigned short>,0> >::emplace<unsigned short>

; 2119 : 
; 2120 :                     // Some characters used for Steam account names are outside the 2-byte range
; 2121 :                     dll_log.Log ( L"[ImGui Font] Unprintable Character: '%wc' (U+%lx)",

	movzx	eax, WORD PTR _c$7[ebp]
	push	eax
	push	eax
	push	OFFSET $SG128600
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	mov	edi, DWORD PTR _c$7[ebp]
	add	esp, 16					; 00000010H
$LN133@RenderText:
	mov	eax, DWORD PTR _glyph$1$[ebp]
$LN32@RenderText:

; 2122 :                                     (wchar_t)c, (wchar_t)c );
; 2123 :                 }
; 2124 :             }
; 2125 : 
; 2126 :             char_width = glyph->XAdvance * scale;

	movss	xmm3, DWORD PTR [eax+4]
	movss	xmm1, DWORD PTR _size$[ebp]
	mulss	xmm3, xmm1

; 2127 : 
; 2128 :             // Arbitrarily assume that both space and tabs are empty glyphs as an optimization
; 2129 :             if (c != ' ' && c != '\t')

	cmp	edi, 32					; 00000020H
	je	$LN34@RenderText
	cmp	edi, 9
	je	$LN34@RenderText

; 2130 :             {
; 2131 :                 // We don't do a second finer clipping test on the Y axis as we've already skipped anything before clip_rect.y and exit once we pass clip_rect.w
; 2132 :                 float x1 = x + glyph->X0 * scale;

	movss	xmm7, DWORD PTR [eax+8]

; 2133 :                 float x2 = x + glyph->X1 * scale;
; 2134 :                 float y1 = y + glyph->Y0 * scale;
; 2135 :                 float y2 = y + glyph->Y1 * scale;
; 2136 :                 if (x1 <= clip_rect.z && x2 >= clip_rect.x)

	mov	ecx, DWORD PTR _clip_rect$[ebp]
	movss	xmm4, DWORD PTR [eax+16]
	movss	xmm6, DWORD PTR [eax+12]
	movss	xmm5, DWORD PTR [eax+20]
	movss	xmm0, DWORD PTR [ecx+8]
	mulss	xmm7, xmm1
	mulss	xmm4, xmm1
	addss	xmm7, DWORD PTR _x$1$[ebp]
	mulss	xmm6, xmm1
	addss	xmm4, DWORD PTR _x$1$[ebp]
	mulss	xmm5, xmm1
	comiss	xmm0, xmm7
	addss	xmm6, DWORD PTR _y$1$[ebp]
	addss	xmm5, DWORD PTR _y$1$[ebp]
	jb	$LN34@RenderText
	movss	xmm0, DWORD PTR [ecx]
	comiss	xmm4, xmm0
	jb	$LN34@RenderText

; 2137 :                 {
; 2138 :                     // Render a character
; 2139 :                     float u1 = glyph->U0;
; 2140 :                     float v1 = glyph->V0;
; 2141 :                     float u2 = glyph->U1;
; 2142 :                     float v2 = glyph->V1;
; 2143 : 
; 2144 :                     // CPU side clipping used to fit text in their frame when the frame is too small. Only does clipping for axis aligned quads.
; 2145 :                     if (cpu_fine_clip)

	cmp	BYTE PTR _cpu_fine_clip$[ebp], 0
	movss	xmm1, DWORD PTR [eax+24]
	movss	xmm2, DWORD PTR [eax+28]
	movss	DWORD PTR _u1$1$[ebp], xmm1
	movss	xmm1, DWORD PTR [eax+32]
	movss	DWORD PTR _u2$1$[ebp], xmm1
	movss	xmm1, DWORD PTR [eax+36]
	movss	DWORD PTR _v2$1$[ebp], xmm1
	movss	xmm1, DWORD PTR _u1$1$[ebp]
	movss	DWORD PTR _v1$1$[ebp], xmm2
	je	$LN40@RenderText

; 2146 :                     {
; 2147 :                         if (x1 < clip_rect.x)

	comiss	xmm0, xmm7
	jbe	SHORT $LN36@RenderText

; 2148 :                         {
; 2149 :                             u1 = u1 + (1.0f - (x2 - clip_rect.x) / (x2 - x1)) * (u2 - u1);

	movaps	xmm1, xmm4
	movss	xmm2, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm4
	subss	xmm0, xmm7

; 2150 :                             x1 = clip_rect.x;

	movss	xmm7, DWORD PTR [ecx]
	divss	xmm1, xmm0
	movss	xmm0, DWORD PTR _u2$1$[ebp]
	subss	xmm0, DWORD PTR _u1$1$[ebp]
	subss	xmm2, xmm1
	mulss	xmm2, xmm0
	addss	xmm2, DWORD PTR _u1$1$[ebp]
	movss	DWORD PTR _u1$1$[ebp], xmm2
	movss	xmm2, DWORD PTR _v1$1$[ebp]
$LN36@RenderText:

; 2151 :                         }
; 2152 :                         if (y1 < clip_rect.y)

	movss	xmm0, DWORD PTR [ecx+4]
	comiss	xmm0, xmm6
	jbe	SHORT $LN37@RenderText

; 2153 :                         {
; 2154 :                             v1 = v1 + (1.0f - (y2 - clip_rect.y) / (y2 - y1)) * (v2 - v1);

	movaps	xmm1, xmm5
	movss	xmm2, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movaps	xmm0, xmm5
	subss	xmm0, xmm6

; 2155 :                             y1 = clip_rect.y;

	movss	xmm6, DWORD PTR [ecx+4]
	divss	xmm1, xmm0
	movss	xmm0, DWORD PTR _v2$1$[ebp]
	subss	xmm0, DWORD PTR _v1$1$[ebp]
	subss	xmm2, xmm1
	mulss	xmm2, xmm0
	addss	xmm2, DWORD PTR _v1$1$[ebp]
$LN37@RenderText:

; 2156 :                         }
; 2157 :                         if (x2 > clip_rect.z)

	movss	xmm0, DWORD PTR [ecx+8]
	comiss	xmm4, xmm0
	jbe	SHORT $LN38@RenderText

; 2158 :                         {
; 2159 :                             u2 = u1 + ((clip_rect.z - x1) / (x2 - x1)) * (u2 - u1);

	subss	xmm4, xmm7
	subss	xmm0, xmm7
	divss	xmm0, xmm4
	movss	xmm4, DWORD PTR _u2$1$[ebp]
	subss	xmm4, DWORD PTR _u1$1$[ebp]
	mulss	xmm0, xmm4

; 2160 :                             x2 = clip_rect.z;

	movss	xmm4, DWORD PTR [ecx+8]
	addss	xmm0, DWORD PTR _u1$1$[ebp]
	movss	DWORD PTR _u2$1$[ebp], xmm0
$LN38@RenderText:

; 2161 :                         }
; 2162 :                         if (y2 > clip_rect.w)

	movss	xmm1, DWORD PTR [ecx+12]
	comiss	xmm5, xmm1
	jbe	SHORT $LN39@RenderText

; 2163 :                         {
; 2164 :                             v2 = v1 + ((clip_rect.w - y1) / (y2 - y1)) * (v2 - v1);

	subss	xmm5, xmm6
	movaps	xmm0, xmm1
	subss	xmm0, xmm6
	divss	xmm0, xmm5
	movss	xmm5, DWORD PTR _v2$1$[ebp]
	subss	xmm5, xmm2
	mulss	xmm0, xmm5

; 2165 :                             y2 = clip_rect.w;

	movaps	xmm5, xmm1
	addss	xmm0, xmm2
	movss	DWORD PTR _v2$1$[ebp], xmm0
$LN39@RenderText:

; 2166 :                         }
; 2167 :                         if (y1 >= y2)

	comiss	xmm6, xmm5
	jb	$LN132@RenderText
$LN34@RenderText:

; 2168 :                         {
; 2169 :                             x += char_width;

	addss	xmm3, DWORD PTR _x$1$[ebp]
	movss	DWORD PTR _x$1$[ebp], xmm3
$LN137@RenderText:
	mov	al, BYTE PTR _word_wrap_enabled$1$[ebp]
$LN134@RenderText:
	mov	edi, DWORD PTR _word_wrap_eol$1$[ebp]
$LN110@RenderText:

; 2047 :     ImDrawIdx* idx_write = draw_list->_IdxWritePtr;
; 2048 :     unsigned int vtx_current_idx = draw_list->_VtxCurrentIdx;
; 2049 : 
; 2050 :     while (s < text_end)

	cmp	esi, ebx
	jb	$LL4@RenderText
$LN130@RenderText:
	mov	eax, DWORD PTR _vtx_write$1$[ebp]
$LN121@RenderText:

; 2186 :                     }
; 2187 :                 }
; 2188 :             }
; 2189 :         }
; 2190 : 
; 2191 :         x += char_width;
; 2192 :     }
; 2193 : 
; 2194 :     // Give back unused vertices
; 2195 :     draw_list->VtxBuffer.resize((int)(vtx_write - draw_list->VtxBuffer.Data));

	mov	ebx, DWORD PTR _draw_list$[ebp]
	mov	ecx, eax
	mov	eax, 1717986919				; 66666667H
	sub	ecx, DWORD PTR [ebx+32]
	imul	ecx
	lea	ecx, DWORD PTR [ebx+24]
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	eax
	call	?resize@?$ImVector@UImDrawVert@@@@QAEXH@Z ; ImVector<ImDrawVert>::resize

; 2196 :     draw_list->IdxBuffer.resize((int)(idx_write - draw_list->IdxBuffer.Data));

	mov	edi, DWORD PTR _idx_write$1$[ebp]
	lea	ecx, DWORD PTR [ebx+12]
	mov	eax, edi
	sub	eax, DWORD PTR [ebx+20]
	sar	eax, 1
	push	eax
	call	?resize@?$ImVector@G@@QAEXH@Z		; ImVector<unsigned short>::resize

; 2197 :     draw_list->CmdBuffer[draw_list->CmdBuffer.Size-1].ElemCount -= (idx_expected_size - draw_list->IdxBuffer.Size);

	mov	edx, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [ebx+8]
	mov	eax, DWORD PTR [ebx+12]
	sub	eax, DWORD PTR _idx_expected_size$1$[ebp]
	shl	edx, 5
	add	DWORD PTR [edx+ecx-32], eax

; 2198 :     draw_list->_VtxWritePtr = vtx_write;

	mov	eax, DWORD PTR _vtx_write$1$[ebp]
	mov	DWORD PTR [ebx+44], eax

; 2199 :     draw_list->_IdxWritePtr = idx_write;
; 2200 :     draw_list->_VtxCurrentIdx = (unsigned int)draw_list->VtxBuffer.Size;

	mov	eax, DWORD PTR [ebx+24]
	mov	DWORD PTR [ebx+48], edi
	mov	DWORD PTR [ebx+40], eax
$LN1@RenderText:

; 2201 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	40					; 00000028H
$LN132@RenderText:
	movss	xmm1, DWORD PTR _u1$1$[ebp]
$LN40@RenderText:

; 2170 :                             continue;
; 2171 :                         }
; 2172 :                     }
; 2173 : 
; 2174 :                     // We are NOT calling PrimRectUV() here because non-inlined causes too much overhead in a debug build.
; 2175 :                     // Inlined here:
; 2176 :                     {
; 2177 :                         idx_write[0] = (ImDrawIdx)(vtx_current_idx); idx_write[1] = (ImDrawIdx)(vtx_current_idx+1); idx_write[2] = (ImDrawIdx)(vtx_current_idx+2);

	mov	edx, DWORD PTR _idx_write$1$[ebp]
	mov	edi, DWORD PTR _vtx_current_idx$1$[ebp]

; 2178 :                         idx_write[3] = (ImDrawIdx)(vtx_current_idx); idx_write[4] = (ImDrawIdx)(vtx_current_idx+2); idx_write[5] = (ImDrawIdx)(vtx_current_idx+3);
; 2179 :                         vtx_write[0].pos.x = x1; vtx_write[0].pos.y = y1; vtx_write[0].col = col; vtx_write[0].uv.x = u1; vtx_write[0].uv.y = v1;
; 2180 :                         vtx_write[1].pos.x = x2; vtx_write[1].pos.y = y1; vtx_write[1].col = col; vtx_write[1].uv.x = u2; vtx_write[1].uv.y = v1;

	movss	xmm0, DWORD PTR _u2$1$[ebp]
	movzx	ecx, di

; 2181 :                         vtx_write[2].pos.x = x2; vtx_write[2].pos.y = y2; vtx_write[2].col = col; vtx_write[2].uv.x = u2; vtx_write[2].uv.y = v2;
; 2182 :                         vtx_write[3].pos.x = x1; vtx_write[3].pos.y = y2; vtx_write[3].col = col; vtx_write[3].uv.x = u1; vtx_write[3].uv.y = v2;
; 2183 :                         vtx_write += 4;
; 2184 :                         vtx_current_idx += 4;

	add	edi, 4
	mov	WORD PTR [edx], cx
	mov	WORD PTR [edx+6], cx
	mov	DWORD PTR _vtx_current_idx$1$[ebp], edi
	lea	eax, DWORD PTR [ecx+1]
	mov	WORD PTR [edx+2], ax
	lea	eax, DWORD PTR [ecx+2]
	mov	WORD PTR [edx+4], ax
	mov	WORD PTR [edx+8], ax
	lea	eax, DWORD PTR [ecx+3]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	WORD PTR [edx+10], ax
	mov	eax, DWORD PTR _vtx_write$1$[ebp]
	movss	DWORD PTR [eax+28], xmm0
	movss	DWORD PTR [eax+48], xmm0
	movss	xmm0, DWORD PTR _v2$1$[ebp]
	movss	DWORD PTR [eax], xmm7
	movss	DWORD PTR [eax+4], xmm6
	mov	DWORD PTR [eax+16], ecx
	movss	DWORD PTR [eax+8], xmm1
	movss	DWORD PTR [eax+12], xmm2
	movss	DWORD PTR [eax+20], xmm4
	movss	DWORD PTR [eax+24], xmm6
	mov	DWORD PTR [eax+36], ecx
	movss	DWORD PTR [eax+32], xmm2
	movss	DWORD PTR [eax+40], xmm4
	movss	DWORD PTR [eax+44], xmm5
	mov	DWORD PTR [eax+56], ecx
	movss	DWORD PTR [eax+52], xmm0
	movss	DWORD PTR [eax+60], xmm7
	movss	DWORD PTR [eax+64], xmm5
	mov	DWORD PTR [eax+76], ecx
	movss	DWORD PTR [eax+68], xmm1
	movss	DWORD PTR [eax+72], xmm0
	add	eax, 80					; 00000050H

; 2185 :                         idx_write += 6;

	add	edx, 12					; 0000000cH
	mov	DWORD PTR _vtx_write$1$[ebp], eax
	mov	DWORD PTR _idx_write$1$[ebp], edx
	jmp	$LN34@RenderText
$LN131@RenderText:
	movss	xmm3, DWORD PTR _char_width$1$[ebp]
	jmp	$LN34@RenderText
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z$0:
	push	OFFSET ?$TSS0@?DL@??RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z@4HA
	call	__Init_thread_abort
	pop	ecx
	ret	0
__ehhandler$?RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z ENDP ; ImFont::RenderText
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_pos_tl$1 = -32						; size = 8
_pos_br$2 = -24						; size = 8
$T3 = -16						; size = 8
$T4 = -8						; size = 8
_draw_list$ = 8						; size = 4
_size$ = 12						; size = 4
_pos$ = 16						; size = 8
_col$ = 24						; size = 4
_c$ = 28						; size = 2
?RenderChar@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IG@Z PROC ; ImFont::RenderChar
; _this$ = ecx

; 1998 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1999 :     if (c == ' ' || c == '\t' || c == '\n' || c == '\r') // Match behavior of RenderText(), those 4 codepoints are hard-coded.

	mov	eax, DWORD PTR _c$[ebp]
	sub	esp, 32					; 00000020H
	push	esi
	mov	esi, ecx
	cmp	ax, 32					; 00000020H
	je	$LN3@RenderChar
	cmp	ax, 9
	je	$LN3@RenderChar
	cmp	ax, 10					; 0000000aH
	je	$LN3@RenderChar
	cmp	ax, 13					; 0000000dH
	je	$LN3@RenderChar

; 2000 :         return;
; 2001 :     if (const Glyph* glyph = FindGlyph(c))

	push	edi
	push	eax
	call	?FindGlyph@ImFont@@QBEPBUGlyph@1@G@Z	; ImFont::FindGlyph
	mov	edi, eax
	test	edi, edi
	je	$LN16@RenderChar

; 2002 :     {
; 2003 :         float scale = (size >= 0.0f) ? (size / FontSize) : 1.0f;

	movss	xmm3, DWORD PTR _size$[ebp]
	comiss	xmm3, DWORD PTR __real@00000000
	jb	SHORT $LN6@RenderChar
	divss	xmm3, DWORD PTR [esi]
	jmp	SHORT $LN7@RenderChar
$LN6@RenderChar:
	movss	xmm3, DWORD PTR __real@3f800000
$LN7@RenderChar:

; 2004 :         pos.x = (float)(int)pos.x + DisplayOffset.x;

	cvttss2si eax, DWORD PTR _pos$[ebp]

; 2008 :         draw_list->PrimReserve(6, 4);

	mov	ecx, DWORD PTR _draw_list$[ebp]
	push	4
	push	6
	movd	xmm2, eax
	cvttss2si eax, DWORD PTR _pos$[ebp+4]
	cvtdq2ps xmm2, xmm2
	movd	xmm1, eax
	addss	xmm2, DWORD PTR [esi+8]
	cvtdq2ps xmm1, xmm1
	movss	DWORD PTR _pos$[ebp], xmm2
	addss	xmm1, DWORD PTR [esi+12]
	movss	DWORD PTR _pos$[ebp+4], xmm1
	movss	xmm0, DWORD PTR [edi+8]
	mulss	xmm0, xmm3
	addss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _pos_tl$1[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 2006 :         ImVec2 pos_tl(pos.x + glyph->X0 * scale, pos.y + glyph->Y0 * scale);

	movss	xmm0, DWORD PTR [edi+12]
	mulss	xmm0, xmm3
	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _pos_tl$1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 2007 :         ImVec2 pos_br(pos.x + glyph->X1 * scale, pos.y + glyph->Y1 * scale);

	movss	xmm0, DWORD PTR [edi+16]
	mulss	xmm0, xmm3
	addss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _pos_br$2[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 2007 :         ImVec2 pos_br(pos.x + glyph->X1 * scale, pos.y + glyph->Y1 * scale);

	movss	xmm0, DWORD PTR [edi+20]
	mulss	xmm0, xmm3
	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _pos_br$2[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 2008 :         draw_list->PrimReserve(6, 4);

	call	?PrimReserve@ImDrawList@@QAEXHH@Z	; ImDrawList::PrimReserve

; 2009 :         draw_list->PrimRectUV(pos_tl, pos_br, ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V1), col);

	push	DWORD PTR _col$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR [edi+32]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 2009 :         draw_list->PrimRectUV(pos_tl, pos_br, ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V1), col);

	lea	eax, DWORD PTR $T4[ebp]
	mov	ecx, DWORD PTR _draw_list$[ebp]
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 2009 :         draw_list->PrimRectUV(pos_tl, pos_br, ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V1), col);

	lea	eax, DWORD PTR $T3[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR [edi+36]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 2009 :         draw_list->PrimRectUV(pos_tl, pos_br, ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V1), col);

	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 2009 :         draw_list->PrimRectUV(pos_tl, pos_br, ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V1), col);

	lea	eax, DWORD PTR _pos_br$2[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR [edi+24]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 2009 :         draw_list->PrimRectUV(pos_tl, pos_br, ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V1), col);

	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 2009 :         draw_list->PrimRectUV(pos_tl, pos_br, ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V1), col);

	lea	eax, DWORD PTR _pos_tl$1[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR [edi+28]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 2009 :         draw_list->PrimRectUV(pos_tl, pos_br, ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V1), col);

	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 2009 :         draw_list->PrimRectUV(pos_tl, pos_br, ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V1), col);

	call	?PrimRectUV@ImDrawList@@QAEXABUImVec2@@000I@Z ; ImDrawList::PrimRectUV
$LN16@RenderChar:
	pop	edi
$LN3@RenderChar:
	pop	esi

; 2010 :     }
; 2011 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?RenderChar@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IG@Z ENDP ; ImFont::RenderChar
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_prev_word_end$1$ = -20					; size = 4
_this$1$ = -16						; size = 4
_blank_width$1$ = -12					; size = 4
_line_width$1$ = -8					; size = 4
_word_width$1$ = -4					; size = 4
_scale$ = 8						; size = 4
_c$1 = 12						; size = 4
_text$ = 12						; size = 4
_text_end$ = 16						; size = 4
_wrap_width$ = 20					; size = 4
?CalcWordWrapPositionA@ImFont@@QBEPBDMPBD0M@Z PROC	; ImFont::CalcWordWrapPositionA
; _this$ = ecx

; 1806 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 1807 :     // Simple word-wrapping for English, not full-featured. Please submit failing cases!
; 1808 :     // FIXME: Much possible improvements (don't cut things like "word !", "word!!!" but cut within "word,,,,", more sensible support for punctuations, support for Unicode punctuations, etc.)
; 1809 : 
; 1810 :     // For references, possible wrap point marked with ^
; 1811 :     //  "aaa bbb, ccc,ddd. eee   fff. ggg!"
; 1812 :     //      ^    ^    ^   ^   ^__    ^    ^
; 1813 : 
; 1814 :     // List of hardcoded separators: .,;!?'"
; 1815 : 
; 1816 :     // Skip extra blanks after a line returns (that includes not counting them in width computation)
; 1817 :     // e.g. "Hello    world" --> "Hello" "World"
; 1818 : 
; 1819 :     // Cut words that cannot possibly fit within one line.
; 1820 :     // e.g.: "The tropical fish" with ~5 characters worth of width --> "The tr" "opical" "fish"
; 1821 : 
; 1822 :     float line_width = 0.0f;
; 1823 :     float word_width = 0.0f;
; 1824 :     float blank_width = 0.0f;
; 1825 : 
; 1826 :     const char* word_end = text;
; 1827 :     const char* prev_word_end = NULL;
; 1828 :     bool inside_word = true;
; 1829 : 
; 1830 :     const char* s = text;
; 1831 :     while (s < text_end)

	mov	edx, DWORD PTR _text_end$[ebp]
	mov	eax, ecx
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _text$[ebp]
	xor	ecx, ecx
	mov	DWORD PTR _this$1$[ebp], eax
	xorps	xmm3, xmm3
	movss	DWORD PTR _line_width$1$[ebp], xmm3
	xorps	xmm2, xmm2
	movss	DWORD PTR _word_width$1$[ebp], xmm2
	xorps	xmm1, xmm1
	movss	DWORD PTR _blank_width$1$[ebp], xmm1
	mov	bl, 1
	mov	DWORD PTR _prev_word_end$1$[ebp], ecx
	mov	esi, edi
	cmp	edi, edx
	jb	SHORT $LN2@CalcWordWr
$LN38@CalcWordWr:
	pop	edi

; 1894 :             break;
; 1895 :         }
; 1896 : 
; 1897 :         s = next_s;
; 1898 :     }
; 1899 : 
; 1900 :     return s;

	mov	eax, esi
	pop	esi
	pop	ebx

; 1901 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LL40@CalcWordWr:
	mov	edx, DWORD PTR _text_end$[ebp]
$LN2@CalcWordWr:

; 1832 :     {
; 1833 :         unsigned int c = (unsigned int)*s;

	movsx	ecx, BYTE PTR [esi]
	mov	DWORD PTR _c$1[ebp], ecx

; 1834 :         const char* next_s;
; 1835 :         if (c < 0x80)

	cmp	ecx, 128				; 00000080H
	jae	SHORT $LN4@CalcWordWr

; 1836 :             next_s = s + 1;

	lea	edx, DWORD PTR [esi+1]

; 1837 :         else

	jmp	SHORT $LN5@CalcWordWr
$LN4@CalcWordWr:

; 1838 :             next_s = s + ImTextCharFromUtf8(&c, s, text_end);

	push	edx
	lea	eax, DWORD PTR _c$1[ebp]
	push	esi
	push	eax
	call	?ImTextCharFromUtf8@@YAHPAIPBD1@Z	; ImTextCharFromUtf8
	mov	ecx, DWORD PTR _c$1[ebp]
	add	esp, 12					; 0000000cH
	movss	xmm1, DWORD PTR _blank_width$1$[ebp]
	movss	xmm2, DWORD PTR _word_width$1$[ebp]
	movss	xmm3, DWORD PTR _line_width$1$[ebp]
	lea	edx, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR _this$1$[ebp]
$LN5@CalcWordWr:

; 1839 :         if (c == 0)

	test	ecx, ecx
	je	SHORT $LN38@CalcWordWr

; 1840 :             break;
; 1841 : 
; 1842 :         if (c < 32)

	cmp	ecx, 32					; 00000020H
	jae	SHORT $LN9@CalcWordWr

; 1843 :         {
; 1844 :             if (c == '\n')

	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN8@CalcWordWr

; 1845 :             {
; 1846 :                 line_width = word_width = blank_width = 0.0f;

	xorps	xmm1, xmm1
	xorps	xmm2, xmm2
	xorps	xmm3, xmm3
	movss	DWORD PTR _blank_width$1$[ebp], xmm1
	movss	DWORD PTR _word_width$1$[ebp], xmm2

; 1847 :                 inside_word = true;

	mov	bl, 1
	movss	DWORD PTR _line_width$1$[ebp], xmm3

; 1848 :                 s = next_s;
; 1849 :                 continue;

	jmp	$LN33@CalcWordWr
$LN8@CalcWordWr:

; 1850 :             }
; 1851 :             if (c == '\r')

	cmp	ecx, 13					; 0000000dH
	je	$LN33@CalcWordWr
$LN9@CalcWordWr:

; 1852 :             {
; 1853 :                 s = next_s;
; 1854 :                 continue;
; 1855 :             }
; 1856 :         }
; 1857 : 
; 1858 :         const float char_width = ((int)c < IndexXAdvance.Size ? IndexXAdvance[(int)c] : FallbackXAdvance) * scale;

	cmp	ecx, DWORD PTR [eax+28]
	jge	SHORT $LN18@CalcWordWr
	mov	eax, DWORD PTR [eax+36]
	movss	xmm0, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$1$[ebp]
	jmp	SHORT $LN19@CalcWordWr
$LN18@CalcWordWr:
	movss	xmm0, DWORD PTR [eax+56]
$LN19@CalcWordWr:
	mulss	xmm0, DWORD PTR _scale$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 96   : static inline bool      ImCharIsSpace(int c)            { return c == ' ' || c == '\t' || c == 0x3000; }

	cmp	ecx, 32					; 00000020H
	je	SHORT $LN26@CalcWordWr
	cmp	ecx, 9
	je	SHORT $LN26@CalcWordWr
	cmp	ecx, 12288				; 00003000H
	je	SHORT $LN26@CalcWordWr
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1872 :             word_width += char_width;

	addss	xmm0, xmm2
	movss	DWORD PTR _word_width$1$[ebp], xmm0

; 1873 :             if (inside_word)

	test	bl, bl
	je	SHORT $LN13@CalcWordWr

; 1874 :             {
; 1875 :                 word_end = next_s;

	mov	edi, edx

; 1876 :             }
; 1877 :             else

	jmp	SHORT $LN14@CalcWordWr
$LN13@CalcWordWr:

; 1878 :             {
; 1879 :                 prev_word_end = word_end;
; 1880 :                 line_width += word_width + blank_width;

	addss	xmm1, xmm0
	mov	DWORD PTR _prev_word_end$1$[ebp], edi
	xorps	xmm0, xmm0

; 1881 :                 word_width = blank_width = 0.0f;

	movss	DWORD PTR _word_width$1$[ebp], xmm0
	addss	xmm3, xmm1
	xorps	xmm1, xmm1
	movss	DWORD PTR _blank_width$1$[ebp], xmm1
	movss	DWORD PTR _line_width$1$[ebp], xmm3
$LN14@CalcWordWr:

; 1882 :             }
; 1883 : 
; 1884 :             // Allow wrapping after punctuation.
; 1885 :             inside_word = !(c == '.' || c == ',' || c == ';' || c == '!' || c == '?' || c == '\"');

	cmp	ecx, 46					; 0000002eH
	je	SHORT $LN20@CalcWordWr
	cmp	ecx, 44					; 0000002cH
	je	SHORT $LN20@CalcWordWr
	cmp	ecx, 59					; 0000003bH
	je	SHORT $LN20@CalcWordWr
	cmp	ecx, 33					; 00000021H
	je	SHORT $LN20@CalcWordWr
	cmp	ecx, 63					; 0000003fH
	je	SHORT $LN20@CalcWordWr
	cmp	ecx, 34					; 00000022H
	je	SHORT $LN20@CalcWordWr
	movss	xmm2, DWORD PTR _word_width$1$[ebp]
	mov	bl, 1
	jmp	SHORT $LN21@CalcWordWr
$LN20@CalcWordWr:
	movss	xmm2, DWORD PTR _word_width$1$[ebp]
	jmp	SHORT $LN41@CalcWordWr
$LN26@CalcWordWr:

; 1859 :         if (ImCharIsSpace(c))
; 1860 :         {
; 1861 :             if (inside_word)

	test	bl, bl
	je	SHORT $LN12@CalcWordWr

; 1862 :             {
; 1863 :                 line_width += blank_width;

	addss	xmm3, xmm1

; 1864 :                 blank_width = 0.0f;
; 1865 :                 word_end = s;

	mov	edi, esi
	xorps	xmm1, xmm1
	movss	DWORD PTR _line_width$1$[ebp], xmm3
$LN12@CalcWordWr:

; 1866 :             }
; 1867 :             blank_width += char_width;

	addss	xmm1, xmm0
	movss	DWORD PTR _blank_width$1$[ebp], xmm1
$LN41@CalcWordWr:

; 1868 :             inside_word = false;

	xor	bl, bl
$LN21@CalcWordWr:

; 1886 :         }
; 1887 : 
; 1888 :         // We ignore blank width at the end of the line (they can be skipped)
; 1889 :         if (line_width + word_width >= wrap_width)

	movss	xmm4, DWORD PTR _wrap_width$[ebp]
	movaps	xmm0, xmm2
	addss	xmm0, xmm3
	comiss	xmm0, xmm4
	jae	SHORT $LN32@CalcWordWr
$LN33@CalcWordWr:
	mov	esi, edx

; 1807 :     // Simple word-wrapping for English, not full-featured. Please submit failing cases!
; 1808 :     // FIXME: Much possible improvements (don't cut things like "word !", "word!!!" but cut within "word,,,,", more sensible support for punctuations, support for Unicode punctuations, etc.)
; 1809 : 
; 1810 :     // For references, possible wrap point marked with ^
; 1811 :     //  "aaa bbb, ccc,ddd. eee   fff. ggg!"
; 1812 :     //      ^    ^    ^   ^   ^__    ^    ^
; 1813 : 
; 1814 :     // List of hardcoded separators: .,;!?'"
; 1815 : 
; 1816 :     // Skip extra blanks after a line returns (that includes not counting them in width computation)
; 1817 :     // e.g. "Hello    world" --> "Hello" "World"
; 1818 : 
; 1819 :     // Cut words that cannot possibly fit within one line.
; 1820 :     // e.g.: "The tropical fish" with ~5 characters worth of width --> "The tr" "opical" "fish"
; 1821 : 
; 1822 :     float line_width = 0.0f;
; 1823 :     float word_width = 0.0f;
; 1824 :     float blank_width = 0.0f;
; 1825 : 
; 1826 :     const char* word_end = text;
; 1827 :     const char* prev_word_end = NULL;
; 1828 :     bool inside_word = true;
; 1829 : 
; 1830 :     const char* s = text;
; 1831 :     while (s < text_end)

	cmp	edx, DWORD PTR _text_end$[ebp]
	jb	$LL40@CalcWordWr

; 1894 :             break;
; 1895 :         }
; 1896 : 
; 1897 :         s = next_s;
; 1898 :     }
; 1899 : 
; 1900 :     return s;

	pop	edi
	pop	esi
	mov	eax, edx
	pop	ebx

; 1901 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN32@CalcWordWr:

; 1890 :         {
; 1891 :             // Words that cannot possibly fit within an entire line will be cut anywhere.
; 1892 :             if (word_width < wrap_width)

	comiss	xmm4, xmm2
	jbe	$LN38@CalcWordWr

; 1893 :                 s = prev_word_end ? prev_word_end : word_end;

	mov	ecx, DWORD PTR _prev_word_end$1$[ebp]
	test	ecx, ecx
	cmovne	edi, ecx

; 1894 :             break;
; 1895 :         }
; 1896 : 
; 1897 :         s = next_s;
; 1898 :     }
; 1899 : 
; 1900 :     return s;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 1901 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?CalcWordWrapPositionA@ImFont@@QBEPBDMPBD0M@Z ENDP	; ImFont::CalcWordWrapPositionA
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_prev_s$1$ = -16					; size = 4
_this$1$ = -12						; size = 4
_c$1 = -8						; size = 4
_scale$1$ = -4						; size = 4
_word_wrap_eol$1$ = 8					; size = 4
___$ReturnUdt$ = 8					; size = 4
_size$ = 12						; size = 4
_max_width$ = 16					; size = 4
_wrap_width$ = 20					; size = 4
_line_width$1$ = 24					; size = 4
_text_begin$ = 24					; size = 4
_text_end$ = 28						; size = 4
_word_wrap_enabled$1$ = 31				; size = 1
_remaining$ = 32					; size = 4
?CalcTextSizeA@ImFont@@QBE?AUImVec2@@MMMPBD0PAPBD@Z PROC ; ImFont::CalcTextSizeA
; _this$ = ecx

; 1904 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx

; 1905 :     if (!text_end)

	mov	ebx, DWORD PTR _text_end$[ebp]
	mov	DWORD PTR _this$1$[ebp], ecx
	push	esi
	mov	esi, DWORD PTR _text_begin$[ebp]
	push	edi
	test	ebx, ebx
	jne	SHORT $LN6@CalcTextSi

; 1906 :         text_end = text_begin + strlen(text_begin); // FIXME-OPT: Need to avoid this.

	mov	edx, esi
	lea	edi, DWORD PTR [edx+1]
	npad	3
$LL58@CalcTextSi:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL58@CalcTextSi
	sub	edx, edi
	lea	ebx, DWORD PTR [edx+esi]
$LN6@CalcTextSi:

; 1907 : 
; 1908 :     const float line_height = size;
; 1909 :     const float scale = size / FontSize;

	movss	xmm3, DWORD PTR _size$[ebp]
	xorps	xmm2, xmm2

; 1914 :     const bool word_wrap_enabled = (wrap_width > 0.0f);

	movss	xmm5, DWORD PTR _wrap_width$[ebp]
	movaps	xmm4, xmm3
	divss	xmm4, DWORD PTR [ecx]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edi], 0
	mov	DWORD PTR [edi+4], 0
	xorps	xmm1, xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1914 :     const bool word_wrap_enabled = (wrap_width > 0.0f);

	comiss	xmm5, xmm2
	movss	DWORD PTR _scale$1$[ebp], xmm4
	movss	DWORD PTR _line_width$1$[ebp], xmm1
	seta	al

; 1915 :     const char* word_wrap_eol = NULL;

	xor	edx, edx
	mov	BYTE PTR _word_wrap_enabled$1$[ebp], al
	mov	DWORD PTR _word_wrap_eol$1$[ebp], edx

; 1916 : 
; 1917 :     const char* s = text_begin;
; 1918 :     while (s < text_end)

	cmp	esi, ebx
	jae	$LN3@CalcTextSi
$LL2@CalcTextSi:

; 1919 :     {
; 1920 :         if (word_wrap_enabled)

	test	al, al
	je	$LN10@CalcTextSi

; 1921 :         {
; 1922 :             // Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
; 1923 :             if (!word_wrap_eol)

	test	edx, edx
	jne	SHORT $LN9@CalcTextSi

; 1924 :             {
; 1925 :                 word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - line_width);

	movaps	xmm0, xmm5
	subss	xmm0, xmm1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ebx
	push	esi
	push	ecx
	movss	DWORD PTR [esp], xmm4
	call	?CalcWordWrapPositionA@ImFont@@QBEPBDMPBD0M@Z ; ImFont::CalcWordWrapPositionA
	movss	xmm1, DWORD PTR _line_width$1$[ebp]
	mov	edx, eax
	movss	xmm3, DWORD PTR _size$[ebp]
	xorps	xmm2, xmm2
	movss	xmm4, DWORD PTR _scale$1$[ebp]
	mov	DWORD PTR _word_wrap_eol$1$[ebp], edx

; 1926 :                 if (word_wrap_eol == s) // Wrap_width is too small to fit anything. Force displaying 1 character to minimize the height discontinuity.

	cmp	esi, edx
	jne	SHORT $LN65@CalcTextSi

; 1927 :                     word_wrap_eol++;    // +1 may not be a character start point in UTF-8 but it's ok because we use s >= word_wrap_eol below

	inc	edx
	mov	DWORD PTR _word_wrap_eol$1$[ebp], edx
$LN9@CalcTextSi:

; 1928 :             }
; 1929 : 
; 1930 :             if (s >= word_wrap_eol)

	cmp	esi, edx
$LN65@CalcTextSi:
	jb	SHORT $LN10@CalcTextSi

; 1931 :             {
; 1932 :                 if (text_size.x < line_width)

	comiss	xmm1, DWORD PTR [edi]
	jbe	SHORT $LN11@CalcTextSi

; 1933 :                     text_size.x = line_width;

	movss	DWORD PTR [edi], xmm1
$LN11@CalcTextSi:

; 1934 :                 text_size.y += line_height;

	movss	xmm0, DWORD PTR [edi+4]

; 1935 :                 line_width = 0.0f;

	movaps	xmm1, xmm2
	addss	xmm0, xmm3
	movss	DWORD PTR _line_width$1$[ebp], xmm1

; 1936 :                 word_wrap_eol = NULL;

	xor	edx, edx
	mov	DWORD PTR _word_wrap_eol$1$[ebp], edx
	movss	DWORD PTR [edi+4], xmm0
$LL4@CalcTextSi:

; 1940 :                 {
; 1941 :                     const char c = *s;

	mov	cl, BYTE PTR [esi]

; 1942 :                     if (ImCharIsSpace(c)) { s++; } else if (c == '\n') { s++; break; } else { break; }

	movsx	eax, cl
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 96   : static inline bool      ImCharIsSpace(int c)            { return c == ' ' || c == '\t' || c == 0x3000; }

	cmp	eax, 32					; 00000020H
	je	SHORT $LN34@CalcTextSi
	cmp	eax, 9
	je	SHORT $LN34@CalcTextSi
	cmp	eax, 12288				; 00003000H
	jne	SHORT $LN57@CalcTextSi
$LN34@CalcTextSi:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1942 :                     if (ImCharIsSpace(c)) { s++; } else if (c == '\n') { s++; break; } else { break; }

	inc	esi
	cmp	esi, ebx
	jb	SHORT $LL4@CalcTextSi

; 1937 : 
; 1938 :                 // Wrapping skips upcoming blanks
; 1939 :                 while (s < text_end)

	jmp	$LN3@CalcTextSi
$LN57@CalcTextSi:

; 1942 :                     if (ImCharIsSpace(c)) { s++; } else if (c == '\n') { s++; break; } else { break; }

	cmp	cl, 10					; 0000000aH
	jne	$LN49@CalcTextSi
	inc	esi

; 1943 :                 }
; 1944 :                 continue;

	jmp	$LN49@CalcTextSi
$LN10@CalcTextSi:

; 1945 :             }
; 1946 :         }
; 1947 : 
; 1948 :         // Decode and advance source
; 1949 :         const char* prev_s = s;
; 1950 :         unsigned int c = (unsigned int)*s;

	movsx	ecx, BYTE PTR [esi]
	mov	edx, esi
	mov	DWORD PTR _prev_s$1$[ebp], edx
	mov	DWORD PTR _c$1[ebp], ecx

; 1951 :         if (c < 0x80)

	cmp	ecx, 128				; 00000080H
	jae	SHORT $LN16@CalcTextSi

; 1952 :         {
; 1953 :             s += 1;

	inc	esi

; 1954 :         }
; 1955 :         else

	jmp	SHORT $LN18@CalcTextSi
$LN16@CalcTextSi:

; 1956 :         {
; 1957 :             s += ImTextCharFromUtf8(&c, s, text_end);

	push	ebx
	lea	eax, DWORD PTR _c$1[ebp]
	push	esi
	push	eax
	call	?ImTextCharFromUtf8@@YAHPAIPBD1@Z	; ImTextCharFromUtf8

; 1958 :             if (c == 0) // Malformed UTF-8?

	mov	ecx, DWORD PTR _c$1[ebp]
	add	esp, 12					; 0000000cH
	add	esi, eax
	test	ecx, ecx
	je	$LN60@CalcTextSi
	mov	edx, DWORD PTR _prev_s$1$[ebp]
$LN18@CalcTextSi:

; 1959 :                 break;
; 1960 :         }
; 1961 : 
; 1962 :         if (c < 32)

	cmp	ecx, 32					; 00000020H
	jae	SHORT $LN21@CalcTextSi

; 1963 :         {
; 1964 :             if (c == '\n')

	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN20@CalcTextSi

; 1965 :             {
; 1966 :                 text_size.x = ImMax(text_size.x, line_width);
; 1967 :                 text_size.y += line_height;

	movss	xmm0, DWORD PTR _line_width$1$[ebp]
	xorps	xmm1, xmm1
	maxss	xmm0, DWORD PTR [edi]
	movss	xmm3, DWORD PTR _size$[ebp]

; 1968 :                 line_width = 0.0f;

	movss	DWORD PTR _line_width$1$[ebp], xmm1
	movss	DWORD PTR [edi], xmm0
	movss	xmm0, DWORD PTR [edi+4]
	addss	xmm0, xmm3
	movss	DWORD PTR [edi+4], xmm0

; 1969 :                 continue;

	jmp	SHORT $LN63@CalcTextSi
$LN20@CalcTextSi:

; 1970 :             }
; 1971 :             if (c == '\r')

	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN61@CalcTextSi
$LN21@CalcTextSi:

; 1972 :                 continue;
; 1973 :         }
; 1974 : 
; 1975 :         const float char_width = ((int)c < IndexXAdvance.Size ? IndexXAdvance[(int)c] : FallbackXAdvance) * scale;

	mov	eax, DWORD PTR _this$1$[ebp]
	cmp	ecx, DWORD PTR [eax+28]
	jge	SHORT $LN28@CalcTextSi
	mov	eax, DWORD PTR [eax+36]
	movss	xmm0, DWORD PTR [eax+ecx*4]
	jmp	SHORT $LN29@CalcTextSi
$LN28@CalcTextSi:
	movss	xmm0, DWORD PTR [eax+56]
$LN29@CalcTextSi:
	movss	xmm4, DWORD PTR _scale$1$[ebp]

; 1976 :         if (line_width + char_width >= max_width)

	movss	xmm1, DWORD PTR _line_width$1$[ebp]
	mulss	xmm0, xmm4
	addss	xmm0, xmm1
	comiss	xmm0, DWORD PTR _max_width$[ebp]
	jae	SHORT $LN48@CalcTextSi

; 1979 :             break;
; 1980 :         }
; 1981 : 
; 1982 :         line_width += char_width;

	movss	xmm3, DWORD PTR _size$[ebp]
	movaps	xmm1, xmm0
	movss	DWORD PTR _line_width$1$[ebp], xmm1
	jmp	SHORT $LN64@CalcTextSi
$LN61@CalcTextSi:
	movss	xmm1, DWORD PTR _line_width$1$[ebp]
	movss	xmm3, DWORD PTR _size$[ebp]
$LN63@CalcTextSi:
	movss	xmm4, DWORD PTR _scale$1$[ebp]
$LN64@CalcTextSi:
	mov	edx, DWORD PTR _word_wrap_eol$1$[ebp]
	xorps	xmm2, xmm2
$LN49@CalcTextSi:

; 1916 : 
; 1917 :     const char* s = text_begin;
; 1918 :     while (s < text_end)

	movss	xmm5, DWORD PTR _wrap_width$[ebp]
	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	al, BYTE PTR _word_wrap_enabled$1$[ebp]
	cmp	esi, ebx
	jb	$LL2@CalcTextSi

; 1976 :         if (line_width + char_width >= max_width)

	jmp	SHORT $LN3@CalcTextSi
$LN48@CalcTextSi:

; 1977 :         {
; 1978 :             s = prev_s;

	mov	esi, edx
	jmp	SHORT $LN3@CalcTextSi
$LN60@CalcTextSi:
	movss	xmm1, DWORD PTR _line_width$1$[ebp]
$LN3@CalcTextSi:

; 1983 :     }
; 1984 : 
; 1985 :     if (text_size.x < line_width)

	comiss	xmm1, DWORD PTR [edi]
	jbe	SHORT $LN23@CalcTextSi

; 1986 :         text_size.x = line_width;

	movss	DWORD PTR [edi], xmm1
$LN23@CalcTextSi:
	xorps	xmm2, xmm2

; 1987 : 
; 1988 :     if (line_width > 0 || text_size.y == 0.0f)

	comiss	xmm1, xmm2
	ja	SHORT $LN25@CalcTextSi
	movss	xmm0, DWORD PTR [edi+4]
	ucomiss	xmm0, xmm2
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN24@CalcTextSi
$LN25@CalcTextSi:

; 1989 :         text_size.y += line_height;

	movss	xmm0, DWORD PTR [edi+4]
	addss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR [edi+4], xmm0
$LN24@CalcTextSi:

; 1990 : 
; 1991 :     if (remaining)

	mov	ecx, DWORD PTR _remaining$[ebp]

; 1993 : 
; 1994 :     return text_size;

	mov	eax, edi
	test	ecx, ecx
	je	SHORT $LN26@CalcTextSi

; 1992 :         *remaining = s;

	mov	DWORD PTR [ecx], esi
$LN26@CalcTextSi:
	pop	edi
	pop	esi
	pop	ebx

; 1995 : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?CalcTextSizeA@ImFont@@QBE?AUImVec2@@MMMPBD0PAPBD@Z ENDP ; ImFont::CalcTextSizeA
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_c$ = 8							; size = 2
?SetFallbackChar@ImFont@@QAEXG@Z PROC			; ImFont::SetFallbackChar
; _this$ = ecx

; 1759 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1760 :     FallbackChar = c;

	mov	ax, WORD PTR _c$[ebp]
	mov	WORD PTR [ecx+60], ax

; 1761 :     BuildLookupTable();

	call	?BuildLookupTable@ImFont@@QAEXXZ	; ImFont::BuildLookupTable

; 1762 : }

	pop	ebp
	ret	4
?SetFallbackChar@ImFont@@QAEXG@Z ENDP			; ImFont::SetFallbackChar
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_c$ = 8							; size = 2
?FindGlyph@ImFont@@QBEPBUGlyph@1@G@Z PROC		; ImFont::FindGlyph
; _this$ = ecx

; 1795 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, ecx

; 1796 :     if (c < IndexLookup.Size)

	movzx	ecx, WORD PTR _c$[ebp]
	cmp	ecx, DWORD PTR [edx+40]
	jge	SHORT $LN3@FindGlyph

; 1797 :     {
; 1798 :         const unsigned short i = IndexLookup[c];

	mov	eax, DWORD PTR [edx+48]
	movzx	eax, WORD PTR [eax+ecx*2]

; 1799 :         if (i != (unsigned short)-1)

	mov	ecx, 65535				; 0000ffffH
	cmp	ax, cx
	je	SHORT $LN3@FindGlyph

; 1800 :             return &Glyphs.Data[i];

	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edx+24]
	lea	eax, DWORD PTR [eax+ecx*8]

; 1803 : }

	pop	ebp
	ret	4
$LN3@FindGlyph:

; 1801 :     }
; 1802 :     return FallbackGlyph;

	mov	eax, DWORD PTR [edx+52]

; 1803 : }

	pop	ebp
	ret	4
?FindGlyph@ImFont@@QBEPBUGlyph@1@G@Z ENDP		; ImFont::FindGlyph
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
tv834 = -4						; size = 4
?BuildLookupTable@ImFont@@QAEXXZ PROC			; ImFont::BuildLookupTable
; _this$ = ecx

; 1720 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	mov	ebx, ecx

; 1721 :     int max_codepoint = 0;
; 1722 :     for (int i = 0; i != Glyphs.Size; i++)

	mov	edx, DWORD PTR [ebx+16]
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebx+16]
	xor	esi, esi
	test	edx, edx
	je	SHORT $LN3@BuildLooku
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	mov	ecx, DWORD PTR [ebx+24]
	npad	6
$LL4@BuildLooku:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1723 :         max_codepoint = ImMax(max_codepoint, (int)Glyphs[i].Codepoint);

	movzx	eax, WORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+40]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 126  : static inline int    ImMax(int lhs, int rhs)                                    { return lhs >= rhs ? lhs : rhs; }

	cmp	esi, eax
	cmovge	eax, esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1723 :         max_codepoint = ImMax(max_codepoint, (int)Glyphs[i].Codepoint);

	mov	esi, eax
	sub	edx, 1
	jne	SHORT $LL4@BuildLooku
$LN3@BuildLooku:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	mov	eax, DWORD PTR [ebx+36]
	test	eax, eax
	je	SHORT $LN22@BuildLooku
	push	eax
	mov	DWORD PTR [ebx+32], 0
	mov	DWORD PTR [ebx+28], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [ebx+36], 0
$LN22@BuildLooku:
	mov	eax, DWORD PTR [ebx+48]
	test	eax, eax
	je	SHORT $LN25@BuildLooku
	push	eax
	mov	DWORD PTR [ebx+44], 0
	mov	DWORD PTR [ebx+40], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [ebx+48], 0
$LN25@BuildLooku:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1728 :     GrowIndex(max_codepoint + 1);

	inc	esi
	mov	ecx, ebx
	push	esi
	mov	DWORD PTR tv834[ebp], esi
	call	?GrowIndex@ImFont@@QAEXH@Z		; ImFont::GrowIndex

; 1729 :     for (int i = 0; i < Glyphs.Size; i++)

	xor	esi, esi
	cmp	DWORD PTR [edi], esi
	jle	SHORT $LN6@BuildLooku

; 1728 :     GrowIndex(max_codepoint + 1);

	xor	edi, edi
$LL7@BuildLooku:

; 1730 :     {
; 1731 :         int codepoint = (int)Glyphs[i].Codepoint;

	mov	eax, DWORD PTR [ebx+24]
	lea	edi, DWORD PTR [edi+40]

; 1732 :         IndexXAdvance[codepoint] = Glyphs[i].XAdvance;

	mov	ecx, DWORD PTR [ebx+36]
	movzx	edx, WORD PTR [edi+eax-40]
	mov	eax, DWORD PTR [edi+eax-36]
	mov	DWORD PTR [ecx+edx*4], eax

; 1733 :         IndexLookup[codepoint] = (unsigned short)i;

	mov	eax, DWORD PTR [ebx+48]
	mov	WORD PTR [eax+edx*2], si
	inc	esi
	cmp	esi, DWORD PTR [ebx+16]
	jl	SHORT $LL7@BuildLooku
	lea	edi, DWORD PTR [ebx+16]
$LN6@BuildLooku:

; 1734 :     }
; 1735 : 
; 1736 :     // Create a glyph to handle TAB
; 1737 :     // FIXME: Needs proper TAB handling but it needs to be contextualized (or we could arbitrary say that each string starts at "column 0" ?)
; 1738 :     if (FindGlyph((unsigned short)' '))

	push	32					; 00000020H
	mov	ecx, ebx
	call	?FindGlyph@ImFont@@QBEPBUGlyph@1@G@Z	; ImFont::FindGlyph
	test	eax, eax
	je	$LN11@BuildLooku

; 1739 :     {
; 1740 :         if (Glyphs.back().Codepoint != '\t')   // So we can call this function multiple times

	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edi+8]
	cmp	WORD PTR [eax+ecx*8-40], 9
	je	SHORT $LN12@BuildLooku

; 1741 :             Glyphs.resize(Glyphs.Size + 1);

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	inc	eax
	push	eax
	call	?resize@?$ImVector@UGlyph@ImFont@@@@QAEXH@Z ; ImVector<ImFont::Glyph>::resize
$LN12@BuildLooku:

; 1742 :         ImFont::Glyph& tab_glyph = Glyphs.back();

	mov	eax, DWORD PTR [edi]

; 1743 :         tab_glyph = *FindGlyph((unsigned short)' ');

	mov	ecx, ebx
	mov	esi, DWORD PTR [ebx+24]
	push	32					; 00000020H
	lea	edi, DWORD PTR [eax+eax*4]
	call	?FindGlyph@ImFont@@QBEPBUGlyph@1@G@Z	; ImFont::FindGlyph
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [esi+edi*8-40], xmm0
	movups	xmm0, XMMWORD PTR [eax+16]
	movups	XMMWORD PTR [esi+edi*8-24], xmm0
	movq	xmm0, QWORD PTR [eax+32]
	mov	eax, 9
	movq	QWORD PTR [esi+edi*8-8], xmm0

; 1744 :         tab_glyph.Codepoint = '\t';
; 1745 :         tab_glyph.XAdvance *= 4;

	movss	xmm0, DWORD PTR [esi+edi*8-36]
	mulss	xmm0, DWORD PTR __real@40800000
	mov	WORD PTR [esi+edi*8-40], ax
	movss	DWORD PTR [esi+edi*8-36], xmm0

; 1746 :         IndexXAdvance[(int)tab_glyph.Codepoint] = (float)tab_glyph.XAdvance;

	mov	eax, DWORD PTR [ebx+36]
	movss	DWORD PTR [eax+36], xmm0

; 1747 :         IndexLookup[(int)tab_glyph.Codepoint] = (unsigned short)(Glyphs.Size-1);

	mov	dx, WORD PTR [ebx+16]
	movzx	ecx, WORD PTR [esi+edi*8-40]
	dec	dx
	mov	eax, DWORD PTR [ebx+48]
	mov	WORD PTR [eax+ecx*2], dx
$LN11@BuildLooku:

; 1748 :     }
; 1749 : 
; 1750 :     FallbackGlyph = NULL;
; 1751 :     FallbackGlyph = FindGlyph(FallbackChar);

	movzx	eax, WORD PTR [ebx+60]
	mov	ecx, ebx
	push	eax
	mov	DWORD PTR [ebx+52], 0
	call	?FindGlyph@ImFont@@QBEPBUGlyph@1@G@Z	; ImFont::FindGlyph
	mov	DWORD PTR [ebx+52], eax
	xorps	xmm0, xmm0

; 1752 :     FallbackXAdvance = FallbackGlyph ? FallbackGlyph->XAdvance : 0.0f;

	test	eax, eax
	je	SHORT $LN15@BuildLooku
	movss	xmm1, DWORD PTR [eax+4]
	jmp	SHORT $LN16@BuildLooku
$LN15@BuildLooku:
	xorps	xmm1, xmm1
$LN16@BuildLooku:

; 1753 :     for (int i = 0; i < max_codepoint + 1; i++)

	mov	esi, DWORD PTR tv834[ebp]
	xor	ecx, ecx
	movss	DWORD PTR [ebx+56], xmm1
	cmp	esi, 4
	jl	SHORT $LC57@BuildLooku
	lea	edi, DWORD PTR [esi-3]
	npad	1
$LL62@BuildLooku:

; 1754 :         if (IndexXAdvance[i] < 0.0f)

	mov	edx, DWORD PTR [ebx+36]
	comiss	xmm0, DWORD PTR [edx+ecx*4]
	jbe	SHORT $LN58@BuildLooku

; 1755 :             IndexXAdvance[i] = FallbackXAdvance;

	mov	eax, DWORD PTR [ebx+56]
	mov	DWORD PTR [edx+ecx*4], eax
$LN58@BuildLooku:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	mov	edx, DWORD PTR [ebx+36]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1754 :         if (IndexXAdvance[i] < 0.0f)

	comiss	xmm0, DWORD PTR [edx+ecx*4+4]
	jbe	SHORT $LN59@BuildLooku

; 1755 :             IndexXAdvance[i] = FallbackXAdvance;

	mov	eax, DWORD PTR [ebx+56]
	mov	DWORD PTR [edx+ecx*4+4], eax
$LN59@BuildLooku:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	mov	edx, DWORD PTR [ebx+36]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1754 :         if (IndexXAdvance[i] < 0.0f)

	comiss	xmm0, DWORD PTR [edx+ecx*4+8]
	jbe	SHORT $LN60@BuildLooku

; 1755 :             IndexXAdvance[i] = FallbackXAdvance;

	mov	eax, DWORD PTR [ebx+56]
	mov	DWORD PTR [edx+ecx*4+8], eax
$LN60@BuildLooku:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	mov	edx, DWORD PTR [ebx+36]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1754 :         if (IndexXAdvance[i] < 0.0f)

	comiss	xmm0, DWORD PTR [edx+ecx*4+12]
	jbe	SHORT $LN61@BuildLooku

; 1755 :             IndexXAdvance[i] = FallbackXAdvance;

	mov	eax, DWORD PTR [ebx+56]
	mov	DWORD PTR [edx+ecx*4+12], eax
$LN61@BuildLooku:
	add	ecx, 4
	cmp	ecx, edi
	jl	SHORT $LL62@BuildLooku
$LC57@BuildLooku:

; 1753 :     for (int i = 0; i < max_codepoint + 1; i++)

	cmp	ecx, esi
	jge	SHORT $LN56@BuildLooku
	npad	3
$LC10@BuildLooku:
	mov	edx, DWORD PTR [ebx+36]

; 1754 :         if (IndexXAdvance[i] < 0.0f)

	comiss	xmm0, DWORD PTR [edx+ecx*4]
	jbe	SHORT $LN8@BuildLooku

; 1755 :             IndexXAdvance[i] = FallbackXAdvance;

	mov	eax, DWORD PTR [ebx+56]
	mov	DWORD PTR [edx+ecx*4], eax
$LN8@BuildLooku:

; 1753 :     for (int i = 0; i < max_codepoint + 1; i++)

	inc	ecx
	cmp	ecx, esi
	jl	SHORT $LC10@BuildLooku
$LN56@BuildLooku:
	pop	edi
	pop	esi
	pop	ebx

; 1756 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?BuildLookupTable@ImFont@@QAEXXZ ENDP			; ImFont::BuildLookupTable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 8
?Clear@ImFont@@QAEXXZ PROC				; ImFont::Clear
; _this$ = ecx

; 1704 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	esi, ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1706 :     DisplayOffset = ImVec2(0.0f, 1.0f);

	mov	eax, DWORD PTR $T1[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp+4], 1065353216	; 3f800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1706 :     DisplayOffset = ImVec2(0.0f, 1.0f);

	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+12], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	mov	eax, DWORD PTR [esi+24]
	test	eax, eax
	je	SHORT $LN6@Clear
	push	eax
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+16], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+24], 0
$LN6@Clear:
	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	je	SHORT $LN9@Clear
	push	eax
	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+28], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+36], 0
$LN9@Clear:
	mov	eax, DWORD PTR [esi+48]
	test	eax, eax
	je	SHORT $LN12@Clear
	push	eax
	mov	DWORD PTR [esi+44], 0
	mov	DWORD PTR [esi+40], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+48], 0
$LN12@Clear:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1712 :     ConfigDataCount = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+52], 0
	mov	DWORD PTR [esi+56], 0
	mov	WORD PTR [esi+62], ax

; 1713 :     ConfigData = NULL;

	mov	DWORD PTR [esi+64], eax

; 1714 :     ContainerAtlas = NULL;

	mov	DWORD PTR [esi+68], eax

; 1715 :     Ascent = Descent = 0.0f;

	mov	DWORD PTR [esi+76], eax
	mov	DWORD PTR [esi+72], eax

; 1716 :     MetricsTotalSurface = 0;

	mov	DWORD PTR [esi+80], eax
	pop	esi

; 1717 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@ImFont@@QAEXXZ ENDP				; ImFont::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1ImFont@@QAE@XZ PROC					; ImFont::~ImFont
; _this$ = ecx

; 1691 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1ImFont@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx

; 1692 :     // Invalidate active font so that the user gets a clear crash instead of a dangling pointer.
; 1693 :     // If you want to delete fonts you need to do it between Render() and NewFrame().
; 1694 :     // FIXME-CLEANUP
; 1695 :     /*
; 1696 :     ImGuiContext& g = *GImGui;
; 1697 :     if (g.Font == this)
; 1698 :         g.Font = NULL;
; 1699 :     */
; 1700 :     Clear();

	call	?Clear@ImFont@@QAEXXZ			; ImFont::Clear
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN4@ImFont
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN4@ImFont:
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	eax, eax
	je	SHORT $LN8@ImFont
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN8@ImFont:
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	test	eax, eax
	je	SHORT $LN12@ImFont
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN12@ImFont:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1701 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__ehhandler$??1ImFont@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1ImFont@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1ImFont@@QAE@XZ ENDP					; ImFont::~ImFont
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0ImFont@@QAE@XZ PROC					; ImFont::ImFont
; _this$ = ecx

; 1684 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0ImFont@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 97   :     ImVec2() { x = y = 0.0f; }

	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+8], 0

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+24], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1684 : {

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+44], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+48], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1686 :     FallbackChar = (ImWchar)'?';

	mov	eax, 63					; 0000003fH
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	DWORD PTR [esi+4], 1065353216		; 3f800000H
	mov	WORD PTR [esi+60], ax

; 1687 :     Clear();

	call	?Clear@ImFont@@QAEXXZ			; ImFont::Clear

; 1688 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0ImFont@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$ImVector@UGlyph@ImFont@@@@QAE@XZ	; ImVector<ImFont::Glyph>::~ImVector<ImFont::Glyph>
__unwindfunclet$??0ImFont@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	jmp	??1?$ImVector@M@@QAE@XZ			; ImVector<float>::~ImVector<float>
__unwindfunclet$??0ImFont@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	jmp	??1?$ImVector@G@@QAE@XZ			; ImVector<unsigned short>::~ImVector<unsigned short>
__ehhandler$??0ImFont@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0ImFont@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0ImFont@@QAE@XZ ENDP					; ImFont::ImFont
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@M@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@M@@QAEXH@Z PROC			; ImVector<float>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@M@@QAEXH@Z ENDP			; ImVector<float>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@M@@QAEXH@Z
_TEXT	SEGMENT
_new_data$1$ = 8					; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@M@@QAEXH@Z PROC			; ImVector<float>::resize, COMDAT
; _this$ = ecx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR _new_size$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jle	SHORT $LN12@resize

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@resize
$LN6@resize:
	mov	eax, 8
$LN7@resize:
	push	ebx
	cmp	eax, edi
	mov	ebx, edi
	cmovg	ebx, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	ebx, ecx
	jle	SHORT $LN13@resize

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [ebx*4]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [esi+8]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN10@resize

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@resize:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], ebx
$LN13@resize:
	pop	ebx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
$LN12@resize:
	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?resize@?$ImVector@M@@QAEXH@Z ENDP			; ImVector<float>::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@M@@QAEHH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?_grow_capacity@?$ImVector@M@@QAEHH@Z PROC		; ImVector<float>::_grow_capacity, COMDAT
; _this$ = ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@grow_capac
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _new_size$[ebp]
	sar	ecx, 1
	add	ecx, esi
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
$LN3@grow_capac:
	mov	eax, DWORD PTR _new_size$[ebp]
	mov	ecx, 8
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
?_grow_capacity@?$ImVector@M@@QAEHH@Z ENDP		; ImVector<float>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@M@@QAEXXZ
_TEXT	SEGMENT
?clear@?$ImVector@M@@QAEXXZ PROC			; ImVector<float>::clear, COMDAT
; _this$ = ecx

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	npad	2
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN2@clear
	push	eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+8], 0
$LN2@clear:
	pop	esi
	ret	0
?clear@?$ImVector@M@@QAEXXZ ENDP			; ImVector<float>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@M@@QBEABMH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@M@@QBEABMH@Z PROC				; ImVector<float>::operator[], COMDAT
; _this$ = ecx

; 913  :     inline const value_type&    operator[](int i) const         { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	pop	ebp
	ret	4
??A?$ImVector@M@@QBEABMH@Z ENDP				; ImVector<float>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@M@@QAEAAMH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@M@@QAEAAMH@Z PROC				; ImVector<float>::operator[], COMDAT
; _this$ = ecx

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	pop	ebp
	ret	4
??A?$ImVector@M@@QAEAAMH@Z ENDP				; ImVector<float>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@M@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@M@@QAE@XZ PROC				; ImVector<float>::~ImVector<float>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@M@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@M@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@M@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@M@@QAE@XZ ENDP				; ImVector<float>::~ImVector<float>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@M@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@M@@QAE@XZ PROC				; ImVector<float>::ImVector<float>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@M@@QAE@XZ ENDP				; ImVector<float>::ImVector<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UGlyph@ImFont@@@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UGlyph@ImFont@@@@QAEXH@Z PROC	; ImVector<ImFont::Glyph>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi+edi*4]
	shl	eax, 3
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	shl	ecx, 3
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@UGlyph@ImFont@@@@QAEXH@Z ENDP	; ImVector<ImFont::Glyph>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UGlyph@ImFont@@@@QAEXH@Z
_TEXT	SEGMENT
_new_data$1$ = 8					; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@UGlyph@ImFont@@@@QAEXH@Z PROC	; ImVector<ImFont::Glyph>::resize, COMDAT
; _this$ = ecx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR _new_size$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jle	SHORT $LN12@resize

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@resize
$LN6@resize:
	mov	eax, 8
$LN7@resize:
	push	ebx
	cmp	eax, edi
	mov	ebx, edi
	cmovg	ebx, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	ebx, ecx
	jle	SHORT $LN13@resize

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [ebx+ebx*4]
	shl	eax, 3
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [esi+8]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN10@resize

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	shl	ecx, 3
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@resize:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], ebx
$LN13@resize:
	pop	ebx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
$LN12@resize:
	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?resize@?$ImVector@UGlyph@ImFont@@@@QAEXH@Z ENDP	; ImVector<ImFont::Glyph>::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UGlyph@ImFont@@@@QAEHH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?_grow_capacity@?$ImVector@UGlyph@ImFont@@@@QAEHH@Z PROC ; ImVector<ImFont::Glyph>::_grow_capacity, COMDAT
; _this$ = ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@grow_capac
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _new_size$[ebp]
	sar	ecx, 1
	add	ecx, esi
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
$LN3@grow_capac:
	mov	eax, DWORD PTR _new_size$[ebp]
	mov	ecx, 8
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
?_grow_capacity@?$ImVector@UGlyph@ImFont@@@@QAEHH@Z ENDP ; ImVector<ImFont::Glyph>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?back@?$ImVector@UGlyph@ImFont@@@@QAEAAUGlyph@ImFont@@XZ
_TEXT	SEGMENT
?back@?$ImVector@UGlyph@ImFont@@@@QAEAAUGlyph@ImFont@@XZ PROC ; ImVector<ImFont::Glyph>::back, COMDAT
; _this$ = ecx

; 922  :     inline value_type&          back()                          { IM_ASSERT(Size > 0); return Data[Size-1]; }

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [eax+edx*8]
	add	eax, -40				; ffffffd8H
	ret	0
?back@?$ImVector@UGlyph@ImFont@@@@QAEAAUGlyph@ImFont@@XZ ENDP ; ImVector<ImFont::Glyph>::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UGlyph@ImFont@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$ImVector@UGlyph@ImFont@@@@QAEXXZ PROC		; ImVector<ImFont::Glyph>::clear, COMDAT
; _this$ = ecx

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	npad	2
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN2@clear
	push	eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+8], 0
$LN2@clear:
	pop	esi
	ret	0
?clear@?$ImVector@UGlyph@ImFont@@@@QAEXXZ ENDP		; ImVector<ImFont::Glyph>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@UGlyph@ImFont@@@@QAEAAUGlyph@ImFont@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@UGlyph@ImFont@@@@QAEAAUGlyph@ImFont@@H@Z PROC ; ImVector<ImFont::Glyph>::operator[], COMDAT
; _this$ = ecx

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [eax+edx*8]
	pop	ebp
	ret	4
??A?$ImVector@UGlyph@ImFont@@@@QAEAAUGlyph@ImFont@@H@Z ENDP ; ImVector<ImFont::Glyph>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@UGlyph@ImFont@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@UGlyph@ImFont@@@@QAE@XZ PROC		; ImVector<ImFont::Glyph>::~ImVector<ImFont::Glyph>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@UGlyph@ImFont@@@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@UGlyph@ImFont@@@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@UGlyph@ImFont@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@UGlyph@ImFont@@@@QAE@XZ ENDP		; ImVector<ImFont::Glyph>::~ImVector<ImFont::Glyph>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@UGlyph@ImFont@@@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@UGlyph@ImFont@@@@QAE@XZ PROC		; ImVector<ImFont::Glyph>::ImVector<ImFont::Glyph>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@UGlyph@ImFont@@@@QAE@XZ ENDP		; ImVector<ImFont::Glyph>::ImVector<ImFont::Glyph>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_texture_data$ = -2472					; size = 2431
_r$6 = -40						; size = 16
$T7 = -32						; size = 8
$T8 = -32						; size = 8
$T9 = -24						; size = 8
$T10 = -16						; size = 8
$T11 = -8						; size = 8
_r$1$ = -4						; size = 4
_tex_uv_scale$1$sroa$714$1$ = 8				; size = 4
_n$1$ = 8						; size = 4
_pass$ = 8						; size = 4
_tex_uv_scale$1$sroa$715$1$ = 12			; size = 4
_y$1$ = 12						; size = 4
_p_rects$ = 12						; size = 4
?RenderCustomTexData@ImFontAtlas@@QAEXHPAX@Z PROC	; ImFontAtlas::RenderCustomTexData
; _this$ = ecx

; 1462 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 2472				; 000009a8H

; 1463 :     // A work of art lies ahead! (. = white layer, X = black layer, others are blank)
; 1464 :     // The white texels on the top left are the ones we'll use everywhere in ImGui to render filled shapes.
; 1465 :     const int TEX_DATA_W = 90;
; 1466 :     const int TEX_DATA_H = 27;
; 1467 :     const char texture_data[TEX_DATA_W*TEX_DATA_H+1] =
; 1468 :     {
; 1469 :         "..-         -XXXXXXX-    X    -           X           -XXXXXXX          -          XXXXXXX"
; 1470 :         "..-         -X.....X-   X.X   -          X.X          -X.....X          -          X.....X"
; 1471 :         "---         -XXX.XXX-  X...X  -         X...X         -X....X           -           X....X"
; 1472 :         "X           -  X.X  - X.....X -        X.....X        -X...X            -            X...X"
; 1473 :         "XX          -  X.X  -X.......X-       X.......X       -X..X.X           -           X.X..X"
; 1474 :         "X.X         -  X.X  -XXXX.XXXX-       XXXX.XXXX       -X.X X.X          -          X.X X.X"
; 1475 :         "X..X        -  X.X  -   X.X   -          X.X          -XX   X.X         -         X.X   XX"
; 1476 :         "X...X       -  X.X  -   X.X   -    XX    X.X    XX    -      X.X        -        X.X      "
; 1477 :         "X....X      -  X.X  -   X.X   -   X.X    X.X    X.X   -       X.X       -       X.X       "
; 1478 :         "X.....X     -  X.X  -   X.X   -  X..X    X.X    X..X  -        X.X      -      X.X        "
; 1479 :         "X......X    -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -         X.X   XX-XX   X.X         "
; 1480 :         "X.......X   -  X.X  -   X.X   -X.....................X-          X.X X.X-X.X X.X          "
; 1481 :         "X........X  -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -           X.X..X-X..X.X           "
; 1482 :         "X.........X -XXX.XXX-   X.X   -  X..X    X.X    X..X  -            X...X-X...X            "
; 1483 :         "X..........X-X.....X-   X.X   -   X.X    X.X    X.X   -           X....X-X....X           "
; 1484 :         "X......XXXXX-XXXXXXX-   X.X   -    XX    X.X    XX    -          X.....X-X.....X          "
; 1485 :         "X...X..X    ---------   X.X   -          X.X          -          XXXXXXX-XXXXXXX          "
; 1486 :         "X..X X..X   -       -XXXX.XXXX-       XXXX.XXXX       ------------------------------------"
; 1487 :         "X.X  X..X   -       -X.......X-       X.......X       -    XX           XX    -           "
; 1488 :         "XX    X..X  -       - X.....X -        X.....X        -   X.X           X.X   -           "
; 1489 :         "      X..X          -  X...X  -         X...X         -  X..X           X..X  -           "
; 1490 :         "       XX           -   X.X   -          X.X          - X...XXXXXXXXXXXXX...X -           "
; 1491 :         "------------        -    X    -           X           -X.....................X-           "
; 1492 :         "                    ----------------------------------- X...XXXXXXXXXXXXX...X -           "
; 1493 :         "                                                      -  X..X           X..X  -           "
; 1494 :         "                                                      -   X.X           X.X   -           "
; 1495 :         "                                                      -    XX           XX    -           "
; 1496 :     };
; 1497 : 
; 1498 :     ImVector<stbrp_rect>& rects = *(ImVector<stbrp_rect>*)p_rects;
; 1499 :     if (pass == 0)

	mov	eax, DWORD PTR _pass$[ebp]
	push	ebx
	mov	ebx, ecx
	mov	ecx, 607				; 0000025fH
	push	esi
	mov	esi, OFFSET $SG16247
	push	edi
	lea	edi, DWORD PTR _texture_data$[ebp]
	rep movsd
	movsw
	movsb
	test	eax, eax
	jne	SHORT $LN11@RenderCust

; 1500 :     {
; 1501 :         // Request rectangles
; 1502 :         stbrp_rect r;
; 1503 :         memset(&r, 0, sizeof(r));
; 1504 :         r.w = (TEX_DATA_W*2)+1;
; 1505 :         r.h = TEX_DATA_H+1;
; 1506 :         rects.push_back(r);

	mov	ecx, DWORD PTR _p_rects$[ebp]
	lea	eax, DWORD PTR _r$6[ebp]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _r$6[ebp], xmm0
	push	eax
	mov	DWORD PTR _r$6[ebp+4], 1835189		; 001c00b5H
	call	?push_back@?$ImVector@Ustbrp_rect@@@@QAEXABUstbrp_rect@@@Z ; ImVector<stbrp_rect>::push_back
	pop	edi
	pop	esi
	pop	ebx

; 1549 :         }
; 1550 :     }
; 1551 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN11@RenderCust:

; 1507 :     }
; 1508 :     else if (pass == 1)

	cmp	eax, 1
	jne	$LN102@RenderCust

; 1509 :     {
; 1510 :         // Render/copy pixels
; 1511 :         const stbrp_rect& r = rects[0];

	mov	eax, DWORD PTR _p_rects$[ebp]

; 1512 :         for (int y = 0, n = 0; y < TEX_DATA_H; y++)

	xor	ecx, ecx
	xor	esi, esi
	mov	DWORD PTR _n$1$[ebp], ecx
	mov	DWORD PTR _y$1$[ebp], esi
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _r$1$[ebp], edx
	npad	5
$LL4@RenderCust:

; 1513 :             for (int x = 0; x < TEX_DATA_W; x++, n++)

	xor	edi, edi
$LL7@RenderCust:

; 1514 :             {
; 1515 :                 const int offset0 = (int)(r.x + x) + (int)(r.y + y) * TexWidth;

	movzx	eax, WORD PTR [edx+10]
	add	eax, esi
	movzx	esi, WORD PTR [edx+8]
	imul	eax, DWORD PTR [ebx+12]

; 1516 :                 const int offset1 = offset0 + 1 + TEX_DATA_W;
; 1517 :                 TexPixelsAlpha8[offset0] = texture_data[n] == '.' ? 0xFF : 0x00;

	mov	dl, BYTE PTR _texture_data$[ebp+ecx]
	add	eax, edi
	add	esi, eax
	mov	eax, DWORD PTR [ebx+4]
	cmp	dl, 46					; 0000002eH
	setne	cl
	dec	cl

; 1518 :                 TexPixelsAlpha8[offset1] = texture_data[n] == 'X' ? 0xFF : 0x00;

	cmp	dl, 88					; 00000058H
	mov	edx, DWORD PTR _r$1$[ebp]
	mov	BYTE PTR [esi+eax], cl
	setne	cl
	mov	eax, DWORD PTR [ebx+4]
	dec	cl
	inc	edi
	mov	BYTE PTR [eax+esi+91], cl
	mov	ecx, DWORD PTR _n$1$[ebp]
	mov	esi, DWORD PTR _y$1$[ebp]
	inc	ecx
	mov	DWORD PTR _n$1$[ebp], ecx
	cmp	edi, 90					; 0000005aH
	jl	SHORT $LL7@RenderCust

; 1512 :         for (int y = 0, n = 0; y < TEX_DATA_H; y++)

	inc	esi
	mov	DWORD PTR _y$1$[ebp], esi
	cmp	esi, 27					; 0000001bH
	jl	SHORT $LL4@RenderCust

; 1520 :         const ImVec2 tex_uv_scale(1.0f / TexWidth, 1.0f / TexHeight);

	movd	xmm0, DWORD PTR [ebx+12]
	movss	xmm3, DWORD PTR __real@3f800000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movzx	eax, WORD PTR [edx+8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1520 :         const ImVec2 tex_uv_scale(1.0f / TexWidth, 1.0f / TexHeight);

	movaps	xmm2, xmm3
	cvtdq2ps xmm0, xmm0
	movaps	xmm1, XMMWORD PTR __xmm@00000000000000004198000041400000
	divss	xmm2, xmm0
	movd	xmm0, DWORD PTR [ebx+16]
	cvtdq2ps xmm0, xmm0
	movaps	xmm6, XMMWORD PTR __xmm@41000000408000004180000040e00000
	divss	xmm3, xmm0
	movd	xmm0, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movzx	eax, WORD PTR [edx+10]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1521 :         TexUvWhitePixel = ImVec2((r.x + 0.5f) * tex_uv_scale.x, (r.y + 0.5f) * tex_uv_scale.y);

	cvtdq2ps xmm0, xmm0
	movaps	xmm7, XMMWORD PTR __xmm@413000004130000041b8000041b80000
	addss	xmm0, DWORD PTR __real@3f000000
	movss	DWORD PTR _tex_uv_scale$1$sroa$714$1$[ebp], xmm3
	movss	DWORD PTR _tex_uv_scale$1$sroa$715$1$[ebp], xmm2
	mulss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T8[ebp], xmm0
	movd	xmm0, eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1521 :         TexUvWhitePixel = ImVec2((r.x + 0.5f) * tex_uv_scale.x, (r.y + 0.5f) * tex_uv_scale.y);

	mov	eax, DWORD PTR $T8[ebp]
	cvtdq2ps xmm0, xmm0
	mov	DWORD PTR [ebx+24], eax
	addss	xmm0, DWORD PTR __real@3f000000
	mulss	xmm0, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T8[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1542 :             cursor_data.Size = size;

	movaps	xmm0, xmm1
	mov	eax, DWORD PTR $T8[ebp+4]
	mov	DWORD PTR [ebx+28], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movzx	eax, WORD PTR [edx+8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1538 :             ImGuiMouseCursorData& cursor_data = GImGui->MouseCursorData[type];

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 1542 :             cursor_data.Size = size;

	psrldq	xmm0, 4
	movd	xmm4, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movzx	eax, WORD PTR [edx+10]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1542 :             cursor_data.Size = size;

	movd	DWORD PTR [ecx+6784], xmm0

; 1543 :             cursor_data.HotOffset = cursor_datas[type][2];

	movaps	xmm0, xmm1
	psrldq	xmm0, 8
	movd	DWORD PTR [ecx+6772], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movaps	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1542 :             cursor_data.Size = size;

	movd	DWORD PTR [ecx+6780], xmm1
	movd	xmm5, eax
	cvtdq2ps xmm4, xmm4
	mov	DWORD PTR [ecx+6768], 0

; 1543 :             cursor_data.HotOffset = cursor_datas[type][2];

	psrldq	xmm1, 12				; 0000000cH
	movd	DWORD PTR [ecx+6776], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movaps	xmm1, xmm4
	addss	xmm1, DWORD PTR __real@41400000

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm0, xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1546 :             pos.x += TEX_DATA_W+1;

	addss	xmm4, DWORD PTR __real@42b60000
	cvtdq2ps xmm5, xmm5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T11[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movaps	xmm0, xmm2

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm5, DWORD PTR __real@40400000
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1544 :             cursor_data.TexUvMin[0] = (pos) * tex_uv_scale;

	mov	eax, DWORD PTR $T11[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm0, xmm1
	movaps	xmm1, xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1544 :             cursor_data.TexUvMin[0] = (pos) * tex_uv_scale;

	mov	DWORD PTR [ecx+6788], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm3, xmm5

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm5, DWORD PTR __real@41980000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T10[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movss	xmm0, DWORD PTR _tex_uv_scale$1$sroa$714$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T11[ebp+4], xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1544 :             cursor_data.TexUvMin[0] = (pos) * tex_uv_scale;

	mov	eax, DWORD PTR $T11[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm0, xmm5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1544 :             cursor_data.TexUvMin[0] = (pos) * tex_uv_scale;

	mov	DWORD PTR [ecx+6792], eax

; 1545 :             cursor_data.TexUvMax[0] = (pos + size) * tex_uv_scale;

	mov	eax, DWORD PTR $T10[ebp]
	mov	DWORD PTR [ecx+6804], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T10[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movaps	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1545 :             cursor_data.TexUvMax[0] = (pos + size) * tex_uv_scale;

	mov	eax, DWORD PTR $T10[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm0, xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1545 :             cursor_data.TexUvMax[0] = (pos + size) * tex_uv_scale;

	mov	DWORD PTR [ecx+6808], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm4, DWORD PTR __real@41400000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T9[ebp+4], xmm3
	movss	DWORD PTR $T9[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movaps	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1547 :             cursor_data.TexUvMin[1] = (pos) * tex_uv_scale;

	mov	eax, DWORD PTR $T9[ebp]
	mov	DWORD PTR [ecx+6796], eax
	mov	eax, DWORD PTR $T9[ebp+4]
	mov	DWORD PTR [ecx+6800], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm0, xmm4
	movss	xmm3, DWORD PTR _tex_uv_scale$1$sroa$714$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T7[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movss	xmm0, DWORD PTR _tex_uv_scale$1$sroa$714$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1548 :             cursor_data.TexUvMax[1] = (pos + size) * tex_uv_scale;

	mov	eax, DWORD PTR $T7[ebp]
	mov	DWORD PTR [ecx+6812], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm0, xmm5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T7[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1542 :             cursor_data.Size = size;

	movaps	xmm0, xmm6

; 1548 :             cursor_data.TexUvMax[1] = (pos + size) * tex_uv_scale;

	mov	eax, DWORD PTR $T7[ebp+4]
	mov	DWORD PTR [ecx+6816], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movzx	eax, WORD PTR [edx+8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1538 :             ImGuiMouseCursorData& cursor_data = GImGui->MouseCursorData[type];

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 1542 :             cursor_data.Size = size;

	psrldq	xmm0, 4
	movd	xmm4, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movzx	eax, WORD PTR [edx+10]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1541 :             cursor_data.Type = type;

	mov	DWORD PTR [ecx+6820], 1

; 1542 :             cursor_data.Size = size;

	movd	DWORD PTR [ecx+6832], xmm6
	movd	DWORD PTR [ecx+6836], xmm0

; 1543 :             cursor_data.HotOffset = cursor_datas[type][2];

	movaps	xmm0, xmm6
	cvtdq2ps xmm4, xmm4
	psrldq	xmm0, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm4, DWORD PTR __real@41500000
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1543 :             cursor_data.HotOffset = cursor_datas[type][2];

	movd	DWORD PTR [ecx+6824], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movaps	xmm0, xmm1
	movd	xmm5, eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1539 :             ImVec2 pos = cursor_datas[type][0] + ImVec2((float)r.x, (float)r.y);

	cvtdq2ps xmm5, xmm5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm0, xmm4

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movaps	xmm1, xmm4
	addss	xmm1, DWORD PTR __real@40e00000

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm3, xmm5

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm5, DWORD PTR __real@41800000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T11[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movaps	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1544 :             cursor_data.TexUvMin[0] = (pos) * tex_uv_scale;

	mov	eax, DWORD PTR $T11[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1543 :             cursor_data.HotOffset = cursor_datas[type][2];

	psrldq	xmm6, 12				; 0000000cH
	movd	DWORD PTR [ecx+6828], xmm6

; 1546 :             pos.x += TEX_DATA_W+1;

	movss	xmm6, DWORD PTR __real@42b60000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T10[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1546 :             pos.x += TEX_DATA_W+1;

	addss	xmm4, xmm6
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movss	xmm0, DWORD PTR _tex_uv_scale$1$sroa$714$1$[ebp]
	mulss	xmm0, xmm5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1544 :             cursor_data.TexUvMin[0] = (pos) * tex_uv_scale;

	mov	DWORD PTR [ecx+6840], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T11[ebp+4], xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1544 :             cursor_data.TexUvMin[0] = (pos) * tex_uv_scale;

	mov	eax, DWORD PTR $T11[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T10[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movaps	xmm0, xmm2
	mulss	xmm0, xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1544 :             cursor_data.TexUvMin[0] = (pos) * tex_uv_scale;

	mov	DWORD PTR [ecx+6844], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm4, DWORD PTR __real@40e00000
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1545 :             cursor_data.TexUvMax[0] = (pos + size) * tex_uv_scale;

	mov	eax, DWORD PTR $T10[ebp]
	mov	DWORD PTR [ecx+6856], eax
	mov	eax, DWORD PTR $T10[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T9[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movaps	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1545 :             cursor_data.TexUvMax[0] = (pos + size) * tex_uv_scale;

	mov	DWORD PTR [ecx+6860], eax

; 1547 :             cursor_data.TexUvMin[1] = (pos) * tex_uv_scale;

	mov	eax, DWORD PTR $T9[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm0, xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1547 :             cursor_data.TexUvMin[1] = (pos) * tex_uv_scale;

	mov	DWORD PTR [ecx+6848], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T9[ebp+4], xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1547 :             cursor_data.TexUvMin[1] = (pos) * tex_uv_scale;

	mov	eax, DWORD PTR $T9[ebp+4]
	mov	DWORD PTR [ecx+6852], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T7[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movss	xmm0, DWORD PTR _tex_uv_scale$1$sroa$714$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1548 :             cursor_data.TexUvMax[1] = (pos + size) * tex_uv_scale;

	mov	eax, DWORD PTR $T7[ebp]
	mov	DWORD PTR [ecx+6864], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm0, xmm5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T7[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1548 :             cursor_data.TexUvMax[1] = (pos + size) * tex_uv_scale;

	mov	eax, DWORD PTR $T7[ebp+4]
	mov	DWORD PTR [ecx+6868], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movzx	eax, WORD PTR [edx+8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1538 :             ImGuiMouseCursorData& cursor_data = GImGui->MouseCursorData[type];

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	movd	xmm3, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movzx	eax, WORD PTR [edx+10]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1539 :             ImVec2 pos = cursor_datas[type][0] + ImVec2((float)r.x, (float)r.y);

	cvtdq2ps xmm3, xmm3

; 1541 :             cursor_data.Type = type;

	mov	DWORD PTR [ecx+6872], 2
	movd	xmm4, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm3, DWORD PTR __real@41f80000
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1539 :             ImVec2 pos = cursor_datas[type][0] + ImVec2((float)r.x, (float)r.y);

	cvtdq2ps xmm4, xmm4

; 1542 :             cursor_data.Size = size;

	movd	DWORD PTR [ecx+6884], xmm7
	movaps	xmm0, xmm7
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movaps	xmm5, xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1542 :             cursor_data.Size = size;

	psrldq	xmm0, 4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movaps	xmm1, xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1542 :             cursor_data.Size = size;

	movd	DWORD PTR [ecx+6888], xmm0

; 1543 :             cursor_data.HotOffset = cursor_datas[type][2];

	movaps	xmm0, xmm7
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movss	xmm2, DWORD PTR _tex_uv_scale$1$sroa$714$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1543 :             cursor_data.HotOffset = cursor_datas[type][2];

	psrldq	xmm0, 8
	movd	DWORD PTR [ecx+6876], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movaps	xmm0, xmm5
	mulss	xmm0, xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1546 :             pos.x += TEX_DATA_W+1;

	addss	xmm3, xmm6
	psrldq	xmm7, 12				; 0000000cH
	movd	DWORD PTR [ecx+6880], xmm7
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm7, DWORD PTR __real@41b80000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T11[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm1, xmm7
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1544 :             cursor_data.TexUvMin[0] = (pos) * tex_uv_scale;

	mov	eax, DWORD PTR $T11[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movaps	xmm0, xmm5
	mulss	xmm2, xmm4

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm4, xmm7
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1544 :             cursor_data.TexUvMin[0] = (pos) * tex_uv_scale;

	mov	DWORD PTR [ecx+6892], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1542 :             cursor_data.Size = size;

	movaps	xmm1, XMMWORD PTR __xmm@4130000040a0000041b8000041100000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T11[ebp+4], xmm2
	movss	DWORD PTR $T10[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movss	xmm0, DWORD PTR _tex_uv_scale$1$sroa$714$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1544 :             cursor_data.TexUvMin[0] = (pos) * tex_uv_scale;

	mov	eax, DWORD PTR $T11[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm0, xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1544 :             cursor_data.TexUvMin[0] = (pos) * tex_uv_scale;

	mov	DWORD PTR [ecx+6896], eax

; 1545 :             cursor_data.TexUvMax[0] = (pos + size) * tex_uv_scale;

	mov	eax, DWORD PTR $T10[ebp]
	mov	DWORD PTR [ecx+6908], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T10[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movaps	xmm0, xmm5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1545 :             cursor_data.TexUvMax[0] = (pos + size) * tex_uv_scale;

	mov	eax, DWORD PTR $T10[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm0, xmm3

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm3, xmm7
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1545 :             cursor_data.TexUvMax[0] = (pos + size) * tex_uv_scale;

	mov	DWORD PTR [ecx+6912], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T9[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movss	xmm2, DWORD PTR _tex_uv_scale$1$sroa$714$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T9[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movaps	xmm0, xmm5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1547 :             cursor_data.TexUvMin[1] = (pos) * tex_uv_scale;

	mov	eax, DWORD PTR $T9[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm0, xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1547 :             cursor_data.TexUvMin[1] = (pos) * tex_uv_scale;

	mov	DWORD PTR [ecx+6900], eax
	mov	eax, DWORD PTR $T9[ebp+4]
	mov	DWORD PTR [ecx+6904], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T7[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movss	xmm0, DWORD PTR _tex_uv_scale$1$sroa$714$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1548 :             cursor_data.TexUvMax[1] = (pos + size) * tex_uv_scale;

	mov	eax, DWORD PTR $T7[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm0, xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1548 :             cursor_data.TexUvMax[1] = (pos + size) * tex_uv_scale;

	mov	DWORD PTR [ecx+6916], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T7[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1542 :             cursor_data.Size = size;

	movaps	xmm0, xmm1

; 1548 :             cursor_data.TexUvMax[1] = (pos + size) * tex_uv_scale;

	mov	eax, DWORD PTR $T7[ebp+4]
	mov	DWORD PTR [ecx+6920], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movzx	eax, WORD PTR [edx+8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1538 :             ImGuiMouseCursorData& cursor_data = GImGui->MouseCursorData[type];

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 1542 :             cursor_data.Size = size;

	psrldq	xmm0, 4
	movd	xmm3, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movzx	eax, WORD PTR [edx+10]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1541 :             cursor_data.Type = type;

	mov	DWORD PTR [ecx+6924], 3
	cvtdq2ps xmm3, xmm3

; 1542 :             cursor_data.Size = size;

	movd	DWORD PTR [ecx+6936], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm3, DWORD PTR __real@41a80000
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1542 :             cursor_data.Size = size;

	movd	DWORD PTR [ecx+6940], xmm0

; 1543 :             cursor_data.HotOffset = cursor_datas[type][2];

	movaps	xmm0, xmm1
	movd	xmm4, eax
	psrldq	xmm0, 8
	movd	DWORD PTR [ecx+6928], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movaps	xmm0, xmm5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1539 :             ImVec2 pos = cursor_datas[type][0] + ImVec2((float)r.x, (float)r.y);

	cvtdq2ps xmm4, xmm4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm0, xmm3
	mulss	xmm2, xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1543 :             cursor_data.HotOffset = cursor_datas[type][2];

	psrldq	xmm1, 12				; 0000000cH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T11[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1544 :             cursor_data.TexUvMin[0] = (pos) * tex_uv_scale;

	mov	eax, DWORD PTR $T11[ebp]
	movd	DWORD PTR [ecx+6932], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T11[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1544 :             cursor_data.TexUvMin[0] = (pos) * tex_uv_scale;

	mov	DWORD PTR [ecx+6944], eax
	mov	eax, DWORD PTR $T11[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm5, DWORD PTR __real@41100000
	addss	xmm4, xmm7

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movss	xmm0, DWORD PTR _tex_uv_scale$1$sroa$715$1$[ebp]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movaps	xmm1, xmm3
	addss	xmm1, xmm5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1544 :             cursor_data.TexUvMin[0] = (pos) * tex_uv_scale;

	mov	DWORD PTR [ecx+6948], eax

; 1546 :             pos.x += TEX_DATA_W+1;

	addss	xmm3, xmm6
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T9[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movss	xmm2, DWORD PTR _tex_uv_scale$1$sroa$714$1$[ebp]
	mulss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1542 :             cursor_data.Size = size;

	movaps	xmm1, XMMWORD PTR __xmm@40a00000413000004110000041b80000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T10[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movss	xmm0, DWORD PTR _tex_uv_scale$1$sroa$714$1$[ebp]
	mulss	xmm0, xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1545 :             cursor_data.TexUvMax[0] = (pos + size) * tex_uv_scale;

	mov	eax, DWORD PTR $T10[ebp]
	mov	DWORD PTR [ecx+6960], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T10[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movss	xmm0, DWORD PTR _tex_uv_scale$1$sroa$715$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1545 :             cursor_data.TexUvMax[0] = (pos + size) * tex_uv_scale;

	mov	eax, DWORD PTR $T10[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm0, xmm3

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm3, xmm5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1545 :             cursor_data.TexUvMax[0] = (pos + size) * tex_uv_scale;

	mov	DWORD PTR [ecx+6964], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T9[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movss	xmm0, DWORD PTR _tex_uv_scale$1$sroa$715$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1547 :             cursor_data.TexUvMin[1] = (pos) * tex_uv_scale;

	mov	eax, DWORD PTR $T9[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm0, xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1547 :             cursor_data.TexUvMin[1] = (pos) * tex_uv_scale;

	mov	DWORD PTR [ecx+6952], eax
	mov	eax, DWORD PTR $T9[ebp+4]
	mov	DWORD PTR [ecx+6956], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T7[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movaps	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1548 :             cursor_data.TexUvMax[1] = (pos + size) * tex_uv_scale;

	mov	eax, DWORD PTR $T7[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm0, xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1548 :             cursor_data.TexUvMax[1] = (pos + size) * tex_uv_scale;

	mov	DWORD PTR [ecx+6968], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T7[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1542 :             cursor_data.Size = size;

	movaps	xmm0, xmm1

; 1548 :             cursor_data.TexUvMax[1] = (pos + size) * tex_uv_scale;

	mov	eax, DWORD PTR $T7[ebp+4]
	mov	DWORD PTR [ecx+6972], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movzx	eax, WORD PTR [edx+8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1538 :             ImGuiMouseCursorData& cursor_data = GImGui->MouseCursorData[type];

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 1542 :             cursor_data.Size = size;

	psrldq	xmm0, 4
	movd	xmm3, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movzx	eax, WORD PTR [edx+10]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1541 :             cursor_data.Type = type;

	mov	DWORD PTR [ecx+6976], 4

; 1542 :             cursor_data.Size = size;

	movd	DWORD PTR [ecx+6988], xmm1
	movd	DWORD PTR [ecx+6992], xmm0

; 1543 :             cursor_data.HotOffset = cursor_datas[type][2];

	movaps	xmm0, xmm1
	movd	xmm4, eax
	cvtdq2ps xmm3, xmm3
	cvtdq2ps xmm4, xmm4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm3, DWORD PTR __real@425c0000
	addss	xmm4, DWORD PTR __real@41900000
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1543 :             cursor_data.HotOffset = cursor_datas[type][2];

	psrldq	xmm0, 8
	movd	DWORD PTR [ecx+6980], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movss	xmm0, DWORD PTR _tex_uv_scale$1$sroa$715$1$[ebp]
	mulss	xmm0, xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1543 :             cursor_data.HotOffset = cursor_datas[type][2];

	psrldq	xmm1, 12				; 0000000cH
	movd	DWORD PTR [ecx+6984], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movaps	xmm1, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T11[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm1, xmm7
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1544 :             cursor_data.TexUvMin[0] = (pos) * tex_uv_scale;

	mov	eax, DWORD PTR $T11[ebp]

; 1546 :             pos.x += TEX_DATA_W+1;

	addss	xmm3, xmm6
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm2, xmm4

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm4, xmm5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1544 :             cursor_data.TexUvMin[0] = (pos) * tex_uv_scale;

	mov	DWORD PTR [ecx+6996], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movss	xmm5, DWORD PTR _tex_uv_scale$1$sroa$715$1$[ebp]
	movaps	xmm0, xmm5
	mulss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T11[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1544 :             cursor_data.TexUvMin[0] = (pos) * tex_uv_scale;

	mov	eax, DWORD PTR $T11[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T10[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movss	xmm0, DWORD PTR _tex_uv_scale$1$sroa$714$1$[ebp]
	mulss	xmm0, xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1544 :             cursor_data.TexUvMin[0] = (pos) * tex_uv_scale;

	mov	DWORD PTR [ecx+7000], eax

; 1545 :             cursor_data.TexUvMax[0] = (pos + size) * tex_uv_scale;

	mov	eax, DWORD PTR $T10[ebp]
	mov	DWORD PTR [ecx+7012], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T10[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movaps	xmm0, xmm5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1545 :             cursor_data.TexUvMax[0] = (pos + size) * tex_uv_scale;

	mov	eax, DWORD PTR $T10[ebp+4]
	mov	DWORD PTR [ecx+7016], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm0, xmm3

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm3, xmm7

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movss	xmm7, DWORD PTR _tex_uv_scale$1$sroa$714$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1542 :             cursor_data.Size = size;

	movaps	xmm1, XMMWORD PTR __xmm@41100000411000004188000041880000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T9[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movaps	xmm0, xmm5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1547 :             cursor_data.TexUvMin[1] = (pos) * tex_uv_scale;

	mov	eax, DWORD PTR $T9[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm0, xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1547 :             cursor_data.TexUvMin[1] = (pos) * tex_uv_scale;

	mov	DWORD PTR [ecx+7004], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T9[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movaps	xmm2, xmm7
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1547 :             cursor_data.TexUvMin[1] = (pos) * tex_uv_scale;

	mov	eax, DWORD PTR $T9[ebp+4]
	mov	DWORD PTR [ecx+7008], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T7[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movaps	xmm0, xmm7
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1548 :             cursor_data.TexUvMax[1] = (pos + size) * tex_uv_scale;

	mov	eax, DWORD PTR $T7[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm0, xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1548 :             cursor_data.TexUvMax[1] = (pos + size) * tex_uv_scale;

	mov	DWORD PTR [ecx+7020], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T7[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1542 :             cursor_data.Size = size;

	movaps	xmm0, xmm1

; 1548 :             cursor_data.TexUvMax[1] = (pos + size) * tex_uv_scale;

	mov	eax, DWORD PTR $T7[ebp+4]
	mov	DWORD PTR [ecx+7024], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movzx	eax, WORD PTR [edx+8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1538 :             ImGuiMouseCursorData& cursor_data = GImGui->MouseCursorData[type];

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 1542 :             cursor_data.Size = size;

	psrldq	xmm0, 4
	movd	xmm3, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movzx	eax, WORD PTR [edx+10]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1541 :             cursor_data.Type = type;

	mov	DWORD PTR [ecx+7028], 5

; 1542 :             cursor_data.Size = size;

	movd	DWORD PTR [ecx+7040], xmm1
	movd	DWORD PTR [ecx+7044], xmm0

; 1543 :             cursor_data.HotOffset = cursor_datas[type][2];

	movaps	xmm0, xmm1
	psrldq	xmm0, 8
	movd	DWORD PTR [ecx+7032], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movaps	xmm0, xmm5

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm5, DWORD PTR __real@41880000
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1539 :             ImVec2 pos = cursor_datas[type][0] + ImVec2((float)r.x, (float)r.y);

	cvtdq2ps xmm3, xmm3
	movd	xmm4, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm3, DWORD PTR __real@42920000
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1543 :             cursor_data.HotOffset = cursor_datas[type][2];

	psrldq	xmm1, 12				; 0000000cH
	movd	DWORD PTR [ecx+7036], xmm1
	cvtdq2ps xmm4, xmm4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm0, xmm3

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movaps	xmm1, xmm3
	addss	xmm1, xmm5

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm2, xmm4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T11[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm4, xmm5

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movss	xmm0, DWORD PTR _tex_uv_scale$1$sroa$715$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1546 :             pos.x += TEX_DATA_W+1;

	addss	xmm3, xmm6
	mov	eax, DWORD PTR $T11[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1544 :             cursor_data.TexUvMin[0] = (pos) * tex_uv_scale;

	mov	DWORD PTR [ecx+7048], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T11[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1544 :             cursor_data.TexUvMin[0] = (pos) * tex_uv_scale;

	mov	eax, DWORD PTR $T11[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T10[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movaps	xmm0, xmm7
	mulss	xmm0, xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1544 :             cursor_data.TexUvMin[0] = (pos) * tex_uv_scale;

	mov	DWORD PTR [ecx+7052], eax

; 1545 :             cursor_data.TexUvMax[0] = (pos + size) * tex_uv_scale;

	mov	eax, DWORD PTR $T10[ebp]
	mov	DWORD PTR [ecx+7064], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T10[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movss	xmm0, DWORD PTR _tex_uv_scale$1$sroa$715$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1545 :             cursor_data.TexUvMax[0] = (pos + size) * tex_uv_scale;

	mov	eax, DWORD PTR $T10[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm0, xmm3

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm3, xmm5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1545 :             cursor_data.TexUvMax[0] = (pos + size) * tex_uv_scale;

	mov	DWORD PTR [ecx+7068], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T9[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movaps	xmm2, xmm7
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T9[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movss	xmm0, DWORD PTR _tex_uv_scale$1$sroa$715$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1547 :             cursor_data.TexUvMin[1] = (pos) * tex_uv_scale;

	mov	eax, DWORD PTR $T9[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm0, xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1547 :             cursor_data.TexUvMin[1] = (pos) * tex_uv_scale;

	mov	DWORD PTR [ecx+7056], eax
	mov	eax, DWORD PTR $T9[ebp+4]
	mov	DWORD PTR [ecx+7060], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T7[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movaps	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1548 :             cursor_data.TexUvMax[1] = (pos + size) * tex_uv_scale;

	mov	eax, DWORD PTR $T7[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm0, xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1548 :             cursor_data.TexUvMax[1] = (pos + size) * tex_uv_scale;

	mov	DWORD PTR [ecx+7072], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T7[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1542 :             cursor_data.Size = size;

	mov	eax, DWORD PTR $T7[ebp+4]
	movaps	xmm1, XMMWORD PTR __xmm@41100000411000004188000041880000

; 1548 :             cursor_data.TexUvMax[1] = (pos + size) * tex_uv_scale;

	mov	DWORD PTR [ecx+7076], eax
	movaps	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movzx	eax, WORD PTR [edx+8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1538 :             ImGuiMouseCursorData& cursor_data = GImGui->MouseCursorData[type];

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movss	xmm6, DWORD PTR _tex_uv_scale$1$sroa$715$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1542 :             cursor_data.Size = size;

	psrldq	xmm0, 4
	movd	xmm3, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movzx	eax, WORD PTR [edx+10]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1541 :             cursor_data.Type = type;

	mov	DWORD PTR [ecx+7080], 6

; 1542 :             cursor_data.Size = size;

	movd	DWORD PTR [ecx+7092], xmm1
	movd	DWORD PTR [ecx+7096], xmm0

; 1543 :             cursor_data.HotOffset = cursor_datas[type][2];

	movaps	xmm0, xmm1
	cvtdq2ps xmm3, xmm3
	psrldq	xmm0, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm3, DWORD PTR __real@425c0000
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1543 :             cursor_data.HotOffset = cursor_datas[type][2];

	movd	DWORD PTR [ecx+7084], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movaps	xmm0, xmm6
	movd	xmm4, eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1543 :             cursor_data.HotOffset = cursor_datas[type][2];

	psrldq	xmm1, 12				; 0000000cH
	movd	DWORD PTR [ecx+7088], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm0, xmm3

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movaps	xmm1, xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1546 :             pos.x += TEX_DATA_W+1;

	addss	xmm3, DWORD PTR __real@42b60000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm1, xmm5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T11[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movaps	xmm0, xmm6
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1544 :             cursor_data.TexUvMin[0] = (pos) * tex_uv_scale;

	mov	eax, DWORD PTR $T11[ebp]
	cvtdq2ps xmm4, xmm4
	mov	DWORD PTR [ecx+7100], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm0, xmm1
	movaps	xmm1, xmm7
	mulss	xmm2, xmm4

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm4, xmm5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T10[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movaps	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T11[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1544 :             cursor_data.TexUvMin[0] = (pos) * tex_uv_scale;

	mov	eax, DWORD PTR $T11[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm0, xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1544 :             cursor_data.TexUvMin[0] = (pos) * tex_uv_scale;

	mov	DWORD PTR [ecx+7104], eax

; 1545 :             cursor_data.TexUvMax[0] = (pos + size) * tex_uv_scale;

	mov	eax, DWORD PTR $T10[ebp]
	mov	DWORD PTR [ecx+7116], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T10[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movaps	xmm0, xmm6
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1545 :             cursor_data.TexUvMax[0] = (pos + size) * tex_uv_scale;

	mov	eax, DWORD PTR $T10[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm0, xmm3

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm3, xmm5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1545 :             cursor_data.TexUvMax[0] = (pos + size) * tex_uv_scale;

	mov	DWORD PTR [ecx+7120], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm1, xmm4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T9[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1547 :             cursor_data.TexUvMin[1] = (pos) * tex_uv_scale;

	mov	eax, DWORD PTR $T9[ebp]
	mov	DWORD PTR [ecx+7108], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm6, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T9[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1547 :             cursor_data.TexUvMin[1] = (pos) * tex_uv_scale;

	mov	eax, DWORD PTR $T9[ebp+4]
	mov	DWORD PTR [ecx+7112], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T7[ebp], xmm6
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1548 :             cursor_data.TexUvMax[1] = (pos + size) * tex_uv_scale;

	mov	eax, DWORD PTR $T7[ebp]
	mov	DWORD PTR [ecx+7124], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T7[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1548 :             cursor_data.TexUvMax[1] = (pos + size) * tex_uv_scale;

	mov	eax, DWORD PTR $T7[ebp+4]
	mov	DWORD PTR [ecx+7128], eax
$LN102@RenderCust:
	pop	edi
	pop	esi
	pop	ebx

; 1549 :         }
; 1550 :     }
; 1551 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?RenderCustomTexData@ImFontAtlas@@QAEXHPAX@Z ENDP	; ImFontAtlas::RenderCustomTexData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_spc$ = -144						; size = 40
_q$2 = -136						; size = 32
_unscaled_descent$3 = -104				; size = 4
_unscaled_ascent$4 = -100				; size = 4
_extra_rects$ = -96					; size = 12
$T5 = -84						; size = 8
_codepoint$1$ = -80					; size = 4
_unscaled_line_gap$6 = -80				; size = 4
_new_data$1$ = -76					; size = 4
_dummy_x$7 = -76					; size = 4
tv1709 = -72						; size = 4
_cfg$1$ = -72						; size = 4
_tmp_array$1$ = -68					; size = 4
_input_i$1$ = -64					; size = 4
tv1731 = -64						; size = 4
_char_idx$1$ = -60					; size = 4
_buf_rects_n$1$ = -60					; size = 4
_range$1$ = -56						; size = 4
_glyph_count$1$ = -56					; size = 4
_i$1$ = -52						; size = 4
_glyph_ranges_count$1$ = -52				; size = 4
_buf_packedchars_n$1$ = -48				; size = 4
tv1711 = -48						; size = 4
_input_i$1$ = -44					; size = 4
_buf_ranges_n$1$ = -44					; size = 4
_buf_ranges$1$ = -40					; size = 4
_input_i$1$ = -40					; size = 4
_buf_packedchars$1$ = -36				; size = 4
tv1722 = -36						; size = 4
_this$1$ = -32						; size = 4
_cfg$1$ = -28						; size = 4
tv1706 = -28						; size = 4
_total_glyph_range_count$1$ = -28			; size = 4
_off_y$1$ = -24						; size = 4
_buf_rects$1$ = -24					; size = 4
tv1721 = -24						; size = 4
_cfg$1$ = -20						; size = 4
tv1719 = -20						; size = 4
_total_glyph_count$1$ = -20				; size = 4
_new_data$1$ = -16					; size = 4
_new_size$1$ = -16					; size = 4
_input_i$1$ = -16					; size = 4
tv1717 = -16						; size = 4
_dummy_y$8 = -16					; size = 4
_font_scale$9 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?Build@ImFontAtlas@@QAE_NXZ PROC			; ImFontAtlas::Build
; _this$ = ecx

; 1256 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Build@ImFontAtlas@@QAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 132				; 00000084H
	push	ebx
	mov	ebx, ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T5[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1261 :     TexUvWhitePixel = ImVec2(0, 0);

	mov	eax, DWORD PTR $T5[ebp]
	push	esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T5[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1261 :     TexUvWhitePixel = ImVec2(0, 0);

	mov	DWORD PTR [ebx+24], eax
	mov	eax, DWORD PTR $T5[ebp+4]
	push	edi
	mov	DWORD PTR _this$1$[ebp], ebx
	mov	DWORD PTR [ebx], 0
	mov	DWORD PTR [ebx+16], 0
	mov	DWORD PTR [ebx+12], 0
	mov	DWORD PTR [ebx+28], eax

; 1262 :     ClearTexData();

	call	?ClearTexData@ImFontAtlas@@QAEXXZ	; ImFontAtlas::ClearTexData

; 1263 : 
; 1264 :     struct ImFontTempBuildData
; 1265 :     {
; 1266 :         stbtt_fontinfo      FontInfo;
; 1267 :         stbrp_rect*         Rects;
; 1268 :         stbtt_pack_range*   Ranges;
; 1269 :         int                 RangesCount;
; 1270 :     };
; 1271 :     ImFontTempBuildData* tmp_array = (ImFontTempBuildData*)ImGui::MemAlloc((size_t)ConfigData.Size * sizeof(ImFontTempBuildData));

	imul	eax, DWORD PTR [ebx+44], 132
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 1272 : 
; 1273 :     // Initialize font information early (so we can error without any cleanup) + count glyphs
; 1274 :     int total_glyph_count = 0;

	xor	edi, edi
	mov	DWORD PTR _tmp_array$1$[ebp], eax
	add	esp, 4
	mov	DWORD PTR _total_glyph_count$1$[ebp], edi

; 1275 :     int total_glyph_range_count = 0;

	mov	DWORD PTR _total_glyph_range_count$1$[ebp], edi

; 1276 :     for (int input_i = 0; input_i < ConfigData.Size; input_i++)

	mov	DWORD PTR _input_i$1$[ebp], edi
	cmp	DWORD PTR [ebx+44], edi
	jle	$LN3@Build

; 1257 :     IM_ASSERT(ConfigData.Size > 0);
; 1258 : 
; 1259 :     TexID = NULL;

	xor	ecx, ecx
	mov	DWORD PTR tv1721[ebp], eax
	mov	DWORD PTR tv1722[ebp], ecx
	npad	6
$LL4@Build:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	mov	eax, DWORD PTR [ebx+52]
	add	eax, ecx
	mov	DWORD PTR _cfg$1$[ebp], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1282 :         const int font_offset = stbtt_GetFontOffsetForIndex((unsigned char*)cfg.FontData, cfg.FontNo);

	push	DWORD PTR [eax+12]
	mov	esi, DWORD PTR [eax]
	push	esi
	call	_stbtt_GetFontOffsetForIndex

; 1283 :         IM_ASSERT(font_offset >= 0);
; 1284 :         if (!stbtt_InitFont(&tmp.FontInfo, (unsigned char*)cfg.FontData, font_offset))

	push	eax
	push	esi
	push	DWORD PTR tv1721[ebp]
	call	_stbtt_InitFont
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN118@Build

; 1286 : 
; 1287 :         // Count glyphs
; 1288 :         if (!cfg.GlyphRanges)

	mov	esi, DWORD PTR _cfg$1$[ebp]
	cmp	DWORD PTR [esi+40], 0
	jne	SHORT $LN36@Build

; 1289 :             cfg.GlyphRanges = GetGlyphRangesDefault();

	mov	ecx, ebx
	call	?GetGlyphRangesDefault@ImFontAtlas@@QAEPBGXZ ; ImFontAtlas::GetGlyphRangesDefault
	mov	DWORD PTR [esi+40], eax
$LN36@Build:

; 1290 :         for (const ImWchar* in_range = cfg.GlyphRanges; in_range[0] && in_range[1]; in_range += 2)

	mov	edx, DWORD PTR [esi+40]
	movzx	eax, WORD PTR [edx]
	test	ax, ax
	je	SHORT $LN2@Build
	mov	ebx, DWORD PTR _total_glyph_range_count$1$[ebp]
$LL7@Build:
	movzx	ecx, WORD PTR [edx+2]
	test	cx, cx
	je	SHORT $LN152@Build
	add	edx, 4

; 1291 :         {
; 1292 :             total_glyph_count += (in_range[1] - in_range[0]) + 1;

	movzx	eax, ax
	sub	ecx, eax
	inc	edi
	add	edi, ecx

; 1293 :             total_glyph_range_count++;

	inc	ebx
	movzx	eax, WORD PTR [edx]
	test	ax, ax
	jne	SHORT $LL7@Build
$LN152@Build:
	mov	DWORD PTR _total_glyph_range_count$1$[ebp], ebx
	mov	ebx, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR _total_glyph_count$1$[ebp], edi
$LN2@Build:

; 1276 :     for (int input_i = 0; input_i < ConfigData.Size; input_i++)

	mov	eax, DWORD PTR _input_i$1$[ebp]
	mov	ecx, DWORD PTR tv1722[ebp]
	inc	eax
	add	DWORD PTR tv1721[ebp], 132		; 00000084H
	add	ecx, 84					; 00000054H
	mov	DWORD PTR _input_i$1$[ebp], eax
	mov	DWORD PTR tv1722[ebp], ecx
	cmp	eax, DWORD PTR [ebx+44]
	jl	$LL4@Build
$LN3@Build:

; 1294 :         }
; 1295 :     }
; 1296 : 
; 1297 :     // Start packing. We need a known width for the skyline algorithm. Using a cheap heuristic here to decide of width. User can override TexDesiredWidth if they wish.
; 1298 :     // After packing is done, width shouldn't matter much, but some API/GPU have texture size limitations and increasing width can decrease height.
; 1299 :     TexWidth = (TexDesiredWidth > 0) ? TexDesiredWidth : (total_glyph_count > 4000) ? 4096 : (total_glyph_count > 2000) ? 2048 : (total_glyph_count > 1000) ? 1024 : 512;

	mov	eax, DWORD PTR [ebx+20]
	test	eax, eax
	jg	SHORT $LN45@Build
	cmp	edi, 4000				; 00000fa0H
	jle	SHORT $LN46@Build
	mov	eax, 4096				; 00001000H
	jmp	SHORT $LN45@Build
$LN118@Build:
	pop	edi
	pop	esi

; 1285 :             return false;

	xor	al, al
	pop	ebx

; 1459 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN46@Build:

; 1294 :         }
; 1295 :     }
; 1296 : 
; 1297 :     // Start packing. We need a known width for the skyline algorithm. Using a cheap heuristic here to decide of width. User can override TexDesiredWidth if they wish.
; 1298 :     // After packing is done, width shouldn't matter much, but some API/GPU have texture size limitations and increasing width can decrease height.
; 1299 :     TexWidth = (TexDesiredWidth > 0) ? TexDesiredWidth : (total_glyph_count > 4000) ? 4096 : (total_glyph_count > 2000) ? 2048 : (total_glyph_count > 1000) ? 1024 : 512;

	cmp	edi, 2000				; 000007d0H
	jle	SHORT $LN44@Build
	mov	eax, 2048				; 00000800H
	jmp	SHORT $LN45@Build
$LN44@Build:
	cmp	edi, 1000				; 000003e8H
	mov	eax, 512				; 00000200H
	mov	ecx, 1024				; 00000400H
	cmovg	eax, ecx
$LN45@Build:

; 1300 :     TexHeight = 0;
; 1301 :     const int max_tex_height = 1024*32;
; 1302 :     stbtt_pack_context spc;
; 1303 :     stbtt_PackBegin(&spc, NULL, TexWidth, max_tex_height, 0, 1, NULL);

	push	0
	push	1
	push	0
	push	32768					; 00008000H
	push	eax
	mov	DWORD PTR [ebx+12], eax
	lea	eax, DWORD PTR _spc$[ebp]
	push	0
	push	eax
	mov	DWORD PTR [ebx+16], 0
	call	_stbtt_PackBegin
	add	esp, 28					; 0000001cH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR _extra_rects$[ebp+4], 0
	mov	DWORD PTR _extra_rects$[ebp], 0
	mov	DWORD PTR _extra_rects$[ebp+8], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1307 :     RenderCustomTexData(0, &extra_rects);

	lea	eax, DWORD PTR _extra_rects$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	push	0
	mov	ecx, ebx
	call	?RenderCustomTexData@ImFontAtlas@@QAEXHPAX@Z ; ImFontAtlas::RenderCustomTexData

; 1308 :     stbtt_PackSetOversampling(&spc, 1, 1);

	push	1
	lea	eax, DWORD PTR _spc$[ebp]
	push	1
	push	eax
	call	_stbtt_PackSetOversampling

; 1309 :     stbrp_pack_rects((stbrp_context*)spc.pack_info, &extra_rects[0], extra_rects.Size);

	mov	esi, DWORD PTR _extra_rects$[ebp]
	push	esi
	push	DWORD PTR _extra_rects$[ebp+8]
	push	DWORD PTR _spc$[ebp+4]
	call	_stbrp_pack_rects
	add	esp, 24					; 00000018H

; 1310 :     for (int i = 0; i < extra_rects.Size; i++)

	test	esi, esi
	jle	SHORT $LN9@Build

; 1294 :         }
; 1295 :     }
; 1296 : 
; 1297 :     // Start packing. We need a known width for the skyline algorithm. Using a cheap heuristic here to decide of width. User can override TexDesiredWidth if they wish.
; 1298 :     // After packing is done, width shouldn't matter much, but some API/GPU have texture size limitations and increasing width can decrease height.
; 1299 :     TexWidth = (TexDesiredWidth > 0) ? TexDesiredWidth : (total_glyph_count > 4000) ? 4096 : (total_glyph_count > 2000) ? 2048 : (total_glyph_count > 1000) ? 1024 : 512;

	mov	edx, DWORD PTR _extra_rects$[ebp+8]
	add	edx, 10					; 0000000aH
$LL10@Build:

; 1311 :         if (extra_rects[i].was_packed)

	cmp	DWORD PTR [edx+2], 0
	je	SHORT $LN8@Build

; 1312 :             TexHeight = ImMax(TexHeight, extra_rects[i].y + extra_rects[i].h);

	movzx	ecx, WORD PTR [edx-4]
	movzx	eax, WORD PTR [edx]
	add	ecx, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 126  : static inline int    ImMax(int lhs, int rhs)                                    { return lhs >= rhs ? lhs : rhs; }

	cmp	DWORD PTR [ebx+16], ecx
	cmovge	ecx, DWORD PTR [ebx+16]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1312 :             TexHeight = ImMax(TexHeight, extra_rects[i].y + extra_rects[i].h);

	mov	DWORD PTR [ebx+16], ecx
$LN8@Build:

; 1310 :     for (int i = 0; i < extra_rects.Size; i++)

	add	edx, 16					; 00000010H
	sub	esi, 1
	jne	SHORT $LL10@Build
$LN9@Build:

; 1316 :     stbtt_packedchar* buf_packedchars = (stbtt_packedchar*)ImGui::MemAlloc(total_glyph_count * sizeof(stbtt_packedchar));

	mov	esi, DWORD PTR _total_glyph_count$1$[ebp]
	shl	edi, 3
	sub	edi, esi
	mov	DWORD PTR _buf_packedchars_n$1$[ebp], 0
	shl	edi, 2
	push	edi
	mov	DWORD PTR _buf_rects_n$1$[ebp], 0
	mov	DWORD PTR _buf_ranges_n$1$[ebp], 0
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 1317 :     stbrp_rect* buf_rects = (stbrp_rect*)ImGui::MemAlloc(total_glyph_count * sizeof(stbrp_rect));

	shl	esi, 4
	push	esi
	mov	DWORD PTR _buf_packedchars$1$[ebp], eax
	mov	DWORD PTR _total_glyph_count$1$[ebp], esi
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	DWORD PTR _buf_rects$1$[ebp], eax

; 1318 :     stbtt_pack_range* buf_ranges = (stbtt_pack_range*)ImGui::MemAlloc(total_glyph_range_count * sizeof(stbtt_pack_range));

	mov	eax, DWORD PTR _total_glyph_range_count$1$[ebp]
	lea	esi, DWORD PTR [eax+eax*2]
	shl	esi, 3
	push	esi
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 1319 :     memset(buf_packedchars, 0, total_glyph_count * sizeof(stbtt_packedchar));

	push	edi
	push	0
	push	DWORD PTR _buf_packedchars$1$[ebp]
	mov	DWORD PTR _buf_ranges$1$[ebp], eax
	call	_memset

; 1320 :     memset(buf_rects, 0, total_glyph_count * sizeof(stbrp_rect));              // Unnecessary but let's clear this for the sake of sanity.

	push	DWORD PTR _total_glyph_count$1$[ebp]
	push	0
	push	DWORD PTR _buf_rects$1$[ebp]
	call	_memset

; 1321 :     memset(buf_ranges, 0, total_glyph_range_count * sizeof(stbtt_pack_range));

	push	esi
	push	0
	push	DWORD PTR _buf_ranges$1$[ebp]
	call	_memset
	add	esp, 48					; 00000030H

; 1322 : 
; 1323 :     // First font pass: pack all glyphs (no rendering at this point, we are working with rectangles in an infinitely tall texture at this point)
; 1324 :     for (int input_i = 0; input_i < ConfigData.Size; input_i++)

	mov	DWORD PTR _input_i$1$[ebp], 0
	cmp	DWORD PTR [ebx+44], 0
	jle	$LN12@Build

; 1313 : 
; 1314 :     // Allocate packing character data and flag packed characters buffer as non-packed (x0=y0=x1=y1=0)
; 1315 :     int buf_packedchars_n = 0, buf_rects_n = 0, buf_ranges_n = 0;

	mov	ebx, DWORD PTR _tmp_array$1$[ebp]
	xor	edx, edx
	mov	eax, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR tv1717[ebp], edx
$LL13@Build:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	mov	ecx, DWORD PTR [eax+52]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1330 :         int glyph_count = 0;

	xor	edi, edi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	add	ecx, edx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1330 :         int glyph_count = 0;

	mov	DWORD PTR _glyph_count$1$[ebp], edi

; 1331 :         int glyph_ranges_count = 0;

	xor	esi, esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR _cfg$1$[ebp], ecx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1331 :         int glyph_ranges_count = 0;

	mov	DWORD PTR _glyph_ranges_count$1$[ebp], esi

; 1332 :         for (const ImWchar* in_range = cfg.GlyphRanges; in_range[0] && in_range[1]; in_range += 2)

	mov	edx, DWORD PTR [ecx+40]
	movzx	eax, WORD PTR [edx]
	test	ax, ax
	je	SHORT $LN15@Build
	npad	1
$LL16@Build:
	movzx	ecx, WORD PTR [edx+2]
	test	cx, cx
	je	SHORT $LN153@Build
	add	edx, 4

; 1333 :         {
; 1334 :             glyph_count += (in_range[1] - in_range[0]) + 1;

	movzx	eax, ax
	sub	ecx, eax
	inc	edi
	add	edi, ecx

; 1335 :             glyph_ranges_count++;

	inc	esi
	movzx	eax, WORD PTR [edx]
	test	ax, ax
	jne	SHORT $LL16@Build
$LN153@Build:
	mov	ecx, DWORD PTR _cfg$1$[ebp]
	mov	DWORD PTR _glyph_count$1$[ebp], edi
	mov	DWORD PTR _glyph_ranges_count$1$[ebp], esi
$LN15@Build:

; 1336 :         }
; 1337 :         tmp.Ranges = buf_ranges + buf_ranges_n;

	mov	edx, DWORD PTR _buf_ranges_n$1$[ebp]
	mov	edi, DWORD PTR _buf_ranges$1$[ebp]

; 1338 :         tmp.RangesCount = glyph_ranges_count;

	mov	DWORD PTR [ebx+128], esi
	lea	eax, DWORD PTR [edx+edx*2]

; 1339 :         buf_ranges_n += glyph_ranges_count;

	add	edx, esi
	lea	eax, DWORD PTR [edi+eax*8]
	mov	DWORD PTR _buf_ranges_n$1$[ebp], edx

; 1340 :         for (int i = 0; i < glyph_ranges_count; i++)

	xor	edi, edi
	mov	DWORD PTR [ebx+124], eax
	test	esi, esi
	jle	SHORT $LN18@Build

; 1336 :         }
; 1337 :         tmp.Ranges = buf_ranges + buf_ranges_n;

	xor	eax, eax
	mov	DWORD PTR tv1719[ebp], eax
	npad	5
$LL19@Build:

; 1340 :         for (int i = 0; i < glyph_ranges_count; i++)

	mov	edx, DWORD PTR [ecx+40]

; 1341 :         {
; 1342 :             const ImWchar* in_range = &cfg.GlyphRanges[i * 2];
; 1343 :             stbtt_pack_range& range = tmp.Ranges[i];

	mov	esi, DWORD PTR [ebx+124]
	add	esi, eax

; 1344 :             range.font_size = cfg.SizePixels;

	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [esi], eax

; 1345 :             range.first_unicode_codepoint_in_range = in_range[0];

	movzx	eax, WORD PTR [edx+edi*4]
	mov	DWORD PTR [esi+4], eax

; 1346 :             range.num_chars = (in_range[1] - in_range[0]) + 1;

	movzx	eax, WORD PTR [edx+edi*4]
	movzx	ecx, WORD PTR [edx+edi*4+2]
	inc	edi

; 1347 :             range.chardata_for_range = buf_packedchars + buf_packedchars_n;

	mov	edx, DWORD PTR _buf_packedchars$1$[ebp]
	sub	ecx, eax
	inc	ecx
	mov	DWORD PTR [esi+12], ecx
	mov	ecx, DWORD PTR _buf_packedchars_n$1$[ebp]
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx

; 1348 :             buf_packedchars_n += range.num_chars;

	add	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR _buf_packedchars_n$1$[ebp], ecx
	mov	ecx, DWORD PTR _cfg$1$[ebp]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR tv1719[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR tv1719[ebp], eax
	cmp	edi, DWORD PTR _glyph_ranges_count$1$[ebp]
	jl	SHORT $LL19@Build
$LN18@Build:

; 1349 :         }
; 1350 : 
; 1351 :         // Pack
; 1352 :         tmp.Rects = buf_rects + buf_rects_n;

	mov	ecx, DWORD PTR _buf_rects_n$1$[ebp]
	mov	eax, ecx

; 1353 :         buf_rects_n += glyph_count;

	add	ecx, DWORD PTR _glyph_count$1$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _buf_rects$1$[ebp]
	mov	DWORD PTR [ebx+120], eax

; 1354 :         stbtt_PackSetOversampling(&spc, cfg.OversampleH, cfg.OversampleV);

	mov	eax, DWORD PTR _cfg$1$[ebp]
	mov	DWORD PTR _buf_rects_n$1$[ebp], ecx
	push	DWORD PTR [eax+24]
	push	DWORD PTR [eax+20]
	lea	eax, DWORD PTR _spc$[ebp]
	push	eax
	call	_stbtt_PackSetOversampling

; 1355 :         int n = stbtt_PackFontRangesGatherRects(&spc, &tmp.FontInfo, tmp.Ranges, tmp.RangesCount, tmp.Rects);

	push	DWORD PTR [ebx+120]
	lea	eax, DWORD PTR _spc$[ebp]
	push	DWORD PTR [ebx+128]
	push	DWORD PTR [ebx+124]
	push	ebx
	push	eax
	call	_stbtt_PackFontRangesGatherRects
	mov	edi, eax

; 1356 :         stbrp_pack_rects((stbrp_context*)spc.pack_info, tmp.Rects, n);

	push	edi
	push	DWORD PTR [ebx+120]
	push	DWORD PTR _spc$[ebp+4]
	call	_stbrp_pack_rects
	add	esp, 44					; 0000002cH

; 1357 : 
; 1358 :         // Extend texture height
; 1359 :         for (int i = 0; i < n; i++)

	test	edi, edi
	jle	SHORT $LN11@Build

; 1349 :         }
; 1350 : 
; 1351 :         // Pack
; 1352 :         tmp.Rects = buf_rects + buf_rects_n;

	xor	edx, edx
	npad	4
$LL22@Build:

; 1360 :             if (tmp.Rects[i].was_packed)

	mov	eax, DWORD PTR [ebx+120]
	cmp	DWORD PTR [edx+eax+12], 0
	je	SHORT $LN20@Build

; 1361 :                 TexHeight = ImMax(TexHeight, tmp.Rects[i].y + tmp.Rects[i].h);

	movzx	ecx, WORD PTR [edx+eax+10]
	mov	esi, DWORD PTR _this$1$[ebp]
	movzx	eax, WORD PTR [edx+eax+6]
	add	ecx, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 126  : static inline int    ImMax(int lhs, int rhs)                                    { return lhs >= rhs ? lhs : rhs; }

	cmp	DWORD PTR [esi+16], ecx
	cmovge	ecx, DWORD PTR [esi+16]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1361 :                 TexHeight = ImMax(TexHeight, tmp.Rects[i].y + tmp.Rects[i].h);

	mov	DWORD PTR [esi+16], ecx
$LN20@Build:

; 1357 : 
; 1358 :         // Extend texture height
; 1359 :         for (int i = 0; i < n; i++)

	add	edx, 16					; 00000010H
	sub	edi, 1
	jne	SHORT $LL22@Build
$LN11@Build:

; 1322 : 
; 1323 :     // First font pass: pack all glyphs (no rendering at this point, we are working with rectangles in an infinitely tall texture at this point)
; 1324 :     for (int input_i = 0; input_i < ConfigData.Size; input_i++)

	mov	ecx, DWORD PTR _input_i$1$[ebp]
	add	ebx, 132				; 00000084H
	mov	eax, DWORD PTR _this$1$[ebp]
	inc	ecx
	mov	edx, DWORD PTR tv1717[ebp]
	add	edx, 84					; 00000054H
	mov	DWORD PTR _input_i$1$[ebp], ecx
	mov	DWORD PTR tv1717[ebp], edx
	cmp	ecx, DWORD PTR [eax+44]
	jl	$LL13@Build
	mov	ebx, eax
$LN12@Build:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 97   : static inline int       ImUpperPowerOfTwo(int v)        { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return v; }

	mov	ecx, DWORD PTR [ebx+16]
	dec	ecx
	mov	eax, ecx
	sar	eax, 1
	or	ecx, eax
	mov	eax, ecx
	sar	eax, 2
	or	ecx, eax
	mov	eax, ecx
	sar	eax, 4
	or	ecx, eax
	mov	eax, ecx
	sar	eax, 8
	or	ecx, eax
	mov	eax, ecx
	sar	eax, 16					; 00000010H
	or	ecx, eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1369 :     TexPixelsAlpha8 = (unsigned char*)ImGui::MemAlloc(TexWidth * TexHeight);

	mov	eax, DWORD PTR [ebx+12]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 97   : static inline int       ImUpperPowerOfTwo(int v)        { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return v; }

	inc	ecx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1369 :     TexPixelsAlpha8 = (unsigned char*)ImGui::MemAlloc(TexWidth * TexHeight);

	imul	eax, ecx
	mov	DWORD PTR [ebx+16], ecx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 1370 :     memset(TexPixelsAlpha8, 0, TexWidth * TexHeight);

	mov	ecx, DWORD PTR [ebx+12]
	imul	ecx, DWORD PTR [ebx+16]
	mov	DWORD PTR [ebx+4], eax
	push	ecx
	push	0
	push	eax
	call	_memset

; 1371 :     spc.pixels = TexPixelsAlpha8;

	mov	eax, DWORD PTR [ebx+4]
	add	esp, 16					; 00000010H

; 1372 :     spc.height = TexHeight;
; 1373 : 
; 1374 :     // Second pass: render characters
; 1375 :     for (int input_i = 0; input_i < ConfigData.Size; input_i++)

	cmp	DWORD PTR [ebx+44], 0
	mov	DWORD PTR _spc$[ebp+32], eax
	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR _spc$[ebp+12], eax
	mov	DWORD PTR _input_i$1$[ebp], 0
	jle	SHORT $LN24@Build

; 1362 :     }
; 1363 :     IM_ASSERT(buf_rects_n == total_glyph_count);
; 1364 :     IM_ASSERT(buf_packedchars_n == total_glyph_count);
; 1365 :     IM_ASSERT(buf_ranges_n == total_glyph_range_count);
; 1366 : 
; 1367 :     // Create texture
; 1368 :     TexHeight = ImUpperPowerOfTwo(TexHeight);

	mov	esi, DWORD PTR _tmp_array$1$[ebp]
	xor	edi, edi
	add	esi, 120				; 00000078H
	npad	1
$LL25@Build:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	mov	eax, DWORD PTR [ebx+52]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1379 :         stbtt_PackSetOversampling(&spc, cfg.OversampleH, cfg.OversampleV);

	push	DWORD PTR [eax+edi+24]
	push	DWORD PTR [eax+edi+20]
	lea	eax, DWORD PTR _spc$[ebp]
	push	eax
	call	_stbtt_PackSetOversampling

; 1380 :         stbtt_PackFontRangesRenderIntoRects(&spc, &tmp.FontInfo, tmp.Ranges, tmp.RangesCount, tmp.Rects);

	push	DWORD PTR [esi]
	lea	eax, DWORD PTR [esi-120]
	push	DWORD PTR [esi+8]
	push	DWORD PTR [esi+4]
	push	eax
	lea	eax, DWORD PTR _spc$[ebp]
	push	eax
	call	_stbtt_PackFontRangesRenderIntoRects
	mov	eax, DWORD PTR _input_i$1$[ebp]
	lea	edi, DWORD PTR [edi+84]
	inc	eax

; 1381 :         tmp.Rects = NULL;

	mov	DWORD PTR [esi], 0
	add	esp, 32					; 00000020H
	mov	DWORD PTR _input_i$1$[ebp], eax
	lea	esi, DWORD PTR [esi+132]
	cmp	eax, DWORD PTR [ebx+44]
	jl	SHORT $LL25@Build
$LN24@Build:

; 1382 :     }
; 1383 : 
; 1384 :     // End packing
; 1385 :     stbtt_PackEnd(&spc);

	lea	eax, DWORD PTR _spc$[ebp]
	push	eax
	call	_stbtt_PackEnd

; 1386 :     ImGui::MemFree(buf_rects);

	push	DWORD PTR _buf_rects$1$[ebp]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 8

; 1387 :     buf_rects = NULL;
; 1388 : 
; 1389 :     // Third pass: setup ImFont and glyphs for runtime
; 1390 :     for (int input_i = 0; input_i < ConfigData.Size; input_i++)

	mov	DWORD PTR _input_i$1$[ebp], 0
	cmp	DWORD PTR [ebx+44], 0
	jle	$LN27@Build

; 1382 :     }
; 1383 : 
; 1384 :     // End packing
; 1385 :     stbtt_PackEnd(&spc);

	mov	esi, DWORD PTR _tmp_array$1$[ebp]
	xor	ecx, ecx
	movss	xmm5, DWORD PTR __real@3f000000
	sub	esi, -128				; ffffff80H
	mov	DWORD PTR tv1709[ebp], ecx
	mov	DWORD PTR tv1706[ebp], esi
	npad	5
$LL28@Build:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	mov	eax, DWORD PTR [ebx+52]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1396 :         float font_scale = stbtt_ScaleForPixelHeight(&tmp.FontInfo, cfg.SizePixels);

	add	esi, -128				; ffffff80H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	add	eax, ecx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1396 :         float font_scale = stbtt_ScaleForPixelHeight(&tmp.FontInfo, cfg.SizePixels);

	push	ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR _cfg$1$[ebp], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1396 :         float font_scale = stbtt_ScaleForPixelHeight(&tmp.FontInfo, cfg.SizePixels);

	movss	xmm0, DWORD PTR [eax+16]
	mov	edi, DWORD PTR [eax+80]
	movss	DWORD PTR [esp], xmm0
	push	esi
	call	_stbtt_ScaleForPixelHeight

; 1397 :         int unscaled_ascent, unscaled_descent, unscaled_line_gap;
; 1398 :         stbtt_GetFontVMetrics(&tmp.FontInfo, &unscaled_ascent, &unscaled_descent, &unscaled_line_gap);

	lea	eax, DWORD PTR _unscaled_line_gap$6[ebp]
	push	eax
	lea	eax, DWORD PTR _unscaled_descent$3[ebp]
	push	eax
	lea	eax, DWORD PTR _unscaled_ascent$4[ebp]
	push	eax
	push	esi
	fstp	DWORD PTR _font_scale$9[ebp]
	call	_stbtt_GetFontVMetrics
	movd	xmm6, DWORD PTR _unscaled_ascent$4[ebp]
	add	esp, 24					; 00000018H
	movd	xmm1, DWORD PTR _unscaled_descent$3[ebp]

; 1399 : 
; 1400 :         float ascent = unscaled_ascent * font_scale;
; 1401 :         float descent = unscaled_descent * font_scale;
; 1402 :         if (!cfg.MergeMode)

	mov	edx, DWORD PTR _cfg$1$[ebp]
	cvtdq2ps xmm6, xmm6
	cmp	BYTE PTR [edx+44], 0
	cvtdq2ps xmm1, xmm1
	mulss	xmm6, DWORD PTR _font_scale$9[ebp]
	mulss	xmm1, DWORD PTR _font_scale$9[ebp]
	movss	DWORD PTR _off_y$1$[ebp], xmm6
	jne	$LN39@Build

; 1403 :         {
; 1404 :             dst_font->ContainerAtlas = this;
; 1405 :             dst_font->ConfigData = &cfg;
; 1406 :             dst_font->ConfigDataCount = 0;

	xor	eax, eax
	mov	DWORD PTR [edi+68], ebx
	mov	DWORD PTR [edi+64], edx
	mov	WORD PTR [edi+62], ax

; 1407 :             dst_font->FontSize = cfg.SizePixels;

	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [edi], eax

; 1408 :             dst_font->Ascent = ascent;

	movss	DWORD PTR [edi+72], xmm6

; 1409 :             dst_font->Descent = descent;

	movss	DWORD PTR [edi+76], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	ecx, DWORD PTR [edi+20]
	test	ecx, ecx
	jns	SHORT $LN86@Build

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	je	SHORT $LN84@Build
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN85@Build
$LN84@Build:
	mov	eax, 8
$LN85@Build:
	xor	esi, esi
	test	eax, eax
	cmovg	esi, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	esi, ecx
	jle	SHORT $LN86@Build

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [esi+esi*4]
	shl	eax, 3
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [edi+24]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN88@Build

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [edi+16]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	shl	ecx, 3
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN88@Build:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [edi+24]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	movss	xmm5, DWORD PTR __real@3f000000
	movss	xmm6, DWORD PTR _off_y$1$[ebp]
	mov	DWORD PTR [edi+24], eax

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [edi+20], esi
$LN86@Build:
	mov	edx, DWORD PTR _cfg$1$[ebp]

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [edi+16], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1411 :             dst_font->MetricsTotalSurface = 0;

	mov	DWORD PTR [edi+80], 0
$LN39@Build:

; 1412 :         }
; 1413 :         dst_font->ConfigDataCount++;

	inc	WORD PTR [edi+62]

; 1414 :         float off_y = (cfg.MergeMode && cfg.MergeGlyphCenterV) ? (ascent - dst_font->Ascent) * 0.5f : 0.0f;

	cmp	BYTE PTR [edx+44], 0
	je	SHORT $LN50@Build
	cmp	BYTE PTR [edx+45], 0
	je	SHORT $LN50@Build
	subss	xmm6, DWORD PTR [edi+72]
	mulss	xmm6, xmm5
	movss	DWORD PTR _off_y$1$[ebp], xmm6
	jmp	SHORT $LN51@Build
$LN50@Build:
	xorps	xmm0, xmm0
	movss	DWORD PTR _off_y$1$[ebp], xmm0
$LN51@Build:

; 1417 :         for (int i = 0; i < tmp.RangesCount; i++)

	mov	esi, DWORD PTR tv1706[ebp]
	xor	ecx, ecx
	mov	DWORD PTR [edi+52], 0
	mov	DWORD PTR _i$1$[ebp], ecx
	cmp	DWORD PTR [esi], ecx
	jle	$LN30@Build

; 1415 : 
; 1416 :         dst_font->FallbackGlyph = NULL; // Always clear fallback so FindGlyph can return NULL. It will be set again in BuildLookupTable()

	xor	ebx, ebx
	mov	DWORD PTR tv1711[ebp], ebx
$LL31@Build:

; 1418 :         {
; 1419 :             stbtt_pack_range& range = tmp.Ranges[i];

	mov	eax, DWORD PTR [esi-4]

; 1420 :             for (int char_idx = 0; char_idx < range.num_chars; char_idx += 1)

	xor	esi, esi
	add	eax, ebx
	mov	DWORD PTR _char_idx$1$[ebp], esi
	mov	DWORD PTR _range$1$[ebp], eax
	cmp	DWORD PTR [eax+12], esi
	jle	$LN29@Build

; 1418 :         {
; 1419 :             stbtt_pack_range& range = tmp.Ranges[i];

	xor	ebx, ebx
	npad	3
$LL34@Build:

; 1421 :             {
; 1422 :                 const stbtt_packedchar& pc = range.chardata_for_range[char_idx];

	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR tv1731[ebp], eax

; 1423 :                 if (!pc.x0 && !pc.x1 && !pc.y0 && !pc.y1)

	cmp	WORD PTR [ebx+eax], 0
	jne	SHORT $LN40@Build
	cmp	WORD PTR [ebx+eax+4], 0
	jne	SHORT $LN40@Build
	cmp	WORD PTR [ebx+eax+2], 0
	jne	SHORT $LN40@Build
	cmp	WORD PTR [ebx+eax+6], 0
	je	$LN32@Build
$LN40@Build:

; 1424 :                     continue;
; 1425 : 
; 1426 :                 const int codepoint = range.first_unicode_codepoint_in_range + char_idx;

	mov	ecx, DWORD PTR _range$1$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, esi

; 1427 :                 if (cfg.MergeMode && dst_font->FindGlyph((unsigned short)codepoint))

	cmp	BYTE PTR [edx+44], 0
	mov	DWORD PTR _codepoint$1$[ebp], ecx
	je	SHORT $LN41@Build
	push	ecx
	mov	ecx, edi
	call	?FindGlyph@ImFont@@QBEPBUGlyph@1@G@Z	; ImFont::FindGlyph
	test	eax, eax
	jne	$LN154@Build
	mov	eax, DWORD PTR tv1731[ebp]
$LN41@Build:

; 1428 :                     continue;
; 1429 : 
; 1430 :                 stbtt_aligned_quad q;
; 1431 :                 float dummy_x = 0.0f, dummy_y = 0.0f;
; 1432 :                 stbtt_GetPackedQuad(range.chardata_for_range, TexWidth, TexHeight, char_idx, &dummy_x, &dummy_y, &q, 0);

	push	0
	lea	ecx, DWORD PTR _q$2[ebp]
	mov	DWORD PTR _dummy_x$7[ebp], 0
	push	ecx
	lea	ecx, DWORD PTR _dummy_y$8[ebp]
	mov	DWORD PTR _dummy_y$8[ebp], 0
	push	ecx
	lea	ecx, DWORD PTR _dummy_x$7[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$1$[ebp]
	push	esi
	push	DWORD PTR [ecx+16]
	push	DWORD PTR [ecx+12]
	push	eax
	call	_stbtt_GetPackedQuad

; 1434 :                 dst_font->Glyphs.resize(dst_font->Glyphs.Size + 1);

	mov	edx, DWORD PTR [edi+16]
	add	esp, 32					; 00000020H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	ecx, DWORD PTR [edi+20]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1434 :                 dst_font->Glyphs.resize(dst_font->Glyphs.Size + 1);

	inc	edx
	mov	DWORD PTR _new_size$1$[ebp], edx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	cmp	edx, ecx
	jle	SHORT $LN97@Build

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN95@Build
	mov	eax, ecx
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _new_size$1$[ebp]
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN96@Build
$LN95@Build:
	mov	eax, 8
$LN96@Build:
	cmp	eax, edx
	mov	esi, edx
	cmovg	esi, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	esi, ecx
	jle	SHORT $LN97@Build

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [esi+esi*4]
	shl	eax, 3
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [edi+24]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN99@Build

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [edi+16]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	shl	ecx, 3
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN99@Build:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [edi+24]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	edx, DWORD PTR _new_size$1$[ebp]
	mov	DWORD PTR [edi+24], eax

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [edi+20], esi
$LN97@Build:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1438 :                 glyph.U0 = q.s0; glyph.V0 = q.t0; glyph.U1 = q.s1; glyph.V1 = q.t1;

	movss	xmm0, DWORD PTR _q$2[ebp+8]
	mov	eax, edx
	movss	xmm1, DWORD PTR _q$2[ebp+4]
	movss	xmm2, DWORD PTR _q$2[ebp+20]
	movss	xmm4, DWORD PTR _q$2[ebp]
	movss	xmm3, DWORD PTR _q$2[ebp+16]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [edi+16], edx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1435 :                 ImFont::Glyph& glyph = dst_font->Glyphs.back();

	lea	edx, DWORD PTR [eax+eax*4]
	mov	esi, DWORD PTR [edi+24]

; 1436 :                 glyph.Codepoint = (ImWchar)codepoint;

	mov	eax, DWORD PTR _codepoint$1$[ebp]

; 1439 :                 glyph.Y0 += (float)(int)(dst_font->Ascent + off_y + 0.5f);

	movss	xmm5, DWORD PTR __real@3f000000
	movss	DWORD PTR [esi+edx*8-16], xmm0
	movss	xmm0, DWORD PTR _q$2[ebp+12]
	movss	DWORD PTR [esi+edx*8-12], xmm0
	movss	xmm0, DWORD PTR _q$2[ebp+24]
	movss	DWORD PTR [esi+edx*8-8], xmm0
	movss	xmm0, DWORD PTR _q$2[ebp+28]
	movss	DWORD PTR [esi+edx*8-4], xmm0
	mov	WORD PTR [esi+edx*8-40], ax
	movss	DWORD PTR [esi+edx*8-28], xmm1
	movss	DWORD PTR [esi+edx*8-20], xmm2
	movss	DWORD PTR [esi+edx*8-32], xmm4
	movss	DWORD PTR [esi+edx*8-24], xmm3
	movss	xmm0, DWORD PTR [edi+72]
	addss	xmm0, DWORD PTR _off_y$1$[ebp]
	addss	xmm0, xmm5
	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	addss	xmm0, xmm1
	movss	DWORD PTR [esi+edx*8-28], xmm0

; 1440 :                 glyph.Y1 += (float)(int)(dst_font->Ascent + off_y + 0.5f);

	movss	xmm0, DWORD PTR [edi+72]
	addss	xmm0, DWORD PTR _off_y$1$[ebp]
	addss	xmm0, xmm5
	cvttss2si eax, xmm0
	movd	xmm0, eax

; 1441 :                 glyph.XAdvance = (pc.xadvance + cfg.GlyphExtraSpacing.x);  // Bake spacing into XAdvance

	mov	eax, DWORD PTR tv1731[ebp]
	cvtdq2ps xmm0, xmm0
	addss	xmm0, xmm2
	movss	DWORD PTR [esi+edx*8-20], xmm0
	movss	xmm0, DWORD PTR [ebx+eax+16]
	mov	eax, DWORD PTR _cfg$1$[ebp]
	addss	xmm0, DWORD PTR [eax+32]
	movss	DWORD PTR [esi+edx*8-36], xmm0

; 1442 :                 if (cfg.PixelSnapH)

	cmp	BYTE PTR [eax+28], 0
	je	SHORT $LN42@Build

; 1443 :                     glyph.XAdvance = (float)(int)(glyph.XAdvance + 0.5f);

	addss	xmm0, xmm5
	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [esi+edx*8-36], xmm0
$LN42@Build:

; 1444 :                 dst_font->MetricsTotalSurface += (int)(glyph.X1 - glyph.X0 + 1.99f) * (int)(glyph.Y1 - glyph.Y0 + 1.99f); // +1 to account for average padding, +0.99 to round

	movss	xmm0, DWORD PTR [esi+edx*8-20]
	subss	xmm3, xmm4
	subss	xmm0, DWORD PTR [esi+edx*8-28]
	mov	esi, DWORD PTR _char_idx$1$[ebp]
	addss	xmm3, DWORD PTR __real@3ffeb852
	addss	xmm0, DWORD PTR __real@3ffeb852
	cvttss2si ecx, xmm3
	cvttss2si eax, xmm0
	imul	ecx, eax
	add	DWORD PTR [edi+80], ecx
$LN154@Build:
	mov	edx, DWORD PTR _cfg$1$[ebp]
$LN32@Build:

; 1420 :             for (int char_idx = 0; char_idx < range.num_chars; char_idx += 1)

	mov	eax, DWORD PTR _range$1$[ebp]
	inc	esi
	add	ebx, 28					; 0000001cH
	mov	DWORD PTR _char_idx$1$[ebp], esi
	cmp	esi, DWORD PTR [eax+12]
	jl	$LL34@Build
	mov	ecx, DWORD PTR _i$1$[ebp]
	mov	ebx, DWORD PTR tv1711[ebp]
$LN29@Build:

; 1417 :         for (int i = 0; i < tmp.RangesCount; i++)

	mov	esi, DWORD PTR tv1706[ebp]
	inc	ecx
	add	ebx, 24					; 00000018H
	mov	DWORD PTR _i$1$[ebp], ecx
	mov	DWORD PTR tv1711[ebp], ebx
	cmp	ecx, DWORD PTR [esi]
	jl	$LL31@Build
	mov	ebx, DWORD PTR _this$1$[ebp]
$LN30@Build:

; 1445 :             }
; 1446 :         }
; 1447 :         cfg.DstFont->BuildLookupTable();

	mov	ecx, DWORD PTR [edx+80]
	call	?BuildLookupTable@ImFont@@QAEXXZ	; ImFont::BuildLookupTable
	mov	eax, DWORD PTR _input_i$1$[ebp]
	add	esi, 132				; 00000084H
	mov	ecx, DWORD PTR tv1709[ebp]
	inc	eax
	movss	xmm5, DWORD PTR __real@3f000000
	add	ecx, 84					; 00000054H
	mov	DWORD PTR _input_i$1$[ebp], eax
	mov	DWORD PTR tv1709[ebp], ecx
	mov	DWORD PTR tv1706[ebp], esi
	cmp	eax, DWORD PTR [ebx+44]
	jl	$LL28@Build
$LN27@Build:

; 1448 :     }
; 1449 : 
; 1450 :     // Cleanup temporaries
; 1451 :     ImGui::MemFree(buf_packedchars);

	push	DWORD PTR _buf_packedchars$1$[ebp]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 1452 :     ImGui::MemFree(buf_ranges);

	push	DWORD PTR _buf_ranges$1$[ebp]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 1453 :     ImGui::MemFree(tmp_array);

	push	DWORD PTR _tmp_array$1$[ebp]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 12					; 0000000cH

; 1454 : 
; 1455 :     // Render into our custom data block
; 1456 :     RenderCustomTexData(1, &extra_rects);

	lea	eax, DWORD PTR _extra_rects$[ebp]
	mov	ecx, ebx
	push	eax
	push	1
	call	?RenderCustomTexData@ImFontAtlas@@QAEXHPAX@Z ; ImFontAtlas::RenderCustomTexData
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	mov	eax, DWORD PTR _extra_rects$[ebp+8]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	eax, eax
	je	SHORT $LN104@Build
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN104@Build:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1459 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	al, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?Build@ImFontAtlas@@QAE_NXZ$0:
	lea	ecx, DWORD PTR _extra_rects$[ebp]
	jmp	??1?$ImVector@Ustbrp_rect@@@@QAE@XZ	; ImVector<stbrp_rect>::~ImVector<stbrp_rect>
__ehhandler$?Build@ImFontAtlas@@QAE_NXZ:
	mov	eax, OFFSET __ehfuncinfo$?Build@ImFontAtlas@@QAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Build@ImFontAtlas@@QAE_NXZ ENDP			; ImFontAtlas::Build
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImFontConfig@@@@QAEXABUImFontConfig@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?push_back@?$ImVector@UImFontConfig@@@@QAEXABUImFontConfig@@@Z PROC ; ImVector<ImFontConfig>::push_back, COMDAT
; _this$ = ecx

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jne	SHORT $LN8@push_back
	inc	edi

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, edi
	cmovg	edi, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	edi, ecx
	jle	SHORT $LN8@push_back

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	imul	eax, edi, 84
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN10@push_back

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	imul	ecx, DWORD PTR [esi], 84
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@push_back:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN8@push_back:

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	imul	ecx, DWORD PTR [esi], 84
	mov	eax, DWORD PTR _v$[ebp]
	pop	edi
	add	ecx, DWORD PTR [esi+8]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movups	xmm0, XMMWORD PTR [eax+16]
	movups	XMMWORD PTR [ecx+16], xmm0
	movups	xmm0, XMMWORD PTR [eax+32]
	movups	XMMWORD PTR [ecx+32], xmm0
	movups	xmm0, XMMWORD PTR [eax+48]
	movups	XMMWORD PTR [ecx+48], xmm0
	movups	xmm0, XMMWORD PTR [eax+64]
	movups	XMMWORD PTR [ecx+64], xmm0
	mov	eax, DWORD PTR [eax+80]
	mov	DWORD PTR [ecx+80], eax
	inc	DWORD PTR [esi]
	pop	esi
	pop	ebp
	ret	4
?push_back@?$ImVector@UImFontConfig@@@@QAEXABUImFontConfig@@@Z ENDP ; ImVector<ImFontConfig>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImFontConfig@@@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UImFontConfig@@@@QAEXH@Z PROC	; ImVector<ImFontConfig>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	imul	eax, edi, 84
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	imul	ecx, DWORD PTR [esi], 84
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@UImFontConfig@@@@QAEXH@Z ENDP	; ImVector<ImFontConfig>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImFontConfig@@@@QAEHH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?_grow_capacity@?$ImVector@UImFontConfig@@@@QAEHH@Z PROC ; ImVector<ImFontConfig>::_grow_capacity, COMDAT
; _this$ = ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@grow_capac
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _new_size$[ebp]
	sar	ecx, 1
	add	ecx, esi
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
$LN3@grow_capac:
	mov	eax, DWORD PTR _new_size$[ebp]
	mov	ecx, 8
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
?_grow_capacity@?$ImVector@UImFontConfig@@@@QAEHH@Z ENDP ; ImVector<ImFontConfig>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImFontConfig@@@@QAEAAUImFontConfig@@XZ
_TEXT	SEGMENT
?back@?$ImVector@UImFontConfig@@@@QAEAAUImFontConfig@@XZ PROC ; ImVector<ImFontConfig>::back, COMDAT
; _this$ = ecx

; 922  :     inline value_type&          back()                          { IM_ASSERT(Size > 0); return Data[Size-1]; }

	imul	edx, DWORD PTR [ecx], 84
	mov	eax, DWORD PTR [ecx+8]
	add	eax, -84				; ffffffacH
	add	eax, edx
	ret	0
?back@?$ImVector@UImFontConfig@@@@QAEAAUImFontConfig@@XZ ENDP ; ImVector<ImFontConfig>::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImFontConfig@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$ImVector@UImFontConfig@@@@QAEXXZ PROC		; ImVector<ImFontConfig>::clear, COMDAT
; _this$ = ecx

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	npad	2
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN2@clear
	push	eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+8], 0
$LN2@clear:
	pop	esi
	ret	0
?clear@?$ImVector@UImFontConfig@@@@QAEXXZ ENDP		; ImVector<ImFontConfig>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImFontConfig@@@@QAEAAUImFontConfig@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@UImFontConfig@@@@QAEAAUImFontConfig@@H@Z PROC ; ImVector<ImFontConfig>::operator[], COMDAT
; _this$ = ecx

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	imul	eax, DWORD PTR _i$[ebp], 84
	add	eax, DWORD PTR [ecx+8]
	pop	ebp
	ret	4
??A?$ImVector@UImFontConfig@@@@QAEAAUImFontConfig@@H@Z ENDP ; ImVector<ImFontConfig>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?empty@?$ImVector@UImFontConfig@@@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$ImVector@UImFontConfig@@@@QBE_NXZ PROC		; ImVector<ImFontConfig>::empty, COMDAT
; _this$ = ecx

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	cmp	DWORD PTR [ecx], 0
	sete	al
	ret	0
?empty@?$ImVector@UImFontConfig@@@@QBE_NXZ ENDP		; ImVector<ImFontConfig>::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImFontConfig@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@UImFontConfig@@@@QAE@XZ PROC		; ImVector<ImFontConfig>::~ImVector<ImFontConfig>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@UImFontConfig@@@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@UImFontConfig@@@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@UImFontConfig@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@UImFontConfig@@@@QAE@XZ ENDP		; ImVector<ImFontConfig>::~ImVector<ImFontConfig>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImFontConfig@@@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@UImFontConfig@@@@QAE@XZ PROC		; ImVector<ImFontConfig>::ImVector<ImFontConfig>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@UImFontConfig@@@@QAE@XZ ENDP		; ImVector<ImFontConfig>::ImVector<ImFontConfig>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@PAUImFont@@@@QAEXABQAUImFont@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?push_back@?$ImVector@PAUImFont@@@@QAEXABQAUImFont@@@Z PROC ; ImVector<ImFont *>::push_back, COMDAT
; _this$ = ecx

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jne	SHORT $LN8@push_back
	inc	edi

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, edi
	cmovg	edi, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	edi, ecx
	jle	SHORT $LN8@push_back

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN10@push_back

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@push_back:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN8@push_back:

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR _v$[ebp]
	pop	edi
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+edx*4], eax
	inc	DWORD PTR [esi]
	pop	esi
	pop	ebp
	ret	4
?push_back@?$ImVector@PAUImFont@@@@QAEXABQAUImFont@@@Z ENDP ; ImVector<ImFont *>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@PAUImFont@@@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@PAUImFont@@@@QAEXH@Z PROC		; ImVector<ImFont *>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@PAUImFont@@@@QAEXH@Z ENDP		; ImVector<ImFont *>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@PAUImFont@@@@QAEHH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?_grow_capacity@?$ImVector@PAUImFont@@@@QAEHH@Z PROC	; ImVector<ImFont *>::_grow_capacity, COMDAT
; _this$ = ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@grow_capac
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _new_size$[ebp]
	sar	ecx, 1
	add	ecx, esi
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
$LN3@grow_capac:
	mov	eax, DWORD PTR _new_size$[ebp]
	mov	ecx, 8
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
?_grow_capacity@?$ImVector@PAUImFont@@@@QAEHH@Z ENDP	; ImVector<ImFont *>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?back@?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@XZ
_TEXT	SEGMENT
?back@?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@XZ PROC	; ImVector<ImFont *>::back, COMDAT
; _this$ = ecx

; 922  :     inline value_type&          back()                          { IM_ASSERT(Size > 0); return Data[Size-1]; }

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [eax+edx*4]
	add	eax, -4					; fffffffcH
	ret	0
?back@?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@XZ ENDP	; ImVector<ImFont *>::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@PAUImFont@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$ImVector@PAUImFont@@@@QAEXXZ PROC		; ImVector<ImFont *>::clear, COMDAT
; _this$ = ecx

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	npad	2
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN2@clear
	push	eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+8], 0
$LN2@clear:
	pop	esi
	ret	0
?clear@?$ImVector@PAUImFont@@@@QAEXXZ ENDP		; ImVector<ImFont *>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@H@Z PROC	; ImVector<ImFont *>::operator[], COMDAT
; _this$ = ecx

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	pop	ebp
	ret	4
??A?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@H@Z ENDP	; ImVector<ImFont *>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@PAUImFont@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@PAUImFont@@@@QAE@XZ PROC			; ImVector<ImFont *>::~ImVector<ImFont *>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@PAUImFont@@@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@PAUImFont@@@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@PAUImFont@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@PAUImFont@@@@QAE@XZ ENDP			; ImVector<ImFont *>::~ImVector<ImFont *>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@PAUImFont@@@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@PAUImFont@@@@QAE@XZ PROC			; ImVector<ImFont *>::ImVector<ImFont *>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@PAUImFont@@@@QAE@XZ ENDP			; ImVector<ImFont *>::ImVector<ImFont *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
?GetGlyphRangesThai@ImFontAtlas@@QAEPBGXZ PROC		; ImFontAtlas::GetGlyphRangesThai
; _this$ = ecx

; 1670 :     static const ImWchar ranges[] =
; 1671 :     {
; 1672 :         0x0020, 0x00FF, // Basic Latin
; 1673 :         0x0E00, 0x0E7F, // Thai
; 1674 :         0,
; 1675 :     };
; 1676 :     return &ranges[0];

	mov	eax, OFFSET ?ranges@?1??GetGlyphRangesThai@ImFontAtlas@@QAEPBGXZ@4QBGB

; 1677 : }

	ret	0
?GetGlyphRangesThai@ImFontAtlas@@QAEPBGXZ ENDP		; ImFontAtlas::GetGlyphRangesThai
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
?GetGlyphRangesCyrillic@ImFontAtlas@@QAEPBGXZ PROC	; ImFontAtlas::GetGlyphRangesCyrillic
; _this$ = ecx

; 1657 :     static const ImWchar ranges[] =
; 1658 :     {
; 1659 :         0x0020, 0x00FF, // Basic Latin + Latin Supplement
; 1660 :         0x0400, 0x052F, // Cyrillic + Cyrillic Supplement
; 1661 :         0x2DE0, 0x2DFF, // Cyrillic Extended-A
; 1662 :         0xA640, 0xA69F, // Cyrillic Extended-B
; 1663 :         0,
; 1664 :     };
; 1665 :     return &ranges[0];

	mov	eax, OFFSET ?ranges@?1??GetGlyphRangesCyrillic@ImFontAtlas@@QAEPBGXZ@4QBGB

; 1666 : }

	ret	0
?GetGlyphRangesCyrillic@ImFontAtlas@@QAEPBGXZ ENDP	; ImFontAtlas::GetGlyphRangesCyrillic
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
?GetGlyphRangesChinese@ImFontAtlas@@QAEPBGXZ PROC	; ImFontAtlas::GetGlyphRangesChinese
; _this$ = ecx

; 1578 :     static const ImWchar ranges[] =
; 1579 :     {
; 1580 :         0x0020, 0x00FF, // Basic Latin + Latin Supplement
; 1581 :         0x3000, 0x30FF, // Punctuations, Hiragana, Katakana
; 1582 :         0x31F0, 0x31FF, // Katakana Phonetic Extensions
; 1583 :         //0x4e00, 0x9FAF, // CJK Ideograms (FULL Range)
; 1584 :         //0x4E00, 0x62FF, // Reduced CJK Ideograms
; 1585 :         //0x8D00, 0x9FCC, // Reduced CJK Ideograms 2
; 1586 :         0xF900, 0xFAFF, // CJK Compat Ideograms
; 1587 :         0xFF00, 0xFFEF, // Half-width characters
; 1588 :         0,
; 1589 :     };
; 1590 :     return &ranges[0];

	mov	eax, OFFSET ?ranges@?1??GetGlyphRangesChinese@ImFontAtlas@@QAEPBGXZ@4QBGB

; 1591 : }

	ret	0
?GetGlyphRangesChinese@ImFontAtlas@@QAEPBGXZ ENDP	; ImFontAtlas::GetGlyphRangesChinese
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
?GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ PROC	; ImFontAtlas::GetGlyphRangesJapanese
; _this$ = ecx

; 1595 :     // Store the 1946 ideograms code points as successive offsets from the initial unicode codepoint 0x4E00. Each offset has an implicit +1.
; 1596 :     // This encoding helps us reduce the source code size.
; 1597 :     static const short offsets_from_0x4E00[] =
; 1598 :     {
; 1599 :         -1,0,1,3,0,0,0,0,1,0,5,1,1,0,7,4,6,10,0,1,9,9,7,1,3,19,1,10,7,1,0,1,0,5,1,0,6,4,2,6,0,0,12,6,8,0,3,5,0,1,0,9,0,0,8,1,1,3,4,5,13,0,0,8,2,17,
; 1600 :         4,3,1,1,9,6,0,0,0,2,1,3,2,22,1,9,11,1,13,1,3,12,0,5,9,2,0,6,12,5,3,12,4,1,2,16,1,1,4,6,5,3,0,6,13,15,5,12,8,14,0,0,6,15,3,6,0,18,8,1,6,14,1,
; 1601 :         5,4,12,24,3,13,12,10,24,0,0,0,1,0,1,1,2,9,10,2,2,0,0,3,3,1,0,3,8,0,3,2,4,4,1,6,11,10,14,6,15,3,4,15,1,0,0,5,2,2,0,0,1,6,5,5,6,0,3,6,5,0,0,1,0,
; 1602 :         11,2,2,8,4,7,0,10,0,1,2,17,19,3,0,2,5,0,6,2,4,4,6,1,1,11,2,0,3,1,2,1,2,10,7,6,3,16,0,8,24,0,0,3,1,1,3,0,1,6,0,0,0,2,0,1,5,15,0,1,0,0,2,11,19,
; 1603 :         1,4,19,7,6,5,1,0,0,0,0,5,1,0,1,9,0,0,5,0,2,0,1,0,3,0,11,3,0,2,0,0,0,0,0,9,3,6,4,12,0,14,0,0,29,10,8,0,14,37,13,0,31,16,19,0,8,30,1,20,8,3,48,
; 1604 :         21,1,0,12,0,10,44,34,42,54,11,18,82,0,2,1,2,12,1,0,6,2,17,2,12,7,0,7,17,4,2,6,24,23,8,23,39,2,16,23,1,0,5,1,2,15,14,5,6,2,11,0,8,6,2,2,2,14,
; 1605 :         20,4,15,3,4,11,10,10,2,5,2,1,30,2,1,0,0,22,5,5,0,3,1,5,4,1,0,0,2,2,21,1,5,1,2,16,2,1,3,4,0,8,4,0,0,5,14,11,2,16,1,13,1,7,0,22,15,3,1,22,7,14,
; 1606 :         22,19,11,24,18,46,10,20,64,45,3,2,0,4,5,0,1,4,25,1,0,0,2,10,0,0,0,1,0,1,2,0,0,9,1,2,0,0,0,2,5,2,1,1,5,5,8,1,1,1,5,1,4,9,1,3,0,1,0,1,1,2,0,0,
; 1607 :         2,0,1,8,22,8,1,0,0,0,0,4,2,1,0,9,8,5,0,9,1,30,24,2,6,4,39,0,14,5,16,6,26,179,0,2,1,1,0,0,0,5,2,9,6,0,2,5,16,7,5,1,1,0,2,4,4,7,15,13,14,0,0,
; 1608 :         3,0,1,0,0,0,2,1,6,4,5,1,4,9,0,3,1,8,0,0,10,5,0,43,0,2,6,8,4,0,2,0,0,9,6,0,9,3,1,6,20,14,6,1,4,0,7,2,3,0,2,0,5,0,3,1,0,3,9,7,0,3,4,0,4,9,1,6,0,
; 1609 :         9,0,0,2,3,10,9,28,3,6,2,4,1,2,32,4,1,18,2,0,3,1,5,30,10,0,2,2,2,0,7,9,8,11,10,11,7,2,13,7,5,10,0,3,40,2,0,1,6,12,0,4,5,1,5,11,11,21,4,8,3,7,
; 1610 :         8,8,33,5,23,0,0,19,8,8,2,3,0,6,1,1,1,5,1,27,4,2,5,0,3,5,6,3,1,0,3,1,12,5,3,3,2,0,7,7,2,1,0,4,0,1,1,2,0,10,10,6,2,5,9,7,5,15,15,21,6,11,5,20,
; 1611 :         4,3,5,5,2,5,0,2,1,0,1,7,28,0,9,0,5,12,5,5,18,30,0,12,3,3,21,16,25,32,9,3,14,11,24,5,66,9,1,2,0,5,9,1,5,1,8,0,8,3,3,0,1,15,1,4,8,1,2,7,0,7,2,
; 1612 :         8,3,7,5,3,7,10,2,1,0,0,2,25,0,6,4,0,10,0,4,2,4,1,12,5,38,4,0,4,1,10,5,9,4,0,14,4,2,5,18,20,21,1,3,0,5,0,7,0,3,7,1,3,1,1,8,1,0,0,0,3,2,5,2,11,
; 1613 :         6,0,13,1,3,9,1,12,0,16,6,2,1,0,2,1,12,6,13,11,2,0,28,1,7,8,14,13,8,13,0,2,0,5,4,8,10,2,37,42,19,6,6,7,4,14,11,18,14,80,7,6,0,4,72,12,36,27,
; 1614 :         7,7,0,14,17,19,164,27,0,5,10,7,3,13,6,14,0,2,2,5,3,0,6,13,0,0,10,29,0,4,0,3,13,0,3,1,6,51,1,5,28,2,0,8,0,20,2,4,0,25,2,10,13,10,0,16,4,0,1,0,
; 1615 :         2,1,7,0,1,8,11,0,0,1,2,7,2,23,11,6,6,4,16,2,2,2,0,22,9,3,3,5,2,0,15,16,21,2,9,20,15,15,5,3,9,1,0,0,1,7,7,5,4,2,2,2,38,24,14,0,0,15,5,6,24,14,
; 1616 :         5,5,11,0,21,12,0,3,8,4,11,1,8,0,11,27,7,2,4,9,21,59,0,1,39,3,60,62,3,0,12,11,0,3,30,11,0,13,88,4,15,5,28,13,1,4,48,17,17,4,28,32,46,0,16,0,
; 1617 :         18,11,1,8,6,38,11,2,6,11,38,2,0,45,3,11,2,7,8,4,30,14,17,2,1,1,65,18,12,16,4,2,45,123,12,56,33,1,4,3,4,7,0,0,0,3,2,0,16,4,2,4,2,0,7,4,5,2,26,
; 1618 :         2,25,6,11,6,1,16,2,6,17,77,15,3,35,0,1,0,5,1,0,38,16,6,3,12,3,3,3,0,9,3,1,3,5,2,9,0,18,0,25,1,3,32,1,72,46,6,2,7,1,3,14,17,0,28,1,40,13,0,20,
; 1619 :         15,40,6,38,24,12,43,1,1,9,0,12,6,0,6,2,4,19,3,7,1,48,0,9,5,0,5,6,9,6,10,15,2,11,19,3,9,2,0,1,10,1,27,8,1,3,6,1,14,0,26,0,27,16,3,4,9,6,2,23,
; 1620 :         9,10,5,25,2,1,6,1,1,48,15,9,15,14,3,4,26,60,29,13,37,21,1,6,4,0,2,11,22,23,16,16,2,2,1,3,0,5,1,6,4,0,0,4,0,0,8,3,0,2,5,0,7,1,7,3,13,2,4,10,
; 1621 :         3,0,2,31,0,18,3,0,12,10,4,1,0,7,5,7,0,5,4,12,2,22,10,4,2,15,2,8,9,0,23,2,197,51,3,1,1,4,13,4,3,21,4,19,3,10,5,40,0,4,1,1,10,4,1,27,34,7,21,
; 1622 :         2,17,2,9,6,4,2,3,0,4,2,7,8,2,5,1,15,21,3,4,4,2,2,17,22,1,5,22,4,26,7,0,32,1,11,42,15,4,1,2,5,0,19,3,1,8,6,0,10,1,9,2,13,30,8,2,24,17,19,1,4,
; 1623 :         4,25,13,0,10,16,11,39,18,8,5,30,82,1,6,8,18,77,11,13,20,75,11,112,78,33,3,0,0,60,17,84,9,1,1,12,30,10,49,5,32,158,178,5,5,6,3,3,1,3,1,4,7,6,
; 1624 :         19,31,21,0,2,9,5,6,27,4,9,8,1,76,18,12,1,4,0,3,3,6,3,12,2,8,30,16,2,25,1,5,5,4,3,0,6,10,2,3,1,0,5,1,19,3,0,8,1,5,2,6,0,0,0,19,1,2,0,5,1,2,5,
; 1625 :         1,3,7,0,4,12,7,3,10,22,0,9,5,1,0,2,20,1,1,3,23,30,3,9,9,1,4,191,14,3,15,6,8,50,0,1,0,0,4,0,0,1,0,2,4,2,0,2,3,0,2,0,2,2,8,7,0,1,1,1,3,3,17,11,
; 1626 :         91,1,9,3,2,13,4,24,15,41,3,13,3,1,20,4,125,29,30,1,0,4,12,2,21,4,5,5,19,11,0,13,11,86,2,18,0,7,1,8,8,2,2,22,1,2,6,5,2,0,1,2,8,0,2,0,5,2,1,0,
; 1627 :         2,10,2,0,5,9,2,1,2,0,1,0,4,0,0,10,2,5,3,0,6,1,0,1,4,4,33,3,13,17,3,18,6,4,7,1,5,78,0,4,1,13,7,1,8,1,0,35,27,15,3,0,0,0,1,11,5,41,38,15,22,6,
; 1628 :         14,14,2,1,11,6,20,63,5,8,27,7,11,2,2,40,58,23,50,54,56,293,8,8,1,5,1,14,0,1,12,37,89,8,8,8,2,10,6,0,0,0,4,5,2,1,0,1,1,2,7,0,3,3,0,4,6,0,3,2,
; 1629 :         19,3,8,0,0,0,4,4,16,0,4,1,5,1,3,0,3,4,6,2,17,10,10,31,6,4,3,6,10,126,7,3,2,2,0,9,0,0,5,20,13,0,15,0,6,0,2,5,8,64,50,3,2,12,2,9,0,0,11,8,20,
; 1630 :         109,2,18,23,0,0,9,61,3,0,28,41,77,27,19,17,81,5,2,14,5,83,57,252,14,154,263,14,20,8,13,6,57,39,38,
; 1631 :     };
; 1632 :     static ImWchar base_ranges[] =
; 1633 :     {
; 1634 :         0x0020, 0x00FF, // Basic Latin + Latin Supplement
; 1635 :         0x3000, 0x30FF, // Punctuations, Hiragana, Katakana
; 1636 :         0x31F0, 0x31FF, // Katakana Phonetic Extensions
; 1637 :         0xFF00, 0xFFEF, // Half-width characters
; 1638 :     };
; 1639 :     static bool full_ranges_unpacked = false;
; 1640 :     static ImWchar full_ranges[IM_ARRAYSIZE(base_ranges) + IM_ARRAYSIZE(offsets_from_0x4E00)*2 + 1];
; 1641 :     if (!full_ranges_unpacked)

	cmp	BYTE PTR ?full_ranges_unpacked@?1??GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ@4_NA, 0
	jne	SHORT $LN12@GetGlyphRa

; 1642 :     {
; 1643 :         // Unpack
; 1644 :         int codepoint = 0x4e00;
; 1645 :         memcpy(full_ranges, base_ranges, sizeof(base_ranges));

	movups	xmm0, XMMWORD PTR ?base_ranges@?1??GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ@4PAGA
	push	esi
	mov	edx, 19968				; 00004e00H

; 1646 :         ImWchar* dst = full_ranges + IM_ARRAYSIZE(base_ranges);;

	mov	eax, OFFSET ?full_ranges@?1??GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ@4PAGA+16
	movups	XMMWORD PTR ?full_ranges@?1??GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ@4PAGA, xmm0
	mov	esi, OFFSET ?offsets_from_0x4E00@?1??GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ@4QBFB+2
$LL4@GetGlyphRa:

; 1647 :         for (int n = 0; n < IM_ARRAYSIZE(offsets_from_0x4E00); n++, dst += 2)
; 1648 :             dst[0] = dst[1] = (ImWchar)(codepoint += (offsets_from_0x4E00[n] + 1));

	movsx	ecx, WORD PTR [esi-2]
	lea	eax, DWORD PTR [eax+8]
	inc	ecx
	add	edx, ecx
	movsx	ecx, WORD PTR [esi]
	mov	WORD PTR [eax-6], dx
	add	esi, 4
	mov	WORD PTR [eax-8], dx
	inc	edx
	add	edx, ecx
	mov	WORD PTR [eax-2], dx
	mov	WORD PTR [eax-4], dx
	cmp	esi, OFFSET ?offsets_from_0x4E00@?1??GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ@4QBFB+3894
	jl	SHORT $LL4@GetGlyphRa

; 1649 :         dst[0] = 0;

	xor	ecx, ecx

; 1650 :         full_ranges_unpacked = true;

	mov	BYTE PTR ?full_ranges_unpacked@?1??GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ@4_NA, 1
	mov	WORD PTR [eax], cx
	pop	esi
$LN12@GetGlyphRa:

; 1651 :     }
; 1652 :     return &full_ranges[0];

	mov	eax, OFFSET ?full_ranges@?1??GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ@4PAGA

; 1653 : }

	ret	0
?GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ ENDP	; ImFontAtlas::GetGlyphRangesJapanese
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
?GetGlyphRangesKorean@ImFontAtlas@@QAEPBGXZ PROC	; ImFontAtlas::GetGlyphRangesKorean
; _this$ = ecx

; 1566 :     static const ImWchar ranges[] =
; 1567 :     {
; 1568 :         0x0020, 0x00FF, // Basic Latin + Latin Supplement
; 1569 :         0x3131, 0x3163, // Korean alphabets
; 1570 :         0xAC00, 0xD79D, // Korean characters
; 1571 :         0,
; 1572 :     };
; 1573 :     return &ranges[0];

	mov	eax, OFFSET ?ranges@?1??GetGlyphRangesKorean@ImFontAtlas@@QAEPBGXZ@4QBGB

; 1574 : }

	ret	0
?GetGlyphRangesKorean@ImFontAtlas@@QAEPBGXZ ENDP	; ImFontAtlas::GetGlyphRangesKorean
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
?GetGlyphRangesDefault@ImFontAtlas@@QAEPBGXZ PROC	; ImFontAtlas::GetGlyphRangesDefault
; _this$ = ecx

; 1556 :     static const ImWchar ranges[] =
; 1557 :     {
; 1558 :         0x0020, 0x00FF, // Basic Latin + Latin Supplement
; 1559 :         0,
; 1560 :     };
; 1561 :     return &ranges[0];

	mov	eax, OFFSET ?ranges@?1??GetGlyphRangesDefault@ImFontAtlas@@QAEPBGXZ@4QBGB

; 1562 : }

	ret	0
?GetGlyphRangesDefault@ImFontAtlas@@QAEPBGXZ ENDP	; ImFontAtlas::GetGlyphRangesDefault
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_pixels$1 = -4						; size = 4
_out_pixels$ = 8					; size = 4
_out_width$ = 12					; size = 4
_out_height$ = 16					; size = 4
_out_bytes_per_pixel$ = 20				; size = 4
?GetTexDataAsRGBA32@ImFontAtlas@@QAEXPAPAEPAH11@Z PROC	; ImFontAtlas::GetTexDataAsRGBA32
; _this$ = ecx

; 1119 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	edi
	mov	edi, ecx

; 1120 :     // Convert to RGBA32 format on demand
; 1121 :     // Although it is likely to be the most commonly used format, our font rendering is 1 channel / 8 bpp
; 1122 :     if (!TexPixelsRGBA32)

	cmp	DWORD PTR [edi+8], 0
	jne	SHORT $LN3@GetTexData

; 1123 :     {
; 1124 :         unsigned char* pixels;
; 1125 :         GetTexDataAsAlpha8(&pixels, NULL, NULL);

	push	esi
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _pixels$1[ebp]
	push	eax
	call	?GetTexDataAsAlpha8@ImFontAtlas@@QAEXPAPAEPAH11@Z ; ImFontAtlas::GetTexDataAsAlpha8

; 1126 :         TexPixelsRGBA32 = (unsigned int*)ImGui::MemAlloc((size_t)(TexWidth * TexHeight * 4));

	mov	eax, DWORD PTR [edi+12]
	imul	eax, DWORD PTR [edi+16]
	shl	eax, 2
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 1127 :         const unsigned char* src = pixels;
; 1128 :         unsigned int* dst = TexPixelsRGBA32;
; 1129 :         for (int n = TexWidth * TexHeight; n > 0; n--)

	mov	ecx, DWORD PTR [edi+12]
	add	esp, 4
	imul	ecx, DWORD PTR [edi+16]
	mov	edx, eax
	mov	esi, DWORD PTR _pixels$1[ebp]
	mov	DWORD PTR [edi+8], edx
	test	ecx, ecx
	jle	SHORT $LN14@GetTexData
$LL4@GetTexData:

; 1130 :             *dst++ = IM_COL32(255, 255, 255, (unsigned int)(*src++));

	movzx	eax, BYTE PTR [esi]
	lea	edx, DWORD PTR [edx+4]
	shl	eax, 24					; 00000018H
	lea	esi, DWORD PTR [esi+1]
	or	eax, 16777215				; 00ffffffH
	dec	ecx
	mov	DWORD PTR [edx-4], eax
	test	ecx, ecx
	jg	SHORT $LL4@GetTexData
$LN14@GetTexData:
	pop	esi
$LN3@GetTexData:

; 1131 :     }
; 1132 : 
; 1133 :     *out_pixels = (unsigned char*)TexPixelsRGBA32;

	mov	eax, DWORD PTR _out_pixels$[ebp]
	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR [eax], ecx

; 1134 :     if (out_width) *out_width = TexWidth;

	mov	ecx, DWORD PTR _out_width$[ebp]
	test	ecx, ecx
	je	SHORT $LN6@GetTexData
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [ecx], eax
$LN6@GetTexData:

; 1135 :     if (out_height) *out_height = TexHeight;

	mov	ecx, DWORD PTR _out_height$[ebp]
	test	ecx, ecx
	je	SHORT $LN7@GetTexData
	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR [ecx], eax
$LN7@GetTexData:

; 1136 :     if (out_bytes_per_pixel) *out_bytes_per_pixel = 4;

	mov	eax, DWORD PTR _out_bytes_per_pixel$[ebp]
	pop	edi
	test	eax, eax
	je	SHORT $LN8@GetTexData
	mov	DWORD PTR [eax], 4
$LN8@GetTexData:

; 1137 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?GetTexDataAsRGBA32@ImFontAtlas@@QAEXPAPAEPAH11@Z ENDP	; ImFontAtlas::GetTexDataAsRGBA32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_out_pixels$ = 8					; size = 4
_out_width$ = 12					; size = 4
_out_height$ = 16					; size = 4
_out_bytes_per_pixel$ = 20				; size = 4
?GetTexDataAsAlpha8@ImFontAtlas@@QAEXPAPAEPAH11@Z PROC	; ImFontAtlas::GetTexDataAsAlpha8
; _this$ = ecx

; 1103 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 1104 :     // Build atlas on demand
; 1105 :     if (TexPixelsAlpha8 == NULL)

	cmp	DWORD PTR [esi+4], 0
	jne	SHORT $LN2@GetTexData
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	cmp	DWORD PTR [esi+44], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1107 :         if (ConfigData.empty())

	jne	SHORT $LN3@GetTexData

; 1108 :             AddFontDefault();

	push	0
	call	?AddFontDefault@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z ; ImFontAtlas::AddFontDefault
$LN3@GetTexData:

; 1109 :         Build();

	mov	ecx, esi
	call	?Build@ImFontAtlas@@QAE_NXZ		; ImFontAtlas::Build
$LN2@GetTexData:

; 1110 :     }
; 1111 : 
; 1112 :     *out_pixels = TexPixelsAlpha8;

	mov	eax, DWORD PTR _out_pixels$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], ecx

; 1113 :     if (out_width) *out_width = TexWidth;

	mov	ecx, DWORD PTR _out_width$[ebp]
	test	ecx, ecx
	je	SHORT $LN4@GetTexData
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [ecx], eax
$LN4@GetTexData:

; 1114 :     if (out_height) *out_height = TexHeight;

	mov	ecx, DWORD PTR _out_height$[ebp]
	test	ecx, ecx
	je	SHORT $LN5@GetTexData
	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx], eax
$LN5@GetTexData:

; 1115 :     if (out_bytes_per_pixel) *out_bytes_per_pixel = 1;

	mov	eax, DWORD PTR _out_bytes_per_pixel$[ebp]
	pop	esi
	test	eax, eax
	je	SHORT $LN6@GetTexData
	mov	DWORD PTR [eax], 1
$LN6@GetTexData:

; 1116 : }

	pop	ebp
	ret	16					; 00000010H
?GetTexDataAsAlpha8@ImFontAtlas@@QAEXPAPAEPAH11@Z ENDP	; ImFontAtlas::GetTexDataAsAlpha8
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
?Clear@ImFontAtlas@@QAEXXZ PROC				; ImFontAtlas::Clear
; _this$ = ecx

; 1096 : {

	npad	2
	push	esi
	mov	esi, ecx

; 1097 :     ClearInputData();

	call	?ClearInputData@ImFontAtlas@@QAEXXZ	; ImFontAtlas::ClearInputData

; 1098 :     ClearTexData();

	mov	ecx, esi
	call	?ClearTexData@ImFontAtlas@@QAEXXZ	; ImFontAtlas::ClearTexData

; 1099 :     ClearFonts();

	mov	ecx, esi
	pop	esi
	jmp	?ClearFonts@ImFontAtlas@@QAEXXZ		; ImFontAtlas::ClearFonts
?Clear@ImFontAtlas@@QAEXXZ ENDP				; ImFontAtlas::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
?ClearFonts@ImFontAtlas@@QAEXXZ PROC			; ImFontAtlas::ClearFonts
; _this$ = ecx

; 1086 : {

	npad	2
	push	esi
	mov	esi, ecx
	push	edi

; 1087 :     for (int i = 0; i < Fonts.Size; i++)

	xor	edi, edi
	cmp	DWORD PTR [esi+32], edi
	jle	SHORT $LN3@ClearFonts
	npad	3
$LL4@ClearFonts:

; 1088 :     {
; 1089 :         Fonts[i]->~ImFont();

	mov	eax, DWORD PTR [esi+40]
	mov	ecx, DWORD PTR [eax+edi*4]
	call	??1ImFont@@QAE@XZ			; ImFont::~ImFont

; 1090 :         ImGui::MemFree(Fonts[i]);

	mov	eax, DWORD PTR [esi+40]
	push	DWORD PTR [eax+edi*4]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	inc	edi
	add	esp, 4
	cmp	edi, DWORD PTR [esi+32]
	jl	SHORT $LL4@ClearFonts
$LN3@ClearFonts:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	mov	eax, DWORD PTR [esi+40]
	test	eax, eax
	je	SHORT $LN15@ClearFonts
	push	eax
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+32], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+40], 0
$LN15@ClearFonts:
	pop	edi
	pop	esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1093 : }

	ret	0
?ClearFonts@ImFontAtlas@@QAEXXZ ENDP			; ImFontAtlas::ClearFonts
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
?ClearInputData@ImFontAtlas@@QAEXXZ PROC		; ImFontAtlas::ClearInputData
; _this$ = ecx

; 1057 : {

	npad	2
	push	ebx
	push	esi
	mov	esi, ecx

; 1058 :     for (int i = 0; i < ConfigData.Size; i++)

	xor	ebx, ebx
	push	edi
	cmp	DWORD PTR [esi+44], ebx
	jle	SHORT $LN3@ClearInput
	xor	edi, edi
$LL4@ClearInput:

; 1059 :         if (ConfigData[i].FontData && ConfigData[i].FontDataOwnedByAtlas)

	mov	eax, DWORD PTR [esi+52]
	mov	ecx, DWORD PTR [edi+eax]
	test	ecx, ecx
	je	SHORT $LN2@ClearInput
	cmp	BYTE PTR [edi+eax+8], 0
	je	SHORT $LN2@ClearInput

; 1060 :         {
; 1061 :             ImGui::MemFree(ConfigData[i].FontData);

	push	ecx
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 1062 :             ConfigData[i].FontData = NULL;

	mov	eax, DWORD PTR [esi+52]
	add	esp, 4
	mov	DWORD PTR [edi+eax], 0
$LN2@ClearInput:

; 1058 :     for (int i = 0; i < ConfigData.Size; i++)

	inc	ebx
	add	edi, 84					; 00000054H
	cmp	ebx, DWORD PTR [esi+44]
	jl	SHORT $LL4@ClearInput
$LN3@ClearInput:

; 1063 :         }
; 1064 : 
; 1065 :     // When clearing this we lose access to the font name and other information used to build the font.
; 1066 :     for (int i = 0; i < Fonts.Size; i++)

	xor	ecx, ecx
	cmp	DWORD PTR [esi+32], ecx
	jle	SHORT $LN6@ClearInput
$LL7@ClearInput:

; 1067 :         if (Fonts[i]->ConfigData >= ConfigData.Data && Fonts[i]->ConfigData < ConfigData.Data + ConfigData.Size)

	mov	eax, DWORD PTR [esi+40]
	mov	edi, DWORD PTR [esi+52]
	mov	ebx, DWORD PTR [eax+ecx*4]
	mov	edx, DWORD PTR [ebx+64]
	cmp	edx, edi
	jb	SHORT $LN5@ClearInput
	imul	eax, DWORD PTR [esi+44], 84
	add	eax, edi
	cmp	edx, eax
	jae	SHORT $LN5@ClearInput

; 1068 :         {
; 1069 :             Fonts[i]->ConfigData = NULL;

	mov	DWORD PTR [ebx+64], 0

; 1070 :             Fonts[i]->ConfigDataCount = 0;

	xor	edx, edx
	mov	eax, DWORD PTR [esi+40]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	WORD PTR [eax+62], dx
$LN5@ClearInput:

; 1063 :         }
; 1064 : 
; 1065 :     // When clearing this we lose access to the font name and other information used to build the font.
; 1066 :     for (int i = 0; i < Fonts.Size; i++)

	inc	ecx
	cmp	ecx, DWORD PTR [esi+32]
	jl	SHORT $LL7@ClearInput
$LN6@ClearInput:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	mov	eax, DWORD PTR [esi+52]
	test	eax, eax
	je	SHORT $LN28@ClearInput
	push	eax
	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+44], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+52], 0
$LN28@ClearInput:
	pop	edi
	pop	esi
	pop	ebx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1073 : }

	ret	0
?ClearInputData@ImFontAtlas@@QAEXXZ ENDP		; ImFontAtlas::ClearInputData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
?ClearTexData@ImFontAtlas@@QAEXXZ PROC			; ImFontAtlas::ClearTexData
; _this$ = ecx

; 1076 : {

	npad	2
	push	esi
	mov	esi, ecx

; 1077 :     if (TexPixelsAlpha8)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN2@ClearTexDa

; 1078 :         ImGui::MemFree(TexPixelsAlpha8);

	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ClearTexDa:

; 1079 :     if (TexPixelsRGBA32)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN5@ClearTexDa

; 1080 :         ImGui::MemFree(TexPixelsRGBA32);

	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN5@ClearTexDa:

; 1081 :     TexPixelsAlpha8 = NULL;
; 1082 :     TexPixelsRGBA32 = NULL;

	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+4], 0
	pop	esi

; 1083 : }

	ret	0
?ClearTexData@ImFontAtlas@@QAEXXZ ENDP			; ImFontAtlas::ClearTexData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_compressed_ttf_data_base85$ = 8			; size = 4
_size_pixels$ = 12					; size = 4
_font_cfg$ = 16						; size = 4
_glyph_ranges$ = 20					; size = 4
?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QAEPAUImFont@@PBDMPBUImFontConfig@@PBG@Z PROC ; ImFontAtlas::AddFontFromMemoryCompressedBase85TTF
; _this$ = ecx

; 1246 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$1$[ebp], ecx

; 1247 :     int compressed_ttf_size = (((int)strlen(compressed_ttf_data_base85) + 4) / 5) * 4;

	mov	ecx, DWORD PTR _compressed_ttf_data_base85$[ebp]
	lea	edx, DWORD PTR [ecx+1]
	npad	1
$LL3@AddFontFro:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL3@AddFontFro
	sub	ecx, edx
	mov	eax, 1717986919				; 66666667H
	add	ecx, 4
	imul	ecx
	push	esi
	sar	edx, 1
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	push	edi
	shl	esi, 2

; 1248 :     void* compressed_ttf = ImGui::MemAlloc((size_t)compressed_ttf_size);

	push	esi
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	edi, eax

; 1249 :     Decode85((const unsigned char*)compressed_ttf_data_base85, (unsigned char*)compressed_ttf);

	push	edi
	push	DWORD PTR _compressed_ttf_data_base85$[ebp]
	call	?Decode85@@YAXPBEPAE@Z			; Decode85

; 1250 :     ImFont* font = AddFontFromMemoryCompressedTTF(compressed_ttf, compressed_ttf_size, size_pixels, font_cfg, glyph_ranges);

	movss	xmm0, DWORD PTR _size_pixels$[ebp]
	add	esp, 12					; 0000000cH
	push	DWORD PTR _glyph_ranges$[ebp]
	push	DWORD PTR _font_cfg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	esi
	push	edi
	call	?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QAEPAUImFont@@PBXHMPBUImFontConfig@@PBG@Z ; ImFontAtlas::AddFontFromMemoryCompressedTTF

; 1251 :     ImGui::MemFree(compressed_ttf);

	push	edi
	mov	esi, eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 1252 :     return font;

	mov	eax, esi
	pop	edi
	pop	esi

; 1253 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QAEPAUImFont@@PBDMPBUImFontConfig@@PBG@Z ENDP ; ImFontAtlas::AddFontFromMemoryCompressedBase85TTF
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T1 = -172						; size = 84
$T2 = -172						; size = 84
_font_cfg$ = -88					; size = 84
_this$1$ = -4						; size = 4
_compressed_ttf_data$ = 8				; size = 4
_compressed_ttf_size$ = 12				; size = 4
_size_pixels$ = 16					; size = 4
_font_cfg_template$ = 20				; size = 4
_glyph_ranges$ = 24					; size = 4
?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QAEPAUImFont@@PBXHMPBUImFontConfig@@PBG@Z PROC ; ImFontAtlas::AddFontFromMemoryCompressedTTF
; _this$ = ecx

; 1234 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	push	ebx
	push	edi

; 1235 :     const unsigned int buf_decompressed_size = stb_decompress_length((unsigned char*)compressed_ttf_data);

	push	DWORD PTR _compressed_ttf_data$[ebp]
	mov	DWORD PTR _this$1$[ebp], ecx
	call	?stb_decompress_length@@YAIPAE@Z	; stb_decompress_length
	mov	edi, eax

; 1236 :     unsigned char* buf_decompressed_data = (unsigned char *)ImGui::MemAlloc(buf_decompressed_size);

	push	edi
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 1237 :     stb_decompress(buf_decompressed_data, (unsigned char*)compressed_ttf_data, (unsigned int)compressed_ttf_size);

	push	DWORD PTR _compressed_ttf_size$[ebp]
	mov	ebx, eax
	push	DWORD PTR _compressed_ttf_data$[ebp]
	push	ebx
	call	?stb_decompress@@YAIPAE0I@Z		; stb_decompress

; 1238 : 
; 1239 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

	mov	eax, DWORD PTR _font_cfg_template$[ebp]
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN3@AddFontFro
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR $T2[ebp], xmm0
	movups	xmm0, XMMWORD PTR [eax+16]
	movups	XMMWORD PTR $T2[ebp+16], xmm0
	movups	xmm0, XMMWORD PTR [eax+32]
	movups	XMMWORD PTR $T2[ebp+32], xmm0
	movups	xmm0, XMMWORD PTR [eax+48]
	movups	XMMWORD PTR $T2[ebp+48], xmm0
	movups	xmm0, XMMWORD PTR [eax+64]
	mov	eax, DWORD PTR [eax+80]
	mov	DWORD PTR $T2[ebp+80], eax
	lea	eax, DWORD PTR $T2[ebp]
	movups	XMMWORD PTR $T2[ebp+64], xmm0
	jmp	SHORT $LN4@AddFontFro
$LN3@AddFontFro:
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0ImFontConfig@@QAE@XZ			; ImFontConfig::ImFontConfig
$LN4@AddFontFro:
	movups	xmm0, XMMWORD PTR [eax]

; 1240 :     IM_ASSERT(font_cfg.FontData == NULL);
; 1241 :     font_cfg.FontDataOwnedByAtlas = true;
; 1242 :     return AddFontFromMemoryTTF(buf_decompressed_data, (int)buf_decompressed_size, size_pixels, &font_cfg, glyph_ranges);

	push	DWORD PTR _glyph_ranges$[ebp]
	movups	XMMWORD PTR _font_cfg$[ebp], xmm0
	mov	BYTE PTR _font_cfg$[ebp+8], 1
	movups	xmm0, XMMWORD PTR [eax+16]
	movups	XMMWORD PTR _font_cfg$[ebp+16], xmm0
	movups	xmm0, XMMWORD PTR [eax+32]
	movups	XMMWORD PTR _font_cfg$[ebp+32], xmm0
	movups	xmm0, XMMWORD PTR [eax+48]
	movups	XMMWORD PTR _font_cfg$[ebp+48], xmm0
	movups	xmm0, XMMWORD PTR [eax+64]
	mov	eax, DWORD PTR [eax+80]
	mov	DWORD PTR _font_cfg$[ebp+80], eax
	lea	eax, DWORD PTR _font_cfg$[ebp]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _this$1$[ebp]
	movups	XMMWORD PTR _font_cfg$[ebp+64], xmm0
	movss	xmm0, DWORD PTR _size_pixels$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	edi
	push	ebx
	call	?AddFontFromMemoryTTF@ImFontAtlas@@QAEPAUImFont@@PAXHMPBUImFontConfig@@PBG@Z ; ImFontAtlas::AddFontFromMemoryTTF
	pop	edi
	pop	ebx

; 1243 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QAEPAUImFont@@PBXHMPBUImFontConfig@@PBG@Z ENDP ; ImFontAtlas::AddFontFromMemoryCompressedTTF
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T1 = -168						; size = 84
$T2 = -168						; size = 84
_font_cfg$ = -84					; size = 84
_ttf_data$ = 8						; size = 4
_ttf_size$ = 12						; size = 4
_size_pixels$ = 16					; size = 4
_font_cfg_template$ = 20				; size = 4
_glyph_ranges$ = 24					; size = 4
?AddFontFromMemoryTTF@ImFontAtlas@@QAEPAUImFont@@PAXHMPBUImFontConfig@@PBG@Z PROC ; ImFontAtlas::AddFontFromMemoryTTF
; _this$ = ecx

; 1222 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1223 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

	mov	eax, DWORD PTR _font_cfg_template$[ebp]
	sub	esp, 168				; 000000a8H
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN4@AddFontFro
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR $T2[ebp], xmm0
	movups	xmm0, XMMWORD PTR [eax+16]
	movups	XMMWORD PTR $T2[ebp+16], xmm0
	movups	xmm0, XMMWORD PTR [eax+32]
	movups	XMMWORD PTR $T2[ebp+32], xmm0
	movups	xmm0, XMMWORD PTR [eax+48]
	movups	XMMWORD PTR $T2[ebp+48], xmm0
	movups	xmm0, XMMWORD PTR [eax+64]
	mov	eax, DWORD PTR [eax+80]
	mov	DWORD PTR $T2[ebp+80], eax
	lea	eax, DWORD PTR $T2[ebp]
	movups	XMMWORD PTR $T2[ebp+64], xmm0
	jmp	SHORT $LN5@AddFontFro
$LN4@AddFontFro:
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0ImFontConfig@@QAE@XZ			; ImFontConfig::ImFontConfig
$LN5@AddFontFro:
	movups	xmm0, XMMWORD PTR [eax]
	movups	xmm1, XMMWORD PTR [eax+32]
	movups	XMMWORD PTR _font_cfg$[ebp], xmm0
	movups	xmm0, XMMWORD PTR [eax+16]
	movups	XMMWORD PTR _font_cfg$[ebp+32], xmm1
	movups	XMMWORD PTR _font_cfg$[ebp+16], xmm0
	movups	xmm0, XMMWORD PTR [eax+48]

; 1224 :     IM_ASSERT(font_cfg.FontData == NULL);
; 1225 :     font_cfg.FontData = ttf_data;
; 1226 :     font_cfg.FontDataSize = ttf_size;
; 1227 :     font_cfg.SizePixels = size_pixels;
; 1228 :     if (glyph_ranges)

	psrldq	xmm1, 8
	movups	XMMWORD PTR _font_cfg$[ebp+48], xmm0
	movups	xmm0, XMMWORD PTR [eax+64]
	mov	eax, DWORD PTR [eax+80]
	mov	DWORD PTR _font_cfg$[ebp+80], eax
	mov	eax, DWORD PTR _ttf_data$[ebp]
	mov	DWORD PTR _font_cfg$[ebp], eax
	mov	eax, DWORD PTR _ttf_size$[ebp]
	mov	DWORD PTR _font_cfg$[ebp+4], eax
	mov	eax, DWORD PTR _glyph_ranges$[ebp]
	test	eax, eax
	movd	ecx, xmm1
	movups	XMMWORD PTR _font_cfg$[ebp+64], xmm0
	movss	xmm0, DWORD PTR _size_pixels$[ebp]
	cmovne	ecx, eax

; 1229 :         font_cfg.GlyphRanges = glyph_ranges;
; 1230 :     return AddFont(&font_cfg);

	lea	eax, DWORD PTR _font_cfg$[ebp]
	mov	DWORD PTR _font_cfg$[ebp+40], ecx
	push	eax
	mov	ecx, esi
	movss	DWORD PTR _font_cfg$[ebp+16], xmm0
	call	?AddFont@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z ; ImFontAtlas::AddFont
	pop	esi

; 1231 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?AddFontFromMemoryTTF@ImFontAtlas@@QAEPAUImFont@@PAXHMPBUImFontConfig@@PBG@Z ENDP ; ImFontAtlas::AddFontFromMemoryTTF
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T1 = -172						; size = 84
$T2 = -172						; size = 84
_font_cfg$ = -88					; size = 84
_data_size$ = -4					; size = 4
_filename$ = 8						; size = 4
_size_pixels$ = 12					; size = 4
_font_cfg_template$ = 16				; size = 4
_glyph_ranges$ = 20					; size = 4
?AddFontFromFileTTF@ImFontAtlas@@QAEPAUImFont@@PBDMPBUImFontConfig@@PBG@Z PROC ; ImFontAtlas::AddFontFromFileTTF
; _this$ = ecx

; 1201 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	push	ebx
	push	esi

; 1202 :     int data_size = 0;
; 1203 :     void* data = ImFileLoadToMemory(filename, "rb", &data_size, 0);

	mov	esi, DWORD PTR _filename$[ebp]
	lea	eax, DWORD PTR _data_size$[ebp]
	push	edi
	push	0
	push	eax
	push	OFFSET $SG15931
	push	esi
	mov	ebx, ecx
	mov	DWORD PTR _data_size$[ebp], 0
	call	?ImFileLoadToMemory@@YAPAXPBD0PAHH@Z	; ImFileLoadToMemory
	mov	edi, eax
	add	esp, 16					; 00000010H

; 1204 :     if (!data)

	test	edi, edi
	jne	SHORT $LN5@AddFontFro
	pop	edi
	pop	esi
	pop	ebx

; 1218 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN5@AddFontFro:

; 1205 :     {
; 1206 :         IM_ASSERT(0); // Could not load file.
; 1207 :         return NULL;
; 1208 :     }
; 1209 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

	mov	eax, DWORD PTR _font_cfg_template$[ebp]
	test	eax, eax
	je	SHORT $LN8@AddFontFro
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR $T2[ebp], xmm0
	movups	xmm0, XMMWORD PTR [eax+16]
	movups	XMMWORD PTR $T2[ebp+16], xmm0
	movups	xmm0, XMMWORD PTR [eax+32]
	movups	XMMWORD PTR $T2[ebp+32], xmm0
	movups	xmm0, XMMWORD PTR [eax+48]
	movups	XMMWORD PTR $T2[ebp+48], xmm0
	movups	xmm0, XMMWORD PTR [eax+64]
	mov	eax, DWORD PTR [eax+80]
	mov	DWORD PTR $T2[ebp+80], eax
	lea	eax, DWORD PTR $T2[ebp]
	movups	XMMWORD PTR $T2[ebp+64], xmm0
	jmp	SHORT $LN9@AddFontFro
$LN8@AddFontFro:
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0ImFontConfig@@QAE@XZ			; ImFontConfig::ImFontConfig
$LN9@AddFontFro:
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR _font_cfg$[ebp], xmm0
	movups	xmm0, XMMWORD PTR [eax+16]
	movups	XMMWORD PTR _font_cfg$[ebp+16], xmm0
	movups	xmm1, XMMWORD PTR [eax+32]
	movups	XMMWORD PTR _font_cfg$[ebp+32], xmm1
	movups	xmm0, XMMWORD PTR [eax+48]

; 1210 :     if (font_cfg.Name[0] == '\0')

	psrldq	xmm1, 14				; 0000000eH
	movups	XMMWORD PTR _font_cfg$[ebp+48], xmm0
	movups	xmm0, XMMWORD PTR [eax+64]
	movups	XMMWORD PTR _font_cfg$[ebp+64], xmm0
	mov	eax, DWORD PTR [eax+80]
	mov	DWORD PTR _font_cfg$[ebp+80], eax
	movd	eax, xmm1
	test	al, al
	jne	SHORT $LN6@AddFontFro

; 1211 :     {
; 1212 :         // Store a short copy of filename into into the font name for convenience
; 1213 :         const char* p;
; 1214 :         for (p = filename + strlen(filename); p > filename && p[-1] != '/' && p[-1] != '\\'; p--) {}

	mov	ecx, esi
	lea	edx, DWORD PTR [ecx+1]
	npad	4
$LL14@AddFontFro:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL14@AddFontFro
	sub	ecx, edx
	lea	eax, DWORD PTR [ecx+esi]
	cmp	eax, esi
	jbe	SHORT $LN15@AddFontFro
$LL4@AddFontFro:
	mov	dl, BYTE PTR [eax-1]
	lea	ecx, DWORD PTR [eax-1]
	cmp	dl, 47					; 0000002fH
	je	SHORT $LN15@AddFontFro
	cmp	dl, 92					; 0000005cH
	je	SHORT $LN15@AddFontFro
	mov	eax, ecx
	cmp	eax, esi
	ja	SHORT $LL4@AddFontFro
$LN15@AddFontFro:
	movss	xmm0, DWORD PTR _size_pixels$[ebp]

; 1215 :         snprintf(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), "%s, %.0fpx", p, size_pixels);

	sub	esp, 8
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	eax
	push	OFFSET $SG15934
	lea	eax, DWORD PTR _font_cfg$[ebp+46]
	push	32					; 00000020H
	push	eax
	call	__snprintf
	add	esp, 24					; 00000018H
$LN6@AddFontFro:

; 1216 :     }
; 1217 :     return AddFontFromMemoryTTF(data, data_size, size_pixels, &font_cfg, glyph_ranges);

	push	DWORD PTR _glyph_ranges$[ebp]
	movss	xmm0, DWORD PTR _size_pixels$[ebp]
	lea	eax, DWORD PTR _font_cfg$[ebp]
	push	eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, ebx
	push	DWORD PTR _data_size$[ebp]
	push	edi
	call	?AddFontFromMemoryTTF@ImFontAtlas@@QAEPAUImFont@@PAXHMPBUImFontConfig@@PBG@Z ; ImFontAtlas::AddFontFromMemoryTTF
	pop	edi
	pop	esi
	pop	ebx

; 1218 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?AddFontFromFileTTF@ImFontAtlas@@QAEPAUImFont@@PBDMPBUImFontConfig@@PBG@Z ENDP ; ImFontAtlas::AddFontFromFileTTF
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T1 = -168						; size = 84
$T2 = -168						; size = 84
_font_cfg$ = -84					; size = 84
_font_cfg_template$ = 8					; size = 4
?AddFontDefault@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z PROC ; ImFontAtlas::AddFontDefault
; _this$ = ecx

; 1186 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 168				; 000000a8H
	push	esi

; 1187 :     ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();

	mov	esi, DWORD PTR _font_cfg_template$[ebp]
	push	edi
	mov	edi, ecx
	test	esi, esi
	je	SHORT $LN5@AddFontDef
	movups	xmm0, XMMWORD PTR [esi]
	mov	eax, DWORD PTR [esi+80]
	mov	DWORD PTR $T2[ebp+80], eax
	lea	eax, DWORD PTR $T2[ebp]
	movups	XMMWORD PTR $T2[ebp], xmm0
	movups	xmm0, XMMWORD PTR [esi+16]
	movups	XMMWORD PTR $T2[ebp+16], xmm0
	movups	xmm0, XMMWORD PTR [esi+32]
	movups	XMMWORD PTR $T2[ebp+32], xmm0
	movups	xmm0, XMMWORD PTR [esi+48]
	movups	XMMWORD PTR $T2[ebp+48], xmm0
	movups	xmm0, XMMWORD PTR [esi+64]
	movups	XMMWORD PTR $T2[ebp+64], xmm0
	jmp	SHORT $LN6@AddFontDef
$LN5@AddFontDef:
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0ImFontConfig@@QAE@XZ			; ImFontConfig::ImFontConfig
$LN6@AddFontDef:
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR _font_cfg$[ebp], xmm0
	movups	xmm0, XMMWORD PTR [eax+16]
	movups	XMMWORD PTR _font_cfg$[ebp+16], xmm0
	movups	xmm0, XMMWORD PTR [eax+32]
	movups	XMMWORD PTR _font_cfg$[ebp+32], xmm0
	movups	xmm0, XMMWORD PTR [eax+48]
	movups	XMMWORD PTR _font_cfg$[ebp+48], xmm0
	movups	xmm0, XMMWORD PTR [eax+64]
	mov	eax, DWORD PTR [eax+80]
	mov	DWORD PTR _font_cfg$[ebp+80], eax
	movups	XMMWORD PTR _font_cfg$[ebp+64], xmm0

; 1188 :     if (!font_cfg_template)

	test	esi, esi
	jne	SHORT $LN2@AddFontDef

; 1189 :     {
; 1190 :         font_cfg.OversampleH = font_cfg.OversampleV = 1;

	mov	DWORD PTR _font_cfg$[ebp+24], 1
	mov	DWORD PTR _font_cfg$[ebp+20], 1

; 1191 :         font_cfg.PixelSnapH = true;

	mov	BYTE PTR _font_cfg$[ebp+28], 1
$LN2@AddFontDef:

; 1192 :     }
; 1193 :     if (font_cfg.Name[0] == '\0') strcpy(font_cfg.Name, "ProggyClean.ttf, 13px");

	cmp	BYTE PTR _font_cfg$[ebp+46], 0
	jne	SHORT $LN3@AddFontDef
	mov	eax, DWORD PTR $SG15910+16
	movups	xmm0, XMMWORD PTR $SG15910
	mov	DWORD PTR _font_cfg$[ebp+62], eax
	mov	ax, WORD PTR $SG15910+20
	movups	XMMWORD PTR _font_cfg$[ebp+46], xmm0
	mov	WORD PTR _font_cfg$[ebp+66], ax
$LN3@AddFontDef:

; 1194 : 
; 1195 :     const char* ttf_compressed_base85 = GetDefaultCompressedFontDataTTFBase85();
; 1196 :     ImFont* font = AddFontFromMemoryCompressedBase85TTF(ttf_compressed_base85, 13.0f, &font_cfg, GetGlyphRangesDefault());

	mov	ecx, edi
	call	?GetGlyphRangesDefault@ImFontAtlas@@QAEPBGXZ ; ImFontAtlas::GetGlyphRangesDefault
	push	eax
	lea	eax, DWORD PTR _font_cfg$[ebp]
	push	eax
	push	ecx
	mov	DWORD PTR [esp], 1095761920		; 41500000H
	call	?GetDefaultCompressedFontDataTTFBase85@@YAPBDXZ ; GetDefaultCompressedFontDataTTFBase85
	push	eax
	mov	ecx, edi
	call	?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QAEPAUImFont@@PBDMPBUImFontConfig@@PBG@Z ; ImFontAtlas::AddFontFromMemoryCompressedBase85TTF
	pop	edi
	pop	esi

; 1197 :     return font;
; 1198 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?AddFontDefault@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z ENDP ; ImFontAtlas::AddFontDefault
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T2 = -24						; size = 4
$T3 = -20						; size = 4
_font$4 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_font_cfg$ = 8						; size = 4
$T5 = 11						; size = 1
?AddFont@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z PROC ; ImFontAtlas::AddFont
; _this$ = ecx

; 1140 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?AddFont@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx

; 1141 :     IM_ASSERT(font_cfg->FontData != NULL && font_cfg->FontDataSize > 0);
; 1142 :     IM_ASSERT(font_cfg->SizePixels > 0.0f);
; 1143 : 
; 1144 :     // Create new font
; 1145 :     if (!font_cfg->MergeMode)

	mov	ebx, DWORD PTR _font_cfg$[ebp]
	push	esi
	push	edi
	mov	edi, ecx
	cmp	BYTE PTR [ebx+44], 0
	jne	SHORT $LN2@AddFont

; 1146 :     {
; 1147 :         ImFont* font = (ImFont*)ImGui::MemAlloc(sizeof(ImFont));

	push	84					; 00000054H
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	DWORD PTR _font$4[ebp], eax

; 1148 :         IM_PLACEMENT_NEW(font) ImFont();

	lea	ecx, DWORD PTR $T5[ebp]
	add	esp, 4
	mov	DWORD PTR $T3[ebp], ecx
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN6@AddFont
	mov	ecx, eax
	call	??0ImFont@@QAE@XZ			; ImFont::ImFont
$LN6@AddFont:

; 1149 :         Fonts.push_back(font);

	lea	eax, DWORD PTR _font$4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	push	eax
	lea	ecx, DWORD PTR [edi+32]
	call	?push_back@?$ImVector@PAUImFont@@@@QAEXABQAUImFont@@@Z ; ImVector<ImFont *>::push_back
$LN2@AddFont:

; 1150 :     }
; 1151 : 
; 1152 :     ConfigData.push_back(*font_cfg);

	push	ebx
	lea	ecx, DWORD PTR [edi+44]
	call	?push_back@?$ImVector@UImFontConfig@@@@QAEXABUImFontConfig@@@Z ; ImVector<ImFontConfig>::push_back

; 1153 :     ImFontConfig& new_font_cfg = ConfigData.back();

	imul	ecx, DWORD PTR [edi+44], 84
	mov	esi, DWORD PTR [edi+52]
	add	esi, ecx

; 1154 : 	if (!new_font_cfg.DstFont)

	cmp	DWORD PTR [esi-4], 0
	jne	SHORT $LN3@AddFont

; 1155 : 	    new_font_cfg.DstFont = Fonts.back();

	mov	ecx, DWORD PTR [edi+32]
	mov	eax, DWORD PTR [edi+40]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	mov	DWORD PTR [esi-4], eax
$LN3@AddFont:

; 1156 :     if (!new_font_cfg.FontDataOwnedByAtlas)

	cmp	BYTE PTR [esi-76], 0
	jne	SHORT $LN4@AddFont

; 1157 :     {
; 1158 :         new_font_cfg.FontData = ImGui::MemAlloc(new_font_cfg.FontDataSize);

	push	DWORD PTR [esi-80]
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 1159 :         new_font_cfg.FontDataOwnedByAtlas = true;
; 1160 :         memcpy(new_font_cfg.FontData, font_cfg->FontData, (size_t)new_font_cfg.FontDataSize);

	push	DWORD PTR [esi-80]
	mov	DWORD PTR [esi-84], eax
	mov	BYTE PTR [esi-76], 1
	push	DWORD PTR [ebx]
	push	eax
	call	_memcpy
	add	esp, 16					; 00000010H
$LN4@AddFont:

; 1161 :     }
; 1162 : 
; 1163 :     // Invalidate texture
; 1164 :     ClearTexData();

	mov	ecx, edi
	call	?ClearTexData@ImFontAtlas@@QAEXXZ	; ImFontAtlas::ClearTexData

; 1165 :     return new_font_cfg.DstFont;

	mov	eax, DWORD PTR [esi-4]

; 1166 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?AddFont@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z$0:
	mov	eax, DWORD PTR _font$4[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	movzx	eax, BYTE PTR [eax]
	push	eax
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXUImPlacementNewDummy@@0@Z	; operator delete
	add	esp, 12					; 0000000cH
	ret	0
__ehhandler$?AddFont@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?AddFont@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddFont@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z ENDP ; ImFontAtlas::AddFont
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1ImFontAtlas@@QAE@XZ PROC				; ImFontAtlas::~ImFontAtlas
; _this$ = ecx

; 1052 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1ImFontAtlas@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx

; 1053 :     Clear();

	call	?Clear@ImFontAtlas@@QAEXXZ		; ImFontAtlas::Clear
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	mov	eax, DWORD PTR [esi+52]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN4@ImFontAtla
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN4@ImFontAtla:
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	eax, eax
	je	SHORT $LN8@ImFontAtla
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN8@ImFontAtla:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1054 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__ehhandler$??1ImFontAtlas@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1ImFontAtlas@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1ImFontAtlas@@QAE@XZ ENDP				; ImFontAtlas::~ImFontAtlas
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 8
_this$ = -4						; size = 4
??0ImFontAtlas@@QAE@XZ PROC				; ImFontAtlas::ImFontAtlas
; _this$ = ecx

; 1043 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 97   :     ImVec2() { x = y = 0.0f; }

	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+24], 0

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+40], 0
	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR [ecx+52], 0

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1048 :     TexUvWhitePixel = ImVec2(0, 0);

	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR [ecx+24], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1048 :     TexUvWhitePixel = ImVec2(0, 0);

	mov	eax, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR [ecx+28], eax

; 1049 : }

	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+12], 0
	mov	esp, ebp
	pop	ebp
	ret	0
??0ImFontAtlas@@QAE@XZ ENDP				; ImFontAtlas::ImFontAtlas
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 8
??0ImFontConfig@@QAE@XZ PROC				; ImFontConfig::ImFontConfig
; _this$ = ecx

; 1025 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 97   :     ImVec2() { x = y = 0.0f; }

	mov	DWORD PTR [ecx+36], 0
	xorps	xmm0, xmm0
	mov	DWORD PTR [ecx+32], 0

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1034 :     GlyphExtraSpacing = ImVec2(0.0f, 0.0f);

	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR [ecx+32], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1034 :     GlyphExtraSpacing = ImVec2(0.0f, 0.0f);

	mov	eax, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR [ecx+36], eax

; 1035 :     GlyphRanges = NULL;
; 1036 :     MergeMode = false;
; 1037 :     MergeGlyphCenterV = false;
; 1038 :     DstFont = NULL;
; 1039 :     memset(Name, 0, sizeof(Name));
; 1040 : }

	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0
	mov	BYTE PTR [ecx+8], 1
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 3
	mov	DWORD PTR [ecx+24], 1
	mov	BYTE PTR [ecx+28], 0
	mov	DWORD PTR [ecx+40], 0
	mov	WORD PTR [ecx+44], 0
	mov	DWORD PTR [ecx+80], 0
	movups	XMMWORD PTR [ecx+46], xmm0
	movups	XMMWORD PTR [ecx+62], xmm0
	mov	esp, ebp
	pop	ebp
	ret	0
??0ImFontConfig@@QAE@XZ ENDP				; ImFontConfig::ImFontConfig
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T1 = -24						; size = 16
_this$1$ = -8						; size = 4
_i$1$ = -4						; size = 4
_scale$ = 8						; size = 4
?ScaleClipRects@ImDrawData@@QAEXABUImVec2@@@Z PROC	; ImDrawData::ScaleClipRects
; _this$ = ecx

; 1008 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx
	mov	ebx, ecx

; 1009 :     for (int i = 0; i < CmdListsCount; i++)

	xor	edx, edx
	mov	DWORD PTR _this$1$[ebp], ebx
	mov	DWORD PTR _i$1$[ebp], edx
	cmp	DWORD PTR [ebx+8], edx
	jle	SHORT $LN3@ScaleClipR
	push	esi
	push	edi
	npad	6
$LL4@ScaleClipR:

; 1010 :     {
; 1011 :         ImDrawList* cmd_list = CmdLists[i];

	mov	eax, DWORD PTR [ebx+4]

; 1012 :         for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)

	xor	esi, esi
	mov	ecx, DWORD PTR [eax+edx*4]
	cmp	DWORD PTR [ecx], esi
	jle	SHORT $LN2@ScaleClipR

; 1010 :     {
; 1011 :         ImDrawList* cmd_list = CmdLists[i];

	mov	edx, DWORD PTR _scale$[ebp]
	xor	edi, edi
$LL7@ScaleClipR:

; 1012 :         for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)

	mov	eax, DWORD PTR [ecx+8]
	inc	esi
	add	eax, edi
	add	edi, 32					; 00000020H

; 1015 :             cmd->ClipRect = ImVec4(cmd->ClipRect.x * scale.x, cmd->ClipRect.y * scale.y, cmd->ClipRect.z * scale.x, cmd->ClipRect.w * scale.y);

	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR [edx]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 109  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

	movss	DWORD PTR $T1[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1015 :             cmd->ClipRect = ImVec4(cmd->ClipRect.x * scale.x, cmd->ClipRect.y * scale.y, cmd->ClipRect.z * scale.x, cmd->ClipRect.w * scale.y);

	movss	xmm0, DWORD PTR [eax+8]
	mulss	xmm0, DWORD PTR [edx+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 109  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1015 :             cmd->ClipRect = ImVec4(cmd->ClipRect.x * scale.x, cmd->ClipRect.y * scale.y, cmd->ClipRect.z * scale.x, cmd->ClipRect.w * scale.y);

	movss	xmm0, DWORD PTR [eax+12]
	mulss	xmm0, DWORD PTR [edx]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 109  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

	movss	DWORD PTR $T1[ebp+8], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1015 :             cmd->ClipRect = ImVec4(cmd->ClipRect.x * scale.x, cmd->ClipRect.y * scale.y, cmd->ClipRect.z * scale.x, cmd->ClipRect.w * scale.y);

	movss	xmm0, DWORD PTR [eax+16]
	mulss	xmm0, DWORD PTR [edx+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 109  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

	movss	DWORD PTR $T1[ebp+12], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1015 :             cmd->ClipRect = ImVec4(cmd->ClipRect.x * scale.x, cmd->ClipRect.y * scale.y, cmd->ClipRect.z * scale.x, cmd->ClipRect.w * scale.y);

	movups	xmm0, XMMWORD PTR $T1[ebp]
	movups	XMMWORD PTR [eax+4], xmm0
	cmp	esi, DWORD PTR [ecx]
	jl	SHORT $LL7@ScaleClipR
	mov	edx, DWORD PTR _i$1$[ebp]
	mov	ebx, DWORD PTR _this$1$[ebp]
$LN2@ScaleClipR:

; 1009 :     for (int i = 0; i < CmdListsCount; i++)

	inc	edx
	mov	DWORD PTR _i$1$[ebp], edx
	cmp	edx, DWORD PTR [ebx+8]
	jl	SHORT $LL4@ScaleClipR
	pop	edi
	pop	esi
$LN3@ScaleClipR:
	pop	ebx

; 1016 :         }
; 1017 :     }
; 1018 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ScaleClipRects@ImDrawData@@QAEXABUImVec2@@@Z ENDP	; ImDrawData::ScaleClipRects
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_new_vtx_buffer$ = -36					; size = 12
_this$1$ = -24						; size = 4
_new_data$1$ = -20					; size = 4
_rhs_data$1$ = -20					; size = 4
_i$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?DeIndexAllBuffers@ImDrawData@@QAEXXZ PROC		; ImDrawData::DeIndexAllBuffers
; _this$ = ecx

; 989  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DeIndexAllBuffers@ImDrawData@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 24					; 00000018H
	push	edi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	xor	edi, edi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 989  : {

	mov	DWORD PTR _this$1$[ebp], ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR _new_vtx_buffer$[ebp+4], 0
	mov	DWORD PTR _new_vtx_buffer$[ebp], 0
	mov	DWORD PTR _new_vtx_buffer$[ebp+8], edi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 992  :     for (int i = 0; i < CmdListsCount; i++)

	xor	eax, eax
	mov	DWORD PTR __$EHRec$[ebp+8], edi
	mov	DWORD PTR [ecx+16], edi
	mov	DWORD PTR [ecx+12], edi
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	DWORD PTR [ecx+8], eax
	jle	$LN3@DeIndexAll
	push	esi
	npad	4
$LL4@DeIndexAll:

; 993  :     {
; 994  :         ImDrawList* cmd_list = CmdLists[i];

	mov	esi, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [esi+eax*4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	mov	edx, DWORD PTR [esi+12]
	test	edx, edx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 995  :         if (cmd_list->IdxBuffer.empty())

	je	$LN46@DeIndexAll

; 996  :             continue;
; 997  :         new_vtx_buffer.resize(cmd_list->IdxBuffer.Size);

	push	edx
	lea	ecx, DWORD PTR _new_vtx_buffer$[ebp]
	call	?resize@?$ImVector@UImDrawVert@@@@QAEXH@Z ; ImVector<ImDrawVert>::resize

; 998  :         for (int j = 0; j < cmd_list->IdxBuffer.Size; j++)

	mov	eax, DWORD PTR _new_vtx_buffer$[ebp+8]
	xor	edi, edi
	mov	DWORD PTR _rhs_data$1$[ebp], eax
	cmp	DWORD PTR [esi+12], edi
	jle	SHORT $LN6@DeIndexAll

; 996  :             continue;
; 997  :         new_vtx_buffer.resize(cmd_list->IdxBuffer.Size);

	mov	edx, eax
	npad	7
$LL7@DeIndexAll:

; 999  :             new_vtx_buffer[j] = cmd_list->VtxBuffer[cmd_list->IdxBuffer[j]];

	mov	eax, DWORD PTR [esi+20]
	lea	edx, DWORD PTR [edx+20]
	movzx	eax, WORD PTR [eax+edi*2]
	inc	edi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [esi+32]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 999  :             new_vtx_buffer[j] = cmd_list->VtxBuffer[cmd_list->IdxBuffer[j]];

	movups	xmm0, XMMWORD PTR [eax+ecx*4]
	movups	XMMWORD PTR [edx-20], xmm0
	mov	eax, DWORD PTR [eax+ecx*4+16]
	mov	DWORD PTR [edx-4], eax
	cmp	edi, DWORD PTR [esi+12]
	jl	SHORT $LL7@DeIndexAll
$LN6@DeIndexAll:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 924  :     inline void                 swap(ImVector<T>& rhs)          { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; value_type* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }

	mov	ecx, DWORD PTR _new_vtx_buffer$[ebp]
	mov	eax, DWORD PTR [esi+24]
	mov	edi, DWORD PTR [esi+32]
	mov	DWORD PTR _new_vtx_buffer$[ebp], eax
	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [esi+24], ecx
	mov	ecx, DWORD PTR _new_vtx_buffer$[ebp+4]
	mov	DWORD PTR _new_vtx_buffer$[ebp+4], eax
	mov	eax, DWORD PTR _rhs_data$1$[ebp]
	mov	DWORD PTR [esi+28], ecx
	mov	DWORD PTR [esi+32], eax

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	ecx, DWORD PTR [esi+16]

; 924  :     inline void                 swap(ImVector<T>& rhs)          { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; value_type* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }

	mov	DWORD PTR _new_vtx_buffer$[ebp+8], edi

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	test	ecx, ecx
	jns	SHORT $LN30@DeIndexAll

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	je	SHORT $LN28@DeIndexAll
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN29@DeIndexAll
$LN28@DeIndexAll:
	mov	eax, 8
$LN29@DeIndexAll:
	xor	edi, edi
	test	eax, eax
	cmovg	edi, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	edi, ecx
	jle	SHORT $LN47@DeIndexAll

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi+edi]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [esi+20]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN32@DeIndexAll

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi+12]
	add	ecx, ecx
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN32@DeIndexAll:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+20]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+20], eax

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+16], edi
$LN47@DeIndexAll:
	mov	edi, DWORD PTR _new_vtx_buffer$[ebp+8]
$LN30@DeIndexAll:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1002 :         TotalVtxCount += cmd_list->VtxBuffer.Size;

	mov	ecx, DWORD PTR _this$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [esi+12], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1002 :         TotalVtxCount += cmd_list->VtxBuffer.Size;

	mov	eax, DWORD PTR [esi+24]
	add	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR _i$1$[ebp]
	jmp	SHORT $LN2@DeIndexAll
$LN46@DeIndexAll:
	mov	edi, DWORD PTR _new_vtx_buffer$[ebp+8]
$LN2@DeIndexAll:

; 992  :     for (int i = 0; i < CmdListsCount; i++)

	inc	eax
	mov	DWORD PTR _i$1$[ebp], eax
	cmp	eax, DWORD PTR [ecx+8]
	jl	$LL4@DeIndexAll
	pop	esi
$LN3@DeIndexAll:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	edi, edi
	je	SHORT $LN35@DeIndexAll
	push	edi
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN35@DeIndexAll:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 1004 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?DeIndexAllBuffers@ImDrawData@@QAEXXZ$0:
	lea	ecx, DWORD PTR _new_vtx_buffer$[ebp]
	jmp	??1?$ImVector@UImDrawVert@@@@QAE@XZ	; ImVector<ImDrawVert>::~ImVector<ImDrawVert>
__ehhandler$?DeIndexAllBuffers@ImDrawData@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?DeIndexAllBuffers@ImDrawData@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?DeIndexAllBuffers@ImDrawData@@QAEXXZ ENDP		; ImDrawData::DeIndexAllBuffers
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
tv365 = -8						; size = 4
_curr_texture_id$1$ = -4				; size = 4
?UpdateTextureID@ImDrawList@@QAEXXZ PROC		; ImDrawList::UpdateTextureID
; _this$ = ecx

; 211  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	edx, ecx
	push	ebx
	push	edi

; 212  :     // If current command is used with different settings we need to add a new command
; 213  :     const ImTextureID curr_texture_id = GetCurrentTextureId();

	mov	edi, DWORD PTR [edx+64]
	test	edi, edi
	je	SHORT $LN8@UpdateText
	mov	eax, DWORD PTR [edx+72]
	mov	edi, DWORD PTR [eax+edi*4-4]
	jmp	SHORT $LN23@UpdateText
$LN8@UpdateText:
	xor	edi, edi
$LN23@UpdateText:

; 214  :     ImDrawCmd* curr_cmd = CmdBuffer.Size ? &CmdBuffer.back() : NULL;

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _curr_texture_id$1$[ebp], edi
	test	eax, eax
	je	$LN3@UpdateText
	mov	ebx, DWORD PTR [edx+8]
	mov	ecx, eax
	shl	ecx, 5
	add	ebx, -32				; ffffffe0H
	add	ebx, ecx

; 215  :     if (!curr_cmd || (curr_cmd->ElemCount != 0 && curr_cmd->TextureId != curr_texture_id) || curr_cmd->UserCallback != NULL)

	je	SHORT $LN3@UpdateText
	cmp	DWORD PTR [ebx], 0
	je	SHORT $LN4@UpdateText
	cmp	DWORD PTR [ebx+20], edi
	jne	SHORT $LN3@UpdateText
$LN4@UpdateText:
	cmp	DWORD PTR [ebx+24], 0
	jne	SHORT $LN3@UpdateText

; 218  :         return;
; 219  :     }
; 220  : 
; 221  :     // Try to merge with previous command if it matches, else use current command
; 222  :     ImDrawCmd* prev_cmd = CmdBuffer.Size > 1 ? curr_cmd - 1 : NULL;
; 223  :     if (prev_cmd && prev_cmd->TextureId == curr_texture_id && memcmp(&prev_cmd->ClipRect, &GetCurrentClipRect(), sizeof(ImVec4)) == 0 && prev_cmd->UserCallback == NULL)

	xor	eax, eax
	cmp	DWORD PTR [edx], 1
	push	esi
	lea	esi, DWORD PTR [ebx-32]
	cmovle	esi, eax
	mov	DWORD PTR tv365[ebp], esi
	test	esi, esi
	je	SHORT $LN5@UpdateText
	cmp	DWORD PTR [esi+20], edi
	jne	SHORT $LN5@UpdateText
	mov	ecx, DWORD PTR [edx+52]
	test	ecx, ecx
	je	SHORT $LN14@UpdateText
	mov	eax, DWORD PTR [edx+60]
	shl	ecx, 4
	add	eax, -16				; fffffff0H
	add	ecx, eax
	jmp	SHORT $LN15@UpdateText
$LN14@UpdateText:
	mov	ecx, OFFSET ?GNullClipRect@@3UImVec4@@B
$LN15@UpdateText:
	add	esi, 4
	mov	edi, 12					; 0000000cH
$LL21@UpdateText:
	mov	eax, DWORD PTR [esi]
	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN5@UpdateText
	add	esi, 4
	add	ecx, 4
	sub	edi, 4
	jae	SHORT $LL21@UpdateText
	mov	eax, DWORD PTR tv365[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN5@UpdateText
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [edx]
	pop	esi
	pop	edi
	pop	ebx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 227  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@UpdateText:

; 224  :         CmdBuffer.pop_back();
; 225  :     else
; 226  :         curr_cmd->TextureId = curr_texture_id;

	mov	eax, DWORD PTR _curr_texture_id$1$[ebp]
	pop	esi
	pop	edi
	mov	DWORD PTR [ebx+20], eax
	pop	ebx

; 227  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@UpdateText:

; 216  :     {
; 217  :         AddDrawCmd();

	mov	ecx, edx
	call	?AddDrawCmd@ImDrawList@@QAEXXZ		; ImDrawList::AddDrawCmd
	pop	edi
	pop	ebx

; 227  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateTextureID@ImDrawList@@QAEXXZ ENDP		; ImDrawList::UpdateTextureID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_curr_clip_rect$ = -20					; size = 16
_curr_cmd$1$ = -4					; size = 4
?UpdateClipRect@ImDrawList@@QAEXXZ PROC			; ImDrawList::UpdateClipRect
; _this$ = ecx

; 192  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 193  :     // If current command is used with different settings we need to add a new command
; 194  :     const ImVec4 curr_clip_rect = GetCurrentClipRect();

	mov	ecx, DWORD PTR [esi+52]
	test	ecx, ecx
	je	SHORT $LN8@UpdateClip
	mov	eax, DWORD PTR [esi+60]
	shl	ecx, 4
	add	eax, -16				; fffffff0H
	add	eax, ecx
	jmp	SHORT $LN9@UpdateClip
$LN8@UpdateClip:
	mov	eax, OFFSET ?GNullClipRect@@3UImVec4@@B
$LN9@UpdateClip:
	movups	xmm0, XMMWORD PTR [eax]

; 195  :     ImDrawCmd* curr_cmd = CmdBuffer.Size > 0 ? &CmdBuffer.Data[CmdBuffer.Size-1] : NULL;

	mov	edx, DWORD PTR [esi]
	movups	XMMWORD PTR _curr_clip_rect$[ebp], xmm0
	test	edx, edx
	jle	$LN3@UpdateClip
	mov	ebx, DWORD PTR [esi+8]
	mov	ecx, edx
	shl	ecx, 5
	add	ebx, -32				; ffffffe0H
	add	ebx, ecx
	mov	DWORD PTR _curr_cmd$1$[ebp], ebx

; 196  :     if (!curr_cmd || (curr_cmd->ElemCount != 0 && memcmp(&curr_cmd->ClipRect, &curr_clip_rect, sizeof(ImVec4)) != 0) || curr_cmd->UserCallback != NULL)

	je	$LN3@UpdateClip
	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN18@UpdateClip
	lea	ecx, DWORD PTR [ebx+4]
	mov	edi, 12					; 0000000cH
	lea	edx, DWORD PTR _curr_clip_rect$[ebp]
	npad	2
$LL19@UpdateClip:
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN3@UpdateClip
	add	ecx, 4
	add	edx, 4
	sub	edi, 4
	jae	SHORT $LL19@UpdateClip
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ebx]
$LN18@UpdateClip:
	cmp	DWORD PTR [ebx+24], 0
	jne	SHORT $LN3@UpdateClip

; 199  :         return;
; 200  :     }
; 201  : 
; 202  :     // Try to merge with previous command if it matches, else use current command
; 203  :     ImDrawCmd* prev_cmd = CmdBuffer.Size > 1 ? curr_cmd - 1 : NULL;
; 204  :     if (curr_cmd->ElemCount == 0 && prev_cmd && memcmp(&prev_cmd->ClipRect, &curr_clip_rect, sizeof(ImVec4)) == 0 && prev_cmd->TextureId == GetCurrentTextureId() && prev_cmd->UserCallback == NULL)

	add	ebx, -32				; ffffffe0H
	xor	ecx, ecx
	cmp	edx, 1
	cmovle	ebx, ecx
	test	eax, eax
	jne	SHORT $LN5@UpdateClip
	test	ebx, ebx
	je	SHORT $LN5@UpdateClip
	lea	ecx, DWORD PTR [ebx+4]
	lea	edx, DWORD PTR _curr_clip_rect$[ebp]
	lea	edi, DWORD PTR [eax+12]
$LL21@UpdateClip:
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN5@UpdateClip
	add	ecx, 4
	add	edx, 4
	sub	edi, 4
	jae	SHORT $LL21@UpdateClip
	mov	ecx, DWORD PTR [esi+64]
	test	ecx, ecx
	je	SHORT $LN14@UpdateClip
	mov	eax, DWORD PTR [esi+72]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	jmp	SHORT $LN15@UpdateClip
$LN14@UpdateClip:
	xor	eax, eax
$LN15@UpdateClip:
	cmp	DWORD PTR [ebx+20], eax
	jne	SHORT $LN5@UpdateClip
	cmp	DWORD PTR [ebx+24], 0
	jne	SHORT $LN5@UpdateClip
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [esi]
	pop	edi
	pop	esi
	pop	ebx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 208  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@UpdateClip:

; 205  :         CmdBuffer.pop_back();
; 206  :     else
; 207  :         curr_cmd->ClipRect = curr_clip_rect;

	mov	eax, DWORD PTR _curr_cmd$1$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	movups	XMMWORD PTR [eax+4], xmm0

; 208  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@UpdateClip:

; 197  :     {
; 198  :         AddDrawCmd();

	mov	ecx, esi
	call	?AddDrawCmd@ImDrawList@@QAEXXZ		; ImDrawList::AddDrawCmd
	pop	edi
	pop	esi
	pop	ebx

; 208  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateClipRect@ImDrawList@@QAEXXZ ENDP			; ImDrawList::UpdateClipRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?PrimWriteIdx@ImDrawList@@QAEXG@Z
_TEXT	SEGMENT
_idx$ = 8						; size = 2
?PrimWriteIdx@ImDrawList@@QAEXG@Z PROC			; ImDrawList::PrimWriteIdx, COMDAT
; _this$ = ecx

; 1299 :     inline    void  PrimWriteIdx(ImDrawIdx idx)                                 { *_IdxWritePtr = idx; _IdxWritePtr++; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR [ecx+48]
	mov	ax, WORD PTR _idx$[ebp]
	mov	WORD PTR [edx], ax
	add	DWORD PTR [ecx+48], 2
	pop	ebp
	ret	4
?PrimWriteIdx@ImDrawList@@QAEXG@Z ENDP			; ImDrawList::PrimWriteIdx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?PrimWriteVtx@ImDrawList@@QAEXABUImVec2@@0I@Z
_TEXT	SEGMENT
_pos$ = 8						; size = 4
_uv$ = 12						; size = 4
_col$ = 16						; size = 4
?PrimWriteVtx@ImDrawList@@QAEXABUImVec2@@0I@Z PROC	; ImDrawList::PrimWriteVtx, COMDAT
; _this$ = ecx

; 1298 :     inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col){ _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _pos$[ebp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR _uv$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR [edi+44]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax
	mov	edx, DWORD PTR [edi+44]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+12], eax
	mov	ecx, DWORD PTR [edi+44]
	mov	eax, DWORD PTR _col$[ebp]
	mov	DWORD PTR [ecx+16], eax
	add	DWORD PTR [edi+44], 20			; 00000014H
	inc	DWORD PTR [edi+40]
	pop	edi
	pop	esi
	pop	ebp
	ret	12					; 0000000cH
?PrimWriteVtx@ImDrawList@@QAEXABUImVec2@@0I@Z ENDP	; ImDrawList::PrimWriteVtx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
_d$ = 20						; size = 4
_uv_a$ = 24						; size = 4
_uv_b$ = 28						; size = 4
_uv_c$ = 32						; size = 4
_uv_d$ = 36						; size = 4
_col$ = 40						; size = 4
?PrimQuadUV@ImDrawList@@QAEXABUImVec2@@0000000I@Z PROC	; ImDrawList::PrimQuadUV
; _this$ = ecx

; 403  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	edi, ecx

; 404  :     ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;

	movzx	esi, WORD PTR [edi+40]

; 405  :     _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);

	mov	eax, DWORD PTR [edi+48]
	lea	edx, DWORD PTR [esi+1]
	mov	WORD PTR [eax], si
	lea	ecx, DWORD PTR [esi+2]
	mov	eax, DWORD PTR [edi+48]
	mov	WORD PTR [eax+2], dx
	mov	eax, DWORD PTR [edi+48]
	mov	WORD PTR [eax+4], cx

; 406  :     _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);

	mov	eax, DWORD PTR [edi+48]
	mov	WORD PTR [eax+6], si
	mov	eax, DWORD PTR [edi+48]
	mov	WORD PTR [eax+8], cx
	lea	ecx, DWORD PTR [esi+3]
	mov	eax, DWORD PTR [edi+48]

; 407  :     _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv_a; _VtxWritePtr[0].col = col;

	mov	esi, DWORD PTR _col$[ebp]
	mov	WORD PTR [eax+10], cx
	mov	edx, DWORD PTR [edi+44]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	edx, DWORD PTR [edi+44]
	mov	ecx, DWORD PTR _uv_a$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR [edi+44]

; 408  :     _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv_b; _VtxWritePtr[1].col = col;

	mov	ecx, DWORD PTR _b$[ebp]
	mov	DWORD PTR [eax+16], esi
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edi+44]
	mov	DWORD PTR [edx+20], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _uv_b$[ebp]
	mov	DWORD PTR [edx+24], eax
	mov	edx, DWORD PTR [edi+44]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx+28], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+32], eax
	mov	eax, DWORD PTR [edi+44]

; 409  :     _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv_c; _VtxWritePtr[2].col = col;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+36], esi
	mov	edx, DWORD PTR [edi+44]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx+40], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _uv_c$[ebp]
	mov	DWORD PTR [edx+44], eax
	mov	edx, DWORD PTR [edi+44]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx+48], eax
	mov	eax, DWORD PTR [ecx+4]

; 410  :     _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv_d; _VtxWritePtr[3].col = col;

	mov	ecx, DWORD PTR _d$[ebp]
	mov	DWORD PTR [edx+52], eax
	mov	eax, DWORD PTR [edi+44]
	mov	DWORD PTR [eax+56], esi
	mov	edx, DWORD PTR [edi+44]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx+60], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _uv_d$[ebp]
	mov	DWORD PTR [edx+64], eax
	mov	edx, DWORD PTR [edi+44]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx+68], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+72], eax
	mov	eax, DWORD PTR [edi+44]
	mov	DWORD PTR [eax+76], esi

; 411  :     _VtxWritePtr += 4;

	add	DWORD PTR [edi+44], 80			; 00000050H

; 412  :     _VtxCurrentIdx += 4;

	add	DWORD PTR [edi+40], 4

; 413  :     _IdxWritePtr += 6;

	add	DWORD PTR [edi+48], 12			; 0000000cH
	pop	edi
	pop	esi

; 414  : }

	pop	ebp
	ret	36					; 00000024H
?PrimQuadUV@ImDrawList@@QAEXABUImVec2@@0000000I@Z ENDP	; ImDrawList::PrimQuadUV
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_uv_d$ = -36						; size = 8
_d$ = -28						; size = 8
_uv_b$ = -20						; size = 8
_b$ = -12						; size = 8
_this$1$ = -4						; size = 4
_a$ = 8							; size = 4
_c$ = 12						; size = 4
_uv_a$ = 16						; size = 4
_uv_c$ = 20						; size = 4
_col$ = 24						; size = 4
?PrimRectUV@ImDrawList@@QAEXABUImVec2@@000I@Z PROC	; ImDrawList::PrimRectUV
; _this$ = ecx

; 388  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 389  :     ImVec2 b(c.x, a.y), d(a.x, c.y), uv_b(uv_c.x, uv_a.y), uv_d(uv_a.x, uv_c.y);
; 390  :     ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;

	movzx	edx, WORD PTR [ecx+40]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR _c$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _uv_c$[ebp]
	push	esi
	movss	xmm0, DWORD PTR [eax]
	mov	esi, DWORD PTR _uv_a$[ebp]
	movss	DWORD PTR _b$[ebp], xmm0
	push	edi
	mov	edi, DWORD PTR _a$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 388  : {

	mov	DWORD PTR _this$1$[ebp], ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR [edi+4]
	movss	DWORD PTR _b$[ebp+4], xmm0
	movss	xmm0, DWORD PTR [edi]
	movss	DWORD PTR _d$[ebp], xmm0
	movss	xmm0, DWORD PTR [eax+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 391  :     _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);

	mov	eax, DWORD PTR [ecx+48]
	lea	ecx, DWORD PTR [edx+1]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _d$[ebp+4], xmm0
	movss	xmm0, DWORD PTR [ebx]
	movss	DWORD PTR _uv_b$[ebp], xmm0
	movss	xmm0, DWORD PTR [esi+4]
	movss	DWORD PTR _uv_b$[ebp+4], xmm0
	movss	xmm0, DWORD PTR [esi]
	movss	DWORD PTR _uv_d$[ebp], xmm0
	movss	xmm0, DWORD PTR [ebx+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 391  :     _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);

	mov	WORD PTR [eax], dx
	mov	eax, DWORD PTR _this$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _uv_d$[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 391  :     _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);

	mov	eax, DWORD PTR [eax+48]
	mov	WORD PTR [eax+2], cx
	lea	ecx, DWORD PTR [edx+2]
	mov	eax, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [eax+48]
	mov	WORD PTR [eax+4], cx

; 392  :     _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [eax+48]
	mov	WORD PTR [eax+6], dx
	mov	eax, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [eax+48]
	mov	WORD PTR [eax+8], cx
	lea	ecx, DWORD PTR [edx+3]
	mov	edx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	WORD PTR [eax+10], cx

; 393  :     _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv_a; _VtxWritePtr[0].col = col;

	mov	ecx, DWORD PTR [edx+44]
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edi+4]
	mov	edi, edx
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR _col$[ebp]
	mov	ecx, DWORD PTR [edi+44]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR [edi+44]

; 394  :     _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv_b; _VtxWritePtr[1].col = col;
; 395  :     _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv_c; _VtxWritePtr[2].col = col;

	mov	esi, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR [edi+44]
	mov	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR [ecx+20], eax
	mov	eax, DWORD PTR _b$[ebp+4]
	mov	DWORD PTR [ecx+24], eax
	mov	ecx, DWORD PTR [edi+44]
	mov	eax, DWORD PTR _uv_b$[ebp]
	mov	DWORD PTR [ecx+28], eax
	mov	eax, DWORD PTR _uv_b$[ebp+4]
	mov	DWORD PTR [ecx+32], eax
	mov	eax, DWORD PTR [edi+44]
	mov	DWORD PTR [eax+36], edx
	mov	ecx, DWORD PTR [edi+44]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx+40], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+44], eax
	mov	ecx, DWORD PTR [edi+44]
	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [ecx+48], eax
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [ecx+52], eax
	mov	eax, DWORD PTR [edi+44]
	mov	DWORD PTR [eax+56], edx

; 396  :     _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv_d; _VtxWritePtr[3].col = col;

	mov	ecx, DWORD PTR [edi+44]
	mov	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR [ecx+60], eax
	mov	eax, DWORD PTR _d$[ebp+4]
	mov	DWORD PTR [ecx+64], eax
	mov	ecx, DWORD PTR [edi+44]
	mov	eax, DWORD PTR _uv_d$[ebp]
	mov	DWORD PTR [ecx+68], eax
	mov	eax, DWORD PTR _uv_d$[ebp+4]
	mov	DWORD PTR [ecx+72], eax
	mov	eax, DWORD PTR [edi+44]
	mov	DWORD PTR [eax+76], edx

; 397  :     _VtxWritePtr += 4;

	add	DWORD PTR [edi+44], 80			; 00000050H

; 398  :     _VtxCurrentIdx += 4;

	add	DWORD PTR [edi+40], 4

; 399  :     _IdxWritePtr += 6;

	add	DWORD PTR [edi+48], 12			; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 400  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?PrimRectUV@ImDrawList@@QAEXABUImVec2@@000I@Z ENDP	; ImDrawList::PrimRectUV
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_d$ = -20						; size = 8
_b$ = -12						; size = 8
_this$1$ = -4						; size = 4
_a$ = 8							; size = 4
_uv$2$ = 12						; size = 4
_c$ = 12						; size = 4
_col$ = 16						; size = 4
?PrimRect@ImDrawList@@QAEXABUImVec2@@0I@Z PROC		; ImDrawList::PrimRect
; _this$ = ecx

; 373  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 374  :     ImVec2 b(c.x, a.y), d(a.x, c.y), uv(GImGui->FontTexUvWhitePixel);

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 375  :     ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;

	movzx	edx, WORD PTR [ecx+40]
	push	ebx
	push	esi
	mov	ebx, DWORD PTR [eax+6180]
	mov	eax, DWORD PTR [eax+6184]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	esi, DWORD PTR _a$[ebp]
	push	edi
	mov	edi, DWORD PTR _c$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 374  :     ImVec2 b(c.x, a.y), d(a.x, c.y), uv(GImGui->FontTexUvWhitePixel);

	mov	DWORD PTR _uv$2$[ebp], eax

; 376  :     _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);

	mov	eax, DWORD PTR [ecx+48]
	mov	DWORD PTR _this$1$[ebp], ecx
	lea	ecx, DWORD PTR [edx+1]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR [edi]
	movss	DWORD PTR _b$[ebp], xmm0
	movss	xmm0, DWORD PTR [esi+4]
	movss	DWORD PTR _b$[ebp+4], xmm0
	movss	xmm0, DWORD PTR [esi]
	movss	DWORD PTR _d$[ebp], xmm0
	movss	xmm0, DWORD PTR [edi+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 376  :     _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);

	mov	WORD PTR [eax], dx
	mov	eax, DWORD PTR _this$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _d$[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 376  :     _IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx+1); _IdxWritePtr[2] = (ImDrawIdx)(idx+2);

	mov	eax, DWORD PTR [eax+48]
	mov	WORD PTR [eax+2], cx
	lea	ecx, DWORD PTR [edx+2]
	mov	eax, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [eax+48]
	mov	WORD PTR [eax+4], cx

; 377  :     _IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx+2); _IdxWritePtr[5] = (ImDrawIdx)(idx+3);

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [eax+48]
	mov	WORD PTR [eax+6], dx
	mov	eax, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [eax+48]
	mov	WORD PTR [eax+8], cx
	lea	ecx, DWORD PTR [edx+3]
	mov	edx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	WORD PTR [eax+10], cx

; 378  :     _VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;

	mov	ecx, DWORD PTR [edx+44]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+44]
	mov	esi, DWORD PTR _uv$2$[ebp]
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], esi
	mov	eax, DWORD PTR [edx+44]
	mov	edx, DWORD PTR _col$[ebp]
	mov	DWORD PTR [eax+16], edx

; 379  :     _VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR [ecx+20], eax
	mov	eax, DWORD PTR _b$[ebp+4]
	mov	DWORD PTR [ecx+24], eax
	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+28], ebx
	mov	DWORD PTR [eax+32], esi
	mov	eax, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+36], edx

; 380  :     _VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;

	mov	ecx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ecx+40], eax
	mov	eax, DWORD PTR [edi+4]
	mov	edi, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR [ecx+44], eax
	mov	eax, DWORD PTR [edi+44]
	mov	DWORD PTR [eax+48], ebx
	mov	DWORD PTR [eax+52], esi
	mov	eax, DWORD PTR [edi+44]
	mov	DWORD PTR [eax+56], edx

; 381  :     _VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col;

	mov	ecx, DWORD PTR [edi+44]
	mov	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR [ecx+60], eax
	mov	eax, DWORD PTR _d$[ebp+4]
	mov	DWORD PTR [ecx+64], eax
	mov	eax, DWORD PTR [edi+44]
	mov	DWORD PTR [eax+68], ebx
	mov	DWORD PTR [eax+72], esi
	mov	eax, DWORD PTR [edi+44]
	mov	DWORD PTR [eax+76], edx

; 382  :     _VtxWritePtr += 4;

	add	DWORD PTR [edi+44], 80			; 00000050H

; 383  :     _VtxCurrentIdx += 4;

	add	DWORD PTR [edi+40], 4

; 384  :     _IdxWritePtr += 6;

	add	DWORD PTR [edi+48], 12			; 0000000cH
	pop	edi
	pop	esi
	pop	ebx

; 385  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?PrimRect@ImDrawList@@QAEXABUImVec2@@0I@Z ENDP		; ImDrawList::PrimRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_idx_count$ = 8						; size = 4
_vtx_count$ = 12					; size = 4
?PrimReserve@ImDrawList@@QAEXHH@Z PROC			; ImDrawList::PrimReserve
; _this$ = ecx

; 358  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ebx, ecx
	push	esi
	push	edi

; 359  :     ImDrawCmd& draw_cmd = CmdBuffer.Data[CmdBuffer.Size-1];
; 360  :     draw_cmd.ElemCount += idx_count;

	mov	edi, DWORD PTR _idx_count$[ebp]

; 361  : 
; 362  :     int vtx_buffer_size = VtxBuffer.Size;

	lea	ecx, DWORD PTR [ebx+24]
	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ebx+8]
	shl	edx, 5
	add	DWORD PTR [edx+eax-32], edi
	mov	esi, DWORD PTR [ecx]

; 363  :     VtxBuffer.resize(vtx_buffer_size + vtx_count);

	mov	eax, DWORD PTR _vtx_count$[ebp]
	add	eax, esi
	push	eax
	call	?resize@?$ImVector@UImDrawVert@@@@QAEXH@Z ; ImVector<ImDrawVert>::resize

; 364  :     _VtxWritePtr = VtxBuffer.Data + vtx_buffer_size;

	mov	eax, DWORD PTR [ebx+32]
	lea	ecx, DWORD PTR [esi+esi*4]

; 365  : 
; 366  :     int idx_buffer_size = IdxBuffer.Size;

	mov	esi, DWORD PTR [ebx+12]
	lea	eax, DWORD PTR [eax+ecx*4]
	lea	ecx, DWORD PTR [ebx+12]
	mov	DWORD PTR [ebx+44], eax

; 367  :     IdxBuffer.resize(idx_buffer_size + idx_count);

	lea	eax, DWORD PTR [esi+edi]
	push	eax
	call	?resize@?$ImVector@G@@QAEXH@Z		; ImVector<unsigned short>::resize

; 368  :     _IdxWritePtr = IdxBuffer.Data + idx_buffer_size;

	mov	eax, DWORD PTR [ebx+20]
	pop	edi
	lea	eax, DWORD PTR [eax+esi*2]
	pop	esi
	mov	DWORD PTR [ebx+48], eax
	pop	ebx

; 369  : }

	pop	ebp
	ret	8
?PrimReserve@ImDrawList@@QAEXHH@Z ENDP			; ImDrawList::PrimReserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
tv368 = -4						; size = 4
?ClearFreeMemory@ImDrawList@@QAEXXZ PROC		; ImDrawList::ClearFreeMemory
; _this$ = ecx

; 140  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN8@ClearFreeM
	push	eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+8], 0
$LN8@ClearFreeM:
	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN11@ClearFreeM
	push	eax
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+12], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+20], 0
$LN11@ClearFreeM:
	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN14@ClearFreeM
	push	eax
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+24], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+32], 0
$LN14@ClearFreeM:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 144  :     _VtxCurrentIdx = 0;

	mov	DWORD PTR [esi+40], 0

; 145  :     _VtxWritePtr = NULL;

	mov	DWORD PTR [esi+44], 0

; 146  :     _IdxWritePtr = NULL;

	mov	DWORD PTR [esi+48], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	mov	eax, DWORD PTR [esi+60]
	test	eax, eax
	je	SHORT $LN17@ClearFreeM
	push	eax
	mov	DWORD PTR [esi+56], 0
	mov	DWORD PTR [esi+52], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+60], 0
$LN17@ClearFreeM:
	mov	eax, DWORD PTR [esi+72]
	test	eax, eax
	je	SHORT $LN20@ClearFreeM
	push	eax
	mov	DWORD PTR [esi+68], 0
	mov	DWORD PTR [esi+64], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+72], 0
$LN20@ClearFreeM:
	mov	eax, DWORD PTR [esi+84]
	test	eax, eax
	je	SHORT $LN23@ClearFreeM
	push	eax
	mov	DWORD PTR [esi+80], 0
	mov	DWORD PTR [esi+76], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+84], 0
$LN23@ClearFreeM:
	push	edi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 152  :     for (int i = 0; i < _Channels.Size; i++)

	xor	edi, edi
	mov	DWORD PTR [esi+88], 0
	mov	DWORD PTR [esi+92], 1
	cmp	DWORD PTR [esi+96], edi
	jle	SHORT $LN3@ClearFreeM
	push	ebx
$LL4@ClearFreeM:

; 153  :     {
; 154  :         if (i == 0) memset(&_Channels[0], 0, sizeof(_Channels[0]));  // channel 0 is a copy of CmdBuffer/IdxBuffer, don't destruct again

	test	edi, edi
	jne	SHORT $LN5@ClearFreeM
	mov	eax, DWORD PTR [esi+104]
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [eax], xmm0
	movq	QWORD PTR [eax+16], xmm0
$LN5@ClearFreeM:

; 155  :         _Channels[i].CmdBuffer.clear();

	mov	ebx, DWORD PTR [esi+104]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	lea	eax, DWORD PTR [edi+edi*2]
	shl	eax, 3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 155  :         _Channels[i].CmdBuffer.clear();

	add	ebx, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR tv368[ebp], eax

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	mov	eax, DWORD PTR [ebx+8]
	test	eax, eax
	je	SHORT $LN30@ClearFreeM
	push	eax
	mov	DWORD PTR [ebx+4], 0
	mov	DWORD PTR [ebx], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [ebx+8], 0
$LN30@ClearFreeM:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 156  :         _Channels[i].IdxBuffer.clear();

	mov	ebx, DWORD PTR [esi+104]
	add	ebx, DWORD PTR tv368[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	mov	eax, DWORD PTR [ebx+20]
	test	eax, eax
	je	SHORT $LN2@ClearFreeM
	push	eax
	mov	DWORD PTR [ebx+16], 0
	mov	DWORD PTR [ebx+12], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [ebx+20], 0
$LN2@ClearFreeM:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 152  :     for (int i = 0; i < _Channels.Size; i++)

	inc	edi
	cmp	edi, DWORD PTR [esi+96]
	jl	SHORT $LL4@ClearFreeM
	pop	ebx
$LN3@ClearFreeM:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	mov	eax, DWORD PTR [esi+104]
	pop	edi
	test	eax, eax
	je	SHORT $LN38@ClearFreeM
	push	eax
	mov	DWORD PTR [esi+100], 0
	mov	DWORD PTR [esi+96], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+104], 0
$LN38@ClearFreeM:
	pop	esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 159  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ClearFreeMemory@ImDrawList@@QAEXXZ ENDP		; ImDrawList::ClearFreeMemory
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
?Clear@ImDrawList@@QAEXXZ PROC				; ImDrawList::Clear
; _this$ = ecx

; 124  : {

	npad	2
	push	esi

; 125  :     CmdBuffer.resize(0);

	push	0
	mov	esi, ecx
	call	?resize@?$ImVector@UImDrawCmd@@@@QAEXH@Z ; ImVector<ImDrawCmd>::resize

; 126  :     IdxBuffer.resize(0);

	push	0
	lea	ecx, DWORD PTR [esi+12]
	call	?resize@?$ImVector@G@@QAEXH@Z		; ImVector<unsigned short>::resize

; 127  :     VtxBuffer.resize(0);

	push	0
	lea	ecx, DWORD PTR [esi+24]
	call	?resize@?$ImVector@UImDrawVert@@@@QAEXH@Z ; ImVector<ImDrawVert>::resize

; 128  :     _VtxCurrentIdx = 0;
; 129  :     _VtxWritePtr = NULL;
; 130  :     _IdxWritePtr = NULL;
; 131  :     _ClipRectStack.resize(0);

	push	0
	lea	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0
	mov	DWORD PTR [esi+48], 0
	call	?resize@?$ImVector@UImVec4@@@@QAEXH@Z	; ImVector<ImVec4>::resize

; 132  :     _TextureIdStack.resize(0);

	push	0
	lea	ecx, DWORD PTR [esi+64]
	call	?resize@?$ImVector@PAX@@QAEXH@Z		; ImVector<void *>::resize

; 133  :     _Path.resize(0);

	push	0
	lea	ecx, DWORD PTR [esi+76]
	call	?resize@?$ImVector@UImVec2@@@@QAEXH@Z	; ImVector<ImVec2>::resize

; 134  :     _ChannelsCurrent = 0;

	mov	DWORD PTR [esi+88], 0

; 135  :     _ChannelsCount = 1;

	mov	DWORD PTR [esi+92], 1
	pop	esi

; 136  :     // NB: Do not clear channels so our allocations are re-used after the first frame.
; 137  : }

	ret	0
?Clear@ImDrawList@@QAEXXZ ENDP				; ImDrawList::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_draw_cmd$ = -32					; size = 32
?AddDrawCmd@ImDrawList@@QAEXXZ PROC			; ImDrawList::AddDrawCmd
; _this$ = ecx

; 166  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 168  :     draw_cmd.ClipRect = GetCurrentClipRect();

	mov	edx, DWORD PTR [ecx+52]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1186 :     ImDrawCmd() { ElemCount = 0; ClipRect.x = ClipRect.y = -8192.0f; ClipRect.z = ClipRect.w = +8192.0f; TextureId = NULL; UserCallback = NULL; UserCallbackData = NULL; }

	mov	DWORD PTR _draw_cmd$[ebp], 0
	mov	DWORD PTR _draw_cmd$[ebp+24], 0
	mov	DWORD PTR _draw_cmd$[ebp+28], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 168  :     draw_cmd.ClipRect = GetCurrentClipRect();

	test	edx, edx
	je	SHORT $LN3@AddDrawCmd
	mov	eax, DWORD PTR [ecx+60]
	shl	edx, 4
	add	eax, -16				; fffffff0H
	add	eax, edx
	jmp	SHORT $LN4@AddDrawCmd
$LN3@AddDrawCmd:
	mov	eax, OFFSET ?GNullClipRect@@3UImVec4@@B
$LN4@AddDrawCmd:
	movups	xmm0, XMMWORD PTR [eax]

; 169  :     draw_cmd.TextureId = GetCurrentTextureId();

	mov	edx, DWORD PTR [ecx+64]
	movups	XMMWORD PTR _draw_cmd$[ebp+4], xmm0
	test	edx, edx
	je	SHORT $LN5@AddDrawCmd
	mov	eax, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR [eax+edx*4-4]
	mov	DWORD PTR _draw_cmd$[ebp+20], eax

; 170  : 
; 171  :     IM_ASSERT(draw_cmd.ClipRect.x <= draw_cmd.ClipRect.z && draw_cmd.ClipRect.y <= draw_cmd.ClipRect.w);
; 172  :     CmdBuffer.push_back(draw_cmd);

	lea	eax, DWORD PTR _draw_cmd$[ebp]
	push	eax
	call	?push_back@?$ImVector@UImDrawCmd@@@@QAEXABUImDrawCmd@@@Z ; ImVector<ImDrawCmd>::push_back

; 173  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@AddDrawCmd:

; 170  : 
; 171  :     IM_ASSERT(draw_cmd.ClipRect.x <= draw_cmd.ClipRect.z && draw_cmd.ClipRect.y <= draw_cmd.ClipRect.w);
; 172  :     CmdBuffer.push_back(draw_cmd);

	lea	eax, DWORD PTR _draw_cmd$[ebp]
	mov	DWORD PTR _draw_cmd$[ebp+20], 0
	push	eax
	call	?push_back@?$ImVector@UImDrawCmd@@@@QAEXABUImDrawCmd@@@Z ; ImVector<ImDrawCmd>::push_back

; 173  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AddDrawCmd@ImDrawList@@QAEXXZ ENDP			; ImDrawList::AddDrawCmd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_callback$ = 8						; size = 4
_callback_data$ = 12					; size = 4
?AddCallback@ImDrawList@@QAEXP6AXPBU1@PBUImDrawCmd@@@ZPAX@Z PROC ; ImDrawList::AddCallback
; _this$ = ecx

; 176  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 177  :     ImDrawCmd* current_cmd = CmdBuffer.Size ? &CmdBuffer.back() : NULL;

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN3@AddCallbac
	mov	edx, DWORD PTR [esi+8]
	shl	ecx, 5
	add	edx, -32				; ffffffe0H
	add	edx, ecx

; 178  :     if (!current_cmd || current_cmd->ElemCount != 0 || current_cmd->UserCallback != NULL)

	je	SHORT $LN3@AddCallbac
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN3@AddCallbac
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN2@AddCallbac
$LN3@AddCallbac:

; 179  :     {
; 180  :         AddDrawCmd();

	mov	ecx, esi
	call	?AddDrawCmd@ImDrawList@@QAEXXZ		; ImDrawList::AddDrawCmd

; 181  :         current_cmd = &CmdBuffer.back();

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+8]
	shl	ecx, 5
	add	edx, -32				; ffffffe0H
	add	edx, ecx
$LN2@AddCallbac:

; 182  :     }
; 183  :     current_cmd->UserCallback = callback;

	mov	eax, DWORD PTR _callback$[ebp]

; 184  :     current_cmd->UserCallbackData = callback_data;
; 185  : 
; 186  :     AddDrawCmd(); // Force a new command after us (see comment below)

	mov	ecx, esi
	mov	DWORD PTR [edx+24], eax
	mov	eax, DWORD PTR _callback_data$[ebp]
	mov	DWORD PTR [edx+28], eax
	call	?AddDrawCmd@ImDrawList@@QAEXXZ		; ImDrawList::AddDrawCmd
	pop	esi

; 187  : }

	pop	ebp
	ret	8
?AddCallback@ImDrawList@@QAEXP6AXPBU1@PBUImDrawCmd@@@ZPAX@Z ENDP ; ImDrawList::AddCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_idx$ = 8						; size = 4
?ChannelsSetCurrent@ImDrawList@@QAEXH@Z PROC		; ImDrawList::ChannelsSetCurrent
; _this$ = ecx

; 345  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 346  :     IM_ASSERT(idx < _ChannelsCount);
; 347  :     if (_ChannelsCurrent == idx) return;

	mov	edi, DWORD PTR _idx$[ebp]
	mov	eax, DWORD PTR [esi+88]
	cmp	eax, edi
	je	SHORT $LN1@ChannelsSe

; 348  :     memcpy(&_Channels.Data[_ChannelsCurrent].CmdBuffer, &CmdBuffer, sizeof(CmdBuffer)); // copy 12 bytes, four times

	movq	xmm0, QWORD PTR [esi]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+104]
	movq	QWORD PTR [eax+edx*8], xmm0
	lea	ecx, DWORD PTR [eax+edx*8]
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx+8], eax

; 349  :     memcpy(&_Channels.Data[_ChannelsCurrent].IdxBuffer, &IdxBuffer, sizeof(IdxBuffer));

	mov	eax, DWORD PTR [esi+88]
	movq	xmm0, QWORD PTR [esi+12]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+104]
	movq	QWORD PTR [eax+ecx*8+12], xmm0
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [ecx+20], eax

; 350  :     _ChannelsCurrent = idx;
; 351  :     memcpy(&CmdBuffer, &_Channels.Data[_ChannelsCurrent].CmdBuffer, sizeof(CmdBuffer));

	lea	ecx, DWORD PTR [edi+edi*2]
	mov	eax, DWORD PTR [esi+104]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR [esi+88], edi
	movq	xmm0, QWORD PTR [ecx]
	movq	QWORD PTR [esi], xmm0
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi+8], eax

; 352  :     memcpy(&IdxBuffer, &_Channels.Data[_ChannelsCurrent].IdxBuffer, sizeof(IdxBuffer));

	movq	xmm0, QWORD PTR [ecx+12]
	movq	QWORD PTR [esi+12], xmm0
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR [esi+20], eax

; 353  :     _IdxWritePtr = IdxBuffer.Data + IdxBuffer.Size;

	mov	ecx, DWORD PTR [esi+12]
	lea	eax, DWORD PTR [eax+ecx*2]
	mov	DWORD PTR [esi+48], eax
$LN1@ChannelsSe:
	pop	edi
	pop	esi

; 354  : }

	pop	ebp
	ret	4
?ChannelsSetCurrent@ImDrawList@@QAEXH@Z ENDP		; ImDrawList::ChannelsSetCurrent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
tv435 = -12						; size = 4
_cmd_write$1$ = -12					; size = 4
_i$1$ = -8						; size = 4
_new_cmd_buffer_count$1$ = -8				; size = 4
tv434 = -4						; size = 4
_new_idx_buffer_count$1$ = -4				; size = 4
?ChannelsMerge@ImDrawList@@QAEXXZ PROC			; ImDrawList::ChannelsMerge
; _this$ = ecx

; 311  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	esi, ecx

; 312  :     // Note that we never use or rely on channels.Size because it is merely a buffer that we never shrink back to 0 to keep all sub-buffers ready for use.
; 313  :     if (_ChannelsCount <= 1)

	cmp	DWORD PTR [esi+92], 1
	jle	$LN1@ChannelsMe

; 314  :         return;
; 315  : 
; 316  :     ChannelsSetCurrent(0);

	push	0
	call	?ChannelsSetCurrent@ImDrawList@@QAEXH@Z	; ImDrawList::ChannelsSetCurrent

; 317  :     if (CmdBuffer.Size && CmdBuffer.back().ElemCount == 0)

	mov	edx, DWORD PTR [esi]
	test	edx, edx
	je	SHORT $LN9@ChannelsMe
	mov	eax, DWORD PTR [esi+8]
	mov	ecx, edx
	shl	ecx, 5
	cmp	DWORD PTR [ecx+eax-32], 0
	jne	SHORT $LN9@ChannelsMe
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	lea	eax, DWORD PTR [edx-1]
	mov	DWORD PTR [esi], eax
$LN9@ChannelsMe:
	push	ebx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 321  :     for (int i = 1; i < _ChannelsCount; i++)

	mov	ebx, 1
	mov	DWORD PTR _new_cmd_buffer_count$1$[ebp], 0
	push	edi
	mov	DWORD PTR _new_idx_buffer_count$1$[ebp], 0
	cmp	DWORD PTR [esi+92], ebx
	jle	SHORT $LN3@ChannelsMe

; 318  :         CmdBuffer.pop_back();
; 319  : 
; 320  :     int new_cmd_buffer_count = 0, new_idx_buffer_count = 0;

	mov	edi, 24					; 00000018H
	mov	DWORD PTR tv435[ebp], edi
$LL4@ChannelsMe:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	mov	edx, DWORD PTR [esi+104]
	add	edx, edi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 324  :         if (ch.CmdBuffer.Size && ch.CmdBuffer.back().ElemCount == 0)

	mov	edi, DWORD PTR [edx]
	test	edi, edi
	je	SHORT $LN10@ChannelsMe
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, edi
	shl	ecx, 5
	cmp	DWORD PTR [ecx+eax-32], 0
	jne	SHORT $LN10@ChannelsMe
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	lea	eax, DWORD PTR [edi-1]
	mov	DWORD PTR [edx], eax
$LN10@ChannelsMe:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 326  :         new_cmd_buffer_count += ch.CmdBuffer.Size;

	mov	edi, DWORD PTR _new_cmd_buffer_count$1$[ebp]
	inc	ebx
	add	edi, DWORD PTR [edx]
	mov	DWORD PTR _new_cmd_buffer_count$1$[ebp], edi

; 327  :         new_idx_buffer_count += ch.IdxBuffer.Size;

	mov	edi, DWORD PTR _new_idx_buffer_count$1$[ebp]
	add	edi, DWORD PTR [edx+12]
	mov	DWORD PTR _new_idx_buffer_count$1$[ebp], edi
	mov	edi, DWORD PTR tv435[ebp]
	add	edi, 24					; 00000018H
	mov	DWORD PTR tv435[ebp], edi
	cmp	ebx, DWORD PTR [esi+92]
	jl	SHORT $LL4@ChannelsMe
$LN3@ChannelsMe:

; 328  :     }
; 329  :     CmdBuffer.resize(CmdBuffer.Size + new_cmd_buffer_count);

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	add	eax, DWORD PTR _new_cmd_buffer_count$1$[ebp]
	push	eax
	call	?resize@?$ImVector@UImDrawCmd@@@@QAEXH@Z ; ImVector<ImDrawCmd>::resize

; 330  :     IdxBuffer.resize(IdxBuffer.Size + new_idx_buffer_count);

	mov	eax, DWORD PTR [esi+12]
	lea	ecx, DWORD PTR [esi+12]
	add	eax, DWORD PTR _new_idx_buffer_count$1$[ebp]
	push	eax
	call	?resize@?$ImVector@G@@QAEXH@Z		; ImVector<unsigned short>::resize

; 331  : 
; 332  :     ImDrawCmd* cmd_write = CmdBuffer.Data + CmdBuffer.Size - new_cmd_buffer_count;
; 333  :     _IdxWritePtr = IdxBuffer.Data + IdxBuffer.Size - new_idx_buffer_count;

	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, DWORD PTR _new_idx_buffer_count$1$[ebp]
	mov	eax, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [esi]
	sub	edx, DWORD PTR _new_cmd_buffer_count$1$[ebp]
	shl	edx, 5
	add	edx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [eax+ecx*2]

; 334  :     for (int i = 1; i < _ChannelsCount; i++)

	mov	ecx, 1
	mov	DWORD PTR _cmd_write$1$[ebp], edx
	mov	DWORD PTR [esi+48], eax
	mov	DWORD PTR _i$1$[ebp], ecx
	cmp	DWORD PTR [esi+92], ecx
	jle	SHORT $LN6@ChannelsMe

; 328  :     }
; 329  :     CmdBuffer.resize(CmdBuffer.Size + new_cmd_buffer_count);

	mov	eax, 24					; 00000018H
	mov	DWORD PTR tv434[ebp], eax
$LL7@ChannelsMe:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	mov	ebx, DWORD PTR [esi+104]
	add	ebx, eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 337  :         if (int sz = ch.CmdBuffer.Size) { memcpy(cmd_write, ch.CmdBuffer.Data, sz * sizeof(ImDrawCmd)); cmd_write += sz; }

	mov	edi, DWORD PTR [ebx]
	test	edi, edi
	je	SHORT $LN11@ChannelsMe
	shl	edi, 5
	push	edi
	push	DWORD PTR [ebx+8]
	push	edx
	call	_memcpy
	mov	eax, DWORD PTR tv434[ebp]
	add	esp, 12					; 0000000cH
	add	DWORD PTR _cmd_write$1$[ebp], edi
	mov	ecx, DWORD PTR _i$1$[ebp]
$LN11@ChannelsMe:

; 338  :         if (int sz = ch.IdxBuffer.Size) { memcpy(_IdxWritePtr, ch.IdxBuffer.Data, sz * sizeof(ImDrawIdx)); _IdxWritePtr += sz; }

	mov	edi, DWORD PTR [ebx+12]
	test	edi, edi
	je	SHORT $LN5@ChannelsMe
	add	edi, edi
	push	edi
	push	DWORD PTR [ebx+20]
	push	DWORD PTR [esi+48]
	call	_memcpy
	mov	eax, DWORD PTR tv434[ebp]
	add	esp, 12					; 0000000cH
	add	DWORD PTR [esi+48], edi
	mov	ecx, DWORD PTR _i$1$[ebp]
$LN5@ChannelsMe:

; 334  :     for (int i = 1; i < _ChannelsCount; i++)

	mov	edx, DWORD PTR _cmd_write$1$[ebp]
	inc	ecx
	add	eax, 24					; 00000018H
	mov	DWORD PTR _i$1$[ebp], ecx
	mov	DWORD PTR tv434[ebp], eax
	cmp	ecx, DWORD PTR [esi+92]
	jl	SHORT $LL7@ChannelsMe
$LN6@ChannelsMe:

; 339  :     }
; 340  :     AddDrawCmd();

	mov	ecx, esi
	call	?AddDrawCmd@ImDrawList@@QAEXXZ		; ImDrawList::AddDrawCmd
	pop	edi

; 341  :     _ChannelsCount = 1;

	mov	DWORD PTR [esi+92], 1
	pop	ebx
$LN1@ChannelsMe:
	pop	esi

; 342  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ChannelsMerge@ImDrawList@@QAEXXZ ENDP			; ImDrawList::ChannelsMerge
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_draw_cmd$1 = -44					; size = 32
tv321 = -12						; size = 4
$T2 = -12						; size = 4
_old_channels_count$1$ = -8				; size = 4
_channels_count$ = 8					; size = 4
?ChannelsSplit@ImDrawList@@QAEXH@Z PROC			; ImDrawList::ChannelsSplit
; _this$ = ecx

; 278  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi

; 279  :     IM_ASSERT(_ChannelsCurrent == 0 && _ChannelsCount == 1);
; 280  :     int old_channels_count = _Channels.Size;
; 281  :     if (old_channels_count < channels_count)

	mov	esi, DWORD PTR _channels_count$[ebp]
	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR [edi+96]
	mov	DWORD PTR _old_channels_count$1$[ebp], ecx
	cmp	ecx, esi
	jge	SHORT $LN5@ChannelsSp

; 282  :         _Channels.resize(channels_count);

	push	esi
	lea	ecx, DWORD PTR [edi+96]
	call	?resize@?$ImVector@UImDrawChannel@@@@QAEXH@Z ; ImVector<ImDrawChannel>::resize
	mov	ecx, DWORD PTR _old_channels_count$1$[ebp]
$LN5@ChannelsSp:

; 284  : 
; 285  :     // _Channels[] (24 bytes each) hold storage that we'll swap with this->_CmdBuffer/_IdxBuffer
; 286  :     // The content of _Channels[0] at this point doesn't matter. We clear it to make state tidy in a debugger but we don't strictly need to.
; 287  :     // When we switch to the next channel, we'll copy _CmdBuffer/_IdxBuffer into _Channels[0] and then _Channels[1] into _CmdBuffer/_IdxBuffer
; 288  :     memset(&_Channels[0], 0, sizeof(ImDrawChannel));

	mov	eax, DWORD PTR [edi+104]
	xorps	xmm0, xmm0
	mov	DWORD PTR [edi+92], esi

; 289  :     for (int i = 1; i < channels_count; i++)

	mov	ebx, 1
	movups	XMMWORD PTR [eax], xmm0
	movq	QWORD PTR [eax+16], xmm0
	cmp	esi, ebx
	jle	$LN3@ChannelsSp

; 283  :     _ChannelsCount = channels_count;

	lea	esi, DWORD PTR [ebx+23]
$LL4@ChannelsSp:

; 290  :     {
; 291  :         if (i >= old_channels_count)

	cmp	ebx, ecx
	jl	SHORT $LN6@ChannelsSp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	mov	eax, DWORD PTR [edi+104]
	add	eax, esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 293  :             IM_PLACEMENT_NEW(&_Channels[i]) ImDrawChannel();

	mov	DWORD PTR $T2[ebp], eax
	je	SHORT $LN7@ChannelsSp
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [eax], xmm0
	movq	QWORD PTR [eax+16], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+16], 0
	mov	DWORD PTR [eax+12], 0
	mov	DWORD PTR [eax+20], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 295  :         else

	jmp	SHORT $LN7@ChannelsSp
$LN6@ChannelsSp:

; 296  :         {
; 297  :             _Channels[i].CmdBuffer.resize(0);

	mov	ecx, DWORD PTR [edi+104]
	push	0
	add	ecx, esi
	call	?resize@?$ImVector@UImDrawCmd@@@@QAEXH@Z ; ImVector<ImDrawCmd>::resize

; 298  :             _Channels[i].IdxBuffer.resize(0);

	mov	ecx, DWORD PTR [edi+104]
	add	ecx, 12					; 0000000cH
	push	0
	add	ecx, esi
	call	?resize@?$ImVector@G@@QAEXH@Z		; ImVector<unsigned short>::resize
$LN7@ChannelsSp:

; 299  :         }
; 300  :         if (_Channels[i].CmdBuffer.Size == 0)

	mov	eax, DWORD PTR [edi+104]
	add	eax, esi
	mov	DWORD PTR tv321[ebp], eax
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@ChannelsSp

; 303  :             draw_cmd.ClipRect = _ClipRectStack.back();

	mov	ecx, DWORD PTR [edi+52]
	mov	eax, DWORD PTR [edi+60]
	add	ecx, ecx

; 304  :             draw_cmd.TextureId = _TextureIdStack.back();

	mov	edx, DWORD PTR [edi+64]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1186 :     ImDrawCmd() { ElemCount = 0; ClipRect.x = ClipRect.y = -8192.0f; ClipRect.z = ClipRect.w = +8192.0f; TextureId = NULL; UserCallback = NULL; UserCallbackData = NULL; }

	mov	DWORD PTR _draw_cmd$1[ebp], 0
	mov	DWORD PTR _draw_cmd$1[ebp+24], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 303  :             draw_cmd.ClipRect = _ClipRectStack.back();

	movups	xmm0, XMMWORD PTR [eax+ecx*8-16]

; 304  :             draw_cmd.TextureId = _TextureIdStack.back();

	mov	eax, DWORD PTR [edi+72]

; 305  :             _Channels[i].CmdBuffer.push_back(draw_cmd);

	mov	ecx, DWORD PTR tv321[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1186 :     ImDrawCmd() { ElemCount = 0; ClipRect.x = ClipRect.y = -8192.0f; ClipRect.z = ClipRect.w = +8192.0f; TextureId = NULL; UserCallback = NULL; UserCallbackData = NULL; }

	mov	DWORD PTR _draw_cmd$1[ebp+28], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 303  :             draw_cmd.ClipRect = _ClipRectStack.back();

	movups	XMMWORD PTR _draw_cmd$1[ebp+4], xmm0

; 304  :             draw_cmd.TextureId = _TextureIdStack.back();

	mov	eax, DWORD PTR [eax+edx*4-4]
	mov	DWORD PTR _draw_cmd$1[ebp+20], eax

; 305  :             _Channels[i].CmdBuffer.push_back(draw_cmd);

	lea	eax, DWORD PTR _draw_cmd$1[ebp]
	push	eax
	call	?push_back@?$ImVector@UImDrawCmd@@@@QAEXABUImDrawCmd@@@Z ; ImVector<ImDrawCmd>::push_back
$LN2@ChannelsSp:

; 289  :     for (int i = 1; i < channels_count; i++)

	mov	ecx, DWORD PTR _old_channels_count$1$[ebp]
	inc	ebx
	add	esi, 24					; 00000018H
	cmp	ebx, DWORD PTR _channels_count$[ebp]
	jl	$LL4@ChannelsSp
$LN3@ChannelsSp:
	pop	edi
	pop	esi
	pop	ebx

; 306  :         }
; 307  :     }
; 308  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?ChannelsSplit@ImDrawList@@QAEXH@Z ENDP			; ImDrawList::ChannelsSplit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 8
$T2 = -12						; size = 8
$T3 = -12						; size = 8
$T4 = -12						; size = 8
$T5 = -12						; size = 8
$T6 = -12						; size = 8
_this$1$ = -4						; size = 4
_r1$1$ = 8						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_rounding$ = 16						; size = 4
_r2$1$ = 20						; size = 4
_rounding_corners$ = 20					; size = 4
?PathRect@ImDrawList@@QAEXABUImVec2@@0MH@Z PROC		; ImDrawList::PathRect
; _this$ = ecx

; 781  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _rounding_corners$[ebp]

; 783  :     r = ImMin(r, fabsf(b.x-a.x) * ( ((rounding_corners&(1|2))==(1|2)) || ((rounding_corners&(4|8))==(4|8)) ? 0.5f : 1.0f ) - 1.0f);

	movss	xmm3, DWORD PTR __real@3f000000
	and	eax, 12					; 0000000cH
	movss	xmm2, DWORD PTR __real@3f800000
	cmp	al, 12					; 0000000cH
	mov	eax, DWORD PTR _rounding_corners$[ebp]
	setne	dl
	mov	DWORD PTR _this$1$[ebp], ecx
	and	eax, 3
	cmp	al, 3
	push	esi
	setne	al
	push	edi
	test	dl, al
	je	SHORT $LN6@PathRect
	movaps	xmm1, xmm2
	jmp	SHORT $LN7@PathRect
$LN6@PathRect:
	movaps	xmm1, xmm3
$LN7@PathRect:
	mov	esi, DWORD PTR _a$[ebp]
	mov	edi, DWORD PTR _b$[ebp]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 658  :         return (float)fabs(_X);

	movss	xmm4, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 783  :     r = ImMin(r, fabsf(b.x-a.x) * ( ((rounding_corners&(1|2))==(1|2)) || ((rounding_corners&(4|8))==(4|8)) ? 0.5f : 1.0f ) - 1.0f);

	movss	xmm6, DWORD PTR [esi]
	movss	xmm0, DWORD PTR [edi]
	subss	xmm0, xmm6
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 658  :         return (float)fabs(_X);

	andps	xmm0, xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 783  :     r = ImMin(r, fabsf(b.x-a.x) * ( ((rounding_corners&(1|2))==(1|2)) || ((rounding_corners&(4|8))==(4|8)) ? 0.5f : 1.0f ) - 1.0f);

	mulss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 127  : static inline float  ImMin(float lhs, float rhs)                                { return lhs < rhs ? lhs : rhs; }

	movss	xmm1, DWORD PTR _rounding$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 783  :     r = ImMin(r, fabsf(b.x-a.x) * ( ((rounding_corners&(1|2))==(1|2)) || ((rounding_corners&(4|8))==(4|8)) ? 0.5f : 1.0f ) - 1.0f);

	subss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 127  : static inline float  ImMin(float lhs, float rhs)                                { return lhs < rhs ? lhs : rhs; }

	comiss	xmm0, xmm1
	ja	SHORT $LN23@PathRect
	movaps	xmm1, xmm0
	movss	DWORD PTR _rounding$[ebp], xmm1
$LN23@PathRect:
	mov	edx, DWORD PTR _rounding_corners$[ebp]
	mov	eax, edx
	and	eax, 9
	cmp	al, 9
	mov	eax, edx
	setne	cl
	and	eax, 6
	cmp	al, 6
	setne	al
	test	cl, al
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 784  :     r = ImMin(r, fabsf(b.y-a.y) * ( ((rounding_corners&(1|8))==(1|8)) || ((rounding_corners&(2|4))==(2|4)) ? 0.5f : 1.0f ) - 1.0f);

	je	SHORT $LN8@PathRect
	movaps	xmm3, xmm2
$LN8@PathRect:
	movss	xmm5, DWORD PTR [esi+4]
	movss	xmm0, DWORD PTR [edi+4]
	subss	xmm0, xmm5
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 658  :         return (float)fabs(_X);

	andps	xmm0, xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 784  :     r = ImMin(r, fabsf(b.y-a.y) * ( ((rounding_corners&(1|8))==(1|8)) || ((rounding_corners&(2|4))==(2|4)) ? 0.5f : 1.0f ) - 1.0f);

	mulss	xmm0, xmm3
	subss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 127  : static inline float  ImMin(float lhs, float rhs)                                { return lhs < rhs ? lhs : rhs; }

	comiss	xmm0, xmm1
	ja	SHORT $LN29@PathRect
	movaps	xmm1, xmm0
	movss	DWORD PTR _rounding$[ebp], xmm1
$LN29@PathRect:
	xorps	xmm0, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 786  :     if (r <= 0.0f || rounding_corners == 0)

	comiss	xmm0, xmm1
	jae	$LN4@PathRect
	test	edx, edx
	je	$LN4@PathRect

; 787  :     {
; 788  :         PathLineTo(a);
; 789  :         PathLineTo(ImVec2(b.x,a.y));
; 790  :         PathLineTo(b);
; 791  :         PathLineTo(ImVec2(a.x,b.y));
; 792  :     }
; 793  :     else
; 794  :     {
; 795  :         const float r0 = (rounding_corners & 1) ? r : 0.0f;

	test	dl, 1
	je	SHORT $LN10@PathRect
	movaps	xmm3, xmm1
	jmp	SHORT $LN11@PathRect
$LN10@PathRect:
	xorps	xmm3, xmm3
$LN11@PathRect:

; 796  :         const float r1 = (rounding_corners & 2) ? r : 0.0f;

	test	dl, 2
	je	SHORT $LN12@PathRect
	movss	DWORD PTR _r1$1$[ebp], xmm1
	jmp	SHORT $LN13@PathRect
$LN12@PathRect:
	xorps	xmm2, xmm2
	movss	DWORD PTR _r1$1$[ebp], xmm2
$LN13@PathRect:

; 797  :         const float r2 = (rounding_corners & 4) ? r : 0.0f;

	test	dl, 4
	jne	SHORT $LN50@PathRect
	xorps	xmm1, xmm1
$LN50@PathRect:
	movss	DWORD PTR _r2$1$[ebp], xmm1

; 798  :         const float r3 = (rounding_corners & 8) ? r : 0.0f;

	test	dl, 8
	jne	SHORT $LN17@PathRect
	movss	DWORD PTR _rounding$[ebp], xmm0
$LN17@PathRect:

; 799  :         PathArcToFast(ImVec2(a.x+r0,a.y+r0), r0, 6, 9);

	push	9
	push	6
	addss	xmm6, xmm3
	addss	xmm5, xmm3
	push	ecx
	mov	ecx, DWORD PTR _this$1$[ebp]
	lea	eax, DWORD PTR $T4[ebp]
	movss	DWORD PTR [esp], xmm3
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp], xmm6
	movss	DWORD PTR $T4[ebp+4], xmm5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 799  :         PathArcToFast(ImVec2(a.x+r0,a.y+r0), r0, 6, 9);

	call	?PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z ; ImDrawList::PathArcToFast

; 800  :         PathArcToFast(ImVec2(b.x-r1,a.y+r1), r1, 9, 12);

	movss	xmm1, DWORD PTR _r1$1$[ebp]
	lea	eax, DWORD PTR $T3[ebp]
	movss	xmm0, DWORD PTR [edi]
	subss	xmm0, xmm1
	push	12					; 0000000cH
	push	9
	push	ecx
	mov	ecx, DWORD PTR _this$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 800  :         PathArcToFast(ImVec2(b.x-r1,a.y+r1), r1, 9, 12);

	movss	xmm0, DWORD PTR [esi+4]
	addss	xmm0, xmm1
	movss	DWORD PTR [esp], xmm1
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 800  :         PathArcToFast(ImVec2(b.x-r1,a.y+r1), r1, 9, 12);

	call	?PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z ; ImDrawList::PathArcToFast

; 801  :         PathArcToFast(ImVec2(b.x-r2,b.y-r2), r2, 0, 3);

	movss	xmm1, DWORD PTR _r2$1$[ebp]
	lea	eax, DWORD PTR $T2[ebp]
	movss	xmm0, DWORD PTR [edi]
	subss	xmm0, xmm1
	push	3
	push	0
	push	ecx
	mov	ecx, DWORD PTR _this$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 801  :         PathArcToFast(ImVec2(b.x-r2,b.y-r2), r2, 0, 3);

	movss	xmm0, DWORD PTR [edi+4]
	subss	xmm0, xmm1
	movss	DWORD PTR [esp], xmm1
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 801  :         PathArcToFast(ImVec2(b.x-r2,b.y-r2), r2, 0, 3);

	call	?PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z ; ImDrawList::PathArcToFast

; 802  :         PathArcToFast(ImVec2(a.x+r3,b.y-r3), r3, 3, 6);

	movss	xmm1, DWORD PTR _rounding$[ebp]
	lea	eax, DWORD PTR $T1[ebp]
	movss	xmm0, DWORD PTR [esi]
	addss	xmm0, xmm1
	push	6
	push	3
	push	ecx
	mov	ecx, DWORD PTR _this$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 802  :         PathArcToFast(ImVec2(a.x+r3,b.y-r3), r3, 3, 6);

	movss	xmm0, DWORD PTR [edi+4]
	subss	xmm0, xmm1
	movss	DWORD PTR [esp], xmm1
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 802  :         PathArcToFast(ImVec2(a.x+r3,b.y-r3), r3, 3, 6);

	call	?PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z ; ImDrawList::PathArcToFast
	pop	edi
	pop	esi

; 804  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN4@PathRect:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1270 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	mov	esi, DWORD PTR _this$1$[ebp]
	push	DWORD PTR _a$[ebp]
	add	esi, 76					; 0000004cH
	mov	ecx, esi
	call	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR _a$[ebp]

; 1270 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	mov	ecx, esi

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR [edi]
	movss	DWORD PTR $T6[ebp], xmm0
	movss	xmm0, DWORD PTR [eax+4]

; 1270 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	lea	eax, DWORD PTR $T6[ebp]
	push	eax

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T6[ebp+4], xmm0

; 1270 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	call	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back
	push	edi
	mov	ecx, esi
	call	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR _a$[ebp]

; 1270 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	mov	ecx, esi

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR [eax]

; 1270 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	lea	eax, DWORD PTR $T5[ebp]

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T5[ebp], xmm0
	movss	xmm0, DWORD PTR [edi+4]

; 1270 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	push	eax

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T5[ebp+4], xmm0

; 1270 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	call	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back
	pop	edi
	pop	esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 804  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?PathRect@ImDrawList@@QAEXABUImVec2@@0MH@Z ENDP		; ImDrawList::PathRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T1 = -16						; size = 8
_p1$ = -8						; size = 8
_p2$ = 8						; size = 4
_p3$ = 12						; size = 4
_p4$ = 16						; size = 4
_t_step$1$ = 20						; size = 4
_num_segments$ = 20					; size = 4
?PathBezierCurveTo@ImDrawList@@QAEXABUImVec2@@00H@Z PROC ; ImDrawList::PathBezierCurveTo
; _this$ = ecx

; 757  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 758  :     ImVec2 p1 = _Path.back();

	mov	edx, DWORD PTR [ecx+84]
	push	esi

; 759  :     if (num_segments == 0)

	mov	esi, DWORD PTR _num_segments$[ebp]
	push	edi
	lea	edi, DWORD PTR [ecx+76]
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+ecx*8-8]
	mov	DWORD PTR _p1$[ebp], eax
	mov	eax, DWORD PTR [edx+ecx*8-4]
	mov	DWORD PTR _p1$[ebp+4], eax
	test	esi, esi
	jne	$LN5@PathBezier

; 760  :     {
; 761  :         // Auto-tessellated
; 762  :         PathBezierToCasteljau(&_Path, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y, GImGui->Style.CurveTessellationTol, 0);

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	esi
	sub	esp, 36					; 00000024H
	movss	xmm0, DWORD PTR [eax+5444]
	mov	eax, DWORD PTR _p4$[ebp]
	movss	DWORD PTR [esp+32], xmm0
	movss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [esp+28], xmm0
	movss	xmm0, DWORD PTR [eax]
	mov	eax, DWORD PTR _p3$[ebp]
	movss	DWORD PTR [esp+24], xmm0
	movss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [esp+20], xmm0
	movss	xmm0, DWORD PTR [eax]
	mov	eax, DWORD PTR _p2$[ebp]
	movss	DWORD PTR [esp+16], xmm0
	movss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [esp+12], xmm0
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _p1$[ebp+4]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _p1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	edi
	call	?PathBezierToCasteljau@@YAXPAV?$ImVector@UImVec2@@@@MMMMMMMMMH@Z ; PathBezierToCasteljau
	add	esp, 44					; 0000002cH
	pop	edi
	pop	esi

; 776  :         }
; 777  :     }
; 778  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN5@PathBezier:

; 763  :     }
; 764  :     else
; 765  :     {
; 766  :         float t_step = 1.0f / (float)num_segments;

	movss	xmm3, DWORD PTR __real@3f800000
	movd	xmm0, esi
	movaps	xmm2, xmm3
	cvtdq2ps xmm0, xmm0
	push	ebx

; 767  :         for (int i_step = 1; i_step <= num_segments; i_step++)

	mov	ebx, 1
	divss	xmm2, xmm0
	movss	DWORD PTR _t_step$1$[ebp], xmm2
	cmp	esi, ebx
	jl	$LN16@PathBezier
	npad	7
$LL4@PathBezier:

; 775  :             _Path.push_back(ImVec2(w1*p1.x + w2*p2.x + w3*p3.x + w4*p4.x, w1*p1.y + w2*p2.y + w3*p3.y + w4*p4.y));

	mov	eax, DWORD PTR _p2$[ebp]
	movaps	xmm0, xmm3
	movd	xmm1, ebx
	cvtdq2ps xmm1, xmm1
	mov	ecx, DWORD PTR _p3$[ebp]
	mov	edx, DWORD PTR _p4$[ebp]
	mulss	xmm1, xmm2
	subss	xmm0, xmm1
	movaps	xmm2, xmm1
	mulss	xmm2, xmm1
	movaps	xmm4, xmm0
	mulss	xmm2, xmm1
	mulss	xmm4, DWORD PTR __real@40400000
	movaps	xmm5, xmm0
	mulss	xmm5, xmm0
	movaps	xmm3, xmm4
	mulss	xmm4, xmm1
	mulss	xmm3, xmm0
	mulss	xmm5, xmm0
	mulss	xmm3, xmm1
	mulss	xmm4, xmm1
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR _p1$[ebp]
	movss	xmm1, DWORD PTR [eax]
	mulss	xmm5, DWORD PTR _p1$[ebp+4]
	mulss	xmm1, xmm3
	mulss	xmm3, DWORD PTR [eax+4]
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, xmm4
	addss	xmm5, xmm3
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, xmm2
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR [ecx+4]
	mulss	xmm0, xmm4
	mov	ecx, edi
	addss	xmm5, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 775  :             _Path.push_back(ImVec2(w1*p1.x + w2*p2.x + w3*p3.x + w4*p4.x, w1*p1.y + w2*p2.y + w3*p3.y + w4*p4.y));

	movss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, xmm2
	addss	xmm5, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 775  :             _Path.push_back(ImVec2(w1*p1.x + w2*p2.x + w3*p3.x + w4*p4.x, w1*p1.y + w2*p2.y + w3*p3.y + w4*p4.y));

	call	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back
	movss	xmm2, DWORD PTR _t_step$1$[ebp]
	inc	ebx
	movss	xmm3, DWORD PTR __real@3f800000
	cmp	ebx, esi
	jle	$LL4@PathBezier
$LN16@PathBezier:
	pop	ebx
	pop	edi
	pop	esi

; 776  :         }
; 777  :     }
; 778  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?PathBezierCurveTo@ImDrawList@@QAEXABUImVec2@@00H@Z ENDP ; ImDrawList::PathBezierCurveTo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
tv702 = -32						; size = 16
$T1 = -24						; size = 8
_new_capacity$1$ = -20					; size = 4
_new_data$1$ = -4					; size = 4
_centre$ = 8						; size = 4
_radius$ = 12						; size = 4
_amin$ = 16						; size = 4
_amax$ = 20						; size = 4
?PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z PROC	; ImDrawList::PathArcToFast
; _this$ = ecx

; 687  : {

	npad	2
	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp

; 688  :     static ImVec2 circle_vtx[12];

	mov	eax, DWORD PTR fs:__tls_array
	sub	esp, 40					; 00000028H
	mov	edx, DWORD PTR __tls_index
	push	esi
	mov	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ?$TSS0@?1??PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z@4HA
	push	edi
	mov	edi, ecx
	cmp	eax, DWORD PTR __Init_thread_epoch[edx]
	jle	SHORT $LN2@PathArcToF
	jmp	$LN48@PathArcToF
$LN2@PathArcToF:

; 689  :     static bool circle_vtx_builds = false;
; 690  :     const int circle_vtx_count = IM_ARRAYSIZE(circle_vtx);
; 691  :     if (!circle_vtx_builds)

	cmp	BYTE PTR ?circle_vtx_builds@?1??PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z@4_NA, 0
	jne	$LN9@PathArcToF

; 692  :     {
; 693  :         for (int i = 0; i < circle_vtx_count; i++)

	xor	esi, esi
	npad	1
$LL5@PathArcToF:
	movd	xmm0, esi
	pshufd	xmm0, xmm0, 0
	paddd	xmm0, XMMWORD PTR __xmm@00000003000000020000000100000000

; 694  :         {
; 695  :             const float a = ((float)i / (float)circle_vtx_count) * 2*IM_PI;

	cvtdq2ps xmm0, xmm0
	mulps	xmm0, XMMWORD PTR __xmm@3daaaaab3daaaaab3daaaaab3daaaaab
	mulps	xmm0, XMMWORD PTR __xmm@40000000400000004000000040000000
	mulps	xmm0, XMMWORD PTR __xmm@40490fdb40490fdb40490fdb40490fdb
	movaps	XMMWORD PTR tv702[ebp], xmm0
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 635  :         return (float)cos(_X);

	call	___vdecl_cosf4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 696  :             circle_vtx[i].x = cosf(a);

	movss	DWORD PTR ?circle_vtx@?1??PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z@4PAU3@A[esi*8], xmm0
	shufps	xmm0, xmm0, 229				; 000000e5H
	movss	DWORD PTR ?circle_vtx@?1??PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z@4PAU3@A[esi*8+8], xmm0
	unpckhps xmm0, xmm0
	movss	DWORD PTR ?circle_vtx@?1??PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z@4PAU3@A[esi*8+16], xmm0
	unpckhps xmm0, xmm0
	movss	DWORD PTR ?circle_vtx@?1??PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z@4PAU3@A[esi*8+24], xmm0
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 736  :         return (float)sin(_X);

	movaps	xmm0, XMMWORD PTR tv702[ebp]
	call	___vdecl_sinf4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 697  :             circle_vtx[i].y = sinf(a);

	movss	DWORD PTR ?circle_vtx@?1??PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z@4PAU3@A[esi*8+4], xmm0
	shufps	xmm0, xmm0, 229				; 000000e5H
	movss	DWORD PTR ?circle_vtx@?1??PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z@4PAU3@A[esi*8+12], xmm0
	unpckhps xmm0, xmm0
	movss	DWORD PTR ?circle_vtx@?1??PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z@4PAU3@A[esi*8+20], xmm0
	unpckhps xmm0, xmm0
	movss	DWORD PTR ?circle_vtx@?1??PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z@4PAU3@A[esi*8+28], xmm0
	add	esi, 4
	cmp	esi, 12					; 0000000cH
	jl	$LL5@PathArcToF

; 698  :         }
; 699  :         circle_vtx_builds = true;

	mov	BYTE PTR ?circle_vtx_builds@?1??PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z@4_NA, 1
$LN9@PathArcToF:

; 700  :     }
; 701  : 
; 702  :     if (amin > amax) return;

	mov	esi, DWORD PTR _amin$[ebx]
	mov	ecx, DWORD PTR _amax$[ebx]
	cmp	esi, ecx
	jg	$LN7@PathArcToF

; 703  :     if (radius == 0.0f)

	movss	xmm1, DWORD PTR _radius$[ebx]
	xorps	xmm0, xmm0
	ucomiss	xmm1, xmm0
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@PathArcToF

; 704  :     {
; 705  :         _Path.push_back(centre);

	push	DWORD PTR _centre$[ebx]
	lea	ecx, DWORD PTR [edi+76]
	call	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back

; 714  :         }
; 715  :     }
; 716  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	16					; 00000010H
$LN11@PathArcToF:

; 706  :     }
; 707  :     else
; 708  :     {
; 709  :         _Path.reserve(_Path.Size + (amax - amin + 1));

	mov	eax, DWORD PTR [edi+76]
	sub	ecx, esi
	inc	ecx
	add	eax, ecx
	mov	DWORD PTR _new_capacity$1$[ebp], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 931  :         if (new_capacity <= Capacity) return;

	cmp	eax, DWORD PTR [edi+80]
	jle	SHORT $LL25@PathArcToF

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	shl	eax, 3
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [edi+84]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN27@PathArcToF

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [edi+76]
	shl	ecx, 3
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN27@PathArcToF:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [edi+84]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	movss	xmm1, DWORD PTR _radius$[ebx]
	mov	DWORD PTR [edi+84], eax

; 937  :         Capacity = new_capacity;

	mov	eax, DWORD PTR _new_capacity$1$[ebp]
	mov	DWORD PTR [edi+80], eax
$LL25@PathArcToF:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 712  :             const ImVec2& c = circle_vtx[a % circle_vtx_count];

	mov	eax, 715827883				; 2aaaaaabH
	mov	ecx, esi
	imul	esi
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
	sub	ecx, eax

; 713  :             _Path.push_back(ImVec2(centre.x + c.x * radius, centre.y + c.y * radius));

	mov	eax, DWORD PTR _centre$[ebx]
	movss	xmm0, DWORD PTR ?circle_vtx@?1??PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z@4PAU3@A[ecx*8]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [eax]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 713  :             _Path.push_back(ImVec2(centre.x + c.x * radius, centre.y + c.y * radius));

	movss	xmm0, DWORD PTR ?circle_vtx@?1??PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z@4PAU3@A[ecx*8+4]
	lea	ecx, DWORD PTR [edi+76]
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [eax+4]
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 713  :             _Path.push_back(ImVec2(centre.x + c.x * radius, centre.y + c.y * radius));

	call	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back
	movss	xmm1, DWORD PTR _radius$[ebx]
	inc	esi
	cmp	esi, DWORD PTR _amax$[ebx]
	jle	SHORT $LL25@PathArcToF
$LN7@PathArcToF:

; 714  :         }
; 715  :     }
; 716  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	16					; 00000010H
$LN48@PathArcToF:

; 688  :     static ImVec2 circle_vtx[12];

	push	OFFSET ?$TSS0@?1??PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z@4HA
	call	__Init_thread_header
	add	esp, 4
	cmp	DWORD PTR ?$TSS0@?1??PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z@4HA, -1
	jne	$LN2@PathArcToF
	mov	eax, OFFSET ?circle_vtx@?1??PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z@4PAU3@A
	mov	ecx, 12					; 0000000cH
	jmp	SHORT $LL16@PathArcToF
$LL16@PathArcToF:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 97   :     ImVec2() { x = y = 0.0f; }

	mov	DWORD PTR [eax+4], 0
	lea	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [eax-8], 0
	sub	ecx, 1
	jne	SHORT $LL16@PathArcToF
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 688  :     static ImVec2 circle_vtx[12];

	push	OFFSET ?$TSS0@?1??PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z@4HA
	call	__Init_thread_footer
	add	esp, 4
	jmp	$LN2@PathArcToF
?PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z ENDP	; ImDrawList::PathArcToFast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 8
tv221 = -4						; size = 4
_centre$ = 8						; size = 4
_radius$ = 12						; size = 4
_amin$ = 16						; size = 4
_amax$ = 20						; size = 4
_a$1$ = 24						; size = 4
_new_data$1$ = 24					; size = 4
_num_segments$ = 24					; size = 4
?PathArcTo@ImDrawList@@QAEXABUImVec2@@MMMH@Z PROC	; ImDrawList::PathArcTo
; _this$ = ecx

; 719  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 720  :     if (radius == 0.0f)

	movss	xmm0, DWORD PTR _radius$[ebp]
	sub	esp, 12					; 0000000cH
	ucomiss	xmm0, DWORD PTR __real@00000000
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@PathArcTo

; 721  :         _Path.push_back(centre);

	push	DWORD PTR _centre$[ebp]
	lea	ecx, DWORD PTR [esi+76]
	call	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back
$LN5@PathArcTo:

; 722  :     _Path.reserve(_Path.Size + (num_segments + 1));

	mov	ebx, DWORD PTR _num_segments$[ebp]
	lea	edi, DWORD PTR [ebx+1]
	add	edi, DWORD PTR [esi+76]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 931  :         if (new_capacity <= Capacity) return;

	cmp	edi, DWORD PTR [esi+80]
	jle	SHORT $LN7@PathArcTo

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*8]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [esi+84]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN9@PathArcTo

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi+76]
	shl	ecx, 3
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN9@PathArcTo:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+84]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+84], eax

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+80], edi
$LN7@PathArcTo:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 723  :     for (int i = 0; i <= num_segments; i++)

	xor	edi, edi
	test	ebx, ebx
	js	$LN3@PathArcTo
	movss	xmm1, DWORD PTR __real@3f800000
	movd	xmm0, ebx
	cvtdq2ps xmm0, xmm0
	movss	xmm2, DWORD PTR _amax$[ebp]
	movss	xmm3, DWORD PTR _amin$[ebp]
	divss	xmm1, xmm0
	subss	xmm2, xmm3
	movss	DWORD PTR tv221[ebp], xmm1
	movss	DWORD PTR _amax$[ebp], xmm2
	npad	4
$LL4@PathArcTo:
	movd	xmm0, edi

; 724  :     {
; 725  :         const float a = amin + ((float)i / (float)num_segments) * (amax - amin);

	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	mulss	xmm0, xmm2
	addss	xmm0, xmm3
	movss	DWORD PTR _a$1$[ebp], xmm0
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 635  :         return (float)cos(_X);

	call	___libm_sse2_cosf
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 726  :         _Path.push_back(ImVec2(centre.x + cosf(a) * radius, centre.y + sinf(a) * radius));

	mulss	xmm0, DWORD PTR _radius$[ebp]
	mov	eax, DWORD PTR _centre$[ebp]
	addss	xmm0, DWORD PTR [eax]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm0
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 736  :         return (float)sin(_X);

	movss	xmm0, DWORD PTR _a$1$[ebp]
	call	___libm_sse2_sinf
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 726  :         _Path.push_back(ImVec2(centre.x + cosf(a) * radius, centre.y + sinf(a) * radius));

	mulss	xmm0, DWORD PTR _radius$[ebp]
	lea	ecx, DWORD PTR [esi+76]
	mov	eax, DWORD PTR _centre$[ebp]
	addss	xmm0, DWORD PTR [eax+4]
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 726  :         _Path.push_back(ImVec2(centre.x + cosf(a) * radius, centre.y + sinf(a) * radius));

	call	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back
	movss	xmm1, DWORD PTR tv221[ebp]
	inc	edi
	movss	xmm2, DWORD PTR _amax$[ebp]
	movss	xmm3, DWORD PTR _amin$[ebp]
	cmp	edi, ebx
	jle	SHORT $LL4@PathArcTo
$LN3@PathArcTo:
	pop	edi
	pop	esi
	pop	ebx

; 727  :     }
; 728  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?PathArcTo@ImDrawList@@QAEXABUImVec2@@MMMH@Z ENDP	; ImDrawList::PathArcTo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?PathStroke@ImDrawList@@QAEXI_NM@Z
_TEXT	SEGMENT
_col$ = 8						; size = 4
_closed$ = 12						; size = 1
_thickness$ = 16					; size = 4
?PathStroke@ImDrawList@@QAEXI_NM@Z PROC			; ImDrawList::PathStroke, COMDAT
; _this$ = ecx

; 1273 :     inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f)  { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness, true); PathClear(); }

	npad	2
	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR _thickness$[ebp]
	push	esi
	push	1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	esi, DWORD PTR [ecx+76]
	push	DWORD PTR _closed$[ebp]
	push	DWORD PTR _col$[ebp]
	push	DWORD PTR [esi]
	push	DWORD PTR [ecx+84]
	call	?AddPolyline@ImDrawList@@QAEXPBUImVec2@@HI_NM1@Z ; ImDrawList::AddPolyline

; 1269 :     inline    void  PathClear()                                                 { _Path.resize(0); }

	push	0
	mov	ecx, esi
	call	?resize@?$ImVector@UImVec2@@@@QAEXH@Z	; ImVector<ImVec2>::resize
	pop	esi

; 1273 :     inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f)  { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness, true); PathClear(); }

	pop	ebp
	ret	12					; 0000000cH
?PathStroke@ImDrawList@@QAEXI_NM@Z ENDP			; ImDrawList::PathStroke
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?PathFill@ImDrawList@@QAEXI@Z
_TEXT	SEGMENT
_col$ = 8						; size = 4
?PathFill@ImDrawList@@QAEXI@Z PROC			; ImDrawList::PathFill, COMDAT
; _this$ = ecx

; 1272 :     inline    void  PathFill(ImU32 col)                                         { AddConvexPolyFilled(_Path.Data, _Path.Size, col, true); PathClear(); }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	1
	push	DWORD PTR _col$[ebp]
	lea	esi, DWORD PTR [ecx+76]
	push	DWORD PTR [esi]
	push	DWORD PTR [ecx+84]
	call	?AddConvexPolyFilled@ImDrawList@@QAEXPBUImVec2@@HI_N@Z ; ImDrawList::AddConvexPolyFilled

; 1269 :     inline    void  PathClear()                                                 { _Path.resize(0); }

	push	0
	mov	ecx, esi
	call	?resize@?$ImVector@UImVec2@@@@QAEXH@Z	; ImVector<ImVec2>::resize
	pop	esi

; 1272 :     inline    void  PathFill(ImU32 col)                                         { AddConvexPolyFilled(_Path.Data, _Path.Size, col, true); PathClear(); }

	pop	ebp
	ret	4
?PathFill@ImDrawList@@QAEXI@Z ENDP			; ImDrawList::PathFill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z
_TEXT	SEGMENT
_pos$ = 8						; size = 4
?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z PROC		; ImDrawList::PathLineTo, COMDAT
; _this$ = ecx

; 1270 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	npad	2
	push	ebp
	mov	ebp, esp
	add	ecx, 76					; 0000004cH
	pop	ebp
	jmp	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back
?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z ENDP		; ImDrawList::PathLineTo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?PathClear@ImDrawList@@QAEXXZ
_TEXT	SEGMENT
?PathClear@ImDrawList@@QAEXXZ PROC			; ImDrawList::PathClear, COMDAT
; _this$ = ecx

; 1269 :     inline    void  PathClear()                                                 { _Path.resize(0); }

	push	0
	add	ecx, 76					; 0000004cH
	call	?resize@?$ImVector@UImVec2@@@@QAEXH@Z	; ImVector<ImVec2>::resize
	ret	0
?PathClear@ImDrawList@@QAEXXZ ENDP			; ImDrawList::PathClear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_pos0$ = 8						; size = 4
_cp0$ = 12						; size = 4
_cp1$ = 16						; size = 4
_pos1$ = 20						; size = 4
_col$ = 24						; size = 4
_thickness$ = 28					; size = 4
_num_segments$ = 32					; size = 4
?AddBezierCurve@ImDrawList@@QAEXABUImVec2@@000IMH@Z PROC ; ImDrawList::AddBezierCurve
; _this$ = ecx

; 922  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 923  :     if ((col & IM_COL32_A_MASK) == 0)

	test	DWORD PTR _col$[ebp], -16777216		; ff000000H
	push	ebx
	mov	ebx, ecx
	je	SHORT $LN1@AddBezierC
	push	esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1270 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	push	DWORD PTR _pos0$[ebp]
	lea	ecx, DWORD PTR [ebx+76]
	call	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 927  :     PathBezierCurveTo(cp0, cp1, pos1, num_segments);

	push	DWORD PTR _num_segments$[ebp]
	mov	ecx, ebx
	push	DWORD PTR _pos1$[ebp]
	push	DWORD PTR _cp1$[ebp]
	push	DWORD PTR _cp0$[ebp]
	call	?PathBezierCurveTo@ImDrawList@@QAEXABUImVec2@@00H@Z ; ImDrawList::PathBezierCurveTo
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1273 :     inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f)  { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness, true); PathClear(); }

	movss	xmm0, DWORD PTR _thickness$[ebp]
	push	1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, ebx
	push	0
	push	DWORD PTR _col$[ebp]
	push	DWORD PTR [ebx+76]
	push	DWORD PTR [ebx+84]
	call	?AddPolyline@ImDrawList@@QAEXPBUImVec2@@HI_NM1@Z ; ImDrawList::AddPolyline

; 1269 :     inline    void  PathClear()                                                 { _Path.resize(0); }

	push	0
	lea	ecx, DWORD PTR [ebx+76]
	call	?resize@?$ImVector@UImVec2@@@@QAEXH@Z	; ImVector<ImVec2>::resize
	pop	esi
$LN1@AddBezierC:
	pop	ebx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 929  : }

	pop	ebp
	ret	28					; 0000001cH
?AddBezierCurve@ImDrawList@@QAEXABUImVec2@@000IMH@Z ENDP ; ImDrawList::AddBezierCurve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\malloc.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\malloc.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\malloc.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\malloc.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\malloc.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\malloc.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T4 = -44						; size = 8
$T5 = -36						; size = 8
_vtx_count$1$ = -28					; size = 4
_col_trans$1$ = -24					; size = 4
_uv$2$ = -20						; size = 4
_uv$1$ = -16						; size = 4
_i0$1$ = -12						; size = 4
_i$1$ = -12						; size = 4
_temp_normals$1$ = -8					; size = 4
_i1$1$ = -4						; size = 4
_this$1$ = -4						; size = 4
_points$ = 8						; size = 4
_points_count$ = 12					; size = 4
_col$ = 16						; size = 4
_i$1$ = 20						; size = 4
_vtx_inner_idx$1$ = 20					; size = 4
tv951 = 20						; size = 4
_anti_aliased$ = 20					; size = 1
?AddConvexPolyFilled@ImDrawList@@QAEXPBUImVec2@@HI_N@Z PROC ; ImDrawList::AddConvexPolyFilled
; _this$ = ecx

; 599  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	esi
	push	edi

; 600  :   IM_ASSERT(points_count > 2);
; 601  : 
; 602  :   if (points_count < 3)

	mov	edi, DWORD PTR _points_count$[ebp]
	mov	esi, ecx
	mov	DWORD PTR _this$1$[ebp], esi
	cmp	edi, 3
	jl	$LN19@AddConvexP

; 603  :     return;
; 604  : 
; 605  :     const ImVec2 uv = GImGui->FontTexUvWhitePixel;

	mov	edx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [edx+6180]
	mov	DWORD PTR _uv$1$[ebp], eax
	mov	eax, DWORD PTR [edx+6184]
	mov	DWORD PTR _uv$2$[ebp], eax

; 606  :     anti_aliased &= GImGui->Style.AntiAliasedShapes;

	mov	al, BYTE PTR _anti_aliased$[ebp]
	test	BYTE PTR [edx+5441], al

; 607  :     //if (ImGui::GetIO().KeyCtrl) anti_aliased = false; // Debug
; 608  : 
; 609  :     if (anti_aliased)

	je	$LN18@AddConvexP

; 610  :     {
; 611  :         // Anti-aliased Fill
; 612  :         const float AA_SIZE = 1.0f;
; 613  :         const ImU32 col_trans = col & IM_COL32(255,255,255,0);

	mov	eax, DWORD PTR _col$[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _col_trans$1$[ebp], eax

; 614  :         const int idx_count = (points_count-2)*3 + points_count*6;
; 615  :         const int vtx_count = (points_count*2);

	lea	eax, DWORD PTR [edi+edi]

; 616  :         PrimReserve(idx_count, vtx_count);

	push	eax
	mov	DWORD PTR _vtx_count$1$[ebp], eax
	lea	eax, DWORD PTR [edi*8-6]
	add	eax, edi
	push	eax
	call	?PrimReserve@ImDrawList@@QAEXHH@Z	; ImDrawList::PrimReserve

; 617  : 
; 618  :         // Add indexes for fill
; 619  :         unsigned int vtx_inner_idx = _VtxCurrentIdx;

	mov	edx, DWORD PTR [esi+40]

; 620  :         unsigned int vtx_outer_idx = _VtxCurrentIdx+1;
; 621  :         for (int i = 2; i < points_count; i++)

	mov	ecx, 2
	mov	DWORD PTR _vtx_inner_idx$1$[ebp], edx
	mov	DWORD PTR _i$1$[ebp], ecx
	cmp	edi, ecx
	jle	SHORT $LN3@AddConvexP
	jmp	SHORT $LN4@AddConvexP
$LL93@AddConvexP:
	mov	edx, DWORD PTR _vtx_inner_idx$1$[ebp]
$LN4@AddConvexP:

; 622  :         {
; 623  :             _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx+((i-1)<<1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx+(i<<1));

	mov	eax, DWORD PTR [esi+48]
	mov	WORD PTR [eax], dx
	mov	eax, DWORD PTR [esi+48]
	movzx	edx, cx
	mov	ecx, DWORD PTR _vtx_inner_idx$1$[ebp]
	add	ecx, -2					; fffffffeH
	lea	ecx, DWORD PTR [ecx+edx*2]
	mov	WORD PTR [eax+2], cx
	mov	eax, DWORD PTR _vtx_inner_idx$1$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	eax, DWORD PTR [esi+48]
	mov	WORD PTR [eax+4], cx
	mov	ecx, DWORD PTR _i$1$[ebp]

; 624  :             _IdxWritePtr += 3;

	add	DWORD PTR [esi+48], 6
	inc	ecx
	mov	DWORD PTR _i$1$[ebp], ecx
	cmp	ecx, edi
	jl	SHORT $LL93@AddConvexP
$LN3@AddConvexP:

; 628  :         ImVec2* temp_normals = (ImVec2*)_malloca(points_count * sizeof(ImVec2));

	lea	edx, DWORD PTR [edi*8]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\malloc.h

; 102  :         size_t _MarkedSize = _Size + _ALLOCA_S_MARKER_SIZE;

	lea	ecx, DWORD PTR [edx+8]

; 103  :         return _MarkedSize > _Size ? _MarkedSize : 0;

	cmp	edx, ecx
	sbb	eax, eax
	test	eax, ecx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 628  :         ImVec2* temp_normals = (ImVec2*)_malloca(points_count * sizeof(ImVec2));

	je	SHORT $LN25@AddConvexP
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\malloc.h

; 103  :         return _MarkedSize > _Size ? _MarkedSize : 0;

	cmp	edx, ecx
	sbb	eax, eax
	and	eax, ecx

; 102  :         size_t _MarkedSize = _Size + _ALLOCA_S_MARKER_SIZE;

	lea	ecx, DWORD PTR [edx+8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 628  :         ImVec2* temp_normals = (ImVec2*)_malloca(points_count * sizeof(ImVec2));

	cmp	eax, 1024				; 00000400H
	ja	SHORT $LN23@AddConvexP
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\malloc.h

; 103  :         return _MarkedSize > _Size ? _MarkedSize : 0;

	cmp	edx, ecx
	sbb	eax, eax
	and	eax, ecx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 628  :         ImVec2* temp_normals = (ImVec2*)_malloca(points_count * sizeof(ImVec2));

	call	__alloca_probe_16
	mov	eax, esp
	mov	DWORD PTR _temp_normals$1$[ebp], eax
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\malloc.h

; 92   :         if (_Ptr)

	test	eax, eax
	je	SHORT $LN26@AddConvexP

; 93   :         {
; 94   :             *((unsigned int*)_Ptr) = _Marker;

	mov	DWORD PTR [eax], 52428			; 0000ccccH

; 95   :             _Ptr = (char*)_Ptr + _ALLOCA_S_MARKER_SIZE;

	add	eax, 8
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 628  :         ImVec2* temp_normals = (ImVec2*)_malloca(points_count * sizeof(ImVec2));

	jmp	SHORT $LN94@AddConvexP
$LN23@AddConvexP:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\malloc.h

; 103  :         return _MarkedSize > _Size ? _MarkedSize : 0;

	cmp	edx, ecx
	sbb	eax, eax
	and	eax, ecx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 628  :         ImVec2* temp_normals = (ImVec2*)_malloca(points_count * sizeof(ImVec2));

	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR _temp_normals$1$[ebp], eax
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\malloc.h

; 92   :         if (_Ptr)

	test	eax, eax
	je	SHORT $LN26@AddConvexP

; 93   :         {
; 94   :             *((unsigned int*)_Ptr) = _Marker;

	mov	DWORD PTR [eax], 56797			; 0000ddddH

; 95   :             _Ptr = (char*)_Ptr + _ALLOCA_S_MARKER_SIZE;

	add	eax, 8
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 628  :         ImVec2* temp_normals = (ImVec2*)_malloca(points_count * sizeof(ImVec2));

	jmp	SHORT $LN94@AddConvexP
$LN25@AddConvexP:
	xor	eax, eax
$LN94@AddConvexP:
	mov	DWORD PTR _temp_normals$1$[ebp], eax
$LN26@AddConvexP:

; 629  :         for (int i0 = points_count-1, i1 = 0; i1 < points_count; i0 = i1++)

	movss	xmm4, DWORD PTR __real@3f800000
	lea	ecx, DWORD PTR [edi-1]
	mov	edx, DWORD PTR _points$[ebp]
	mov	DWORD PTR _i0$1$[ebp], ecx
	test	edi, edi
	jle	$LN6@AddConvexP
	movss	xmm5, DWORD PTR __xmm@80000000800000008000000080000000
	xorps	xmm6, xmm6
	shl	ecx, 3
	xor	esi, esi
$LL7@AddConvexP:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm1, DWORD PTR [edx+esi*8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 629  :         for (int i0 = points_count-1, i1 = 0; i1 < points_count; i0 = i1++)

	lea	edi, DWORD PTR [esi*8]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm2, DWORD PTR [edx+esi*8+4]
	subss	xmm1, DWORD PTR [ecx+edx]
	subss	xmm2, DWORD PTR [ecx+edx+4]

; 139  : static inline float  ImInvLength(const ImVec2& lhs, float fail_value)           { float d = lhs.x*lhs.x + lhs.y*lhs.y; if (d > 0.0f) return 1.0f / sqrtf(d); return fail_value; }

	movaps	xmm0, xmm1
	movaps	xmm3, xmm2
	mulss	xmm0, xmm1
	mulss	xmm3, xmm2
	addss	xmm3, xmm0
	comiss	xmm3, xmm6
	jbe	SHORT $LN46@AddConvexP
	xorps	xmm0, xmm0
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 746  :         return (float)sqrt(_X);

	sqrtss	xmm0, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 139  : static inline float  ImInvLength(const ImVec2& lhs, float fail_value)           { float d = lhs.x*lhs.x + lhs.y*lhs.y; if (d > 0.0f) return 1.0f / sqrtf(d); return fail_value; }

	movaps	xmm3, xmm4
	divss	xmm3, xmm0
	jmp	SHORT $LN45@AddConvexP
$LN46@AddConvexP:
	movaps	xmm3, xmm4
$LN45@AddConvexP:

; 120  : static inline ImVec2& operator*=(ImVec2& lhs, const float rhs)                  { lhs.x *= rhs; lhs.y *= rhs; return lhs; }

	mulss	xmm1, xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 629  :         for (int i0 = points_count-1, i1 = 0; i1 < points_count; i0 = i1++)

	inc	esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 120  : static inline ImVec2& operator*=(ImVec2& lhs, const float rhs)                  { lhs.x *= rhs; lhs.y *= rhs; return lhs; }

	mulss	xmm2, xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 636  :             temp_normals[i0].y = -diff.x;

	xorps	xmm1, xmm5
	movss	DWORD PTR [ecx+eax+4], xmm1
	movss	DWORD PTR [ecx+eax], xmm2
	mov	ecx, edi
	mov	edi, DWORD PTR _points_count$[ebp]
	cmp	esi, edi
	jl	SHORT $LL7@AddConvexP
	mov	esi, DWORD PTR _this$1$[ebp]
$LN6@AddConvexP:

; 637  :         }
; 638  : 
; 639  :         for (int i0 = points_count-1, i1 = 0; i1 < points_count; i0 = i1++)

	xor	ecx, ecx
	mov	DWORD PTR _i1$1$[ebp], ecx
	test	edi, edi
	jle	$LN9@AddConvexP
	movss	xmm5, DWORD PTR __real@3f000000
	movss	xmm7, DWORD PTR __real@358637bd
	movss	xmm6, DWORD PTR __real@42c80000
	npad	1
$LL10@AddConvexP:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	mov	edi, DWORD PTR _i0$1$[ebp]
	movss	xmm1, DWORD PTR [eax+ecx*8]
	movss	xmm2, DWORD PTR [eax+ecx*8+4]
	addss	xmm1, DWORD PTR [eax+edi*8]
	addss	xmm2, DWORD PTR [eax+edi*8+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 646  :             if (dmr2 > 0.000001f)

	mov	edi, DWORD PTR _points_count$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	mulss	xmm1, xmm5
	mulss	xmm2, xmm5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 645  :             float dmr2 = dm.x*dm.x + dm.y*dm.y;

	movaps	xmm3, xmm1
	mulss	xmm3, xmm1
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	addss	xmm3, xmm0

; 646  :             if (dmr2 > 0.000001f)

	comiss	xmm3, xmm7
	jbe	SHORT $LN20@AddConvexP

; 647  :             {
; 648  :                 float scale = 1.0f / dmr2;

	movaps	xmm0, xmm4
	divss	xmm0, xmm3
	minss	xmm0, xmm6
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 120  : static inline ImVec2& operator*=(ImVec2& lhs, const float rhs)                  { lhs.x *= rhs; lhs.y *= rhs; return lhs; }

	mulss	xmm1, xmm0
	mulss	xmm2, xmm0
$LN20@AddConvexP:

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [edx+ecx*8]

; 120  : static inline ImVec2& operator*=(ImVec2& lhs, const float rhs)                  { lhs.x *= rhs; lhs.y *= rhs; return lhs; }

	mulss	xmm1, xmm5
	mulss	xmm2, xmm5

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T5[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [edx+ecx*8+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 655  :             _VtxWritePtr[0].pos = (points[i1] - dm); _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;        // Inner

	mov	ecx, DWORD PTR [esi+44]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 655  :             _VtxWritePtr[0].pos = (points[i1] - dm); _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;        // Inner

	mov	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR [ecx], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T5[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 655  :             _VtxWritePtr[0].pos = (points[i1] - dm); _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;        // Inner

	mov	eax, DWORD PTR $T5[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR _uv$1$[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR _uv$2$[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	eax, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	DWORD PTR [eax+16], ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	mov	eax, DWORD PTR _i1$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 656  :             _VtxWritePtr[1].pos = (points[i1] + dm); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer

	mov	ecx, DWORD PTR [esi+44]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [edx+eax*8]
	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [edx+eax*8+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 656  :             _VtxWritePtr[1].pos = (points[i1] + dm); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer

	mov	eax, DWORD PTR $T4[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 656  :             _VtxWritePtr[1].pos = (points[i1] + dm); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer

	mov	DWORD PTR [ecx+20], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 656  :             _VtxWritePtr[1].pos = (points[i1] + dm); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer

	mov	eax, DWORD PTR $T4[ebp+4]
	mov	DWORD PTR [ecx+24], eax
	mov	eax, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR _uv$1$[ebp]
	mov	DWORD PTR [eax+28], ecx
	mov	ecx, DWORD PTR _uv$2$[ebp]
	mov	DWORD PTR [eax+32], ecx
	mov	eax, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR _col_trans$1$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 657  :             _VtxWritePtr += 2;
; 658  : 
; 659  :             // Add indexes for fringes
; 660  :             _IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx+(i1<<1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx+(i0<<1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx+(i0<<1));

	mov	eax, DWORD PTR _i1$1$[ebp]
	mov	ecx, DWORD PTR _vtx_inner_idx$1$[ebp]
	add	DWORD PTR [esi+44], 40			; 00000028H
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	eax, DWORD PTR [esi+48]
	mov	WORD PTR [eax], dx
	mov	eax, DWORD PTR _i0$1$[ebp]
	lea	ecx, DWORD PTR [ecx+eax*2]
	mov	eax, DWORD PTR [esi+48]
	mov	WORD PTR [eax+2], cx
	mov	ecx, DWORD PTR _i0$1$[ebp]
	mov	eax, DWORD PTR [esi+48]
	lea	ecx, DWORD PTR [ecx*2+1]
	add	ecx, DWORD PTR _vtx_inner_idx$1$[ebp]
	mov	WORD PTR [eax+4], cx

; 661  :             _IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx+(i0<<1)); _IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx+(i1<<1)); _IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx+(i1<<1));

	mov	eax, DWORD PTR [esi+48]
	mov	WORD PTR [eax+6], cx
	mov	ecx, DWORD PTR _i1$1$[ebp]
	mov	eax, DWORD PTR [esi+48]
	lea	ecx, DWORD PTR [ecx*2+1]
	add	ecx, DWORD PTR _vtx_inner_idx$1$[ebp]
	mov	WORD PTR [eax+8], cx
	mov	eax, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR _i1$1$[ebp]
	mov	DWORD PTR _i0$1$[ebp], ecx
	inc	ecx
	mov	DWORD PTR _i1$1$[ebp], ecx
	mov	WORD PTR [eax+10], dx

; 662  :             _IdxWritePtr += 6;

	add	DWORD PTR [esi+48], 12			; 0000000cH
	mov	eax, DWORD PTR _temp_normals$1$[ebp]
	mov	edx, DWORD PTR _points$[ebp]
	cmp	ecx, edi
	jl	$LL10@AddConvexP
$LN9@AddConvexP:

; 663  :         }
; 664  :         _VtxCurrentIdx += (ImDrawIdx)vtx_count;

	mov	eax, DWORD PTR _vtx_count$1$[ebp]
	movzx	eax, ax

; 681  :         }
; 682  :         _VtxCurrentIdx += (ImDrawIdx)vtx_count;

	add	DWORD PTR [esi+40], eax

; 683  :     }
; 684  : }

	lea	esp, DWORD PTR [ebp-52]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN18@AddConvexP:

; 665  :     }
; 666  :     else
; 667  :     {
; 668  :         // Non Anti-aliased Fill
; 669  :         const int idx_count = (points_count-2)*3;

	lea	eax, DWORD PTR [edi-2]

; 670  :         const int vtx_count = points_count;
; 671  :         PrimReserve(idx_count, vtx_count);

	push	edi
	lea	eax, DWORD PTR [eax+eax*2]
	push	eax
	call	?PrimReserve@ImDrawList@@QAEXHH@Z	; ImDrawList::PrimReserve

; 672  :         for (int i = 0; i < vtx_count; i++)

	test	edi, edi
	jle	SHORT $LN12@AddConvexP

; 670  :         const int vtx_count = points_count;
; 671  :         PrimReserve(idx_count, vtx_count);

	mov	edx, DWORD PTR _points$[ebp]
	mov	edi, DWORD PTR _points_count$[ebp]
	npad	3
$LL13@AddConvexP:

; 673  :         {
; 674  :             _VtxWritePtr[0].pos = points[i]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;

	mov	ecx, DWORD PTR [esi+44]
	lea	edx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR [edx-8]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx-4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR _uv$1$[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR _uv$2$[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	eax, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 675  :             _VtxWritePtr++;

	add	DWORD PTR [esi+44], 20			; 00000014H
	sub	edi, 1
	jne	SHORT $LL13@AddConvexP
	mov	edi, DWORD PTR _points_count$[ebp]
$LN12@AddConvexP:

; 676  :         }
; 677  :         for (int i = 2; i < points_count; i++)

	mov	edx, 2
	mov	DWORD PTR _i$1$[ebp], edx
	cmp	edi, edx
	jle	SHORT $LN15@AddConvexP
$LL16@AddConvexP:

; 678  :         {
; 679  :             _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx+i-1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx+i);

	mov	ecx, DWORD PTR [esi+48]
	mov	ax, WORD PTR [esi+40]
	movzx	edx, dx
	mov	WORD PTR [ecx], ax
	movzx	ecx, WORD PTR [esi+40]
	mov	eax, DWORD PTR [esi+48]
	dec	cx
	add	cx, dx
	mov	WORD PTR [eax+2], cx
	movzx	ecx, WORD PTR [esi+40]
	mov	eax, DWORD PTR [esi+48]
	add	cx, dx
	mov	edx, DWORD PTR _i$1$[ebp]
	inc	edx
	mov	DWORD PTR _i$1$[ebp], edx
	mov	WORD PTR [eax+4], cx

; 680  :             _IdxWritePtr += 3;

	add	DWORD PTR [esi+48], 6
	cmp	edx, edi
	jl	SHORT $LL16@AddConvexP
$LN15@AddConvexP:

; 681  :         }
; 682  :         _VtxCurrentIdx += (ImDrawIdx)vtx_count;

	movzx	eax, di
	add	DWORD PTR [esi+40], eax
$LN19@AddConvexP:

; 683  :     }
; 684  : }

	lea	esp, DWORD PTR [ebp-52]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?AddConvexPolyFilled@ImDrawList@@QAEXPBUImVec2@@HI_N@Z ENDP ; ImDrawList::AddConvexPolyFilled
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\malloc.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\malloc.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\malloc.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\malloc.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\malloc.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\malloc.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T21 = -80						; size = 8
$T22 = -72						; size = 8
$T23 = -72						; size = 8
$T24 = -72						; size = 8
$T25 = -72						; size = 8
$T26 = -72						; size = 8
$T27 = -72						; size = 8
$T28 = -72						; size = 8
$T29 = -72						; size = 8
$T30 = -72						; size = 8
$T31 = -72						; size = 8
$T32 = -64						; size = 8
$T33 = -64						; size = 8
_vtx_count$1$ = -56					; size = 4
$T34 = -52						; size = 8
$T35 = -52						; size = 8
$T36 = -52						; size = 8
$T37 = -52						; size = 8
_idx2$1$ = -48						; size = 4
tv3299 = -48						; size = 4
tv3252 = -48						; size = 4
tv3123 = -48						; size = 4
$T38 = -44						; size = 8
tv3328 = -40						; size = 4
tv3006 = -40						; size = 4
_points$1$ = -36					; size = 4
tv3274 = -36						; size = 4
_col_trans$1$ = -32					; size = 4
_idx2$1$ = -28						; size = 4
tv3301 = -28						; size = 4
tv3296 = -28						; size = 4
_temp_points$1$ = -24					; size = 4
_uv$2$ = -20						; size = 4
_uv$1$ = -16						; size = 4
_this$1$ = -12						; size = 4
tv3332 = -8						; size = 4
_thick_line$1$ = -1					; size = 1
_points$ = 8						; size = 4
_points_count$ = 12					; size = 4
_col$ = 16						; size = 4
_idx1$1$ = 20						; size = 4
_idx1$1$ = 20						; size = 4
tv3192 = 20						; size = 4
_closed$ = 20						; size = 1
tv3298 = 24						; size = 4
tv3276 = 24						; size = 4
tv3257 = 24						; size = 4
_thickness$ = 24					; size = 4
_temp_normals$1$ = 28					; size = 4
tv3258 = 28						; size = 4
_anti_aliased$ = 28					; size = 1
?AddPolyline@ImDrawList@@QAEXPBUImVec2@@HI_NM1@Z PROC	; ImDrawList::AddPolyline
; _this$ = ecx

; 418  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	esi
	push	edi

; 419  :     if (points_count < 2)

	mov	edi, DWORD PTR _points_count$[ebp]
	mov	esi, ecx
	mov	DWORD PTR _this$1$[ebp], esi
	cmp	edi, 2
	jl	$LN18@AddPolylin

; 420  :         return;
; 421  : 
; 422  :     const ImVec2 uv = GImGui->FontTexUvWhitePixel;
; 423  :     anti_aliased &= GImGui->Style.AntiAliasedLines;
; 424  :     //if (ImGui::GetIO().KeyCtrl) anti_aliased = false; // Debug
; 425  : 
; 426  :     int count = points_count;
; 427  :     if (!closed)
; 428  :         count = points_count-1;
; 429  : 
; 430  :     const bool thick_line = thickness > 1.0f;

	cmp	BYTE PTR _closed$[ebp], 0
	lea	ecx, DWORD PTR [edi-1]
	movss	xmm0, DWORD PTR _thickness$[ebp]
	mov	edx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	cmovne	ecx, edi
	comiss	xmm0, DWORD PTR __real@3f800000
	mov	DWORD PTR tv3332[ebp], ecx
	mov	eax, DWORD PTR [edx+6180]
	mov	DWORD PTR _uv$1$[ebp], eax
	mov	eax, DWORD PTR [edx+6184]
	mov	DWORD PTR _uv$2$[ebp], eax
	mov	al, BYTE PTR _anti_aliased$[ebp]
	seta	BYTE PTR _thick_line$1$[ebp]
	test	BYTE PTR [edx+5440], al

; 431  :     if (anti_aliased)

	je	$LN22@AddPolylin

; 432  :     {
; 433  :         // Anti-aliased stroke
; 434  :         const float AA_SIZE = 1.0f;
; 435  :         const ImU32 col_trans = col & IM_COL32(255,255,255,0);

	mov	eax, DWORD PTR _col$[ebp]
	and	eax, 16777215				; 00ffffffH

; 436  : 
; 437  :         const int idx_count = thick_line ? count*18 : count*12;

	cmp	BYTE PTR _thick_line$1$[ebp], 0
	mov	DWORD PTR _col_trans$1$[ebp], eax
	je	SHORT $LN34@AddPolylin
	lea	eax, DWORD PTR [ecx+ecx*8]
	add	eax, eax

; 438  :         const int vtx_count = thick_line ? points_count*4 : points_count*3;

	lea	ecx, DWORD PTR [edi*4]
	jmp	SHORT $LN265@AddPolylin
$LN34@AddPolylin:

; 436  : 
; 437  :         const int idx_count = thick_line ? count*18 : count*12;

	lea	eax, DWORD PTR [ecx+ecx*2]
	shl	eax, 2

; 438  :         const int vtx_count = thick_line ? points_count*4 : points_count*3;

	lea	ecx, DWORD PTR [edi+edi*2]
$LN265@AddPolylin:

; 439  :         PrimReserve(idx_count, vtx_count);

	push	ecx
	mov	DWORD PTR _vtx_count$1$[ebp], ecx
	mov	ecx, esi
	push	eax
	call	?PrimReserve@ImDrawList@@QAEXHH@Z	; ImDrawList::PrimReserve

; 442  :         ImVec2* temp_normals = (ImVec2*)_malloca(points_count * (thick_line ? 5 : 3) * sizeof(ImVec2));

	xor	edx, edx
	cmp	BYTE PTR _thick_line$1$[ebp], dl
	setne	dl
	lea	edx, DWORD PTR [edx*2+3]
	imul	edx, edi
	shl	edx, 3
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\malloc.h

; 102  :         size_t _MarkedSize = _Size + _ALLOCA_S_MARKER_SIZE;

	lea	ecx, DWORD PTR [edx+8]

; 103  :         return _MarkedSize > _Size ? _MarkedSize : 0;

	cmp	edx, ecx
	sbb	eax, eax
	test	eax, ecx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 442  :         ImVec2* temp_normals = (ImVec2*)_malloca(points_count * (thick_line ? 5 : 3) * sizeof(ImVec2));

	je	SHORT $LN40@AddPolylin
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\malloc.h

; 103  :         return _MarkedSize > _Size ? _MarkedSize : 0;

	cmp	edx, ecx
	sbb	eax, eax
	and	eax, ecx

; 102  :         size_t _MarkedSize = _Size + _ALLOCA_S_MARKER_SIZE;

	lea	ecx, DWORD PTR [edx+8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 442  :         ImVec2* temp_normals = (ImVec2*)_malloca(points_count * (thick_line ? 5 : 3) * sizeof(ImVec2));

	cmp	eax, 1024				; 00000400H
	ja	SHORT $LN38@AddPolylin
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\malloc.h

; 103  :         return _MarkedSize > _Size ? _MarkedSize : 0;

	cmp	edx, ecx
	sbb	eax, eax
	and	eax, ecx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 442  :         ImVec2* temp_normals = (ImVec2*)_malloca(points_count * (thick_line ? 5 : 3) * sizeof(ImVec2));

	call	__alloca_probe_16
	mov	ecx, esp
	mov	DWORD PTR _temp_normals$1$[ebp], ecx
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\malloc.h

; 92   :         if (_Ptr)

	test	ecx, ecx
	je	SHORT $LN41@AddPolylin

; 93   :         {
; 94   :             *((unsigned int*)_Ptr) = _Marker;

	mov	DWORD PTR [ecx], 52428			; 0000ccccH

; 95   :             _Ptr = (char*)_Ptr + _ALLOCA_S_MARKER_SIZE;

	add	ecx, 8
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 442  :         ImVec2* temp_normals = (ImVec2*)_malloca(points_count * (thick_line ? 5 : 3) * sizeof(ImVec2));

	jmp	SHORT $LN266@AddPolylin
$LN38@AddPolylin:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\malloc.h

; 103  :         return _MarkedSize > _Size ? _MarkedSize : 0;

	cmp	edx, ecx
	sbb	eax, eax
	and	eax, ecx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 442  :         ImVec2* temp_normals = (ImVec2*)_malloca(points_count * (thick_line ? 5 : 3) * sizeof(ImVec2));

	push	eax
	call	DWORD PTR __imp__malloc
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR _temp_normals$1$[ebp], ecx
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\malloc.h

; 92   :         if (_Ptr)

	test	ecx, ecx
	je	SHORT $LN41@AddPolylin

; 93   :         {
; 94   :             *((unsigned int*)_Ptr) = _Marker;

	mov	DWORD PTR [ecx], 56797			; 0000ddddH

; 95   :             _Ptr = (char*)_Ptr + _ALLOCA_S_MARKER_SIZE;

	add	ecx, 8
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 442  :         ImVec2* temp_normals = (ImVec2*)_malloca(points_count * (thick_line ? 5 : 3) * sizeof(ImVec2));

	jmp	SHORT $LN266@AddPolylin
$LN40@AddPolylin:
	xor	ecx, ecx
$LN266@AddPolylin:
	mov	DWORD PTR _temp_normals$1$[ebp], ecx
$LN41@AddPolylin:

; 445  :         for (int i1 = 0; i1 < count; i1++)

	cmp	DWORD PTR tv3332[ebp], 0
	lea	edx, DWORD PTR [ecx+edi*8]
	mov	eax, DWORD PTR _points$[ebp]
	movss	xmm4, DWORD PTR __real@3f800000
	mov	DWORD PTR _temp_points$1$[ebp], edx
	mov	DWORD PTR _points$1$[ebp], eax
	jle	$LN3@AddPolylin

; 443  :         ImVec2* temp_points = temp_normals + points_count;

	movss	xmm5, DWORD PTR __xmm@80000000800000008000000080000000
	lea	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR _points$[ebp]
	xorps	xmm6, xmm6
	mov	DWORD PTR tv3301[ebp], eax

; 445  :         for (int i1 = 0; i1 < count; i1++)

	sub	eax, ecx
	mov	DWORD PTR tv3299[ebp], eax
	mov	ecx, 1
	mov	eax, DWORD PTR tv3332[ebp]
	mov	DWORD PTR tv3328[ebp], eax
	npad	3
$LL4@AddPolylin:
	xor	eax, eax
	cmp	ecx, edi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	mov	edi, DWORD PTR tv3301[ebp]
	cmovne	eax, ecx
	movss	xmm1, DWORD PTR [esi+eax*8]
	movss	xmm2, DWORD PTR [esi+eax*8+4]
	mov	eax, DWORD PTR tv3299[ebp]
	subss	xmm1, DWORD PTR [edi]
	subss	xmm2, DWORD PTR [eax+edx]

; 139  : static inline float  ImInvLength(const ImVec2& lhs, float fail_value)           { float d = lhs.x*lhs.x + lhs.y*lhs.y; if (d > 0.0f) return 1.0f / sqrtf(d); return fail_value; }

	movaps	xmm3, xmm1
	mulss	xmm3, xmm1
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	addss	xmm3, xmm0
	comiss	xmm3, xmm6
	jbe	SHORT $LN73@AddPolylin
	xorps	xmm0, xmm0
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 746  :         return (float)sqrt(_X);

	sqrtss	xmm0, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 139  : static inline float  ImInvLength(const ImVec2& lhs, float fail_value)           { float d = lhs.x*lhs.x + lhs.y*lhs.y; if (d > 0.0f) return 1.0f / sqrtf(d); return fail_value; }

	movaps	xmm3, xmm4
	divss	xmm3, xmm0
	jmp	SHORT $LN72@AddPolylin
$LN73@AddPolylin:
	movaps	xmm3, xmm4
$LN72@AddPolylin:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 445  :         for (int i1 = 0; i1 < count; i1++)

	add	DWORD PTR tv3301[ebp], 8
	inc	ecx
	mov	edi, DWORD PTR _points_count$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 120  : static inline ImVec2& operator*=(ImVec2& lhs, const float rhs)                  { lhs.x *= rhs; lhs.y *= rhs; return lhs; }

	mulss	xmm1, xmm3
	mulss	xmm2, xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 451  :             temp_normals[i1].y = -diff.x;

	xorps	xmm1, xmm5
	movss	DWORD PTR [edx], xmm1
	movss	DWORD PTR [edx-4], xmm2
	add	edx, 8
	sub	DWORD PTR tv3328[ebp], 1
	jne	SHORT $LL4@AddPolylin
	mov	esi, DWORD PTR _this$1$[ebp]
	mov	edx, DWORD PTR _temp_points$1$[ebp]
	mov	ecx, DWORD PTR _temp_normals$1$[ebp]
$LN3@AddPolylin:

; 452  :         }
; 453  :         if (!closed)

	mov	al, BYTE PTR _closed$[ebp]
	test	al, al
	jne	SHORT $LN24@AddPolylin

; 454  :             temp_normals[points_count-1] = temp_normals[points_count-2];

	mov	eax, DWORD PTR [ecx+edi*8-16]
	mov	DWORD PTR [edx-8], eax
	mov	eax, DWORD PTR [ecx+edi*8-12]
	mov	DWORD PTR [edx-4], eax
	mov	al, BYTE PTR _closed$[ebp]
$LN24@AddPolylin:

; 455  : 
; 456  :         if (!thick_line)

	cmp	BYTE PTR _thick_line$1$[ebp], 0
	jne	$LN25@AddPolylin

; 457  :         {
; 458  :             if (!closed)

	test	al, al
	jne	$LN27@AddPolylin
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm1, DWORD PTR [ecx+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	mov	eax, DWORD PTR _points$[ebp]
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR [ecx]
	addss	xmm1, DWORD PTR [eax+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T37[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 460  :                 temp_points[0] = points[0] + temp_normals[0] * AA_SIZE;

	mov	eax, DWORD PTR $T37[ebp]
	mov	DWORD PTR [edx], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T37[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 460  :                 temp_points[0] = points[0] + temp_normals[0] * AA_SIZE;

	mov	eax, DWORD PTR $T37[ebp+4]
	mov	DWORD PTR [edx+4], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	mov	eax, DWORD PTR _points$[ebp]
	movss	xmm0, DWORD PTR [eax]
	subss	xmm0, DWORD PTR [ecx]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T36[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [eax+4]
	subss	xmm0, DWORD PTR [ecx+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 461  :                 temp_points[1] = points[0] - temp_normals[0] * AA_SIZE;

	mov	eax, DWORD PTR $T36[ebp]

; 462  :                 temp_points[(points_count-1)*2+0] = points[points_count-1] + temp_normals[points_count-1] * AA_SIZE;

	mov	ecx, edi
	mov	DWORD PTR [edx+8], eax
	add	ecx, ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T36[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 461  :                 temp_points[1] = points[0] - temp_normals[0] * AA_SIZE;

	mov	eax, DWORD PTR $T36[ebp+4]
	mov	DWORD PTR [edx+12], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR [edx-8]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	mov	eax, DWORD PTR _points$[ebp]
	addss	xmm0, DWORD PTR [eax+edi*8-8]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T35[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [eax+edi*8-4]
	addss	xmm0, DWORD PTR [edx-4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 462  :                 temp_points[(points_count-1)*2+0] = points[points_count-1] + temp_normals[points_count-1] * AA_SIZE;

	mov	eax, DWORD PTR $T35[ebp]
	mov	DWORD PTR [edx+ecx*8-16], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T35[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 462  :                 temp_points[(points_count-1)*2+0] = points[points_count-1] + temp_normals[points_count-1] * AA_SIZE;

	mov	eax, DWORD PTR $T35[ebp+4]
	mov	DWORD PTR [edx+ecx*8-12], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	mov	eax, DWORD PTR _points$[ebp]
	movss	xmm0, DWORD PTR [eax+edi*8-8]
	subss	xmm0, DWORD PTR [edx-8]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T34[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [eax+edi*8-4]
	subss	xmm0, DWORD PTR [edx-4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 463  :                 temp_points[(points_count-1)*2+1] = points[points_count-1] - temp_normals[points_count-1] * AA_SIZE;

	mov	eax, DWORD PTR $T34[ebp]
	mov	DWORD PTR [edx+ecx*8-8], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T34[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 463  :                 temp_points[(points_count-1)*2+1] = points[points_count-1] - temp_normals[points_count-1] * AA_SIZE;

	mov	eax, DWORD PTR $T34[ebp+4]
	mov	DWORD PTR [edx+ecx*8-4], eax
	mov	ecx, DWORD PTR _temp_normals$1$[ebp]
$LN27@AddPolylin:

; 468  :             for (int i1 = 0; i1 < count; i1++)

	cmp	DWORD PTR tv3332[ebp], 0
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR _idx1$1$[ebp], eax
	jle	$LN6@AddPolylin

; 464  :             }
; 465  : 
; 466  :             // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
; 467  :             unsigned int idx1 = _VtxCurrentIdx;

	movss	xmm5, DWORD PTR __real@3f000000
	movss	xmm7, DWORD PTR __real@358637bd
	movss	xmm6, DWORD PTR __real@42c80000
	mov	DWORD PTR tv3298[ebp], 1
	mov	DWORD PTR tv3296[ebp], ecx
$LL7@AddPolylin:

; 469  :             {
; 470  :                 const int i2 = (i1+1) == points_count ? 0 : i1+1;
; 471  :                 unsigned int idx2 = (i1+1) == points_count ? _VtxCurrentIdx : idx1+3;

	xor	eax, eax
	cmp	DWORD PTR tv3298[ebp], edi
	cmovne	eax, DWORD PTR tv3298[ebp]
	jne	SHORT $LN46@AddPolylin
	mov	edx, DWORD PTR [esi+40]
	mov	DWORD PTR _idx2$1$[ebp], edx
	mov	edx, DWORD PTR _temp_points$1$[ebp]
	jmp	SHORT $LN47@AddPolylin
$LN46@AddPolylin:
	mov	esi, DWORD PTR _idx1$1$[ebp]
	add	esi, 3
	mov	DWORD PTR _idx2$1$[ebp], esi
$LN47@AddPolylin:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm1, DWORD PTR [ecx+eax*8]
	mov	esi, DWORD PTR tv3296[ebp]
	movss	xmm2, DWORD PTR [ecx+eax*8+4]
	mov	ecx, esi
	addss	xmm1, DWORD PTR [esi]
	addss	xmm2, DWORD PTR [ecx+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 476  :                 if (dmr2 > 0.000001f)

	mov	esi, DWORD PTR _this$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	mulss	xmm1, xmm5
	mulss	xmm2, xmm5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 475  :                 float dmr2 = dm.x*dm.x + dm.y*dm.y;

	movaps	xmm3, xmm1
	mulss	xmm3, xmm1
	movaps	xmm0, xmm2
	mulss	xmm0, xmm2
	addss	xmm3, xmm0

; 476  :                 if (dmr2 > 0.000001f)

	comiss	xmm3, xmm7
	jbe	SHORT $LN28@AddPolylin

; 477  :                 {
; 478  :                     float scale = 1.0f / dmr2;

	movaps	xmm0, xmm4
	divss	xmm0, xmm3
	minss	xmm0, xmm6
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 120  : static inline ImVec2& operator*=(ImVec2& lhs, const float rhs)                  { lhs.x *= rhs; lhs.y *= rhs; return lhs; }

	mulss	xmm1, xmm0
	mulss	xmm2, xmm0
$LN28@AddPolylin:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 483  :                 temp_points[i2*2+0] = points[i2] + dm;

	mov	ecx, DWORD PTR _points$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR [ecx+eax*8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 483  :                 temp_points[i2*2+0] = points[i2] + dm;

	lea	ecx, DWORD PTR [ecx+eax*8]
	inc	DWORD PTR tv3298[ebp]
	shl	eax, 4
	mov	DWORD PTR tv3006[ebp], eax
	mov	edi, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T33[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [ecx+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 483  :                 temp_points[i2*2+0] = points[i2] + dm;

	mov	eax, DWORD PTR $T33[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 483  :                 temp_points[i2*2+0] = points[i2] + dm;

	mov	DWORD PTR [edi+edx], eax
	add	DWORD PTR tv3296[ebp], 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T33[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 483  :                 temp_points[i2*2+0] = points[i2] + dm;

	mov	eax, DWORD PTR $T33[ebp+4]
	mov	DWORD PTR [edi+edx+4], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [ecx]
	subss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T31[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [ecx+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 484  :                 temp_points[i2*2+1] = points[i2] - dm;

	mov	ecx, edi
	mov	eax, DWORD PTR $T31[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 487  :                 _IdxWritePtr[0] = (ImDrawIdx)(idx2+0); _IdxWritePtr[1] = (ImDrawIdx)(idx1+0); _IdxWritePtr[2] = (ImDrawIdx)(idx1+2);

	mov	edi, DWORD PTR _idx2$1$[ebp]
	mov	DWORD PTR [ecx+edx+8], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T31[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 484  :                 temp_points[i2*2+1] = points[i2] - dm;

	mov	eax, DWORD PTR $T31[ebp+4]
	mov	DWORD PTR [ecx+edx+12], eax

; 488  :                 _IdxWritePtr[3] = (ImDrawIdx)(idx1+2); _IdxWritePtr[4] = (ImDrawIdx)(idx2+2); _IdxWritePtr[5] = (ImDrawIdx)(idx2+0);
; 489  :                 _IdxWritePtr[6] = (ImDrawIdx)(idx2+1); _IdxWritePtr[7] = (ImDrawIdx)(idx1+1); _IdxWritePtr[8] = (ImDrawIdx)(idx1+0);

	lea	edx, DWORD PTR [edi+1]
	mov	eax, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR _idx1$1$[ebp]
	mov	WORD PTR [eax], di
	mov	eax, DWORD PTR [esi+48]
	mov	WORD PTR [eax+2], cx
	add	ecx, 2
	mov	eax, DWORD PTR [esi+48]
	mov	WORD PTR [eax+4], cx
	mov	eax, DWORD PTR [esi+48]
	mov	WORD PTR [eax+6], cx
	lea	ecx, DWORD PTR [edi+2]
	mov	eax, DWORD PTR [esi+48]
	mov	WORD PTR [eax+8], cx
	mov	eax, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR _idx1$1$[ebp]
	inc	ecx
	mov	WORD PTR [eax+10], di
	mov	eax, DWORD PTR [esi+48]
	mov	WORD PTR [eax+12], dx
	mov	eax, DWORD PTR [esi+48]
	mov	WORD PTR [eax+14], cx
	mov	eax, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR _idx1$1$[ebp]

; 490  :                 _IdxWritePtr[9] = (ImDrawIdx)(idx1+0); _IdxWritePtr[10]= (ImDrawIdx)(idx2+0); _IdxWritePtr[11]= (ImDrawIdx)(idx2+1);
; 491  :                 _IdxWritePtr += 12;
; 492  : 
; 493  :                 idx1 = idx2;

	mov	DWORD PTR _idx1$1$[ebp], edi
	mov	WORD PTR [eax+16], cx
	mov	eax, DWORD PTR [esi+48]
	mov	WORD PTR [eax+18], cx
	mov	eax, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR _temp_normals$1$[ebp]
	mov	WORD PTR [eax+20], di
	mov	eax, DWORD PTR [esi+48]
	mov	edi, DWORD PTR _points_count$[ebp]
	mov	WORD PTR [eax+22], dx
	add	DWORD PTR [esi+48], 24			; 00000018H
	sub	DWORD PTR tv3332[ebp], 1
	mov	edx, DWORD PTR _temp_points$1$[ebp]
	jne	$LL7@AddPolylin
$LN6@AddPolylin:

; 494  :             }
; 495  : 
; 496  :             // Add vertexes
; 497  :             for (int i = 0; i < points_count; i++)

	test	edi, edi
	jle	$LN15@AddPolylin
	mov	eax, DWORD PTR _points$[ebp]
$LL10@AddPolylin:

; 498  :             {
; 499  :                 _VtxWritePtr[0].pos = points[i];          _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;

	mov	eax, DWORD PTR [eax]
	lea	edx, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _points$1$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR _uv$1$[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR _uv$2$[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	eax, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 500  :                 _VtxWritePtr[1].pos = temp_points[i*2+0]; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;

	mov	ecx, DWORD PTR [esi+44]
	mov	eax, DWORD PTR [edx-16]
	mov	DWORD PTR [ecx+20], eax
	mov	eax, DWORD PTR [edx-12]
	mov	DWORD PTR [ecx+24], eax
	mov	eax, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR _uv$1$[ebp]
	mov	DWORD PTR [eax+28], ecx
	mov	ecx, DWORD PTR _uv$2$[ebp]
	mov	DWORD PTR [eax+32], ecx
	mov	eax, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR _col_trans$1$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 501  :                 _VtxWritePtr[2].pos = temp_points[i*2+1]; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col_trans;

	mov	ecx, DWORD PTR [esi+44]
	mov	eax, DWORD PTR [edx-8]
	mov	DWORD PTR [ecx+40], eax
	mov	eax, DWORD PTR [edx-4]
	mov	DWORD PTR [ecx+44], eax
	mov	eax, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR _uv$1$[ebp]
	mov	DWORD PTR [eax+48], ecx
	mov	ecx, DWORD PTR _uv$2$[ebp]
	mov	DWORD PTR [eax+52], ecx
	mov	eax, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR _col_trans$1$[ebp]
	mov	DWORD PTR [eax+56], ecx
	mov	eax, DWORD PTR _points$1$[ebp]

; 502  :                 _VtxWritePtr += 3;

	add	DWORD PTR [esi+44], 60			; 0000003cH
	add	eax, 8
	mov	DWORD PTR _points$1$[ebp], eax
	sub	edi, 1
	jne	$LL10@AddPolylin

; 563  :             }
; 564  :         }
; 565  :         _VtxCurrentIdx += (ImDrawIdx)vtx_count;

	mov	eax, DWORD PTR _vtx_count$1$[ebp]
	movzx	eax, ax
	add	DWORD PTR [esi+40], eax

; 594  :         }
; 595  :     }
; 596  : }

	lea	esp, DWORD PTR [ebp-88]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$LN25@AddPolylin:

; 503  :             }
; 504  :         }
; 505  :         else
; 506  :         {
; 507  :             const float half_inner_thickness = (thickness - AA_SIZE) * 0.5f;

	movss	xmm1, DWORD PTR __real@3f800000
	movss	xmm5, DWORD PTR _thickness$[ebp]
	movss	xmm6, DWORD PTR __real@3f000000
	subss	xmm5, xmm1
	mulss	xmm5, xmm6

; 508  :             if (!closed)

	test	al, al
	jne	$LN30@AddPolylin
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	mov	eax, DWORD PTR _points$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 510  :                 temp_points[0] = points[0] + temp_normals[0] * (half_inner_thickness + AA_SIZE);

	movaps	xmm3, xmm5
	addss	xmm3, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	movss	xmm1, DWORD PTR [ecx]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [eax]

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	mulss	xmm1, xmm3
	movaps	xmm2, xmm3
	mulss	xmm2, DWORD PTR [ecx+4]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm1
	addss	xmm2, DWORD PTR [eax+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T30[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 510  :                 temp_points[0] = points[0] + temp_normals[0] * (half_inner_thickness + AA_SIZE);

	mov	eax, DWORD PTR $T30[ebp]
	mov	DWORD PTR [edx], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T30[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 510  :                 temp_points[0] = points[0] + temp_normals[0] * (half_inner_thickness + AA_SIZE);

	mov	eax, DWORD PTR $T30[ebp+4]
	mov	DWORD PTR [edx+4], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	movss	xmm1, DWORD PTR [ecx]
	movss	xmm2, DWORD PTR [ecx+4]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	mov	eax, DWORD PTR _points$[ebp]

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	mulss	xmm1, xmm5
	mulss	xmm2, xmm5

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, xmm1
	addss	xmm2, DWORD PTR [eax+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T29[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 511  :                 temp_points[1] = points[0] + temp_normals[0] * (half_inner_thickness);

	mov	eax, DWORD PTR $T29[ebp]
	mov	DWORD PTR [edx+8], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T29[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 511  :                 temp_points[1] = points[0] + temp_normals[0] * (half_inner_thickness);

	mov	eax, DWORD PTR $T29[ebp+4]
	mov	DWORD PTR [edx+12], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	movss	xmm1, DWORD PTR [ecx]

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	mov	eax, DWORD PTR _points$[ebp]

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	movss	xmm2, DWORD PTR [ecx+4]
	mulss	xmm1, xmm5

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [eax]

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	mulss	xmm2, xmm5

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T28[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [eax+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 512  :                 temp_points[2] = points[0] - temp_normals[0] * (half_inner_thickness);

	mov	eax, DWORD PTR $T28[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 512  :                 temp_points[2] = points[0] - temp_normals[0] * (half_inner_thickness);

	mov	DWORD PTR [edx+16], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	movaps	xmm2, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T28[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 512  :                 temp_points[2] = points[0] - temp_normals[0] * (half_inner_thickness);

	mov	eax, DWORD PTR $T28[ebp+4]
	mov	DWORD PTR [edx+20], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	mulss	xmm2, DWORD PTR [ecx+4]
	movss	xmm1, DWORD PTR [ecx]

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	mov	ecx, DWORD PTR _points$[ebp]

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	mulss	xmm1, xmm3

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [ecx]
	subss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T27[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [ecx+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 513  :                 temp_points[3] = points[0] - temp_normals[0] * (half_inner_thickness + AA_SIZE);

	mov	eax, DWORD PTR $T27[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 513  :                 temp_points[3] = points[0] - temp_normals[0] * (half_inner_thickness + AA_SIZE);

	mov	DWORD PTR [edx+24], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T27[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 513  :                 temp_points[3] = points[0] - temp_normals[0] * (half_inner_thickness + AA_SIZE);

	mov	eax, DWORD PTR $T27[ebp+4]
	mov	DWORD PTR [edx+28], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	movss	xmm0, DWORD PTR [edx-8]
	movss	xmm1, DWORD PTR [edx-4]
	mulss	xmm0, xmm3
	mulss	xmm1, xmm3

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, DWORD PTR [ecx+edi*8-8]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T26[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [ecx+edi*8-4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 514  :                 temp_points[(points_count-1)*4+0] = points[points_count-1] + temp_normals[points_count-1] * (half_inner_thickness + AA_SIZE);

	mov	ecx, edi
	mov	eax, DWORD PTR $T26[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 514  :                 temp_points[(points_count-1)*4+0] = points[points_count-1] + temp_normals[points_count-1] * (half_inner_thickness + AA_SIZE);

	shl	ecx, 5
	mov	DWORD PTR [ecx+edx-32], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T26[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 514  :                 temp_points[(points_count-1)*4+0] = points[points_count-1] + temp_normals[points_count-1] * (half_inner_thickness + AA_SIZE);

	mov	eax, DWORD PTR $T26[ebp+4]
	mov	DWORD PTR [ecx+edx-28], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	mov	eax, DWORD PTR _points$[ebp]

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	movss	xmm1, DWORD PTR [edx-8]
	movss	xmm2, DWORD PTR [edx-4]
	mulss	xmm1, xmm5

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [eax+edi*8-8]

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	mulss	xmm2, xmm5

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm1

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	movaps	xmm1, xmm5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T25[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [eax+edi*8-4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 515  :                 temp_points[(points_count-1)*4+1] = points[points_count-1] + temp_normals[points_count-1] * (half_inner_thickness);

	mov	eax, DWORD PTR $T25[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 515  :                 temp_points[(points_count-1)*4+1] = points[points_count-1] + temp_normals[points_count-1] * (half_inner_thickness);

	mov	DWORD PTR [ecx+edx-24], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T25[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 515  :                 temp_points[(points_count-1)*4+1] = points[points_count-1] + temp_normals[points_count-1] * (half_inner_thickness);

	mov	eax, DWORD PTR $T25[ebp+4]
	mov	DWORD PTR [ecx+edx-20], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	mulss	xmm1, DWORD PTR [edx-8]

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	mov	eax, DWORD PTR _points$[ebp]

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	movss	xmm2, DWORD PTR [edx-4]
	mulss	xmm2, xmm5

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [eax+edi*8-8]
	subss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T24[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [eax+edi*8-4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 516  :                 temp_points[(points_count-1)*4+2] = points[points_count-1] - temp_normals[points_count-1] * (half_inner_thickness);

	mov	eax, DWORD PTR $T24[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 516  :                 temp_points[(points_count-1)*4+2] = points[points_count-1] - temp_normals[points_count-1] * (half_inner_thickness);

	mov	DWORD PTR [ecx+edx-16], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T24[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 516  :                 temp_points[(points_count-1)*4+2] = points[points_count-1] - temp_normals[points_count-1] * (half_inner_thickness);

	mov	eax, DWORD PTR $T24[ebp+4]
	mov	DWORD PTR [ecx+edx-12], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	movss	xmm1, DWORD PTR [edx-8]

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	mov	eax, DWORD PTR _points$[ebp]

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	movss	xmm2, DWORD PTR [edx-4]
	mulss	xmm1, xmm3

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [eax+edi*8-8]

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	mulss	xmm2, xmm3

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@3f800000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T23[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [eax+edi*8-4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 517  :                 temp_points[(points_count-1)*4+3] = points[points_count-1] - temp_normals[points_count-1] * (half_inner_thickness + AA_SIZE);

	mov	eax, DWORD PTR $T23[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 517  :                 temp_points[(points_count-1)*4+3] = points[points_count-1] - temp_normals[points_count-1] * (half_inner_thickness + AA_SIZE);

	mov	DWORD PTR [ecx+edx-8], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T23[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 517  :                 temp_points[(points_count-1)*4+3] = points[points_count-1] - temp_normals[points_count-1] * (half_inner_thickness + AA_SIZE);

	mov	eax, DWORD PTR $T23[ebp+4]
	mov	DWORD PTR [ecx+edx-4], eax
	mov	ecx, DWORD PTR _temp_normals$1$[ebp]
$LN30@AddPolylin:

; 522  :             for (int i1 = 0; i1 < count; i1++)

	cmp	DWORD PTR tv3332[ebp], 0
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR _idx1$1$[ebp], eax
	jle	$LN12@AddPolylin

; 518  :             }
; 519  : 
; 520  :             // FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
; 521  :             unsigned int idx1 = _VtxCurrentIdx;

	movaps	xmm7, xmm5
	mov	DWORD PTR tv3276[ebp], 1
	addss	xmm7, xmm1
	mov	DWORD PTR tv3274[ebp], ecx
$LL13@AddPolylin:

; 525  :                 unsigned int idx2 = (i1+1) == points_count ? _VtxCurrentIdx : idx1+4;

	xor	eax, eax
	cmp	DWORD PTR tv3276[ebp], edi
	cmovne	eax, DWORD PTR tv3276[ebp]
	mov	DWORD PTR tv3123[ebp], eax
	jne	SHORT $LN50@AddPolylin
	mov	edi, DWORD PTR [esi+40]
	jmp	SHORT $LN267@AddPolylin
$LN50@AddPolylin:
	mov	edi, DWORD PTR _idx1$1$[ebp]
	add	edi, 4
$LN267@AddPolylin:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	mov	esi, DWORD PTR tv3123[ebp]
	mov	eax, DWORD PTR tv3274[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 525  :                 unsigned int idx2 = (i1+1) == points_count ? _VtxCurrentIdx : idx1+4;

	mov	DWORD PTR _idx2$1$[ebp], edi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm4, DWORD PTR [ecx+esi*8]
	movss	xmm3, DWORD PTR [ecx+esi*8+4]
	addss	xmm4, DWORD PTR [eax]
	addss	xmm3, DWORD PTR [eax+4]

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	mulss	xmm4, xmm6
	mulss	xmm3, xmm6
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 529  :                 float dmr2 = dm.x*dm.x + dm.y*dm.y;

	movaps	xmm2, xmm4
	mulss	xmm2, xmm4
	movaps	xmm0, xmm3
	mulss	xmm0, xmm3
	addss	xmm2, xmm0

; 530  :                 if (dmr2 > 0.000001f)

	comiss	xmm2, DWORD PTR __real@358637bd
	jbe	SHORT $LN31@AddPolylin

; 531  :                 {
; 532  :                     float scale = 1.0f / dmr2;

	divss	xmm1, xmm2
	minss	xmm1, DWORD PTR __real@42c80000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 120  : static inline ImVec2& operator*=(ImVec2& lhs, const float rhs)                  { lhs.x *= rhs; lhs.y *= rhs; return lhs; }

	movaps	xmm0, xmm1
	mulss	xmm3, xmm1
	mulss	xmm4, xmm0
$LN31@AddPolylin:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 538  :                 temp_points[i2*4+0] = points[i2] + dm_out;

	mov	eax, DWORD PTR _points$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	movaps	xmm1, xmm7

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [eax+esi*8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 538  :                 temp_points[i2*4+0] = points[i2] + dm_out;

	lea	ecx, DWORD PTR [eax+esi*8]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	mulss	xmm1, xmm4
	movaps	xmm2, xmm7
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 538  :                 temp_points[i2*4+0] = points[i2] + dm_out;

	shl	esi, 5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	mulss	xmm2, xmm3

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm1

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	mulss	xmm4, xmm5
	mulss	xmm3, xmm5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T22[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [ecx+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 538  :                 temp_points[i2*4+0] = points[i2] + dm_out;

	mov	eax, DWORD PTR $T22[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 538  :                 temp_points[i2*4+0] = points[i2] + dm_out;

	mov	DWORD PTR [esi+edx], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T22[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movaps	xmm0, xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 538  :                 temp_points[i2*4+0] = points[i2] + dm_out;

	mov	eax, DWORD PTR $T22[ebp+4]
	mov	DWORD PTR [esi+edx+4], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, DWORD PTR [ecx]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T32[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [ecx+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 539  :                 temp_points[i2*4+1] = points[i2] + dm_in;

	mov	eax, DWORD PTR $T32[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 539  :                 temp_points[i2*4+1] = points[i2] + dm_in;

	mov	DWORD PTR [esi+edx+8], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T32[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 539  :                 temp_points[i2*4+1] = points[i2] + dm_in;

	mov	eax, DWORD PTR $T32[ebp+4]
	mov	DWORD PTR [esi+edx+12], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [ecx]
	subss	xmm0, xmm4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T38[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [ecx+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 540  :                 temp_points[i2*4+2] = points[i2] - dm_in;

	mov	eax, DWORD PTR $T38[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm0, xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 540  :                 temp_points[i2*4+2] = points[i2] - dm_in;

	mov	DWORD PTR [esi+edx+16], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T38[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 540  :                 temp_points[i2*4+2] = points[i2] - dm_in;

	mov	eax, DWORD PTR $T38[ebp+4]
	mov	DWORD PTR [esi+edx+20], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [ecx]
	subss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T21[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [ecx+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 541  :                 temp_points[i2*4+3] = points[i2] - dm_out;

	mov	eax, DWORD PTR $T21[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 541  :                 temp_points[i2*4+3] = points[i2] - dm_out;

	mov	DWORD PTR [esi+edx+24], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T21[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 541  :                 temp_points[i2*4+3] = points[i2] - dm_out;

	mov	eax, DWORD PTR $T21[ebp+4]
	mov	DWORD PTR [esi+edx+28], eax

; 542  : 
; 543  :                 // Add indexes
; 544  :                 _IdxWritePtr[0]  = (ImDrawIdx)(idx2+1); _IdxWritePtr[1]  = (ImDrawIdx)(idx1+1); _IdxWritePtr[2]  = (ImDrawIdx)(idx1+2);

	lea	esi, DWORD PTR [edi+1]
	mov	edi, DWORD PTR _this$1$[ebp]
	mov	edx, DWORD PTR _idx1$1$[ebp]
	mov	eax, DWORD PTR [edi+48]
	lea	ecx, DWORD PTR [edx+1]
	add	edx, 2
	mov	DWORD PTR tv3252[ebp], edx
	mov	WORD PTR [eax], si
	mov	eax, DWORD PTR [edi+48]
	mov	WORD PTR [eax+2], cx
	mov	eax, DWORD PTR [edi+48]
	mov	WORD PTR [eax+4], dx

; 545  :                 _IdxWritePtr[3]  = (ImDrawIdx)(idx1+2); _IdxWritePtr[4]  = (ImDrawIdx)(idx2+2); _IdxWritePtr[5]  = (ImDrawIdx)(idx2+1);

	mov	eax, DWORD PTR [edi+48]
	mov	edi, DWORD PTR _idx2$1$[ebp]
	add	edi, 2
	mov	WORD PTR [eax+6], dx
	mov	eax, DWORD PTR _this$1$[ebp]

; 546  :                 _IdxWritePtr[6]  = (ImDrawIdx)(idx2+1); _IdxWritePtr[7]  = (ImDrawIdx)(idx1+1); _IdxWritePtr[8]  = (ImDrawIdx)(idx1+0);

	mov	edx, DWORD PTR _idx1$1$[ebp]
	mov	eax, DWORD PTR [eax+48]
	mov	WORD PTR [eax+8], di
	mov	eax, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [eax+48]
	mov	WORD PTR [eax+10], si
	mov	eax, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [eax+48]
	mov	WORD PTR [eax+12], si
	mov	eax, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [eax+48]
	mov	WORD PTR [eax+14], cx
	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [ecx+48]
	mov	WORD PTR [eax+16], dx

; 547  :                 _IdxWritePtr[9]  = (ImDrawIdx)(idx1+0); _IdxWritePtr[10] = (ImDrawIdx)(idx2+0); _IdxWritePtr[11] = (ImDrawIdx)(idx2+1);

	mov	eax, DWORD PTR [ecx+48]
	inc	DWORD PTR tv3276[ebp]
	add	DWORD PTR tv3274[ebp], 8
	movss	xmm1, DWORD PTR __real@3f800000
	mov	WORD PTR [eax+18], dx
	mov	eax, DWORD PTR [ecx+48]
	mov	ecx, DWORD PTR _idx2$1$[ebp]

; 548  :                 _IdxWritePtr[12] = (ImDrawIdx)(idx2+2); _IdxWritePtr[13] = (ImDrawIdx)(idx1+2); _IdxWritePtr[14] = (ImDrawIdx)(idx1+3);

	mov	edx, DWORD PTR tv3252[ebp]
	mov	WORD PTR [eax+20], cx
	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [ecx+48]
	mov	WORD PTR [eax+22], si
	mov	esi, ecx
	mov	ecx, DWORD PTR _idx1$1$[ebp]
	add	ecx, 3
	mov	eax, DWORD PTR [esi+48]
	mov	WORD PTR [eax+24], di
	mov	eax, DWORD PTR [esi+48]
	mov	WORD PTR [eax+26], dx
	mov	eax, DWORD PTR [esi+48]

; 549  :                 _IdxWritePtr[15] = (ImDrawIdx)(idx1+3); _IdxWritePtr[16] = (ImDrawIdx)(idx2+3); _IdxWritePtr[17] = (ImDrawIdx)(idx2+2);

	mov	edx, DWORD PTR _idx2$1$[ebp]

; 550  :                 _IdxWritePtr += 18;
; 551  : 
; 552  :                 idx1 = idx2;

	mov	DWORD PTR _idx1$1$[ebp], edx
	mov	WORD PTR [eax+28], cx
	mov	eax, DWORD PTR [esi+48]
	mov	WORD PTR [eax+30], cx
	lea	ecx, DWORD PTR [edx+3]
	mov	eax, DWORD PTR [esi+48]
	mov	edx, DWORD PTR _temp_points$1$[ebp]
	mov	WORD PTR [eax+32], cx
	mov	eax, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR _temp_normals$1$[ebp]
	mov	WORD PTR [eax+34], di
	add	DWORD PTR [esi+48], 36			; 00000024H
	sub	DWORD PTR tv3332[ebp], 1
	mov	edi, DWORD PTR _points_count$[ebp]
	jne	$LL13@AddPolylin
$LN12@AddPolylin:

; 553  :             }
; 554  : 
; 555  :             // Add vertexes
; 556  :             for (int i = 0; i < points_count; i++)

	test	edi, edi
	jle	$LN15@AddPolylin
	add	edx, 16					; 00000010H
$LL16@AddPolylin:

; 557  :             {
; 558  :                 _VtxWritePtr[0].pos = temp_points[i*4+0]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col_trans;

	mov	ecx, DWORD PTR [esi+44]
	lea	edx, DWORD PTR [edx+32]
	mov	eax, DWORD PTR [edx-48]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx-44]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR _uv$1$[ebp]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR _uv$2$[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	eax, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR _col_trans$1$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 559  :                 _VtxWritePtr[1].pos = temp_points[i*4+1]; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;

	mov	ecx, DWORD PTR [esi+44]
	mov	eax, DWORD PTR [edx-40]
	mov	DWORD PTR [ecx+20], eax
	mov	eax, DWORD PTR [edx-36]
	mov	DWORD PTR [ecx+24], eax
	mov	eax, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR _uv$1$[ebp]
	mov	DWORD PTR [eax+28], ecx
	mov	ecx, DWORD PTR _uv$2$[ebp]
	mov	DWORD PTR [eax+32], ecx
	mov	eax, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 560  :                 _VtxWritePtr[2].pos = temp_points[i*4+2]; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;

	mov	ecx, DWORD PTR [esi+44]
	mov	eax, DWORD PTR [edx-32]
	mov	DWORD PTR [ecx+40], eax
	mov	eax, DWORD PTR [edx-28]
	mov	DWORD PTR [ecx+44], eax
	mov	eax, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR _uv$1$[ebp]
	mov	DWORD PTR [eax+48], ecx
	mov	ecx, DWORD PTR _uv$2$[ebp]
	mov	DWORD PTR [eax+52], ecx
	mov	eax, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	DWORD PTR [eax+56], ecx

; 561  :                 _VtxWritePtr[3].pos = temp_points[i*4+3]; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col_trans;

	mov	ecx, DWORD PTR [esi+44]
	mov	eax, DWORD PTR [edx-24]
	mov	DWORD PTR [ecx+60], eax
	mov	eax, DWORD PTR [edx-20]
	mov	DWORD PTR [ecx+64], eax
	mov	eax, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR _uv$1$[ebp]
	mov	DWORD PTR [eax+68], ecx
	mov	ecx, DWORD PTR _uv$2$[ebp]
	mov	DWORD PTR [eax+72], ecx
	mov	eax, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR _col_trans$1$[ebp]
	mov	DWORD PTR [eax+76], ecx

; 562  :                 _VtxWritePtr += 4;

	add	DWORD PTR [esi+44], 80			; 00000050H
	sub	edi, 1
	jne	$LL16@AddPolylin
$LN15@AddPolylin:

; 563  :             }
; 564  :         }
; 565  :         _VtxCurrentIdx += (ImDrawIdx)vtx_count;

	mov	eax, DWORD PTR _vtx_count$1$[ebp]
	movzx	eax, ax
	add	DWORD PTR [esi+40], eax

; 594  :         }
; 595  :     }
; 596  : }

	lea	esp, DWORD PTR [ebp-88]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$LN22@AddPolylin:

; 566  :     }
; 567  :     else
; 568  :     {
; 569  :         // Non Anti-aliased Stroke
; 570  :         const int idx_count = count*6;
; 571  :         const int vtx_count = count*4;      // FIXME-OPT: Not sharing edges

	lea	eax, DWORD PTR [ecx*4]

; 572  :         PrimReserve(idx_count, vtx_count);

	push	eax
	lea	eax, DWORD PTR [ecx+ecx*2]
	mov	ecx, esi
	add	eax, eax
	push	eax
	call	?PrimReserve@ImDrawList@@QAEXHH@Z	; ImDrawList::PrimReserve

; 573  : 
; 574  :         for (int i1 = 0; i1 < count; i1++)

	cmp	DWORD PTR tv3332[ebp], 0
	jle	$LN18@AddPolylin

; 566  :     }
; 567  :     else
; 568  :     {
; 569  :         // Non Anti-aliased Stroke
; 570  :         const int idx_count = count*6;
; 571  :         const int vtx_count = count*4;      // FIXME-OPT: Not sharing edges

	movss	xmm6, DWORD PTR _thickness$[ebp]
	xorps	xmm2, xmm2
	mov	ecx, DWORD PTR _points$[ebp]
	mulss	xmm6, DWORD PTR __real@3f000000
	mov	edx, DWORD PTR _uv$2$[ebp]
	movss	xmm4, DWORD PTR __real@3f800000
	mov	DWORD PTR tv3258[ebp], 1
	mov	DWORD PTR tv3257[ebp], ecx
	npad	3
$LL19@AddPolylin:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm7, DWORD PTR [ecx]
	xor	eax, eax
	cmp	DWORD PTR tv3258[ebp], edi
	mov	edi, DWORD PTR _points$[ebp]
	cmovne	eax, DWORD PTR tv3258[ebp]
	mov	DWORD PTR tv3192[ebp], eax
	movss	xmm3, DWORD PTR [edi+eax*8]
	movss	xmm5, DWORD PTR [edi+eax*8+4]
	subss	xmm3, xmm7
	subss	xmm5, DWORD PTR [ecx+4]

; 139  : static inline float  ImInvLength(const ImVec2& lhs, float fail_value)           { float d = lhs.x*lhs.x + lhs.y*lhs.y; if (d > 0.0f) return 1.0f / sqrtf(d); return fail_value; }

	movaps	xmm0, xmm3
	movaps	xmm1, xmm5
	mulss	xmm0, xmm3
	mulss	xmm1, xmm5
	addss	xmm1, xmm0
	comiss	xmm1, xmm2
	movaps	xmm2, xmm4
	jbe	SHORT $LN233@AddPolylin
	xorps	xmm0, xmm0
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 746  :         return (float)sqrt(_X);

	sqrtss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 139  : static inline float  ImInvLength(const ImVec2& lhs, float fail_value)           { float d = lhs.x*lhs.x + lhs.y*lhs.y; if (d > 0.0f) return 1.0f / sqrtf(d); return fail_value; }

	divss	xmm2, xmm0
$LN233@AddPolylin:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 584  :             _VtxWritePtr[0].pos.x = p1.x + dy; _VtxWritePtr[0].pos.y = p1.y - dx; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;

	mov	eax, DWORD PTR [esi+44]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 120  : static inline ImVec2& operator*=(ImVec2& lhs, const float rhs)                  { lhs.x *= rhs; lhs.y *= rhs; return lhs; }

	movaps	xmm1, xmm2
	mulss	xmm2, xmm5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 584  :             _VtxWritePtr[0].pos.x = p1.x + dy; _VtxWritePtr[0].pos.y = p1.y - dx; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;

	mov	edi, DWORD PTR _col$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 120  : static inline ImVec2& operator*=(ImVec2& lhs, const float rhs)                  { lhs.x *= rhs; lhs.y *= rhs; return lhs; }

	mulss	xmm1, xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 583  :             const float dy = diff.y * (thickness * 0.5f);

	mulss	xmm2, xmm6
	mulss	xmm1, xmm6

; 584  :             _VtxWritePtr[0].pos.x = p1.x + dy; _VtxWritePtr[0].pos.y = p1.y - dx; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;

	addss	xmm7, xmm2
	movss	DWORD PTR [eax], xmm7
	movss	xmm0, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [esi+44]
	subss	xmm0, xmm1
	mov	ecx, DWORD PTR _uv$1$[ebp]
	movss	DWORD PTR [eax+4], xmm0

; 585  :             _VtxWritePtr[1].pos.x = p2.x + dy; _VtxWritePtr[1].pos.y = p2.y - dx; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;

	movaps	xmm0, xmm2
	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [eax+16], edi
	mov	edi, DWORD PTR _points$[ebp]
	mov	eax, DWORD PTR tv3192[ebp]
	addss	xmm0, DWORD PTR [edi+eax*8]
	mov	eax, DWORD PTR [esi+44]
	movss	DWORD PTR [eax+20], xmm0
	mov	eax, DWORD PTR tv3192[ebp]
	movss	xmm0, DWORD PTR [edi+eax*8+4]
	mov	eax, DWORD PTR [esi+44]
	subss	xmm0, xmm1
	movss	DWORD PTR [eax+24], xmm0
	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR [eax+32], edx
	mov	eax, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR _col$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 586  :             _VtxWritePtr[2].pos.x = p2.x - dy; _VtxWritePtr[2].pos.y = p2.y + dx; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;

	mov	eax, DWORD PTR tv3192[ebp]
	mov	ecx, DWORD PTR _uv$1$[ebp]
	movss	xmm0, DWORD PTR [edi+eax*8]
	mov	eax, DWORD PTR [esi+44]
	subss	xmm0, xmm2
	movss	DWORD PTR [eax+40], xmm0
	movaps	xmm0, xmm1
	mov	eax, DWORD PTR tv3192[ebp]
	addss	xmm0, DWORD PTR [edi+eax*8+4]
	mov	eax, DWORD PTR [esi+44]
	mov	edi, DWORD PTR _col$[ebp]
	movss	DWORD PTR [eax+44], xmm0
	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [eax+48], ecx
	mov	DWORD PTR [eax+52], edx
	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [eax+56], edi

; 587  :             _VtxWritePtr[3].pos.x = p1.x - dy; _VtxWritePtr[3].pos.y = p1.y + dx; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col;

	mov	eax, DWORD PTR tv3257[ebp]
	movss	xmm0, DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+44]
	subss	xmm0, xmm2
	movss	DWORD PTR [eax+60], xmm0
	mov	eax, DWORD PTR tv3257[ebp]
	addss	xmm1, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [esi+44]
	movss	DWORD PTR [eax+64], xmm1
	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [eax+68], ecx
	mov	DWORD PTR [eax+72], edx
	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [eax+76], edi

; 588  :             _VtxWritePtr += 4;
; 589  : 
; 590  :             _IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx+1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx+2);

	mov	ecx, DWORD PTR [esi+48]
	movzx	eax, WORD PTR [esi+40]
	add	DWORD PTR [esi+44], 80			; 00000050H
	mov	WORD PTR [ecx], ax
	movzx	ecx, WORD PTR [esi+40]
	mov	eax, DWORD PTR [esi+48]
	inc	cx
	mov	WORD PTR [eax+2], cx
	movzx	ecx, WORD PTR [esi+40]
	mov	eax, DWORD PTR [esi+48]
	add	cx, 2
	mov	WORD PTR [eax+4], cx

; 591  :             _IdxWritePtr[3] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[4] = (ImDrawIdx)(_VtxCurrentIdx+2); _IdxWritePtr[5] = (ImDrawIdx)(_VtxCurrentIdx+3);

	mov	ecx, DWORD PTR [esi+48]
	movzx	eax, WORD PTR [esi+40]

; 573  : 
; 574  :         for (int i1 = 0; i1 < count; i1++)

	inc	DWORD PTR tv3258[ebp]
	xorps	xmm2, xmm2
	mov	edi, DWORD PTR _points_count$[ebp]

; 591  :             _IdxWritePtr[3] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[4] = (ImDrawIdx)(_VtxCurrentIdx+2); _IdxWritePtr[5] = (ImDrawIdx)(_VtxCurrentIdx+3);

	mov	WORD PTR [ecx+6], ax
	movzx	ecx, WORD PTR [esi+40]
	mov	eax, DWORD PTR [esi+48]
	add	cx, 2
	mov	WORD PTR [eax+8], cx
	movzx	ecx, WORD PTR [esi+40]
	mov	eax, DWORD PTR [esi+48]
	add	cx, 3
	mov	WORD PTR [eax+10], cx
	mov	ecx, DWORD PTR tv3257[ebp]

; 592  :             _IdxWritePtr += 6;

	add	DWORD PTR [esi+48], 12			; 0000000cH
	add	ecx, 8

; 593  :             _VtxCurrentIdx += 4;

	add	DWORD PTR [esi+40], 4
	sub	DWORD PTR tv3332[ebp], 1
	mov	DWORD PTR tv3257[ebp], ecx
	jne	$LL19@AddPolylin
$LN18@AddPolylin:

; 594  :         }
; 595  :     }
; 596  : }

	lea	esp, DWORD PTR [ebp-88]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?AddPolyline@ImDrawList@@QAEXPBUImVec2@@HI_NM1@Z ENDP	; ImDrawList::AddPolyline
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_user_texture_id$ = 8					; size = 4
_a$ = 12						; size = 4
_b$ = 16						; size = 4
_uv0$ = 20						; size = 4
_uv1$ = 24						; size = 4
_col$ = 28						; size = 4
?AddImage@ImDrawList@@QAEXPAXABUImVec2@@111I@Z PROC	; ImDrawList::AddImage
; _this$ = ecx

; 967  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 968  :     if ((col & IM_COL32_A_MASK) == 0)

	test	DWORD PTR _col$[ebp], -16777216		; ff000000H
	push	esi
	mov	esi, ecx
	je	SHORT $LN4@AddImage
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	cmp	DWORD PTR [esi+64], 0
	push	ebx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 972  :     const bool push_texture_id = _TextureIdStack.empty() || user_texture_id != _TextureIdStack.back();

	je	SHORT $LN6@AddImage
	mov	edx, DWORD PTR [esi+64]
	mov	ecx, DWORD PTR [esi+72]
	mov	eax, DWORD PTR _user_texture_id$[ebp]
	cmp	eax, DWORD PTR [ecx+edx*4-4]
	jne	SHORT $LN6@AddImage
	xor	bl, bl
	jmp	SHORT $LN3@AddImage
$LN6@AddImage:

; 973  :     if (push_texture_id)
; 974  :         PushTextureID(user_texture_id);

	lea	eax, DWORD PTR _user_texture_id$[ebp]
	mov	ecx, esi
	push	eax
	mov	bl, 1
	call	?PushTextureID@ImDrawList@@QAEXABQAX@Z	; ImDrawList::PushTextureID
$LN3@AddImage:

; 975  : 
; 976  :     PrimReserve(6, 4);

	push	4
	push	6
	mov	ecx, esi
	call	?PrimReserve@ImDrawList@@QAEXHH@Z	; ImDrawList::PrimReserve

; 977  :     PrimRectUV(a, b, uv0, uv1, col);

	push	DWORD PTR _col$[ebp]
	mov	ecx, esi
	push	DWORD PTR _uv1$[ebp]
	push	DWORD PTR _uv0$[ebp]
	push	DWORD PTR _b$[ebp]
	push	DWORD PTR _a$[ebp]
	call	?PrimRectUV@ImDrawList@@QAEXABUImVec2@@000I@Z ; ImDrawList::PrimRectUV

; 978  : 
; 979  :     if (push_texture_id)

	test	bl, bl
	pop	ebx
	je	SHORT $LN4@AddImage

; 980  :         PopTextureID();

	mov	ecx, esi
	call	?PopTextureID@ImDrawList@@QAEXXZ	; ImDrawList::PopTextureID
$LN4@AddImage:
	pop	esi

; 981  : }

	pop	ebp
	ret	24					; 00000018H
?AddImage@ImDrawList@@QAEXPAXABUImVec2@@111I@Z ENDP	; ImDrawList::AddImage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_clip_rect$ = -20					; size = 16
_this$1$ = -4						; size = 4
_font$ = 8						; size = 4
_font_size$ = 12					; size = 4
_pos$ = 16						; size = 4
_col$ = 20						; size = 4
_text_begin$ = 24					; size = 4
_text_end$ = 28						; size = 4
_wrap_width$ = 32					; size = 4
_cpu_fine_clip_rect$ = 36				; size = 4
?AddText@ImDrawList@@QAEXPBUImFont@@MABUImVec2@@IPBD2MPBUImVec4@@@Z PROC ; ImDrawList::AddText
; _this$ = ecx

; 932  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 933  :     if ((col & IM_COL32_A_MASK) == 0)

	test	DWORD PTR _col$[ebp], -16777216		; ff000000H
	mov	DWORD PTR _this$1$[ebp], ecx
	je	$LN1@AddText

; 934  :         return;
; 935  : 
; 936  :     if (text_end == NULL)

	mov	edx, DWORD PTR _text_end$[ebp]
	push	esi
	mov	esi, DWORD PTR _text_begin$[ebp]
	test	edx, edx
	jne	SHORT $LN3@AddText

; 937  :         text_end = text_begin + strlen(text_begin);

	mov	ecx, esi
	lea	edx, DWORD PTR [ecx+1]
$LL27@AddText:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL27@AddText
	sub	ecx, edx
	lea	edx, DWORD PTR [ecx+esi]
$LN3@AddText:

; 938  :     if (text_begin == text_end)

	cmp	esi, edx
	je	$LN28@AddText

; 939  :         return;
; 940  : 
; 941  :     // Note: This is one of the few instance of breaking the encapsulation of ImDrawList, as we pull this from ImGui state, but it is just SO useful.
; 942  :     // Might just move Font/FontSize to ImDrawList?
; 943  :     if (font == NULL)

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	edi
	mov	edi, DWORD PTR _font$[ebp]
	test	edi, edi
	jne	SHORT $LN5@AddText

; 944  :         font = GImGui->Font;

	mov	edi, DWORD PTR [ecx+6168]
$LN5@AddText:

; 945  :     if (font_size == 0.0f)

	movss	xmm2, DWORD PTR _font_size$[ebp]
	ucomiss	xmm2, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN6@AddText

; 946  :         font_size = GImGui->FontSize;

	movss	xmm2, DWORD PTR [ecx+6172]
$LN6@AddText:

; 947  : 
; 948  :     IM_ASSERT(font->ContainerAtlas->TexID == _TextureIdStack.back());  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.
; 949  : 
; 950  :     ImVec4 clip_rect = _ClipRectStack.back();

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	eax, DWORD PTR [eax+60]
	shl	ecx, 4
	movups	xmm0, XMMWORD PTR [ecx+eax-16]

; 951  :     if (cpu_fine_clip_rect)

	mov	eax, DWORD PTR _cpu_fine_clip_rect$[ebp]
	movups	XMMWORD PTR _clip_rect$[ebp], xmm0
	test	eax, eax
	je	SHORT $LN29@AddText

; 952  :     {
; 953  :         clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);

	movss	xmm1, DWORD PTR [eax]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 128  : static inline float  ImMax(float lhs, float rhs)                                { return lhs >= rhs ? lhs : rhs; }

	movss	xmm0, DWORD PTR _clip_rect$[ebp]
	comiss	xmm0, xmm1
	jae	SHORT $LN14@AddText
	movss	DWORD PTR _clip_rect$[ebp], xmm1
$LN14@AddText:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 954  :         clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);

	movss	xmm1, DWORD PTR [eax+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 128  : static inline float  ImMax(float lhs, float rhs)                                { return lhs >= rhs ? lhs : rhs; }

	movss	xmm0, DWORD PTR _clip_rect$[ebp+4]
	comiss	xmm0, xmm1
	jae	SHORT $LN18@AddText
	movss	DWORD PTR _clip_rect$[ebp+4], xmm1
$LN18@AddText:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 955  :         clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);

	movss	xmm0, DWORD PTR [eax+8]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 127  : static inline float  ImMin(float lhs, float rhs)                                { return lhs < rhs ? lhs : rhs; }

	comiss	xmm0, DWORD PTR _clip_rect$[ebp+8]
	ja	SHORT $LN22@AddText
	movss	DWORD PTR _clip_rect$[ebp+8], xmm0
$LN22@AddText:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 956  :         clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);

	movss	xmm0, DWORD PTR [eax+12]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 127  : static inline float  ImMin(float lhs, float rhs)                                { return lhs < rhs ? lhs : rhs; }

	comiss	xmm0, DWORD PTR _clip_rect$[ebp+12]
	ja	SHORT $LN26@AddText
	movss	DWORD PTR _clip_rect$[ebp+12], xmm0
$LN26@AddText:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 958  :     font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);

	test	eax, eax
$LN29@AddText:
	movss	xmm0, DWORD PTR _wrap_width$[ebp]
	setne	al
	movzx	eax, al
	push	eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _clip_rect$[ebp]
	push	edx
	push	esi
	push	eax
	push	DWORD PTR _col$[ebp]
	mov	eax, DWORD PTR _pos$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$1$[ebp]
	movss	DWORD PTR [esp], xmm2
	push	ecx
	mov	ecx, edi
	call	?RenderText@ImFont@@QBEXPAUImDrawList@@MUImVec2@@IABUImVec4@@PBD3M_N@Z ; ImFont::RenderText
	pop	edi
$LN28@AddText:
	pop	esi
$LN1@AddText:

; 959  : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?AddText@ImDrawList@@QAEXPBUImFont@@MABUImVec2@@IPBD2MPBUImVec4@@@Z ENDP ; ImDrawList::AddText
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_pos$ = 8						; size = 4
_col$ = 12						; size = 4
_text_begin$ = 16					; size = 4
_text_end$ = 20						; size = 4
?AddText@ImDrawList@@QAEXABUImVec2@@IPBD1@Z PROC	; ImDrawList::AddText
; _this$ = ecx

; 962  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 963  :     AddText(GImGui->Font, GImGui->FontSize, pos, col, text_begin, text_end);

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	0
	push	ecx
	mov	DWORD PTR [esp], 0
	push	DWORD PTR _text_end$[ebp]
	movss	xmm0, DWORD PTR [eax+6172]
	push	DWORD PTR _text_begin$[ebp]
	push	DWORD PTR _col$[ebp]
	push	DWORD PTR _pos$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR [eax+6168]
	call	?AddText@ImDrawList@@QAEXPBUImFont@@MABUImVec2@@IPBD2MPBUImVec4@@@Z ; ImDrawList::AddText

; 964  : }

	pop	ebp
	ret	16					; 00000010H
?AddText@ImDrawList@@QAEXABUImVec2@@IPBD1@Z ENDP	; ImDrawList::AddText
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_centre$ = 8						; size = 4
_radius$ = 12						; size = 4
_col$ = 16						; size = 4
_num_segments$ = 20					; size = 4
?AddCircleFilled@ImDrawList@@QAEXABUImVec2@@MIH@Z PROC	; ImDrawList::AddCircleFilled
; _this$ = ecx

; 912  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 913  :     if ((col & IM_COL32_A_MASK) == 0)

	test	DWORD PTR _col$[ebp], -16777216		; ff000000H
	push	ebx
	mov	ebx, ecx
	je	SHORT $LN1@AddCircleF

; 914  :         return;
; 915  : 
; 916  :     const float a_max = IM_PI*2.0f * ((float)num_segments - 1.0f) / (float)num_segments;

	mov	eax, DWORD PTR _num_segments$[ebp]
	push	esi

; 917  :     PathArcTo(centre, radius, 0.0f, a_max, num_segments);

	push	eax
	sub	esp, 12					; 0000000cH
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	movaps	xmm0, xmm1
	subss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR __real@40c90fdb
	divss	xmm0, xmm1
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _radius$[ebp]
	mov	DWORD PTR [esp+4], 0
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _centre$[ebp]
	call	?PathArcTo@ImDrawList@@QAEXABUImVec2@@MMMH@Z ; ImDrawList::PathArcTo
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1272 :     inline    void  PathFill(ImU32 col)                                         { AddConvexPolyFilled(_Path.Data, _Path.Size, col, true); PathClear(); }

	push	1
	push	DWORD PTR _col$[ebp]
	mov	ecx, ebx
	push	DWORD PTR [ebx+76]
	push	DWORD PTR [ebx+84]
	call	?AddConvexPolyFilled@ImDrawList@@QAEXPBUImVec2@@HI_N@Z ; ImDrawList::AddConvexPolyFilled

; 1269 :     inline    void  PathClear()                                                 { _Path.resize(0); }

	push	0
	lea	ecx, DWORD PTR [ebx+76]
	call	?resize@?$ImVector@UImVec2@@@@QAEXH@Z	; ImVector<ImVec2>::resize
	pop	esi
$LN1@AddCircleF:
	pop	ebx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 919  : }

	pop	ebp
	ret	16					; 00000010H
?AddCircleFilled@ImDrawList@@QAEXABUImVec2@@MIH@Z ENDP	; ImDrawList::AddCircleFilled
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_centre$ = 8						; size = 4
_radius$ = 12						; size = 4
_col$ = 16						; size = 4
_num_segments$ = 20					; size = 4
_thickness$ = 24					; size = 4
?AddCircle@ImDrawList@@QAEXABUImVec2@@MIHM@Z PROC	; ImDrawList::AddCircle
; _this$ = ecx

; 902  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 903  :     if ((col & IM_COL32_A_MASK) == 0)

	test	DWORD PTR _col$[ebp], -16777216		; ff000000H
	push	ebx
	mov	ebx, ecx
	je	SHORT $LN1@AddCircle

; 904  :         return;
; 905  : 
; 906  :     const float a_max = IM_PI*2.0f * ((float)num_segments - 1.0f) / (float)num_segments;

	mov	eax, DWORD PTR _num_segments$[ebp]
	push	esi

; 907  :     PathArcTo(centre, radius-0.5f, 0.0f, a_max, num_segments);

	push	eax
	sub	esp, 12					; 0000000cH
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	movaps	xmm0, xmm1
	subss	xmm0, DWORD PTR __real@3f800000
	mulss	xmm0, DWORD PTR __real@40c90fdb
	divss	xmm0, xmm1
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _radius$[ebp]
	subss	xmm0, DWORD PTR __real@3f000000
	mov	DWORD PTR [esp+4], 0
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _centre$[ebp]
	call	?PathArcTo@ImDrawList@@QAEXABUImVec2@@MMMH@Z ; ImDrawList::PathArcTo
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1273 :     inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f)  { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness, true); PathClear(); }

	movss	xmm0, DWORD PTR _thickness$[ebp]
	push	1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, ebx
	push	1
	push	DWORD PTR _col$[ebp]
	push	DWORD PTR [ebx+76]
	push	DWORD PTR [ebx+84]
	call	?AddPolyline@ImDrawList@@QAEXPBUImVec2@@HI_NM1@Z ; ImDrawList::AddPolyline

; 1269 :     inline    void  PathClear()                                                 { _Path.resize(0); }

	push	0
	lea	ecx, DWORD PTR [ebx+76]
	call	?resize@?$ImVector@UImVec2@@@@QAEXH@Z	; ImVector<ImVec2>::resize
	pop	esi
$LN1@AddCircle:
	pop	ebx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 909  : }

	pop	ebp
	ret	20					; 00000014H
?AddCircle@ImDrawList@@QAEXABUImVec2@@MIHM@Z ENDP	; ImDrawList::AddCircle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
_col$ = 20						; size = 4
?AddTriangleFilled@ImDrawList@@QAEXABUImVec2@@00I@Z PROC ; ImDrawList::AddTriangleFilled
; _this$ = ecx

; 891  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 892  :     if ((col & IM_COL32_A_MASK) == 0)

	test	DWORD PTR _col$[ebp], -16777216		; ff000000H
	push	ebx
	mov	ebx, ecx
	je	SHORT $LN1@AddTriangl
	push	esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1270 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	push	DWORD PTR _a$[ebp]
	lea	ecx, DWORD PTR [ebx+76]
	call	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back
	push	DWORD PTR _b$[ebp]
	lea	ecx, DWORD PTR [ebx+76]
	call	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back
	push	DWORD PTR _c$[ebp]
	lea	ecx, DWORD PTR [ebx+76]
	call	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back

; 1272 :     inline    void  PathFill(ImU32 col)                                         { AddConvexPolyFilled(_Path.Data, _Path.Size, col, true); PathClear(); }

	push	1
	push	DWORD PTR _col$[ebp]
	mov	ecx, ebx
	push	DWORD PTR [ebx+76]
	push	DWORD PTR [ebx+84]
	call	?AddConvexPolyFilled@ImDrawList@@QAEXPBUImVec2@@HI_N@Z ; ImDrawList::AddConvexPolyFilled

; 1269 :     inline    void  PathClear()                                                 { _Path.resize(0); }

	push	0
	lea	ecx, DWORD PTR [ebx+76]
	call	?resize@?$ImVector@UImVec2@@@@QAEXH@Z	; ImVector<ImVec2>::resize
	pop	esi
$LN1@AddTriangl:
	pop	ebx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 899  : }

	pop	ebp
	ret	16					; 00000010H
?AddTriangleFilled@ImDrawList@@QAEXABUImVec2@@00I@Z ENDP ; ImDrawList::AddTriangleFilled
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
_col$ = 20						; size = 4
_thickness$ = 24					; size = 4
?AddTriangle@ImDrawList@@QAEXABUImVec2@@00IM@Z PROC	; ImDrawList::AddTriangle
; _this$ = ecx

; 880  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 881  :     if ((col & IM_COL32_A_MASK) == 0)

	test	DWORD PTR _col$[ebp], -16777216		; ff000000H
	push	ebx
	mov	ebx, ecx
	je	SHORT $LN1@AddTriangl
	push	esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1270 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	push	DWORD PTR _a$[ebp]
	lea	ecx, DWORD PTR [ebx+76]
	call	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back
	push	DWORD PTR _b$[ebp]
	lea	ecx, DWORD PTR [ebx+76]
	call	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back
	push	DWORD PTR _c$[ebp]
	lea	ecx, DWORD PTR [ebx+76]
	call	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back

; 1273 :     inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f)  { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness, true); PathClear(); }

	movss	xmm0, DWORD PTR _thickness$[ebp]
	push	1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, ebx
	push	1
	push	DWORD PTR _col$[ebp]
	push	DWORD PTR [ebx+76]
	push	DWORD PTR [ebx+84]
	call	?AddPolyline@ImDrawList@@QAEXPBUImVec2@@HI_NM1@Z ; ImDrawList::AddPolyline

; 1269 :     inline    void  PathClear()                                                 { _Path.resize(0); }

	push	0
	lea	ecx, DWORD PTR [ebx+76]
	call	?resize@?$ImVector@UImVec2@@@@QAEXH@Z	; ImVector<ImVec2>::resize
	pop	esi
$LN1@AddTriangl:
	pop	ebx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 888  : }

	pop	ebp
	ret	20					; 00000014H
?AddTriangle@ImDrawList@@QAEXABUImVec2@@00IM@Z ENDP	; ImDrawList::AddTriangle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
_d$ = 20						; size = 4
_col$ = 24						; size = 4
?AddQuadFilled@ImDrawList@@QAEXABUImVec2@@000I@Z PROC	; ImDrawList::AddQuadFilled
; _this$ = ecx

; 868  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 869  :     if ((col & IM_COL32_A_MASK) == 0)

	test	DWORD PTR _col$[ebp], -16777216		; ff000000H
	push	ebx
	mov	ebx, ecx
	je	SHORT $LN1@AddQuadFil
	push	esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1270 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	push	DWORD PTR _a$[ebp]
	lea	ecx, DWORD PTR [ebx+76]
	call	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back
	push	DWORD PTR _b$[ebp]
	lea	ecx, DWORD PTR [ebx+76]
	call	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back
	push	DWORD PTR _c$[ebp]
	lea	ecx, DWORD PTR [ebx+76]
	call	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back
	push	DWORD PTR _d$[ebp]
	lea	ecx, DWORD PTR [ebx+76]
	call	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back

; 1272 :     inline    void  PathFill(ImU32 col)                                         { AddConvexPolyFilled(_Path.Data, _Path.Size, col, true); PathClear(); }

	push	1
	push	DWORD PTR _col$[ebp]
	mov	ecx, ebx
	push	DWORD PTR [ebx+76]
	push	DWORD PTR [ebx+84]
	call	?AddConvexPolyFilled@ImDrawList@@QAEXPBUImVec2@@HI_N@Z ; ImDrawList::AddConvexPolyFilled

; 1269 :     inline    void  PathClear()                                                 { _Path.resize(0); }

	push	0
	lea	ecx, DWORD PTR [ebx+76]
	call	?resize@?$ImVector@UImVec2@@@@QAEXH@Z	; ImVector<ImVec2>::resize
	pop	esi
$LN1@AddQuadFil:
	pop	ebx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 877  : }

	pop	ebp
	ret	20					; 00000014H
?AddQuadFilled@ImDrawList@@QAEXABUImVec2@@000I@Z ENDP	; ImDrawList::AddQuadFilled
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_c$ = 16						; size = 4
_d$ = 20						; size = 4
_col$ = 24						; size = 4
_thickness$ = 28					; size = 4
?AddQuad@ImDrawList@@QAEXABUImVec2@@000IM@Z PROC	; ImDrawList::AddQuad
; _this$ = ecx

; 856  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 857  :     if ((col & IM_COL32_A_MASK) == 0)

	test	DWORD PTR _col$[ebp], -16777216		; ff000000H
	push	ebx
	mov	ebx, ecx
	je	SHORT $LN1@AddQuad
	push	esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1270 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	push	DWORD PTR _a$[ebp]
	lea	ecx, DWORD PTR [ebx+76]
	call	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back
	push	DWORD PTR _b$[ebp]
	lea	ecx, DWORD PTR [ebx+76]
	call	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back
	push	DWORD PTR _c$[ebp]
	lea	ecx, DWORD PTR [ebx+76]
	call	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back
	push	DWORD PTR _d$[ebp]
	lea	ecx, DWORD PTR [ebx+76]
	call	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back

; 1273 :     inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f)  { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness, true); PathClear(); }

	movss	xmm0, DWORD PTR _thickness$[ebp]
	push	1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, ebx
	push	1
	push	DWORD PTR _col$[ebp]
	push	DWORD PTR [ebx+76]
	push	DWORD PTR [ebx+84]
	call	?AddPolyline@ImDrawList@@QAEXPBUImVec2@@HI_NM1@Z ; ImDrawList::AddPolyline

; 1269 :     inline    void  PathClear()                                                 { _Path.resize(0); }

	push	0
	lea	ecx, DWORD PTR [ebx+76]
	call	?resize@?$ImVector@UImVec2@@@@QAEXH@Z	; ImVector<ImVec2>::resize
	pop	esi
$LN1@AddQuad:
	pop	ebx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 865  : }

	pop	ebp
	ret	24					; 00000018H
?AddQuad@ImDrawList@@QAEXABUImVec2@@000IM@Z ENDP	; ImDrawList::AddQuad
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 8
$T2 = -12						; size = 8
_this$1$ = -4						; size = 4
_a$ = 8							; size = 4
_c$ = 12						; size = 4
_col_upr_left$ = 16					; size = 4
_col_upr_right$ = 20					; size = 4
_col_bot_right$ = 24					; size = 4
_col_bot_left$ = 28					; size = 4
?AddRectFilledMultiColor@ImDrawList@@QAEXABUImVec2@@0IIII@Z PROC ; ImDrawList::AddRectFilledMultiColor
; _this$ = ecx

; 841  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 842  :     if (((col_upr_left | col_upr_right | col_bot_right | col_bot_left) & IM_COL32_A_MASK) == 0)

	mov	eax, DWORD PTR _col_upr_left$[ebp]
	or	eax, DWORD PTR _col_upr_right$[ebp]
	or	eax, DWORD PTR _col_bot_right$[ebp]
	or	eax, DWORD PTR _col_bot_left$[ebp]
	mov	DWORD PTR _this$1$[ebp], ecx
	test	eax, -16777216				; ff000000H
	je	$LN1@AddRectFil

; 843  :         return;
; 844  : 
; 845  :     const ImVec2 uv = GImGui->FontTexUvWhitePixel;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR [eax+6180]
	mov	ebx, DWORD PTR [eax+6184]

; 846  :     PrimReserve(6, 4);

	push	4
	push	6
	call	?PrimReserve@ImDrawList@@QAEXHH@Z	; ImDrawList::PrimReserve
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1299 :     inline    void  PrimWriteIdx(ImDrawIdx idx)                                 { *_IdxWritePtr = idx; _IdxWritePtr++; }

	mov	edx, DWORD PTR _this$1$[ebp]

; 1298 :     inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col){ _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }

	mov	esi, DWORD PTR _a$[ebp]

; 1299 :     inline    void  PrimWriteIdx(ImDrawIdx idx)                                 { *_IdxWritePtr = idx; _IdxWritePtr++; }

	mov	ecx, DWORD PTR [edx+48]
	movzx	eax, WORD PTR [edx+40]
	mov	WORD PTR [ecx], ax
	add	DWORD PTR [edx+48], 2
	mov	ecx, DWORD PTR [edx+48]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 847  :     PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+1)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+2));

	movzx	eax, WORD PTR [edx+40]
	inc	ax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1299 :     inline    void  PrimWriteIdx(ImDrawIdx idx)                                 { *_IdxWritePtr = idx; _IdxWritePtr++; }

	mov	WORD PTR [ecx], ax
	add	DWORD PTR [edx+48], 2
	mov	ecx, DWORD PTR [edx+48]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 847  :     PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+1)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+2));

	movzx	eax, WORD PTR [edx+40]
	add	ax, 2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1299 :     inline    void  PrimWriteIdx(ImDrawIdx idx)                                 { *_IdxWritePtr = idx; _IdxWritePtr++; }

	mov	WORD PTR [ecx], ax
	add	DWORD PTR [edx+48], 2
	mov	ecx, DWORD PTR [edx+48]
	movzx	eax, WORD PTR [edx+40]
	mov	WORD PTR [ecx], ax
	add	DWORD PTR [edx+48], 2
	mov	ecx, DWORD PTR [edx+48]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 848  :     PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+2)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+3));

	movzx	eax, WORD PTR [edx+40]
	add	ax, 2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1299 :     inline    void  PrimWriteIdx(ImDrawIdx idx)                                 { *_IdxWritePtr = idx; _IdxWritePtr++; }

	mov	WORD PTR [ecx], ax
	add	DWORD PTR [edx+48], 2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 848  :     PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+2)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx+3));

	movzx	eax, WORD PTR [edx+40]
	mov	ecx, DWORD PTR [edx+48]
	add	ax, 3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1299 :     inline    void  PrimWriteIdx(ImDrawIdx idx)                                 { *_IdxWritePtr = idx; _IdxWritePtr++; }

	mov	WORD PTR [ecx], ax
	add	DWORD PTR [edx+48], 2

; 1298 :     inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col){ _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }

	mov	ecx, DWORD PTR [edx+44]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _col_upr_left$[ebp]
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], ebx
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [eax+16], ecx
	add	DWORD PTR [edx+44], 20			; 00000014H
	inc	DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [edx+44]

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	edx, DWORD PTR _c$[ebp]
	movss	xmm0, DWORD PTR [edx]
	movss	DWORD PTR $T2[ebp], xmm0
	movss	xmm0, DWORD PTR [esi+4]

; 1298 :     inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col){ _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }

	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR [ecx], eax

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp+4], xmm0

; 1298 :     inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col){ _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }

	mov	eax, DWORD PTR $T2[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], ebx
	mov	eax, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR _col_upr_right$[ebp]
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR _this$1$[ebp]
	add	DWORD PTR [eax+44], 20			; 00000014H
	mov	ecx, DWORD PTR [eax+44]
	inc	DWORD PTR [eax+40]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], ebx
	mov	eax, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR _col_bot_right$[ebp]
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR _this$1$[ebp]
	add	DWORD PTR [eax+44], 20			; 00000014H
	inc	DWORD PTR [eax+40]
	mov	ecx, DWORD PTR [eax+44]

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR [esi]
	movss	DWORD PTR $T1[ebp], xmm0
	movss	xmm0, DWORD PTR [edx+4]

; 1298 :     inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col){ _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }

	mov	eax, DWORD PTR $T1[ebp]
	mov	edx, DWORD PTR _col_bot_left$[ebp]
	mov	DWORD PTR [ecx], eax

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm0

; 1298 :     inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col){ _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }

	mov	eax, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], ebx
	mov	eax, DWORD PTR [ecx+44]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR [eax+16], edx
	add	DWORD PTR [ecx+44], 20			; 00000014H
	inc	DWORD PTR [ecx+40]
$LN1@AddRectFil:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 853  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?AddRectFilledMultiColor@ImDrawList@@QAEXABUImVec2@@0IIII@Z ENDP ; ImDrawList::AddRectFilledMultiColor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_col$ = 16						; size = 4
_rounding$ = 20						; size = 4
_rounding_corners_flags$ = 24				; size = 4
?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z PROC	; ImDrawList::AddRectFilled
; _this$ = ecx

; 825  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx

; 826  :     if ((col & IM_COL32_A_MASK) == 0)

	mov	ebx, DWORD PTR _col$[ebp]
	push	edi
	mov	edi, ecx
	test	ebx, -16777216				; ff000000H
	je	SHORT $LN4@AddRectFil

; 827  :         return;
; 828  :     if (rounding > 0.0f)

	movss	xmm0, DWORD PTR _rounding$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN3@AddRectFil

; 829  :     {
; 830  :         PathRect(a, b, rounding, rounding_corners_flags);

	push	esi
	push	DWORD PTR _rounding_corners_flags$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _b$[ebp]
	push	DWORD PTR _a$[ebp]
	call	?PathRect@ImDrawList@@QAEXABUImVec2@@0MH@Z ; ImDrawList::PathRect
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1272 :     inline    void  PathFill(ImU32 col)                                         { AddConvexPolyFilled(_Path.Data, _Path.Size, col, true); PathClear(); }

	push	1
	push	ebx
	push	DWORD PTR [edi+76]
	mov	ecx, edi
	push	DWORD PTR [edi+84]
	call	?AddConvexPolyFilled@ImDrawList@@QAEXPBUImVec2@@HI_N@Z ; ImDrawList::AddConvexPolyFilled

; 1269 :     inline    void  PathClear()                                                 { _Path.resize(0); }

	push	0
	lea	ecx, DWORD PTR [edi+76]
	call	?resize@?$ImVector@UImVec2@@@@QAEXH@Z	; ImVector<ImVec2>::resize
	pop	esi
	pop	edi
	pop	ebx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 838  : }

	pop	ebp
	ret	20					; 00000014H
$LN3@AddRectFil:

; 831  :         PathFill(col);
; 832  :     }
; 833  :     else
; 834  :     {
; 835  :         PrimReserve(6, 4);

	push	4
	push	6
	call	?PrimReserve@ImDrawList@@QAEXHH@Z	; ImDrawList::PrimReserve

; 836  :         PrimRect(a, b, col);

	push	ebx
	push	DWORD PTR _b$[ebp]
	mov	ecx, edi
	push	DWORD PTR _a$[ebp]
	call	?PrimRect@ImDrawList@@QAEXABUImVec2@@0I@Z ; ImDrawList::PrimRect
$LN4@AddRectFil:
	pop	edi
	pop	ebx

; 838  : }

	pop	ebp
	ret	20					; 00000014H
?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ENDP	; ImDrawList::AddRectFilled
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T1 = -16						; size = 8
$T2 = -8						; size = 8
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_col$ = 16						; size = 4
_rounding$ = 20						; size = 4
_rounding_corners_flags$ = 24				; size = 4
_thickness$ = 28					; size = 4
?AddRect@ImDrawList@@QAEXABUImVec2@@0IMHM@Z PROC	; ImDrawList::AddRect
; _this$ = ecx

; 817  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 818  :     if ((col & IM_COL32_A_MASK) == 0)

	test	DWORD PTR _col$[ebp], -16777216		; ff000000H
	push	ebx
	mov	ebx, ecx
	je	$LN1@AddRect
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	mov	eax, DWORD PTR _b$[ebp]
	movss	xmm1, DWORD PTR __real@3f000000
	push	esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 820  :     PathRect(a + ImVec2(0.5f,0.5f), b - ImVec2(0.5f,0.5f), rounding, rounding_corners_flags);

	push	DWORD PTR _rounding_corners_flags$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [eax]
	subss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 820  :     PathRect(a + ImVec2(0.5f,0.5f), b - ImVec2(0.5f,0.5f), rounding, rounding_corners_flags);

	push	ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [eax+4]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	mov	eax, DWORD PTR _a$[ebp]

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [eax+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 820  :     PathRect(a + ImVec2(0.5f,0.5f), b - ImVec2(0.5f,0.5f), rounding, rounding_corners_flags);

	lea	eax, DWORD PTR $T2[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 820  :     PathRect(a + ImVec2(0.5f,0.5f), b - ImVec2(0.5f,0.5f), rounding, rounding_corners_flags);

	movss	xmm0, DWORD PTR _rounding$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?PathRect@ImDrawList@@QAEXABUImVec2@@0MH@Z ; ImDrawList::PathRect
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1273 :     inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f)  { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness, true); PathClear(); }

	movss	xmm0, DWORD PTR _thickness$[ebp]
	push	1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, ebx
	push	1
	push	DWORD PTR _col$[ebp]
	push	DWORD PTR [ebx+76]
	push	DWORD PTR [ebx+84]
	call	?AddPolyline@ImDrawList@@QAEXPBUImVec2@@HI_NM1@Z ; ImDrawList::AddPolyline

; 1269 :     inline    void  PathClear()                                                 { _Path.resize(0); }

	push	0
	lea	ecx, DWORD PTR [ebx+76]
	call	?resize@?$ImVector@UImVec2@@@@QAEXH@Z	; ImVector<ImVec2>::resize
	pop	esi
$LN1@AddRect:
	pop	ebx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 822  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?AddRect@ImDrawList@@QAEXABUImVec2@@0IMHM@Z ENDP	; ImDrawList::AddRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 8
$T2 = -8						; size = 8
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_col$ = 16						; size = 4
_thickness$ = 20					; size = 4
?AddLine@ImDrawList@@QAEXABUImVec2@@0IM@Z PROC		; ImDrawList::AddLine
; _this$ = ecx

; 807  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 808  :     if ((col & IM_COL32_A_MASK) == 0)

	test	DWORD PTR _col$[ebp], -16777216		; ff000000H
	push	ebx
	mov	ebx, ecx
	je	$LN1@AddLine
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	mov	eax, DWORD PTR _a$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1270 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	lea	ecx, DWORD PTR [ebx+76]
	push	esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR __real@3f000000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [eax+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1270 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	lea	eax, DWORD PTR $T2[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, DWORD PTR __real@3f000000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1270 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	push	eax

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp+4], xmm0

; 1270 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	call	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	mov	eax, DWORD PTR _b$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1270 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	lea	ecx, DWORD PTR [ebx+76]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR __real@3f000000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [eax+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1270 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	lea	eax, DWORD PTR $T1[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, DWORD PTR __real@3f000000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1270 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	push	eax

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm0

; 1270 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	call	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back

; 1273 :     inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f)  { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness, true); PathClear(); }

	movss	xmm0, DWORD PTR _thickness$[ebp]
	push	1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, ebx
	push	0
	push	DWORD PTR _col$[ebp]
	push	DWORD PTR [ebx+76]
	push	DWORD PTR [ebx+84]
	call	?AddPolyline@ImDrawList@@QAEXPBUImVec2@@HI_NM1@Z ; ImDrawList::AddPolyline

; 1269 :     inline    void  PathClear()                                                 { _Path.resize(0); }

	push	0
	lea	ecx, DWORD PTR [ebx+76]
	call	?resize@?$ImVector@UImVec2@@@@QAEXH@Z	; ImVector<ImVec2>::resize
	pop	esi
$LN1@AddLine:
	pop	ebx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 813  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?AddLine@ImDrawList@@QAEXABUImVec2@@0IM@Z ENDP		; ImDrawList::AddLine
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
?PopTextureID@ImDrawList@@QAEXXZ PROC			; ImDrawList::PopTextureID
; _this$ = ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [ecx+64]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 274  :     UpdateTextureID();

	jmp	?UpdateTextureID@ImDrawList@@QAEXXZ	; ImDrawList::UpdateTextureID
?PopTextureID@ImDrawList@@QAEXXZ ENDP			; ImDrawList::PopTextureID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_texture_id$ = 8					; size = 4
?PushTextureID@ImDrawList@@QAEXABQAX@Z PROC		; ImDrawList::PushTextureID
; _this$ = ecx

; 265  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 266  :     _TextureIdStack.push_back(texture_id);

	push	DWORD PTR _texture_id$[ebp]
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+64]
	call	?push_back@?$ImVector@PAX@@QAEXABQAX@Z	; ImVector<void *>::push_back

; 267  :     UpdateTextureID();

	mov	ecx, esi
	call	?UpdateTextureID@ImDrawList@@QAEXXZ	; ImDrawList::UpdateTextureID
	pop	esi

; 268  : }

	pop	ebp
	ret	4
?PushTextureID@ImDrawList@@QAEXABQAX@Z ENDP		; ImDrawList::PushTextureID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
?PopClipRect@ImDrawList@@QAEXXZ PROC			; ImDrawList::PopClipRect
; _this$ = ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [ecx+52]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 261  :     UpdateClipRect();

	jmp	?UpdateClipRect@ImDrawList@@QAEXXZ	; ImDrawList::UpdateClipRect
?PopClipRect@ImDrawList@@QAEXXZ ENDP			; ImDrawList::PopClipRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
$T1 = -16						; size = 8
$T2 = -8						; size = 8
?PushClipRectFullScreen@ImDrawList@@QAEXXZ PROC		; ImDrawList::PushClipRectFullScreen
; _this$ = ecx

; 252  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR ?GNullClipRect@@3UImVec4@@B+8
	movss	DWORD PTR $T2[ebp], xmm0
	movss	xmm0, DWORD PTR ?GNullClipRect@@3UImVec4@@B+12
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 253  :     PushClipRect(ImVec2(GNullClipRect.x, GNullClipRect.y), ImVec2(GNullClipRect.z, GNullClipRect.w));

	push	0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 253  :     PushClipRect(ImVec2(GNullClipRect.x, GNullClipRect.y), ImVec2(GNullClipRect.z, GNullClipRect.w));

	push	DWORD PTR $T2[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR ?GNullClipRect@@3UImVec4@@B
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 253  :     PushClipRect(ImVec2(GNullClipRect.x, GNullClipRect.y), ImVec2(GNullClipRect.z, GNullClipRect.w));

	push	DWORD PTR $T2[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm0
	movss	xmm0, DWORD PTR ?GNullClipRect@@3UImVec4@@B+4
	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 253  :     PushClipRect(ImVec2(GNullClipRect.x, GNullClipRect.y), ImVec2(GNullClipRect.z, GNullClipRect.w));

	push	DWORD PTR $T1[ebp+4]
	push	DWORD PTR $T1[ebp]
	call	?PushClipRect@ImDrawList@@QAEXUImVec2@@0_N@Z ; ImDrawList::PushClipRect

; 254  :     //PushClipRect(GetVisibleRect());   // FIXME-OPT: This would be more correct but we're not supposed to access ImGuiContext from here?
; 255  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PushClipRectFullScreen@ImDrawList@@QAEXXZ ENDP		; ImDrawList::PushClipRectFullScreen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp
_TEXT	SEGMENT
_current$1 = -32					; size = 16
_cr$ = -16						; size = 16
_cr_min$ = 8						; size = 8
_cr_max$ = 16						; size = 8
_intersect_with_current_clip_rect$ = 24			; size = 1
?PushClipRect@ImDrawList@@QAEXUImVec2@@0_N@Z PROC	; ImDrawList::PushClipRect
; _this$ = ecx

; 234  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 236  :     if (intersect_with_current_clip_rect && _ClipRectStack.Size)

	cmp	BYTE PTR _intersect_with_current_clip_rect$[ebp], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 109  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

	movss	xmm1, DWORD PTR _cr_min$[ebp]
	movss	xmm0, DWORD PTR _cr_min$[ebp+4]
	movss	xmm3, DWORD PTR _cr_max$[ebp]
	movss	xmm2, DWORD PTR _cr_max$[ebp+4]
	push	esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 234  : {

	mov	esi, ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 109  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

	movss	DWORD PTR _cr$[ebp], xmm1
	movss	DWORD PTR _cr$[ebp+4], xmm0
	movss	DWORD PTR _cr$[ebp+8], xmm3
	movss	DWORD PTR _cr$[ebp+12], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 236  :     if (intersect_with_current_clip_rect && _ClipRectStack.Size)

	je	SHORT $LN6@PushClipRe
	mov	ecx, DWORD PTR [esi+52]
	test	ecx, ecx
	je	SHORT $LN6@PushClipRe

; 237  :     {
; 238  :         ImVec4 current = _ClipRectStack.Data[_ClipRectStack.Size-1];

	mov	eax, DWORD PTR [esi+60]
	add	ecx, ecx
	movups	xmm4, XMMWORD PTR [eax+ecx*8-16]

; 239  :         if (cr.x < current.x) cr.x = current.x;

	comiss	xmm4, xmm1
	movups	XMMWORD PTR _current$1[ebp], xmm4
	jbe	SHORT $LN3@PushClipRe
	movaps	xmm1, xmm4
	movss	DWORD PTR _cr$[ebp], xmm1
$LN3@PushClipRe:

; 240  :         if (cr.y < current.y) cr.y = current.y;

	movss	xmm4, DWORD PTR _current$1[ebp+4]
	comiss	xmm4, xmm0
	jbe	SHORT $LN4@PushClipRe
	movaps	xmm0, xmm4
	movss	DWORD PTR _cr$[ebp+4], xmm0
$LN4@PushClipRe:

; 241  :         if (cr.z > current.z) cr.z = current.z;

	movss	xmm4, DWORD PTR _current$1[ebp+8]
	comiss	xmm3, xmm4
	jbe	SHORT $LN5@PushClipRe
	movaps	xmm3, xmm4
	movss	DWORD PTR _cr$[ebp+8], xmm3
$LN5@PushClipRe:

; 242  :         if (cr.w > current.w) cr.w = current.w;

	movss	xmm4, DWORD PTR _current$1[ebp+12]
	comiss	xmm2, xmm4
	jbe	SHORT $LN6@PushClipRe
	movaps	xmm2, xmm4
	movss	DWORD PTR _cr$[ebp+12], xmm2
$LN6@PushClipRe:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 128  : static inline float  ImMax(float lhs, float rhs)                                { return lhs >= rhs ? lhs : rhs; }

	comiss	xmm1, xmm3
	jb	SHORT $LN12@PushClipRe
	movss	DWORD PTR _cr$[ebp+8], xmm1
$LN12@PushClipRe:
	comiss	xmm0, xmm2
	jb	SHORT $LN16@PushClipRe
	movss	DWORD PTR _cr$[ebp+12], xmm0
$LN16@PushClipRe:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui_draw.cpp

; 247  :     _ClipRectStack.push_back(cr);

	lea	eax, DWORD PTR _cr$[ebp]
	push	eax
	lea	ecx, DWORD PTR [esi+52]
	call	?push_back@?$ImVector@UImVec4@@@@QAEXABUImVec4@@@Z ; ImVector<ImVec4>::push_back

; 248  :     UpdateClipRect();

	mov	ecx, esi
	call	?UpdateClipRect@ImDrawList@@QAEXXZ	; ImDrawList::UpdateClipRect
	pop	esi

; 249  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?PushClipRect@ImDrawList@@QAEXUImVec2@@0_N@Z ENDP	; ImDrawList::PushClipRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImDrawChannel@@@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UImDrawChannel@@@@QAEXH@Z PROC	; ImVector<ImDrawChannel>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi+edi*2]
	shl	eax, 3
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	shl	ecx, 3
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@UImDrawChannel@@@@QAEXH@Z ENDP	; ImVector<ImDrawChannel>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImDrawChannel@@@@QAEXH@Z
_TEXT	SEGMENT
_new_data$1$ = 8					; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@UImDrawChannel@@@@QAEXH@Z PROC	; ImVector<ImDrawChannel>::resize, COMDAT
; _this$ = ecx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR _new_size$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jle	SHORT $LN12@resize

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@resize
$LN6@resize:
	mov	eax, 8
$LN7@resize:
	push	ebx
	cmp	eax, edi
	mov	ebx, edi
	cmovg	ebx, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	ebx, ecx
	jle	SHORT $LN13@resize

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [ebx+ebx*2]
	shl	eax, 3
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [esi+8]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN10@resize

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	shl	ecx, 3
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@resize:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], ebx
$LN13@resize:
	pop	ebx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
$LN12@resize:
	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?resize@?$ImVector@UImDrawChannel@@@@QAEXH@Z ENDP	; ImVector<ImDrawChannel>::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImDrawChannel@@@@QAEHH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?_grow_capacity@?$ImVector@UImDrawChannel@@@@QAEHH@Z PROC ; ImVector<ImDrawChannel>::_grow_capacity, COMDAT
; _this$ = ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@grow_capac
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _new_size$[ebp]
	sar	ecx, 1
	add	ecx, esi
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
$LN3@grow_capac:
	mov	eax, DWORD PTR _new_size$[ebp]
	mov	ecx, 8
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
?_grow_capacity@?$ImVector@UImDrawChannel@@@@QAEHH@Z ENDP ; ImVector<ImDrawChannel>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImDrawChannel@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$ImVector@UImDrawChannel@@@@QAEXXZ PROC		; ImVector<ImDrawChannel>::clear, COMDAT
; _this$ = ecx

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	npad	2
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN2@clear
	push	eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+8], 0
$LN2@clear:
	pop	esi
	ret	0
?clear@?$ImVector@UImDrawChannel@@@@QAEXXZ ENDP		; ImVector<ImDrawChannel>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImDrawChannel@@@@QAEAAUImDrawChannel@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@UImDrawChannel@@@@QAEAAUImDrawChannel@@H@Z PROC ; ImVector<ImDrawChannel>::operator[], COMDAT
; _this$ = ecx

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [eax+edx*8]
	pop	ebp
	ret	4
??A?$ImVector@UImDrawChannel@@@@QAEAAUImDrawChannel@@H@Z ENDP ; ImVector<ImDrawChannel>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z PROC	; ImVector<ImVec2>::push_back, COMDAT
; _this$ = ecx

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi]
	mov	ecx, DWORD PTR [edi+4]
	cmp	esi, ecx
	jne	SHORT $LN8@push_back
	inc	esi

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, esi
	cmovg	esi, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	esi, ecx
	jle	SHORT $LN8@push_back

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [esi*8]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN10@push_back

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [edi]
	shl	ecx, 3
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@push_back:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [edi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [edi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [edi+4], esi
	pop	ebx
$LN8@push_back:

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	esi, DWORD PTR [edi+8]
	mov	edx, DWORD PTR [edi]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi+edx*8], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+edx*8+4], eax
	inc	DWORD PTR [edi]
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ENDP	; ImVector<ImVec2>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImVec2@@@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UImVec2@@@@QAEXH@Z PROC		; ImVector<ImVec2>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*8]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 3
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@UImVec2@@@@QAEXH@Z ENDP		; ImVector<ImVec2>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImVec2@@@@QAEXH@Z
_TEXT	SEGMENT
_new_data$1$ = 8					; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@UImVec2@@@@QAEXH@Z PROC		; ImVector<ImVec2>::resize, COMDAT
; _this$ = ecx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR _new_size$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jle	SHORT $LN12@resize

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@resize
$LN6@resize:
	mov	eax, 8
$LN7@resize:
	push	ebx
	cmp	eax, edi
	mov	ebx, edi
	cmovg	ebx, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	ebx, ecx
	jle	SHORT $LN13@resize

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [ebx*8]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [esi+8]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN10@resize

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 3
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@resize:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], ebx
$LN13@resize:
	pop	ebx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
$LN12@resize:
	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?resize@?$ImVector@UImVec2@@@@QAEXH@Z ENDP		; ImVector<ImVec2>::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImVec2@@@@QAEHH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?_grow_capacity@?$ImVector@UImVec2@@@@QAEHH@Z PROC	; ImVector<ImVec2>::_grow_capacity, COMDAT
; _this$ = ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@grow_capac
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _new_size$[ebp]
	sar	ecx, 1
	add	ecx, esi
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
$LN3@grow_capac:
	mov	eax, DWORD PTR _new_size$[ebp]
	mov	ecx, 8
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
?_grow_capacity@?$ImVector@UImVec2@@@@QAEHH@Z ENDP	; ImVector<ImVec2>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImVec2@@@@QAEAAUImVec2@@XZ
_TEXT	SEGMENT
?back@?$ImVector@UImVec2@@@@QAEAAUImVec2@@XZ PROC	; ImVector<ImVec2>::back, COMDAT
; _this$ = ecx

; 922  :     inline value_type&          back()                          { IM_ASSERT(Size > 0); return Data[Size-1]; }

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [eax+edx*8]
	add	eax, -8					; fffffff8H
	ret	0
?back@?$ImVector@UImVec2@@@@QAEAAUImVec2@@XZ ENDP	; ImVector<ImVec2>::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImVec2@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$ImVector@UImVec2@@@@QAEXXZ PROC		; ImVector<ImVec2>::clear, COMDAT
; _this$ = ecx

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	npad	2
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN2@clear
	push	eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+8], 0
$LN2@clear:
	pop	esi
	ret	0
?clear@?$ImVector@UImVec2@@@@QAEXXZ ENDP		; ImVector<ImVec2>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@PAX@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$ImVector@PAX@@QAEXXZ PROC			; ImVector<void *>::pop_back, COMDAT
; _this$ = ecx

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [ecx]
	ret	0
?pop_back@?$ImVector@PAX@@QAEXXZ ENDP			; ImVector<void *>::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@PAX@@QAEXABQAX@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?push_back@?$ImVector@PAX@@QAEXABQAX@Z PROC		; ImVector<void *>::push_back, COMDAT
; _this$ = ecx

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jne	SHORT $LN8@push_back
	inc	edi

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, edi
	cmovg	edi, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	edi, ecx
	jle	SHORT $LN8@push_back

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN10@push_back

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@push_back:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN8@push_back:

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR _v$[ebp]
	pop	edi
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+edx*4], eax
	inc	DWORD PTR [esi]
	pop	esi
	pop	ebp
	ret	4
?push_back@?$ImVector@PAX@@QAEXABQAX@Z ENDP		; ImVector<void *>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@PAX@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@PAX@@QAEXH@Z PROC			; ImVector<void *>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@PAX@@QAEXH@Z ENDP			; ImVector<void *>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@PAX@@QAEXH@Z
_TEXT	SEGMENT
_new_data$1$ = 8					; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@PAX@@QAEXH@Z PROC			; ImVector<void *>::resize, COMDAT
; _this$ = ecx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR _new_size$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jle	SHORT $LN12@resize

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@resize
$LN6@resize:
	mov	eax, 8
$LN7@resize:
	push	ebx
	cmp	eax, edi
	mov	ebx, edi
	cmovg	ebx, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	ebx, ecx
	jle	SHORT $LN13@resize

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [ebx*4]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [esi+8]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN10@resize

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@resize:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], ebx
$LN13@resize:
	pop	ebx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
$LN12@resize:
	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?resize@?$ImVector@PAX@@QAEXH@Z ENDP			; ImVector<void *>::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@PAX@@QAEHH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?_grow_capacity@?$ImVector@PAX@@QAEHH@Z PROC		; ImVector<void *>::_grow_capacity, COMDAT
; _this$ = ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@grow_capac
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _new_size$[ebp]
	sar	ecx, 1
	add	ecx, esi
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
$LN3@grow_capac:
	mov	eax, DWORD PTR _new_size$[ebp]
	mov	ecx, 8
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
?_grow_capacity@?$ImVector@PAX@@QAEHH@Z ENDP		; ImVector<void *>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?back@?$ImVector@PAX@@QAEAAPAXXZ
_TEXT	SEGMENT
?back@?$ImVector@PAX@@QAEAAPAXXZ PROC			; ImVector<void *>::back, COMDAT
; _this$ = ecx

; 922  :     inline value_type&          back()                          { IM_ASSERT(Size > 0); return Data[Size-1]; }

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [eax+edx*4]
	add	eax, -4					; fffffffcH
	ret	0
?back@?$ImVector@PAX@@QAEAAPAXXZ ENDP			; ImVector<void *>::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@PAX@@QAEXXZ
_TEXT	SEGMENT
?clear@?$ImVector@PAX@@QAEXXZ PROC			; ImVector<void *>::clear, COMDAT
; _this$ = ecx

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	npad	2
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN2@clear
	push	eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+8], 0
$LN2@clear:
	pop	esi
	ret	0
?clear@?$ImVector@PAX@@QAEXXZ ENDP			; ImVector<void *>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?empty@?$ImVector@PAX@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$ImVector@PAX@@QBE_NXZ PROC			; ImVector<void *>::empty, COMDAT
; _this$ = ecx

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	cmp	DWORD PTR [ecx], 0
	sete	al
	ret	0
?empty@?$ImVector@PAX@@QBE_NXZ ENDP			; ImVector<void *>::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@UImVec4@@@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$ImVector@UImVec4@@@@QAEXXZ PROC		; ImVector<ImVec4>::pop_back, COMDAT
; _this$ = ecx

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [ecx]
	ret	0
?pop_back@?$ImVector@UImVec4@@@@QAEXXZ ENDP		; ImVector<ImVec4>::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImVec4@@@@QAEXABUImVec4@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?push_back@?$ImVector@UImVec4@@@@QAEXABUImVec4@@@Z PROC	; ImVector<ImVec4>::push_back, COMDAT
; _this$ = ecx

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jne	SHORT $LN8@push_back
	inc	edi

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, edi
	cmovg	edi, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	edi, ecx
	jle	SHORT $LN8@push_back

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	mov	eax, edi
	shl	eax, 4
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN10@push_back

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 4
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@push_back:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN8@push_back:

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR _v$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR [esi+8]
	pop	edi
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	inc	DWORD PTR [esi]
	pop	esi
	pop	ebp
	ret	4
?push_back@?$ImVector@UImVec4@@@@QAEXABUImVec4@@@Z ENDP	; ImVector<ImVec4>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImVec4@@@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UImVec4@@@@QAEXH@Z PROC		; ImVector<ImVec4>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	mov	eax, edi
	shl	eax, 4
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 4
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@UImVec4@@@@QAEXH@Z ENDP		; ImVector<ImVec4>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImVec4@@@@QAEXH@Z
_TEXT	SEGMENT
_new_data$1$ = 8					; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@UImVec4@@@@QAEXH@Z PROC		; ImVector<ImVec4>::resize, COMDAT
; _this$ = ecx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR _new_size$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jle	SHORT $LN12@resize

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@resize
$LN6@resize:
	mov	eax, 8
$LN7@resize:
	push	ebx
	cmp	eax, edi
	mov	ebx, edi
	cmovg	ebx, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	ebx, ecx
	jle	SHORT $LN13@resize

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	mov	eax, ebx
	shl	eax, 4
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [esi+8]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN10@resize

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 4
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@resize:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], ebx
$LN13@resize:
	pop	ebx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
$LN12@resize:
	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?resize@?$ImVector@UImVec4@@@@QAEXH@Z ENDP		; ImVector<ImVec4>::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImVec4@@@@QAEHH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?_grow_capacity@?$ImVector@UImVec4@@@@QAEHH@Z PROC	; ImVector<ImVec4>::_grow_capacity, COMDAT
; _this$ = ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@grow_capac
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _new_size$[ebp]
	sar	ecx, 1
	add	ecx, esi
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
$LN3@grow_capac:
	mov	eax, DWORD PTR _new_size$[ebp]
	mov	ecx, 8
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
?_grow_capacity@?$ImVector@UImVec4@@@@QAEHH@Z ENDP	; ImVector<ImVec4>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImVec4@@@@QAEAAUImVec4@@XZ
_TEXT	SEGMENT
?back@?$ImVector@UImVec4@@@@QAEAAUImVec4@@XZ PROC	; ImVector<ImVec4>::back, COMDAT
; _this$ = ecx

; 922  :     inline value_type&          back()                          { IM_ASSERT(Size > 0); return Data[Size-1]; }

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+8]
	shl	edx, 4
	add	eax, -16				; fffffff0H
	add	eax, edx
	ret	0
?back@?$ImVector@UImVec4@@@@QAEAAUImVec4@@XZ ENDP	; ImVector<ImVec4>::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImVec4@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$ImVector@UImVec4@@@@QAEXXZ PROC		; ImVector<ImVec4>::clear, COMDAT
; _this$ = ecx

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	npad	2
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN2@clear
	push	eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+8], 0
$LN2@clear:
	pop	esi
	ret	0
?clear@?$ImVector@UImVec4@@@@QAEXXZ ENDP		; ImVector<ImVec4>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImDrawVert@@@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UImDrawVert@@@@QAEXH@Z PROC		; ImVector<ImDrawVert>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi+edi*4]
	shl	eax, 2
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	shl	ecx, 2
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@UImDrawVert@@@@QAEXH@Z ENDP		; ImVector<ImDrawVert>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImDrawVert@@@@QAEXH@Z
_TEXT	SEGMENT
_new_data$1$ = 8					; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@UImDrawVert@@@@QAEXH@Z PROC		; ImVector<ImDrawVert>::resize, COMDAT
; _this$ = ecx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR _new_size$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jle	SHORT $LN12@resize

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@resize
$LN6@resize:
	mov	eax, 8
$LN7@resize:
	push	ebx
	cmp	eax, edi
	mov	ebx, edi
	cmovg	ebx, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	ebx, ecx
	jle	SHORT $LN13@resize

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [ebx+ebx*4]
	shl	eax, 2
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [esi+8]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN10@resize

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	shl	ecx, 2
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@resize:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], ebx
$LN13@resize:
	pop	ebx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
$LN12@resize:
	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?resize@?$ImVector@UImDrawVert@@@@QAEXH@Z ENDP		; ImVector<ImDrawVert>::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImDrawVert@@@@QAEHH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?_grow_capacity@?$ImVector@UImDrawVert@@@@QAEHH@Z PROC	; ImVector<ImDrawVert>::_grow_capacity, COMDAT
; _this$ = ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@grow_capac
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _new_size$[ebp]
	sar	ecx, 1
	add	ecx, esi
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
$LN3@grow_capac:
	mov	eax, DWORD PTR _new_size$[ebp]
	mov	ecx, 8
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
?_grow_capacity@?$ImVector@UImDrawVert@@@@QAEHH@Z ENDP	; ImVector<ImDrawVert>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?swap@?$ImVector@UImDrawVert@@@@QAEXAAV1@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
?swap@?$ImVector@UImDrawVert@@@@QAEXAAV1@@Z PROC	; ImVector<ImDrawVert>::swap, COMDAT
; _this$ = ecx

; 924  :     inline void                 swap(ImVector<T>& rhs)          { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; value_type* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _rhs$[ebp]
	push	edi
	mov	edi, ecx
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [edi], edx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [edi+4], edx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [edi+8], ecx
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?swap@?$ImVector@UImDrawVert@@@@QAEXAAV1@@Z ENDP	; ImVector<ImDrawVert>::swap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImDrawVert@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$ImVector@UImDrawVert@@@@QAEXXZ PROC		; ImVector<ImDrawVert>::clear, COMDAT
; _this$ = ecx

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	npad	2
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN2@clear
	push	eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+8], 0
$LN2@clear:
	pop	esi
	ret	0
?clear@?$ImVector@UImDrawVert@@@@QAEXXZ ENDP		; ImVector<ImDrawVert>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImDrawVert@@@@QAEAAUImDrawVert@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@UImDrawVert@@@@QAEAAUImDrawVert@@H@Z PROC	; ImVector<ImDrawVert>::operator[], COMDAT
; _this$ = ecx

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [eax+edx*4]
	pop	ebp
	ret	4
??A?$ImVector@UImDrawVert@@@@QAEAAUImDrawVert@@H@Z ENDP	; ImVector<ImDrawVert>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImDrawVert@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@UImDrawVert@@@@QAE@XZ PROC		; ImVector<ImDrawVert>::~ImVector<ImDrawVert>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@UImDrawVert@@@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@UImDrawVert@@@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@UImDrawVert@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@UImDrawVert@@@@QAE@XZ ENDP		; ImVector<ImDrawVert>::~ImVector<ImDrawVert>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImDrawVert@@@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@UImDrawVert@@@@QAE@XZ PROC		; ImVector<ImDrawVert>::ImVector<ImDrawVert>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@UImDrawVert@@@@QAE@XZ ENDP		; ImVector<ImDrawVert>::ImVector<ImDrawVert>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0ImDrawChannel@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ImDrawChannel@@QAE@XZ PROC				; ImDrawChannel::ImDrawChannel, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+20], 0
	mov	esp, ebp
	pop	ebp
	ret	0
??0ImDrawChannel@@QAE@XZ ENDP				; ImDrawChannel::ImDrawChannel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@G@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@G@@QAEXH@Z PROC			; ImVector<unsigned short>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi+edi]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	add	ecx, ecx
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@G@@QAEXH@Z ENDP			; ImVector<unsigned short>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@G@@QAEXH@Z
_TEXT	SEGMENT
_new_data$1$ = 8					; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@G@@QAEXH@Z PROC			; ImVector<unsigned short>::resize, COMDAT
; _this$ = ecx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR _new_size$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jle	SHORT $LN12@resize

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@resize
$LN6@resize:
	mov	eax, 8
$LN7@resize:
	push	ebx
	cmp	eax, edi
	mov	ebx, edi
	cmovg	ebx, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	ebx, ecx
	jle	SHORT $LN13@resize

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [ebx+ebx]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [esi+8]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN10@resize

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	add	ecx, ecx
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@resize:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], ebx
$LN13@resize:
	pop	ebx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
$LN12@resize:
	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?resize@?$ImVector@G@@QAEXH@Z ENDP			; ImVector<unsigned short>::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@G@@QAEHH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?_grow_capacity@?$ImVector@G@@QAEHH@Z PROC		; ImVector<unsigned short>::_grow_capacity, COMDAT
; _this$ = ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@grow_capac
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _new_size$[ebp]
	sar	ecx, 1
	add	ecx, esi
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
$LN3@grow_capac:
	mov	eax, DWORD PTR _new_size$[ebp]
	mov	ecx, 8
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
?_grow_capacity@?$ImVector@G@@QAEHH@Z ENDP		; ImVector<unsigned short>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@G@@QAEXXZ
_TEXT	SEGMENT
?clear@?$ImVector@G@@QAEXXZ PROC			; ImVector<unsigned short>::clear, COMDAT
; _this$ = ecx

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	npad	2
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN2@clear
	push	eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+8], 0
$LN2@clear:
	pop	esi
	ret	0
?clear@?$ImVector@G@@QAEXXZ ENDP			; ImVector<unsigned short>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@G@@QBEABGH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@G@@QBEABGH@Z PROC				; ImVector<unsigned short>::operator[], COMDAT
; _this$ = ecx

; 913  :     inline const value_type&    operator[](int i) const         { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+eax*2]
	pop	ebp
	ret	4
??A?$ImVector@G@@QBEABGH@Z ENDP				; ImVector<unsigned short>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@G@@QAEAAGH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@G@@QAEAAGH@Z PROC				; ImVector<unsigned short>::operator[], COMDAT
; _this$ = ecx

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+eax*2]
	pop	ebp
	ret	4
??A?$ImVector@G@@QAEAAGH@Z ENDP				; ImVector<unsigned short>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?empty@?$ImVector@G@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$ImVector@G@@QBE_NXZ PROC			; ImVector<unsigned short>::empty, COMDAT
; _this$ = ecx

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	cmp	DWORD PTR [ecx], 0
	sete	al
	ret	0
?empty@?$ImVector@G@@QBE_NXZ ENDP			; ImVector<unsigned short>::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@G@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@G@@QAE@XZ PROC				; ImVector<unsigned short>::~ImVector<unsigned short>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@G@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@G@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@G@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@G@@QAE@XZ ENDP				; ImVector<unsigned short>::~ImVector<unsigned short>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@G@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@G@@QAE@XZ PROC				; ImVector<unsigned short>::ImVector<unsigned short>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@G@@QAE@XZ ENDP				; ImVector<unsigned short>::ImVector<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@UImDrawCmd@@@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$ImVector@UImDrawCmd@@@@QAEXXZ PROC		; ImVector<ImDrawCmd>::pop_back, COMDAT
; _this$ = ecx

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [ecx]
	ret	0
?pop_back@?$ImVector@UImDrawCmd@@@@QAEXXZ ENDP		; ImVector<ImDrawCmd>::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImDrawCmd@@@@QAEXABUImDrawCmd@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?push_back@?$ImVector@UImDrawCmd@@@@QAEXABUImDrawCmd@@@Z PROC ; ImVector<ImDrawCmd>::push_back, COMDAT
; _this$ = ecx

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jne	SHORT $LN8@push_back
	inc	edi

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, edi
	cmovg	edi, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	edi, ecx
	jle	SHORT $LN8@push_back

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	mov	eax, edi
	shl	eax, 5
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN10@push_back

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 5
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@push_back:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN8@push_back:

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR _v$[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR [esi+8]
	pop	edi
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movups	xmm0, XMMWORD PTR [eax+16]
	movups	XMMWORD PTR [ecx+16], xmm0
	inc	DWORD PTR [esi]
	pop	esi
	pop	ebp
	ret	4
?push_back@?$ImVector@UImDrawCmd@@@@QAEXABUImDrawCmd@@@Z ENDP ; ImVector<ImDrawCmd>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImDrawCmd@@@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UImDrawCmd@@@@QAEXH@Z PROC		; ImVector<ImDrawCmd>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	mov	eax, edi
	shl	eax, 5
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 5
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@UImDrawCmd@@@@QAEXH@Z ENDP		; ImVector<ImDrawCmd>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImDrawCmd@@@@QAEXH@Z
_TEXT	SEGMENT
_new_data$1$ = 8					; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@UImDrawCmd@@@@QAEXH@Z PROC		; ImVector<ImDrawCmd>::resize, COMDAT
; _this$ = ecx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR _new_size$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jle	SHORT $LN12@resize

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@resize
$LN6@resize:
	mov	eax, 8
$LN7@resize:
	push	ebx
	cmp	eax, edi
	mov	ebx, edi
	cmovg	ebx, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	ebx, ecx
	jle	SHORT $LN13@resize

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	mov	eax, ebx
	shl	eax, 5
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [esi+8]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN10@resize

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 5
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@resize:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], ebx
$LN13@resize:
	pop	ebx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
$LN12@resize:
	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?resize@?$ImVector@UImDrawCmd@@@@QAEXH@Z ENDP		; ImVector<ImDrawCmd>::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImDrawCmd@@@@QAEHH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?_grow_capacity@?$ImVector@UImDrawCmd@@@@QAEHH@Z PROC	; ImVector<ImDrawCmd>::_grow_capacity, COMDAT
; _this$ = ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@grow_capac
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _new_size$[ebp]
	sar	ecx, 1
	add	ecx, esi
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
$LN3@grow_capac:
	mov	eax, DWORD PTR _new_size$[ebp]
	mov	ecx, 8
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
?_grow_capacity@?$ImVector@UImDrawCmd@@@@QAEHH@Z ENDP	; ImVector<ImDrawCmd>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImDrawCmd@@@@QAEAAUImDrawCmd@@XZ
_TEXT	SEGMENT
?back@?$ImVector@UImDrawCmd@@@@QAEAAUImDrawCmd@@XZ PROC	; ImVector<ImDrawCmd>::back, COMDAT
; _this$ = ecx

; 922  :     inline value_type&          back()                          { IM_ASSERT(Size > 0); return Data[Size-1]; }

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+8]
	shl	edx, 5
	add	eax, -32				; ffffffe0H
	add	eax, edx
	ret	0
?back@?$ImVector@UImDrawCmd@@@@QAEAAUImDrawCmd@@XZ ENDP	; ImVector<ImDrawCmd>::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImDrawCmd@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$ImVector@UImDrawCmd@@@@QAEXXZ PROC		; ImVector<ImDrawCmd>::clear, COMDAT
; _this$ = ecx

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	npad	2
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN2@clear
	push	eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+8], 0
$LN2@clear:
	pop	esi
	ret	0
?clear@?$ImVector@UImDrawCmd@@@@QAEXXZ ENDP		; ImVector<ImDrawCmd>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImDrawCmd@@@@QAEAAUImDrawCmd@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@UImDrawCmd@@@@QAEAAUImDrawCmd@@H@Z PROC	; ImVector<ImDrawCmd>::operator[], COMDAT
; _this$ = ecx

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR [ecx+8]
	pop	ebp
	ret	4
??A?$ImVector@UImDrawCmd@@@@QAEAAUImDrawCmd@@H@Z ENDP	; ImVector<ImDrawCmd>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImDrawCmd@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@UImDrawCmd@@@@QAE@XZ PROC			; ImVector<ImDrawCmd>::~ImVector<ImDrawCmd>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@UImDrawCmd@@@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@UImDrawCmd@@@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@UImDrawCmd@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@UImDrawCmd@@@@QAE@XZ ENDP			; ImVector<ImDrawCmd>::~ImVector<ImDrawCmd>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImDrawCmd@@@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@UImDrawCmd@@@@QAE@XZ PROC			; ImVector<ImDrawCmd>::ImVector<ImDrawCmd>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@UImDrawCmd@@@@QAE@XZ ENDP			; ImVector<ImDrawCmd>::ImVector<ImDrawCmd>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0ImDrawCmd@@QAE@XZ
_TEXT	SEGMENT
??0ImDrawCmd@@QAE@XZ PROC				; ImDrawCmd::ImDrawCmd, COMDAT
; _this$ = ecx

; 108  :     ImVec4() { x = y = z = w = 0.0f; }

	mov	DWORD PTR [ecx+16], 0

; 1186 :     ImDrawCmd() { ElemCount = 0; ClipRect.x = ClipRect.y = -8192.0f; ClipRect.z = ClipRect.w = +8192.0f; TextureId = NULL; UserCallback = NULL; UserCallbackData = NULL; }

	mov	eax, ecx

; 108  :     ImVec4() { x = y = z = w = 0.0f; }

	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+4], 0

; 1186 :     ImDrawCmd() { ElemCount = 0; ClipRect.x = ClipRect.y = -8192.0f; ClipRect.z = ClipRect.w = +8192.0f; TextureId = NULL; UserCallback = NULL; UserCallbackData = NULL; }

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], -973078528		; c6000000H
	mov	DWORD PTR [ecx+4], -973078528		; c6000000H
	mov	DWORD PTR [ecx+16], 1174405120		; 46000000H
	mov	DWORD PTR [ecx+12], 1174405120		; 46000000H
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0
	ret	0
??0ImDrawCmd@@QAE@XZ ENDP				; ImDrawCmd::ImDrawCmd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@D@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@D@@QAE@XZ PROC				; ImVector<char>::~ImVector<char>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@D@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@D@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@D@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@D@@QAE@XZ ENDP				; ImVector<char>::~ImVector<char>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@D@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@D@@QAE@XZ PROC				; ImVector<char>::ImVector<char>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@D@@QAE@XZ ENDP				; ImVector<char>::ImVector<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0ImVec4@@QAE@MMMM@Z
_TEXT	SEGMENT
__x$ = 8						; size = 4
__y$ = 12						; size = 4
__z$ = 16						; size = 4
__w$ = 20						; size = 4
??0ImVec4@@QAE@MMMM@Z PROC				; ImVec4::ImVec4, COMDAT
; _this$ = ecx

; 109  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

	npad	2
	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR __x$[ebp]
	mov	eax, ecx
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR __y$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	movss	xmm0, DWORD PTR __z$[ebp]
	movss	DWORD PTR [ecx+8], xmm0
	movss	xmm0, DWORD PTR __w$[ebp]
	movss	DWORD PTR [ecx+12], xmm0
	pop	ebp
	ret	16					; 00000010H
??0ImVec4@@QAE@MMMM@Z ENDP				; ImVec4::ImVec4
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0ImVec4@@QAE@XZ
_TEXT	SEGMENT
??0ImVec4@@QAE@XZ PROC					; ImVec4::ImVec4, COMDAT
; _this$ = ecx

; 108  :     ImVec4() { x = y = z = w = 0.0f; }

	mov	DWORD PTR [ecx+12], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx], 0
	ret	0
??0ImVec4@@QAE@XZ ENDP					; ImVec4::ImVec4
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0ImVec2@@QAE@MM@Z
_TEXT	SEGMENT
__x$ = 8						; size = 4
__y$ = 12						; size = 4
??0ImVec2@@QAE@MM@Z PROC				; ImVec2::ImVec2, COMDAT
; _this$ = ecx

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	npad	2
	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR __x$[ebp]
	mov	eax, ecx
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR __y$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	pop	ebp
	ret	8
??0ImVec2@@QAE@MM@Z ENDP				; ImVec2::ImVec2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0ImVec2@@QAE@XZ
_TEXT	SEGMENT
??0ImVec2@@QAE@XZ PROC					; ImVec2::ImVec2, COMDAT
; _this$ = ecx

; 97   :     ImVec2() { x = y = 0.0f; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	ret	0
??0ImVec2@@QAE@XZ ENDP					; ImVec2::ImVec2
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___n$[ebp]
	test	esi, esi
	je	SHORT $LN6@vector
	push	ebx
	mov	ebx, DWORD PTR ___f$[ebp]
	push	edi
	mov	edi, DWORD PTR ___t$[ebp]
$LL2@vector:
	mov	ecx, edi
	call	ebx
	add	edi, DWORD PTR ___s$[ebp]
	sub	esi, 1
	jne	SHORT $LL2@vector
	pop	edi
	pop	ebx
$LN6@vector:
	pop	esi
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
