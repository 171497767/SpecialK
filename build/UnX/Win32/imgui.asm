; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	C:\Users\andon\Source\Repos\SpecialK\src\imgui\imgui.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?SK_ImGui_Visible@@3_NA				; SK_ImGui_Visible
PUBLIC	?nav_usable@@3_NA				; nav_usable
PUBLIC	?analog_sensitivity@@3MA			; analog_sensitivity
PUBLIC	?GImGui@@3PAUImGuiContext@@A			; GImGui
_BSS	SEGMENT
?SK_ImGui_Visible@@3_NA DB 01H DUP (?)			; SK_ImGui_Visible
?nav_usable@@3_NA DB 01H DUP (?)			; nav_usable
_BSS	ENDS
_DATA	SEGMENT
?analog_sensitivity@@3MA DD 043a6aa3dr		; 333.33 ; analog_sensitivity
?GImGui@@3PAUImGuiContext@@A DD FLAT:?GImDefaultContext@@3UImGuiContext@@A ; GImGui
?STB_TEXTEDIT_NEWLINE@ImGuiStb@@3GA DW 0aH		; ImGuiStb::STB_TEXTEDIT_NEWLINE
_DATA	ENDS
CONST	SEGMENT
$SG117765 DB	'void_context_menu', 00H
$SG16770 DB	00H
$SG117181 DB	00H
$SG119822 DB	'%d', 00H
$SG17162 DB	00H
$SG119827 DB	'%f', 00H
$SG121691 DB	00H
$SG119831 DB	'%f', 00H
$SG122801 DB	00H
$SG119835 DB	'%f', 00H
$SG122803 DB	00H
$SG119838 DB	'%f', 00H
	ORG $+1
$SG117791 DB	'%s.%s.%08X', 00H
	ORG $+1
$SG117792 DB	'%s.%08X', 00H
$SG121909 DB	'*Unknown item*', 00H
	ORG $+1
$SG116823 DB	'Debug', 00H
	ORG $+2
$SG116898 DB	'rb', 00H
	ORG $+1
$SG116902 DB	'%.*s', 00H
	ORG $+3
$SG116907 DB	'Pos=%f,%f', 00H
	ORG $+2
$SG116910 DB	'Size=%f,%f', 00H
	ORG $+1
$SG116912 DB	'Collapsed=%d', 00H
	ORG $+3
$SG122045 DB	'*Unknown item*', 00H
	ORG $+1
$SG116937 DB	'wt', 00H
	ORG $+1
$SG116941 DB	'###', 00H
$SG116942 DB	'[%s]', 0aH, 00H
	ORG $+2
$SG116943 DB	'Pos=%d,%d', 0aH, 00H
	ORG $+1
$SG116944 DB	'Size=%d,%d', 0aH, 00H
$SG120017 DB	'%.3f', 00H
	ORG $+3
$SG116945 DB	'Collapsed=%li', 0aH, 00H
	ORG $+1
$SG116946 DB	0aH, 00H
	ORG $+2
$SG122096 DB	'##MainMenuBar', 00H
	ORG $+2
$SG120059 DB	'%.3f', 00H
	ORG $+3
$SG122110 DB	'##menubar', 00H
	ORG $+2
$SG120072 DB	'%.0f deg', 00H
	ORG $+3
$SG120087 DB	'%.0f', 00H
	ORG $+3
$SG120103 DB	'%.0f', 00H
	ORG $+3
$SG120121 DB	'##v', 00H
$SG122175 DB	'##menus', 00H
$SG142679 DB	'[', 00H, 'X', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H
	DB	't', 00H, '_', 00H, 'H', 00H, 'o', 00H, 't', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, '(', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H
	DB	't', 00H, ' ', 00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c'
	DB	00H, 'e', 00H, ' ', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 'n', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'e', 00H, 'd', 00H, ')', 00H, 00H
	DB	00H
	ORG $+2
$SG142684 DB	'[', 00H, 'X', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H
	DB	't', 00H, '_', 00H, 'H', 00H, 'o', 00H, 't', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, '(', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H
	DB	't', 00H, ' ', 00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c'
	DB	00H, 'e', 00H, ' ', 00H, 'D', 00H, 'i', 00H, 's', 00H, 'c', 00H
	DB	'o', 00H, 'n', 00H, 'n', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'e'
	DB	00H, 'd', 00H, ')', 00H, 00H, 00H
$SG120162 DB	'##v', 00H
$SG122223 DB	'#colorbutton', 00H
	ORG $+3
$SG122226 DB	'Color:', 0aH, '(%.2f,%.2f,%.2f,%.2f)', 0aH, '#%02X%02X%0'
	DB	'2X%02X', 00H
	ORG $+1
$SG117182 DB	0dH, 0aH, '%*s%.*s', 00H
	ORG $+2
$SG117183 DB	' %.*s', 00H
	ORG $+2
$SG122305 DB	'M:999', 00H
	ORG $+2
$SG122306 DB	'##X', 00H
$SG122307 DB	'##Y', 00H
$SG122308 DB	'##Z', 00H
$SG122309 DB	'##W', 00H
$SG122310 DB	'%3.0f', 00H
	ORG $+2
$SG122311 DB	'%3.0f', 00H
	ORG $+2
$SG122312 DB	'%3.0f', 00H
	ORG $+2
$SG120264 DB	'%.3f', 00H
	ORG $+3
$SG122313 DB	'%3.0f', 00H
	ORG $+2
$SG122314 DB	'R:%3.0f', 00H
$SG122315 DB	'G:%3.0f', 00H
$SG122316 DB	'B:%3.0f', 00H
$SG122317 DB	'A:%3.0f', 00H
$SG122318 DB	'H:%3.0f', 00H
$SG122319 DB	'S:%3.0f', 00H
$SG122320 DB	'V:%3.0f', 00H
$SG122321 DB	'A:%3.0f', 00H
$SG122327 DB	'#%02X%02X%02X%02X', 00H
	ORG $+2
$SG122328 DB	'#%02X%02X%02X', 00H
	ORG $+2
$SG122330 DB	'##Text', 00H
	ORG $+1
$SG122334 DB	'%02X%02X%02X%02X', 00H
	ORG $+3
$SG122335 DB	'%02X%02X%02X', 00H
	ORG $+3
$SG122338 DB	'Color:', 0aH, '(%.2f,%.2f,%.2f,%.2f)', 0aH, '#%02X%02X%0'
	DB	'2X%02X', 00H
	ORG $+1
$SG120291 DB	'##v', 00H
$SG122340 DB	'RGB', 00H
$SG122341 DB	'HSV', 00H
$SG122342 DB	'HEX', 00H
$SG118260 DB	'#RESIZE', 00H
$SG16890 DB	'#MOVE', 00H
	ORG $+2
$SG122369 DB	0dH, 0aH, '--------------------------------', 00H
	ORG $+1
$SG120334 DB	'##min', 00H
	ORG $+2
$SG120335 DB	'##max', 00H
	ORG $+2
$SG118297 DB	'#COLLAPSE', 00H
	ORG $+2
$SG118301 DB	'#CLOSE', 00H
	ORG $+1
$SG120351 DB	'%.0f', 00H
	ORG $+3
$SG118312 DB	'#CloseColumns', 00H
	ORG $+2
$SG120369 DB	'##v', 00H
$SG119349 DB	'#image', 00H
	ORG $+1
$SG119369 DB	'ab', 00H
	ORG $+1
$SG119383 DB	0dH, 0aH, 00H
	ORG $+1
$SG120408 DB	'##min', 00H
	ORG $+2
$SG120409 DB	'##max', 00H
	ORG $+2
$SG118365 DB	'#SCROLLX', 00H
	ORG $+3
$SG118366 DB	'#SCROLLY', 00H
	ORG $+3
$SG119397 DB	'LogButtons', 00H
	ORG $+1
$SG119398 DB	'Log To TTY', 00H
	ORG $+1
$SG119399 DB	'Log To File', 00H
$SG119400 DB	'Log To Clipboard', 00H
	ORG $+3
$SG119401 DB	'Depth', 00H
	ORG $+2
$SG121494 DB	'#SCROLLY', 00H
	ORG $+3
$SG122543 DB	'columns', 00H
$SG122560 DB	'#TreePush', 00H
	ORG $+2
$SG122566 DB	'#TreePush', 00H
	ORG $+2
$SG119494 DB	0aH, '##', 00H
$SG119495 DB	'##', 00H
	ORG $+1
$SG119502 DB	'>', 00H
	ORG $+2
$SG122578 DB	'true', 00H
	ORG $+3
$SG122579 DB	'false', 00H
	ORG $+2
$SG122580 DB	'%s: %s', 00H
	ORG $+1
$SG122585 DB	'%s: %d', 00H
	ORG $+1
$SG122590 DB	'%s: %d', 00H
	ORG $+1
$SG122600 DB	'%%s: %s', 00H
$SG122601 DB	'%s: %.3f', 00H
	ORG $+3
$SG122606 DB	'%s: (%.2f,%.2f,%.2f,%.2f)', 00H
	ORG $+2
?GStyleVarInfo@@3QBUImGuiStyleVarInfo@@B DD 01H		; GStyleVarInfo
	DD	00H
	DD	02H
	DD	04H
	DD	01H
	DD	014H
	DD	02H
	DD	0cH
	DD	01H
	DD	020H
	DD	02H
	DD	024H
	DD	01H
	DD	02cH
	DD	02H
	DD	030H
	DD	02H
	DD	038H
	DD	01H
	DD	048H
	DD	01H
	DD	058H
	DD	02H
	DD	060H
$SG122612 DB	'%s: %08X', 00H
	ORG $+3
$SG121603 DB	'#SCROLLY', 00H
	ORG $+3
$SG17169 DB	'1.50 WIP', 00H
	ORG $+3
$SG120603 DB	'%.0f%%', 00H
	ORG $+1
$SG118597 DB	'Text', 00H
	ORG $+3
$SG118599 DB	'TextDisabled', 00H
	ORG $+3
$SG120649 DB	'[x]', 00H
$SG118601 DB	'WindowBg', 00H
	ORG $+3
$SG120650 DB	'[ ]', 00H
$SG118603 DB	'ChildWindowBg', 00H
	ORG $+2
$SG118605 DB	'PopupBg', 00H
$SG118607 DB	'Border', 00H
	ORG $+1
$SG118609 DB	'BorderShadow', 00H
	ORG $+3
$SG118611 DB	'FrameBg', 00H
$SG118613 DB	'FrameBgHovered', 00H
	ORG $+1
$SG118615 DB	'FrameBgActive', 00H
	ORG $+2
$SG118617 DB	'TitleBg', 00H
$SG16217 DB	'imgui.ini', 00H
	ORG $+2
$SG16218 DB	'imgui_log.txt', 00H
	ORG $+2
$SG118619 DB	'TitleBgCollapsed', 00H
	ORG $+3
$SG118621 DB	'TitleBgActive', 00H
	ORG $+2
$SG121694 DB	'-', 00H
	ORG $+2
$SG118623 DB	'MenuBarBg', 00H
	ORG $+2
$SG121696 DB	'+', 00H
	ORG $+2
$SG118625 DB	'ScrollbarBg', 00H
$SG118627 DB	'ScrollbarGrab', 00H
	ORG $+2
$SG118629 DB	'ScrollbarGrabHovered', 00H
	ORG $+3
$SG118631 DB	'ScrollbarGrabActive', 00H
$SG118633 DB	'ComboBg', 00H
$SG118635 DB	'CheckMark', 00H
	ORG $+2
$SG118637 DB	'SliderGrab', 00H
	ORG $+1
$SG118639 DB	'SliderGrabActive', 00H
	ORG $+3
$SG121713 DB	'%f', 00H
	ORG $+1
$SG118641 DB	'Button', 00H
	ORG $+1
$SG121714 DB	'%%.%df', 00H
	ORG $+1
$SG117618 DB	'##Tooltip', 00H
	ORG $+2
$SG118643 DB	'ButtonHovered', 00H
	ORG $+2
$SG118645 DB	'ButtonActive', 00H
	ORG $+3
$SG118647 DB	'Header', 00H
	ORG $+1
$SG118649 DB	'HeaderHovered', 00H
	ORG $+2
$SG118651 DB	'HeaderActive', 00H
	ORG $+3
$SG118653 DB	'Column', 00H
	ORG $+1
$SG121726 DB	'%08X', 00H
	ORG $+3
$SG121727 DB	'%d', 00H
	ORG $+1
$SG118655 DB	'ColumnHovered', 00H
	ORG $+2
$SG118657 DB	'ColumnActive', 00H
	ORG $+3
$SG118659 DB	'ResizeGrip', 00H
	ORG $+1
$SG120708 DB	'(x)', 00H
$SG120709 DB	'( )', 00H
$SG118661 DB	'ResizeGripHovered', 00H
	ORG $+2
$SG118663 DB	'ResizeGripActive', 00H
	ORG $+3
$SG118665 DB	'CloseButton', 00H
$SG117642 DB	'##menus', 00H
$SG118667 DB	'CloseButtonHovered', 00H
	ORG $+1
$SG118669 DB	'CloseButtonActive', 00H
	ORG $+2
$SG121743 DB	'##v', 00H
$SG118671 DB	'PlotLines', 00H
	ORG $+2
$SG118673 DB	'PlotLinesHovered', 00H
	ORG $+3
$SG118675 DB	'PlotHistogram', 00H
	ORG $+2
$SG118677 DB	'PlotHistogramHovered', 00H
	ORG $+3
$SG118679 DB	'TextSelectedBg', 00H
	ORG $+1
$SG118681 DB	'ModalWindowDarkening', 00H
	ORG $+3
$SG118683 DB	'NavHighlight', 00H
	ORG $+3
$SG118685 DB	'NavWindowingHighlight', 00H
	ORG $+2
$SG118686 DB	'Unknown', 00H
$SG122785 DB	'ImGui Metrics', 00H
	ORG $+2
$SG122786 DB	'ImGui %s', 00H
	ORG $+3
$SG122787 DB	'Application average %.3f ms/frame (%.1f FPS)', 00H
	ORG $+3
$SG122788 DB	'%d vertices, %d indices (%d triangles)', 00H
	ORG $+1
$SG122789 DB	'%d allocations', 00H
	ORG $+1
$SG122790 DB	'sizeof(ImGuiContext) = %u, sizeof(ImGuiWindow) = %u', 00H
$SG122791 DB	'Show clipping rectangles when hovering a ImDrawCmd', 00H
	ORG $+1
$SG122792 DB	'Windows', 00H
$SG122794 DB	'Active DrawLists (%d)', 00H
	ORG $+2
$SG122795 DB	'DrawList', 00H
	ORG $+3
$SG122796 DB	'DrawList', 00H
	ORG $+3
$SG122798 DB	'Open Popups Stack (%d)', 00H
	ORG $+1
$SG122799 DB	'Popups', 00H
	ORG $+1
$SG122800 DB	' ChildMenu', 00H
	ORG $+1
$SG121776 DB	'##v', 00H
$SG122802 DB	' ChildWindow', 00H
	ORG $+3
$SG122804 DB	'NULL', 00H
	ORG $+3
$SG122805 DB	'PopupID: %08x, Window: ''%s''%s%s', 00H
$SG122807 DB	'Basic state', 00H
$SG122808 DB	'None', 00H
	ORG $+3
$SG122809 DB	'Mouse', 00H
	ORG $+2
$SG122810 DB	'Nav', 00H
$SG122811 DB	'NULL', 00H
	ORG $+3
$SG122812 DB	'HoveredWindow: ''%s''', 00H
$SG122813 DB	'NULL', 00H
	ORG $+3
$SG122814 DB	'HoveredRootWindow: ''%s''', 00H
$SG122815 DB	'HoveredId: 0x%08X/0x%08X', 00H
	ORG $+3
$SG122816 DB	'ActiveId: 0x%08X/0x%08X, ActiveIdSource: %s', 00H
$SG122817 DB	'NULL', 00H
	ORG $+3
$SG122818 DB	'ActiveIdWindow: ''%s', 00H
$SG122819 DB	'NULL', 00H
	ORG $+3
$SG122820 DB	'NavWindow: ''%s'', NavId: 0x%08X, NavLayer: %d', 00H
	ORG $+3
$SG122821 DB	'NavRefRectRel: (%.1f,%.1f)(%.1f,%.1f)', 00H
	ORG $+2
$SG122822 DB	'NavUsable: %d, NavActive: %d', 00H
	ORG $+3
$SG122823 DB	'NavDisableHighlight: %d, NavDisableMouseHover: %d', 00H
	ORG $+2
$SG119756 DB	'%d', 00H
	ORG $+1
$SG119757 DB	'%.*d', 00H
	ORG $+3
$SG119761 DB	'%f', 00H
	ORG $+1
$SG119762 DB	'%.*f', 00H
	ORG $+3
$SG117717 DB	'##menu_%d', 00H
	ORG $+2
$SG117718 DB	'##popup_%08x', 00H
	ORG $+3
$SG117756 DB	'window_context_menu', 00H
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0ImVec2@@QAE@XZ				; ImVec2::ImVec2
PUBLIC	??0ImVec2@@QAE@MM@Z				; ImVec2::ImVec2
PUBLIC	??0ImVec4@@QAE@XZ				; ImVec4::ImVec4
PUBLIC	??0ImVec4@@QAE@MMMM@Z				; ImVec4::ImVec4
PUBLIC	?GetIO@ImGui@@YAAAUImGuiIO@@XZ			; ImGui::GetIO
PUBLIC	?GetStyle@ImGui@@YAAAUImGuiStyle@@XZ		; ImGui::GetStyle
PUBLIC	?GetDrawData@ImGui@@YAPAUImDrawData@@XZ		; ImGui::GetDrawData
PUBLIC	?NewFrame@ImGui@@YAXXZ				; ImGui::NewFrame
PUBLIC	?Render@ImGui@@YAXXZ				; ImGui::Render
PUBLIC	?Shutdown@ImGui@@YAXXZ				; ImGui::Shutdown
PUBLIC	?ShowMetricsWindow@ImGui@@YAXPA_N@Z		; ImGui::ShowMetricsWindow
PUBLIC	?Begin@ImGui@@YA_NPBDPA_NH@Z			; ImGui::Begin
PUBLIC	?Begin@ImGui@@YA_NPBDPA_NABUImVec2@@MH@Z	; ImGui::Begin
PUBLIC	?End@ImGui@@YAXXZ				; ImGui::End
PUBLIC	?BeginChild@ImGui@@YA_NPBDABUImVec2@@_NH@Z	; ImGui::BeginChild
PUBLIC	?BeginChild@ImGui@@YA_NIABUImVec2@@_NH@Z	; ImGui::BeginChild
PUBLIC	?EndChild@ImGui@@YAXXZ				; ImGui::EndChild
PUBLIC	?GetContentRegionMax@ImGui@@YA?AUImVec2@@XZ	; ImGui::GetContentRegionMax
PUBLIC	?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ	; ImGui::GetContentRegionAvail
PUBLIC	?GetContentRegionAvailWidth@ImGui@@YAMXZ	; ImGui::GetContentRegionAvailWidth
PUBLIC	?GetWindowContentRegionMin@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetWindowContentRegionMin
PUBLIC	?GetWindowContentRegionMax@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetWindowContentRegionMax
PUBLIC	?GetWindowContentRegionWidth@ImGui@@YAMXZ	; ImGui::GetWindowContentRegionWidth
PUBLIC	?GetWindowDrawList@ImGui@@YAPAUImDrawList@@XZ	; ImGui::GetWindowDrawList
PUBLIC	?GetWindowPos@ImGui@@YA?AUImVec2@@XZ		; ImGui::GetWindowPos
PUBLIC	?GetWindowSize@ImGui@@YA?AUImVec2@@XZ		; ImGui::GetWindowSize
PUBLIC	?GetWindowWidth@ImGui@@YAMXZ			; ImGui::GetWindowWidth
PUBLIC	?GetWindowHeight@ImGui@@YAMXZ			; ImGui::GetWindowHeight
PUBLIC	?IsWindowCollapsed@ImGui@@YA_NXZ		; ImGui::IsWindowCollapsed
PUBLIC	?SetWindowFontScale@ImGui@@YAXM@Z		; ImGui::SetWindowFontScale
PUBLIC	?SetNextWindowPos@ImGui@@YAXABUImVec2@@H@Z	; ImGui::SetNextWindowPos
PUBLIC	?SetNextWindowPosCenter@ImGui@@YAXH@Z		; ImGui::SetNextWindowPosCenter
PUBLIC	?SetNextWindowSize@ImGui@@YAXABUImVec2@@H@Z	; ImGui::SetNextWindowSize
PUBLIC	?SetNextWindowSizeConstraints@ImGui@@YAXABUImVec2@@0P6AXPAUImGuiSizeConstraintCallbackData@@@ZPAX@Z ; ImGui::SetNextWindowSizeConstraints
PUBLIC	?SetNextWindowContentSize@ImGui@@YAXABUImVec2@@@Z ; ImGui::SetNextWindowContentSize
PUBLIC	?SetNextWindowContentWidth@ImGui@@YAXM@Z	; ImGui::SetNextWindowContentWidth
PUBLIC	?SetNextWindowCollapsed@ImGui@@YAX_NH@Z		; ImGui::SetNextWindowCollapsed
PUBLIC	?SetNextWindowFocus@ImGui@@YAXXZ		; ImGui::SetNextWindowFocus
PUBLIC	?SetWindowPos@ImGui@@YAXABUImVec2@@H@Z		; ImGui::SetWindowPos
PUBLIC	?SetWindowSize@ImGui@@YAXABUImVec2@@H@Z		; ImGui::SetWindowSize
PUBLIC	?SetWindowCollapsed@ImGui@@YAX_NH@Z		; ImGui::SetWindowCollapsed
PUBLIC	?SetWindowFocus@ImGui@@YAXXZ			; ImGui::SetWindowFocus
PUBLIC	?SetWindowPos@ImGui@@YAXPBDABUImVec2@@H@Z	; ImGui::SetWindowPos
PUBLIC	?SetWindowSize@ImGui@@YAXPBDABUImVec2@@H@Z	; ImGui::SetWindowSize
PUBLIC	?SetWindowCollapsed@ImGui@@YAXPBD_NH@Z		; ImGui::SetWindowCollapsed
PUBLIC	?SetWindowFocus@ImGui@@YAXPBD@Z			; ImGui::SetWindowFocus
PUBLIC	?GetScrollX@ImGui@@YAMXZ			; ImGui::GetScrollX
PUBLIC	?GetScrollY@ImGui@@YAMXZ			; ImGui::GetScrollY
PUBLIC	?GetScrollMaxX@ImGui@@YAMXZ			; ImGui::GetScrollMaxX
PUBLIC	?GetScrollMaxY@ImGui@@YAMXZ			; ImGui::GetScrollMaxY
PUBLIC	?SetScrollX@ImGui@@YAXM@Z			; ImGui::SetScrollX
PUBLIC	?SetScrollY@ImGui@@YAXM@Z			; ImGui::SetScrollY
PUBLIC	?SetScrollHere@ImGui@@YAXM@Z			; ImGui::SetScrollHere
PUBLIC	?SetScrollFromPosY@ImGui@@YAXMM@Z		; ImGui::SetScrollFromPosY
PUBLIC	?SetKeyboardFocusHere@ImGui@@YAXH@Z		; ImGui::SetKeyboardFocusHere
PUBLIC	?SetStateStorage@ImGui@@YAXPAUImGuiStorage@@@Z	; ImGui::SetStateStorage
PUBLIC	?GetStateStorage@ImGui@@YAPAUImGuiStorage@@XZ	; ImGui::GetStateStorage
PUBLIC	?PushFont@ImGui@@YAXPAUImFont@@@Z		; ImGui::PushFont
PUBLIC	?PopFont@ImGui@@YAXXZ				; ImGui::PopFont
PUBLIC	?PushStyleColor@ImGui@@YAXHABUImVec4@@@Z	; ImGui::PushStyleColor
PUBLIC	?PopStyleColor@ImGui@@YAXH@Z			; ImGui::PopStyleColor
PUBLIC	?PushStyleVar@ImGui@@YAXHM@Z			; ImGui::PushStyleVar
PUBLIC	?PushStyleVar@ImGui@@YAXHABUImVec2@@@Z		; ImGui::PushStyleVar
PUBLIC	?PopStyleVar@ImGui@@YAXH@Z			; ImGui::PopStyleVar
PUBLIC	?GetFont@ImGui@@YAPAUImFont@@XZ			; ImGui::GetFont
PUBLIC	?GetFontSize@ImGui@@YAMXZ			; ImGui::GetFontSize
PUBLIC	?GetFontTexUvWhitePixel@ImGui@@YA?AUImVec2@@XZ	; ImGui::GetFontTexUvWhitePixel
PUBLIC	?GetColorU32@ImGui@@YAIHM@Z			; ImGui::GetColorU32
PUBLIC	?GetColorU32@ImGui@@YAIABUImVec4@@@Z		; ImGui::GetColorU32
PUBLIC	?PushItemWidth@ImGui@@YAXM@Z			; ImGui::PushItemWidth
PUBLIC	?PopItemWidth@ImGui@@YAXXZ			; ImGui::PopItemWidth
PUBLIC	?CalcItemWidth@ImGui@@YAMXZ			; ImGui::CalcItemWidth
PUBLIC	?PushTextWrapPos@ImGui@@YAXM@Z			; ImGui::PushTextWrapPos
PUBLIC	?PopTextWrapPos@ImGui@@YAXXZ			; ImGui::PopTextWrapPos
PUBLIC	?PushAllowKeyboardFocus@ImGui@@YAX_N@Z		; ImGui::PushAllowKeyboardFocus
PUBLIC	?PopAllowKeyboardFocus@ImGui@@YAXXZ		; ImGui::PopAllowKeyboardFocus
PUBLIC	?PushButtonRepeat@ImGui@@YAX_N@Z		; ImGui::PushButtonRepeat
PUBLIC	?PopButtonRepeat@ImGui@@YAXXZ			; ImGui::PopButtonRepeat
PUBLIC	?Separator@ImGui@@YAXXZ				; ImGui::Separator
PUBLIC	?SameLine@ImGui@@YAXMM@Z			; ImGui::SameLine
PUBLIC	?NewLine@ImGui@@YAXXZ				; ImGui::NewLine
PUBLIC	?Spacing@ImGui@@YAXXZ				; ImGui::Spacing
PUBLIC	?Dummy@ImGui@@YAXABUImVec2@@@Z			; ImGui::Dummy
PUBLIC	?Indent@ImGui@@YAXM@Z				; ImGui::Indent
PUBLIC	?Unindent@ImGui@@YAXM@Z				; ImGui::Unindent
PUBLIC	?BeginGroup@ImGui@@YAXXZ			; ImGui::BeginGroup
PUBLIC	?EndGroup@ImGui@@YAXXZ				; ImGui::EndGroup
PUBLIC	?GetCursorPos@ImGui@@YA?AUImVec2@@XZ		; ImGui::GetCursorPos
PUBLIC	?GetCursorPosX@ImGui@@YAMXZ			; ImGui::GetCursorPosX
PUBLIC	?GetCursorPosY@ImGui@@YAMXZ			; ImGui::GetCursorPosY
PUBLIC	?SetCursorPos@ImGui@@YAXABUImVec2@@@Z		; ImGui::SetCursorPos
PUBLIC	?SetCursorPosX@ImGui@@YAXM@Z			; ImGui::SetCursorPosX
PUBLIC	?SetCursorPosY@ImGui@@YAXM@Z			; ImGui::SetCursorPosY
PUBLIC	?GetCursorStartPos@ImGui@@YA?AUImVec2@@XZ	; ImGui::GetCursorStartPos
PUBLIC	?GetCursorScreenPos@ImGui@@YA?AUImVec2@@XZ	; ImGui::GetCursorScreenPos
PUBLIC	?SetCursorScreenPos@ImGui@@YAXABUImVec2@@@Z	; ImGui::SetCursorScreenPos
PUBLIC	?AlignFirstTextHeightToWidgets@ImGui@@YAXXZ	; ImGui::AlignFirstTextHeightToWidgets
PUBLIC	?GetTextLineHeight@ImGui@@YAMXZ			; ImGui::GetTextLineHeight
PUBLIC	?GetTextLineHeightWithSpacing@ImGui@@YAMXZ	; ImGui::GetTextLineHeightWithSpacing
PUBLIC	?GetItemsLineHeightWithSpacing@ImGui@@YAMXZ	; ImGui::GetItemsLineHeightWithSpacing
PUBLIC	?Columns@ImGui@@YAXHPBD_N@Z			; ImGui::Columns
PUBLIC	?NextColumn@ImGui@@YAXXZ			; ImGui::NextColumn
PUBLIC	?GetColumnIndex@ImGui@@YAHXZ			; ImGui::GetColumnIndex
PUBLIC	?GetColumnOffset@ImGui@@YAMH@Z			; ImGui::GetColumnOffset
PUBLIC	?SetColumnOffset@ImGui@@YAXHM@Z			; ImGui::SetColumnOffset
PUBLIC	?GetColumnWidth@ImGui@@YAMH@Z			; ImGui::GetColumnWidth
PUBLIC	?GetColumnsCount@ImGui@@YAHXZ			; ImGui::GetColumnsCount
PUBLIC	?PushID@ImGui@@YAXPBD@Z				; ImGui::PushID
PUBLIC	?PushID@ImGui@@YAXPBD0@Z			; ImGui::PushID
PUBLIC	?PushID@ImGui@@YAXPBX@Z				; ImGui::PushID
PUBLIC	?PushID@ImGui@@YAXH@Z				; ImGui::PushID
PUBLIC	?PopID@ImGui@@YAXXZ				; ImGui::PopID
PUBLIC	?GetID@ImGui@@YAIPBD@Z				; ImGui::GetID
PUBLIC	?GetID@ImGui@@YAIPBD0@Z				; ImGui::GetID
PUBLIC	?GetID@ImGui@@YAIPBX@Z				; ImGui::GetID
PUBLIC	?Text@ImGui@@YAXPBDZZ				; ImGui::Text
PUBLIC	?TextV@ImGui@@YAXPBDPAD@Z			; ImGui::TextV
PUBLIC	?TextColored@ImGui@@YAXABUImVec4@@PBDZZ		; ImGui::TextColored
PUBLIC	?TextColoredV@ImGui@@YAXABUImVec4@@PBDPAD@Z	; ImGui::TextColoredV
PUBLIC	?TextDisabled@ImGui@@YAXPBDZZ			; ImGui::TextDisabled
PUBLIC	?TextDisabledV@ImGui@@YAXPBDPAD@Z		; ImGui::TextDisabledV
PUBLIC	?TextWrapped@ImGui@@YAXPBDZZ			; ImGui::TextWrapped
PUBLIC	?TextWrappedV@ImGui@@YAXPBDPAD@Z		; ImGui::TextWrappedV
PUBLIC	?TextUnformatted@ImGui@@YAXPBD0@Z		; ImGui::TextUnformatted
PUBLIC	?LabelText@ImGui@@YAXPBD0ZZ			; ImGui::LabelText
PUBLIC	?LabelTextV@ImGui@@YAXPBD0PAD@Z			; ImGui::LabelTextV
PUBLIC	?Bullet@ImGui@@YAXXZ				; ImGui::Bullet
PUBLIC	?BulletText@ImGui@@YAXPBDZZ			; ImGui::BulletText
PUBLIC	?BulletTextV@ImGui@@YAXPBDPAD@Z			; ImGui::BulletTextV
PUBLIC	?Button@ImGui@@YA_NPBDABUImVec2@@@Z		; ImGui::Button
PUBLIC	?SmallButton@ImGui@@YA_NPBD@Z			; ImGui::SmallButton
PUBLIC	?InvisibleButton@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::InvisibleButton
PUBLIC	?Image@ImGui@@YAXPAXABUImVec2@@11ABUImVec4@@2@Z	; ImGui::Image
PUBLIC	?ImageButton@ImGui@@YA_NPAXABUImVec2@@11HABUImVec4@@2@Z ; ImGui::ImageButton
PUBLIC	?Checkbox@ImGui@@YA_NPBDPA_N@Z			; ImGui::Checkbox
PUBLIC	?CheckboxFlags@ImGui@@YA_NPBDPAII@Z		; ImGui::CheckboxFlags
PUBLIC	?RadioButton@ImGui@@YA_NPBD_N@Z			; ImGui::RadioButton
PUBLIC	?RadioButton@ImGui@@YA_NPBDPAHH@Z		; ImGui::RadioButton
PUBLIC	?Combo@ImGui@@YA_NPBDPAHPBQBDHH@Z		; ImGui::Combo
PUBLIC	?Combo@ImGui@@YA_NPBDPAH0H@Z			; ImGui::Combo
PUBLIC	?Combo@ImGui@@YA_NPBDPAHP6A_NPAXHPAPBD@Z2HH@Z	; ImGui::Combo
PUBLIC	?ColorButton@ImGui@@YA_NABUImVec4@@_N1@Z	; ImGui::ColorButton
PUBLIC	?ColorEdit3@ImGui@@YA_NPBDQAM@Z			; ImGui::ColorEdit3
PUBLIC	?ColorEdit4@ImGui@@YA_NPBDQAM_N@Z		; ImGui::ColorEdit4
PUBLIC	?ColorEditMode@ImGui@@YAXH@Z			; ImGui::ColorEditMode
PUBLIC	?PlotLines@ImGui@@YAXPBDPBMHH0MMUImVec2@@H@Z	; ImGui::PlotLines
PUBLIC	?PlotLines@ImGui@@YAXPBDP6AMPAXH@Z1HH0MMUImVec2@@@Z ; ImGui::PlotLines
PUBLIC	?PlotLinesC@ImGui@@YAXPBDPBMHH0MMUImVec2@@HMMM_N@Z ; ImGui::PlotLinesC
PUBLIC	?PlotHistogram@ImGui@@YAXPBDPBMHH0MMUImVec2@@H@Z ; ImGui::PlotHistogram
PUBLIC	?PlotHistogram@ImGui@@YAXPBDP6AMPAXH@Z1HH0MMUImVec2@@@Z ; ImGui::PlotHistogram
PUBLIC	?ProgressBar@ImGui@@YAXMABUImVec2@@PBD@Z	; ImGui::ProgressBar
PUBLIC	?DragFloat@ImGui@@YA_NPBDPAMMMM0M@Z		; ImGui::DragFloat
PUBLIC	?DragFloat2@ImGui@@YA_NPBDQAMMMM0M@Z		; ImGui::DragFloat2
PUBLIC	?DragFloat3@ImGui@@YA_NPBDQAMMMM0M@Z		; ImGui::DragFloat3
PUBLIC	?DragFloat4@ImGui@@YA_NPBDQAMMMM0M@Z		; ImGui::DragFloat4
PUBLIC	?DragFloatRange2@ImGui@@YA_NPBDPAM1MMM00M@Z	; ImGui::DragFloatRange2
PUBLIC	?DragInt@ImGui@@YA_NPBDPAHMHH0@Z		; ImGui::DragInt
PUBLIC	?DragInt2@ImGui@@YA_NPBDQAHMHH0@Z		; ImGui::DragInt2
PUBLIC	?DragInt3@ImGui@@YA_NPBDQAHMHH0@Z		; ImGui::DragInt3
PUBLIC	?DragInt4@ImGui@@YA_NPBDQAHMHH0@Z		; ImGui::DragInt4
PUBLIC	?DragIntRange2@ImGui@@YA_NPBDPAH1MHH00@Z	; ImGui::DragIntRange2
PUBLIC	?InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ; ImGui::InputText
PUBLIC	?InputTextMultiline@ImGui@@YA_NPBDPADIABUImVec2@@HP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ; ImGui::InputTextMultiline
PUBLIC	?InputFloat@ImGui@@YA_NPBDPAMMMHH@Z		; ImGui::InputFloat
PUBLIC	?InputFloat2@ImGui@@YA_NPBDQAMHH@Z		; ImGui::InputFloat2
PUBLIC	?InputFloat3@ImGui@@YA_NPBDQAMHH@Z		; ImGui::InputFloat3
PUBLIC	?InputFloat4@ImGui@@YA_NPBDQAMHH@Z		; ImGui::InputFloat4
PUBLIC	?InputInt@ImGui@@YA_NPBDPAHHHH@Z		; ImGui::InputInt
PUBLIC	?InputInt2@ImGui@@YA_NPBDQAHH@Z			; ImGui::InputInt2
PUBLIC	?InputInt3@ImGui@@YA_NPBDQAHH@Z			; ImGui::InputInt3
PUBLIC	?InputInt4@ImGui@@YA_NPBDQAHH@Z			; ImGui::InputInt4
PUBLIC	?SliderFloat@ImGui@@YA_NPBDPAMMM0M@Z		; ImGui::SliderFloat
PUBLIC	?SliderFloat2@ImGui@@YA_NPBDQAMMM0M@Z		; ImGui::SliderFloat2
PUBLIC	?SliderFloat3@ImGui@@YA_NPBDQAMMM0M@Z		; ImGui::SliderFloat3
PUBLIC	?SliderFloat4@ImGui@@YA_NPBDQAMMM0M@Z		; ImGui::SliderFloat4
PUBLIC	?SliderAngle@ImGui@@YA_NPBDPAMMM@Z		; ImGui::SliderAngle
PUBLIC	?SliderInt@ImGui@@YA_NPBDPAHHH0@Z		; ImGui::SliderInt
PUBLIC	?SliderInt2@ImGui@@YA_NPBDQAHHH0@Z		; ImGui::SliderInt2
PUBLIC	?SliderInt3@ImGui@@YA_NPBDQAHHH0@Z		; ImGui::SliderInt3
PUBLIC	?SliderInt4@ImGui@@YA_NPBDQAHHH0@Z		; ImGui::SliderInt4
PUBLIC	?VSliderFloat@ImGui@@YA_NPBDABUImVec2@@PAMMM0M@Z ; ImGui::VSliderFloat
PUBLIC	?VSliderInt@ImGui@@YA_NPBDABUImVec2@@PAHHH0@Z	; ImGui::VSliderInt
PUBLIC	?TreeNode@ImGui@@YA_NPBD@Z			; ImGui::TreeNode
PUBLIC	?TreeNode@ImGui@@YA_NPBD0ZZ			; ImGui::TreeNode
PUBLIC	?TreeNode@ImGui@@YA_NPBXPBDZZ			; ImGui::TreeNode
PUBLIC	?TreeNodeV@ImGui@@YA_NPBD0PAD@Z			; ImGui::TreeNodeV
PUBLIC	?TreeNodeV@ImGui@@YA_NPBXPBDPAD@Z		; ImGui::TreeNodeV
PUBLIC	?TreeNodeEx@ImGui@@YA_NPBDH@Z			; ImGui::TreeNodeEx
PUBLIC	?TreeNodeEx@ImGui@@YA_NPBDH0ZZ			; ImGui::TreeNodeEx
PUBLIC	?TreeNodeEx@ImGui@@YA_NPBXHPBDZZ		; ImGui::TreeNodeEx
PUBLIC	?TreeNodeExV@ImGui@@YA_NPBDH0PAD@Z		; ImGui::TreeNodeExV
PUBLIC	?TreeNodeExV@ImGui@@YA_NPBXHPBDPAD@Z		; ImGui::TreeNodeExV
PUBLIC	?TreePush@ImGui@@YAXPBD@Z			; ImGui::TreePush
PUBLIC	?TreePush@ImGui@@YAXPBX@Z			; ImGui::TreePush
PUBLIC	?TreePop@ImGui@@YAXXZ				; ImGui::TreePop
PUBLIC	?TreeAdvanceToLabelPos@ImGui@@YAXXZ		; ImGui::TreeAdvanceToLabelPos
PUBLIC	?GetTreeNodeToLabelSpacing@ImGui@@YAMXZ		; ImGui::GetTreeNodeToLabelSpacing
PUBLIC	?SetNextTreeNodeOpen@ImGui@@YAX_NH@Z		; ImGui::SetNextTreeNodeOpen
PUBLIC	?CollapsingHeader@ImGui@@YA_NPBDH@Z		; ImGui::CollapsingHeader
PUBLIC	?CollapsingHeader@ImGui@@YA_NPBDPA_NH@Z		; ImGui::CollapsingHeader
PUBLIC	?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z	; ImGui::Selectable
PUBLIC	?Selectable@ImGui@@YA_NPBDPA_NHABUImVec2@@@Z	; ImGui::Selectable
PUBLIC	?ListBox@ImGui@@YA_NPBDPAHPBQBDHH@Z		; ImGui::ListBox
PUBLIC	?ListBox@ImGui@@YA_NPBDPAHP6A_NPAXHPAPBD@Z2HH@Z	; ImGui::ListBox
PUBLIC	?ListBoxHeader@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::ListBoxHeader
PUBLIC	?ListBoxHeader@ImGui@@YA_NPBDHH@Z		; ImGui::ListBoxHeader
PUBLIC	?ListBoxFooter@ImGui@@YAXXZ			; ImGui::ListBoxFooter
PUBLIC	?Value@ImGui@@YAXPBD_N@Z			; ImGui::Value
PUBLIC	?Value@ImGui@@YAXPBDH@Z				; ImGui::Value
PUBLIC	?Value@ImGui@@YAXPBDI@Z				; ImGui::Value
PUBLIC	?Value@ImGui@@YAXPBDM0@Z			; ImGui::Value
PUBLIC	?ValueColor@ImGui@@YAXPBDABUImVec4@@@Z		; ImGui::ValueColor
PUBLIC	?ValueColor@ImGui@@YAXPBDI@Z			; ImGui::ValueColor
PUBLIC	?SetTooltip@ImGui@@YAXPBDZZ			; ImGui::SetTooltip
PUBLIC	?SetTooltipV@ImGui@@YAXPBDPAD@Z			; ImGui::SetTooltipV
PUBLIC	?BeginTooltip@ImGui@@YAXXZ			; ImGui::BeginTooltip
PUBLIC	?EndTooltip@ImGui@@YAXXZ			; ImGui::EndTooltip
PUBLIC	?BeginMainMenuBar@ImGui@@YA_NXZ			; ImGui::BeginMainMenuBar
PUBLIC	?EndMainMenuBar@ImGui@@YAXXZ			; ImGui::EndMainMenuBar
PUBLIC	?BeginMenuBar@ImGui@@YA_NXZ			; ImGui::BeginMenuBar
PUBLIC	?EndMenuBar@ImGui@@YAXXZ			; ImGui::EndMenuBar
PUBLIC	?BeginMenu@ImGui@@YA_NPBD_N@Z			; ImGui::BeginMenu
PUBLIC	?EndMenu@ImGui@@YAXXZ				; ImGui::EndMenu
PUBLIC	?MenuItem@ImGui@@YA_NPBD0_N1@Z			; ImGui::MenuItem
PUBLIC	?MenuItem@ImGui@@YA_NPBD0PA_N_N@Z		; ImGui::MenuItem
PUBLIC	?OpenPopup@ImGui@@YAXPBD@Z			; ImGui::OpenPopup
PUBLIC	?BeginPopup@ImGui@@YA_NPBD@Z			; ImGui::BeginPopup
PUBLIC	?BeginPopupModal@ImGui@@YA_NPBDPA_NH@Z		; ImGui::BeginPopupModal
PUBLIC	?BeginPopupContextItem@ImGui@@YA_NPBDH@Z	; ImGui::BeginPopupContextItem
PUBLIC	?BeginPopupContextWindow@ImGui@@YA_N_NPBDH@Z	; ImGui::BeginPopupContextWindow
PUBLIC	?BeginPopupContextVoid@ImGui@@YA_NPBDH@Z	; ImGui::BeginPopupContextVoid
PUBLIC	?EndPopup@ImGui@@YAXXZ				; ImGui::EndPopup
PUBLIC	?CloseCurrentPopup@ImGui@@YAXXZ			; ImGui::CloseCurrentPopup
PUBLIC	?LogToTTY@ImGui@@YAXH@Z				; ImGui::LogToTTY
PUBLIC	?LogToFile@ImGui@@YAXHPBD@Z			; ImGui::LogToFile
PUBLIC	?LogToClipboard@ImGui@@YAXH@Z			; ImGui::LogToClipboard
PUBLIC	?LogFinish@ImGui@@YAXXZ				; ImGui::LogFinish
PUBLIC	?LogButtons@ImGui@@YAXXZ			; ImGui::LogButtons
PUBLIC	?LogText@ImGui@@YAXPBDZZ			; ImGui::LogText
PUBLIC	?PushClipRect@ImGui@@YAXABUImVec2@@0_N@Z	; ImGui::PushClipRect
PUBLIC	?PopClipRect@ImGui@@YAXXZ			; ImGui::PopClipRect
PUBLIC	?IsItemHovered@ImGui@@YA_NXZ			; ImGui::IsItemHovered
PUBLIC	?IsItemHoveredRect@ImGui@@YA_NXZ		; ImGui::IsItemHoveredRect
PUBLIC	?IsItemActive@ImGui@@YA_NXZ			; ImGui::IsItemActive
PUBLIC	?IsItemFocused@ImGui@@YA_NXZ			; ImGui::IsItemFocused
PUBLIC	?IsItemClicked@ImGui@@YA_NH@Z			; ImGui::IsItemClicked
PUBLIC	?IsItemVisible@ImGui@@YA_NXZ			; ImGui::IsItemVisible
PUBLIC	?IsAnyItemHovered@ImGui@@YA_NXZ			; ImGui::IsAnyItemHovered
PUBLIC	?IsAnyItemActive@ImGui@@YA_NXZ			; ImGui::IsAnyItemActive
PUBLIC	?IsAnyItemFocused@ImGui@@YA_NXZ			; ImGui::IsAnyItemFocused
PUBLIC	?GetItemRectMin@ImGui@@YA?AUImVec2@@XZ		; ImGui::GetItemRectMin
PUBLIC	?GetItemRectMax@ImGui@@YA?AUImVec2@@XZ		; ImGui::GetItemRectMax
PUBLIC	?GetItemRectSize@ImGui@@YA?AUImVec2@@XZ		; ImGui::GetItemRectSize
PUBLIC	?SetItemAllowOverlap@ImGui@@YAXXZ		; ImGui::SetItemAllowOverlap
PUBLIC	?SetItemDefaultFocus@ImGui@@YAXXZ		; ImGui::SetItemDefaultFocus
PUBLIC	?IsWindowFocused@ImGui@@YA_NXZ			; ImGui::IsWindowFocused
PUBLIC	?IsWindowHovered@ImGui@@YA_NXZ			; ImGui::IsWindowHovered
PUBLIC	?IsWindowHoveredRect@ImGui@@YA_NXZ		; ImGui::IsWindowHoveredRect
PUBLIC	?IsRootWindowFocused@ImGui@@YA_NXZ		; ImGui::IsRootWindowFocused
PUBLIC	?IsRootWindowOrAnyChildFocused@ImGui@@YA_NXZ	; ImGui::IsRootWindowOrAnyChildFocused
PUBLIC	?IsRootWindowOrAnyChildHovered@ImGui@@YA_NXZ	; ImGui::IsRootWindowOrAnyChildHovered
PUBLIC	?IsAnyWindowFocused@ImGui@@YA_NXZ		; ImGui::IsAnyWindowFocused
PUBLIC	?IsAnyWindowHovered@ImGui@@YA_NXZ		; ImGui::IsAnyWindowHovered
PUBLIC	?IsAnyWindowHoveredAtPos@ImGui@@YA_NABUImVec2@@@Z ; ImGui::IsAnyWindowHoveredAtPos
PUBLIC	?IsRectVisible@ImGui@@YA_NABUImVec2@@@Z		; ImGui::IsRectVisible
PUBLIC	?IsRectVisible@ImGui@@YA_NABUImVec2@@0@Z	; ImGui::IsRectVisible
PUBLIC	?GetTime@ImGui@@YAMXZ				; ImGui::GetTime
PUBLIC	?GetFrameCount@ImGui@@YAHXZ			; ImGui::GetFrameCount
PUBLIC	?GetStyleColName@ImGui@@YAPBDH@Z		; ImGui::GetStyleColName
PUBLIC	?CalcItemRectClosestPoint@ImGui@@YA?AUImVec2@@ABU2@_NM@Z ; ImGui::CalcItemRectClosestPoint
PUBLIC	?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z	; ImGui::CalcTextSize
PUBLIC	?CalcListClipping@ImGui@@YAXHMPAH0@Z		; ImGui::CalcListClipping
PUBLIC	?BeginChildFrame@ImGui@@YA_NIABUImVec2@@H@Z	; ImGui::BeginChildFrame
PUBLIC	?EndChildFrame@ImGui@@YAXXZ			; ImGui::EndChildFrame
PUBLIC	?ColorConvertU32ToFloat4@ImGui@@YA?AUImVec4@@I@Z ; ImGui::ColorConvertU32ToFloat4
PUBLIC	?ColorConvertFloat4ToU32@ImGui@@YAIABUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
PUBLIC	?ColorConvertRGBtoHSV@ImGui@@YAXMMMAAM00@Z	; ImGui::ColorConvertRGBtoHSV
PUBLIC	?ColorConvertHSVtoRGB@ImGui@@YAXMMMAAM00@Z	; ImGui::ColorConvertHSVtoRGB
PUBLIC	?GetKeyIndex@ImGui@@YAHH@Z			; ImGui::GetKeyIndex
PUBLIC	?IsKeyDown@ImGui@@YA_NH@Z			; ImGui::IsKeyDown
PUBLIC	?IsKeyPressed@ImGui@@YA_NH_N@Z			; ImGui::IsKeyPressed
PUBLIC	?IsKeyReleased@ImGui@@YA_NH@Z			; ImGui::IsKeyReleased
PUBLIC	?GetKeyPressedAmount@ImGui@@YAHHMM@Z		; ImGui::GetKeyPressedAmount
PUBLIC	?IsMouseDown@ImGui@@YA_NH@Z			; ImGui::IsMouseDown
PUBLIC	?IsMouseClicked@ImGui@@YA_NH_N@Z		; ImGui::IsMouseClicked
PUBLIC	?IsMouseDoubleClicked@ImGui@@YA_NH@Z		; ImGui::IsMouseDoubleClicked
PUBLIC	?IsMouseReleased@ImGui@@YA_NH@Z			; ImGui::IsMouseReleased
PUBLIC	?IsMouseDragging@ImGui@@YA_NHM@Z		; ImGui::IsMouseDragging
PUBLIC	?IsMouseHoveringRect@ImGui@@YA_NABUImVec2@@0_N@Z ; ImGui::IsMouseHoveringRect
PUBLIC	?GetMousePos@ImGui@@YA?AUImVec2@@XZ		; ImGui::GetMousePos
PUBLIC	?GetMousePosOnOpeningCurrentPopup@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetMousePosOnOpeningCurrentPopup
PUBLIC	?GetMouseDragDelta@ImGui@@YA?AUImVec2@@HM@Z	; ImGui::GetMouseDragDelta
PUBLIC	?ResetMouseDragDelta@ImGui@@YAXH@Z		; ImGui::ResetMouseDragDelta
PUBLIC	?GetMouseCursor@ImGui@@YAHXZ			; ImGui::GetMouseCursor
PUBLIC	?SetMouseCursor@ImGui@@YAXH@Z			; ImGui::SetMouseCursor
PUBLIC	?CaptureKeyboardFromApp@ImGui@@YAX_N@Z		; ImGui::CaptureKeyboardFromApp
PUBLIC	?CaptureMouseFromApp@ImGui@@YAX_N@Z		; ImGui::CaptureMouseFromApp
PUBLIC	?IsNavDragging@ImGui@@YA_NHM@Z			; ImGui::IsNavDragging
PUBLIC	?MemAlloc@ImGui@@YAPAXI@Z			; ImGui::MemAlloc
PUBLIC	?MemFree@ImGui@@YAXPAX@Z			; ImGui::MemFree
PUBLIC	?GetClipboardText@ImGui@@YAPBDXZ		; ImGui::GetClipboardText
PUBLIC	?SetClipboardText@ImGui@@YAXPBD@Z		; ImGui::SetClipboardText
PUBLIC	?GetVersion@ImGui@@YAPBDXZ			; ImGui::GetVersion
PUBLIC	?CreateContext@ImGui@@YAPAUImGuiContext@@P6APAXI@ZP6AXPAX@Z@Z ; ImGui::CreateContext
PUBLIC	?DestroyContext@ImGui@@YAXPAUImGuiContext@@@Z	; ImGui::DestroyContext
PUBLIC	?GetCurrentContext@ImGui@@YAPAUImGuiContext@@XZ	; ImGui::GetCurrentContext
PUBLIC	?SetCurrentContext@ImGui@@YAXPAUImGuiContext@@@Z ; ImGui::SetCurrentContext
PUBLIC	??0ImGuiStyle@@QAE@XZ				; ImGuiStyle::ImGuiStyle
PUBLIC	?AddInputCharacter@ImGuiIO@@QAEXG@Z		; ImGuiIO::AddInputCharacter
PUBLIC	?AddInputCharactersUTF8@ImGuiIO@@QAEXPBD@Z	; ImGuiIO::AddInputCharactersUTF8
PUBLIC	??0ImGuiIO@@QAE@XZ				; ImGuiIO::ImGuiIO
PUBLIC	??0TextRange@ImGuiTextFilter@@QAE@PBD0@Z	; ImGuiTextFilter::TextRange::TextRange
PUBLIC	?begin@TextRange@ImGuiTextFilter@@QBEPBDXZ	; ImGuiTextFilter::TextRange::begin
PUBLIC	?end@TextRange@ImGuiTextFilter@@QBEPBDXZ	; ImGuiTextFilter::TextRange::end
PUBLIC	?empty@TextRange@ImGuiTextFilter@@QBE_NXZ	; ImGuiTextFilter::TextRange::empty
PUBLIC	?front@TextRange@ImGuiTextFilter@@QBEDXZ	; ImGuiTextFilter::TextRange::front
PUBLIC	?is_blank@TextRange@ImGuiTextFilter@@SA_ND@Z	; ImGuiTextFilter::TextRange::is_blank
PUBLIC	?trim_blanks@TextRange@ImGuiTextFilter@@QAEXXZ	; ImGuiTextFilter::TextRange::trim_blanks
PUBLIC	?split@TextRange@ImGuiTextFilter@@QAEXDAAV?$ImVector@UTextRange@ImGuiTextFilter@@@@@Z ; ImGuiTextFilter::TextRange::split
PUBLIC	??0?$ImVector@UTextRange@ImGuiTextFilter@@@@QAE@XZ ; ImVector<ImGuiTextFilter::TextRange>::ImVector<ImGuiTextFilter::TextRange>
PUBLIC	??1?$ImVector@UTextRange@ImGuiTextFilter@@@@QAE@XZ ; ImVector<ImGuiTextFilter::TextRange>::~ImVector<ImGuiTextFilter::TextRange>
PUBLIC	?empty@?$ImVector@UTextRange@ImGuiTextFilter@@@@QBE_NXZ ; ImVector<ImGuiTextFilter::TextRange>::empty
PUBLIC	??A?$ImVector@UTextRange@ImGuiTextFilter@@@@QAEAAUTextRange@ImGuiTextFilter@@H@Z ; ImVector<ImGuiTextFilter::TextRange>::operator[]
PUBLIC	??A?$ImVector@UTextRange@ImGuiTextFilter@@@@QBEABUTextRange@ImGuiTextFilter@@H@Z ; ImVector<ImGuiTextFilter::TextRange>::operator[]
PUBLIC	?_grow_capacity@?$ImVector@UTextRange@ImGuiTextFilter@@@@QAEHH@Z ; ImVector<ImGuiTextFilter::TextRange>::_grow_capacity
PUBLIC	?resize@?$ImVector@UTextRange@ImGuiTextFilter@@@@QAEXH@Z ; ImVector<ImGuiTextFilter::TextRange>::resize
PUBLIC	?reserve@?$ImVector@UTextRange@ImGuiTextFilter@@@@QAEXH@Z ; ImVector<ImGuiTextFilter::TextRange>::reserve
PUBLIC	?push_back@?$ImVector@UTextRange@ImGuiTextFilter@@@@QAEXABUTextRange@ImGuiTextFilter@@@Z ; ImVector<ImGuiTextFilter::TextRange>::push_back
PUBLIC	??0ImGuiTextFilter@@QAE@PBD@Z			; ImGuiTextFilter::ImGuiTextFilter
PUBLIC	?Draw@ImGuiTextFilter@@QAE_NPBDM@Z		; ImGuiTextFilter::Draw
PUBLIC	?PassFilter@ImGuiTextFilter@@QBE_NPBD0@Z	; ImGuiTextFilter::PassFilter
PUBLIC	?Build@ImGuiTextFilter@@QAEXXZ			; ImGuiTextFilter::Build
PUBLIC	??0?$ImVector@D@@QAE@XZ				; ImVector<char>::ImVector<char>
PUBLIC	??1?$ImVector@D@@QAE@XZ				; ImVector<char>::~ImVector<char>
PUBLIC	??A?$ImVector@D@@QAEAADH@Z			; ImVector<char>::operator[]
PUBLIC	?clear@?$ImVector@D@@QAEXXZ			; ImVector<char>::clear
PUBLIC	?begin@?$ImVector@D@@QAEPADXZ			; ImVector<char>::begin
PUBLIC	?front@?$ImVector@D@@QBEABDXZ			; ImVector<char>::front
PUBLIC	?_grow_capacity@?$ImVector@D@@QAEHH@Z		; ImVector<char>::_grow_capacity
PUBLIC	?resize@?$ImVector@D@@QAEXH@Z			; ImVector<char>::resize
PUBLIC	?reserve@?$ImVector@D@@QAEXH@Z			; ImVector<char>::reserve
PUBLIC	?push_back@?$ImVector@D@@QAEXABD@Z		; ImVector<char>::push_back
PUBLIC	??0ImGuiTextBuffer@@QAE@XZ			; ImGuiTextBuffer::ImGuiTextBuffer
PUBLIC	?begin@ImGuiTextBuffer@@QBEPBDXZ		; ImGuiTextBuffer::begin
PUBLIC	?size@ImGuiTextBuffer@@QBEHXZ			; ImGuiTextBuffer::size
PUBLIC	?clear@ImGuiTextBuffer@@QAEXXZ			; ImGuiTextBuffer::clear
PUBLIC	?append@ImGuiTextBuffer@@QAAXPBDZZ		; ImGuiTextBuffer::append
PUBLIC	?appendv@ImGuiTextBuffer@@QAEXPBDPAD@Z		; ImGuiTextBuffer::appendv
PUBLIC	??1ImGuiTextBuffer@@QAE@XZ			; ImGuiTextBuffer::~ImGuiTextBuffer
PUBLIC	??_GImGuiTextBuffer@@QAEPAXI@Z			; ImGuiTextBuffer::`scalar deleting destructor'
PUBLIC	??0Pair@ImGuiStorage@@QAE@IH@Z			; ImGuiStorage::Pair::Pair
PUBLIC	??0Pair@ImGuiStorage@@QAE@IM@Z			; ImGuiStorage::Pair::Pair
PUBLIC	??0Pair@ImGuiStorage@@QAE@IPAX@Z		; ImGuiStorage::Pair::Pair
PUBLIC	??0?$ImVector@UPair@ImGuiStorage@@@@QAE@XZ	; ImVector<ImGuiStorage::Pair>::ImVector<ImGuiStorage::Pair>
PUBLIC	??1?$ImVector@UPair@ImGuiStorage@@@@QAE@XZ	; ImVector<ImGuiStorage::Pair>::~ImVector<ImGuiStorage::Pair>
PUBLIC	??A?$ImVector@UPair@ImGuiStorage@@@@QAEAAUPair@ImGuiStorage@@H@Z ; ImVector<ImGuiStorage::Pair>::operator[]
PUBLIC	?clear@?$ImVector@UPair@ImGuiStorage@@@@QAEXXZ	; ImVector<ImGuiStorage::Pair>::clear
PUBLIC	?begin@?$ImVector@UPair@ImGuiStorage@@@@QAEPAUPair@ImGuiStorage@@XZ ; ImVector<ImGuiStorage::Pair>::begin
PUBLIC	?end@?$ImVector@UPair@ImGuiStorage@@@@QAEPAUPair@ImGuiStorage@@XZ ; ImVector<ImGuiStorage::Pair>::end
PUBLIC	?end@?$ImVector@UPair@ImGuiStorage@@@@QBEPBUPair@ImGuiStorage@@XZ ; ImVector<ImGuiStorage::Pair>::end
PUBLIC	?reserve@?$ImVector@UPair@ImGuiStorage@@@@QAEXH@Z ; ImVector<ImGuiStorage::Pair>::reserve
PUBLIC	?insert@?$ImVector@UPair@ImGuiStorage@@@@QAEPAUPair@ImGuiStorage@@PBU23@ABU23@@Z ; ImVector<ImGuiStorage::Pair>::insert
PUBLIC	?Clear@ImGuiStorage@@QAEXXZ			; ImGuiStorage::Clear
PUBLIC	?GetInt@ImGuiStorage@@QBEHIH@Z			; ImGuiStorage::GetInt
PUBLIC	?SetInt@ImGuiStorage@@QAEXIH@Z			; ImGuiStorage::SetInt
PUBLIC	?GetBool@ImGuiStorage@@QBE_NI_N@Z		; ImGuiStorage::GetBool
PUBLIC	?SetBool@ImGuiStorage@@QAEXI_N@Z		; ImGuiStorage::SetBool
PUBLIC	?GetFloat@ImGuiStorage@@QBEMIM@Z		; ImGuiStorage::GetFloat
PUBLIC	?SetFloat@ImGuiStorage@@QAEXIM@Z		; ImGuiStorage::SetFloat
PUBLIC	?GetVoidPtr@ImGuiStorage@@QBEPAXI@Z		; ImGuiStorage::GetVoidPtr
PUBLIC	?SetVoidPtr@ImGuiStorage@@QAEXIPAX@Z		; ImGuiStorage::SetVoidPtr
PUBLIC	?GetIntRef@ImGuiStorage@@QAEPAHIH@Z		; ImGuiStorage::GetIntRef
PUBLIC	?GetBoolRef@ImGuiStorage@@QAEPA_NI_N@Z		; ImGuiStorage::GetBoolRef
PUBLIC	?GetFloatRef@ImGuiStorage@@QAEPAMIM@Z		; ImGuiStorage::GetFloatRef
PUBLIC	?GetVoidPtrRef@ImGuiStorage@@QAEPAPAXIPAX@Z	; ImGuiStorage::GetVoidPtrRef
PUBLIC	?SetAllInt@ImGuiStorage@@QAEXH@Z		; ImGuiStorage::SetAllInt
PUBLIC	??0ImGuiStorage@@QAE@XZ				; ImGuiStorage::ImGuiStorage
PUBLIC	??1ImGuiStorage@@QAE@XZ				; ImGuiStorage::~ImGuiStorage
PUBLIC	?DeleteChars@ImGuiTextEditCallbackData@@QAEXHH@Z ; ImGuiTextEditCallbackData::DeleteChars
PUBLIC	?InsertChars@ImGuiTextEditCallbackData@@QAEXHPBD0@Z ; ImGuiTextEditCallbackData::InsertChars
PUBLIC	??0ImGuiSizeConstraintCallbackData@@QAE@XZ	; ImGuiSizeConstraintCallbackData::ImGuiSizeConstraintCallbackData
PUBLIC	??0ImColor@@QAE@HHHH@Z				; ImColor::ImColor
PUBLIC	??0ImColor@@QAE@MMMM@Z				; ImColor::ImColor
PUBLIC	??BImColor@@QBEIXZ				; ImColor::operator unsigned int
PUBLIC	??BImColor@@QBE?AUImVec4@@XZ			; ImColor::operator ImVec4
PUBLIC	?HSV@ImColor@@SA?AU1@MMMM@Z			; ImColor::HSV
PUBLIC	??0ImGuiListClipper@@QAE@HM@Z			; ImGuiListClipper::ImGuiListClipper
PUBLIC	??1ImGuiListClipper@@QAE@XZ			; ImGuiListClipper::~ImGuiListClipper
PUBLIC	?Step@ImGuiListClipper@@QAE_NXZ			; ImGuiListClipper::Step
PUBLIC	?Begin@ImGuiListClipper@@QAEXHM@Z		; ImGuiListClipper::Begin
PUBLIC	?End@ImGuiListClipper@@QAEXXZ			; ImGuiListClipper::End
PUBLIC	??0?$ImVector@UImDrawCmd@@@@QAE@XZ		; ImVector<ImDrawCmd>::ImVector<ImDrawCmd>
PUBLIC	??1?$ImVector@UImDrawCmd@@@@QAE@XZ		; ImVector<ImDrawCmd>::~ImVector<ImDrawCmd>
PUBLIC	?empty@?$ImVector@UImDrawCmd@@@@QBE_NXZ		; ImVector<ImDrawCmd>::empty
PUBLIC	?begin@?$ImVector@UImDrawCmd@@@@QAEPAUImDrawCmd@@XZ ; ImVector<ImDrawCmd>::begin
PUBLIC	?end@?$ImVector@UImDrawCmd@@@@QAEPAUImDrawCmd@@XZ ; ImVector<ImDrawCmd>::end
PUBLIC	?back@?$ImVector@UImDrawCmd@@@@QAEAAUImDrawCmd@@XZ ; ImVector<ImDrawCmd>::back
PUBLIC	?pop_back@?$ImVector@UImDrawCmd@@@@QAEXXZ	; ImVector<ImDrawCmd>::pop_back
PUBLIC	??0?$ImVector@G@@QAE@XZ				; ImVector<unsigned short>::ImVector<unsigned short>
PUBLIC	??1?$ImVector@G@@QAE@XZ				; ImVector<unsigned short>::~ImVector<unsigned short>
PUBLIC	??A?$ImVector@G@@QAEAAGH@Z			; ImVector<unsigned short>::operator[]
PUBLIC	??A?$ImVector@G@@QBEABGH@Z			; ImVector<unsigned short>::operator[]
PUBLIC	?clear@?$ImVector@G@@QAEXXZ			; ImVector<unsigned short>::clear
PUBLIC	?_grow_capacity@?$ImVector@G@@QAEHH@Z		; ImVector<unsigned short>::_grow_capacity
PUBLIC	?resize@?$ImVector@G@@QAEXH@Z			; ImVector<unsigned short>::resize
PUBLIC	?reserve@?$ImVector@G@@QAEXH@Z			; ImVector<unsigned short>::reserve
PUBLIC	??0?$ImVector@UImDrawVert@@@@QAE@XZ		; ImVector<ImDrawVert>::ImVector<ImDrawVert>
PUBLIC	??1?$ImVector@UImDrawVert@@@@QAE@XZ		; ImVector<ImDrawVert>::~ImVector<ImDrawVert>
PUBLIC	?empty@?$ImVector@UImDrawVert@@@@QBE_NXZ	; ImVector<ImDrawVert>::empty
PUBLIC	??A?$ImVector@UImDrawVert@@@@QAEAAUImDrawVert@@H@Z ; ImVector<ImDrawVert>::operator[]
PUBLIC	??0?$ImVector@UImVec4@@@@QAE@XZ			; ImVector<ImVec4>::ImVector<ImVec4>
PUBLIC	??1?$ImVector@UImVec4@@@@QAE@XZ			; ImVector<ImVec4>::~ImVector<ImVec4>
PUBLIC	?back@?$ImVector@UImVec4@@@@QAEAAUImVec4@@XZ	; ImVector<ImVec4>::back
PUBLIC	??0?$ImVector@PAX@@QAE@XZ			; ImVector<void *>::ImVector<void *>
PUBLIC	??1?$ImVector@PAX@@QAE@XZ			; ImVector<void *>::~ImVector<void *>
PUBLIC	??0?$ImVector@UImVec2@@@@QAE@XZ			; ImVector<ImVec2>::ImVector<ImVec2>
PUBLIC	??1?$ImVector@UImVec2@@@@QAE@XZ			; ImVector<ImVec2>::~ImVector<ImVec2>
PUBLIC	?_grow_capacity@?$ImVector@UImVec2@@@@QAEHH@Z	; ImVector<ImVec2>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImVec2@@@@QAEXH@Z		; ImVector<ImVec2>::resize
PUBLIC	?reserve@?$ImVector@UImVec2@@@@QAEXH@Z		; ImVector<ImVec2>::reserve
PUBLIC	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back
PUBLIC	??0?$ImVector@UImDrawChannel@@@@QAE@XZ		; ImVector<ImDrawChannel>::ImVector<ImDrawChannel>
PUBLIC	??1?$ImVector@UImDrawChannel@@@@QAE@XZ		; ImVector<ImDrawChannel>::~ImVector<ImDrawChannel>
PUBLIC	??0ImDrawList@@QAE@XZ				; ImDrawList::ImDrawList
PUBLIC	??1ImDrawList@@QAE@XZ				; ImDrawList::~ImDrawList
PUBLIC	?PathClear@ImDrawList@@QAEXXZ			; ImDrawList::PathClear
PUBLIC	?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z	; ImDrawList::PathLineTo
PUBLIC	?PathFill@ImDrawList@@QAEXI@Z			; ImDrawList::PathFill
PUBLIC	?PathStroke@ImDrawList@@QAEXI_NM@Z		; ImDrawList::PathStroke
PUBLIC	??_GImDrawList@@QAEPAXI@Z			; ImDrawList::`scalar deleting destructor'
PUBLIC	??0ImDrawData@@QAE@XZ				; ImDrawData::ImDrawData
PUBLIC	??0?$ImVector@PAUImFont@@@@QAE@XZ		; ImVector<ImFont *>::ImVector<ImFont *>
PUBLIC	??1?$ImVector@PAUImFont@@@@QAE@XZ		; ImVector<ImFont *>::~ImVector<ImFont *>
PUBLIC	?empty@?$ImVector@PAUImFont@@@@QBE_NXZ		; ImVector<ImFont *>::empty
PUBLIC	??A?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@H@Z	; ImVector<ImFont *>::operator[]
PUBLIC	?clear@?$ImVector@PAUImFont@@@@QAEXXZ		; ImVector<ImFont *>::clear
PUBLIC	?back@?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@XZ ; ImVector<ImFont *>::back
PUBLIC	?_grow_capacity@?$ImVector@PAUImFont@@@@QAEHH@Z	; ImVector<ImFont *>::_grow_capacity
PUBLIC	?reserve@?$ImVector@PAUImFont@@@@QAEXH@Z	; ImVector<ImFont *>::reserve
PUBLIC	?push_back@?$ImVector@PAUImFont@@@@QAEXABQAUImFont@@@Z ; ImVector<ImFont *>::push_back
PUBLIC	?pop_back@?$ImVector@PAUImFont@@@@QAEXXZ	; ImVector<ImFont *>::pop_back
PUBLIC	??0?$ImVector@M@@QAE@XZ				; ImVector<float>::ImVector<float>
PUBLIC	??1?$ImVector@M@@QAE@XZ				; ImVector<float>::~ImVector<float>
PUBLIC	?empty@?$ImVector@M@@QBE_NXZ			; ImVector<float>::empty
PUBLIC	??A?$ImVector@M@@QBEABMH@Z			; ImVector<float>::operator[]
PUBLIC	?back@?$ImVector@M@@QAEAAMXZ			; ImVector<float>::back
PUBLIC	?_grow_capacity@?$ImVector@M@@QAEHH@Z		; ImVector<float>::_grow_capacity
PUBLIC	?resize@?$ImVector@M@@QAEXH@Z			; ImVector<float>::resize
PUBLIC	?reserve@?$ImVector@M@@QAEXH@Z			; ImVector<float>::reserve
PUBLIC	?push_back@?$ImVector@M@@QAEXABM@Z		; ImVector<float>::push_back
PUBLIC	?pop_back@?$ImVector@M@@QAEXXZ			; ImVector<float>::pop_back
PUBLIC	?GetCharAdvance@ImFont@@QBEMG@Z			; ImFont::GetCharAdvance
PUBLIC	_fabsf
PUBLIC	_fmodf
PUBLIC	_powf
PUBLIC	_sqrtf
PUBLIC	?ImTextStrToUtf8@@YAHPADHPBG1@Z			; ImTextStrToUtf8
PUBLIC	?ImTextCharFromUtf8@@YAHPAIPBD1@Z		; ImTextCharFromUtf8
PUBLIC	?ImTextStrFromUtf8@@YAHPAGHPBD1PAPBD@Z		; ImTextStrFromUtf8
PUBLIC	?ImTextCountCharsFromUtf8@@YAHPBD0@Z		; ImTextCountCharsFromUtf8
PUBLIC	?ImTextCountUtf8BytesFromStr@@YAHPBG0@Z		; ImTextCountUtf8BytesFromStr
PUBLIC	?ImHash@@YAIPBXHI@Z				; ImHash
PUBLIC	?ImFileLoadToMemory@@YAPAXPBD0PAHH@Z		; ImFileLoadToMemory
PUBLIC	?ImFileOpen@@YAPAU_iobuf@@PBD0@Z		; ImFileOpen
PUBLIC	?ImIsPointInTriangle@@YA_NABUImVec2@@000@Z	; ImIsPointInTriangle
PUBLIC	?ImStricmp@@YAHPBD0@Z				; ImStricmp
PUBLIC	?ImStrnicmp@@YAHPBD0H@Z				; ImStrnicmp
PUBLIC	?ImStrdup@@YAPADPBD@Z				; ImStrdup
PUBLIC	?ImStrlenW@@YAHPBG@Z				; ImStrlenW
PUBLIC	?ImStrbolW@@YAPBGPBG0@Z				; ImStrbolW
PUBLIC	?ImStristr@@YAPBDPBD000@Z			; ImStristr
PUBLIC	?ImFormatString@@YAHPADHPBDZZ			; ImFormatString
PUBLIC	?ImFormatStringV@@YAHPADHPBD0@Z			; ImFormatStringV
PUBLIC	??2@YAPAXIUImPlacementNewDummy@@PAX@Z		; operator new
PUBLIC	??3@YAXPAXUImPlacementNewDummy@@0@Z		; operator delete
PUBLIC	??0ImRect@@QAE@XZ				; ImRect::ImRect
PUBLIC	??0ImRect@@QAE@ABUImVec2@@0@Z			; ImRect::ImRect
PUBLIC	??0ImRect@@QAE@ABUImVec4@@@Z			; ImRect::ImRect
PUBLIC	??0ImRect@@QAE@MMMM@Z				; ImRect::ImRect
PUBLIC	?GetCenter@ImRect@@QBE?AUImVec2@@XZ		; ImRect::GetCenter
PUBLIC	?GetSize@ImRect@@QBE?AUImVec2@@XZ		; ImRect::GetSize
PUBLIC	?GetWidth@ImRect@@QBEMXZ			; ImRect::GetWidth
PUBLIC	?GetHeight@ImRect@@QBEMXZ			; ImRect::GetHeight
PUBLIC	?GetTL@ImRect@@QBE?AUImVec2@@XZ			; ImRect::GetTL
PUBLIC	?GetTR@ImRect@@QBE?AUImVec2@@XZ			; ImRect::GetTR
PUBLIC	?GetBL@ImRect@@QBE?AUImVec2@@XZ			; ImRect::GetBL
PUBLIC	?GetBR@ImRect@@QBE?AUImVec2@@XZ			; ImRect::GetBR
PUBLIC	?Contains@ImRect@@QBE_NABUImVec2@@@Z		; ImRect::Contains
PUBLIC	?Contains@ImRect@@QBE_NABU1@@Z			; ImRect::Contains
PUBLIC	?Overlaps@ImRect@@QBE_NABU1@@Z			; ImRect::Overlaps
PUBLIC	?Add@ImRect@@QAEXABUImVec2@@@Z			; ImRect::Add
PUBLIC	?Add@ImRect@@QAEXABU1@@Z			; ImRect::Add
PUBLIC	?Expand@ImRect@@QAEXM@Z				; ImRect::Expand
PUBLIC	?Expand@ImRect@@QAEXABUImVec2@@@Z		; ImRect::Expand
PUBLIC	?Translate@ImRect@@QAEXABUImVec2@@@Z		; ImRect::Translate
PUBLIC	?Clip@ImRect@@QBEXAAU1@@Z			; ImRect::Clip
PUBLIC	?Floor@ImRect@@QAEXXZ				; ImRect::Floor
PUBLIC	?GetClosestPoint@ImRect@@QBE?AUImVec2@@U2@_N@Z	; ImRect::GetClosestPoint
PUBLIC	??4ImRect@@QAEAAU0@ABU0@@Z			; ImRect::operator=
PUBLIC	??4ImRect@@QAEAAU0@$$QAU0@@Z			; ImRect::operator=
PUBLIC	??0ImGuiColMod@@QAE@XZ				; ImGuiColMod::ImGuiColMod
PUBLIC	??0ImGuiStyleMod@@QAE@HM@Z			; ImGuiStyleMod::ImGuiStyleMod
PUBLIC	??0ImGuiStyleMod@@QAE@HUImVec2@@@Z		; ImGuiStyleMod::ImGuiStyleMod
PUBLIC	??0ImGuiSimpleColumns@@QAE@XZ			; ImGuiSimpleColumns::ImGuiSimpleColumns
PUBLIC	?Update@ImGuiSimpleColumns@@QAEXHM_N@Z		; ImGuiSimpleColumns::Update
PUBLIC	?DeclColumns@ImGuiSimpleColumns@@QAEMMMM@Z	; ImGuiSimpleColumns::DeclColumns
PUBLIC	?CalcExtraSpace@ImGuiSimpleColumns@@QAEMM@Z	; ImGuiSimpleColumns::CalcExtraSpace
PUBLIC	??4ImGuiSimpleColumns@@QAEAAU0@ABU0@@Z		; ImGuiSimpleColumns::operator=
PUBLIC	??4ImGuiSimpleColumns@@QAEAAU0@$$QAU0@@Z	; ImGuiSimpleColumns::operator=
PUBLIC	??0ImGuiTextEditState@@QAE@XZ			; ImGuiTextEditState::ImGuiTextEditState
PUBLIC	?CursorAnimReset@ImGuiTextEditState@@QAEXXZ	; ImGuiTextEditState::CursorAnimReset
PUBLIC	?CursorClamp@ImGuiTextEditState@@QAEXXZ		; ImGuiTextEditState::CursorClamp
PUBLIC	?HasSelection@ImGuiTextEditState@@QBE_NXZ	; ImGuiTextEditState::HasSelection
PUBLIC	?ClearSelection@ImGuiTextEditState@@QAEXXZ	; ImGuiTextEditState::ClearSelection
PUBLIC	?SelectAll@ImGuiTextEditState@@QAEXXZ		; ImGuiTextEditState::SelectAll
PUBLIC	?OnKeyPressed@ImGuiTextEditState@@QAEXH@Z	; ImGuiTextEditState::OnKeyPressed
PUBLIC	??1ImGuiTextEditState@@QAE@XZ			; ImGuiTextEditState::~ImGuiTextEditState
PUBLIC	??4ImGuiTextEditState@@QAEAAU0@ABU0@@Z		; ImGuiTextEditState::operator=
PUBLIC	??4ImGuiTextEditState@@QAEAAU0@$$QAU0@@Z	; ImGuiTextEditState::operator=
PUBLIC	??0ImGuiMouseCursorData@@QAE@XZ			; ImGuiMouseCursorData::ImGuiMouseCursorData
PUBLIC	??0ImGuiPopupRef@@QAE@IPAUImGuiWindow@@IABUImVec2@@1@Z ; ImGuiPopupRef::ImGuiPopupRef
PUBLIC	??0?$ImVector@PAUImGuiWindow@@@@QAE@XZ		; ImVector<ImGuiWindow *>::ImVector<ImGuiWindow *>
PUBLIC	??1?$ImVector@PAUImGuiWindow@@@@QAE@XZ		; ImVector<ImGuiWindow *>::~ImVector<ImGuiWindow *>
PUBLIC	?empty@?$ImVector@PAUImGuiWindow@@@@QBE_NXZ	; ImVector<ImGuiWindow *>::empty
PUBLIC	??A?$ImVector@PAUImGuiWindow@@@@QAEAAPAUImGuiWindow@@H@Z ; ImVector<ImGuiWindow *>::operator[]
PUBLIC	?clear@?$ImVector@PAUImGuiWindow@@@@QAEXXZ	; ImVector<ImGuiWindow *>::clear
PUBLIC	?begin@?$ImVector@PAUImGuiWindow@@@@QAEPAPAUImGuiWindow@@XZ ; ImVector<ImGuiWindow *>::begin
PUBLIC	?back@?$ImVector@PAUImGuiWindow@@@@QAEAAPAUImGuiWindow@@XZ ; ImVector<ImGuiWindow *>::back
PUBLIC	?swap@?$ImVector@PAUImGuiWindow@@@@QAEXAAV1@@Z	; ImVector<ImGuiWindow *>::swap
PUBLIC	?_grow_capacity@?$ImVector@PAUImGuiWindow@@@@QAEHH@Z ; ImVector<ImGuiWindow *>::_grow_capacity
PUBLIC	?resize@?$ImVector@PAUImGuiWindow@@@@QAEXH@Z	; ImVector<ImGuiWindow *>::resize
PUBLIC	?reserve@?$ImVector@PAUImGuiWindow@@@@QAEXH@Z	; ImVector<ImGuiWindow *>::reserve
PUBLIC	?push_back@?$ImVector@PAUImGuiWindow@@@@QAEXABQAUImGuiWindow@@@Z ; ImVector<ImGuiWindow *>::push_back
PUBLIC	?pop_back@?$ImVector@PAUImGuiWindow@@@@QAEXXZ	; ImVector<ImGuiWindow *>::pop_back
PUBLIC	?erase@?$ImVector@PAUImGuiWindow@@@@QAEPAPAUImGuiWindow@@PBQAU2@@Z ; ImVector<ImGuiWindow *>::erase
PUBLIC	?insert@?$ImVector@PAUImGuiWindow@@@@QAEPAPAUImGuiWindow@@PBQAU2@ABQAU2@@Z ; ImVector<ImGuiWindow *>::insert
PUBLIC	??0?$ImVector@UImGuiIniData@@@@QAE@XZ		; ImVector<ImGuiIniData>::ImVector<ImGuiIniData>
PUBLIC	??1?$ImVector@UImGuiIniData@@@@QAE@XZ		; ImVector<ImGuiIniData>::~ImVector<ImGuiIniData>
PUBLIC	??A?$ImVector@UImGuiIniData@@@@QAEAAUImGuiIniData@@H@Z ; ImVector<ImGuiIniData>::operator[]
PUBLIC	?clear@?$ImVector@UImGuiIniData@@@@QAEXXZ	; ImVector<ImGuiIniData>::clear
PUBLIC	?back@?$ImVector@UImGuiIniData@@@@QAEAAUImGuiIniData@@XZ ; ImVector<ImGuiIniData>::back
PUBLIC	?_grow_capacity@?$ImVector@UImGuiIniData@@@@QAEHH@Z ; ImVector<ImGuiIniData>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImGuiIniData@@@@QAEXH@Z	; ImVector<ImGuiIniData>::resize
PUBLIC	?reserve@?$ImVector@UImGuiIniData@@@@QAEXH@Z	; ImVector<ImGuiIniData>::reserve
PUBLIC	??0?$ImVector@UImGuiColMod@@@@QAE@XZ		; ImVector<ImGuiColMod>::ImVector<ImGuiColMod>
PUBLIC	??1?$ImVector@UImGuiColMod@@@@QAE@XZ		; ImVector<ImGuiColMod>::~ImVector<ImGuiColMod>
PUBLIC	?clear@?$ImVector@UImGuiColMod@@@@QAEXXZ	; ImVector<ImGuiColMod>::clear
PUBLIC	?back@?$ImVector@UImGuiColMod@@@@QAEAAUImGuiColMod@@XZ ; ImVector<ImGuiColMod>::back
PUBLIC	?_grow_capacity@?$ImVector@UImGuiColMod@@@@QAEHH@Z ; ImVector<ImGuiColMod>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImGuiColMod@@@@QAEXH@Z	; ImVector<ImGuiColMod>::reserve
PUBLIC	?push_back@?$ImVector@UImGuiColMod@@@@QAEXABUImGuiColMod@@@Z ; ImVector<ImGuiColMod>::push_back
PUBLIC	?pop_back@?$ImVector@UImGuiColMod@@@@QAEXXZ	; ImVector<ImGuiColMod>::pop_back
PUBLIC	??0?$ImVector@UImGuiStyleMod@@@@QAE@XZ		; ImVector<ImGuiStyleMod>::ImVector<ImGuiStyleMod>
PUBLIC	??1?$ImVector@UImGuiStyleMod@@@@QAE@XZ		; ImVector<ImGuiStyleMod>::~ImVector<ImGuiStyleMod>
PUBLIC	?clear@?$ImVector@UImGuiStyleMod@@@@QAEXXZ	; ImVector<ImGuiStyleMod>::clear
PUBLIC	?back@?$ImVector@UImGuiStyleMod@@@@QAEAAUImGuiStyleMod@@XZ ; ImVector<ImGuiStyleMod>::back
PUBLIC	?_grow_capacity@?$ImVector@UImGuiStyleMod@@@@QAEHH@Z ; ImVector<ImGuiStyleMod>::_grow_capacity
PUBLIC	?reserve@?$ImVector@UImGuiStyleMod@@@@QAEXH@Z	; ImVector<ImGuiStyleMod>::reserve
PUBLIC	?push_back@?$ImVector@UImGuiStyleMod@@@@QAEXABUImGuiStyleMod@@@Z ; ImVector<ImGuiStyleMod>::push_back
PUBLIC	?pop_back@?$ImVector@UImGuiStyleMod@@@@QAEXXZ	; ImVector<ImGuiStyleMod>::pop_back
PUBLIC	??0?$ImVector@UImGuiPopupRef@@@@QAE@XZ		; ImVector<ImGuiPopupRef>::ImVector<ImGuiPopupRef>
PUBLIC	??1?$ImVector@UImGuiPopupRef@@@@QAE@XZ		; ImVector<ImGuiPopupRef>::~ImVector<ImGuiPopupRef>
PUBLIC	?empty@?$ImVector@UImGuiPopupRef@@@@QBE_NXZ	; ImVector<ImGuiPopupRef>::empty
PUBLIC	??A?$ImVector@UImGuiPopupRef@@@@QAEAAUImGuiPopupRef@@H@Z ; ImVector<ImGuiPopupRef>::operator[]
PUBLIC	?clear@?$ImVector@UImGuiPopupRef@@@@QAEXXZ	; ImVector<ImGuiPopupRef>::clear
PUBLIC	?back@?$ImVector@UImGuiPopupRef@@@@QAEAAUImGuiPopupRef@@XZ ; ImVector<ImGuiPopupRef>::back
PUBLIC	?_grow_capacity@?$ImVector@UImGuiPopupRef@@@@QAEHH@Z ; ImVector<ImGuiPopupRef>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImGuiPopupRef@@@@QAEXH@Z	; ImVector<ImGuiPopupRef>::resize
PUBLIC	?reserve@?$ImVector@UImGuiPopupRef@@@@QAEXH@Z	; ImVector<ImGuiPopupRef>::reserve
PUBLIC	?push_back@?$ImVector@UImGuiPopupRef@@@@QAEXABUImGuiPopupRef@@@Z ; ImVector<ImGuiPopupRef>::push_back
PUBLIC	?pop_back@?$ImVector@UImGuiPopupRef@@@@QAEXXZ	; ImVector<ImGuiPopupRef>::pop_back
PUBLIC	??0?$ImVector@PAUImDrawList@@@@QAE@XZ		; ImVector<ImDrawList *>::ImVector<ImDrawList *>
PUBLIC	??1?$ImVector@PAUImDrawList@@@@QAE@XZ		; ImVector<ImDrawList *>::~ImVector<ImDrawList *>
PUBLIC	?empty@?$ImVector@PAUImDrawList@@@@QBE_NXZ	; ImVector<ImDrawList *>::empty
PUBLIC	??A?$ImVector@PAUImDrawList@@@@QAEAAPAUImDrawList@@H@Z ; ImVector<ImDrawList *>::operator[]
PUBLIC	?clear@?$ImVector@PAUImDrawList@@@@QAEXXZ	; ImVector<ImDrawList *>::clear
PUBLIC	?_grow_capacity@?$ImVector@PAUImDrawList@@@@QAEHH@Z ; ImVector<ImDrawList *>::_grow_capacity
PUBLIC	?resize@?$ImVector@PAUImDrawList@@@@QAEXH@Z	; ImVector<ImDrawList *>::resize
PUBLIC	?reserve@?$ImVector@PAUImDrawList@@@@QAEXH@Z	; ImVector<ImDrawList *>::reserve
PUBLIC	?push_back@?$ImVector@PAUImDrawList@@@@QAEXABQAUImDrawList@@@Z ; ImVector<ImDrawList *>::push_back
PUBLIC	??0ImGuiContext@@QAE@XZ				; ImGuiContext::ImGuiContext
PUBLIC	??1ImGuiContext@@QAE@XZ				; ImGuiContext::~ImGuiContext
PUBLIC	??_GImGuiContext@@QAEPAXI@Z			; ImGuiContext::`scalar deleting destructor'
PUBLIC	??0?$ImVector@H@@QAE@XZ				; ImVector<int>::ImVector<int>
PUBLIC	??1?$ImVector@H@@QAE@XZ				; ImVector<int>::~ImVector<int>
PUBLIC	?empty@?$ImVector@H@@QBE_NXZ			; ImVector<int>::empty
PUBLIC	?back@?$ImVector@H@@QAEAAHXZ			; ImVector<int>::back
PUBLIC	?_grow_capacity@?$ImVector@H@@QAEHH@Z		; ImVector<int>::_grow_capacity
PUBLIC	?resize@?$ImVector@H@@QAEXH@Z			; ImVector<int>::resize
PUBLIC	?reserve@?$ImVector@H@@QAEXH@Z			; ImVector<int>::reserve
PUBLIC	?push_back@?$ImVector@H@@QAEXABH@Z		; ImVector<int>::push_back
PUBLIC	?pop_back@?$ImVector@H@@QAEXXZ			; ImVector<int>::pop_back
PUBLIC	??0?$ImVector@UImGuiGroupData@@@@QAE@XZ		; ImVector<ImGuiGroupData>::ImVector<ImGuiGroupData>
PUBLIC	??1?$ImVector@UImGuiGroupData@@@@QAE@XZ		; ImVector<ImGuiGroupData>::~ImVector<ImGuiGroupData>
PUBLIC	?empty@?$ImVector@UImGuiGroupData@@@@QBE_NXZ	; ImVector<ImGuiGroupData>::empty
PUBLIC	?back@?$ImVector@UImGuiGroupData@@@@QAEAAUImGuiGroupData@@XZ ; ImVector<ImGuiGroupData>::back
PUBLIC	?_grow_capacity@?$ImVector@UImGuiGroupData@@@@QAEHH@Z ; ImVector<ImGuiGroupData>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImGuiGroupData@@@@QAEXH@Z	; ImVector<ImGuiGroupData>::resize
PUBLIC	?reserve@?$ImVector@UImGuiGroupData@@@@QAEXH@Z	; ImVector<ImGuiGroupData>::reserve
PUBLIC	?pop_back@?$ImVector@UImGuiGroupData@@@@QAEXXZ	; ImVector<ImGuiGroupData>::pop_back
PUBLIC	??0?$ImVector@UImGuiColumnData@@@@QAE@XZ	; ImVector<ImGuiColumnData>::ImVector<ImGuiColumnData>
PUBLIC	??1?$ImVector@UImGuiColumnData@@@@QAE@XZ	; ImVector<ImGuiColumnData>::~ImVector<ImGuiColumnData>
PUBLIC	??A?$ImVector@UImGuiColumnData@@@@QAEAAUImGuiColumnData@@H@Z ; ImVector<ImGuiColumnData>::operator[]
PUBLIC	?_grow_capacity@?$ImVector@UImGuiColumnData@@@@QAEHH@Z ; ImVector<ImGuiColumnData>::_grow_capacity
PUBLIC	?resize@?$ImVector@UImGuiColumnData@@@@QAEXH@Z	; ImVector<ImGuiColumnData>::resize
PUBLIC	?reserve@?$ImVector@UImGuiColumnData@@@@QAEXH@Z	; ImVector<ImGuiColumnData>::reserve
PUBLIC	??0ImGuiDrawContext@@QAE@XZ			; ImGuiDrawContext::ImGuiDrawContext
PUBLIC	??1ImGuiDrawContext@@QAE@XZ			; ImGuiDrawContext::~ImGuiDrawContext
PUBLIC	??4ImGuiDrawContext@@QAEAAU0@ABU0@@Z		; ImGuiDrawContext::operator=
PUBLIC	??4ImGuiDrawContext@@QAEAAU0@$$QAU0@@Z		; ImGuiDrawContext::operator=
PUBLIC	??0?$ImVector@I@@QAE@XZ				; ImVector<unsigned int>::ImVector<unsigned int>
PUBLIC	??1?$ImVector@I@@QAE@XZ				; ImVector<unsigned int>::~ImVector<unsigned int>
PUBLIC	??A?$ImVector@I@@QAEAAIH@Z			; ImVector<unsigned int>::operator[]
PUBLIC	?back@?$ImVector@I@@QAEAAIXZ			; ImVector<unsigned int>::back
PUBLIC	?_grow_capacity@?$ImVector@I@@QAEHH@Z		; ImVector<unsigned int>::_grow_capacity
PUBLIC	?resize@?$ImVector@I@@QAEXH@Z			; ImVector<unsigned int>::resize
PUBLIC	?reserve@?$ImVector@I@@QAEXH@Z			; ImVector<unsigned int>::reserve
PUBLIC	?push_back@?$ImVector@I@@QAEXABI@Z		; ImVector<unsigned int>::push_back
PUBLIC	?pop_back@?$ImVector@I@@QAEXXZ			; ImVector<unsigned int>::pop_back
PUBLIC	??0ImGuiWindow@@QAE@PBD@Z			; ImGuiWindow::ImGuiWindow
PUBLIC	??1ImGuiWindow@@QAE@XZ				; ImGuiWindow::~ImGuiWindow
PUBLIC	?GetID@ImGuiWindow@@QAEIPBD0@Z			; ImGuiWindow::GetID
PUBLIC	?GetID@ImGuiWindow@@QAEIPBX@Z			; ImGuiWindow::GetID
PUBLIC	?GetIDNoKeepAlive@ImGuiWindow@@QAEIPBD0@Z	; ImGuiWindow::GetIDNoKeepAlive
PUBLIC	?GetChildID@ImGuiWindow@@QAEIPAU1@@Z		; ImGuiWindow::GetChildID
PUBLIC	?Rect@ImGuiWindow@@QBE?AUImRect@@XZ		; ImGuiWindow::Rect
PUBLIC	?CalcFontSize@ImGuiWindow@@QBEMXZ		; ImGuiWindow::CalcFontSize
PUBLIC	?TitleBarHeight@ImGuiWindow@@QBEMXZ		; ImGuiWindow::TitleBarHeight
PUBLIC	?TitleBarRect@ImGuiWindow@@QBE?AUImRect@@XZ	; ImGuiWindow::TitleBarRect
PUBLIC	?MenuBarHeight@ImGuiWindow@@QBEMXZ		; ImGuiWindow::MenuBarHeight
PUBLIC	?MenuBarRect@ImGuiWindow@@QBE?AUImRect@@XZ	; ImGuiWindow::MenuBarRect
PUBLIC	??4ImGuiWindow@@QAEAAU0@ABU0@@Z			; ImGuiWindow::operator=
PUBLIC	??_GImGuiWindow@@QAEPAXI@Z			; ImGuiWindow::`scalar deleting destructor'
PUBLIC	?GetCurrentWindowRead@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetCurrentWindowRead
PUBLIC	?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ	; ImGui::GetCurrentWindow
PUBLIC	?GetParentWindow@ImGui@@YAPAUImGuiWindow@@XZ	; ImGui::GetParentWindow
PUBLIC	?FindWindowByName@ImGui@@YAPAUImGuiWindow@@PBD@Z ; ImGui::FindWindowByName
PUBLIC	?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z	; ImGui::FocusWindow
PUBLIC	?EndFrame@ImGui@@YAXXZ				; ImGui::EndFrame
PUBLIC	?SetActiveID@ImGui@@YAXIPAUImGuiWindow@@@Z	; ImGui::SetActiveID
PUBLIC	?SetActiveIDNoNav@ImGui@@YAXIPAUImGuiWindow@@@Z	; ImGui::SetActiveIDNoNav
PUBLIC	?ClearActiveID@ImGui@@YAXXZ			; ImGui::ClearActiveID
PUBLIC	?SetHoveredID@ImGui@@YAXI@Z			; ImGui::SetHoveredID
PUBLIC	?KeepAliveID@ImGui@@YAXI@Z			; ImGui::KeepAliveID
PUBLIC	?ItemSize@ImGui@@YAXABUImVec2@@M@Z		; ImGui::ItemSize
PUBLIC	?ItemSize@ImGui@@YAXABUImRect@@M@Z		; ImGui::ItemSize
PUBLIC	?ItemAdd@ImGui@@YA_NABUImRect@@PBIPBU2@@Z	; ImGui::ItemAdd
PUBLIC	?IsClippedEx@ImGui@@YA_NABUImRect@@PBI_N@Z	; ImGui::IsClippedEx
PUBLIC	?IsHovered@ImGui@@YA_NABUImRect@@I_N@Z		; ImGui::IsHovered
PUBLIC	?FocusableItemRegister@ImGui@@YA_NPAUImGuiWindow@@I_N@Z ; ImGui::FocusableItemRegister
PUBLIC	?FocusableItemUnregister@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusableItemUnregister
PUBLIC	?CalcItemSize@ImGui@@YA?AUImVec2@@U2@MM@Z	; ImGui::CalcItemSize
PUBLIC	?CalcWrapWidthForPos@ImGui@@YAMABUImVec2@@M@Z	; ImGui::CalcWrapWidthForPos
PUBLIC	?PushItemFlag@ImGui@@YAXH_N@Z			; ImGui::PushItemFlag
PUBLIC	?PopItemFlag@ImGui@@YAXXZ			; ImGui::PopItemFlag
PUBLIC	?OpenPopupEx@ImGui@@YAXPBD_N@Z			; ImGui::OpenPopupEx
PUBLIC	?CalcTypematicPressedRepeatAmount@ImGui@@YAHMMMM@Z ; ImGui::CalcTypematicPressedRepeatAmount
PUBLIC	?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z		; ImGui::RenderText
PUBLIC	?RenderTextWrapped@ImGui@@YAXUImVec2@@PBD1M@Z	; ImGui::RenderTextWrapped
PUBLIC	?RenderTextClipped@ImGui@@YAXABUImVec2@@0PBD1PBU2@0PBUImRect@@@Z ; ImGui::RenderTextClipped
PUBLIC	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z		; ImGui::RenderFrame
PUBLIC	?RenderCollapseTriangle@ImGui@@YAXUImVec2@@_NM@Z ; ImGui::RenderCollapseTriangle
PUBLIC	?RenderBullet@ImGui@@YAXUImVec2@@@Z		; ImGui::RenderBullet
PUBLIC	?RenderCheckMark@ImGui@@YAXUImVec2@@I@Z		; ImGui::RenderCheckMark
PUBLIC	?RenderNavHighlight@ImGui@@YAXABUImRect@@I@Z	; ImGui::RenderNavHighlight
PUBLIC	?FindRenderedTextEnd@ImGui@@YAPBDPBD0@Z		; ImGui::FindRenderedTextEnd
PUBLIC	?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z	; ImGui::ButtonBehavior
PUBLIC	?ButtonEx@ImGui@@YA_NPBDABUImVec2@@H@Z		; ImGui::ButtonEx
PUBLIC	?CloseButton@ImGui@@YA_NIABUImVec2@@M@Z		; ImGui::CloseButton
PUBLIC	?SliderBehavior@ImGui@@YA_NABUImRect@@IPAMMMMHH@Z ; ImGui::SliderBehavior
PUBLIC	?SliderFloatN@ImGui@@YA_NPBDPAMHMM0M@Z		; ImGui::SliderFloatN
PUBLIC	?SliderIntN@ImGui@@YA_NPBDPAHHHH0@Z		; ImGui::SliderIntN
PUBLIC	?DragBehavior@ImGui@@YA_NABUImRect@@IPAMMMMHM@Z	; ImGui::DragBehavior
PUBLIC	?DragFloatN@ImGui@@YA_NPBDPAMHMMM0M@Z		; ImGui::DragFloatN
PUBLIC	?DragIntN@ImGui@@YA_NPBDPAHHMHH0@Z		; ImGui::DragIntN
PUBLIC	?InputTextEx@ImGui@@YA_NPBDPADHABUImVec2@@HP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ; ImGui::InputTextEx
PUBLIC	?InputFloatN@ImGui@@YA_NPBDPAMHHH@Z		; ImGui::InputFloatN
PUBLIC	?InputIntN@ImGui@@YA_NPBDPAHHH@Z		; ImGui::InputIntN
PUBLIC	?InputScalarEx@ImGui@@YA_NPBDW4ImGuiDataType@@PAX220H@Z ; ImGui::InputScalarEx
PUBLIC	?InputScalarAsWidgetReplacement@ImGui@@YA_NABUImRect@@PBDW4ImGuiDataType@@PAXIH@Z ; ImGui::InputScalarAsWidgetReplacement
PUBLIC	?TreeNodeBehavior@ImGui@@YA_NIHPBD0@Z		; ImGui::TreeNodeBehavior
PUBLIC	?TreeNodeBehaviorIsOpen@ImGui@@YA_NIH@Z		; ImGui::TreeNodeBehaviorIsOpen
PUBLIC	?TreePushRawID@ImGui@@YAXI@Z			; ImGui::TreePushRawID
PUBLIC	?PlotEx@ImGui@@YAXW4ImGuiPlotType@@PBDP6AMPAXH@Z2HH1MMUImVec2@@@Z ; ImGui::PlotEx
PUBLIC	?PlotCEx@ImGui@@YAXW4ImGuiPlotType@@PBDP6AMPAXH@Z2HH1MMUImVec2@@MMM_N@Z ; ImGui::PlotCEx
PUBLIC	?ParseFormatPrecision@ImGui@@YAHPBDH@Z		; ImGui::ParseFormatPrecision
PUBLIC	?RoundScalar@ImGui@@YAMMH@Z			; ImGui::RoundScalar
PUBLIC	?abs@@YAJJ@Z					; abs
PUBLIC	?sqrt@@YAMM@Z					; sqrt
PUBLIC	?min@?$numeric_limits@M@std@@SAMXZ		; std::numeric_limits<float>::min
PUBLIC	?max@?$numeric_limits@M@std@@SAMXZ		; std::numeric_limits<float>::max
PUBLIC	?ImStrncpy@@YAXPADPBDH@Z			; ImStrncpy
PUBLIC	??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const *>
PUBLIC	?_InterlockedCompareExchange@@YAKPCKKK@Z	; _InterlockedCompareExchange
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z	; std::char_traits<wchar_t>::assign
PUBLIC	?copy@?$char_traits@D@std@@SAPADQADQBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADQADQBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Allocate@std@@YAPAXII_N@Z			; std::_Allocate
PUBLIC	?_Deallocate@std@@YAXPAXII@Z			; std::_Deallocate
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
PUBLIC	?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
PUBLIC	?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
PUBLIC	?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
PUBLIC	?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Assign_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_lv_contents
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z	; std::allocator<wchar_t>::deallocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
PUBLIC	??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
PUBLIC	?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr
PUBLIC	?_Orphan_all@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Orphan_all
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
PUBLIC	??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>
PUBLIC	??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
PUBLIC	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
PUBLIC	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
PUBLIC	?isVisible@SK_Console@@QAE_NXZ			; SK_Console::isVisible
PUBLIC	?markRead@sk_input_api_context_s@@QAEXW4sk_input_dev_type@@@Z ; sk_input_api_context_s::markRead
PUBLIC	??0show_eula_s@@QAE@XZ				; show_eula_s::show_eula_s
PUBLIC	?GetVarPtr@ImGuiStyleVarInfo@@QBEPAXXZ		; ImGuiStyleVarInfo::GetVarPtr
PUBLIC	??0ImGuiPlotArrayGetterData@@QAE@PBMH@Z		; ImGuiPlotArrayGetterData::ImGuiPlotArrayGetterData
PUBLIC	??0SK_Thread_CriticalSection@@QAE@PAU_RTL_CRITICAL_SECTION@@@Z ; SK_Thread_CriticalSection::SK_Thread_CriticalSection
PUBLIC	?lock@SK_Thread_CriticalSection@@QAEXXZ		; SK_Thread_CriticalSection::lock
PUBLIC	?unlock@SK_Thread_CriticalSection@@QAEXXZ	; SK_Thread_CriticalSection::unlock
PUBLIC	??0SK_Thread_HybridSpinlock@@QAE@H@Z		; SK_Thread_HybridSpinlock::SK_Thread_HybridSpinlock
PUBLIC	??1SK_Thread_HybridSpinlock@@QAE@XZ		; SK_Thread_HybridSpinlock::~SK_Thread_HybridSpinlock
PUBLIC	?SK_ImGui_GetGlyphRangesDefaultEx@@YAPBGXZ	; SK_ImGui_GetGlyphRangesDefaultEx
PUBLIC	?SK_ImGui_LoadFonts@@YAXXZ			; SK_ImGui_LoadFonts
PUBLIC	??0?$lock_guard@VSK_Thread_CriticalSection@@@std@@QAE@AAVSK_Thread_CriticalSection@@@Z ; std::lock_guard<SK_Thread_CriticalSection>::lock_guard<SK_Thread_CriticalSection>
PUBLIC	??1?$lock_guard@VSK_Thread_CriticalSection@@@std@@QAE@XZ ; std::lock_guard<SK_Thread_CriticalSection>::~lock_guard<SK_Thread_CriticalSection>
PUBLIC	?SK_ImGui_ProcessRawInput@@YGIPAUHRAWINPUT__@@IPAXPAIIH@Z ; SK_ImGui_ProcessRawInput
PUBLIC	?SK_Input_RememberPressedKeys@@YAXXZ		; SK_Input_RememberPressedKeys
PUBLIC	?SK_ImGui_WantMouseWarpFiltering@@YA_NXZ	; SK_ImGui_WantMouseWarpFiltering
PUBLIC	?SK_ImGui_DeltaTestMouse@@YAJAAUtagPOINTS@@KF@Z	; SK_ImGui_DeltaTestMouse
PUBLIC	?ImGui_WndProcHandler@@YGJPAUHWND__@@IIJ@Z	; ImGui_WndProcHandler
PUBLIC	?SK_ImGui_FilterXInput@@YA_NKPAU_XINPUT_STATE@@@Z ; SK_ImGui_FilterXInput
PUBLIC	??$max@K@std@@YAABKABK0@Z			; std::max<unsigned long>
PUBLIC	?run@linear_pulse_event_s@<unnamed-type-haptic_events>@@QAEMXZ ; <unnamed-type-haptic_events>::linear_pulse_event_s::run
PUBLIC	??0<unnamed-type-haptic_events>@@QAE@XZ		; <unnamed-type-haptic_events>::<unnamed-type-haptic_events>
PUBLIC	??$max@M@std@@YAABMABM0@Z			; std::max<float>
PUBLIC	?SK_ImGui_ToggleEx@@YG_NAA_N0@Z			; SK_ImGui_ToggleEx
PUBLIC	?SK_ImGui_PollGamepad_EndFrame@@YAXXZ		; SK_ImGui_PollGamepad_EndFrame
PUBLIC	??$min@M@std@@YAABMABM0@Z			; std::min<float>
PUBLIC	?SK_ImGui_PollGamepad@@YAXXZ			; SK_ImGui_PollGamepad
PUBLIC	??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ; std::move<std::_Wrap_alloc<std::allocator<char> > &>
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>
PUBLIC	??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> >
PUBLIC	??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z		; std::addressof<wchar_t *>
PUBLIC	??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$_Unfancy@_W@std@@YAPA_WPA_W@Z		; std::_Unfancy<wchar_t>
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	??$_Min_value@I@std@@YAABIABI0@Z		; std::_Min_value<unsigned int>
PUBLIC	??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<char> > >
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ; std::allocator<wchar_t>::destroy<wchar_t *>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??_C@_09GBFFKCDJ@?$CD?$CDOverlay?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?eula@@3Ushow_eula_s@@A				; eula
PUBLIC	??_C@_0CF@IMBENNLG@?$CFs?3?5?8?$CFs?8?5?$CFd?5vtx?0?5?$CFd?5indices?0?5?$CFd?5@ ; `string'
PUBLIC	??_C@_0BE@LDCFEMCB@CURRENTLY?5APPENDING?$AA@	; `string'
PUBLIC	??_C@_0BK@FDNBBNBF@Callback?5?$CFp?0?5user_data?5?$CFp?$AA@ ; `string'
PUBLIC	??_C@_07KNEBDGNE@indexed?$AA@			; `string'
PUBLIC	??_C@_0M@NGJKDAN@non?9indexed?$AA@		; `string'
PUBLIC	??_C@_0EB@GBKAKAEN@Draw?5?$CF?94d?5?$CFs?5vtx?0?5tex?5?$DN?5?$CFp?0?5clip@ ; `string'
PUBLIC	??_C@_03CEPBOMNB@vtx?$AA@			; `string'
PUBLIC	??_C@_03NDEAONJP@?5?5?5?$AA@			; `string'
PUBLIC	??_C@_0DP@LIPFHOCP@?$CFs?5?$CF04d?5?$HL?5pos?5?$DN?5?$CI?$CF8?42f?0?$CF8?42f?$CJ?0?5u@ ; `string'
PUBLIC	??_C@_07JMKCEEPK@?$CFs?5?$CI?$CFd?$CJ?$AA@	; `string'
PUBLIC	??_C@_06BKKJGDHO@Window?$AA@			; `string'
PUBLIC	??_C@_0BD@KOKNLAED@?$CFs?5?8?$CFs?8?0?5?$CFd?5?$EA?50x?$CFp?$AA@ ; `string'
PUBLIC	??_C@_08IJNCDCKF@DrawList?$AA@			; `string'
PUBLIC	??_C@_0BB@OALIFMJB@Pos?3?5?$CI?$CF?41f?0?$CF?41f?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CM@FNPKCFJC@Size?3?5?$CI?$CF?41f?0?$CF?41f?$CJ?0?5SizeContents?5@ ; `string'
PUBLIC	??_C@_0BE@LFBJHAFP@Scroll?3?5?$CI?$CF?42f?0?$CF?42f?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CN@NNMFALIK@NavLastId?3?50x?$CF08x?0?5NavLayerActiv@ ; `string'
PUBLIC	??_C@_0L@EHLMOHOL@RootWindow?$AA@		; `string'
PUBLIC	??_C@_0N@BGDHDNPO@ChildWindows?$AA@		; `string'
PUBLIC	??_C@_0BC@PDGNHIHG@Storage?3?5?$CFd?5bytes?$AA@	; `string'
PUBLIC	?font_lock@@3VSK_Thread_HybridSpinlock@@A	; font_lock
PUBLIC	??_C@_06OMAMIPPI@?$CFws?2?$CFs?$AA@		; `string'
PUBLIC	?window_active@?1???R<lambda_34955bda5757b6d1afe210935814f65c>@@QBE_NPAUHWND__@@IIJ@Z@4_NA ; `<lambda_34955bda5757b6d1afe210935814f65c>::operator()'::`2'::window_active
PUBLIC	??_C@_1DK@BLGEDKBM@?$AAW?$AAM?$AA_?$AAA?$AAP?$AAP?$AAC?$AAO?$AAM?$AAM?$AAA?$AAN?$AAD?$AA?5?$AAK?$AAe?$AAy?$AAb?$AAo?$AAa?$AAr?$AAd?$AA?5?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EE@HBEADAKP@?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AAd?$AA?5?$AAW?$AAM?$AA_?$AAA?$AAP?$AAP?$AAC?$AAO?$AAM?$AAM?$AAA?$AAN?$AAD?$AA?5?$AAM?$AAo?$AAu?$AAs?$AAe?$AA?5?$AAE?$AAv?$AAe?$AAn@ ; `string'
PUBLIC	??_C@_1DE@HMFBBKJG@?$AAW?$AAM?$AA_?$AAA?$AAP?$AAP?$AAC?$AAO?$AAM?$AAM?$AAA?$AAN?$AAD?$AA?5?$AAM?$AAo?$AAu?$AAs?$AAe?$AA?5?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?$AA@ ; `string'
PUBLIC	??_C@_1FE@DBJNABHE@?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AAd?$AA?5?$AAW?$AAM?$AA_?$AAA?$AAP?$AAP?$AAC?$AAO?$AAM?$AAM?$AAA?$AAN?$AAD?$AA?5?$AAM?$AAo?$AAu?$AAs?$AAe?$AA?5?$AAD?$AAe?$AAl?$AAt@ ; `string'
PUBLIC	?haptic_events@@3U<unnamed-type-haptic_events>@@A ; haptic_events
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@00800000
PUBLIC	__real@1e3ce508
PUBLIC	__real@358637bd
PUBLIC	__real@3727c5ac
PUBLIC	__real@38000100
PUBLIC	__real@38285303
PUBLIC	__real@38d1b717
PUBLIC	__real@3a83126f
PUBLIC	__real@3b360b61
PUBLIC	__real@3b808081
PUBLIC	__real@3b91a2b4
PUBLIC	__real@3c23d70a
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e19999a
PUBLIC	__real@3e2aaaab
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e800000
PUBLIC	__real@3e99999a
PUBLIC	__real@3e9d2f1b
PUBLIC	__real@3e9eb852
PUBLIC	__real@3eaaaaab
PUBLIC	__real@3ecccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f266666
PUBLIC	__real@3f350481
PUBLIC	__real@3f400000
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f5db22d
PUBLIC	__real@3f733333
PUBLIC	__real@3f7ff972
PUBLIC	__real@3f7fff58
PUBLIC	__real@3f800000
PUBLIC	__real@3f800054
PUBLIC	__real@3f99999a
PUBLIC	__real@3faccccd
PUBLIC	__real@3fc00000
PUBLIC	__real@40000000
PUBLIC	__real@40200000
PUBLIC	__real@40400000
PUBLIC	__real@40800000
PUBLIC	__real@40a00000
PUBLIC	__real@40c00000
PUBLIC	__real@40c90fdb
PUBLIC	__real@40eccccd
PUBLIC	__real@41000000
PUBLIC	__real@41200000
PUBLIC	__real@41800000
PUBLIC	__real@41a00000
PUBLIC	__real@41c00000
PUBLIC	__real@41f00000
PUBLIC	__real@42652ee0
PUBLIC	__real@42c80000
PUBLIC	__real@42f00000
PUBLIC	__real@437f0000
PUBLIC	__real@44160000
PUBLIC	__real@447a0000
PUBLIC	__real@45f54800
PUBLIC	__real@461c3c00
PUBLIC	__real@46fffe00
PUBLIC	__real@7f7fffff
PUBLIC	__real@beaaaaab
PUBLIC	__real@bf000000
PUBLIC	__real@bf5db22d
PUBLIC	__real@bf800000
PUBLIC	__real@c0000000
PUBLIC	__real@c2c80000
PUBLIC	__real@ff7fffff
PUBLIC	__xmm@3b8080813b8080813b8080813b808081
PUBLIC	__xmm@3df5c28f3f8000003f8000003f800000
PUBLIC	__xmm@3e4ccccd3f4ccccd3ecccccd3ecccccd
PUBLIC	__xmm@3e99999a3f4ccccd3ecccccd3ecccccd
PUBLIC	__xmm@3e99999a3f4ccccd3f4ccccd3f4ccccd
PUBLIC	__xmm@3e99999a3f8000003f8000003f800000
PUBLIC	__xmm@3eb333333e4ccccd3e4ccccd3e4ccccd
PUBLIC	__xmm@3eb333333f8000000000000000000000
PUBLIC	__xmm@3ecccccd3f0000003f0000003f4ccccd
PUBLIC	__xmm@3ecccccd3f4ccccd3ecccccd3ecccccd
PUBLIC	__xmm@3ecccccd3f4ccccd3f4ccccd3f666666
PUBLIC	__xmm@3ee666663f2666663f2666663f666666
PUBLIC	__xmm@3ee666663f6666663ecccccd3ecccccd
PUBLIC	__xmm@3f0000003f6666663f0000003f000000
PUBLIC	__xmm@3f0000003f6666663f6666663f666666
PUBLIC	__xmm@3f19999a3e99999a3e8000003e4ccccd
PUBLIC	__xmm@3f19999a3ecccccd3ecccccd3f2b851f
PUBLIC	__xmm@3f19999a3f6666663f3333333f333333
PUBLIC	__xmm@3f19999a3f8000003f8000003f800000
PUBLIC	__xmm@3f2666663f3333333f3333333f333333
PUBLIC	__xmm@3f333333000000000000000000000000
PUBLIC	__xmm@3f4ccccd3f0ccccd3ecccccd3ecccccd
PUBLIC	__xmm@3f4ccccd3f5eb8523f07ae143f07ae14
PUBLIC	__xmm@3f4ccccd3f6666663ee666663ee66666
PUBLIC	__xmm@3f547ae13f0000003e75c28f3e75c28f
PUBLIC	__xmm@3f5eb8523f2666663ea8f5c33ea8f5c3
PUBLIC	__xmm@3f6666663dcccccd3d4ccccd3d4ccccd
PUBLIC	__xmm@3f6666663f8000003f8000003f800000
PUBLIC	__xmm@3f7d70a43e4ccccd3e4ccccd3e4ccccd
PUBLIC	__xmm@3f800000000000003f19999a3f800000
PUBLIC	__xmm@3f800000000000003f3333333f666666
PUBLIC	__xmm@3f8000003ec8c8ca3ec8c8ca3f800000
PUBLIC	__xmm@3f8000003ecccccd3ecccccd3f2b851f
PUBLIC	__xmm@3f8000003f0000003f0000003f000000
PUBLIC	__xmm@3f8000003f0000003f0000003f4ccccd
PUBLIC	__xmm@3f8000003f19999a3f19999a3f19999a
PUBLIC	__xmm@3f8000003f19999a3f19999a3f333333
PUBLIC	__xmm@3f8000003f3333333f3333333f333333
PUBLIC	__xmm@3f8000003f3333333f3333333f666666
PUBLIC	__xmm@3f8000003f6666663f6666663f666666
PUBLIC	__xmm@3f8000003f8000003f8000003f800000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@7f7fffff7f7fffffff7fffffff7fffff
PUBLIC	__xmm@7fffffff7fffffff7fffffff7fffffff
PUBLIC	__xmm@80000000800000008000000080000000
PUBLIC	__xmm@ff7fffffff7fffff7f7fffff7f7fffff
PUBLIC	__xmm@ffffffffffffffffffffffffffffffff
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	___std_terminate:PROC
EXTRN	__imp___invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp__memmove:PROC
EXTRN	__imp__strchr:PROC
EXTRN	__imp__strncpy:PROC
EXTRN	?PushClipRect@ImDrawList@@QAEXUImVec2@@0_N@Z:PROC ; ImDrawList::PushClipRect
EXTRN	?PushClipRectFullScreen@ImDrawList@@QAEXXZ:PROC	; ImDrawList::PushClipRectFullScreen
EXTRN	?PopClipRect@ImDrawList@@QAEXXZ:PROC		; ImDrawList::PopClipRect
EXTRN	?PushTextureID@ImDrawList@@QAEXABQAX@Z:PROC	; ImDrawList::PushTextureID
EXTRN	?PopTextureID@ImDrawList@@QAEXXZ:PROC		; ImDrawList::PopTextureID
EXTRN	?AddLine@ImDrawList@@QAEXABUImVec2@@0IM@Z:PROC	; ImDrawList::AddLine
EXTRN	?AddRect@ImDrawList@@QAEXABUImVec2@@0IMHM@Z:PROC ; ImDrawList::AddRect
EXTRN	?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z:PROC ; ImDrawList::AddRectFilled
EXTRN	?AddTriangleFilled@ImDrawList@@QAEXABUImVec2@@00I@Z:PROC ; ImDrawList::AddTriangleFilled
EXTRN	?AddCircle@ImDrawList@@QAEXABUImVec2@@MIHM@Z:PROC ; ImDrawList::AddCircle
EXTRN	?AddCircleFilled@ImDrawList@@QAEXABUImVec2@@MIH@Z:PROC ; ImDrawList::AddCircleFilled
EXTRN	?AddText@ImDrawList@@QAEXPBUImFont@@MABUImVec2@@IPBD2MPBUImVec4@@@Z:PROC ; ImDrawList::AddText
EXTRN	?AddImage@ImDrawList@@QAEXPAXABUImVec2@@111I@Z:PROC ; ImDrawList::AddImage
EXTRN	?AddPolyline@ImDrawList@@QAEXPBUImVec2@@HI_NM1@Z:PROC ; ImDrawList::AddPolyline
EXTRN	?AddConvexPolyFilled@ImDrawList@@QAEXPBUImVec2@@HI_N@Z:PROC ; ImDrawList::AddConvexPolyFilled
EXTRN	?PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z:PROC ; ImDrawList::PathArcToFast
EXTRN	?ChannelsSplit@ImDrawList@@QAEXH@Z:PROC		; ImDrawList::ChannelsSplit
EXTRN	?ChannelsMerge@ImDrawList@@QAEXXZ:PROC		; ImDrawList::ChannelsMerge
EXTRN	?ChannelsSetCurrent@ImDrawList@@QAEXH@Z:PROC	; ImDrawList::ChannelsSetCurrent
EXTRN	?Clear@ImDrawList@@QAEXXZ:PROC			; ImDrawList::Clear
EXTRN	?ClearFreeMemory@ImDrawList@@QAEXXZ:PROC	; ImDrawList::ClearFreeMemory
EXTRN	??0ImFontConfig@@QAE@XZ:PROC			; ImFontConfig::ImFontConfig
EXTRN	??0ImFontAtlas@@QAE@XZ:PROC			; ImFontAtlas::ImFontAtlas
EXTRN	??1ImFontAtlas@@QAE@XZ:PROC			; ImFontAtlas::~ImFontAtlas
EXTRN	?AddFontDefault@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z:PROC ; ImFontAtlas::AddFontDefault
EXTRN	?AddFontFromFileTTF@ImFontAtlas@@QAEPAUImFont@@PBDMPBUImFontConfig@@PBG@Z:PROC ; ImFontAtlas::AddFontFromFileTTF
EXTRN	?Clear@ImFontAtlas@@QAEXXZ:PROC			; ImFontAtlas::Clear
EXTRN	?GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ:PROC ; ImFontAtlas::GetGlyphRangesJapanese
EXTRN	?GetGlyphRangesChinese@ImFontAtlas@@QAEPBGXZ:PROC ; ImFontAtlas::GetGlyphRangesChinese
EXTRN	?GetGlyphRangesCyrillic@ImFontAtlas@@QAEPBGXZ:PROC ; ImFontAtlas::GetGlyphRangesCyrillic
EXTRN	??0ImFont@@QAE@XZ:PROC				; ImFont::ImFont
EXTRN	??1ImFont@@QAE@XZ:PROC				; ImFont::~ImFont
EXTRN	?FindGlyph@ImFont@@QBEPBUGlyph@1@G@Z:PROC	; ImFont::FindGlyph
EXTRN	?CalcTextSizeA@ImFont@@QBE?AUImVec2@@MMMPBD0PAPBD@Z:PROC ; ImFont::CalcTextSizeA
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp___wfopen:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fflush:PROC
EXTRN	__imp__fread:PROC
EXTRN	__imp__fseek:PROC
EXTRN	__imp__ftell:PROC
EXTRN	_vfprintf:PROC
EXTRN	_vsnprintf:PROC
EXTRN	_sprintf:PROC
EXTRN	_snprintf:PROC
EXTRN	_sscanf:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__qsort:PROC
EXTRN	__imp__atoi:PROC
EXTRN	__imp__iswprint:PROC
EXTRN	__imp__isprint:PROC
EXTRN	__imp__toupper:PROC
EXTRN	__imp__GetFileAttributesA@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__InitializeCriticalSectionAndSpinCount@8:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__GlobalAlloc@8:PROC
EXTRN	__imp__GlobalLock@4:PROC
EXTRN	__imp__GlobalUnlock@4:PROC
EXTRN	__imp__ToUnicodeEx@28:PROC
EXTRN	__imp__GetKeyboardLayout@4:PROC
EXTRN	__imp__GetMessagePos@0:PROC
EXTRN	__imp__DefWindowProcA@16:PROC
EXTRN	__imp__DefWindowProcW@16:PROC
EXTRN	__imp__OpenClipboard@4:PROC
EXTRN	__imp__CloseClipboard@0:PROC
EXTRN	__imp__SetClipboardData@8:PROC
EXTRN	__imp__GetClipboardData@4:PROC
EXTRN	__imp__EmptyClipboard@0:PROC
EXTRN	__imp__GetActiveWindow@0:PROC
EXTRN	__imp__IsWindowUnicode@4:PROC
EXTRN	__imp__GetForegroundWindow@0:PROC
EXTRN	__imp__timeGetTime@0:PROC
EXTRN	__imp__joyGetPosEx@8:PROC
EXTRN	__imp__joyGetDevCapsW@12:PROC
EXTRN	_ImmGetContext@4:PROC
EXTRN	_ImmSetCompositionWindow@8:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	__imp_?_Xout_of_range@std@@YAXPBD@Z:PROC
EXTRN	?getInstance@SK_Console@@SAPAV1@XZ:PROC		; SK_Console::getInstance
EXTRN	?KeyUp@SK_Console@@QAEHEJ@Z:PROC		; SK_Console::KeyUp
EXTRN	?KeyDown@SK_Console@@QAEHEJ@Z:PROC		; SK_Console::KeyDown
EXTRN	?SK_ImGui_WantGamepadCapture@@YA_NXZ:PROC	; SK_ImGui_WantGamepadCapture
EXTRN	?SK_ImGui_WantMouseCapture@@YA_NXZ:PROC		; SK_ImGui_WantMouseCapture
EXTRN	?SK_ImGui_WantKeyboardCapture@@YA_NXZ:PROC	; SK_ImGui_WantKeyboardCapture
EXTRN	?update@sk_imgui_cursor_s@@QAEXXZ:PROC		; sk_imgui_cursor_s::update
EXTRN	?LocalToClient@sk_imgui_cursor_s@@QAEXPAUtagPOINT@@@Z:PROC ; sk_imgui_cursor_s::LocalToClient
EXTRN	?ClientToLocal@sk_imgui_cursor_s@@QAEXPAUtagPOINT@@@Z:PROC ; sk_imgui_cursor_s::ClientToLocal
EXTRN	?SK_RawInput_EnableLegacyMouse@@YA_N_N@Z:PROC	; SK_RawInput_EnableLegacyMouse
EXTRN	?SK_RawInput_RestoreLegacyMouse@@YAXXZ:PROC	; SK_RawInput_RestoreLegacyMouse
EXTRN	?SK_RawInput_EnableLegacyKeyboard@@YA_N_N@Z:PROC ; SK_RawInput_EnableLegacyKeyboard
EXTRN	?SK_ImGui_IsMouseRelevant@@YA_NXZ:PROC		; SK_ImGui_IsMouseRelevant
EXTRN	?SK_ImGui_DrawEULA@@YGXPAX@Z:PROC		; SK_ImGui_DrawEULA
EXTRN	?SK_GetFontsDir@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ:PROC ; SK_GetFontsDir
EXTRN	?Log@iSK_Logger@@UAAXQB_WZZ:PROC		; iSK_Logger::Log
EXTRN	?SK_InputUtil_IsHWCursorVisible@@YA_NXZ:PROC	; SK_InputUtil_IsHWCursorVisible
EXTRN	?SK_XInput_PollController@@YA_NHPAU_XINPUT_STATE@@@Z:PROC ; SK_XInput_PollController
EXTRN	?SK_XInput_PulseController@@YA_NHMM@Z:PROC	; SK_XInput_PulseController
EXTRN	?SK_XInput_ZeroHaptics@@YAXH@Z:PROC		; SK_XInput_ZeroHaptics
EXTRN	?SK_JOY_TranslateToXInput@@YA?AU_XINPUT_STATE@@PAUjoyinfoex_tag@@PBUtagJOYCAPSW@@@Z:PROC ; SK_JOY_TranslateToXInput
EXTRN	?SK_ImGui_Toggle@@YAXXZ:PROC			; SK_ImGui_Toggle
EXTRN	?SK_GetFramesDrawn@@YGKXZ:PROC			; SK_GetFramesDrawn
EXTRN	__CIfmod:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___libm_sse2_powf:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	?SK_ReShade_Visible@@3_NA:BYTE			; SK_ReShade_Visible
EXTRN	?GetAsyncKeyState_Original@@3P6GFH@ZA:DWORD	; GetAsyncKeyState_Original
EXTRN	?GetRawInputData_Original@@3P6GIPAUHRAWINPUT__@@IPAXPAII@ZA:DWORD ; GetRawInputData_Original
EXTRN	?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A:BYTE	; SK_ImGui_Cursor
EXTRN	?SK_RawInput_Backend@@3Usk_input_api_context_s@@A:BYTE ; SK_RawInput_Backend
EXTRN	?game_window@@3Usk_window_s@@A:BYTE		; game_window
EXTRN	?config@@3Usk_config_t@@A:BYTE			; config
EXTRN	?dll_log@@3UiSK_Logger@@A:BYTE			; dll_log
EXTRN	?SK_ImGui_ActivationKeys@@3PAHA:BYTE		; SK_ImGui_ActivationKeys
EXTRN	?joy_to_xi@@3U_XINPUT_STATE@@A:BYTE		; joy_to_xi
EXTRN	?steam_to_xi@@3PAU_XINPUT_STATE@@A:DWORD	; steam_to_xi
EXTRN	?SK_ImGui_Widgets@@3USK_ImGui_WidgetRegistry@@A:BYTE ; SK_ImGui_Widgets
EXTRN	__fltused:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
_BSS	SEGMENT
	ALIGN	4

?GImDefaultFontAtlas@@3UImFontAtlas@@A DB 038H DUP (?)	; GImDefaultFontAtlas
?GImDefaultContext@@3UImGuiContext@@A DB 03b58H DUP (?)	; GImDefaultContext
_BSS	ENDS
;	COMDAT ?crc32_lut@?1??ImHash@@YAIPBXHI@Z@4PAIA
_BSS	SEGMENT
?crc32_lut@?1??ImHash@@YAIPBXHI@Z@4PAIA DD 0100H DUP (?) ; `ImHash'::`2'::crc32_lut
_BSS	ENDS
_BSS	SEGMENT
?eula@@3Ushow_eula_s@@A DW 01H DUP (?)			; eula
_BSS	ENDS
;	COMDAT ?last_x@?1??NewFrame@ImGui@@YAXXZ@4HA
_BSS	SEGMENT
?last_x@?1??NewFrame@ImGui@@YAXXZ@4HA DD 01H DUP (?)	; `ImGui::NewFrame'::`2'::last_x
_BSS	ENDS
;	COMDAT ?last_y@?1??NewFrame@ImGui@@YAXXZ@4HA
_BSS	SEGMENT
?last_y@?1??NewFrame@ImGui@@YAXXZ@4HA DD 01H DUP (?)	; `ImGui::NewFrame'::`2'::last_y
_BSS	ENDS
;	COMDAT ?buf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPBDPAX@Z@4V?$ImVector@D@@A
_BSS	SEGMENT
?buf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPBDPAX@Z@4V?$ImVector@D@@A DB 0cH DUP (?) ; `GetClipboardTextFn_DefaultImpl'::`2'::buf_local
_BSS	ENDS
;	COMDAT ?$TSS0@?1??GetClipboardTextFn_DefaultImpl@@YAPBDPAX@Z@4HA
_BSS	SEGMENT
?$TSS0@?1??GetClipboardTextFn_DefaultImpl@@YAPBDPAX@Z@4HA DD 01H DUP (?) ; TSS0<`template-parameter-2',tClipboardTextFn_DefaultImpl,int, ?? &>
_BSS	ENDS
_BSS	SEGMENT
	ALIGN	4

?font_lock@@3VSK_Thread_HybridSpinlock@@A DD 01H DUP (?) ; font_lock
_BSS	ENDS
;	COMDAT ?init@?1??SK_ImGui_LoadFonts@@YAXXZ@4KC
_BSS	SEGMENT
?init@?1??SK_ImGui_LoadFonts@@YAXXZ@4KC DD 01H DUP (?)	; `SK_ImGui_LoadFonts'::`2'::init
_BSS	ENDS
;	COMDAT ?last_input@?1??SK_ImGui_ProcessRawInput@@YGIPAUHRAWINPUT__@@IPAXPAIIH@Z@4PAU2@A
_BSS	SEGMENT
?last_input@?1??SK_ImGui_ProcessRawInput@@YGIPAUHRAWINPUT__@@IPAXPAIIH@Z@4PAU2@A DD 01H DUP (?) ; `SK_ImGui_ProcessRawInput'::`2'::last_input
_BSS	ENDS
;	COMDAT ?last_pos@?1??ImGui_WndProcHandler@@YGJPAUHWND__@@IIJ@Z@4UtagPOINTS@@A
_BSS	SEGMENT
?last_pos@?1??ImGui_WndProcHandler@@YGJPAUHWND__@@IIJ@Z@4UtagPOINTS@@A DD 01H DUP (?) ; `ImGui_WndProcHandler'::`2'::last_pos
_BSS	ENDS
;	COMDAT ?nav_id@?CK@??SK_ImGui_PollGamepad_EndFrame@@YAXXZ@4IA
_BSS	SEGMENT
?nav_id@?CK@??SK_ImGui_PollGamepad_EndFrame@@YAXXZ@4IA DD 01H DUP (?) ; `SK_ImGui_PollGamepad_EndFrame'::`42'::nav_id
_BSS	ENDS
;	COMDAT ?last_toggle@?1??SK_ImGui_PollGamepad@@YAXXZ@4KA
_BSS	SEGMENT
?last_toggle@?1??SK_ImGui_PollGamepad@@YAXXZ@4KA DD 01H DUP (?) ; `SK_ImGui_PollGamepad'::`2'::last_toggle
_BSS	ENDS
CRT$XCU	SEGMENT
?GImDefaultFontAtlas$initializer$@@3P6AXXZA DD FLAT:??__EGImDefaultFontAtlas@@YAXXZ ; GImDefaultFontAtlas$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@ffffffffffffffffffffffffffffffff
CONST	SEGMENT
__xmm@ffffffffffffffffffffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
CONST	ENDS
;	COMDAT __xmm@ff7fffffff7fffff7f7fffff7f7fffff
CONST	SEGMENT
__xmm@ff7fffffff7fffff7f7fffff7f7fffff DB 0ffH, 0ffH, 07fH, 07fH, 0ffH, 0ffH
	DB	07fH, 07fH, 0ffH, 0ffH, 07fH, 0ffH, 0ffH, 0ffH, 07fH, 0ffH
CONST	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@7fffffff7fffffff7fffffff7fffffff
CONST	SEGMENT
__xmm@7fffffff7fffffff7fffffff7fffffff DB 0ffH, 0ffH, 0ffH, 07fH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 07fH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __xmm@7f7fffff7f7fffffff7fffffff7fffff
CONST	SEGMENT
__xmm@7f7fffff7f7fffffff7fffffff7fffff DB 0ffH, 0ffH, 07fH, 0ffH, 0ffH, 0ffH
	DB	07fH, 0ffH, 0ffH, 0ffH, 07fH, 07fH, 0ffH, 0ffH, 07fH, 07fH
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __xmm@3f8000003f8000003f8000003f800000
CONST	SEGMENT
__xmm@3f8000003f8000003f8000003f800000 DB 00H, 00H, 080H, '?', 00H, 00H, 080H
	DB	'?', 00H, 00H, 080H, '?', 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@3f8000003f6666663f6666663f666666
CONST	SEGMENT
__xmm@3f8000003f6666663f6666663f666666 DB 'fff?fff?fff?', 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@3f8000003f3333333f3333333f666666
CONST	SEGMENT
__xmm@3f8000003f3333333f3333333f666666 DB 'fff?333?333?', 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@3f8000003f3333333f3333333f333333
CONST	SEGMENT
__xmm@3f8000003f3333333f3333333f333333 DB '333?333?333?', 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@3f8000003f19999a3f19999a3f333333
CONST	SEGMENT
__xmm@3f8000003f19999a3f19999a3f333333 DB '333?', 09aH, 099H, 019H, '?', 09aH
	DB	099H, 019H, '?', 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@3f8000003f19999a3f19999a3f19999a
CONST	SEGMENT
__xmm@3f8000003f19999a3f19999a3f19999a DB 09aH, 099H, 019H, '?', 09aH, 099H
	DB	019H, '?', 09aH, 099H, 019H, '?', 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@3f8000003f0000003f0000003f4ccccd
CONST	SEGMENT
__xmm@3f8000003f0000003f0000003f4ccccd DB 0cdH, 0ccH, 'L?', 00H, 00H, 00H
	DB	'?', 00H, 00H, 00H, '?', 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@3f8000003f0000003f0000003f000000
CONST	SEGMENT
__xmm@3f8000003f0000003f0000003f000000 DB 00H, 00H, 00H, '?', 00H, 00H, 00H
	DB	'?', 00H, 00H, 00H, '?', 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@3f8000003ecccccd3ecccccd3f2b851f
CONST	SEGMENT
__xmm@3f8000003ecccccd3ecccccd3f2b851f DB 01fH, 085H, '+?', 0cdH, 0ccH, 0ccH
	DB	'>', 0cdH, 0ccH, 0ccH, '>', 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@3f8000003ec8c8ca3ec8c8ca3f800000
CONST	SEGMENT
__xmm@3f8000003ec8c8ca3ec8c8ca3f800000 DB 00H, 00H, 080H, '?', 0caH, 0c8H
	DB	0c8H, '>', 0caH, 0c8H, 0c8H, '>', 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@3f800000000000003f3333333f666666
CONST	SEGMENT
__xmm@3f800000000000003f3333333f666666 DB 'fff?333?', 00H, 00H, 00H, 00H, 00H
	DB	00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@3f800000000000003f19999a3f800000
CONST	SEGMENT
__xmm@3f800000000000003f19999a3f800000 DB 00H, 00H, 080H, '?', 09aH, 099H
	DB	019H, '?', 00H, 00H, 00H, 00H, 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@3f7d70a43e4ccccd3e4ccccd3e4ccccd
CONST	SEGMENT
__xmm@3f7d70a43e4ccccd3e4ccccd3e4ccccd DB 0cdH, 0ccH, 'L>', 0cdH, 0ccH, 'L'
	DB	'>', 0cdH, 0ccH, 'L>', 0a4H, 'p}?'
CONST	ENDS
;	COMDAT __xmm@3f6666663f8000003f8000003f800000
CONST	SEGMENT
__xmm@3f6666663f8000003f8000003f800000 DB 00H, 00H, 080H, '?', 00H, 00H, 080H
	DB	'?', 00H, 00H, 080H, '?fff?'
CONST	ENDS
;	COMDAT __xmm@3f6666663dcccccd3d4ccccd3d4ccccd
CONST	SEGMENT
__xmm@3f6666663dcccccd3d4ccccd3d4ccccd DB 0cdH, 0ccH, 'L=', 0cdH, 0ccH, 'L'
	DB	'=', 0cdH, 0ccH, 0ccH, '=fff?'
CONST	ENDS
;	COMDAT __xmm@3f5eb8523f2666663ea8f5c33ea8f5c3
CONST	SEGMENT
__xmm@3f5eb8523f2666663ea8f5c33ea8f5c3 DB 0c3H, 0f5H, 0a8H, '>', 0c3H, 0f5H
	DB	0a8H, '>ff&?R', 0b8H, '^?'
CONST	ENDS
;	COMDAT __xmm@3f547ae13f0000003e75c28f3e75c28f
CONST	SEGMENT
__xmm@3f547ae13f0000003e75c28f3e75c28f DB 08fH, 0c2H, 'u>', 08fH, 0c2H, 'u'
	DB	'>', 00H, 00H, 00H, '?', 0e1H, 'zT?'
CONST	ENDS
;	COMDAT __xmm@3f4ccccd3f6666663ee666663ee66666
CONST	SEGMENT
__xmm@3f4ccccd3f6666663ee666663ee66666 DB 'ff', 0e6H, '>ff', 0e6H, '>fff?'
	DB	0cdH, 0ccH, 'L?'
CONST	ENDS
;	COMDAT __xmm@3f4ccccd3f5eb8523f07ae143f07ae14
CONST	SEGMENT
__xmm@3f4ccccd3f5eb8523f07ae143f07ae14 DB 014H, 0aeH, 07H, '?', 014H, 0aeH
	DB	07H, '?R', 0b8H, '^?', 0cdH, 0ccH, 'L?'
CONST	ENDS
;	COMDAT __xmm@3f4ccccd3f0ccccd3ecccccd3ecccccd
CONST	SEGMENT
__xmm@3f4ccccd3f0ccccd3ecccccd3ecccccd DB 0cdH, 0ccH, 0ccH, '>', 0cdH, 0ccH
	DB	0ccH, '>', 0cdH, 0ccH, 0cH, '?', 0cdH, 0ccH, 'L?'
CONST	ENDS
;	COMDAT __xmm@3f333333000000000000000000000000
CONST	SEGMENT
__xmm@3f333333000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, '333?'
CONST	ENDS
;	COMDAT __xmm@3f2666663f3333333f3333333f333333
CONST	SEGMENT
__xmm@3f2666663f3333333f3333333f333333 DB '333?333?333?ff&?'
CONST	ENDS
;	COMDAT __xmm@3f19999a3f8000003f8000003f800000
CONST	SEGMENT
__xmm@3f19999a3f8000003f8000003f800000 DB 00H, 00H, 080H, '?', 00H, 00H, 080H
	DB	'?', 00H, 00H, 080H, '?', 09aH, 099H, 019H, '?'
CONST	ENDS
;	COMDAT __xmm@3f19999a3f6666663f3333333f333333
CONST	SEGMENT
__xmm@3f19999a3f6666663f3333333f333333 DB '333?333?fff?', 09aH, 099H, 019H
	DB	'?'
CONST	ENDS
;	COMDAT __xmm@3f19999a3ecccccd3ecccccd3f2b851f
CONST	SEGMENT
__xmm@3f19999a3ecccccd3ecccccd3f2b851f DB 01fH, 085H, '+?', 0cdH, 0ccH, 0ccH
	DB	'>', 0cdH, 0ccH, 0ccH, '>', 09aH, 099H, 019H, '?'
CONST	ENDS
;	COMDAT __xmm@3f19999a3e99999a3e8000003e4ccccd
CONST	SEGMENT
__xmm@3f19999a3e99999a3e8000003e4ccccd DB 0cdH, 0ccH, 'L>', 00H, 00H, 080H
	DB	'>', 09aH, 099H, 099H, '>', 09aH, 099H, 019H, '?'
CONST	ENDS
;	COMDAT __xmm@3f0000003f6666663f6666663f666666
CONST	SEGMENT
__xmm@3f0000003f6666663f6666663f666666 DB 'fff?fff?fff?', 00H, 00H, 00H, '?'
CONST	ENDS
;	COMDAT __xmm@3f0000003f6666663f0000003f000000
CONST	SEGMENT
__xmm@3f0000003f6666663f0000003f000000 DB 00H, 00H, 00H, '?', 00H, 00H, 00H
	DB	'?fff?', 00H, 00H, 00H, '?'
CONST	ENDS
;	COMDAT __xmm@3ee666663f6666663ecccccd3ecccccd
CONST	SEGMENT
__xmm@3ee666663f6666663ecccccd3ecccccd DB 0cdH, 0ccH, 0ccH, '>', 0cdH, 0ccH
	DB	0ccH, '>fff?ff', 0e6H, '>'
CONST	ENDS
;	COMDAT __xmm@3ee666663f2666663f2666663f666666
CONST	SEGMENT
__xmm@3ee666663f2666663f2666663f666666 DB 'fff?ff&?ff&?ff', 0e6H, '>'
CONST	ENDS
;	COMDAT __xmm@3ecccccd3f4ccccd3f4ccccd3f666666
CONST	SEGMENT
__xmm@3ecccccd3f4ccccd3f4ccccd3f666666 DB 'fff?', 0cdH, 0ccH, 'L?', 0cdH, 0ccH
	DB	'L?', 0cdH, 0ccH, 0ccH, '>'
CONST	ENDS
;	COMDAT __xmm@3ecccccd3f4ccccd3ecccccd3ecccccd
CONST	SEGMENT
__xmm@3ecccccd3f4ccccd3ecccccd3ecccccd DB 0cdH, 0ccH, 0ccH, '>', 0cdH, 0ccH
	DB	0ccH, '>', 0cdH, 0ccH, 'L?', 0cdH, 0ccH, 0ccH, '>'
CONST	ENDS
;	COMDAT __xmm@3ecccccd3f0000003f0000003f4ccccd
CONST	SEGMENT
__xmm@3ecccccd3f0000003f0000003f4ccccd DB 0cdH, 0ccH, 'L?', 00H, 00H, 00H
	DB	'?', 00H, 00H, 00H, '?', 0cdH, 0ccH, 0ccH, '>'
CONST	ENDS
;	COMDAT __xmm@3eb333333f8000000000000000000000
CONST	SEGMENT
__xmm@3eb333333f8000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 080H, '?33', 0b3H, '>'
CONST	ENDS
;	COMDAT __xmm@3eb333333e4ccccd3e4ccccd3e4ccccd
CONST	SEGMENT
__xmm@3eb333333e4ccccd3e4ccccd3e4ccccd DB 0cdH, 0ccH, 'L>', 0cdH, 0ccH, 'L'
	DB	'>', 0cdH, 0ccH, 'L>33', 0b3H, '>'
CONST	ENDS
;	COMDAT __xmm@3e99999a3f8000003f8000003f800000
CONST	SEGMENT
__xmm@3e99999a3f8000003f8000003f800000 DB 00H, 00H, 080H, '?', 00H, 00H, 080H
	DB	'?', 00H, 00H, 080H, '?', 09aH, 099H, 099H, '>'
CONST	ENDS
;	COMDAT __xmm@3e99999a3f4ccccd3f4ccccd3f4ccccd
CONST	SEGMENT
__xmm@3e99999a3f4ccccd3f4ccccd3f4ccccd DB 0cdH, 0ccH, 'L?', 0cdH, 0ccH, 'L'
	DB	'?', 0cdH, 0ccH, 'L?', 09aH, 099H, 099H, '>'
CONST	ENDS
;	COMDAT __xmm@3e99999a3f4ccccd3ecccccd3ecccccd
CONST	SEGMENT
__xmm@3e99999a3f4ccccd3ecccccd3ecccccd DB 0cdH, 0ccH, 0ccH, '>', 0cdH, 0ccH
	DB	0ccH, '>', 0cdH, 0ccH, 'L?', 09aH, 099H, 099H, '>'
CONST	ENDS
;	COMDAT __xmm@3e4ccccd3f4ccccd3ecccccd3ecccccd
CONST	SEGMENT
__xmm@3e4ccccd3f4ccccd3ecccccd3ecccccd DB 0cdH, 0ccH, 0ccH, '>', 0cdH, 0ccH
	DB	0ccH, '>', 0cdH, 0ccH, 'L?', 0cdH, 0ccH, 'L>'
CONST	ENDS
;	COMDAT __xmm@3df5c28f3f8000003f8000003f800000
CONST	SEGMENT
__xmm@3df5c28f3f8000003f8000003f800000 DB 00H, 00H, 080H, '?', 00H, 00H, 080H
	DB	'?', 00H, 00H, 080H, '?', 08fH, 0c2H, 0f5H, '='
CONST	ENDS
;	COMDAT __xmm@3b8080813b8080813b8080813b808081
CONST	SEGMENT
__xmm@3b8080813b8080813b8080813b808081 DB 081H, 080H, 080H, ';', 081H, 080H
	DB	080H, ';', 081H, 080H, 080H, ';', 081H, 080H, 080H, ';'
CONST	ENDS
;	COMDAT __real@ff7fffff
CONST	SEGMENT
__real@ff7fffff DD 0ff7fffffr			; -3.40282e+38
CONST	ENDS
;	COMDAT __real@c2c80000
CONST	SEGMENT
__real@c2c80000 DD 0c2c80000r			; -100
CONST	ENDS
;	COMDAT __real@c0000000
CONST	SEGMENT
__real@c0000000 DD 0c0000000r			; -2
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@bf5db22d
CONST	SEGMENT
__real@bf5db22d DD 0bf5db22dr			; -0.866
CONST	ENDS
;	COMDAT __real@bf000000
CONST	SEGMENT
__real@bf000000 DD 0bf000000r			; -0.5
CONST	ENDS
;	COMDAT __real@beaaaaab
CONST	SEGMENT
__real@beaaaaab DD 0beaaaaabr			; -0.333333
CONST	ENDS
;	COMDAT __real@7f7fffff
CONST	SEGMENT
__real@7f7fffff DD 07f7fffffr			; 3.40282e+38
CONST	ENDS
;	COMDAT __real@46fffe00
CONST	SEGMENT
__real@46fffe00 DD 046fffe00r			; 32767
CONST	ENDS
;	COMDAT __real@461c3c00
CONST	SEGMENT
__real@461c3c00 DD 0461c3c00r			; 9999
CONST	ENDS
;	COMDAT __real@45f54800
CONST	SEGMENT
__real@45f54800 DD 045f54800r			; 7849
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@44160000
CONST	SEGMENT
__real@44160000 DD 044160000r			; 600
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@42f00000
CONST	SEGMENT
__real@42f00000 DD 042f00000r			; 120
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42652ee0
CONST	SEGMENT
__real@42652ee0 DD 042652ee0r			; 57.2958
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@41c00000
CONST	SEGMENT
__real@41c00000 DD 041c00000r			; 24
CONST	ENDS
;	COMDAT __real@41a00000
CONST	SEGMENT
__real@41a00000 DD 041a00000r			; 20
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@41000000
CONST	SEGMENT
__real@41000000 DD 041000000r			; 8
CONST	ENDS
;	COMDAT __real@40eccccd
CONST	SEGMENT
__real@40eccccd DD 040eccccdr			; 7.4
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT __real@40c00000
CONST	SEGMENT
__real@40c00000 DD 040c00000r			; 6
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@40200000
CONST	SEGMENT
__real@40200000 DD 040200000r			; 2.5
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3fc00000
CONST	SEGMENT
__real@3fc00000 DD 03fc00000r			; 1.5
CONST	ENDS
;	COMDAT __real@3faccccd
CONST	SEGMENT
__real@3faccccd DD 03faccccdr			; 1.35
CONST	ENDS
;	COMDAT __real@3f99999a
CONST	SEGMENT
__real@3f99999a DD 03f99999ar			; 1.2
CONST	ENDS
;	COMDAT __real@3f800054
CONST	SEGMENT
__real@3f800054 DD 03f800054r			; 1.00001
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f7fff58
CONST	SEGMENT
__real@3f7fff58 DD 03f7fff58r			; 0.99999
CONST	ENDS
;	COMDAT __real@3f7ff972
CONST	SEGMENT
__real@3f7ff972 DD 03f7ff972r			; 0.9999
CONST	ENDS
;	COMDAT __real@3f733333
CONST	SEGMENT
__real@3f733333 DD 03f733333r			; 0.95
CONST	ENDS
;	COMDAT __real@3f5db22d
CONST	SEGMENT
__real@3f5db22d DD 03f5db22dr			; 0.866
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f400000
CONST	SEGMENT
__real@3f400000 DD 03f400000r			; 0.75
CONST	ENDS
;	COMDAT __real@3f350481
CONST	SEGMENT
__real@3f350481 DD 03f350481r			; 0.7071
CONST	ENDS
;	COMDAT __real@3f266666
CONST	SEGMENT
__real@3f266666 DD 03f266666r			; 0.65
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3ecccccd
CONST	SEGMENT
__real@3ecccccd DD 03ecccccdr			; 0.4
CONST	ENDS
;	COMDAT __real@3eaaaaab
CONST	SEGMENT
__real@3eaaaaab DD 03eaaaaabr			; 0.333333
CONST	ENDS
;	COMDAT __real@3e9eb852
CONST	SEGMENT
__real@3e9eb852 DD 03e9eb852r			; 0.31
CONST	ENDS
;	COMDAT __real@3e9d2f1b
CONST	SEGMENT
__real@3e9d2f1b DD 03e9d2f1br			; 0.307
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3e2aaaab
CONST	SEGMENT
__real@3e2aaaab DD 03e2aaaabr			; 0.166667
CONST	ENDS
;	COMDAT __real@3e19999a
CONST	SEGMENT
__real@3e19999a DD 03e19999ar			; 0.15
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3b91a2b4
CONST	SEGMENT
__real@3b91a2b4 DD 03b91a2b4r			; 0.00444444
CONST	ENDS
;	COMDAT __real@3b808081
CONST	SEGMENT
__real@3b808081 DD 03b808081r			; 0.00392157
CONST	ENDS
;	COMDAT __real@3b360b61
CONST	SEGMENT
__real@3b360b61 DD 03b360b61r			; 0.00277778
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT __real@38d1b717
CONST	SEGMENT
__real@38d1b717 DD 038d1b717r			; 0.0001
CONST	ENDS
;	COMDAT __real@38285303
CONST	SEGMENT
__real@38285303 DD 038285303r			; 4.01316e-05
CONST	ENDS
;	COMDAT __real@38000100
CONST	SEGMENT
__real@38000100 DD 038000100r			; 3.05185e-05
CONST	ENDS
;	COMDAT __real@3727c5ac
CONST	SEGMENT
__real@3727c5ac DD 03727c5acr			; 1e-05
CONST	ENDS
;	COMDAT __real@358637bd
CONST	SEGMENT
__real@358637bd DD 0358637bdr			; 1e-06
CONST	ENDS
;	COMDAT __real@1e3ce508
CONST	SEGMENT
__real@1e3ce508 DD 01e3ce508r			; 1e-20
CONST	ENDS
;	COMDAT __real@00800000
CONST	SEGMENT
__real@00800000 DD 000800000r			; 1.17549e-38
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ?last_state@?1??SK_ImGui_PollGamepad@@YAXXZ@4U_XINPUT_STATE@@A
_DATA	SEGMENT
?last_state@?1??SK_ImGui_PollGamepad@@YAXXZ@4U_XINPUT_STATE@@A DD 01H ; `SK_ImGui_PollGamepad'::`2'::last_state
	DW	00H
	ORG $+10
_DATA	ENDS
;	COMDAT ?dwLastPress@?O@??SK_ImGui_PollGamepad_EndFrame@@YAXXZ@4KA
_DATA	SEGMENT
?dwLastPress@?O@??SK_ImGui_PollGamepad_EndFrame@@YAXXZ@4KA DD 0ffffffffH ; `SK_ImGui_PollGamepad_EndFrame'::`14'::dwLastPress
_DATA	ENDS
;	COMDAT ?last_state@?1??SK_ImGui_PollGamepad_EndFrame@@YAXXZ@4U_XINPUT_STATE@@A
_DATA	SEGMENT
?last_state@?1??SK_ImGui_PollGamepad_EndFrame@@YAXXZ@4U_XINPUT_STATE@@A DD 01H ; `SK_ImGui_PollGamepad_EndFrame'::`2'::last_state
	DW	00H
	ORG $+10
_DATA	ENDS
_DATA	SEGMENT
	ORG $+2
?haptic_events@@3U<unnamed-type-haptic_events>@@A DD 043af0000r ; 350 ; haptic_events
	DD	03f800000r			; 1
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	042aa0000r			; 85
	DD	03f000000r			; 0.5
	DD	000000000r			; 0
	DD	000000000r			; 0
	DD	042700000r			; 60
	DD	03c75c28fr			; 0.015
	DD	000000000r			; 0
	DD	000000000r			; 0
_DATA	ENDS
;	COMDAT ??_C@_1FE@DBJNABHE@?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AAd?$AA?5?$AAW?$AAM?$AA_?$AAA?$AAP?$AAP?$AAC?$AAO?$AAM?$AAM?$AAA?$AAN?$AAD?$AA?5?$AAM?$AAo?$AAu?$AAs?$AAe?$AA?5?$AAD?$AAe?$AAl?$AAt@
CONST	SEGMENT
??_C@_1FE@DBJNABHE@?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AAd?$AA?5?$AAW?$AAM?$AA_?$AAA?$AAP?$AAP?$AAC?$AAO?$AAM?$AAM?$AAA?$AAN?$AAD?$AA?5?$AAM?$AAo?$AAu?$AAs?$AAe?$AA?5?$AAD?$AAe?$AAl?$AAt@ DB 'R'
	DB	00H, 'e', 00H, 'm', 00H, 'o', 00H, 'v', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 'W', 00H, 'M', 00H, '_', 00H, 'A', 00H, 'P', 00H, 'P'
	DB	00H, 'C', 00H, 'O', 00H, 'M', 00H, 'M', 00H, 'A', 00H, 'N', 00H
	DB	'D', 00H, ' ', 00H, 'M', 00H, 'o', 00H, 'u', 00H, 's', 00H, 'e'
	DB	00H, ' ', 00H, 'D', 00H, 'e', 00H, 'l', 00H, 't', 00H, 'a', 00H
	DB	' ', 00H, 'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'u', 00H, 'r'
	DB	00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@HMFBBKJG@?$AAW?$AAM?$AA_?$AAA?$AAP?$AAP?$AAC?$AAO?$AAM?$AAM?$AAA?$AAN?$AAD?$AA?5?$AAM?$AAo?$AAu?$AAs?$AAe?$AA?5?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@HMFBBKJG@?$AAW?$AAM?$AA_?$AAA?$AAP?$AAP?$AAC?$AAO?$AAM?$AAM?$AAA?$AAN?$AAD?$AA?5?$AAM?$AAo?$AAu?$AAs?$AAe?$AA?5?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?$AA@ DB 'W'
	DB	00H, 'M', 00H, '_', 00H, 'A', 00H, 'P', 00H, 'P', 00H, 'C', 00H
	DB	'O', 00H, 'M', 00H, 'M', 00H, 'A', 00H, 'N', 00H, 'D', 00H, ' '
	DB	00H, 'M', 00H, 'o', 00H, 'u', 00H, 's', 00H, 'e', 00H, ' ', 00H
	DB	'E', 00H, 'v', 00H, 'e', 00H, 'n', 00H, 't', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@HBEADAKP@?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AAd?$AA?5?$AAW?$AAM?$AA_?$AAA?$AAP?$AAP?$AAC?$AAO?$AAM?$AAM?$AAA?$AAN?$AAD?$AA?5?$AAM?$AAo?$AAu?$AAs?$AAe?$AA?5?$AAE?$AAv?$AAe?$AAn@
CONST	SEGMENT
??_C@_1EE@HBEADAKP@?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AAd?$AA?5?$AAW?$AAM?$AA_?$AAA?$AAP?$AAP?$AAC?$AAO?$AAM?$AAM?$AAA?$AAN?$AAD?$AA?5?$AAM?$AAo?$AAu?$AAs?$AAe?$AA?5?$AAE?$AAv?$AAe?$AAn@ DB 'R'
	DB	00H, 'e', 00H, 'm', 00H, 'o', 00H, 'v', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 'W', 00H, 'M', 00H, '_', 00H, 'A', 00H, 'P', 00H, 'P'
	DB	00H, 'C', 00H, 'O', 00H, 'M', 00H, 'M', 00H, 'A', 00H, 'N', 00H
	DB	'D', 00H, ' ', 00H, 'M', 00H, 'o', 00H, 'u', 00H, 's', 00H, 'e'
	DB	00H, ' ', 00H, 'E', 00H, 'v', 00H, 'e', 00H, 'n', 00H, 't', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@BLGEDKBM@?$AAW?$AAM?$AA_?$AAA?$AAP?$AAP?$AAC?$AAO?$AAM?$AAM?$AAA?$AAN?$AAD?$AA?5?$AAK?$AAe?$AAy?$AAb?$AAo?$AAa?$AAr?$AAd?$AA?5?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@BLGEDKBM@?$AAW?$AAM?$AA_?$AAA?$AAP?$AAP?$AAC?$AAO?$AAM?$AAM?$AAA?$AAN?$AAD?$AA?5?$AAK?$AAe?$AAy?$AAb?$AAo?$AAa?$AAr?$AAd?$AA?5?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?$AA@ DB 'W'
	DB	00H, 'M', 00H, '_', 00H, 'A', 00H, 'P', 00H, 'P', 00H, 'C', 00H
	DB	'O', 00H, 'M', 00H, 'M', 00H, 'A', 00H, 'N', 00H, 'D', 00H, ' '
	DB	00H, 'K', 00H, 'e', 00H, 'y', 00H, 'b', 00H, 'o', 00H, 'a', 00H
	DB	'r', 00H, 'd', 00H, ' ', 00H, 'E', 00H, 'v', 00H, 'e', 00H, 'n'
	DB	00H, 't', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?window_active@?1???R<lambda_34955bda5757b6d1afe210935814f65c>@@QBE_NPAUHWND__@@IIJ@Z@4_NA
_DATA	SEGMENT
?window_active@?1???R<lambda_34955bda5757b6d1afe210935814f65c>@@QBE_NPAUHWND__@@IIJ@Z@4_NA DB 01H ; `<lambda_34955bda5757b6d1afe210935814f65c>::operator()'::`2'::window_active
_DATA	ENDS
;	COMDAT ??_C@_06OMAMIPPI@?$CFws?2?$CFs?$AA@
CONST	SEGMENT
??_C@_06OMAMIPPI@?$CFws?2?$CFs?$AA@ DB '%ws\%s', 00H	; `string'
CONST	ENDS
;	COMDAT ?ranges@?1??SK_ImGui_GetGlyphRangesDefaultEx@@YAPBGXZ@4QBGB
CONST	SEGMENT
?ranges@?1??SK_ImGui_GetGlyphRangesDefaultEx@@YAPBGXZ@4QBGB DW 020H ; `SK_ImGui_GetGlyphRangesDefaultEx'::`2'::ranges
	DW	0ffH
	DW	0100H
	DW	03ffH
	DW	02000H
	DW	0206fH
	DW	02100H
	DW	021ffH
	DW	02600H
	DW	026ffH
	DW	02700H
	DW	027bfH
	DW	00H
CONST	ENDS
;	COMDAT ??_C@_0BC@PDGNHIHG@Storage?3?5?$CFd?5bytes?$AA@
CONST	SEGMENT
??_C@_0BC@PDGNHIHG@Storage?3?5?$CFd?5bytes?$AA@ DB 'Storage: %d bytes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BGDHDNPO@ChildWindows?$AA@
CONST	SEGMENT
??_C@_0N@BGDHDNPO@ChildWindows?$AA@ DB 'ChildWindows', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EHLMOHOL@RootWindow?$AA@
CONST	SEGMENT
??_C@_0L@EHLMOHOL@RootWindow?$AA@ DB 'RootWindow', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@NNMFALIK@NavLastId?3?50x?$CF08x?0?5NavLayerActiv@
CONST	SEGMENT
??_C@_0CN@NNMFALIK@NavLastId?3?50x?$CF08x?0?5NavLayerActiv@ DB 'NavLastId'
	DB	': 0x%08x, NavLayerActiveFlags: %02X', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LFBJHAFP@Scroll?3?5?$CI?$CF?42f?0?$CF?42f?$CJ?$AA@
CONST	SEGMENT
??_C@_0BE@LFBJHAFP@Scroll?3?5?$CI?$CF?42f?0?$CF?42f?$CJ?$AA@ DB 'Scroll: '
	DB	'(%.2f,%.2f)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@FNPKCFJC@Size?3?5?$CI?$CF?41f?0?$CF?41f?$CJ?0?5SizeContents?5@
CONST	SEGMENT
??_C@_0CM@FNPKCFJC@Size?3?5?$CI?$CF?41f?0?$CF?41f?$CJ?0?5SizeContents?5@ DB 'S'
	DB	'ize: (%.1f,%.1f), SizeContents (%.1f,%.1f)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OALIFMJB@Pos?3?5?$CI?$CF?41f?0?$CF?41f?$CJ?$AA@
CONST	SEGMENT
??_C@_0BB@OALIFMJB@Pos?3?5?$CI?$CF?41f?0?$CF?41f?$CJ?$AA@ DB 'Pos: (%.1f,'
	DB	'%.1f)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_08IJNCDCKF@DrawList?$AA@
CONST	SEGMENT
??_C@_08IJNCDCKF@DrawList?$AA@ DB 'DrawList', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KOKNLAED@?$CFs?5?8?$CFs?8?0?5?$CFd?5?$EA?50x?$CFp?$AA@
CONST	SEGMENT
??_C@_0BD@KOKNLAED@?$CFs?5?8?$CFs?8?0?5?$CFd?5?$EA?50x?$CFp?$AA@ DB '%s '''
	DB	'%s'', %d @ 0x%p', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06BKKJGDHO@Window?$AA@
CONST	SEGMENT
??_C@_06BKKJGDHO@Window?$AA@ DB 'Window', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07JMKCEEPK@?$CFs?5?$CI?$CFd?$CJ?$AA@
CONST	SEGMENT
??_C@_07JMKCEEPK@?$CFs?5?$CI?$CFd?$CJ?$AA@ DB '%s (%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@LIPFHOCP@?$CFs?5?$CF04d?5?$HL?5pos?5?$DN?5?$CI?$CF8?42f?0?$CF8?42f?$CJ?0?5u@
CONST	SEGMENT
??_C@_0DP@LIPFHOCP@?$CFs?5?$CF04d?5?$HL?5pos?5?$DN?5?$CI?$CF8?42f?0?$CF8?42f?$CJ?0?5u@ DB '%'
	DB	's %04d { pos = (%8.2f,%8.2f), uv = (%.6f,%.6f), col = %08X }', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_03NDEAONJP@?5?5?5?$AA@
CONST	SEGMENT
??_C@_03NDEAONJP@?5?5?5?$AA@ DB '   ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03CEPBOMNB@vtx?$AA@
CONST	SEGMENT
??_C@_03CEPBOMNB@vtx?$AA@ DB 'vtx', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@GBKAKAEN@Draw?5?$CF?94d?5?$CFs?5vtx?0?5tex?5?$DN?5?$CFp?0?5clip@
CONST	SEGMENT
??_C@_0EB@GBKAKAEN@Draw?5?$CF?94d?5?$CFs?5vtx?0?5tex?5?$DN?5?$CFp?0?5clip@ DB 'D'
	DB	'raw %-4d %s vtx, tex = %p, clip_rect = (%.0f,%.0f)..(%.0f,%.0'
	DB	'f)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NGJKDAN@non?9indexed?$AA@
CONST	SEGMENT
??_C@_0M@NGJKDAN@non?9indexed?$AA@ DB 'non-indexed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07KNEBDGNE@indexed?$AA@
CONST	SEGMENT
??_C@_07KNEBDGNE@indexed?$AA@ DB 'indexed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FDNBBNBF@Callback?5?$CFp?0?5user_data?5?$CFp?$AA@
CONST	SEGMENT
??_C@_0BK@FDNBBNBF@Callback?5?$CFp?0?5user_data?5?$CFp?$AA@ DB 'Callback '
	DB	'%p, user_data %p', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LDCFEMCB@CURRENTLY?5APPENDING?$AA@
CONST	SEGMENT
??_C@_0BE@LDCFEMCB@CURRENTLY?5APPENDING?$AA@ DB 'CURRENTLY APPENDING', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@IMBENNLG@?$CFs?3?5?8?$CFs?8?5?$CFd?5vtx?0?5?$CFd?5indices?0?5?$CFd?5@
CONST	SEGMENT
??_C@_0CF@IMBENNLG@?$CFs?3?5?8?$CFs?8?5?$CFd?5vtx?0?5?$CFd?5indices?0?5?$CFd?5@ DB '%'
	DB	's: ''%s'' %d vtx, %d indices, %d cmds', 00H	; `string'
CONST	ENDS
;	COMDAT ?show_clip_rects@?4??ShowMetricsWindow@ImGui@@YAXPA_N@Z@4_NA
_DATA	SEGMENT
?show_clip_rects@?4??ShowMetricsWindow@ImGui@@YAXPA_N@Z@4_NA DB 01H ; `ImGui::ShowMetricsWindow'::`5'::show_clip_rects
_DATA	ENDS
;	COMDAT ?min_steps@?1??GetMinimumStepAtDecimalPrecision@@YAMH@Z@4QBMB
CONST	SEGMENT
?min_steps@?1??GetMinimumStepAtDecimalPrecision@@YAMH@Z@4QBMB DD 03f800000r ; 1 ; `GetMinimumStepAtDecimalPrecision'::`2'::min_steps
	DD	03dcccccdr			; 0.1
	DD	03c23d70ar			; 0.01
	DD	03a83126fr			; 0.001
	DD	038d1b717r			; 0.0001
	DD	03727c5acr			; 1e-05
	DD	0358637bdr			; 1e-06
	DD	033d6bf95r			; 1e-07
	DD	0322bcc77r			; 1e-08
	DD	03089705fr			; 1e-09
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09GBFFKCDJ@?$CD?$CDOverlay?$AA@
CONST	SEGMENT
??_C@_09GBFFKCDJ@?$CD?$CDOverlay?$AA@ DB '##Overlay', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??R<lambda_7a12fd051827e0f33bd65ef841f2c8b8>@@QBEPAUImFont@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MPBGPAUImFontConfig@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??R<lambda_7a12fd051827e0f33bd65ef841f2c8b8>@@QBEPAUImFont@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MPBGPAUImFontConfig@@@Z$0
__ehfuncinfo$??R<lambda_7a12fd051827e0f33bd65ef841f2c8b8>@@QBEPAUImFont@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MPBGPAUImFontConfig@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??R<lambda_7a12fd051827e0f33bd65ef841f2c8b8>@@QBEPAUImFont@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MPBGPAUImFontConfig@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??__Fbuf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPBDPAX@Z@YAXXZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??__Fbuf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPBDPAX@Z@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??__Fbuf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPBDPAX@Z@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z$18 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z$0
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z$18
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@I@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1ImGuiDrawContext@@QAE@XZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??1ImGuiDrawContext@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1ImGuiDrawContext@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@UImGuiColumnData@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@UImGuiGroupData@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@H@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1ImGuiContext@@QAE@XZ DD 019930522H
	DD	0eH
	DD	FLAT:__unwindtable$??1ImGuiContext@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1ImGuiContext@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0ImGuiContext@@QAE@XZ DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$??0ImGuiContext@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0ImGuiContext@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ImGuiContext@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0ImGuiContext@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0ImGuiContext@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0ImGuiContext@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0ImGuiContext@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0ImGuiContext@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0ImGuiContext@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0ImGuiContext@@QAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??0ImGuiContext@@QAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??0ImGuiContext@@QAE@XZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$??0ImGuiContext@@QAE@XZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$??0ImGuiContext@@QAE@XZ$11
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@PAUImDrawList@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@UImGuiPopupRef@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@UImGuiStyleMod@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@UImGuiColMod@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@UImGuiIniData@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@PAUImGuiWindow@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1ImGuiTextEditState@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1ImGuiTextEditState@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1ImGuiTextEditState@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@M@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@PAUImFont@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1ImDrawList@@QAE@XZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??1ImDrawList@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1ImDrawList@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0ImDrawList@@QAE@XZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??0ImDrawList@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0ImDrawList@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ImDrawList@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0ImDrawList@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0ImDrawList@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0ImDrawList@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0ImDrawList@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0ImDrawList@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0ImDrawList@@QAE@XZ$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@UImDrawChannel@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@UImVec2@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@PAX@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@UImVec4@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@UImDrawVert@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@G@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@UImDrawCmd@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1ImGuiStorage@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1ImGuiStorage@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1ImGuiStorage@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@UPair@ImGuiStorage@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_GImGuiTextBuffer@@QAEPAXI@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??_GImGuiTextBuffer@@QAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_GImGuiTextBuffer@@QAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1ImGuiTextBuffer@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1ImGuiTextBuffer@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1ImGuiTextBuffer@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ImGuiTextBuffer@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ImGuiTextBuffer@@QAE@XZ$0
__ehfuncinfo$??0ImGuiTextBuffer@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0ImGuiTextBuffer@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@D@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$ImVector@UTextRange@ImGuiTextFilter@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?SK_ImGui_LoadFonts@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SK_ImGui_LoadFonts@@YAXXZ$0
__unwindtable$?CreateNewWindow@@YAPAUImGuiWindow@@PBDUImVec2@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateNewWindow@@YAPAUImGuiWindow@@PBDUImVec2@@H@Z$0
__unwindtable$??0ImGuiTextFilter@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ImGuiTextFilter@@QAE@PBD@Z$0
__unwindtable$?CreateContext@ImGui@@YAPAUImGuiContext@@P6APAXI@ZP6AXPAX@Z@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateContext@ImGui@@YAPAUImGuiContext@@P6APAXI@ZP6AXPAX@Z@Z$0
__unwindtable$?Shutdown@ImGui@@YAXXZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__unwindtable$??1ImGuiWindow@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__unwindtable$?ImFileOpen@@YAPAU_iobuf@@PBD0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ImFileOpen@@YAPAU_iobuf@@PBD0@Z$0
	DD	0ffffffffH
	DD	FLAT:___std_terminate
__unwindtable$?NewFrame@ImGui@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?NewFrame@ImGui@@YAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?NewFrame@ImGui@@YAXXZ$1
__unwindtable$??0ImGuiWindow@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ImGuiWindow@@QAE@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0ImGuiWindow@@QAE@PBD@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0ImGuiWindow@@QAE@PBD@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0ImGuiWindow@@QAE@PBD@Z$3
__ehfuncinfo$?SK_ImGui_LoadFonts@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SK_ImGui_LoadFonts@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?CreateNewWindow@@YAPAUImGuiWindow@@PBDUImVec2@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CreateNewWindow@@YAPAUImGuiWindow@@PBDUImVec2@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??1ImGuiWindow@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1ImGuiWindow@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__ehfuncinfo$??0ImGuiWindow@@QAE@PBD@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0ImGuiWindow@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?ImFileOpen@@YAPAU_iobuf@@PBD0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ImFileOpen@@YAPAU_iobuf@@PBD0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0ImGuiTextFilter@@QAE@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0ImGuiTextFilter@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?CreateContext@ImGui@@YAPAUImGuiContext@@P6APAXI@ZP6AXPAX@Z@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CreateContext@ImGui@@YAPAUImGuiContext@@P6APAXI@ZP6AXPAX@Z@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?Shutdown@ImGui@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Shutdown@ImGui@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?NewFrame@ImGui@@YAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?NewFrame@ImGui@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
?GImDefaultContext$initializer$@@3P6AXXZA DD FLAT:??__EGImDefaultContext@@YAXXZ ; GImDefaultContext$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?font_lock$initializer$@@3P6AXXZA DD FLAT:??__Efont_lock@@YAXXZ ; font_lock$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 839  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 841  : 		}

	pop	ebp
	ret	8
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 846  : 		_Ptr->~_Uty();
; 847  : 		}

	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z PROC	; std::allocator<wchar_t>::destroy<wchar_t *>, COMDAT
; _this$ = ecx

; 846  : 		_Ptr->~_Uty();
; 847  : 		}

	ret	4
??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ENDP	; std::allocator<wchar_t>::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 958  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN8@construct:

; 959  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 960  : 		}

	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 965  : 		_Al.destroy(_Ptr);
; 966  : 		}

	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z PROC ; std::allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>, COMDAT

; 965  : 		_Al.destroy(_Ptr);
; 966  : 		}

	ret	0
??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ENDP ; std::allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1596 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	ret	8
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 1096 : 		_Mytraits::construct(*this, _Ptr,
; 1097 : 			_STD forward<_Types>(_Args)...);
; 1098 : 		}

	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
;	COMDAT ??$_Min_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Min_value@I@std@@YAABIABI0@Z PROC			; std::_Min_value<unsigned int>, COMDAT

; 22   : 	{	// return smaller of _Left and _Right

	npad	2
	push	ebp
	mov	ebp, esp

; 23   : 	return (_Right < _Left ? _Right : _Left);

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	cmovb	eax, edx

; 24   : 	}

	pop	ebp
	ret	0
??$_Min_value@I@std@@YAABIABI0@Z ENDP			; std::_Min_value<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 642  : 	{	// do nothing for plain pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 644  : 	}

	pop	ebp
	ret	0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$_Unfancy@_W@std@@YAPA_WPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@_W@std@@YAPA_WPA_W@Z PROC			; std::_Unfancy<wchar_t>, COMDAT

; 642  : 	{	// do nothing for plain pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 644  : 	}

	pop	ebp
	ret	0
??$_Unfancy@_W@std@@YAPA_WPA_W@Z ENDP			; std::_Unfancy<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 1103 : 		_Mytraits::destroy(*this, _Ptr);
; 1104 : 		}

	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>, COMDAT
; _this$ = ecx

; 1103 : 		_Mytraits::destroy(*this, _Ptr);
; 1104 : 		}

	ret	4
??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z PROC		; std::addressof<wchar_t *>, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z ENDP		; std::addressof<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> >, COMDAT
; _this$ = ecx

; 1054 : 		}

	mov	eax, ecx
	ret	4
??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>, COMDAT
; _this$ = ecx

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 1705 : 		}

	mov	eax, ecx

; 1596 : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 1705 : 		}

	ret	4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<char> > &>, COMDAT

; 1350 : 	{	// forward _Arg as movable

	npad	2
	push	ebp
	mov	ebp, esp

; 1351 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1352 : 	}

	pop	ebp
	ret	0
??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_state$ = -32						; size = 16
_visible$1 = -2						; size = 1
_nav$2 = -1						; size = 1
?SK_ImGui_PollGamepad@@YAXXZ PROC			; SK_ImGui_PollGamepad

; 12231: {

	npad	2
	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	esi
	push	edi

; 12232:   ImGuiIO& io =

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	esi, eax

; 12233:     ImGui::GetIO ();
; 12234: 
; 12235: 
; 12236:   //extern INT SK_ImGui_ActivationKeys [256];
; 12237:   //
; 12238:   //for (int i = 8; i < 256; i++)
; 12239:   //{
; 12240:   //  if (SK_ImGui_ActivationKeys [i] > 0)
; 12241:   //  {
; 12242:   //    game_window.CallProc (game_window.hWnd, WM_KEYUP,    i, 0);
; 12243:   //    game_window.CallProc (game_window.hWnd, WM_SYSKEYUP, i, 0);
; 12244:   //
; 12245:   //    SK_ImGui_ActivationKeys [i] = 0;
; 12246:   //  }
; 12247:   //}
; 12248: 
; 12249: 
; 12250:          XINPUT_STATE state    = {      };
; 12251:   static XINPUT_STATE last_state { 1, 0 };
; 12252: 
; 12253:   for ( float& NavInput : io.NavInputs )

	lea	edi, DWORD PTR [esi+776]
	lea	edx, DWORD PTR [edi+64]
	cmp	edx, edi
	sbb	ecx, ecx
	and	ecx, -16				; fffffff0H
	add	ecx, 16					; 00000010H
	cmp	edi, edx
	ja	SHORT $LN3@SK_ImGui_P

; 12254:     NavInput = 0.0f;

	xor	eax, eax
	rep stosd
	lea	edi, DWORD PTR [esi+776]
$LN3@SK_ImGui_P:

; 12255: 
; 12256:   bool api_bridge =
; 12257:     config.input.gamepad.native_ps4 || ( steam_to_xi != nullptr );

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+674, 0
	movss	xmm5, DWORD PTR __real@3a83126f
	jne	SHORT $LN27@SK_ImGui_P
	cmp	DWORD PTR ?steam_to_xi@@3PAU_XINPUT_STATE@@A, 0 ; steam_to_xi
	jne	SHORT $LN27@SK_ImGui_P

; 12258: 
; 12259: #if 1
; 12260:   state = joy_to_xi;

	movups	xmm0, XMMWORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A

; 12261: #else
; 12262:   state = di8_to_xi;
; 12263: #endif
; 12264: 
; 12265:   if ( ( api_bridge ||
; 12266:          SK_XInput_PollController ( config.input.gamepad.xinput.ui_slot,
; 12267:                                       &state
; 12268:                                   )
; 12269:         )                                &&

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	push	DWORD PTR ?config@@3Usk_config_t@@A+680
	movups	XMMWORD PTR _state$[ebp], xmm0
	call	?SK_XInput_PollController@@YA_NHPAU_XINPUT_STATE@@@Z ; SK_XInput_PollController
	add	esp, 8
	test	al, al
	je	$LN91@SK_ImGui_P
	movaps	xmm0, XMMWORD PTR _state$[ebp]
	movss	xmm5, DWORD PTR __real@3a83126f
	jmp	SHORT $LN6@SK_ImGui_P
$LN27@SK_ImGui_P:

; 12258: 
; 12259: #if 1
; 12260:   state = joy_to_xi;

	movups	xmm0, XMMWORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A
	movaps	XMMWORD PTR _state$[ebp], xmm0
$LN6@SK_ImGui_P:

; 12261: #else
; 12262:   state = di8_to_xi;
; 12263: #endif
; 12264: 
; 12265:   if ( ( api_bridge ||
; 12266:          SK_XInput_PollController ( config.input.gamepad.xinput.ui_slot,
; 12267:                                       &state
; 12268:                                   )
; 12269:         )                                &&

	movd	eax, xmm0
	cmp	DWORD PTR ?last_state@?1??SK_ImGui_PollGamepad@@YAXXZ@4U_XINPUT_STATE@@A, eax
	ja	$LN91@SK_ImGui_P

; 12270:         last_state.dwPacketNumber <= state.dwPacketNumber
; 12271:      )
; 12272:   {
; 12273:     last_state = state;
; 12274: 
; 12275:     if (nav_usable)

	cmp	BYTE PTR ?nav_usable@@3_NA, 0		; nav_usable
	movups	XMMWORD PTR ?last_state@?1??SK_ImGui_PollGamepad@@YAXXZ@4U_XINPUT_STATE@@A, xmm0
	je	$LN91@SK_ImGui_P

; 12276:     {
; 12277:       float LX   = state.Gamepad.sThumbLX;

	movsx	eax, WORD PTR _state$[ebp+8]
	xorps	xmm4, xmm4
	movd	xmm2, eax

; 12278:       float LY   = state.Gamepad.sThumbLY;

	movsx	eax, WORD PTR _state$[ebp+10]
	cvtdq2ps xmm2, xmm2
	movd	xmm3, eax
	cvtdq2ps xmm3, xmm3

; 12279: 
; 12280:       float norm = sqrt ( LX*LX + LY*LY );

	movaps	xmm0, xmm2
	movaps	xmm1, xmm3
	mulss	xmm0, xmm2
	mulss	xmm1, xmm3
	addss	xmm1, xmm0

; 12287:       if (norm > XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE)

	movss	xmm0, DWORD PTR __real@45f54800
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 746  :         return (float)sqrt(_X);

	sqrtss	xmm4, xmm1
	xorps	xmm1, xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12287:       if (norm > XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE)

	comiss	xmm4, xmm0
	jbe	SHORT $LN8@SK_ImGui_P

; 12288:       {
; 12289:         norm = std::min (norm, 32767.0f) - XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE;

	minss	xmm4, DWORD PTR __real@46fffe00
	subss	xmm4, xmm0

; 12290:         unit =           norm/(32767.0f  - XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE);

	mulss	xmm4, DWORD PTR __real@38285303

; 12291:       }
; 12292: 
; 12293:       else

	jmp	SHORT $LN9@SK_ImGui_P
$LN8@SK_ImGui_P:
	xorps	xmm4, xmm4
$LN9@SK_ImGui_P:

; 12294:       {
; 12295:         norm = 0.0f;
; 12296:         unit = 0.0f;
; 12297:       }
; 12298: 
; 12299:       float uLX = (LX / 32767.0f) * unit;
; 12300:       float uLY = (LY / 32767.0f) * unit;
; 12301: 
; 12302:       // Press Button, Tweak Value                    // e.g. Circle button
; 12303:       io.NavInputs [ImGuiNavInput_PadActivate] +=

	mov	eax, DWORD PTR _state$[ebp+4]
	shr	eax, 12					; 0000000cH
	and	eax, 1
	mulss	xmm3, DWORD PTR __real@38000100
	mulss	xmm2, DWORD PTR __real@38000100
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm3, xmm4
	addss	xmm0, DWORD PTR [edi]
	mulss	xmm2, xmm4
	movss	DWORD PTR [edi], xmm0

; 12304:         static_cast <float> ((state.Gamepad.wButtons & XINPUT_GAMEPAD_A) != 0);
; 12305: 
; 12306:       // Close Menu/PopUp/Child, Clear Selection      // e.g. Cross button
; 12307:       io.NavInputs [ImGuiNavInput_PadCancel]   +=

	mov	eax, DWORD PTR _state$[ebp+4]
	shr	eax, 13					; 0000000dH
	and	eax, 1
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	addss	xmm0, DWORD PTR [esi+780]
	movss	DWORD PTR [esi+780], xmm0

; 12308:         static_cast <float> ((state.Gamepad.wButtons & XINPUT_GAMEPAD_B) != 0);
; 12309: 
; 12310:       // Text Input                                   // e.g. Triangle button
; 12311:       io.NavInputs [ImGuiNavInput_PadInput]    +=

	mov	ax, WORD PTR _state$[ebp+4]
	shr	ax, 15					; 0000000fH
	movzx	eax, ax
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	addss	xmm0, DWORD PTR [esi+784]
	movss	DWORD PTR [esi+784], xmm0

; 12312:         static_cast <float> ((state.Gamepad.wButtons & XINPUT_GAMEPAD_Y) != 0);
; 12313: 
; 12314:       // Access Menu, Focus, Move, Resize             // e.g. Square button
; 12315:       io.NavInputs [ImGuiNavInput_PadMenu]     +=

	mov	eax, DWORD PTR _state$[ebp+4]
	shr	eax, 14					; 0000000eH
	and	eax, 1
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	addss	xmm0, DWORD PTR [esi+788]
	movss	DWORD PTR [esi+788], xmm0

; 12316:         static_cast <float> ((state.Gamepad.wButtons & XINPUT_GAMEPAD_X) != 0);
; 12317: 
; 12318:       //
; 12319:       // [ANALOG INPUTS]
; 12320:       //
; 12321:       // Move Up, Resize Window (with PadMenu held)   // e.g. D-pad up/down/left/right
; 12322:       io.NavInputs [ImGuiNavInput_PadUp]    +=  0.001f *

	mov	eax, DWORD PTR _state$[ebp+4]
	and	eax, 1
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm5
	addss	xmm0, DWORD PTR [esi+792]
	movss	DWORD PTR [esi+792], xmm0

; 12323:         static_cast <float> (
; 12324:           (state.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP)    != 0
; 12325:         );
; 12326: 
; 12327:       // Move Down
; 12328:       io.NavInputs [ImGuiNavInput_PadDown]  +=  0.001f *

	mov	eax, DWORD PTR _state$[ebp+4]
	shr	eax, 1
	and	eax, 1
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm5
	addss	xmm0, DWORD PTR [esi+796]
	movss	DWORD PTR [esi+796], xmm0

; 12329:         static_cast <float> (
; 12330:           (state.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN)  != 0
; 12331:         );
; 12332: 
; 12333:       // Move Left
; 12334:       io.NavInputs [ImGuiNavInput_PadLeft]  +=  0.001f *

	mov	eax, DWORD PTR _state$[ebp+4]
	shr	eax, 2
	and	eax, 1
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm5
	addss	xmm0, DWORD PTR [esi+800]
	movss	DWORD PTR [esi+800], xmm0

; 12335:         static_cast <float> (
; 12336:           (state.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_LEFT)  != 0
; 12337:         );
; 12338: 
; 12339:       // Move Right
; 12340:       io.NavInputs [ImGuiNavInput_PadRight] +=  0.001f *

	mov	eax, DWORD PTR _state$[ebp+4]
	shr	eax, 3
	and	eax, 1
	mov	DWORD PTR [esi+812], 0

; 12341:         static_cast <float> (
; 12342:           (state.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT) != 0
; 12343:         );
; 12344: 
; 12345: 
; 12346:       io.NavInputs [ImGuiNavInput_PadScrollDown]    = 0.0f;
; 12347:       io.NavInputs [ImGuiNavInput_PadScrollUp]      = 0.0f;
; 12348: 
; 12349:       if (uLY > 0.0f)

	comiss	xmm3, xmm1
	mov	DWORD PTR [esi+808], 0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm5
	addss	xmm0, DWORD PTR [esi+804]
	movss	DWORD PTR [esi+804], xmm0
	movss	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	jbe	SHORT $LN10@SK_ImGui_P

; 12350:         io.NavInputs [ImGuiNavInput_PadScrollUp]   += uLY / analog_sensitivity;

	divss	xmm3, DWORD PTR ?analog_sensitivity@@3MA
	movss	DWORD PTR [esi+808], xmm3
	jmp	SHORT $LN12@SK_ImGui_P
$LN10@SK_ImGui_P:

; 12351: 
; 12352:       else if (uLY < 0.0f)

	comiss	xmm1, xmm3
	jbe	SHORT $LN12@SK_ImGui_P

; 12353:         io.NavInputs [ImGuiNavInput_PadScrollDown] -= uLY / analog_sensitivity;

	divss	xmm3, DWORD PTR ?analog_sensitivity@@3MA
	xorps	xmm3, xmm0
	movss	DWORD PTR [esi+812], xmm3
$LN12@SK_ImGui_P:

; 12354: 
; 12355: 
; 12356:       io.NavInputs [ImGuiNavInput_PadScrollLeft]    = 0.0f;
; 12357:       io.NavInputs [ImGuiNavInput_PadScrollRight]   = 0.0f;
; 12358: 
; 12359:       if (uLX > 0.0f)

	comiss	xmm2, xmm1
	mov	DWORD PTR [esi+816], 0
	mov	DWORD PTR [esi+820], 0
	jbe	SHORT $LN13@SK_ImGui_P

; 12360:         io.NavInputs [ImGuiNavInput_PadScrollRight] += uLX / analog_sensitivity;

	divss	xmm2, DWORD PTR ?analog_sensitivity@@3MA
	movss	DWORD PTR [esi+820], xmm2
	jmp	SHORT $LN15@SK_ImGui_P
$LN13@SK_ImGui_P:

; 12361: 
; 12362:       else if (uLX < 0.0f)

	comiss	xmm1, xmm2
	jbe	SHORT $LN15@SK_ImGui_P

; 12363:         io.NavInputs [ImGuiNavInput_PadScrollLeft]  -= uLX / analog_sensitivity;

	divss	xmm2, DWORD PTR ?analog_sensitivity@@3MA
	xorps	xmm2, xmm0
	movss	DWORD PTR [esi+816], xmm2
$LN15@SK_ImGui_P:

; 12364: 
; 12365: 
; 12366:       // Next Window (with PadMenu held)              // e.g. L-trigger
; 12367:       io.NavInputs [ImGuiNavInput_PadFocusPrev]   +=

	mov	eax, DWORD PTR _state$[ebp+4]
	shr	eax, 8
	and	eax, 1
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	addss	xmm0, DWORD PTR [esi+824]
	movss	DWORD PTR [esi+824], xmm0

; 12368:         static_cast <float> (
; 12369:           (state.Gamepad.wButtons & XINPUT_GAMEPAD_LEFT_SHOULDER) != 0
; 12370:         );
; 12371: 
; 12372:       // Prev Window (with PadMenu held)              // e.g. R-trigger
; 12373:       io.NavInputs [ImGuiNavInput_PadFocusNext]   += 

	mov	eax, DWORD PTR _state$[ebp+4]
	shr	eax, 9
	and	eax, 1
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	addss	xmm0, DWORD PTR [esi+828]
	movss	DWORD PTR [esi+828], xmm0

; 12374:         static_cast <float> (
; 12375:           (state.Gamepad.wButtons & XINPUT_GAMEPAD_RIGHT_SHOULDER) != 0
; 12376:         );
; 12377: 
; 12378:       io.NavInputs [ImGuiNavInput_PadTweakSlow] +=

	mov	al, BYTE PTR _state$[ebp+6]
	cmp	al, 30					; 0000001eH
	jbe	SHORT $LN29@SK_ImGui_P
	movzx	eax, al
	sub	eax, 30					; 0000001eH
	jmp	SHORT $LN30@SK_ImGui_P
$LN29@SK_ImGui_P:
	xor	eax, eax
$LN30@SK_ImGui_P:
	movss	xmm2, DWORD PTR __real@3b91a2b4
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm2
	addss	xmm0, DWORD PTR [esi+832]
	movss	DWORD PTR [esi+832], xmm0

; 12379:         static_cast <float> ( 
; 12380:           SK_Threshold ( state.Gamepad.bLeftTrigger, 
; 12381:                          XINPUT_GAMEPAD_TRIGGER_THRESHOLD ) ) /
; 12382:               ( 255.0f - XINPUT_GAMEPAD_TRIGGER_THRESHOLD     );
; 12383: 
; 12384:       io.NavInputs [ImGuiNavInput_PadTweakFast] +=

	mov	al, BYTE PTR _state$[ebp+7]
	cmp	al, 30					; 0000001eH
	jbe	SHORT $LN31@SK_ImGui_P
	movzx	eax, al
	sub	eax, 30					; 0000001eH
	jmp	SHORT $LN32@SK_ImGui_P
$LN31@SK_ImGui_P:
	xor	eax, eax
$LN32@SK_ImGui_P:
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm2
	addss	xmm0, DWORD PTR [esi+836]
	movss	DWORD PTR [esi+836], xmm0
	jmp	SHORT $LN88@SK_ImGui_P
$LN91@SK_ImGui_P:
	xorps	xmm1, xmm1
$LN88@SK_ImGui_P:

; 12385:         static_cast <float> (
; 12386:           SK_Threshold ( state.Gamepad.bRightTrigger,
; 12387:                          XINPUT_GAMEPAD_TRIGGER_THRESHOLD ) ) /
; 12388:               ( 255.0f - XINPUT_GAMEPAD_TRIGGER_THRESHOLD     );
; 12389:     }
; 12390:   }
; 12391: 
; 12392: 
; 12393:   if ( io.KeysDown         [VK_CAPITAL] &&

	cmp	BYTE PTR [esi+249], 0
	je	SHORT $LN16@SK_ImGui_P
	movss	xmm0, DWORD PTR [esi+1108]
	ucomiss	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN16@SK_ImGui_P

; 12394:        io.KeysDownDuration [VK_CAPITAL] == 0.0f )
; 12395:   {
; 12396:     bool visible = false,
; 12397:          nav     = true;
; 12398: 
; 12399:     SK_ImGui_ToggleEx (visible, nav);

	lea	eax, DWORD PTR _nav$2[ebp]
	mov	BYTE PTR _visible$1[ebp], 0
	push	eax
	lea	eax, DWORD PTR _visible$1[ebp]
	mov	BYTE PTR _nav$2[ebp], 1
	push	eax
	call	?SK_ImGui_ToggleEx@@YG_NAA_N0@Z		; SK_ImGui_ToggleEx
$LN16@SK_ImGui_P:

; 12400:   }
; 12401: 
; 12402: 
; 12403:   if (! nav_usable)

	cmp	BYTE PTR ?nav_usable@@3_NA, 0		; nav_usable
	jne	SHORT $LN17@SK_ImGui_P

; 12404:     io.NavActive = false;

	mov	BYTE PTR [esi+845], 0
$LN17@SK_ImGui_P:

; 12405: 
; 12406:   //
; 12407:   // Same basic idea as above, only for keyboard
; 12408:   //
; 12409:   //   The primary difference between gamepad and keyboard is the lack of a left
; 12410:   //     analog stick to differentiate D-Pad behavior from analog stick movement.
; 12411:   //
; 12412:   //   For keyboard, we alias both to the same task and also consider WASD to be
; 12413:   //     identical to Up/Down/Left/Right.
; 12414:   //
; 12415:   if (io.NavUsable && nav_usable)

	cmp	BYTE PTR [esi+844], 0
	movss	xmm2, DWORD PTR __real@3f800000
	je	$LN18@SK_ImGui_P
	cmp	BYTE PTR ?nav_usable@@3_NA, 0		; nav_usable
	je	$LN18@SK_ImGui_P

; 12416:   {
; 12417:     io.NavInputs [ImGuiNavInput_PadMenu] += (io.KeyCtrl) ? 1.0f : 0.0f;

	cmp	BYTE PTR [esi+225], 0
	xorps	xmm1, xmm1
	je	SHORT $LN33@SK_ImGui_P
	movaps	xmm3, xmm2
	jmp	SHORT $LN34@SK_ImGui_P
$LN33@SK_ImGui_P:
	xorps	xmm3, xmm3
$LN34@SK_ImGui_P:

; 12418: 
; 12419:     if (! io.WantTextInput)

	cmp	BYTE PTR [esi+842], 0
	movss	xmm0, DWORD PTR [esi+788]
	addss	xmm0, xmm3
	movss	DWORD PTR [esi+788], xmm0
	jne	$LN20@SK_ImGui_P

; 12420:     {
; 12421:       const bool up    = ( io.KeysDown ['W'] || io.KeysDown [VK_UP   ] );

	cmp	BYTE PTR [esi+316], 0
	jne	SHORT $LN35@SK_ImGui_P
	cmp	BYTE PTR [esi+267], 0
	jne	SHORT $LN35@SK_ImGui_P
	xor	dl, dl
	jmp	SHORT $LN36@SK_ImGui_P
$LN35@SK_ImGui_P:
	mov	dl, 1
$LN36@SK_ImGui_P:

; 12422:       const bool down  = ( io.KeysDown ['S'] || io.KeysDown [VK_DOWN ] );

	cmp	BYTE PTR [esi+312], 0
	jne	SHORT $LN37@SK_ImGui_P
	cmp	BYTE PTR [esi+269], 0
	jne	SHORT $LN37@SK_ImGui_P
	xor	ah, ah
	jmp	SHORT $LN38@SK_ImGui_P
$LN37@SK_ImGui_P:
	mov	ah, 1
$LN38@SK_ImGui_P:

; 12423:       const bool left  = ( io.KeysDown ['A'] || io.KeysDown [VK_LEFT ] );

	cmp	BYTE PTR [esi+294], 0
	jne	SHORT $LN39@SK_ImGui_P
	cmp	BYTE PTR [esi+266], 0
	jne	SHORT $LN39@SK_ImGui_P
	xor	cl, cl
	jmp	SHORT $LN40@SK_ImGui_P
$LN39@SK_ImGui_P:
	mov	cl, 1
$LN40@SK_ImGui_P:

; 12424:       const bool right = ( io.KeysDown ['D'] || io.KeysDown [VK_RIGHT] );

	cmp	BYTE PTR [esi+297], 0
	jne	SHORT $LN41@SK_ImGui_P
	cmp	BYTE PTR [esi+268], 0
	jne	SHORT $LN41@SK_ImGui_P
	xor	al, al
	jmp	SHORT $LN42@SK_ImGui_P
$LN41@SK_ImGui_P:
	mov	al, 1
$LN42@SK_ImGui_P:

; 12425: 
; 12426:       const float inv_analog     =
; 12427:           ( 1.0f / analog_sensitivity );
; 12428: 
; 12429:       const float analog_epsilon = 0.001f;
; 12430: 
; 12431:       io.NavInputs [ImGuiNavInput_PadScrollUp]    +=

	cmp	BYTE PTR [esi+262], 0
	movaps	xmm0, xmm2
	divss	xmm0, DWORD PTR ?analog_sensitivity@@3MA
	je	SHORT $LN43@SK_ImGui_P
	movaps	xmm3, xmm0
	jmp	SHORT $LN44@SK_ImGui_P
$LN43@SK_ImGui_P:
	xorps	xmm3, xmm3
$LN44@SK_ImGui_P:

; 12432:         (io.KeysDown [VK_PRIOR] ? inv_analog : 0.0f);
; 12433:       io.NavInputs [ImGuiNavInput_PadScrollDown]  +=

	cmp	BYTE PTR [esi+263], 0
	movss	xmm6, DWORD PTR [esi+808]
	addss	xmm6, xmm3
	movss	DWORD PTR [esi+808], xmm6
	je	SHORT $LN45@SK_ImGui_P
	movaps	xmm3, xmm0
	jmp	SHORT $LN46@SK_ImGui_P
$LN45@SK_ImGui_P:
	xorps	xmm3, xmm3
$LN46@SK_ImGui_P:

; 12434:         (io.KeysDown [VK_NEXT ] ? inv_analog : 0.0f);
; 12435:       io.NavInputs [ImGuiNavInput_PadScrollLeft]  +=

	cmp	BYTE PTR [esi+265], 0
	addss	xmm3, DWORD PTR [esi+812]
	movss	DWORD PTR [esi+812], xmm3
	je	SHORT $LN47@SK_ImGui_P
	movaps	xmm4, xmm0
	jmp	SHORT $LN48@SK_ImGui_P
$LN47@SK_ImGui_P:
	xorps	xmm4, xmm4
$LN48@SK_ImGui_P:

; 12436:         (io.KeysDown [VK_HOME ] ? inv_analog : 0.0f);
; 12437:       io.NavInputs [ImGuiNavInput_PadScrollRight] +=

	cmp	BYTE PTR [esi+264], 0
	movss	xmm7, DWORD PTR [esi+816]
	addss	xmm7, xmm4
	movss	DWORD PTR [esi+816], xmm7
	je	SHORT $LN49@SK_ImGui_P
	movaps	xmm5, xmm0
	jmp	SHORT $LN50@SK_ImGui_P
$LN49@SK_ImGui_P:
	xorps	xmm5, xmm5
$LN50@SK_ImGui_P:
	addss	xmm5, DWORD PTR [esi+820]
	movss	DWORD PTR [esi+820], xmm5

; 12438:         (io.KeysDown [VK_END  ] ? inv_analog : 0.0f);
; 12439: 
; 12440:       io.NavInputs [ImGuiNavInput_PadScrollUp]    +=

	test	dl, dl
	je	SHORT $LN51@SK_ImGui_P
	movaps	xmm4, xmm0
	jmp	SHORT $LN52@SK_ImGui_P
$LN51@SK_ImGui_P:
	xorps	xmm4, xmm4
$LN52@SK_ImGui_P:
	addss	xmm4, xmm6
	movss	DWORD PTR [esi+808], xmm4

; 12441:         (up    ? inv_analog : 0.0f);
; 12442:       io.NavInputs [ImGuiNavInput_PadScrollDown]  +=

	test	ah, ah
	je	SHORT $LN53@SK_ImGui_P
	movaps	xmm4, xmm0
	jmp	SHORT $LN54@SK_ImGui_P
$LN53@SK_ImGui_P:
	xorps	xmm4, xmm4
$LN54@SK_ImGui_P:
	addss	xmm4, xmm3
	movss	DWORD PTR [esi+812], xmm4

; 12443:         (down  ? inv_analog : 0.0f);
; 12444:       io.NavInputs [ImGuiNavInput_PadScrollLeft]  +=

	test	cl, cl
	je	SHORT $LN55@SK_ImGui_P
	movaps	xmm3, xmm0
	jmp	SHORT $LN56@SK_ImGui_P
$LN55@SK_ImGui_P:
	xorps	xmm3, xmm3
$LN56@SK_ImGui_P:
	addss	xmm3, xmm7
	movss	DWORD PTR [esi+816], xmm3

; 12445:         (left  ? inv_analog : 0.0f);
; 12446:       io.NavInputs [ImGuiNavInput_PadScrollRight] +=

	test	al, al
	jne	SHORT $LN58@SK_ImGui_P
	xorps	xmm0, xmm0
$LN58@SK_ImGui_P:

; 12447:         (right ? inv_analog : 0.0f);
; 12448: 
; 12449:       io.NavInputs [ImGuiNavInput_PadUp]          +=

	movss	xmm3, DWORD PTR __real@3a83126f
	addss	xmm0, xmm5
	movss	DWORD PTR [esi+820], xmm0
	test	dl, dl
	je	SHORT $LN59@SK_ImGui_P
	movaps	xmm0, xmm3
	jmp	SHORT $LN60@SK_ImGui_P
$LN59@SK_ImGui_P:
	xorps	xmm0, xmm0
$LN60@SK_ImGui_P:
	addss	xmm0, DWORD PTR [esi+792]
	movss	DWORD PTR [esi+792], xmm0

; 12450:         (up    ? analog_epsilon : 0.0f);
; 12451:       io.NavInputs [ImGuiNavInput_PadDown]        +=

	test	ah, ah
	je	SHORT $LN61@SK_ImGui_P
	movaps	xmm4, xmm3
	jmp	SHORT $LN62@SK_ImGui_P
$LN61@SK_ImGui_P:
	xorps	xmm4, xmm4
$LN62@SK_ImGui_P:
	movss	xmm0, DWORD PTR [esi+796]
	addss	xmm0, xmm4
	movss	DWORD PTR [esi+796], xmm0

; 12452:         (down  ? analog_epsilon : 0.0f);
; 12453:       io.NavInputs [ImGuiNavInput_PadLeft]        +=

	test	cl, cl
	je	SHORT $LN63@SK_ImGui_P
	movaps	xmm0, xmm3
	jmp	SHORT $LN64@SK_ImGui_P
$LN63@SK_ImGui_P:
	xorps	xmm0, xmm0
$LN64@SK_ImGui_P:
	addss	xmm0, DWORD PTR [esi+800]
	movss	DWORD PTR [esi+800], xmm0

; 12454:         (left  ? analog_epsilon : 0.0f);
; 12455:       io.NavInputs [ImGuiNavInput_PadRight]       +=

	test	al, al
	jne	SHORT $LN66@SK_ImGui_P
	xorps	xmm3, xmm3
$LN66@SK_ImGui_P:
	addss	xmm3, DWORD PTR [esi+804]
	movss	DWORD PTR [esi+804], xmm3
$LN20@SK_ImGui_P:

; 12456:         (right ? analog_epsilon : 0.0f);
; 12457:     }
; 12458: 
; 12459:     io.NavInputs  [ImGuiNavInput_PadActivate]     +=

	cmp	BYTE PTR [esi+242], 0
	je	SHORT $LN67@SK_ImGui_P
	movaps	xmm0, xmm2
	jmp	SHORT $LN68@SK_ImGui_P
$LN67@SK_ImGui_P:
	xorps	xmm0, xmm0
$LN68@SK_ImGui_P:

; 12460:       io.KeysDown [VK_RETURN]  ?  1.0f : 0.0f;
; 12461:     io.NavInputs  [ImGuiNavInput_PadCancel]       +=

	cmp	BYTE PTR [esi+256], 0
	addss	xmm0, DWORD PTR [edi]
	movss	DWORD PTR [edi], xmm0
	je	SHORT $LN69@SK_ImGui_P
	movaps	xmm1, xmm2
$LN69@SK_ImGui_P:
	movss	xmm0, DWORD PTR [esi+780]
	addss	xmm0, xmm1
	movss	DWORD PTR [esi+780], xmm0

; 12462:       io.KeysDown [VK_ESCAPE]  ?  1.0f : 0.0f;
; 12463:   }
; 12464: 
; 12465:   else

	jmp	SHORT $LN19@SK_ImGui_P
$LN18@SK_ImGui_P:

; 12466:     io.NavActive = false;

	mov	BYTE PTR [esi+845], 0
$LN19@SK_ImGui_P:

; 12467: 
; 12468:   io.NavInputs [ImGuiNavInput_PadFocusPrev] +=

	mov	al, BYTE PTR [esi+225]
	test	al, al
	je	SHORT $LN94@SK_ImGui_P
	cmp	BYTE PTR [esi+226], 0
	je	SHORT $LN94@SK_ImGui_P
	cmp	BYTE PTR [esi+238], 0
	xorps	xmm1, xmm1
	je	SHORT $LN71@SK_ImGui_P
	movss	xmm0, DWORD PTR [esi+1064]
	ucomiss	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN71@SK_ImGui_P
	movaps	xmm0, xmm2
	jmp	SHORT $LN72@SK_ImGui_P
$LN94@SK_ImGui_P:
	xorps	xmm1, xmm1
$LN71@SK_ImGui_P:
	xorps	xmm0, xmm0
$LN72@SK_ImGui_P:
	addss	xmm0, DWORD PTR [esi+824]
	movss	DWORD PTR [esi+824], xmm0

; 12469:     (io.KeyCtrl && io.KeyShift && io.KeysDown [VK_TAB] &&
; 12470:                           io.KeysDownDuration [VK_TAB] == 0.0f)  ? 1.0f : 0.0f;
; 12471: 
; 12472:   io.NavInputs [ImGuiNavInput_PadFocusNext] +=

	test	al, al
	je	SHORT $LN73@SK_ImGui_P
	cmp	BYTE PTR [esi+238], 0
	je	SHORT $LN73@SK_ImGui_P
	movss	xmm0, DWORD PTR [esi+1064]
	ucomiss	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN74@SK_ImGui_P
$LN73@SK_ImGui_P:
	xorps	xmm2, xmm2
$LN74@SK_ImGui_P:

; 12473:     (io.KeyCtrl                && io.KeysDown [VK_TAB] &&
; 12474:                           io.KeysDownDuration [VK_TAB] == 0.0f)  ? 1.0f : 0.0f;
; 12475: 
; 12476: 
; 12477: 
; 12478:   if (io.NavInputs [ImGuiNavInput_PadActivate] != 0.0f)

	movss	xmm0, DWORD PTR [edi]
	addss	xmm2, DWORD PTR [esi+828]
	ucomiss	xmm0, xmm1
	movss	DWORD PTR [esi+828], xmm2
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN21@SK_ImGui_P

; 12479:     io.MouseDown [4] = true;

	mov	BYTE PTR [esi+216], 1

; 12480:   else

	jmp	SHORT $LN22@SK_ImGui_P
$LN21@SK_ImGui_P:

; 12481:     io.MouseDown [4] = false;

	mov	BYTE PTR [esi+216], 0
$LN22@SK_ImGui_P:

; 12482: 
; 12483:   static DWORD last_toggle = 0UL;
; 12484: 
; 12485:   if ( ( io.NavInputs             [ImGuiNavInput_PadTweakSlow] != 0.0f &&
; 12486:          io.NavInputs             [ImGuiNavInput_PadTweakFast] != 0.0f )   &&

	movss	xmm0, DWORD PTR [esi+832]
	ucomiss	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN25@SK_ImGui_P
	movss	xmm0, DWORD PTR [esi+836]
	ucomiss	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN25@SK_ImGui_P
	movss	xmm0, DWORD PTR [esi+5180]
	ucomiss	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN24@SK_ImGui_P
	movss	xmm0, DWORD PTR [esi+5184]
	ucomiss	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN25@SK_ImGui_P
$LN24@SK_ImGui_P:

; 12487:        ( io.NavInputsDownDuration [ImGuiNavInput_PadTweakSlow] == 0.0f ||
; 12488:          io.NavInputsDownDuration [ImGuiNavInput_PadTweakFast] == 0.0f )      )
; 12489:   {
; 12490:     if (last_toggle < SK_GetFramesDrawn () - 1)

	call	?SK_GetFramesDrawn@@YGKXZ		; SK_GetFramesDrawn
	dec	eax
	cmp	DWORD PTR ?last_toggle@?1??SK_ImGui_PollGamepad@@YAXXZ@4KA, eax
	jae	SHORT $LN25@SK_ImGui_P

; 12491:     {
; 12492:       SK_ImGui_Widgets.hide_all = (! SK_ImGui_Widgets.hide_all);

	cmp	BYTE PTR ?SK_ImGui_Widgets@@3USK_ImGui_WidgetRegistry@@A+32, 0
	sete	BYTE PTR ?SK_ImGui_Widgets@@3USK_ImGui_WidgetRegistry@@A+32

; 12493:       last_toggle               =    SK_GetFramesDrawn ();

	call	?SK_GetFramesDrawn@@YGKXZ		; SK_GetFramesDrawn
	mov	DWORD PTR ?last_toggle@?1??SK_ImGui_PollGamepad@@YAXXZ@4KA, eax
$LN25@SK_ImGui_P:

; 12494:     }
; 12495:   }
; 12496: }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
?SK_ImGui_PollGamepad@@YAXXZ ENDP			; SK_ImGui_PollGamepad
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
;	COMDAT ??$min@M@std@@YAABMABM0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@M@std@@YAABMABM0@Z PROC				; std::min<float>, COMDAT

; 3778 : 	{	// return smaller of _Left and _Right

	npad	2
	push	ebp
	mov	ebp, esp

; 3779 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	movss	xmm0, DWORD PTR [eax]
	comiss	xmm0, DWORD PTR [ecx]
	cmova	eax, ecx

; 3780 : 	}

	pop	ebp
	ret	0
??$min@M@std@@YAABMABM0@Z ENDP				; std::min<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_joy_caps$1 = -856					; size = 728
$T2 = -128						; size = 16
_joy_ex$3 = -108					; size = 52
$T4 = -56						; size = 4
$T5 = -52						; size = 4
$T6 = -48						; size = 4
$T7 = -44						; size = 4
$T8 = -40						; size = 4
$T9 = -36						; size = 4
_state$ = -32						; size = 16
$T10 = -8						; size = 4
$T11 = -8						; size = 4
_toggle_nav$12 = -2					; size = 1
_toggle$13 = -2						; size = 1
_toggle_vis$14 = -1					; size = 1
_nav$15 = -1						; size = 1
?SK_ImGui_PollGamepad_EndFrame@@YAXXZ PROC		; SK_ImGui_PollGamepad_EndFrame

; 12071: {

	npad	2
	push	ebx
	mov	ebx, esp
	sub	esp, 8
	and	esp, -16				; fffffff0H
	add	esp, 4
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [esp+4], ebp
	mov	ebp, esp
	sub	esp, 856				; 00000358H
	push	esi
	push	edi

; 12072:   ImGuiIO& io (ImGui::GetIO ());

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	edi, eax

; 12073: 
; 12074:   // Reset Mouse / Keyboard State so that we can process all state transitions
; 12075:   //   that occur during the next frame without losing any input events.
; 12076:   if (GetForegroundWindow () == game_window.hWnd)

	call	DWORD PTR __imp__GetForegroundWindow@0
	cmp	eax, DWORD PTR ?game_window@@3Usk_window_s@@A+4
	jne	$LN5@SK_ImGui_P

; 12077:   {
; 12078:     io.MouseDown [0] = (GetAsyncKeyState_Original (VK_LBUTTON)  & 0x8000) != 0;

	push	1
	call	DWORD PTR ?GetAsyncKeyState_Original@@3P6GFH@ZA ; GetAsyncKeyState_Original
	shr	eax, 15					; 0000000fH
	and	al, 1

; 12079:     io.MouseDown [1] = (GetAsyncKeyState_Original (VK_RBUTTON)  & 0x8000) != 0;

	push	2
	mov	BYTE PTR [edi+212], al
	call	DWORD PTR ?GetAsyncKeyState_Original@@3P6GFH@ZA ; GetAsyncKeyState_Original
	shr	eax, 15					; 0000000fH
	and	al, 1

; 12080:     io.MouseDown [2] = (GetAsyncKeyState_Original (VK_MBUTTON)  & 0x8000) != 0;

	push	4
	mov	BYTE PTR [edi+213], al
	call	DWORD PTR ?GetAsyncKeyState_Original@@3P6GFH@ZA ; GetAsyncKeyState_Original
	shr	eax, 15					; 0000000fH
	and	al, 1

; 12081:     io.MouseDown [3] = (GetAsyncKeyState_Original (VK_XBUTTON1) & 0x8000) != 0;

	push	5
	mov	BYTE PTR [edi+214], al
	call	DWORD PTR ?GetAsyncKeyState_Original@@3P6GFH@ZA ; GetAsyncKeyState_Original
	shr	eax, 15					; 0000000fH
	and	al, 1

; 12082:     io.MouseDown [4] = (GetAsyncKeyState_Original (VK_XBUTTON2) & 0x8000) != 0;

	push	6
	mov	BYTE PTR [edi+215], al
	call	DWORD PTR ?GetAsyncKeyState_Original@@3P6GFH@ZA ; GetAsyncKeyState_Original
	shr	eax, 15					; 0000000fH

; 12083: 
; 12084:     // This stupid hack prevents the Steam overlay from making the software
; 12085:     //   think tab is stuck down.
; 12086:     for (int i = 8; i < 256; i++)

	mov	esi, 8
	and	al, 1
	mov	BYTE PTR [edi+216], al
	npad	3
$LL4@SK_ImGui_P:

; 12087:       io.KeysDown [i] = (GetAsyncKeyState_Original (i) & 0x8000) != 0;

	push	esi
	call	DWORD PTR ?GetAsyncKeyState_Original@@3P6GFH@ZA ; GetAsyncKeyState_Original
	shr	eax, 15					; 0000000fH
	and	al, 1
	mov	BYTE PTR [edi+esi+229], al
	inc	esi
	cmp	esi, 256				; 00000100H
	jl	SHORT $LL4@SK_ImGui_P

; 12088:   }
; 12089: 
; 12090:   else

	jmp	SHORT $LN6@SK_ImGui_P
$LN5@SK_ImGui_P:

; 12091:   {
; 12092:     ZeroMemory (io.KeysDown,  sizeof (bool) * 512);

	push	512					; 00000200H
	lea	eax, DWORD PTR [edi+229]
	push	0
	push	eax
	call	_memset

; 12093:     ZeroMemory (io.MouseDown, sizeof (bool) * 5);

	mov	DWORD PTR [edi+212], 0
	add	esp, 12					; 0000000cH
	mov	BYTE PTR [edi+216], 0
$LN6@SK_ImGui_P:

; 12094:   }
; 12095: 
; 12096:          XINPUT_STATE state      = {      };
; 12097:   static XINPUT_STATE last_state = { 1, 0 };
; 12098: 
; 12099:   bool api_bridge =
; 12100:     config.input.gamepad.native_ps4 || ( steam_to_xi != nullptr );

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+674, 0
	xorps	xmm0, xmm0
	mov	esi, DWORD PTR __imp__timeGetTime@0
	movaps	XMMWORD PTR _state$[ebp], xmm0
	jne	SHORT $LN28@SK_ImGui_P
	cmp	DWORD PTR ?steam_to_xi@@3PAU_XINPUT_STATE@@A, 0 ; steam_to_xi
	jne	SHORT $LN28@SK_ImGui_P

; 12117:   }
; 12118: 
; 12119: #if 1
; 12120:   state = joy_to_xi;

	movups	xmm0, XMMWORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A

; 12121: #else
; 12122:   state = di8_to_xi;
; 12123: #endif
; 12124: 
; 12125:   if ( api_bridge ||

	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	push	DWORD PTR ?config@@3Usk_config_t@@A+680
	movups	XMMWORD PTR _state$[ebp], xmm0
	call	?SK_XInput_PollController@@YA_NHPAU_XINPUT_STATE@@@Z ; SK_XInput_PollController
	add	esp, 8
	test	al, al
	jne	SHORT $LN100@SK_ImGui_P

; 12172:     }
; 12173:   }
; 12174: 
; 12175:   else
; 12176:     ZeroMemory (&state.Gamepad, sizeof XINPUT_GAMEPAD);

	xorps	xmm0, xmm0
	mov	DWORD PTR _state$[ebp+12], 0
	movq	QWORD PTR _state$[ebp+4], xmm0
	movaps	xmm1, XMMWORD PTR _state$[ebp]
	jmp	$LN102@SK_ImGui_P
$LN100@SK_ImGui_P:

; 12117:   }
; 12118: 
; 12119: #if 1
; 12120:   state = joy_to_xi;

	movaps	xmm1, XMMWORD PTR _state$[ebp]
	jmp	SHORT $LN10@SK_ImGui_P
$LN28@SK_ImGui_P:

; 12101: 
; 12102:   if (api_bridge)
; 12103:   {
; 12104:     // Translate DirectInput to XInput, because I'm not writing multiple controller codepaths
; 12105:     //   for no good reason.
; 12106:     JOYINFOEX joy_ex   { };

	push	52					; 00000034H
	lea	eax, DWORD PTR _joy_ex$3[ebp]
	push	0
	push	eax
	call	_memset

; 12107:     JOYCAPSW  joy_caps { };

	push	728					; 000002d8H
	lea	eax, DWORD PTR _joy_caps$1[ebp]
	push	0
	push	eax
	call	_memset
	add	esp, 24					; 00000018H

; 12108: 
; 12109:     joy_ex.dwSize  = sizeof JOYINFOEX;

	mov	DWORD PTR _joy_ex$3[ebp], 52		; 00000034H

; 12110:     joy_ex.dwFlags = JOY_RETURNALL      | JOY_RETURNPOVCTS |
; 12111:                      JOY_RETURNCENTERED | JOY_USEDEADZONE;
; 12112: 
; 12113:     joyGetPosEx    (JOYSTICKID1, &joy_ex);

	lea	eax, DWORD PTR _joy_ex$3[ebp]
	mov	DWORD PTR _joy_ex$3[ebp+4], 3839	; 00000effH
	push	eax
	push	0
	call	DWORD PTR __imp__joyGetPosEx@8

; 12114:     joyGetDevCapsW (JOYSTICKID1, &joy_caps, sizeof JOYCAPSW);

	push	728					; 000002d8H
	lea	eax, DWORD PTR _joy_caps$1[ebp]
	push	eax
	push	0
	call	DWORD PTR __imp__joyGetDevCapsW@12

; 12115: 
; 12116:     SK_JOY_TranslateToXInput (&joy_ex, &joy_caps);

	lea	eax, DWORD PTR _joy_caps$1[ebp]
	push	eax
	lea	eax, DWORD PTR _joy_ex$3[ebp]
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?SK_JOY_TranslateToXInput@@YA?AU_XINPUT_STATE@@PAUjoyinfoex_tag@@PBUtagJOYCAPSW@@@Z ; SK_JOY_TranslateToXInput

; 12117:   }
; 12118: 
; 12119: #if 1
; 12120:   state = joy_to_xi;

	movups	xmm1, XMMWORD PTR ?joy_to_xi@@3U_XINPUT_STATE@@A
	add	esp, 12					; 0000000cH
	movaps	XMMWORD PTR _state$[ebp], xmm1
$LN10@SK_ImGui_P:

; 12126:        SK_XInput_PollController (config.input.gamepad.xinput.ui_slot, &state) )
; 12127:   {
; 12128:     if ( state.Gamepad.wButtons & XINPUT_GAMEPAD_BACK  &&
; 12129:          state.Gamepad.wButtons & XINPUT_GAMEPAD_START &&

	movaps	xmm0, xmm1
	psrldq	xmm0, 4
	movd	eax, xmm0
	test	al, 32					; 00000020H
	je	SHORT $LN101@SK_ImGui_P
	test	al, 16					; 00000010H
	je	SHORT $LN101@SK_ImGui_P
	movd	edx, xmm1
	cmp	DWORD PTR ?last_state@?1??SK_ImGui_PollGamepad_EndFrame@@YAXXZ@4U_XINPUT_STATE@@A, edx
	ja	$LN102@SK_ImGui_P

; 12130:          last_state.dwPacketNumber <= state.dwPacketNumber )
; 12131:     {
; 12132:       if (! ( last_state.Gamepad.wButtons & XINPUT_GAMEPAD_BACK &&

	mov	cx, WORD PTR ?last_state@?1??SK_ImGui_PollGamepad_EndFrame@@YAXXZ@4U_XINPUT_STATE@@A+4
	test	cl, 32					; 00000020H
	je	SHORT $LN13@SK_ImGui_P
	test	cl, 16					; 00000010H
	jne	SHORT $LN14@SK_ImGui_P
$LN13@SK_ImGui_P:

; 12133:               last_state.Gamepad.wButtons & XINPUT_GAMEPAD_START ) )
; 12134:       {
; 12135:         bool toggle = true,
; 12136:              nav    = (! nav_usable);

	cmp	BYTE PTR ?nav_usable@@3_NA, 0		; nav_usable

; 12137: 
; 12138:         // Additional condition for Final Fantasy X so as not to interfere with soft reset
; 12139:         if (! ( state.Gamepad.bLeftTrigger  > XINPUT_GAMEPAD_TRIGGER_THRESHOLD || 

	movaps	xmm0, xmm1
	psrldq	xmm0, 6
	movd	eax, xmm0
	sete	BYTE PTR _nav$15[ebp]
	mov	BYTE PTR _toggle$13[ebp], 1
	cmp	al, 30					; 0000001eH
	ja	SHORT $LN14@SK_ImGui_P
	movaps	xmm0, xmm1
	psrldq	xmm0, 7
	movd	eax, xmm0
	cmp	al, 30					; 0000001eH
	ja	SHORT $LN14@SK_ImGui_P

; 12140:                 state.Gamepad.bRightTrigger > XINPUT_GAMEPAD_TRIGGER_THRESHOLD ) )
; 12141:         {
; 12142:           SK_ImGui_ToggleEx (toggle, nav);

	lea	eax, DWORD PTR _nav$15[ebp]
	push	eax
	lea	eax, DWORD PTR _toggle$13[ebp]
	push	eax
	call	?SK_ImGui_ToggleEx@@YG_NAA_N0@Z		; SK_ImGui_ToggleEx
	movaps	xmm1, XMMWORD PTR _state$[ebp]
$LN101@SK_ImGui_P:
	mov	cx, WORD PTR ?last_state@?1??SK_ImGui_PollGamepad_EndFrame@@YAXXZ@4U_XINPUT_STATE@@A+4
	mov	edx, DWORD PTR _state$[ebp]
$LN14@SK_ImGui_P:

; 12143:         }
; 12144:       }
; 12145:     }
; 12146: 
; 12147:      const DWORD LONG_PRESS  = 400UL;
; 12148:     static DWORD dwLastPress = MAXDWORD;
; 12149: 
; 12150:     if (last_state.dwPacketNumber <= state.dwPacketNumber)

	cmp	DWORD PTR ?last_state@?1??SK_ImGui_PollGamepad_EndFrame@@YAXXZ@4U_XINPUT_STATE@@A, edx
	ja	$LN102@SK_ImGui_P

; 12151:     {
; 12152:       if ( (     state.Gamepad.wButtons & XINPUT_GAMEPAD_BACK) &&

	movaps	xmm0, xmm1
	psrldq	xmm0, 4
	movd	eax, xmm0
	and	eax, 32					; 00000020H
	je	$LN16@SK_ImGui_P
	test	cl, 32					; 00000020H
	je	$LN16@SK_ImGui_P

; 12153:            (last_state.Gamepad.wButtons & XINPUT_GAMEPAD_BACK) )
; 12154:       {
; 12155:         if (dwLastPress < timeGetTime () - LONG_PRESS)

	call	esi
	sub	eax, 400				; 00000190H
	cmp	DWORD PTR ?dwLastPress@?O@??SK_ImGui_PollGamepad_EndFrame@@YAXXZ@4KA, eax
	jae	$LN103@SK_ImGui_P
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1466 : static inline bool SK_ImGui_Active (void) { return SK_ImGui_Visible || SK_ReShade_Visible; };

	cmp	BYTE PTR ?SK_ImGui_Visible@@3_NA, 0	; SK_ImGui_Visible
	jne	SHORT $LN32@SK_ImGui_P
	cmp	BYTE PTR ?SK_ReShade_Visible@@3_NA, 0	; SK_ReShade_Visible
	jne	SHORT $LN32@SK_ImGui_P
	xor	eax, eax
	jmp	SHORT $LN33@SK_ImGui_P
$LN32@SK_ImGui_P:
	mov	eax, 1
$LN33@SK_ImGui_P:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12157:           bool toggle_vis = (! SK_ImGui_Active ());

	test	al, al

; 12158:           bool toggle_nav =    true;

	mov	BYTE PTR _toggle_nav$12[ebp], 1
	sete	BYTE PTR _toggle_vis$14[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1466 : static inline bool SK_ImGui_Active (void) { return SK_ImGui_Visible || SK_ReShade_Visible; };

	cmp	BYTE PTR ?SK_ImGui_Visible@@3_NA, 0	; SK_ImGui_Visible
	jne	SHORT $LN36@SK_ImGui_P
	cmp	BYTE PTR ?SK_ReShade_Visible@@3_NA, 0	; SK_ReShade_Visible
	je	SHORT $LN19@SK_ImGui_P
$LN36@SK_ImGui_P:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12161:             SK_ImGui_ToggleEx (toggle_vis, toggle_nav);

	lea	eax, DWORD PTR _toggle_nav$12[ebp]
	push	eax
	lea	eax, DWORD PTR _toggle_vis$14[ebp]
	push	eax
	call	?SK_ImGui_ToggleEx@@YG_NAA_N0@Z		; SK_ImGui_ToggleEx
$LN19@SK_ImGui_P:

; 12162: 
; 12163:           dwLastPress = MAXDWORD;
; 12164:         }
; 12165:       }

	movaps	xmm1, XMMWORD PTR _state$[ebp]
$LN20@SK_ImGui_P:

; 12171:         dwLastPress = MAXDWORD;

	mov	DWORD PTR ?dwLastPress@?O@??SK_ImGui_PollGamepad_EndFrame@@YAXXZ@4KA, -1
$LN102@SK_ImGui_P:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1466 : static inline bool SK_ImGui_Active (void) { return SK_ImGui_Visible || SK_ReShade_Visible; };

	cmp	BYTE PTR ?SK_ImGui_Visible@@3_NA, 0	; SK_ImGui_Visible
	jne	SHORT $LN40@SK_ImGui_P
	cmp	BYTE PTR ?SK_ReShade_Visible@@3_NA, 0	; SK_ReShade_Visible
	je	$LN98@SK_ImGui_P
$LN40@SK_ImGui_P:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12179:   if (SK_ImGui_Active () && config.input.gamepad.haptic_ui)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+670, 0
	je	$LN98@SK_ImGui_P

; 12180:   {
; 12181:     ImGuiContext& g =

	mov	edi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 12182:       *GImGui;
; 12183: 
; 12184:     static ImGuiID nav_id = 0;
; 12185: 
; 12186:     if (g.NavId != nav_id)

	mov	eax, DWORD PTR [edi+6384]
	cmp	eax, DWORD PTR ?nav_id@?CK@??SK_ImGui_PollGamepad_EndFrame@@YAXXZ@4IA
	je	$LN25@SK_ImGui_P

; 12187:     {
; 12188:       if (haptic_events.PulseNav.end > static_cast <float> (timeGetTime ()))

	call	esi
	movss	xmm2, DWORD PTR ?haptic_events@@3U<unnamed-type-haptic_events>@@A+44
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	comiss	xmm2, xmm0
	jbe	SHORT $LN24@SK_ImGui_P

; 12189:       {
; 12190:         haptic_events.PulseNav.end   += haptic_events.PulseNav.duration;

	movss	xmm1, DWORD PTR ?haptic_events@@3U<unnamed-type-haptic_events>@@A+32
	movaps	xmm0, xmm1
	addss	xmm0, xmm2
	movss	DWORD PTR ?haptic_events@@3U<unnamed-type-haptic_events>@@A+44, xmm0

; 12191:         haptic_events.PulseNav.start += haptic_events.PulseNav.duration;

	movss	xmm0, DWORD PTR ?haptic_events@@3U<unnamed-type-haptic_events>@@A+40
	addss	xmm0, xmm1
	movss	DWORD PTR ?haptic_events@@3U<unnamed-type-haptic_events>@@A+40, xmm0

; 12192:       }
; 12193: 
; 12194:       else

	jmp	SHORT $LN25@SK_ImGui_P
$LN16@SK_ImGui_P:

; 12166: 
; 12167:       else if (state.Gamepad.wButtons & XINPUT_GAMEPAD_BACK)

	test	ax, ax
	je	$LN20@SK_ImGui_P

; 12168:         dwLastPress = timeGetTime ();

	call	esi
	mov	DWORD PTR ?dwLastPress@?O@??SK_ImGui_PollGamepad_EndFrame@@YAXXZ@4KA, eax
$LN103@SK_ImGui_P:

; 12169: 
; 12170:       else

	movaps	xmm1, XMMWORD PTR _state$[ebp]
	jmp	$LN102@SK_ImGui_P
$LN24@SK_ImGui_P:

; 12195:       {
; 12196:         haptic_events.PulseNav.start = static_cast <float> (timeGetTime ());

	call	esi
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR ?haptic_events@@3U<unnamed-type-haptic_events>@@A+40, xmm0

; 12197:         haptic_events.PulseNav.end   = haptic_events.PulseNav.start +

	addss	xmm0, DWORD PTR ?haptic_events@@3U<unnamed-type-haptic_events>@@A+32
	movss	DWORD PTR ?haptic_events@@3U<unnamed-type-haptic_events>@@A+44, xmm0
$LN25@SK_ImGui_P:

; 12198:                                          haptic_events.PulseNav.duration;
; 12199:       }
; 12200:     }
; 12201: 
; 12202:     if (g.ActiveIdIsJustActivated)

	cmp	BYTE PTR [edi+6273], 0
	je	SHORT $LN26@SK_ImGui_P

; 12203:     {
; 12204:       haptic_events.PulseButton.start = static_cast <float> (timeGetTime ());

	call	esi
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm1, xmm0

; 12205:       haptic_events.PulseButton.end   = haptic_events.PulseButton.start +

	movss	xmm0, DWORD PTR ?haptic_events@@3U<unnamed-type-haptic_events>@@A+16
	addss	xmm0, xmm1
	movss	DWORD PTR ?haptic_events@@3U<unnamed-type-haptic_events>@@A+24, xmm1
	movss	DWORD PTR ?haptic_events@@3U<unnamed-type-haptic_events>@@A+28, xmm0
$LN26@SK_ImGui_P:

; 11996:       auto now = static_cast <float> (timeGetTime ());

	call	esi
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH

; 11997:       
; 11998:       return config.input.gamepad.haptic_ui ?

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+670, 0
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm2, xmm0
	je	SHORT $LN44@SK_ImGui_P
	movss	xmm0, DWORD PTR ?haptic_events@@3U<unnamed-type-haptic_events>@@A+44
	movaps	xmm1, xmm0
	subss	xmm0, DWORD PTR ?haptic_events@@3U<unnamed-type-haptic_events>@@A+40
	subss	xmm1, xmm2
	divss	xmm1, xmm0
	mulss	xmm1, DWORD PTR ?haptic_events@@3U<unnamed-type-haptic_events>@@A+36
	maxss	xmm1, DWORD PTR __real@00000000
	movss	DWORD PTR $T11[ebp], xmm1
	movss	DWORD PTR $T9[ebp], xmm1
	jmp	SHORT $LN45@SK_ImGui_P
$LN44@SK_ImGui_P:
	xorps	xmm0, xmm0
	movss	DWORD PTR $T11[ebp], xmm0
	movss	DWORD PTR $T9[ebp], xmm0
$LN45@SK_ImGui_P:

; 12206:                                           haptic_events.PulseButton.duration;
; 12207:     }
; 12208: 
; 12209:     SK_XInput_PulseController ( config.input.gamepad.xinput.ui_slot,

	mov	DWORD PTR $T5[ebp], 1053609165		; 3ecccccdH

; 11996:       auto now = static_cast <float> (timeGetTime ());

	call	esi
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH

; 11997:       
; 11998:       return config.input.gamepad.haptic_ui ?

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+670, 0
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm2, xmm0
	je	SHORT $LN51@SK_ImGui_P
	movss	xmm0, DWORD PTR ?haptic_events@@3U<unnamed-type-haptic_events>@@A+44
	movaps	xmm1, xmm0
	subss	xmm0, DWORD PTR ?haptic_events@@3U<unnamed-type-haptic_events>@@A+40
	subss	xmm1, xmm2
	divss	xmm1, xmm0
	mulss	xmm1, DWORD PTR ?haptic_events@@3U<unnamed-type-haptic_events>@@A+36
	maxss	xmm1, DWORD PTR __real@00000000
	movss	DWORD PTR $T6[ebp], xmm1
	jmp	SHORT $LN52@SK_ImGui_P
$LN51@SK_ImGui_P:
	xorps	xmm0, xmm0
	movss	DWORD PTR $T6[ebp], xmm0
$LN52@SK_ImGui_P:

; 11996:       auto now = static_cast <float> (timeGetTime ());

	call	esi
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH

; 11997:       
; 11998:       return config.input.gamepad.haptic_ui ?

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+670, 0
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm2, xmm0
	je	SHORT $LN58@SK_ImGui_P
	movss	xmm0, DWORD PTR ?haptic_events@@3U<unnamed-type-haptic_events>@@A+12
	movaps	xmm1, xmm0
	subss	xmm0, DWORD PTR ?haptic_events@@3U<unnamed-type-haptic_events>@@A+8
	subss	xmm1, xmm2
	divss	xmm1, xmm0
	mulss	xmm1, DWORD PTR ?haptic_events@@3U<unnamed-type-haptic_events>@@A+4
	maxss	xmm1, DWORD PTR __real@00000000
	movss	DWORD PTR $T7[ebp], xmm1
	jmp	SHORT $LN59@SK_ImGui_P
$LN58@SK_ImGui_P:
	xorps	xmm0, xmm0
	movss	DWORD PTR $T7[ebp], xmm0
$LN59@SK_ImGui_P:

; 11996:       auto now = static_cast <float> (timeGetTime ());

	call	esi
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH

; 11997:       
; 11998:       return config.input.gamepad.haptic_ui ?

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+670, 0
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm2, xmm0
	je	SHORT $LN65@SK_ImGui_P
	movss	xmm0, DWORD PTR ?haptic_events@@3U<unnamed-type-haptic_events>@@A+28
	movaps	xmm1, xmm0
	subss	xmm0, DWORD PTR ?haptic_events@@3U<unnamed-type-haptic_events>@@A+24
	subss	xmm1, xmm2
	divss	xmm1, xmm0
	mulss	xmm1, DWORD PTR ?haptic_events@@3U<unnamed-type-haptic_events>@@A+20
	maxss	xmm1, DWORD PTR __real@00000000
	movss	DWORD PTR $T8[ebp], xmm1
	jmp	SHORT $LN66@SK_ImGui_P
$LN65@SK_ImGui_P:
	xorps	xmm0, xmm0
	movss	DWORD PTR $T8[ebp], xmm0
$LN66@SK_ImGui_P:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 3779 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	movss	xmm0, DWORD PTR __real@3ecccccd
	lea	ecx, DWORD PTR $T5[ebp]
	comiss	xmm0, DWORD PTR $T11[ebp]
	lea	eax, DWORD PTR $T9[ebp]
	cmovbe	eax, ecx
	mov	DWORD PTR $T4[ebp], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 11996:       auto now = static_cast <float> (timeGetTime ());

	call	esi
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH

; 11997:       
; 11998:       return config.input.gamepad.haptic_ui ?

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+670, 0
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm2, xmm0
	je	SHORT $LN75@SK_ImGui_P
	movss	xmm0, DWORD PTR ?haptic_events@@3U<unnamed-type-haptic_events>@@A+12
	movaps	xmm1, xmm0
	subss	xmm0, DWORD PTR ?haptic_events@@3U<unnamed-type-haptic_events>@@A+8
	subss	xmm1, xmm2
	divss	xmm1, xmm0
	mulss	xmm1, DWORD PTR ?haptic_events@@3U<unnamed-type-haptic_events>@@A+4
	maxss	xmm1, DWORD PTR __real@00000000
	movss	DWORD PTR $T10[ebp], xmm1
	jmp	SHORT $LN76@SK_ImGui_P
$LN75@SK_ImGui_P:
	xorps	xmm0, xmm0
	movss	DWORD PTR $T10[ebp], xmm0
$LN76@SK_ImGui_P:

; 11996:       auto now = static_cast <float> (timeGetTime ());

	call	esi
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH

; 11997:       
; 11998:       return config.input.gamepad.haptic_ui ?

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+670, 0
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm2, xmm0
	je	SHORT $LN82@SK_ImGui_P
	movss	xmm0, DWORD PTR ?haptic_events@@3U<unnamed-type-haptic_events>@@A+28
	movaps	xmm1, xmm0
	subss	xmm0, DWORD PTR ?haptic_events@@3U<unnamed-type-haptic_events>@@A+24
	subss	xmm1, xmm2
	divss	xmm1, xmm0
	mulss	xmm1, DWORD PTR ?haptic_events@@3U<unnamed-type-haptic_events>@@A+20
	maxss	xmm1, DWORD PTR __real@00000000
	jmp	SHORT $LN83@SK_ImGui_P
$LN82@SK_ImGui_P:
	xorps	xmm1, xmm1
$LN83@SK_ImGui_P:

; 12206:                                           haptic_events.PulseButton.duration;
; 12207:     }
; 12208: 
; 12209:     SK_XInput_PulseController ( config.input.gamepad.xinput.ui_slot,

	movss	xmm0, DWORD PTR $T8[ebp]
	sub	esp, 8
	addss	xmm0, DWORD PTR $T7[ebp]
	mov	eax, DWORD PTR $T4[ebp]
	addss	xmm1, DWORD PTR $T10[ebp]
	addss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR $T6[ebp]
	minss	xmm0, DWORD PTR __real@3ecccccd
	addss	xmm1, xmm0
	movss	DWORD PTR [esp], xmm1
	push	DWORD PTR ?config@@3Usk_config_t@@A+680
	call	?SK_XInput_PulseController@@YA_NHMM@Z	; SK_XInput_PulseController

; 12210:                                   haptic_events.PulseTitle.run  () +
; 12211:                                   haptic_events.PulseButton.run () +
; 12212:                   std::min (0.4f, haptic_events.PulseNav.run ()),
; 12213:                                     haptic_events.PulseTitle.run  () +
; 12214:                                     haptic_events.PulseButton.run () +
; 12215:                     std::min (0.4f, haptic_events.PulseNav.run    ()) );
; 12216: 
; 12217:     nav_id = g.NavId;
; 12218:   }
; 12219: 
; 12220:   last_state = state;

	movups	xmm0, XMMWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edi+6384]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR ?nav_id@?CK@??SK_ImGui_PollGamepad_EndFrame@@YAXXZ@4IA, eax
	movups	XMMWORD PTR ?last_state@?1??SK_ImGui_PollGamepad_EndFrame@@YAXXZ@4U_XINPUT_STATE@@A, xmm0

; 12221: }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
$LN98@SK_ImGui_P:
	pop	edi
	movups	XMMWORD PTR ?last_state@?1??SK_ImGui_PollGamepad_EndFrame@@YAXXZ@4U_XINPUT_STATE@@A, xmm1
	pop	esi
	mov	esp, ebp
	pop	ebp
	mov	esp, ebx
	pop	ebx
	ret	0
?SK_ImGui_PollGamepad_EndFrame@@YAXXZ ENDP		; SK_ImGui_PollGamepad_EndFrame
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_toggle_ui$ = 8						; size = 4
_toggle_nav$ = 12					; size = 4
?SK_ImGui_ToggleEx@@YG_NAA_N0@Z PROC			; SK_ImGui_ToggleEx

; 12023: {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 12024:   if (toggle_ui)

	mov	esi, DWORD PTR _toggle_ui$[ebp]
	push	edi
	cmp	BYTE PTR [esi], 0
	je	SHORT $LN2@SK_ImGui_T

; 12025:     SK_ImGui_Toggle ();

	call	?SK_ImGui_Toggle@@YAXXZ			; SK_ImGui_Toggle
$LN2@SK_ImGui_T:

; 12026:   
; 12027:   if (toggle_nav && SK_ImGui_Active ())

	mov	edi, DWORD PTR _toggle_nav$[ebp]
	cmp	BYTE PTR [edi], 0
	je	SHORT $LN3@SK_ImGui_T
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1466 : static inline bool SK_ImGui_Active (void) { return SK_ImGui_Visible || SK_ReShade_Visible; };

	cmp	BYTE PTR ?SK_ImGui_Visible@@3_NA, 0	; SK_ImGui_Visible
	jne	SHORT $LN9@SK_ImGui_T
	cmp	BYTE PTR ?SK_ReShade_Visible@@3_NA, 0	; SK_ReShade_Visible
	je	SHORT $LN3@SK_ImGui_T
$LN9@SK_ImGui_T:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12028:     nav_usable = (! nav_usable);

	cmp	BYTE PTR ?nav_usable@@3_NA, 0		; nav_usable
	sete	BYTE PTR ?nav_usable@@3_NA		; nav_usable
$LN3@SK_ImGui_T:

; 12029:   
; 12030:   //if (nav_usable)
; 12031:     ImGui::SetNextWindowFocus ();

	call	?SetNextWindowFocus@ImGui@@YAXXZ	; ImGui::SetNextWindowFocus
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1466 : static inline bool SK_ImGui_Active (void) { return SK_ImGui_Visible || SK_ReShade_Visible; };

	cmp	BYTE PTR ?SK_ImGui_Visible@@3_NA, 0	; SK_ImGui_Visible
	jne	SHORT $LN13@SK_ImGui_T
	cmp	BYTE PTR ?SK_ReShade_Visible@@3_NA, 0	; SK_ReShade_Visible
	jne	SHORT $LN13@SK_ImGui_T
	xor	eax, eax
	jmp	SHORT $LN14@SK_ImGui_T
$LN13@SK_ImGui_T:
	mov	eax, 1
$LN14@SK_ImGui_T:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12039:   toggle_ui  = SK_ImGui_Active ();

	mov	BYTE PTR [esi], al

; 12040:   toggle_nav = nav_usable;

	movzx	eax, BYTE PTR ?nav_usable@@3_NA		; nav_usable
	mov	BYTE PTR [edi], al
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1466 : static inline bool SK_ImGui_Active (void) { return SK_ImGui_Visible || SK_ReShade_Visible; };

	mov	cl, BYTE PTR ?SK_ImGui_Visible@@3_NA	; SK_ImGui_Visible
	mov	al, BYTE PTR ?SK_ReShade_Visible@@3_NA	; SK_ReShade_Visible
	pop	edi
	pop	esi
	test	cl, cl
	jne	SHORT $LN17@SK_ImGui_T
	test	al, al
	je	SHORT $LN29@SK_ImGui_T
$LN17@SK_ImGui_T:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12042:   if (SK_ImGui_Active () && nav_usable)

	cmp	BYTE PTR ?nav_usable@@3_NA, 0		; nav_usable
	je	SHORT $LN4@SK_ImGui_T

; 12043:   {
; 12044:     SK_Input_RememberPressedKeys ();

	call	?SK_Input_RememberPressedKeys@@YAXXZ	; SK_Input_RememberPressedKeys

; 12045: 
; 12046:     haptic_events.PulseTitle.start = static_cast <float> (timeGetTime ());

	call	DWORD PTR __imp__timeGetTime@0

; 12047:     haptic_events.PulseTitle.end   = haptic_events.PulseTitle.start +

	mov	cl, BYTE PTR ?SK_ImGui_Visible@@3_NA	; SK_ImGui_Visible
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	al, BYTE PTR ?SK_ReShade_Visible@@3_NA	; SK_ReShade_Visible
	cvtpd2ps xmm1, xmm0
	movss	xmm0, DWORD PTR ?haptic_events@@3U<unnamed-type-haptic_events>@@A
	addss	xmm0, xmm1
	movss	DWORD PTR ?haptic_events@@3U<unnamed-type-haptic_events>@@A+8, xmm1
	movss	DWORD PTR ?haptic_events@@3U<unnamed-type-haptic_events>@@A+12, xmm0
$LN4@SK_ImGui_T:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1466 : static inline bool SK_ImGui_Active (void) { return SK_ImGui_Visible || SK_ReShade_Visible; };

	test	cl, cl
	jne	SHORT $LN25@SK_ImGui_T
	test	al, al
	jne	SHORT $LN25@SK_ImGui_T
$LN29@SK_ImGui_T:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12055:       SK_XInput_ZeroHaptics (config.input.gamepad.xinput.ui_slot);

	push	DWORD PTR ?config@@3Usk_config_t@@A+680
	call	?SK_XInput_ZeroHaptics@@YAXH@Z		; SK_XInput_ZeroHaptics
	add	esp, 4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1466 : static inline bool SK_ImGui_Active (void) { return SK_ImGui_Visible || SK_ReShade_Visible; };

	cmp	BYTE PTR ?SK_ImGui_Visible@@3_NA, 0	; SK_ImGui_Visible
	jne	SHORT $LN25@SK_ImGui_T
	cmp	BYTE PTR ?SK_ReShade_Visible@@3_NA, 0	; SK_ReShade_Visible
	jne	SHORT $LN25@SK_ImGui_T
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12057:   return SK_ImGui_Active ();

	xor	al, al

; 12058: }

	pop	ebp
	ret	8
$LN25@SK_ImGui_T:

; 12057:   return SK_ImGui_Active ();

	mov	al, 1

; 12058: }

	pop	ebp
	ret	8
?SK_ImGui_ToggleEx@@YG_NAA_N0@Z ENDP			; SK_ImGui_ToggleEx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
;	COMDAT ??$max@M@std@@YAABMABM0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@M@std@@YAABMABM0@Z PROC				; std::max<float>, COMDAT

; 3742 : 	{	// return larger of _Left and _Right

	npad	2
	push	ebp
	mov	ebp, esp

; 3743 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR __Left$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	comiss	xmm0, DWORD PTR [eax]
	cmova	eax, ecx

; 3744 : 	}

	pop	ebp
	ret	0
??$max@M@std@@YAABMABM0@Z ENDP				; std::max<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0<unnamed-type-haptic_events>@@QAE@XZ
_TEXT	SEGMENT
??0<unnamed-type-haptic_events>@@QAE@XZ PROC		; <unnamed-type-haptic_events>::<unnamed-type-haptic_events>, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], 1135542272		; 43af0000H
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 1065353216		; 3f800000H
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 1118437376		; 42aa0000H
	mov	DWORD PTR [ecx+20], 1056964608		; 3f000000H
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+32], 1114636288		; 42700000H
	mov	DWORD PTR [ecx+36], 1014350479		; 3c75c28fH
	mov	DWORD PTR [ecx+40], 0
	mov	DWORD PTR [ecx+44], 0
	ret	0
??0<unnamed-type-haptic_events>@@QAE@XZ ENDP		; <unnamed-type-haptic_events>::<unnamed-type-haptic_events>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
;	COMDAT ?run@linear_pulse_event_s@<unnamed-type-haptic_events>@@QAEMXZ
_TEXT	SEGMENT
tv79 = -4						; size = 4
?run@linear_pulse_event_s@<unnamed-type-haptic_events>@@QAEMXZ PROC ; <unnamed-type-haptic_events>::linear_pulse_event_s::run, COMDAT
; _this$ = ecx

; 11995:     float run (void) {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 11996:       auto now = static_cast <float> (timeGetTime ());

	call	DWORD PTR __imp__timeGetTime@0
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH

; 11997:       
; 11998:       return config.input.gamepad.haptic_ui ?

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+670, 0
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm2, xmm0
	je	SHORT $LN3@run
	movss	xmm0, DWORD PTR [esi+12]
	movaps	xmm1, xmm0
	subss	xmm0, DWORD PTR [esi+8]
	subss	xmm1, xmm2
	divss	xmm1, xmm0
	mulss	xmm1, DWORD PTR [esi+4]
	pop	esi
	maxss	xmm1, DWORD PTR __real@00000000
	movss	DWORD PTR tv79[ebp], xmm1
	fld	DWORD PTR tv79[ebp]

; 11999:                std::max (0.0f, strength * ((end - now) / (end - start))) :
; 12000:                          0.0f;
; 12001:     }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@run:

; 11997:       
; 11998:       return config.input.gamepad.haptic_ui ?

	mov	DWORD PTR tv79[ebp], 0
	fld	DWORD PTR tv79[ebp]
	pop	esi

; 11999:                std::max (0.0f, strength * ((end - now) / (end - start))) :
; 12000:                          0.0f;
; 12001:     }

	mov	esp, ebp
	pop	ebp
	ret	0
?run@linear_pulse_event_s@<unnamed-type-haptic_events>@@QAEMXZ ENDP ; <unnamed-type-haptic_events>::linear_pulse_event_s::run
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
;	COMDAT ??$max@K@std@@YAABKABK0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@K@std@@YAABKABK0@Z PROC				; std::max<unsigned long>, COMDAT

; 3742 : 	{	// return larger of _Left and _Right

	npad	2
	push	ebp
	mov	ebp, esp

; 3743 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	cmovb	eax, ecx

; 3744 : 	}

	pop	ebp
	ret	0
??$max@K@std@@YAABKABK0@Z ENDP				; std::max<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_dwUserIndex$ = 8					; size = 4
_pState$ = 12						; size = 4
?SK_ImGui_FilterXInput@@YA_NKPAU_XINPUT_STATE@@@Z PROC	; SK_ImGui_FilterXInput

; 11973: {

	npad	2
	push	ebp
	mov	ebp, esp

; 11974:   if ( SK_ImGui_WantGamepadCapture () &&

	call	?SK_ImGui_WantGamepadCapture@@YA_NXZ	; SK_ImGui_WantGamepadCapture
	test	al, al
	je	SHORT $LN2@SK_ImGui_F
	mov	eax, DWORD PTR _dwUserIndex$[ebp]
	cmp	eax, DWORD PTR ?config@@3Usk_config_t@@A+680
	jne	SHORT $LN2@SK_ImGui_F

; 11975:        dwUserIndex == (DWORD)config.input.gamepad.xinput.ui_slot )
; 11976:   {
; 11977:     ZeroMemory (&pState->Gamepad, sizeof XINPUT_GAMEPAD);

	mov	edx, DWORD PTR _pState$[ebp]
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 3743 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	ecx, 1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 11983:     return true;

	mov	al, 1
	movq	QWORD PTR [edx+4], xmm0
	mov	DWORD PTR [edx+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 3743 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	cmp	DWORD PTR [edx], ecx
	cmova	ecx, DWORD PTR [edx]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 11980:     pState->dwPacketNumber =

	mov	DWORD PTR [edx], ecx

; 11987: }

	pop	ebp
	ret	0
$LN2@SK_ImGui_F:

; 11984:   }
; 11985: 
; 11986:   return false;

	xor	al, al

; 11987: }

	pop	ebp
	ret	0
?SK_ImGui_FilterXInput@@YA_NKPAU_XINPUT_STATE@@@Z ENDP	; SK_ImGui_FilterXInput
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
;	COMDAT ??0<lambda_a71b56d13de6c5a0c01a9b6128e8e6fc>@@QAE@AAUImGuiIO@@@Z
_TEXT	SEGMENT
_<io>$ = 8						; size = 4
??0<lambda_a71b56d13de6c5a0c01a9b6128e8e6fc>@@QAE@AAUImGuiIO@@@Z PROC ; <lambda_a71b56d13de6c5a0c01a9b6128e8e6fc>::<lambda_a71b56d13de6c5a0c01a9b6128e8e6fc>, COMDAT
; _this$ = ecx

; 11553:     };

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _<io>$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??0<lambda_a71b56d13de6c5a0c01a9b6128e8e6fc>@@QAE@AAUImGuiIO@@@Z ENDP ; <lambda_a71b56d13de6c5a0c01a9b6128e8e6fc>::<lambda_a71b56d13de6c5a0c01a9b6128e8e6fc>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
;	COMDAT ??R<lambda_a71b56d13de6c5a0c01a9b6128e8e6fc>@@QBEX_N@Z
_TEXT	SEGMENT
_active$ = 8						; size = 1
??R<lambda_a71b56d13de6c5a0c01a9b6128e8e6fc>@@QBEX_N@Z PROC ; <lambda_a71b56d13de6c5a0c01a9b6128e8e6fc>::operator(), COMDAT
; _this$ = ecx

; 11540:     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx

; 11541:       bool changed = (active != window_active);

	mov	bl, BYTE PTR _active$[ebp]
	cmp	bl, BYTE PTR ?window_active@?1???R<lambda_34955bda5757b6d1afe210935814f65c>@@QBE_NPAUHWND__@@IIJ@Z@4_NA ; `<lambda_34955bda5757b6d1afe210935814f65c>::operator()'::`2'::window_active
	setne	al

; 11542: 
; 11543:       if (active && changed)

	test	bl, bl
	je	SHORT $LN5@operator
	test	al, al
	je	SHORT $LN6@operator

; 11544:         SK_Input_RememberPressedKeys ();

	call	?SK_Input_RememberPressedKeys@@YAXXZ	; SK_Input_RememberPressedKeys

; 11550:       }
; 11551: 
; 11552:       window_active = active;

	mov	BYTE PTR ?window_active@?1???R<lambda_34955bda5757b6d1afe210935814f65c>@@QBE_NPAUHWND__@@IIJ@Z@4_NA, bl ; `<lambda_34955bda5757b6d1afe210935814f65c>::operator()'::`2'::window_active
	pop	ebx

; 11553:     };

	pop	ebp
	ret	4
$LN5@operator:

; 11545: 
; 11546:       if ((! active) && changed)

	test	al, al
	je	SHORT $LN6@operator

; 11547:       {
; 11548:         ZeroMemory (io.MouseDown, sizeof (bool) * 5  );

	mov	eax, DWORD PTR [ecx]

; 11549:         ZeroMemory (io.KeysDown,  sizeof (bool) * 512);

	push	512					; 00000200H
	push	0
	mov	DWORD PTR [eax+212], 0
	mov	BYTE PTR [eax+216], 0
	mov	eax, DWORD PTR [ecx]
	add	eax, 229				; 000000e5H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN6@operator:

; 11550:       }
; 11551: 
; 11552:       window_active = active;

	mov	BYTE PTR ?window_active@?1???R<lambda_34955bda5757b6d1afe210935814f65c>@@QBE_NPAUHWND__@@IIJ@Z@4_NA, bl ; `<lambda_34955bda5757b6d1afe210935814f65c>::operator()'::`2'::window_active
	pop	ebx

; 11553:     };

	pop	ebp
	ret	4
??R<lambda_a71b56d13de6c5a0c01a9b6128e8e6fc>@@QBEX_N@Z ENDP ; <lambda_a71b56d13de6c5a0c01a9b6128e8e6fc>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
;	COMDAT ??R<lambda_34955bda5757b6d1afe210935814f65c>@@QBE_NPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_data$1 = -44						; size = 40
_ActivateWindow$ = -4					; size = 4
_hWnd$ = 8						; size = 4
_msg$ = 12						; size = 4
_key_str$2 = 16						; size = 2
_size$3 = 16						; size = 4
_wParam$ = 16						; size = 4
tv686 = 20						; size = 4
_lParam$ = 20						; size = 4
??R<lambda_34955bda5757b6d1afe210935814f65c>@@QBE_NPAUHWND__@@IIJ@Z PROC ; <lambda_34955bda5757b6d1afe210935814f65c>::operator(), COMDAT
; _this$ = ecx

; 11533:   {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	push	edi

; 11534:     static bool window_active = true;
; 11535: 
; 11536:     ImGuiIO& io =

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO

; 11554: 
; 11555:     switch (msg)

	mov	ecx, DWORD PTR _msg$[ebp]
	mov	esi, eax

; 11553:     };

	mov	DWORD PTR _ActivateWindow$[ebp], esi

; 11554: 
; 11555:     switch (msg)

	cmp	ecx, 512				; 00000200H
	ja	$LN82@operator
	je	$LN59@operator
	cmp	ecx, 28					; 0000001cH
	ja	SHORT $LN83@operator
	je	SHORT $LN22@operator
	cmp	ecx, 6
	jne	SHORT $LN16@operator
$LN22@operator:

; 11613: 
; 11614: 
; 11615:       case WM_ACTIVATEAPP:
; 11616:       case WM_ACTIVATE:
; 11617:       case WM_NCACTIVATE:
; 11618:       {
; 11619:         if (hWnd == game_window.hWnd)

	mov	eax, DWORD PTR ?game_window@@3Usk_window_s@@A+4
	cmp	DWORD PTR _hWnd$[ebp], eax
	jne	SHORT $LN16@operator

; 11620:         {
; 11621:           if (msg == WM_NCACTIVATE || msg == WM_ACTIVATEAPP)

	cmp	ecx, 134				; 00000086H
	je	$LN26@operator
	cmp	ecx, 28					; 0000001cH
	je	$LN26@operator

; 11624:           }
; 11625: 
; 11626:           else if (msg == WM_ACTIVATE)

	cmp	ecx, 6
	jne	SHORT $LN16@operator

; 11627:           {
; 11628:             switch (LOWORD (wParam))

	cmp	WORD PTR _wParam$[ebp], 0
	je	SHORT $LN29@operator

; 11629:             {
; 11630:               case WA_ACTIVE:
; 11631:               case WA_CLICKACTIVE:
; 11632:               default: // Unknown
; 11633:               {
; 11634:                 ActivateWindow ((HWND)lParam != game_window.hWnd);

	cmp	DWORD PTR _lParam$[ebp], eax
$LN92@operator:
	setne	al
$LN91@operator:

; 11622:           {
; 11623:             ActivateWindow (wParam != 0x00);

	movzx	eax, al
	lea	ecx, DWORD PTR _ActivateWindow$[ebp]
	push	eax
	call	??R<lambda_a71b56d13de6c5a0c01a9b6128e8e6fc>@@QBEX_N@Z ; <lambda_a71b56d13de6c5a0c01a9b6128e8e6fc>::operator()
$LN16@operator:

; 11888:         }
; 11889:       } break;
; 11890:     }
; 11891: 
; 11892:     return false;

	pop	edi
	pop	esi
	xor	al, al
	pop	ebx

; 11893:   };

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN83@operator:

; 11554: 
; 11555:     switch (msg)

	lea	eax, DWORD PTR [ecx-33]
	cmp	eax, 228				; 000000e4H
	ja	SHORT $LN16@operator
	movzx	eax, BYTE PTR $LN90@operator[eax]
	jmp	DWORD PTR $LN94@operator[eax*4]
$LN20@operator:

; 11599:             }
; 11600:           } break;
; 11601:         }
; 11602:       } break;
; 11603: 
; 11604: 
; 11605: 
; 11606:       case WM_MOUSEACTIVATE:
; 11607:       {
; 11608:         if (hWnd == game_window.hWnd)

	mov	eax, DWORD PTR _hWnd$[ebp]
	cmp	eax, DWORD PTR ?game_window@@3Usk_window_s@@A+4
	jne	SHORT $LN16@operator

; 11609:         {
; 11610:           ActivateWindow (((HWND)wParam == hWnd));

	cmp	DWORD PTR _wParam$[ebp], eax
	sete	al

; 11611:         }
; 11612:       } break;

	jmp	SHORT $LN91@operator
$LN29@operator:

; 11635:               } break;
; 11636: 
; 11637:               case WA_INACTIVE:
; 11638:               {
; 11639:                 ActivateWindow (lParam == 0 || (HWND)lParam == game_window.hWnd);

	mov	ecx, DWORD PTR _lParam$[ebp]
	test	ecx, ecx
	je	SHORT $LN74@operator
	cmp	ecx, eax
	je	SHORT $LN74@operator
	xor	al, al
	lea	ecx, DWORD PTR _ActivateWindow$[ebp]
	push	eax
	call	??R<lambda_a71b56d13de6c5a0c01a9b6128e8e6fc>@@QBEX_N@Z ; <lambda_a71b56d13de6c5a0c01a9b6128e8e6fc>::operator()
	pop	edi
	pop	esi

; 11888:         }
; 11889:       } break;
; 11890:     }
; 11891: 
; 11892:     return false;

	xor	al, al
	pop	ebx

; 11893:   };

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN74@operator:

; 11635:               } break;
; 11636: 
; 11637:               case WA_INACTIVE:
; 11638:               {
; 11639:                 ActivateWindow (lParam == 0 || (HWND)lParam == game_window.hWnd);

	mov	eax, 1
	lea	ecx, DWORD PTR _ActivateWindow$[ebp]
	push	eax
	call	??R<lambda_a71b56d13de6c5a0c01a9b6128e8e6fc>@@QBEX_N@Z ; <lambda_a71b56d13de6c5a0c01a9b6128e8e6fc>::operator()
	pop	edi
	pop	esi

; 11888:         }
; 11889:       } break;
; 11890:     }
; 11891: 
; 11892:     return false;

	xor	al, al
	pop	ebx

; 11893:   };

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN26@operator:

; 11622:           {
; 11623:             ActivateWindow (wParam != 0x00);

	cmp	DWORD PTR _wParam$[ebp], 0

; 11640:               } break;
; 11641:             }
; 11642:           }
; 11643:         }
; 11644:       } break;

	jmp	$LN92@operator
$LN39@operator:

; 11693: 
; 11694:       case WM_KEYDOWN:
; 11695:       case WM_SYSKEYDOWN:
; 11696:       {
; 11697:         BYTE  vkCode   = LOWORD (wParam) & 0xFF;
; 11698:         BYTE  scanCode = HIWORD (lParam) & 0x7F;

	mov	edi, DWORD PTR _lParam$[ebp]
	mov	eax, edi

; 11699: 
; 11700:         if (vkCode & 0xF8) // Valid Keys:  8 - 255

	mov	ebx, DWORD PTR _wParam$[ebp]
	shr	eax, 16					; 00000010H
	and	eax, -129				; ffffff7fH
	mov	DWORD PTR tv686[ebp], eax
	test	bl, 248					; 000000f8H
	je	$LN40@operator

; 11701:         {
; 11702:           // Don't process Alt+Tab or Alt+Enter
; 11703:           if (msg == WM_SYSKEYDOWN && ( vkCode == VK_TAB || vkCode == VK_RETURN ))

	cmp	ecx, 260				; 00000104H
	jne	SHORT $LN42@operator
	cmp	bl, 9
	je	$LN16@operator
	cmp	bl, 13					; 0000000dH
	je	$LN16@operator
$LN42@operator:

; 11704:             return false;
; 11705: 
; 11706:           // Just the make / break events, repeats are ignored
; 11707:           if      ((lParam & 0x40000000UL) == 0)

	test	edi, 1073741824				; 40000000H
	jne	SHORT $LN44@operator

; 11708:             SK_Console::getInstance ()->KeyDown (vkCode, MAXDWORD);

	push	-1
	push	ebx
	call	?getInstance@SK_Console@@SAPAV1@XZ	; SK_Console::getInstance
	mov	ecx, eax
	call	?KeyDown@SK_Console@@QAEHEJ@Z		; SK_Console::KeyDown
$LN44@operator:

; 11709: 
; 11710:           if (vkCode != VK_TAB)

	cmp	bl, 9
	je	$LN54@operator

; 11711:           {
; 11712:             wchar_t key_str;
; 11713: 
; 11714:             if ( ToUnicodeEx ( vkCode,
; 11715:                                scanCode,
; 11716:                                (const BYTE *)io.KeysDown,
; 11717:                               &key_str,
; 11718:                                1,
; 11719:                                0x00,
; 11720:                                GetKeyboardLayout (0) )
; 11721:                      &&

	push	0
	call	DWORD PTR __imp__GetKeyboardLayout@4
	push	eax
	push	0
	push	1
	lea	eax, DWORD PTR _key_str$2[ebp]
	push	eax
	lea	eax, DWORD PTR [esi+229]
	push	eax
	mov	eax, DWORD PTR tv686[ebp]
	movzx	eax, al
	push	eax
	movzx	eax, bl
	push	eax
	call	DWORD PTR __imp__ToUnicodeEx@28
	test	eax, eax
	je	$LN54@operator
	push	DWORD PTR _key_str$2[ebp]
	call	DWORD PTR __imp__iswprint
	add	esp, 4
	test	eax, eax
	je	$LN54@operator

; 11722:                   iswprint ( key_str )
; 11723:                )
; 11724:             {
; 11725:               ImGui_WndProcHandler ( hWnd, WM_CHAR, key_str, lParam );

	movzx	eax, WORD PTR _key_str$2[ebp]
	push	edi
	push	eax
	push	258					; 00000102H
	push	DWORD PTR _hWnd$[ebp]
	call	?ImGui_WndProcHandler@@YGJPAUHWND__@@IIJ@Z ; ImGui_WndProcHandler
	pop	edi
	pop	esi

; 11767:         }
; 11768: 
; 11769:         return true;

	mov	al, 1
	pop	ebx

; 11893:   };

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN40@operator:

; 11726:             }
; 11727:           }
; 11728:         }
; 11729: 
; 11730:         // Mouse event
; 11731:         //
; 11732:         else if (vkCode < 7)

	cmp	bl, 7
	jae	SHORT $LN54@operator

; 11733:         {
; 11734:           int remap = -1;
; 11735: 
; 11736:           // Stupid hack, but these indices are discontinuous
; 11737:           //
; 11738:           switch (vkCode)

	movzx	eax, bl
	dec	eax
	cmp	eax, 5
	ja	SHORT $LN54@operator
	jmp	DWORD PTR $LN95@operator[eax*4]
$LN48@operator:

; 11739:           {
; 11740:             case VK_LBUTTON:
; 11741:               remap = 0;

	xor	eax, eax
	pop	edi

; 11758:               break;
; 11759: 
; 11760:             default:
; 11761:               assert (false); // WTF?! These keys don't exist
; 11762:               break;
; 11763:           }
; 11764: 
; 11765:           if (remap != -1)
; 11766:             io.MouseDown [remap] = true;

	mov	BYTE PTR [eax+esi+212], 1

; 11767:         }
; 11768: 
; 11769:         return true;

	mov	al, 1
	pop	esi
	pop	ebx

; 11893:   };

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN49@operator:

; 11742:               break;
; 11743: 
; 11744:             case VK_RBUTTON:
; 11745:               remap = 1;

	mov	eax, 1
	pop	edi

; 11758:               break;
; 11759: 
; 11760:             default:
; 11761:               assert (false); // WTF?! These keys don't exist
; 11762:               break;
; 11763:           }
; 11764: 
; 11765:           if (remap != -1)
; 11766:             io.MouseDown [remap] = true;

	mov	BYTE PTR [eax+esi+212], al
	pop	esi
	pop	ebx

; 11893:   };

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN50@operator:

; 11746:               break;
; 11747: 
; 11748:             case VK_MBUTTON:
; 11749:               remap = 2;

	mov	eax, 2
	pop	edi

; 11758:               break;
; 11759: 
; 11760:             default:
; 11761:               assert (false); // WTF?! These keys don't exist
; 11762:               break;
; 11763:           }
; 11764: 
; 11765:           if (remap != -1)
; 11766:             io.MouseDown [remap] = true;

	mov	BYTE PTR [eax+esi+212], 1

; 11767:         }
; 11768: 
; 11769:         return true;

	mov	al, 1
	pop	esi
	pop	ebx

; 11893:   };

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN51@operator:

; 11750:               break;
; 11751: 
; 11752:             case VK_XBUTTON1:
; 11753:               remap = 3;

	mov	eax, 3
	pop	edi

; 11758:               break;
; 11759: 
; 11760:             default:
; 11761:               assert (false); // WTF?! These keys don't exist
; 11762:               break;
; 11763:           }
; 11764: 
; 11765:           if (remap != -1)
; 11766:             io.MouseDown [remap] = true;

	mov	BYTE PTR [eax+esi+212], 1

; 11767:         }
; 11768: 
; 11769:         return true;

	mov	al, 1
	pop	esi
	pop	ebx

; 11893:   };

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN52@operator:

; 11754:               break;
; 11755: 
; 11756:             case VK_XBUTTON2:
; 11757:               remap = 4;

	mov	eax, 4

; 11758:               break;
; 11759: 
; 11760:             default:
; 11761:               assert (false); // WTF?! These keys don't exist
; 11762:               break;
; 11763:           }
; 11764: 
; 11765:           if (remap != -1)
; 11766:             io.MouseDown [remap] = true;

	mov	BYTE PTR [eax+esi+212], 1
$LN54@operator:

; 11767:         }
; 11768: 
; 11769:         return true;

	pop	edi
	pop	esi
	mov	al, 1
	pop	ebx

; 11893:   };

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN55@operator:

; 11770:       } break;
; 11771: 
; 11772: 
; 11773:       case WM_KEYUP:
; 11774:       case WM_SYSKEYUP:
; 11775:       {
; 11776:         BYTE vkCode = LOWORD (wParam) & 0xFF;
; 11777: 
; 11778:         if (vkCode & 0xF8) // Valid Keys:  8 - 255

	mov	eax, DWORD PTR _wParam$[ebp]
	test	al, 248					; 000000f8H
	je	$LN16@operator

; 11779:         {
; 11780:           // Don't process Alt+Tab or Alt+Enter
; 11781:           if (msg == WM_SYSKEYUP && ( vkCode == VK_TAB || vkCode == VK_RETURN ))

	cmp	ecx, 261				; 00000105H
	jne	SHORT $LN57@operator
	cmp	al, 9
	je	$LN16@operator
	cmp	al, 13					; 0000000dH
	je	$LN16@operator
$LN57@operator:

; 11782:             return false;
; 11783: 
; 11784:           SK_Console::getInstance ()->KeyUp (vkCode, lParam);

	push	DWORD PTR _lParam$[ebp]
	push	eax
	call	?getInstance@SK_Console@@SAPAV1@XZ	; SK_Console::getInstance
	mov	ecx, eax
	call	?KeyUp@SK_Console@@QAEHEJ@Z		; SK_Console::KeyUp
	pop	edi
	pop	esi

; 11785: 
; 11786:           return true;

	mov	al, 1
	pop	ebx

; 11893:   };

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN65@operator:

; 11835:       } break;
; 11836: 
; 11837: 
; 11838:       case WM_CHAR:
; 11839:       {
; 11840:         // You can also use ToAscii()+GetKeyboardState() to retrieve characters.
; 11841:         if ((wParam & 0xff) > 7 && wParam < 0x10000)

	mov	ecx, DWORD PTR _wParam$[ebp]
	cmp	cl, 7
	jbe	$LN34@operator
	cmp	ecx, 65536				; 00010000H
	jae	$LN34@operator

; 11842:         {
; 11843:           io.AddInputCharacter ((unsigned short)(wParam & 0xFFFF));

	push	ecx
	mov	ecx, esi
	call	?AddInputCharacter@ImGuiIO@@QAEXG@Z	; ImGuiIO::AddInputCharacter
	pop	edi
	pop	esi

; 11844:         }
; 11845: 
; 11846:         return true;

	mov	al, 1
	pop	ebx

; 11893:   };

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN67@operator:

; 11847:       } break;
; 11848: 
; 11849: 
; 11850:       case WM_INPUT:
; 11851:       {
; 11852:         RAWINPUT data = { };
; 11853:         UINT     size = sizeof RAWINPUT;
; 11854: 
; 11855:         int      ret  =
; 11856:           GetRawInputData_Original ((HRAWINPUT)lParam, RID_HEADER, &data, &size, sizeof (RAWINPUTHEADER) );

	mov	esi, DWORD PTR _lParam$[ebp]
	lea	eax, DWORD PTR _size$3[ebp]
	push	16					; 00000010H
	push	eax
	lea	eax, DWORD PTR _data$1[ebp]
	mov	DWORD PTR _size$3[ebp], 40		; 00000028H
	push	eax
	xorps	xmm0, xmm0
	push	268435461				; 10000005H
	push	esi
	movups	XMMWORD PTR _data$1[ebp], xmm0
	movups	XMMWORD PTR _data$1[ebp+16], xmm0
	movq	QWORD PTR _data$1[ebp+32], xmm0
	call	DWORD PTR ?GetRawInputData_Original@@3P6GIPAUHRAWINPUT__@@IPAXPAII@ZA ; GetRawInputData_Original

; 11857: 
; 11858:         if (ret)

	test	eax, eax
	je	$LN16@operator

; 11859:         {
; 11860:           auto *pData =
; 11861:             new uint8_t [size];

	push	DWORD PTR _size$3[ebp]
	call	??_U@YAPAXI@Z				; operator new[]
	mov	edi, eax
	add	esp, 4

; 11862: 
; 11863:           if (! pData)

	test	edi, edi
	je	$LN16@operator

; 11864:             return 0;
; 11865: 
; 11866:           bool cap = false;
; 11867: 
; 11868:           switch (data.header.dwType)

	mov	eax, DWORD PTR _data$1[ebp]

; 11877:               break;
; 11878: 
; 11879:             default:
; 11880:               cap  = SK_ImGui_ProcessRawInput ((HRAWINPUT)lParam, RID_INPUT, &data, &size, sizeof (data.header), true) != 0;

	push	1
	push	16					; 00000010H
	sub	eax, 0
	je	$LN70@operator
	sub	eax, 1
	lea	eax, DWORD PTR _size$3[ebp]
	push	eax
	lea	eax, DWORD PTR _data$1[ebp]
	push	eax
	push	268435459				; 10000003H
	push	esi
	je	SHORT $LN71@operator
	call	?SK_ImGui_ProcessRawInput@@YGIPAUHRAWINPUT__@@IPAXPAIIH@Z ; SK_ImGui_ProcessRawInput
	test	eax, eax
	setne	bl

; 11881:               cap &= SK_ImGui_WantGamepadCapture ();

	call	?SK_ImGui_WantGamepadCapture@@YA_NXZ	; SK_ImGui_WantGamepadCapture

; 11882:               break;
; 11883:           }
; 11884: 
; 11885:           delete [] pData;

	push	edi
	and	bl, al
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 11886: 
; 11887:           return cap;

	mov	al, bl
	pop	edi
	pop	esi
	pop	ebx

; 11893:   };

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN71@operator:

; 11872:               break;
; 11873: 
; 11874:             case RIM_TYPEKEYBOARD:
; 11875:               cap  = SK_ImGui_ProcessRawInput ((HRAWINPUT)lParam, RID_INPUT, &data, &size, sizeof (data.header), true) != 0;

	call	?SK_ImGui_ProcessRawInput@@YGIPAUHRAWINPUT__@@IPAXPAIIH@Z ; SK_ImGui_ProcessRawInput
	test	eax, eax
	setne	bl

; 11876:               cap &= ( SK_Console::getInstance ()->isVisible () || SK_ImGui_WantKeyboardCapture () || SK_ImGui_WantGamepadCapture () );

	call	?getInstance@SK_Console@@SAPAV1@XZ	; SK_Console::getInstance
	cmp	BYTE PTR [eax+4356], 0
	jne	SHORT $LN80@operator
	call	?SK_ImGui_WantKeyboardCapture@@YA_NXZ	; SK_ImGui_WantKeyboardCapture
	test	al, al
	jne	SHORT $LN80@operator
	call	?SK_ImGui_WantGamepadCapture@@YA_NXZ	; SK_ImGui_WantGamepadCapture
	test	al, al
	jne	SHORT $LN80@operator
	xor	eax, eax

; 11882:               break;
; 11883:           }
; 11884: 
; 11885:           delete [] pData;

	push	edi
	and	bl, al
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 11886: 
; 11887:           return cap;

	mov	al, bl
	pop	edi
	pop	esi
	pop	ebx

; 11893:   };

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN80@operator:

; 11876:               cap &= ( SK_Console::getInstance ()->isVisible () || SK_ImGui_WantKeyboardCapture () || SK_ImGui_WantGamepadCapture () );

	mov	eax, 1

; 11882:               break;
; 11883:           }
; 11884: 
; 11885:           delete [] pData;

	push	edi
	and	bl, al
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 11886: 
; 11887:           return cap;

	mov	al, bl
	pop	edi
	pop	esi
	pop	ebx

; 11893:   };

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN70@operator:

; 11869:           {
; 11870:             case RIM_TYPEMOUSE:
; 11871:               cap = SK_ImGui_ProcessRawInput ((HRAWINPUT)lParam, RID_INPUT, &data, &size, sizeof (data.header),  true) != 0 && SK_ImGui_WantMouseCapture ();

	lea	eax, DWORD PTR _size$3[ebp]
	push	eax
	lea	eax, DWORD PTR _data$1[ebp]
	push	eax
	push	268435459				; 10000003H
	push	esi
	call	?SK_ImGui_ProcessRawInput@@YGIPAUHRAWINPUT__@@IPAXPAIIH@Z ; SK_ImGui_ProcessRawInput
	test	eax, eax
	je	SHORT $LN78@operator
	call	?SK_ImGui_WantMouseCapture@@YA_NXZ	; SK_ImGui_WantMouseCapture
	test	al, al
	je	SHORT $LN78@operator

; 11882:               break;
; 11883:           }
; 11884: 
; 11885:           delete [] pData;

	push	edi
	mov	bl, 1
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 11886: 
; 11887:           return cap;

	mov	al, bl
	pop	edi
	pop	esi
	pop	ebx

; 11893:   };

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN78@operator:

; 11882:               break;
; 11883:           }
; 11884: 
; 11885:           delete [] pData;

	push	edi
	xor	bl, bl
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 11886: 
; 11887:           return cap;

	mov	al, bl
	pop	edi
	pop	esi
	pop	ebx

; 11893:   };

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN59@operator:

; 11787:         }
; 11788:       } break;
; 11789: 
; 11790: 
; 11791:       case WM_NCMOUSEMOVE:
; 11792:       case WM_MOUSEMOVE:
; 11793:       {
; 11794:         LONG lDeltaRet = SK_ImGui_DeltaTestMouse (last_pos, (DWORD)lParam);

	mov	edi, DWORD PTR _lParam$[ebp]
	push	1
	push	edi
	push	OFFSET ?last_pos@?1??ImGui_WndProcHandler@@YGJPAUHWND__@@IIJ@Z@4UtagPOINTS@@A
	call	?SK_ImGui_DeltaTestMouse@@YAJAAUtagPOINTS@@KF@Z ; SK_ImGui_DeltaTestMouse
	mov	ebx, eax
	add	esp, 12					; 0000000cH

; 11795: 
; 11796:         // Return:
; 11797:         //
; 11798:         //   -1 if no filtering is desired
; 11799:         //    0 if the message should be passed onto app, but internal cursor pos unchanged
; 11800:         //    1 if the message should be completely eradicated
; 11801:         //
; 11802:         if (lDeltaRet >= 0)

	test	ebx, ebx
	js	SHORT $LN60@operator

; 11803:         {
; 11804:           if (SK_ImGui_IsMouseRelevant ())

	call	?SK_ImGui_IsMouseRelevant@@YA_NXZ	; SK_ImGui_IsMouseRelevant
	test	al, al
	je	SHORT $LN61@operator

; 11805:             SK_ImGui_Cursor.update ();

	mov	ecx, OFFSET ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A ; SK_ImGui_Cursor
	call	?update@sk_imgui_cursor_s@@QAEXXZ	; sk_imgui_cursor_s::update
$LN61@operator:

; 11806: 
; 11807:           return lDeltaRet;

	pop	edi
	test	ebx, ebx
	pop	esi
	setne	al
	pop	ebx

; 11893:   };

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN60@operator:

; 11808:         }
; 11809: 
; 11810:         SHORT xPos = GET_X_LPARAM (lParam);
; 11811:         SHORT yPos = GET_Y_LPARAM (lParam);
; 11812: 
; 11813:         SK_ImGui_Cursor.pos.x = xPos;

	movsx	eax, di

; 11814:         SK_ImGui_Cursor.pos.y = yPos;
; 11815: 
; 11816:         SK_ImGui_Cursor.ClientToLocal (&SK_ImGui_Cursor.pos);

	mov	ecx, OFFSET ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A ; SK_ImGui_Cursor
	mov	DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+20, eax
	shr	edi, 16					; 00000010H
	movsx	eax, di
	push	OFFSET ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+20
	mov	DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+24, eax
	call	?ClientToLocal@sk_imgui_cursor_s@@QAEXPAUtagPOINT@@@Z ; sk_imgui_cursor_s::ClientToLocal
	movd	xmm0, DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+20

; 11817: 
; 11818:         io.MousePos.x = (float)SK_ImGui_Cursor.pos.x;

	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [esi+204], xmm0
	movd	xmm0, DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+24

; 11819:         io.MousePos.y = (float)SK_ImGui_Cursor.pos.y;

	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [esi+208], xmm0

; 11820: 
; 11821:         if (! SK_ImGui_WantMouseCapture ())

	call	?SK_ImGui_WantMouseCapture@@YA_NXZ	; SK_ImGui_WantMouseCapture
	test	al, al
	jne	SHORT $LN62@operator

; 11822:         {
; 11823:           if (SK_ImGui_IsMouseRelevant ())

	call	?SK_ImGui_IsMouseRelevant@@YA_NXZ	; SK_ImGui_IsMouseRelevant
	test	al, al
	je	SHORT $LN63@operator

; 11824:             SK_ImGui_Cursor.update ();

	mov	ecx, OFFSET ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A ; SK_ImGui_Cursor
	call	?update@sk_imgui_cursor_s@@QAEXXZ	; sk_imgui_cursor_s::update
$LN63@operator:

; 11825: 
; 11826:           SK_ImGui_Cursor.orig_pos = SK_ImGui_Cursor.pos;

	mov	eax, DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+20
	pop	edi
	mov	DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+4, eax
	mov	eax, DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+24
	pop	esi
	mov	DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+8, eax

; 11888:         }
; 11889:       } break;
; 11890:     }
; 11891: 
; 11892:     return false;

	xor	al, al
	pop	ebx

; 11893:   };

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN62@operator:

; 11827: 
; 11828:           return false;
; 11829:         }
; 11830: 
; 11831:         if (SK_ImGui_IsMouseRelevant ())

	call	?SK_ImGui_IsMouseRelevant@@YA_NXZ	; SK_ImGui_IsMouseRelevant
	test	al, al
	je	$LN34@operator

; 11832:           SK_ImGui_Cursor.update ();

	mov	ecx, OFFSET ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A ; SK_ImGui_Cursor
	call	?update@sk_imgui_cursor_s@@QAEXXZ	; sk_imgui_cursor_s::update
	pop	edi
	pop	esi

; 11833: 
; 11834:         return true;

	mov	al, 1
	pop	ebx

; 11893:   };

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN82@operator:

; 11554: 
; 11555:     switch (msg)

	cmp	ecx, 786				; 00000312H
	ja	$LN84@operator
	je	$LN12@operator
	add	ecx, -513				; fffffdffH
	cmp	ecx, 12					; 0000000cH
	ja	$LN16@operator
	jmp	DWORD PTR $LN96@operator[ecx*4]
$LN30@operator:
	pop	edi

; 11645: 
; 11646: 
; 11647:       case WM_LBUTTONDOWN:
; 11648:       case WM_LBUTTONDBLCLK: // Sent on receipt of the second click
; 11649:         io.MouseDown [0] = true;

	mov	BYTE PTR [esi+212], 1

; 11650:         return true;

	mov	al, 1
	pop	esi
	pop	ebx

; 11893:   };

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN31@operator:
	pop	edi

; 11651: 
; 11652:       case WM_RBUTTONDOWN:
; 11653:       case WM_RBUTTONDBLCLK: // Sent on receipt of the second click 
; 11654:         io.MouseDown [1] = true;

	mov	BYTE PTR [esi+213], 1

; 11655:         return true;

	mov	al, 1
	pop	esi
	pop	ebx

; 11893:   };

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN32@operator:
	pop	edi

; 11656: 
; 11657:       case WM_MBUTTONDOWN:
; 11658:       case WM_MBUTTONDBLCLK: // Sent on receipt of the second click
; 11659:         io.MouseDown [2] = true;

	mov	BYTE PTR [esi+214], 1

; 11660:         return true;

	mov	al, 1
	pop	esi
	pop	ebx

; 11893:   };

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN33@operator:

; 11661: 
; 11662:       case WM_XBUTTONDOWN:
; 11663:       case WM_XBUTTONDBLCLK: // Sent on receipt of the second click
; 11664:       {
; 11665:         WORD Flags =
; 11666:           GET_XBUTTON_WPARAM (wParam);

	mov	ecx, DWORD PTR _wParam$[ebp]
	shr	ecx, 16					; 00000010H

; 11667: 
; 11668:         io.MouseDown [3] |= (Flags & XBUTTON1) != 0;

	mov	al, cl

; 11669:         io.MouseDown [4] |= (Flags & XBUTTON2) != 0;

	shr	cl, 1
	and	al, 1
	and	cl, 1
	or	BYTE PTR [esi+215], al

; 11670: 
; 11671:         return true;

	mov	al, 1
	or	BYTE PTR [esi+216], cl
	pop	edi
	pop	esi
	pop	ebx

; 11893:   };

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN38@operator:

; 11672:       } break;
; 11673: 
; 11674:       // Don't care about these events for anything other than filtering;
; 11675:       //   we will poll the immediate mouse state when the frame starts.
; 11676:       //
; 11677:       //  This effectively gives us buffered mouse input behavior, where
; 11678:       //    no mouse click is ever lost (only the time that it happened).
; 11679:       //
; 11680:       case WM_LBUTTONUP:
; 11681:         return true;
; 11682:       case WM_RBUTTONUP:
; 11683:         return true;
; 11684:       case WM_MBUTTONUP:
; 11685:         return true;
; 11686:       case WM_XBUTTONUP:
; 11687:         return true;
; 11688: 
; 11689: 
; 11690:       case WM_MOUSEWHEEL:
; 11691:         io.MouseWheel += GET_WHEEL_DELTA_WPARAM (wParam) > 0 ? +1.0f : -1.0f;

	mov	eax, DWORD PTR _wParam$[ebp]
	shr	eax, 16					; 00000010H
	test	ax, ax
	jle	SHORT $LN76@operator
	movss	xmm1, DWORD PTR __real@3f800000
	jmp	SHORT $LN77@operator
$LN76@operator:
	movss	xmm1, DWORD PTR __real@bf800000
$LN77@operator:
	movss	xmm0, DWORD PTR [esi+220]

; 11692:         return true;

	mov	al, 1
	addss	xmm0, xmm1
	pop	edi
	movss	DWORD PTR [esi+220], xmm0
	pop	esi
	pop	ebx

; 11893:   };

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN12@operator:

; 11556:     {
; 11557:       case WM_HOTKEY:
; 11558:       {
; 11559:         if (SK_ImGui_WantGamepadCapture ())

	call	?SK_ImGui_WantGamepadCapture@@YA_NXZ	; SK_ImGui_WantGamepadCapture
	test	al, al
	je	$LN16@operator
$LN34@operator:
	pop	edi
	pop	esi

; 11560:         {
; 11561:           return 1;

	mov	al, 1
	pop	ebx

; 11893:   };

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN84@operator:

; 11554: 
; 11555:     switch (msg)

	cmp	ecx, 793				; 00000319H
	jne	$LN16@operator

; 11562:         }
; 11563:       } break;
; 11564: 
; 11565:       // TODO: Take the bazillion different sources of input and translate them all into
; 11566:       //          a standard window message format for sanity's sake during filter evaluation.
; 11567:       case WM_APPCOMMAND:
; 11568:       {
; 11569:         switch (GET_DEVICE_LPARAM (lParam))

	mov	eax, DWORD PTR _lParam$[ebp]
	shr	eax, 16					; 00000010H
	and	eax, 61440				; 0000f000H
	je	SHORT $LN15@operator
	cmp	eax, 32768				; 00008000H
	jne	$LN16@operator

; 11579:             //}
; 11580:           } break;
; 11581: 
; 11582:           case FAPPCOMMAND_MOUSE:
; 11583:           {
; 11584:             if (SK_ImGui_WantMouseCapture ())

	call	?SK_ImGui_WantMouseCapture@@YA_NXZ	; SK_ImGui_WantMouseCapture
	test	al, al
	je	SHORT $LN18@operator

; 11585:             {
; 11586:               dll_log.Log (L"Removed WM_APPCOMMAND Mouse Event");

	push	OFFSET ??_C@_1EE@HBEADAKP@?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AAd?$AA?5?$AAW?$AAM?$AA_?$AAA?$AAP?$AAP?$AAC?$AAO?$AAM?$AAM?$AAA?$AAN?$AAD?$AA?5?$AAM?$AAo?$AAu?$AAs?$AAe?$AA?5?$AAE?$AAv?$AAe?$AAn@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8

; 11587:               return true;

	mov	al, 1
	pop	edi
	pop	esi
	pop	ebx

; 11893:   };

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN18@operator:

; 11588:             }
; 11589: 
; 11590:             dll_log.Log (L"WM_APPCOMMAND Mouse Event");

	push	OFFSET ??_C@_1DE@HMFBBKJG@?$AAW?$AAM?$AA_?$AAA?$AAP?$AAP?$AAC?$AAO?$AAM?$AAM?$AAA?$AAN?$AAD?$AA?5?$AAM?$AAo?$AAu?$AAs?$AAe?$AA?5?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?$AA@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8

; 11591: 
; 11592:             DWORD dwPos = GetMessagePos ();

	call	DWORD PTR __imp__GetMessagePos@0

; 11593:             LONG  lRet  = SK_ImGui_DeltaTestMouse (*(POINTS *)&last_pos, dwPos);

	push	1
	push	eax
	push	OFFSET ?last_pos@?1??ImGui_WndProcHandler@@YGJPAUHWND__@@IIJ@Z@4UtagPOINTS@@A
	call	?SK_ImGui_DeltaTestMouse@@YAJAAUtagPOINTS@@KF@Z ; SK_ImGui_DeltaTestMouse
	add	esp, 12					; 0000000cH

; 11594: 
; 11595:             if (lRet >= 0)

	test	eax, eax
	js	$LN16@operator

; 11596:             {
; 11597:               dll_log.Log (L"Removed WM_APPCOMMAND Mouse Delta Failure");

	push	OFFSET ??_C@_1FE@DBJNABHE@?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe?$AAd?$AA?5?$AAW?$AAM?$AA_?$AAA?$AAP?$AAP?$AAC?$AAO?$AAM?$AAM?$AAA?$AAN?$AAD?$AA?5?$AAM?$AAo?$AAu?$AAs?$AAe?$AA?5?$AAD?$AAe?$AAl?$AAt@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8

; 11598:               return true;

	mov	al, 1
	pop	edi
	pop	esi
	pop	ebx

; 11893:   };

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN15@operator:

; 11570:         {
; 11571:           case FAPPCOMMAND_KEY:
; 11572:           {
; 11573:             dll_log.Log (L"WM_APPCOMMAND Keyboard Event");

	push	OFFSET ??_C@_1DK@BLGEDKBM@?$AAW?$AAM?$AA_?$AAA?$AAP?$AAP?$AAC?$AAO?$AAM?$AAM?$AAA?$AAN?$AAD?$AA?5?$AAK?$AAe?$AAy?$AAb?$AAo?$AAa?$AAr?$AAd?$AA?5?$AAE?$AAv?$AAe?$AAn?$AAt?$AA?$AA@
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8

; 11574: 
; 11575:             //if (SK_ImGui_WantKeyboardCapture ())
; 11576:             //{
; 11577:             if (window_active)

	cmp	BYTE PTR ?window_active@?1???R<lambda_34955bda5757b6d1afe210935814f65c>@@QBE_NPAUHWND__@@IIJ@Z@4_NA, 0 ; `<lambda_34955bda5757b6d1afe210935814f65c>::operator()'::`2'::window_active
	je	$LN16@operator

; 11578:               return true;

	pop	edi
	pop	esi
	mov	al, 1
	pop	ebx

; 11893:   };

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	1
$LN94@operator:
	DD	$LN20@operator
	DD	$LN22@operator
	DD	$LN59@operator
	DD	$LN67@operator
	DD	$LN39@operator
	DD	$LN55@operator
	DD	$LN65@operator
	DD	$LN16@operator
$LN90@operator:
	DB	0
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	1
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	2
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	4
	DB	5
	npad	3
$LN95@operator:
	DD	$LN48@operator
	DD	$LN49@operator
	DD	$LN54@operator
	DD	$LN50@operator
	DD	$LN51@operator
	DD	$LN52@operator
$LN96@operator:
	DD	$LN30@operator
	DD	$LN34@operator
	DD	$LN30@operator
	DD	$LN31@operator
	DD	$LN34@operator
	DD	$LN31@operator
	DD	$LN32@operator
	DD	$LN34@operator
	DD	$LN32@operator
	DD	$LN38@operator
	DD	$LN33@operator
	DD	$LN34@operator
	DD	$LN33@operator
??R<lambda_34955bda5757b6d1afe210935814f65c>@@QBE_NPAUHWND__@@IIJ@Z ENDP ; <lambda_34955bda5757b6d1afe210935814f65c>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_MessageProc$ = -1					; size = 1
_hWnd$ = 8						; size = 4
_msg$ = 12						; size = 4
_filter_raw_input$1$ = 15				; size = 1
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_filter_warps$1$ = 23					; size = 1
?ImGui_WndProcHandler@@YGJPAUHWND__@@IIJ@Z PROC		; ImGui_WndProcHandler

; 11481: {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx

; 11482:   if (msg == WM_DEVICECHANGE)
; 11483:   {
; 11484:     switch (wParam)

	mov	ebx, DWORD PTR _wParam$[ebp]
	push	esi
	mov	esi, DWORD PTR _msg$[ebp]
	push	edi
	mov	edi, DWORD PTR _lParam$[ebp]
	cmp	esi, 537				; 00000219H
	jne	$LN11@ImGui_WndP
	lea	eax, DWORD PTR [ebx-32768]
	cmp	eax, 4
	ja	$LN11@ImGui_WndP
	jmp	DWORD PTR $LN135@ImGui_WndP[eax*4]
$LN5@ImGui_WndP:

; 11485:     {
; 11486:       case DBT_DEVICEARRIVAL:
; 11487:       {
; 11488:         auto *pHdr = reinterpret_cast <DEV_BROADCAST_HDR *> (lParam);
; 11489:   
; 11490:         if (pHdr->dbch_devicetype == DBT_DEVTYP_DEVICEINTERFACE)

	cmp	DWORD PTR [edi+4], 5
	jne	SHORT $LN11@ImGui_WndP

; 11491:         {
; 11492:           if ( config.input.gamepad.xinput.placehold [0] || config.input.gamepad.xinput.placehold [1] ||
; 11493:                config.input.gamepad.xinput.placehold [2] || config.input.gamepad.xinput.placehold [3] )

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+684, 0
	jne	SHORT $LN8@ImGui_WndP
	cmp	BYTE PTR ?config@@3Usk_config_t@@A+685, 0
	jne	SHORT $LN8@ImGui_WndP
	cmp	BYTE PTR ?config@@3Usk_config_t@@A+686, 0
	jne	SHORT $LN8@ImGui_WndP
	cmp	BYTE PTR ?config@@3Usk_config_t@@A+687, 0
	je	SHORT $LN11@ImGui_WndP
$LN8@ImGui_WndP:

; 11494:           {
; 11495:             dll_log.Log (L"[XInput_Hot]  (Input Device Connected)");

	push	OFFSET $SG142679
$LN133@ImGui_WndP:
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8
$LN39@ImGui_WndP:

; 11496:             return true;

	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx

; 11954: }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN9@ImGui_WndP:

; 11497:           }
; 11498:         }
; 11499:       } break;
; 11500:   
; 11501:       case DBT_DEVICEQUERYREMOVE:
; 11502:       case DBT_DEVICEREMOVEPENDING:
; 11503:       case DBT_DEVICEREMOVECOMPLETE:
; 11504:       {
; 11505:         auto *pHdr = reinterpret_cast <DEV_BROADCAST_HDR *> (lParam);
; 11506:   
; 11507:         if (pHdr->dbch_devicetype == DBT_DEVTYP_DEVICEINTERFACE)

	cmp	DWORD PTR [edi+4], 5
	jne	SHORT $LN11@ImGui_WndP

; 11508:         {
; 11509:           if ( config.input.gamepad.xinput.placehold [0] || config.input.gamepad.xinput.placehold [1] ||
; 11510:                config.input.gamepad.xinput.placehold [2] || config.input.gamepad.xinput.placehold [3] )

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+684, 0
	jne	SHORT $LN12@ImGui_WndP
	cmp	BYTE PTR ?config@@3Usk_config_t@@A+685, 0
	jne	SHORT $LN12@ImGui_WndP
	cmp	BYTE PTR ?config@@3Usk_config_t@@A+686, 0
	jne	SHORT $LN12@ImGui_WndP
	cmp	BYTE PTR ?config@@3Usk_config_t@@A+687, 0
	je	SHORT $LN11@ImGui_WndP
$LN12@ImGui_WndP:

; 11511:           {
; 11512:             dll_log.Log (L"[XInput_Hot]  (Input Device Disconnected)");

	push	OFFSET $SG142684

; 11513:             return true;

	jmp	SHORT $LN133@ImGui_WndP
$LN11@ImGui_WndP:

; 11514:           }
; 11515:         }
; 11516:       } break;
; 11517:     }
; 11518:   }
; 11519: 
; 11520: 
; 11521:   HWND hWndActive = GetActiveWindow ();

	call	DWORD PTR __imp__GetActiveWindow@0

; 11522: 
; 11523:   if (hWndActive != game_window.hWnd && hWndActive != nullptr)

	cmp	eax, DWORD PTR ?game_window@@3Usk_window_s@@A+4
	je	SHORT $LN13@ImGui_WndP
	test	eax, eax
	jne	$LN20@ImGui_WndP
$LN13@ImGui_WndP:

; 11524:     return 0;
; 11525: 
; 11526: 
; 11527:   static POINTS last_pos;
; 11528: 
; 11529:   UNREFERENCED_PARAMETER (lParam);
; 11530: 
; 11531:   auto MessageProc = [&](HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) ->
; 11532:   bool
; 11533:   {
; 11534:     static bool window_active = true;
; 11535: 
; 11536:     ImGuiIO& io =
; 11537:       ImGui::GetIO ();
; 11538: 
; 11539:     auto ActivateWindow = [&](bool active = false)
; 11540:     {
; 11541:       bool changed = (active != window_active);
; 11542: 
; 11543:       if (active && changed)
; 11544:         SK_Input_RememberPressedKeys ();
; 11545: 
; 11546:       if ((! active) && changed)
; 11547:       {
; 11548:         ZeroMemory (io.MouseDown, sizeof (bool) * 5  );
; 11549:         ZeroMemory (io.KeysDown,  sizeof (bool) * 512);
; 11550:       }
; 11551: 
; 11552:       window_active = active;
; 11553:     };
; 11554: 
; 11555:     switch (msg)
; 11556:     {
; 11557:       case WM_HOTKEY:
; 11558:       {
; 11559:         if (SK_ImGui_WantGamepadCapture ())
; 11560:         {
; 11561:           return 1;
; 11562:         }
; 11563:       } break;
; 11564: 
; 11565:       // TODO: Take the bazillion different sources of input and translate them all into
; 11566:       //          a standard window message format for sanity's sake during filter evaluation.
; 11567:       case WM_APPCOMMAND:
; 11568:       {
; 11569:         switch (GET_DEVICE_LPARAM (lParam))
; 11570:         {
; 11571:           case FAPPCOMMAND_KEY:
; 11572:           {
; 11573:             dll_log.Log (L"WM_APPCOMMAND Keyboard Event");
; 11574: 
; 11575:             //if (SK_ImGui_WantKeyboardCapture ())
; 11576:             //{
; 11577:             if (window_active)
; 11578:               return true;
; 11579:             //}
; 11580:           } break;
; 11581: 
; 11582:           case FAPPCOMMAND_MOUSE:
; 11583:           {
; 11584:             if (SK_ImGui_WantMouseCapture ())
; 11585:             {
; 11586:               dll_log.Log (L"Removed WM_APPCOMMAND Mouse Event");
; 11587:               return true;
; 11588:             }
; 11589: 
; 11590:             dll_log.Log (L"WM_APPCOMMAND Mouse Event");
; 11591: 
; 11592:             DWORD dwPos = GetMessagePos ();
; 11593:             LONG  lRet  = SK_ImGui_DeltaTestMouse (*(POINTS *)&last_pos, dwPos);
; 11594: 
; 11595:             if (lRet >= 0)
; 11596:             {
; 11597:               dll_log.Log (L"Removed WM_APPCOMMAND Mouse Delta Failure");
; 11598:               return true;
; 11599:             }
; 11600:           } break;
; 11601:         }
; 11602:       } break;
; 11603: 
; 11604: 
; 11605: 
; 11606:       case WM_MOUSEACTIVATE:
; 11607:       {
; 11608:         if (hWnd == game_window.hWnd)
; 11609:         {
; 11610:           ActivateWindow (((HWND)wParam == hWnd));
; 11611:         }
; 11612:       } break;
; 11613: 
; 11614: 
; 11615:       case WM_ACTIVATEAPP:
; 11616:       case WM_ACTIVATE:
; 11617:       case WM_NCACTIVATE:
; 11618:       {
; 11619:         if (hWnd == game_window.hWnd)
; 11620:         {
; 11621:           if (msg == WM_NCACTIVATE || msg == WM_ACTIVATEAPP)
; 11622:           {
; 11623:             ActivateWindow (wParam != 0x00);
; 11624:           }
; 11625: 
; 11626:           else if (msg == WM_ACTIVATE)
; 11627:           {
; 11628:             switch (LOWORD (wParam))
; 11629:             {
; 11630:               case WA_ACTIVE:
; 11631:               case WA_CLICKACTIVE:
; 11632:               default: // Unknown
; 11633:               {
; 11634:                 ActivateWindow ((HWND)lParam != game_window.hWnd);
; 11635:               } break;
; 11636: 
; 11637:               case WA_INACTIVE:
; 11638:               {
; 11639:                 ActivateWindow (lParam == 0 || (HWND)lParam == game_window.hWnd);
; 11640:               } break;
; 11641:             }
; 11642:           }
; 11643:         }
; 11644:       } break;
; 11645: 
; 11646: 
; 11647:       case WM_LBUTTONDOWN:
; 11648:       case WM_LBUTTONDBLCLK: // Sent on receipt of the second click
; 11649:         io.MouseDown [0] = true;
; 11650:         return true;
; 11651: 
; 11652:       case WM_RBUTTONDOWN:
; 11653:       case WM_RBUTTONDBLCLK: // Sent on receipt of the second click 
; 11654:         io.MouseDown [1] = true;
; 11655:         return true;
; 11656: 
; 11657:       case WM_MBUTTONDOWN:
; 11658:       case WM_MBUTTONDBLCLK: // Sent on receipt of the second click
; 11659:         io.MouseDown [2] = true;
; 11660:         return true;
; 11661: 
; 11662:       case WM_XBUTTONDOWN:
; 11663:       case WM_XBUTTONDBLCLK: // Sent on receipt of the second click
; 11664:       {
; 11665:         WORD Flags =
; 11666:           GET_XBUTTON_WPARAM (wParam);
; 11667: 
; 11668:         io.MouseDown [3] |= (Flags & XBUTTON1) != 0;
; 11669:         io.MouseDown [4] |= (Flags & XBUTTON2) != 0;
; 11670: 
; 11671:         return true;
; 11672:       } break;
; 11673: 
; 11674:       // Don't care about these events for anything other than filtering;
; 11675:       //   we will poll the immediate mouse state when the frame starts.
; 11676:       //
; 11677:       //  This effectively gives us buffered mouse input behavior, where
; 11678:       //    no mouse click is ever lost (only the time that it happened).
; 11679:       //
; 11680:       case WM_LBUTTONUP:
; 11681:         return true;
; 11682:       case WM_RBUTTONUP:
; 11683:         return true;
; 11684:       case WM_MBUTTONUP:
; 11685:         return true;
; 11686:       case WM_XBUTTONUP:
; 11687:         return true;
; 11688: 
; 11689: 
; 11690:       case WM_MOUSEWHEEL:
; 11691:         io.MouseWheel += GET_WHEEL_DELTA_WPARAM (wParam) > 0 ? +1.0f : -1.0f;
; 11692:         return true;
; 11693: 
; 11694:       case WM_KEYDOWN:
; 11695:       case WM_SYSKEYDOWN:
; 11696:       {
; 11697:         BYTE  vkCode   = LOWORD (wParam) & 0xFF;
; 11698:         BYTE  scanCode = HIWORD (lParam) & 0x7F;
; 11699: 
; 11700:         if (vkCode & 0xF8) // Valid Keys:  8 - 255
; 11701:         {
; 11702:           // Don't process Alt+Tab or Alt+Enter
; 11703:           if (msg == WM_SYSKEYDOWN && ( vkCode == VK_TAB || vkCode == VK_RETURN ))
; 11704:             return false;
; 11705: 
; 11706:           // Just the make / break events, repeats are ignored
; 11707:           if      ((lParam & 0x40000000UL) == 0)
; 11708:             SK_Console::getInstance ()->KeyDown (vkCode, MAXDWORD);
; 11709: 
; 11710:           if (vkCode != VK_TAB)
; 11711:           {
; 11712:             wchar_t key_str;
; 11713: 
; 11714:             if ( ToUnicodeEx ( vkCode,
; 11715:                                scanCode,
; 11716:                                (const BYTE *)io.KeysDown,
; 11717:                               &key_str,
; 11718:                                1,
; 11719:                                0x00,
; 11720:                                GetKeyboardLayout (0) )
; 11721:                      &&
; 11722:                   iswprint ( key_str )
; 11723:                )
; 11724:             {
; 11725:               ImGui_WndProcHandler ( hWnd, WM_CHAR, key_str, lParam );
; 11726:             }
; 11727:           }
; 11728:         }
; 11729: 
; 11730:         // Mouse event
; 11731:         //
; 11732:         else if (vkCode < 7)
; 11733:         {
; 11734:           int remap = -1;
; 11735: 
; 11736:           // Stupid hack, but these indices are discontinuous
; 11737:           //
; 11738:           switch (vkCode)
; 11739:           {
; 11740:             case VK_LBUTTON:
; 11741:               remap = 0;
; 11742:               break;
; 11743: 
; 11744:             case VK_RBUTTON:
; 11745:               remap = 1;
; 11746:               break;
; 11747: 
; 11748:             case VK_MBUTTON:
; 11749:               remap = 2;
; 11750:               break;
; 11751: 
; 11752:             case VK_XBUTTON1:
; 11753:               remap = 3;
; 11754:               break;
; 11755: 
; 11756:             case VK_XBUTTON2:
; 11757:               remap = 4;
; 11758:               break;
; 11759: 
; 11760:             default:
; 11761:               assert (false); // WTF?! These keys don't exist
; 11762:               break;
; 11763:           }
; 11764: 
; 11765:           if (remap != -1)
; 11766:             io.MouseDown [remap] = true;
; 11767:         }
; 11768: 
; 11769:         return true;
; 11770:       } break;
; 11771: 
; 11772: 
; 11773:       case WM_KEYUP:
; 11774:       case WM_SYSKEYUP:
; 11775:       {
; 11776:         BYTE vkCode = LOWORD (wParam) & 0xFF;
; 11777: 
; 11778:         if (vkCode & 0xF8) // Valid Keys:  8 - 255
; 11779:         {
; 11780:           // Don't process Alt+Tab or Alt+Enter
; 11781:           if (msg == WM_SYSKEYUP && ( vkCode == VK_TAB || vkCode == VK_RETURN ))
; 11782:             return false;
; 11783: 
; 11784:           SK_Console::getInstance ()->KeyUp (vkCode, lParam);
; 11785: 
; 11786:           return true;
; 11787:         }
; 11788:       } break;
; 11789: 
; 11790: 
; 11791:       case WM_NCMOUSEMOVE:
; 11792:       case WM_MOUSEMOVE:
; 11793:       {
; 11794:         LONG lDeltaRet = SK_ImGui_DeltaTestMouse (last_pos, (DWORD)lParam);
; 11795: 
; 11796:         // Return:
; 11797:         //
; 11798:         //   -1 if no filtering is desired
; 11799:         //    0 if the message should be passed onto app, but internal cursor pos unchanged
; 11800:         //    1 if the message should be completely eradicated
; 11801:         //
; 11802:         if (lDeltaRet >= 0)
; 11803:         {
; 11804:           if (SK_ImGui_IsMouseRelevant ())
; 11805:             SK_ImGui_Cursor.update ();
; 11806: 
; 11807:           return lDeltaRet;
; 11808:         }
; 11809: 
; 11810:         SHORT xPos = GET_X_LPARAM (lParam);
; 11811:         SHORT yPos = GET_Y_LPARAM (lParam);
; 11812: 
; 11813:         SK_ImGui_Cursor.pos.x = xPos;
; 11814:         SK_ImGui_Cursor.pos.y = yPos;
; 11815: 
; 11816:         SK_ImGui_Cursor.ClientToLocal (&SK_ImGui_Cursor.pos);
; 11817: 
; 11818:         io.MousePos.x = (float)SK_ImGui_Cursor.pos.x;
; 11819:         io.MousePos.y = (float)SK_ImGui_Cursor.pos.y;
; 11820: 
; 11821:         if (! SK_ImGui_WantMouseCapture ())
; 11822:         {
; 11823:           if (SK_ImGui_IsMouseRelevant ())
; 11824:             SK_ImGui_Cursor.update ();
; 11825: 
; 11826:           SK_ImGui_Cursor.orig_pos = SK_ImGui_Cursor.pos;
; 11827: 
; 11828:           return false;
; 11829:         }
; 11830: 
; 11831:         if (SK_ImGui_IsMouseRelevant ())
; 11832:           SK_ImGui_Cursor.update ();
; 11833: 
; 11834:         return true;
; 11835:       } break;
; 11836: 
; 11837: 
; 11838:       case WM_CHAR:
; 11839:       {
; 11840:         // You can also use ToAscii()+GetKeyboardState() to retrieve characters.
; 11841:         if ((wParam & 0xff) > 7 && wParam < 0x10000)
; 11842:         {
; 11843:           io.AddInputCharacter ((unsigned short)(wParam & 0xFFFF));
; 11844:         }
; 11845: 
; 11846:         return true;
; 11847:       } break;
; 11848: 
; 11849: 
; 11850:       case WM_INPUT:
; 11851:       {
; 11852:         RAWINPUT data = { };
; 11853:         UINT     size = sizeof RAWINPUT;
; 11854: 
; 11855:         int      ret  =
; 11856:           GetRawInputData_Original ((HRAWINPUT)lParam, RID_HEADER, &data, &size, sizeof (RAWINPUTHEADER) );
; 11857: 
; 11858:         if (ret)
; 11859:         {
; 11860:           auto *pData =
; 11861:             new uint8_t [size];
; 11862: 
; 11863:           if (! pData)
; 11864:             return 0;
; 11865: 
; 11866:           bool cap = false;
; 11867: 
; 11868:           switch (data.header.dwType)
; 11869:           {
; 11870:             case RIM_TYPEMOUSE:
; 11871:               cap = SK_ImGui_ProcessRawInput ((HRAWINPUT)lParam, RID_INPUT, &data, &size, sizeof (data.header),  true) != 0 && SK_ImGui_WantMouseCapture ();
; 11872:               break;
; 11873: 
; 11874:             case RIM_TYPEKEYBOARD:
; 11875:               cap  = SK_ImGui_ProcessRawInput ((HRAWINPUT)lParam, RID_INPUT, &data, &size, sizeof (data.header), true) != 0;
; 11876:               cap &= ( SK_Console::getInstance ()->isVisible () || SK_ImGui_WantKeyboardCapture () || SK_ImGui_WantGamepadCapture () );
; 11877:               break;
; 11878: 
; 11879:             default:
; 11880:               cap  = SK_ImGui_ProcessRawInput ((HRAWINPUT)lParam, RID_INPUT, &data, &size, sizeof (data.header), true) != 0;
; 11881:               cap &= SK_ImGui_WantGamepadCapture ();
; 11882:               break;
; 11883:           }
; 11884: 
; 11885:           delete [] pData;
; 11886: 
; 11887:           return cap;
; 11888:         }
; 11889:       } break;
; 11890:     }
; 11891: 
; 11892:     return false;
; 11893:   };
; 11894: 
; 11895: 
; 11896:   bool handled          = MessageProc (hWnd, msg, wParam, lParam);

	push	edi
	push	ebx
	push	esi
	push	DWORD PTR _hWnd$[ebp]
	lea	ecx, DWORD PTR _MessageProc$[ebp]
	call	??R<lambda_34955bda5757b6d1afe210935814f65c>@@QBE_NPAUHWND__@@IIJ@Z ; <lambda_34955bda5757b6d1afe210935814f65c>::operator()
	mov	bl, al

; 11897:   bool filter_raw_input = (msg == WM_INPUT && handled);

	cmp	esi, 255				; 000000ffH
	jne	SHORT $LN24@ImGui_WndP
	mov	BYTE PTR _filter_raw_input$1$[ebp], 1
	test	bl, bl
	jne	SHORT $LN25@ImGui_WndP
$LN24@ImGui_WndP:
	mov	BYTE PTR _filter_raw_input$1$[ebp], 0
$LN25@ImGui_WndP:

; 11898: 
; 11899: 
; 11900:   bool filter_warps = SK_ImGui_WantMouseWarpFiltering ();

	call	?SK_ImGui_WantMouseWarpFiltering@@YA_NXZ ; SK_ImGui_WantMouseWarpFiltering
	mov	BYTE PTR _filter_warps$1$[ebp], al

; 11901: 
; 11902:   UINT uMsg = msg;
; 11903: 
; 11904:   if (/*SK_ImGui_Visible &&*/ handled)

	test	bl, bl
	je	$LN20@ImGui_WndP

; 11905:   { 
; 11906:     bool keyboard_capture =
; 11907:       ( ( (uMsg >= WM_KEYFIRST   && uMsg <= WM_KEYLAST) ||
; 11908:            uMsg == WM_HOTKEY     ||
; 11909:          ( uMsg == WM_APPCOMMAND && GET_DEVICE_LPARAM (lParam)  == FAPPCOMMAND_KEY   ) ) &&

	cmp	esi, 256				; 00000100H
	jb	SHORT $LN26@ImGui_WndP
	cmp	esi, 265				; 00000109H
	jbe	SHORT $LN27@ImGui_WndP
$LN26@ImGui_WndP:
	cmp	esi, 786				; 00000312H
	je	SHORT $LN27@ImGui_WndP
	cmp	esi, 793				; 00000319H
	jne	SHORT $LN28@ImGui_WndP
	mov	eax, edi
	shr	eax, 16					; 00000010H
	test	eax, 61440				; 0000f000H
	jne	SHORT $LN28@ImGui_WndP
$LN27@ImGui_WndP:
	call	?SK_ImGui_WantKeyboardCapture@@YA_NXZ	; SK_ImGui_WantKeyboardCapture
	test	al, al
	je	SHORT $LN28@ImGui_WndP
	mov	bh, 1
	jmp	SHORT $LN29@ImGui_WndP
$LN28@ImGui_WndP:
	xor	bh, bh
$LN29@ImGui_WndP:

; 11910:           SK_ImGui_WantKeyboardCapture () );
; 11911: 
; 11912:     bool mouse_capture =
; 11913:       ( ( ( uMsg >= WM_MOUSEFIRST && uMsg <= WM_MOUSELAST ) ||
; 11914:           ( uMsg == WM_APPCOMMAND && GET_DEVICE_LPARAM (lParam) == FAPPCOMMAND_MOUSE ) ) && 

	cmp	esi, 512				; 00000200H
	jb	SHORT $LN30@ImGui_WndP
	cmp	esi, 526				; 0000020eH
	jbe	SHORT $LN32@ImGui_WndP
$LN30@ImGui_WndP:
	cmp	esi, 793				; 00000319H
	jne	SHORT $LN31@ImGui_WndP
	mov	eax, edi
	shr	eax, 16					; 00000010H
	and	eax, 61440				; 0000f000H
	cmp	eax, 32768				; 00008000H
	jne	SHORT $LN31@ImGui_WndP
$LN32@ImGui_WndP:
	call	?SK_ImGui_WantMouseCapture@@YA_NXZ	; SK_ImGui_WantMouseCapture
	test	al, al
	jne	SHORT $LN34@ImGui_WndP
	cmp	BYTE PTR _filter_warps$1$[ebp], al
	je	SHORT $LN31@ImGui_WndP
	cmp	esi, 512				; 00000200H
	jne	SHORT $LN31@ImGui_WndP
$LN34@ImGui_WndP:
	mov	bl, 1
	jmp	SHORT $LN35@ImGui_WndP
$LN31@ImGui_WndP:
	xor	bl, bl
$LN35@ImGui_WndP:

; 11915: 
; 11916:           ( SK_ImGui_WantMouseCapture () || 
; 11917:             (filter_warps && uMsg == WM_MOUSEMOVE) )
; 11918:       );
; 11919: 
; 11920:     if ((wParam & 0xFF) < 7)

	mov	eax, DWORD PTR _wParam$[ebp]
	cmp	al, 7
	jae	SHORT $LN16@ImGui_WndP

; 11921:     {
; 11922:       // Some games use Virtual Key Codes 1-6 (mouse button 0-4)
; 11923:       //   instead of WM_LBUTTONDOWN, etc.
; 11924:       if ( ( SK_ImGui_WantMouseCapture () && uMsg == WM_KEYDOWN ) ||

	call	?SK_ImGui_WantMouseCapture@@YA_NXZ	; SK_ImGui_WantMouseCapture
	test	al, al
	je	SHORT $LN18@ImGui_WndP
	cmp	esi, 256				; 00000100H
	je	SHORT $LN17@ImGui_WndP
$LN18@ImGui_WndP:
	call	?SK_ImGui_WantMouseCapture@@YA_NXZ	; SK_ImGui_WantMouseCapture
	test	al, al
	je	SHORT $LN16@ImGui_WndP
	cmp	esi, 257				; 00000101H
	jne	SHORT $LN16@ImGui_WndP
$LN17@ImGui_WndP:

; 11925:            ( SK_ImGui_WantMouseCapture () && uMsg == WM_KEYUP   ) )
; 11926:       {
; 11927:         // Block Mouse Input
; 11928:         mouse_capture    = true;

	mov	bl, 1

; 11929:         keyboard_capture = false;

	xor	bh, bh
$LN16@ImGui_WndP:

; 11930:       }
; 11931:     }
; 11932: 
; 11933:     if (config.input.ui.capture_mouse)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+660, 0
	je	SHORT $LN36@ImGui_WndP

; 11934:     {
; 11935:       mouse_capture = (uMsg >= WM_MOUSEFIRST  && uMsg <= WM_MOUSELAST);

	lea	eax, DWORD PTR [esi-512]
	cmp	eax, 14					; 0000000eH
	setbe	bl
$LN36@ImGui_WndP:

; 11936:     }
; 11937: 
; 11938:     if ( keyboard_capture || mouse_capture || filter_raw_input )

	test	bh, bh
	jne	SHORT $LN21@ImGui_WndP
	test	bl, bl
	jne	SHORT $LN21@ImGui_WndP
	cmp	BYTE PTR _filter_raw_input$1$[ebp], bl
	je	SHORT $LN20@ImGui_WndP
$LN21@ImGui_WndP:

; 11939:     {
; 11940:       if (uMsg == WM_INPUT)

	cmp	esi, 255				; 000000ffH
	jne	$LN39@ImGui_WndP

; 11941:       {
; 11942:         bool bUnicode =
; 11943:           IsWindowUnicode (hWnd);

	mov	esi, DWORD PTR _hWnd$[ebp]
	push	esi
	call	DWORD PTR __imp__IsWindowUnicode@4

; 11944: 
; 11945:         ( bUnicode ? DefWindowProcW (hWnd, uMsg, lParam, wParam) :

	push	DWORD PTR _wParam$[ebp]
	push	edi
	push	255					; 000000ffH
	push	esi
	test	eax, eax
	je	SHORT $LN38@ImGui_WndP
	call	DWORD PTR __imp__DefWindowProcW@16
	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx

; 11954: }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN38@ImGui_WndP:

; 11944: 
; 11945:         ( bUnicode ? DefWindowProcW (hWnd, uMsg, lParam, wParam) :

	call	DWORD PTR __imp__DefWindowProcA@16
	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx

; 11954: }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN20@ImGui_WndP:
	pop	edi
	pop	esi

; 11946:                      DefWindowProcA (hWnd, uMsg, lParam, wParam) );
; 11947:       }
; 11948: 
; 11949:       return 1;
; 11950:     }
; 11951:   }
; 11952: 
; 11953:   return 0;

	xor	eax, eax
	pop	ebx

; 11954: }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	1
$LN135@ImGui_WndP:
	DD	$LN5@ImGui_WndP
	DD	$LN9@ImGui_WndP
	DD	$LN11@ImGui_WndP
	DD	$LN9@ImGui_WndP
	DD	$LN9@ImGui_WndP
?ImGui_WndProcHandler@@YGJPAUHWND__@@IIJ@Z ENDP		; ImGui_WndProcHandler
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdlib.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdlib.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdlib.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_center$1 = -12						; size = 8
_local$1$ = -4						; size = 4
_last_pos$ = 8						; size = 4
_lParam$ = 12						; size = 4
_threshold$ = 16					; size = 2
?SK_ImGui_DeltaTestMouse@@YAJAAUtagPOINTS@@KF@Z PROC	; SK_ImGui_DeltaTestMouse

; 11425: {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 11426:   bool filter_warps = SK_ImGui_WantMouseWarpFiltering ();

	call	?SK_ImGui_WantMouseWarpFiltering@@YA_NXZ ; SK_ImGui_WantMouseWarpFiltering

; 11427: 
; 11428:   if (filter_warps)

	test	al, al
	je	$LN5@SK_ImGui_D

; 11429:   {
; 11430:     bool filter = false;
; 11431: 
; 11432:     // Filter out small movements / mouselook warps
; 11433:     //
; 11434:     //   This does create a weird deadzone in the center of the screen,
; 11435:     //     but most people will not notice ;)
; 11436:     //
; 11437:     if ( abs (last_pos.x - GET_X_LPARAM (lParam)) < threshold &&

	push	ebx
	push	esi
	mov	esi, DWORD PTR _last_pos$[ebp]
	xor	bl, bl
	push	edi
	mov	edi, DWORD PTR _lParam$[ebp]
	movsx	ecx, di
	movsx	eax, WORD PTR [esi]
	sub	eax, ecx
	mov	DWORD PTR _local$1$[ebp], ecx
	movsx	ecx, WORD PTR _threshold$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, ecx
	jge	SHORT $LN3@SK_ImGui_D
	mov	eax, edi
	movzx	ebx, bl
	shr	eax, 16					; 00000010H
	movsx	ecx, ax
	movsx	eax, WORD PTR [esi+2]
	sub	eax, ecx
	movsx	ecx, WORD PTR _threshold$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, ecx
	mov	eax, 1
	cmovl	ebx, eax
$LN3@SK_ImGui_D:

; 11438:          abs (last_pos.y - GET_Y_LPARAM (lParam)) < threshold )
; 11439:     {
; 11440:       filter = true;
; 11441:     }
; 11442: 
; 11443:     ImGuiIO& io =

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO

; 11444:       ImGui::GetIO ();
; 11445: 
; 11446:     POINT center { static_cast <LONG> (io.DisplaySize.x / 2.0f),

	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR __real@3f000000
	cvttss2si ecx, xmm0
	mov	DWORD PTR _center$1[ebp], ecx

; 11447:                    static_cast <LONG> (io.DisplaySize.y / 2.0f) };
; 11448: 
; 11449:     SK_ImGui_Cursor.LocalToClient (&center);

	mov	ecx, OFFSET ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A ; SK_ImGui_Cursor
	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	mov	DWORD PTR _center$1[ebp+4], eax
	lea	eax, DWORD PTR _center$1[ebp]
	push	eax
	call	?LocalToClient@sk_imgui_cursor_s@@QAEXPAUtagPOINT@@@Z ; sk_imgui_cursor_s::LocalToClient

; 11452:     if ( abs (center.x - GET_X_LPARAM (lParam)) <= (static_cast <float> (center.x) / (100.0f / config.input.mouse.antiwarp_deadzone)) &&

	movss	xmm0, DWORD PTR __real@42c80000
	divss	xmm0, DWORD PTR ?config@@3Usk_config_t@@A+716
	mov	ecx, DWORD PTR _center$1[ebp]
	mov	eax, ecx
	sub	eax, DWORD PTR _local$1$[ebp]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdlib.h

; 356  :         return labs(_X);

	cdq
	xor	eax, edx
	sub	eax, edx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 11452:     if ( abs (center.x - GET_X_LPARAM (lParam)) <= (static_cast <float> (center.x) / (100.0f / config.input.mouse.antiwarp_deadzone)) &&

	movss	xmm2, DWORD PTR __real@3f800000
	divss	xmm2, xmm0
	movd	xmm0, ecx
	cvtdq2ps xmm0, xmm0
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	mulss	xmm0, xmm2
	comiss	xmm0, xmm1
	jb	SHORT $LN4@SK_ImGui_D
	mov	esi, DWORD PTR _center$1[ebp+4]
	mov	eax, edi
	shr	eax, 16					; 00000010H
	movsx	ecx, ax
	mov	eax, esi
	sub	eax, ecx
	movzx	ebx, bl
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdlib.h

; 356  :         return labs(_X);

	cdq
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 11452:     if ( abs (center.x - GET_X_LPARAM (lParam)) <= (static_cast <float> (center.x) / (100.0f / config.input.mouse.antiwarp_deadzone)) &&

	mov	ecx, 1
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdlib.h

; 356  :         return labs(_X);

	xor	eax, edx
	movd	xmm0, esi
	mov	esi, DWORD PTR _last_pos$[ebp]
	sub	eax, edx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 11452:     if ( abs (center.x - GET_X_LPARAM (lParam)) <= (static_cast <float> (center.x) / (100.0f / config.input.mouse.antiwarp_deadzone)) &&

	cvtdq2ps xmm0, xmm0
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	mulss	xmm0, xmm2
	comiss	xmm0, xmm1
	cmovae	ebx, ecx
$LN4@SK_ImGui_D:

; 11453:          abs (center.y - GET_Y_LPARAM (lParam)) <= (static_cast <float> (center.y) / (100.0f / config.input.mouse.antiwarp_deadzone)) )
; 11454:     {
; 11455:       filter = true;
; 11456:     }
; 11457: 
; 11458:     POINT local { GET_X_LPARAM (lParam),
; 11459:                   GET_Y_LPARAM (lParam) };
; 11460: 
; 11461:     last_pos.x = static_cast <SHORT> (local.x);

	mov	ecx, DWORD PTR _local$1$[ebp]
	shr	edi, 16					; 00000010H

; 11462:     last_pos.y = static_cast <SHORT> (local.y);
; 11463: 
; 11464:     // Dispose Without Processing
; 11465:     if (filter)

	test	bl, bl
	movsx	eax, di
	pop	edi
	mov	WORD PTR [esi], cx
	mov	WORD PTR [esi+2], ax
	pop	esi
	pop	ebx
	je	SHORT $LN5@SK_ImGui_D

; 11466:     {
; 11467:       return SK_ImGui_IsMouseRelevant () ? 1 : 0;

	call	?SK_ImGui_IsMouseRelevant@@YA_NXZ	; SK_ImGui_IsMouseRelevant
	xor	ecx, ecx
	test	al, al
	setne	cl
	mov	eax, ecx

; 11472: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@SK_ImGui_D:

; 11468:     }
; 11469:   }
; 11470: 
; 11471:   return -1;

	or	eax, -1

; 11472: }

	mov	esp, ebp
	pop	ebp
	ret	0
?SK_ImGui_DeltaTestMouse@@YAJAAUtagPOINTS@@KF@Z ENDP	; SK_ImGui_DeltaTestMouse
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?SK_ImGui_WantMouseWarpFiltering@@YA_NXZ PROC		; SK_ImGui_WantMouseWarpFiltering

; 11411:   extern bool
; 11412:   SK_InputUtil_IsHWCursorVisible (void);
; 11413: 
; 11414:   if ( ( SK_ImGui_Cursor.prefs.no_warp.ui_open && SK_ImGui_IsMouseRelevant       () ) ||

	cmp	BYTE PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+38, 0
	je	SHORT $LN4@SK_ImGui_W
	call	?SK_ImGui_IsMouseRelevant@@YA_NXZ	; SK_ImGui_IsMouseRelevant
	test	al, al
	jne	SHORT $LN3@SK_ImGui_W
$LN4@SK_ImGui_W:
	cmp	BYTE PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+36, 0
	je	SHORT $LN2@SK_ImGui_W
	call	?SK_InputUtil_IsHWCursorVisible@@YA_NXZ	; SK_InputUtil_IsHWCursorVisible
	test	al, al
	je	SHORT $LN2@SK_ImGui_W
$LN3@SK_ImGui_W:

; 11415:        ( SK_ImGui_Cursor.prefs.no_warp.visible && SK_InputUtil_IsHWCursorVisible () ) )
; 11416:   {
; 11417:     return true;

	mov	al, 1

; 11421: }

	ret	0
$LN2@SK_ImGui_W:

; 11418:   }
; 11419: 
; 11420:   return false;

	xor	al, al

; 11421: }

	ret	0
?SK_ImGui_WantMouseWarpFiltering@@YA_NXZ ENDP		; SK_ImGui_WantMouseWarpFiltering
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?SK_Input_RememberPressedKeys@@YAXXZ PROC		; SK_Input_RememberPressedKeys

; 11380: {

	npad	2
	push	esi

; 11381:   for (int i = 7; i < 256; i++)

	mov	esi, 7
	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	edx, 6
	lea	ecx, DWORD PTR [eax+229]
$LL4@SK_Input_R:

; 11382:   {
; 11383:     SK_ImGui_ActivationKeys [i] += ImGui::GetIO ().KeysDown [i] ? 6 : 0;

	xor	eax, eax
	cmp	BYTE PTR [ecx+esi], al
	cmovne	eax, edx
	add	DWORD PTR ?SK_ImGui_ActivationKeys@@3PAHA[esi*4], eax
	inc	esi
	cmp	esi, 256				; 00000100H
	jl	SHORT $LL4@SK_Input_R
	pop	esi

; 11384:   }
; 11385: }

	ret	0
?SK_Input_RememberPressedKeys@@YAXXZ ENDP		; SK_Input_RememberPressedKeys
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
;	COMDAT ??0<lambda_0ae521ef5a0d84f91f4c9393d2278f3e>@@QAE@AAHAA_N1@Z
_TEXT	SEGMENT
_<self>$ = 8						; size = 4
_<already_processed>$ = 12				; size = 4
_<foreground>$ = 16					; size = 4
??0<lambda_0ae521ef5a0d84f91f4c9393d2278f3e>@@QAE@AAHAA_N1@Z PROC ; <lambda_0ae521ef5a0d84f91f4c9393d2278f3e>::<lambda_0ae521ef5a0d84f91f4c9393d2278f3e>, COMDAT
; _this$ = ecx

; 11213:       };

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _<self>$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _<already_processed>$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR _<foreground>$[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	pop	ebp
	ret	12					; 0000000cH
??0<lambda_0ae521ef5a0d84f91f4c9393d2278f3e>@@QAE@AAHAA_N1@Z ENDP ; <lambda_0ae521ef5a0d84f91f4c9393d2278f3e>::<lambda_0ae521ef5a0d84f91f4c9393d2278f3e>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\input\input.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\input\input.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\input\input.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
;	COMDAT ??R<lambda_0ae521ef5a0d84f91f4c9393d2278f3e>@@QBE_NIPAUtagRAWINPUT@@AA_N1@Z
_TEXT	SEGMENT
_VKey$1$ = 8						; size = 4
_uiCommand$ = 8						; size = 4
_pData$ = 12						; size = 4
_mouse$ = 16						; size = 4
_keyboard$ = 20						; size = 4
??R<lambda_0ae521ef5a0d84f91f4c9393d2278f3e>@@QBE_NIPAUtagRAWINPUT@@AA_N1@Z PROC ; <lambda_0ae521ef5a0d84f91f4c9393d2278f3e>::operator(), COMDAT
; _this$ = ecx

; 11129:       {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	esi, ecx

; 11130:         bool filter = false;

	xor	bl, bl

; 11131: 
; 11132:         switch (pData->header.dwType)

	mov	ecx, DWORD PTR _pData$[ebp]
	push	edi
	mov	eax, DWORD PTR [ecx]
	sub	eax, 0
	je	$LN4@operator
	sub	eax, 1

; 11198:           } break;
; 11199: 
; 11200: 
; 11201:           default:
; 11202:           {
; 11203:             if ((! self) && uiCommand == RID_INPUT && (! already_processed))

	mov	eax, DWORD PTR [esi]
	je	SHORT $LN9@operator
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN22@operator
	cmp	DWORD PTR _uiCommand$[ebp], 268435459	; 10000003H
	jne	SHORT $LN22@operator
	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax], bl
	jne	SHORT $LN22@operator
; File c:\users\andon\source\repos\specialk\include\specialk\input\input.h

; 103  :   void markRead  (sk_input_dev_type type) { InterlockedIncrement (&last_frame.reads    [ type == sk_input_dev_type::Mouse    ? 0 :

	lock	 inc	 (null) PTR ?SK_RawInput_Backend@@3Usk_input_api_context_s@@A+40
$LN22@operator:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 11207:             if (SK_ImGui_WantGamepadCapture ())

	call	?SK_ImGui_WantGamepadCapture@@YA_NXZ	; SK_ImGui_WantGamepadCapture
	test	al, al
	je	$LN45@operator

; 11208:               filter = true;

	pop	edi
	pop	esi
	mov	al, 1
	pop	ebx

; 11213:       };

	pop	ebp
	ret	16					; 00000010H
$LN9@operator:

; 11150:           } break;
; 11151: 
; 11152: 
; 11153:           case RIM_TYPEKEYBOARD:
; 11154:           {
; 11155:             if ((! self) && uiCommand == RID_INPUT && (! already_processed))

	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN10@operator
	cmp	DWORD PTR _uiCommand$[ebp], 268435459	; 10000003H
	jne	SHORT $LN10@operator
	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN10@operator
; File c:\users\andon\source\repos\specialk\include\specialk\input\input.h

; 103  :   void markRead  (sk_input_dev_type type) { InterlockedIncrement (&last_frame.reads    [ type == sk_input_dev_type::Mouse    ? 0 :

	lock	 inc	 (null) PTR ?SK_RawInput_Backend@@3Usk_input_api_context_s@@A+36
$LN10@operator:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 11159:               (((RAWINPUT *)pData)->data.keyboard.VKey & 0xFF);

	mov	ax, WORD PTR [ecx+22]
	mov	ecx, 255				; 000000ffH
	and	ax, cx
	movzx	eax, ax
	mov	DWORD PTR _VKey$1$[ebp], eax

; 11160: 
; 11161:             if (SK_ImGui_IsMouseRelevant ())

	call	?SK_ImGui_IsMouseRelevant@@YA_NXZ	; SK_ImGui_IsMouseRelevant
	mov	edi, 1
	test	al, al
	je	SHORT $LN17@operator

; 11162:             {
; 11163:               // Only filter keydown message, not key releases
; 11164:               if (SK_ImGui_WantKeyboardCapture ())

	call	?SK_ImGui_WantKeyboardCapture@@YA_NXZ	; SK_ImGui_WantKeyboardCapture
	test	al, al
	je	SHORT $LN13@operator

; 11165:               {
; 11166:                 if (VKey & 0xF8) // Valid Keys:  8 - 255

	test	BYTE PTR _VKey$1$[ebp], 248		; 000000f8H
	movzx	ebx, bl
	cmovne	ebx, edi
$LN13@operator:

; 11167:                   filter = true;
; 11168:               }
; 11169: 
; 11170: 
; 11171:               if (SK_ImGui_WantMouseCapture ())

	call	?SK_ImGui_WantMouseCapture@@YA_NXZ	; SK_ImGui_WantMouseCapture
	test	al, al
	je	SHORT $LN17@operator

; 11172:               {
; 11173:                 // That's actually a mouse button...
; 11174:                 if (foreground && VKey < 7)

	mov	eax, DWORD PTR [esi+8]
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN17@operator
	cmp	WORD PTR _VKey$1$[ebp], 7
	jae	SHORT $LN17@operator

; 11175:                 {
; 11176:                   if (((RAWINPUT *)pData)->data.keyboard.Message == WM_KEYDOWN)

	mov	ecx, DWORD PTR _pData$[ebp]
	movzx	eax, bl
	mov	ecx, DWORD PTR [ecx+24]
	cmp	ecx, 256				; 00000100H
	cmove	eax, edi

; 11177:                     filter = true;
; 11178: 
; 11179:                   if (((RAWINPUT *)pData)->data.keyboard.Message == WM_KEYUP)

	cmp	ecx, 257				; 00000101H
	movzx	ebx, al
	cmove	ebx, edi
$LN17@operator:

; 11180:                     filter = true;
; 11181:                 }
; 11182:               }
; 11183:             }
; 11184: 
; 11185: 
; 11186:             // Block keyboard input to the game while the console is active
; 11187:             if (SK_Console::getInstance ()->isVisible () && (VKey & 0xFF) > 7)

	call	?getInstance@SK_Console@@SAPAV1@XZ	; SK_Console::getInstance
	mov	edx, DWORD PTR _VKey$1$[ebp]
	cmp	BYTE PTR [eax+4356], 0
	je	SHORT $LN18@operator
	cmp	dl, 7
	movzx	ebx, bl
	cmova	ebx, edi
$LN18@operator:

; 11188:               filter = true;
; 11189: 
; 11190: 
; 11191:             // Block keyboard input to the game while it's in the background
; 11192:             if (config.window.background_render && (! game_window.active))

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+744, 0
	je	SHORT $LN19@operator
	cmp	BYTE PTR ?game_window@@3Usk_window_s@@A+17, 0
	movzx	ebx, bl
	cmove	ebx, edi
$LN19@operator:

; 11193:               filter = true;
; 11194: 
; 11195: 
; 11196:             if (VKey & 0xF8) // Valid Keys:  8 - 255

	test	dl, 248					; 000000f8H
	je	SHORT $LN45@operator

; 11197:               keyboard = true;

	mov	eax, DWORD PTR _keyboard$[ebp]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax], 1

; 11209:           } break;
; 11210:         }
; 11211: 
; 11212:         return filter;

	mov	al, bl
	pop	ebx

; 11213:       };

	pop	ebp
	ret	16					; 00000010H
$LN4@operator:

; 11133:         {
; 11134:           case RIM_TYPEMOUSE:
; 11135:           {
; 11136:             if ((! self) && uiCommand == RID_INPUT && (! already_processed))

	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN5@operator
	cmp	DWORD PTR _uiCommand$[ebp], 268435459	; 10000003H
	jne	SHORT $LN5@operator
	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN5@operator
; File c:\users\andon\source\repos\specialk\include\specialk\input\input.h

; 103  :   void markRead  (sk_input_dev_type type) { InterlockedIncrement (&last_frame.reads    [ type == sk_input_dev_type::Mouse    ? 0 :

	lock	 inc	 (null) PTR ?SK_RawInput_Backend@@3Usk_input_api_context_s@@A+32
$LN5@operator:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 11139:             if (SK_ImGui_IsMouseRelevant ())

	call	?SK_ImGui_IsMouseRelevant@@YA_NXZ	; SK_ImGui_IsMouseRelevant
	mov	edi, 1
	test	al, al
	je	SHORT $LN7@operator

; 11140:             {
; 11141:               if ( SK_ImGui_WantMouseCapture () )

	call	?SK_ImGui_WantMouseCapture@@YA_NXZ	; SK_ImGui_WantMouseCapture
	test	al, al
	movzx	ebx, bl
	cmovne	ebx, edi
$LN7@operator:

; 11142:                 filter = true;
; 11143:             }
; 11144: 
; 11145:             // Block mouse input to the game while it's in the background
; 11146:             if (config.window.background_render && (! game_window.active))

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+744, 0
	je	SHORT $LN8@operator
	cmp	BYTE PTR ?game_window@@3Usk_window_s@@A+17, 0
	movzx	ebx, bl
	cmove	ebx, edi
$LN8@operator:

; 11147:               filter = true;
; 11148: 
; 11149:             mouse = true;

	mov	eax, DWORD PTR _mouse$[ebp]
	mov	BYTE PTR [eax], 1
$LN45@operator:

; 11209:           } break;
; 11210:         }
; 11211: 
; 11212:         return filter;

	pop	edi
	pop	esi
	mov	al, bl
	pop	ebx

; 11213:       };

	pop	ebp
	ret	16					; 00000010H
??R<lambda_0ae521ef5a0d84f91f4c9393d2278f3e>@@QBE_NIPAUtagRAWINPUT@@AA_N1@Z ENDP ; <lambda_0ae521ef5a0d84f91f4c9393d2278f3e>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_FilterRawInput$ = -24					; size = 12
_size$1$ = -12						; size = 4
tv543 = -8						; size = 4
_already_processed$ = -2				; size = 1
_foreground$ = -1					; size = 1
_hRawInput$ = 8						; size = 4
_owns_data$1$ = 11					; size = 1
_uiCommand$ = 12					; size = 4
_filter$1$ = 15						; size = 1
_pData$ = 16						; size = 4
_mouse$ = 19						; size = 1
_pcbSize$ = 20						; size = 4
_cbSizeHeader$ = 24					; size = 4
_keyboard$ = 27						; size = 1
_self$ = 28						; size = 4
?SK_ImGui_ProcessRawInput@@YGIPAUHRAWINPUT__@@IPAXPAIIH@Z PROC ; SK_ImGui_ProcessRawInput

; 11067: {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 11068:   HWND hWndActive =
; 11069:     GetActiveWindow ();

	call	DWORD PTR __imp__GetActiveWindow@0

; 11070: 
; 11071:   if ( ( hWndActive != nullptr && hWndActive != game_window.hWnd ) )

	test	eax, eax
	je	SHORT $LN4@SK_ImGui_P
	cmp	eax, DWORD PTR ?game_window@@3Usk_window_s@@A+4
	je	SHORT $LN4@SK_ImGui_P

; 11072:     return GetRawInputData_Original (hRawInput, uiCommand, pData, pcbSize, cbSizeHeader);

	push	DWORD PTR _cbSizeHeader$[ebp]
	push	DWORD PTR _pcbSize$[ebp]
	push	DWORD PTR _pData$[ebp]
	push	DWORD PTR _uiCommand$[ebp]
	push	DWORD PTR _hRawInput$[ebp]
	call	DWORD PTR ?GetRawInputData_Original@@3P6GIPAUHRAWINPUT__@@IPAXPAII@ZA ; GetRawInputData_Original

; 11375: }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$LN4@SK_ImGui_P:

; 11073: 
; 11074: 
; 11075:   static HRAWINPUT last_input = nullptr;
; 11076: 
; 11077:   bool already_processed = (last_input == hRawInput);
; 11078:        last_input        =  (! self) ? hRawInput : nullptr;

	mov	ecx, DWORD PTR _self$[ebp]
	push	esi
	mov	esi, DWORD PTR _hRawInput$[ebp]
	cmp	DWORD PTR ?last_input@?1??SK_ImGui_ProcessRawInput@@YGIPAUHRAWINPUT__@@IPAXPAIIH@Z@4PAU2@A, esi
	sete	dl
	xor	eax, eax
	test	ecx, ecx
	mov	BYTE PTR _already_processed$[ebp], dl
	cmove	eax, esi
	mov	DWORD PTR ?last_input@?1??SK_ImGui_ProcessRawInput@@YGIPAUHRAWINPUT__@@IPAXPAIIH@Z@4PAU2@A, eax

; 11079: 
; 11080: 
; 11081:   if (self && (! already_processed))

	je	SHORT $LN7@SK_ImGui_P
	test	dl, dl
	jne	SHORT $LN7@SK_ImGui_P

; 11082:   {
; 11083:     if (SK_ImGui_WantMouseCapture ())

	call	?SK_ImGui_WantMouseCapture@@YA_NXZ	; SK_ImGui_WantMouseCapture
	test	al, al
	je	SHORT $LN6@SK_ImGui_P

; 11084:       SK_RawInput_EnableLegacyMouse  (true);

	push	1
	call	?SK_RawInput_EnableLegacyMouse@@YA_N_N@Z ; SK_RawInput_EnableLegacyMouse
	add	esp, 4

; 11085:     else

	jmp	SHORT $LN7@SK_ImGui_P
$LN6@SK_ImGui_P:

; 11086:       SK_RawInput_RestoreLegacyMouse ();

	call	?SK_RawInput_RestoreLegacyMouse@@YAXXZ	; SK_RawInput_RestoreLegacyMouse
$LN7@SK_ImGui_P:
	push	ebx
	push	edi

; 11087:   }
; 11088:   
; 11089:   // Keep this on ALWAYS to fix Steam Overlay in Skyrim SE
; 11090:   //
; 11091:   //if (SK_ImGui_WantKeyboardCapture ())
; 11092:     SK_RawInput_EnableLegacyKeyboard (true);

	push	1
	call	?SK_RawInput_EnableLegacyKeyboard@@YA_N_N@Z ; SK_RawInput_EnableLegacyKeyboard

; 11093:   //else
; 11094:   //  SK_RawInput_RestoreLegacyKeyboard ();
; 11095: 
; 11096: 
; 11097:   bool owns_data = false;
; 11098: 
; 11099:   if (pData == nullptr)

	mov	edi, DWORD PTR _pData$[ebp]
	add	esp, 4
	mov	ecx, DWORD PTR _cbSizeHeader$[ebp]
	mov	eax, DWORD PTR _uiCommand$[ebp]

; 11100:   {
; 11101:     GetRawInputData_Original (hRawInput, uiCommand, pData, pcbSize, cbSizeHeader);

	mov	ebx, DWORD PTR _pcbSize$[ebp]
	mov	BYTE PTR _owns_data$1$[ebp], 0
	test	edi, edi
	jne	SHORT $LN11@SK_ImGui_P
	push	ecx
	push	ebx
	push	0
	push	eax
	push	esi
	call	DWORD PTR ?GetRawInputData_Original@@3P6GIPAUHRAWINPUT__@@IPAXPAII@ZA ; GetRawInputData_Original

; 11102: 
; 11103:     if (*pcbSize < 1024)

	mov	eax, DWORD PTR [ebx]
	cmp	eax, 1024				; 00000400H
	jae	$LN10@SK_ImGui_P

; 11104:       pData = new uint8_t [*pcbSize];

	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	mov	edi, eax
	add	esp, 4

; 11105: 
; 11106:     if (pData != nullptr)

	test	edi, edi
	je	$LN10@SK_ImGui_P

; 11107:       owns_data = true;
; 11108: 
; 11109:     else

	mov	eax, DWORD PTR _uiCommand$[ebp]
	mov	ecx, DWORD PTR _cbSizeHeader$[ebp]
	mov	BYTE PTR _owns_data$1$[ebp], 1
$LN11@SK_ImGui_P:

; 11111:   }
; 11112: 
; 11113: 
; 11114:   int size =
; 11115:     GetRawInputData_Original (hRawInput, uiCommand, pData, pcbSize, cbSizeHeader);

	push	ecx
	push	ebx
	push	edi
	push	eax
	push	esi
	call	DWORD PTR ?GetRawInputData_Original@@3P6GIPAUHRAWINPUT__@@IPAXPAII@ZA ; GetRawInputData_Original

; 11119:   bool keyboard = false;
; 11120: 
; 11121:   // Input event happened while the window had focus if true, otherwise aanother
; 11122:   //   window is currently capturing input and the most appropriate response is
; 11123:   //     usually to ignore the event.
; 11124:   bool foreground = GET_RAWINPUT_CODE_WPARAM (((RAWINPUT *)pData)->header.wParam) == RIM_INPUT;

	cmp	BYTE PTR [edi+12], 0

; 11214: 
; 11215:   filter = FilterRawInput (uiCommand, (RAWINPUT *)pData, mouse, keyboard);

	lea	ecx, DWORD PTR _FilterRawInput$[ebp]
	mov	esi, DWORD PTR _uiCommand$[ebp]
	mov	DWORD PTR _size$1$[ebp], eax
	sete	BYTE PTR _foreground$[ebp]

; 11213:       };

	lea	eax, DWORD PTR _self$[ebp]

; 11116: 
; 11117:   bool filter   = false;
; 11118:   bool mouse    = false;

	mov	BYTE PTR _mouse$[ebp], 0

; 11213:       };

	mov	DWORD PTR _FilterRawInput$[ebp], eax
	lea	eax, DWORD PTR _already_processed$[ebp]
	mov	DWORD PTR _FilterRawInput$[ebp+4], eax
	lea	eax, DWORD PTR _foreground$[ebp]
	mov	DWORD PTR _FilterRawInput$[ebp+8], eax

; 11214: 
; 11215:   filter = FilterRawInput (uiCommand, (RAWINPUT *)pData, mouse, keyboard);

	lea	eax, DWORD PTR _keyboard$[ebp]
	push	eax
	lea	eax, DWORD PTR _mouse$[ebp]
	mov	BYTE PTR _keyboard$[ebp], 0
	push	eax
	push	edi
	push	esi
	call	??R<lambda_0ae521ef5a0d84f91f4c9393d2278f3e>@@QBE_NIPAUtagRAWINPUT@@AA_N1@Z ; <lambda_0ae521ef5a0d84f91f4c9393d2278f3e>::operator()
	mov	BYTE PTR _filter$1$[ebp], al

; 11216: 
; 11217:   if (uiCommand == RID_INPUT /*&& SK_ImGui_Visible*/)

	cmp	esi, 268435459				; 10000003H
	jne	$LN22@SK_ImGui_P

; 11218:   {
; 11219:     switch (((RAWINPUT *)pData)->header.dwType)

	mov	ecx, DWORD PTR [edi]
	sub	ecx, 0
	je	$LN13@SK_ImGui_P
	sub	ecx, 1
	jne	$LN22@SK_ImGui_P

; 11259:         }
; 11260:       } break;
; 11261: 
; 11262: 
; 11263:       case RIM_TYPEKEYBOARD:
; 11264:       {
; 11265:         USHORT VKey =
; 11266:           ((RAWINPUT *)pData)->data.keyboard.VKey;

	movzx	ebx, WORD PTR [edi+22]

; 11267: 
; 11268:         // VKeys 0-7 aren't on the keyboard :)
; 11269:         if (VKey & 0xFFF8) // Valid Keys:  8 - 65535

	test	ebx, 65528				; 0000fff8H
	je	$LN22@SK_ImGui_P

; 11270:         {
; 11271:           if (! (((RAWINPUT *)pData)->data.keyboard.Flags & RI_KEY_BREAK))

	test	BYTE PTR [edi+18], 1
	jne	SHORT $LN54@SK_ImGui_P

; 11272:           {
; 11273:             if (foreground)

	cmp	BYTE PTR _foreground$[ebp], cl
	je	SHORT $LN54@SK_ImGui_P

; 11274:               ImGui::GetIO ().KeysDown [VKey & 0xFF] = true;

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	movzx	ecx, bl
	mov	BYTE PTR [eax+ecx+229], 1
$LN54@SK_ImGui_P:

; 11275:           }
; 11276: 
; 11277:           if ( ((RAWINPUT *)pData)->data.keyboard.Message == WM_KEYDOWN)

	cmp	DWORD PTR [edi+24], 256			; 00000100H
	jne	SHORT $LN28@SK_ImGui_P

; 11278:           {
; 11279:             if (foreground && (! self))

	cmp	BYTE PTR _foreground$[ebp], 0
	je	$LN22@SK_ImGui_P
	cmp	DWORD PTR _self$[ebp], 0
	jne	SHORT $LN28@SK_ImGui_P

; 11280:               ImGui::GetIO ().KeysDown [VKey & 0xFF] = true;

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	movzx	ecx, bl
	mov	BYTE PTR [eax+ecx+229], 1
$LN28@SK_ImGui_P:

; 11281:           }
; 11282: 
; 11283:           if (foreground)

	cmp	BYTE PTR _foreground$[ebp], 0
	je	$LN22@SK_ImGui_P

; 11284:           {
; 11285:             if ( ((RAWINPUT *)pData)->data.keyboard.Message == WM_CHAR)

	cmp	DWORD PTR [edi+24], 258			; 00000102H
	jne	$LN22@SK_ImGui_P

; 11286:               ImGui::GetIO ().AddInputCharacter (VKey);

	push	ebx
	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	ecx, eax
	call	?AddInputCharacter@ImGuiIO@@QAEXG@Z	; ImGuiIO::AddInputCharacter

; 11287:           }
; 11288:         }
; 11289:       } break;

	jmp	$LN22@SK_ImGui_P
$LN10@SK_ImGui_P:
	pop	edi
	pop	ebx

; 11110:       return 0;

	xor	eax, eax
	pop	esi

; 11375: }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$LN13@SK_ImGui_P:

; 11220:     {
; 11221:       case RIM_TYPEMOUSE:
; 11222:       {
; 11223:         if (self)

	cmp	DWORD PTR _self$[ebp], 0
	je	$LN22@SK_ImGui_P

; 11224:         {
; 11225:           if (SK_ImGui_IsMouseRelevant () && config.input.mouse.add_relative_motion)

	call	?SK_ImGui_IsMouseRelevant@@YA_NXZ	; SK_ImGui_IsMouseRelevant
	test	al, al
	je	SHORT $LN15@SK_ImGui_P
	cmp	BYTE PTR ?config@@3Usk_config_t@@A+713, 0
	je	SHORT $LN15@SK_ImGui_P

; 11226:           {
; 11227:             // 99% of games don't need this, and if we use relative motion to update the cursor position that
; 11228:             //   requires re-synchronizing with the desktop's logical cursor coordinates at some point because
; 11229:             //     Raw Input does not include cursor accelleration, etc.
; 11230:             POINT client { ((RAWINPUT *)pData)->data.mouse.lLastX, ((RAWINPUT *)pData)->data.mouse.lLastY };
; 11231: 
; 11232:             ////SK_ImGui_Cursor.ClientToLocal (&client);
; 11233: 
; 11234:             SK_ImGui_Cursor.pos.x += client.x;

	mov	esi, DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+20
	mov	eax, DWORD PTR [edi+32]
	add	esi, DWORD PTR [edi+28]

; 11235:             SK_ImGui_Cursor.pos.y += client.y;

	add	DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+24, eax
	mov	DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+20, esi

; 11236:             
; 11237:             ImGui::GetIO ().MousePos.x = (float)SK_ImGui_Cursor.pos.x;

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	movd	xmm0, esi
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [eax+204], xmm0
	movd	xmm0, DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+24

; 11238:             ImGui::GetIO ().MousePos.y = (float)SK_ImGui_Cursor.pos.y;

	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR tv543[ebp], xmm0
	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	movss	xmm0, DWORD PTR tv543[ebp]

; 11239: 
; 11240:             SK_ImGui_Cursor.update ();

	mov	ecx, OFFSET ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A ; SK_ImGui_Cursor
	movss	DWORD PTR [eax+208], xmm0
	call	?update@sk_imgui_cursor_s@@QAEXXZ	; sk_imgui_cursor_s::update
$LN15@SK_ImGui_P:

; 11241:           }
; 11242: 
; 11243:           if (foreground)

	cmp	BYTE PTR _foreground$[ebp], 0
	je	SHORT $LN21@SK_ImGui_P

; 11244:           {
; 11245:             if ( ((RAWINPUT *)pData)->data.mouse.ulButtons & RI_MOUSE_LEFT_BUTTON_DOWN   )

	test	BYTE PTR [edi+20], 1
	je	SHORT $LN17@SK_ImGui_P

; 11246:               ImGui::GetIO ().MouseDown [0] = true;

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	BYTE PTR [eax+212], 1
$LN17@SK_ImGui_P:

; 11247:             if ( ((RAWINPUT *)pData)->data.mouse.ulButtons & RI_MOUSE_RIGHT_BUTTON_DOWN  )

	test	BYTE PTR [edi+20], 4
	je	SHORT $LN18@SK_ImGui_P

; 11248:               ImGui::GetIO ().MouseDown [1] = true;

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	BYTE PTR [eax+213], 1
$LN18@SK_ImGui_P:

; 11249:             if ( ((RAWINPUT *)pData)->data.mouse.ulButtons & RI_MOUSE_MIDDLE_BUTTON_DOWN )

	test	BYTE PTR [edi+20], 16			; 00000010H
	je	SHORT $LN19@SK_ImGui_P

; 11250:               ImGui::GetIO ().MouseDown [2] = true;

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	BYTE PTR [eax+214], 1
$LN19@SK_ImGui_P:

; 11251:             if ( ((RAWINPUT *)pData)->data.mouse.ulButtons & RI_MOUSE_BUTTON_4_DOWN      )

	test	BYTE PTR [edi+20], 64			; 00000040H
	je	SHORT $LN20@SK_ImGui_P

; 11252:               ImGui::GetIO ().MouseDown [3] = true;

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	BYTE PTR [eax+215], 1
$LN20@SK_ImGui_P:

; 11253:             if ( ((RAWINPUT *)pData)->data.mouse.ulButtons & RI_MOUSE_BUTTON_5_DOWN      )

	test	DWORD PTR [edi+20], 256			; 00000100H
	je	SHORT $LN21@SK_ImGui_P

; 11254:               ImGui::GetIO ().MouseDown [4] = true;

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	BYTE PTR [eax+216], 1
$LN21@SK_ImGui_P:

; 11255:           }
; 11256: 
; 11257:           if ( ((RAWINPUT *)pData)->data.mouse.usButtonFlags == RI_MOUSE_WHEEL       )

	mov	eax, 1024				; 00000400H
	cmp	WORD PTR [edi+20], ax
	jne	SHORT $LN22@SK_ImGui_P

; 11258:             ImGui::GetIO ().MouseWheel += ((short)((RAWINPUT *)pData)->data.mouse.usButtonData);

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	lea	ecx, DWORD PTR [eax+220]
	movsx	eax, WORD PTR [edi+22]
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	addss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [ecx], xmm0
$LN22@SK_ImGui_P:

; 11290: 
; 11291: 
; 11292:       default:
; 11293:         break;
; 11294:     }
; 11295:   }
; 11296: 
; 11297:   if (filter || keyboard)

	mov	bh, BYTE PTR _filter$1$[ebp]
	mov	bl, BYTE PTR _keyboard$[ebp]
	test	bh, bh
	jne	SHORT $LN33@SK_ImGui_P
	test	bl, bl
	jne	SHORT $LN52@SK_ImGui_P
	mov	ebx, DWORD PTR _size$1$[ebp]
$LN32@SK_ImGui_P:

; 11369:   }
; 11370: 
; 11371:   if (owns_data)

	mov	al, BYTE PTR _owns_data$1$[ebp]
	test	al, al
	je	SHORT $LN45@SK_ImGui_P

; 11372:     delete [] pData;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	al, BYTE PTR _owns_data$1$[ebp]
	add	esp, 4
$LN45@SK_ImGui_P:

; 11373: 
; 11374:   return owns_data ? 0 : size;

	xor	ecx, ecx
	test	al, al
	pop	edi
	cmovne	ebx, ecx
	mov	eax, ebx
	pop	ebx
	pop	esi

; 11375: }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$LN33@SK_ImGui_P:

; 11298:   {
; 11299:     // Clearing all bytes above would have set the type to mouse, and some games
; 11300:     //   will actually read data coming from RawInput even when the size returned is 0!
; 11301:     ((RAWINPUT *)pData)->header.dwType = keyboard ? RIM_TYPEKEYBOARD      :

	test	bl, bl
	je	SHORT $LN47@SK_ImGui_P
$LN52@SK_ImGui_P:
	mov	eax, 1
	jmp	SHORT $LN48@SK_ImGui_P
$LN47@SK_ImGui_P:
	xor	ecx, ecx
	mov	eax, 2
	cmp	BYTE PTR _mouse$[ebp], cl
	cmovne	eax, ecx
$LN48@SK_ImGui_P:

; 11302:                                                     mouse ? RIM_TYPEMOUSE :
; 11303:                                                             RIM_TYPEHID;
; 11304: 
; 11305:     if (! owns_data)

	cmp	BYTE PTR _owns_data$1$[ebp], 0

; 11308:       {
; 11309:         memset (pData, 0, *pcbSize);

	mov	esi, DWORD PTR _pcbSize$[ebp]
	mov	DWORD PTR [edi], eax
	jne	$LN44@SK_ImGui_P

; 11306:     {
; 11307:       if (! keyboard)

	test	bl, bl
	jne	SHORT $LN35@SK_ImGui_P

; 11308:       {
; 11309:         memset (pData, 0, *pcbSize);

	push	DWORD PTR [esi]
	push	0
	push	edi
	call	_memset
	add	esp, 12					; 0000000cH
$LN35@SK_ImGui_P:

; 11310:       }
; 11311: 
; 11312:       // Tell the game this event happened in the background, most will
; 11313:       //   throw it out quick and easy. Even easier if we tell it the event came
; 11314:       //     from the keyboard.
; 11315:       if (filter)

	test	bh, bh
	je	SHORT $LN36@SK_ImGui_P

; 11316:       {
; 11317:         ((RAWINPUT *)pData)->header.wParam = RIM_INPUTSINK;
; 11318:         ((RAWINPUT *)pData)->header.dwType = RIM_TYPEKEYBOARD;
; 11319: 
; 11320:         // Fake key release
; 11321:         ((RAWINPUT *)pData)->data.keyboard.Flags |= RI_KEY_BREAK;

	or	WORD PTR [edi+18], 1
	mov	DWORD PTR [edi+12], 1
	mov	DWORD PTR [edi], 1
$LN36@SK_ImGui_P:

; 11322:       }
; 11323: 
; 11324:       // Ugh, why does everything have to be so complicated? :P
; 11325:       //
; 11326:       //   This horrible nightmare prevents games from seeing keys as stuck after
; 11327:       //     activating the ImGui overlay.
; 11328:       //
; 11329:       if (keyboard)

	test	bl, bl
	je	SHORT $LN51@SK_ImGui_P

; 11330:       {
; 11331:         bool release = (((RAWINPUT *)pData)->data.keyboard.Flags & RI_KEY_BREAK) != 0;

	mov	bl, BYTE PTR [edi+18]
	and	bl, 1

; 11332:         bool erase   = SK_ImGui_WantKeyboardCapture ();

	call	?SK_ImGui_WantKeyboardCapture@@YA_NXZ	; SK_ImGui_WantKeyboardCapture

; 11333:         bool invert  = false;
; 11334: 
; 11335:         USHORT VKey =
; 11336:           ( (RAWINPUT *)pData )->data.keyboard.VKey & 0xFF;

	mov	cx, WORD PTR [edi+22]
	mov	edx, 255				; 000000ffH
	and	cx, dx
	movzx	ecx, cx

; 11337: 
; 11338:         if (erase)

	test	al, al
	je	SHORT $LN44@SK_ImGui_P

; 11339:         {
; 11340:           if ((! release) && SK_ImGui_ActivationKeys [VKey] > 0)

	test	bl, bl
	jne	SHORT $LN44@SK_ImGui_P
	mov	eax, DWORD PTR ?SK_ImGui_ActivationKeys@@3PAHA[ecx*4]
	test	eax, eax
	jle	SHORT $LN44@SK_ImGui_P

; 11341:           {
; 11342:             SK_ImGui_ActivationKeys [VKey]--;

	dec	eax
	mov	DWORD PTR ?SK_ImGui_ActivationKeys@@3PAHA[ecx*4], eax

; 11343:             invert = true;
; 11344:           }
; 11345: 
; 11346:           if (invert)
; 11347:           {
; 11348:             // We WANT the game to know about this event, don't sink it.
; 11349:             ((RAWINPUT *)pData)->header.wParam = RIM_INPUT;
; 11350:             ((RAWINPUT *)pData)->header.dwType = RIM_TYPEKEYBOARD;
; 11351: 
; 11352:             // Fake key release
; 11353:             ((RAWINPUT *)pData)->data.keyboard.Flags |= RI_KEY_BREAK;

	or	WORD PTR [edi+18], 1

; 11354: 
; 11355:             if (((RAWINPUT *)pData)->data.keyboard.Message      == WM_KEYDOWN)

	mov	eax, DWORD PTR [edi+24]
	mov	DWORD PTR [edi+12], 0
	mov	DWORD PTR [edi], 1
	cmp	eax, 256				; 00000100H
	jne	SHORT $LN41@SK_ImGui_P

; 11356:               ((RAWINPUT *)pData)->data.keyboard.Message = WM_KEYUP;

	mov	DWORD PTR [edi+24], 257			; 00000101H

; 11366:     }
; 11367: 
; 11368:     size = *pcbSize;

	mov	ebx, DWORD PTR [esi]
	jmp	$LN32@SK_ImGui_P
$LN41@SK_ImGui_P:

; 11357: 
; 11358:             else if (((RAWINPUT *)pData)->data.keyboard.Message == WM_SYSKEYDOWN)

	cmp	eax, 260				; 00000104H
	jne	SHORT $LN44@SK_ImGui_P

; 11359:               ((RAWINPUT *)pData)->data.keyboard.Message = WM_SYSKEYUP;

	mov	DWORD PTR [edi+24], 261			; 00000105H

; 11366:     }
; 11367: 
; 11368:     size = *pcbSize;

	mov	ebx, DWORD PTR [esi]
	jmp	$LN32@SK_ImGui_P
$LN51@SK_ImGui_P:

; 11360:           }
; 11361:         }
; 11362:       }
; 11363: 
; 11364:       if (! keyboard)
; 11365:         *pcbSize = 0;

	mov	DWORD PTR [esi], 0
$LN44@SK_ImGui_P:

; 11366:     }
; 11367: 
; 11368:     size = *pcbSize;

	mov	ebx, DWORD PTR [esi]
	jmp	$LN32@SK_ImGui_P
?SK_ImGui_ProcessRawInput@@YGIPAUHRAWINPUT__@@IPAXPAIIH@Z ENDP ; SK_ImGui_ProcessRawInput
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
;	COMDAT ??R<lambda_7a12fd051827e0f33bd65ef841f2c8b8>@@QBEPAUImFont@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MPBGPAUImFontConfig@@@Z
_TEXT	SEGMENT
_szFullPath$ = -560					; size = 521
$T2 = -36						; size = 24
__$EHRec$ = -12						; size = 12
_filename$ = 8						; size = 24
_point_size$ = 32					; size = 4
_glyph_range$ = 36					; size = 4
_cfg$ = 40						; size = 4
??R<lambda_7a12fd051827e0f33bd65ef841f2c8b8>@@QBEPAUImFont@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MPBGPAUImFontConfig@@@Z PROC ; <lambda_7a12fd051827e0f33bd65ef841f2c8b8>::operator(), COMDAT
; _this$ = ecx

; 10996:     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??R<lambda_7a12fd051827e0f33bd65ef841f2c8b8>@@QBEPAUImFont@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MPBGPAUImFontConfig@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 548				; 00000224H
	push	esi

; 10997:       char szFullPath [ MAX_PATH * 2 + 1 ] = { };

	push	521					; 00000209H
	lea	eax, DWORD PTR _szFullPath$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	push	eax
	call	_memset

; 10999:       if (GetFileAttributesA (filename.c_str ()) != INVALID_FILE_ATTRIBUTES)

	mov	esi, DWORD PTR __imp__GetFileAttributesA@4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	lea	eax, DWORD PTR _filename$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10997:       char szFullPath [ MAX_PATH * 2 + 1 ] = { };

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR _filename$[ebp+20], 16	; 00000010H

; 1621 : 		return (_Large_string_engaged()

	cmovae	eax, DWORD PTR _filename$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10999:       if (GetFileAttributesA (filename.c_str ()) != INVALID_FILE_ATTRIBUTES)

	push	eax
	call	esi
	cmp	eax, -1
	je	SHORT $LN2@operator
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR _filename$[ebp+20], 16	; 00000010H

; 1621 : 		return (_Large_string_engaged()

	lea	eax, DWORD PTR _filename$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 11000:         strncpy (szFullPath, filename.c_str (), MAX_PATH * 2);

	push	520					; 00000208H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	cmovae	eax, DWORD PTR _filename$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 11000:         strncpy (szFullPath, filename.c_str (), MAX_PATH * 2);

	push	eax
	lea	eax, DWORD PTR _szFullPath$[ebp]
	push	eax
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH
$LN4@operator:

; 11009:       }
; 11010: 
; 11011:       if (*szFullPath != '\0')

	cmp	BYTE PTR _szFullPath$[ebp], 0
	je	$LN5@operator

; 11012:       {
; 11013:         ImGuiIO& io =

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO

; 11014:           ImGui::GetIO ();
; 11015: 
; 11016:         return

	push	DWORD PTR _glyph_range$[ebp]
	movss	xmm0, DWORD PTR _point_size$[ebp]
	push	DWORD PTR _cfg$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _szFullPath$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ecx
	mov	ecx, DWORD PTR [eax+128]
	call	?AddFontFromFileTTF@ImFontAtlas@@QAEPAUImFont@@PBDMPBUImFontConfig@@PBG@Z ; ImFontAtlas::AddFontFromFileTTF
	mov	esi, eax
	jmp	SHORT $LN9@operator
$LN2@operator:

; 11004:         snprintf (szFullPath, MAX_PATH * 2, R"(%ws\%s)", SK_GetFontsDir ().c_str (), filename.c_str ());

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?SK_GetFontsDir@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; SK_GetFontsDir
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1621 : 		return (_Large_string_engaged()

	lea	ecx, DWORD PTR _filename$[ebp]

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR _filename$[ebp+20], 16	; 00000010H

; 1621 : 		return (_Large_string_engaged()

	cmovae	ecx, DWORD PTR _filename$[ebp]

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [eax+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN80@operator
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN80@operator:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 11004:         snprintf (szFullPath, MAX_PATH * 2, R"(%ws\%s)", SK_GetFontsDir ().c_str (), filename.c_str ());

	push	ecx
	push	eax
	push	OFFSET ??_C@_06OMAMIPPI@?$CFws?2?$CFs?$AA@
	lea	eax, DWORD PTR _szFullPath$[ebp]
	push	520					; 00000208H
	push	eax
	call	_snprintf
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR $T2[ebp+20]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 11004:         snprintf (szFullPath, MAX_PATH * 2, R"(%ws\%s)", SK_GetFontsDir ().c_str (), filename.c_str ());

	add	esp, 20					; 00000014H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN90@operator
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T2[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN90@operator:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 11007:         if (GetFileAttributesA (szFullPath) == INVALID_FILE_ATTRIBUTES)

	lea	eax, DWORD PTR _szFullPath$[ebp]
	push	eax
	call	esi
	cmp	eax, -1
	jne	$LN4@operator

; 11008:           *szFullPath = '\0';

	mov	BYTE PTR _szFullPath$[ebp], 0
$LN5@operator:

; 11017:           io.Fonts->AddFontFromFileTTF ( szFullPath, 
; 11018:                                            point_size,
; 11019:                                              cfg,
; 11020:                                                glyph_range );
; 11021:       }
; 11022: 
; 11023:       return (ImFont *)nullptr;

	xor	esi, esi
$LN9@operator:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR _filename$[ebp+20]
	cmp	eax, 16					; 00000010H

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN146@operator
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR _filename$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN146@operator:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 11024:     };

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??R<lambda_7a12fd051827e0f33bd65ef841f2c8b8>@@QBEPAUImFont@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MPBGPAUImFontConfig@@@Z$0:
	lea	ecx, DWORD PTR _filename$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??R<lambda_7a12fd051827e0f33bd65ef841f2c8b8>@@QBEPAUImFont@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MPBGPAUImFontConfig@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??R<lambda_7a12fd051827e0f33bd65ef841f2c8b8>@@QBEPAUImFont@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MPBGPAUImFontConfig@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??R<lambda_7a12fd051827e0f33bd65ef841f2c8b8>@@QBEPAUImFont@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MPBGPAUImFontConfig@@@Z ENDP ; <lambda_7a12fd051827e0f33bd65ef841f2c8b8>::operator()
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\mutex
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\mutex
;	COMDAT ??1?$lock_guard@VSK_Thread_CriticalSection@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$lock_guard@VSK_Thread_CriticalSection@@@std@@QAE@XZ PROC ; std::lock_guard<SK_Thread_CriticalSection>::~lock_guard<SK_Thread_CriticalSection>, COMDAT
; _this$ = ecx
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h

; 248  :     LeaveCriticalSection (cs_);

	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp__LeaveCriticalSection@4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\mutex

; 230  : 		}

	ret	0
??1?$lock_guard@VSK_Thread_CriticalSection@@@std@@QAE@XZ ENDP ; std::lock_guard<SK_Thread_CriticalSection>::~lock_guard<SK_Thread_CriticalSection>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\mutex
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\mutex
;	COMDAT ??0?$lock_guard@VSK_Thread_CriticalSection@@@std@@QAE@AAVSK_Thread_CriticalSection@@@Z
_TEXT	SEGMENT
__Mtx$ = 8						; size = 4
??0?$lock_guard@VSK_Thread_CriticalSection@@@std@@QAE@AAVSK_Thread_CriticalSection@@@Z PROC ; std::lock_guard<SK_Thread_CriticalSection>::lock_guard<SK_Thread_CriticalSection>, COMDAT
; _this$ = ecx

; 218  : 		{	// construct and lock

	npad	2
	push	ebp
	mov	ebp, esp

; 217  : 		: _MyMutex(_Mtx)

	mov	eax, DWORD PTR __Mtx$[ebp]
	push	esi

; 218  : 		{	// construct and lock

	mov	esi, ecx
	mov	DWORD PTR [esi], eax
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h

; 243  :     EnterCriticalSection (cs_);

	push	DWORD PTR [eax]
	call	DWORD PTR __imp__EnterCriticalSection@4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\mutex

; 220  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$lock_guard@VSK_Thread_CriticalSection@@@std@@QAE@AAVSK_Thread_CriticalSection@@@Z ENDP ; std::lock_guard<SK_Thread_CriticalSection>::lock_guard<SK_Thread_CriticalSection>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\mutex
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_font_cfg$2 = -108					; size = 84
_cs_load_font$ = -20					; size = 4
_LoadFont$3 = -13					; size = 1
__$EHRec$ = -12						; size = 12
?SK_ImGui_LoadFonts@@YAXXZ PROC				; SK_ImGui_LoadFonts

; 10982: {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SK_ImGui_LoadFonts@@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 96					; 00000060H
	push	esi
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h

; 243  :     EnterCriticalSection (cs_);

	push	DWORD PTR ?font_lock@@3VSK_Thread_HybridSpinlock@@A ; font_lock
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\mutex

; 217  : 		: _MyMutex(_Mtx)

	mov	DWORD PTR _cs_load_font$[ebp], OFFSET ?font_lock@@3VSK_Thread_HybridSpinlock@@A ; font_lock
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h

; 243  :     EnterCriticalSection (cs_);

	call	DWORD PTR __imp__EnterCriticalSection@4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10983:   std::lock_guard <SK_Thread_CriticalSection> cs_load_font (font_lock);

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h

; 9003 :     return (unsigned long) _InterlockedCompareExchange((volatile long*) Destination, (long) Exchange, (long) Comperand);

	mov	ecx, 1
	mov	edx, OFFSET ?init@?1??SK_ImGui_LoadFonts@@YAXXZ@4KC
	xor	eax, eax
	lock	 cmpxchg DWORD PTR [edx], ecx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10987:   if (! InterlockedCompareExchange (&init, 1, 0))

	test	eax, eax
	jne	$LN2@SK_ImGui_L

; 10988:   {
; 10989:     ImGuiIO& io =

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO

; 10990:       ImGui::GetIO ();
; 10991: 
; 10992:     ImFontConfig font_cfg;

	lea	ecx, DWORD PTR _font_cfg$2[ebp]
	mov	esi, eax
	call	??0ImFontConfig@@QAE@XZ			; ImFontConfig::ImFontConfig

; 11026:     if (! LoadFont (

	push	0
	mov	BYTE PTR _font_cfg$2[ebp+44], 1
	call	?SK_ImGui_GetGlyphRangesDefaultEx@@YAPBGXZ ; SK_ImGui_GetGlyphRangesDefaultEx
	movss	xmm0, DWORD PTR ?config@@3Usk_config_t@@A+252
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	movss	DWORD PTR [esp+24], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2174 : 		assign(_Right, 0, npos);

	push	-1
	push	0

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2174 : 		assign(_Right, 0, npos);

	push	OFFSET ?config@@3Usk_config_t@@A+228
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2174 : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 11026:     if (! LoadFont (

	lea	ecx, DWORD PTR _LoadFont$3[ebp]
	call	??R<lambda_7a12fd051827e0f33bd65ef841f2c8b8>@@QBEPAUImFont@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MPBGPAUImFontConfig@@@Z ; <lambda_7a12fd051827e0f33bd65ef841f2c8b8>::operator()
	test	eax, eax
	jne	SHORT $LN3@SK_ImGui_L

; 11027:             config.imgui.font.default.file,
; 11028:               config.imgui.font.default.size,
; 11029:                 SK_ImGui_GetGlyphRangesDefaultEx () ) )
; 11030:     {
; 11031: 
; 11032:       io.Fonts->AddFontDefault ();

	mov	ecx, DWORD PTR [esi+128]
	push	eax
	call	?AddFontDefault@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z ; ImFontAtlas::AddFontDefault
$LN3@SK_ImGui_L:

; 11035:     LoadFont (config.imgui.font.japanese.file,  config.imgui.font.japanese.size, io.Fonts->GetGlyphRangesJapanese (), &font_cfg);

	mov	ecx, DWORD PTR [esi+128]
	lea	eax, DWORD PTR _font_cfg$2[ebp]
	push	eax
	call	?GetGlyphRangesJapanese@ImFontAtlas@@QAEPBGXZ ; ImFontAtlas::GetGlyphRangesJapanese
	movss	xmm0, DWORD PTR ?config@@3Usk_config_t@@A+280
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	movss	DWORD PTR [esp+24], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2174 : 		assign(_Right, 0, npos);

	push	-1
	push	0

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2174 : 		assign(_Right, 0, npos);

	push	OFFSET ?config@@3Usk_config_t@@A+256
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2174 : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 11035:     LoadFont (config.imgui.font.japanese.file,  config.imgui.font.japanese.size, io.Fonts->GetGlyphRangesJapanese (), &font_cfg);

	lea	ecx, DWORD PTR _LoadFont$3[ebp]
	call	??R<lambda_7a12fd051827e0f33bd65ef841f2c8b8>@@QBEPAUImFont@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MPBGPAUImFontConfig@@@Z ; <lambda_7a12fd051827e0f33bd65ef841f2c8b8>::operator()

; 11036:     LoadFont (config.imgui.font.chinese.file,   config.imgui.font.chinese.size,  io.Fonts->GetGlyphRangesChinese  (), &font_cfg);

	mov	ecx, DWORD PTR [esi+128]
	lea	eax, DWORD PTR _font_cfg$2[ebp]
	push	eax
	call	?GetGlyphRangesChinese@ImFontAtlas@@QAEPBGXZ ; ImFontAtlas::GetGlyphRangesChinese
	movss	xmm0, DWORD PTR ?config@@3Usk_config_t@@A+196
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	movss	DWORD PTR [esp+24], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2174 : 		assign(_Right, 0, npos);

	push	-1
	push	0

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2174 : 		assign(_Right, 0, npos);

	push	OFFSET ?config@@3Usk_config_t@@A+172
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2174 : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 11036:     LoadFont (config.imgui.font.chinese.file,   config.imgui.font.chinese.size,  io.Fonts->GetGlyphRangesChinese  (), &font_cfg);

	lea	ecx, DWORD PTR _LoadFont$3[ebp]
	call	??R<lambda_7a12fd051827e0f33bd65ef841f2c8b8>@@QBEPAUImFont@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MPBGPAUImFontConfig@@@Z ; <lambda_7a12fd051827e0f33bd65ef841f2c8b8>::operator()

; 11038:     LoadFont (config.imgui.font.cyrillic.file,  config.imgui.font.cyrillic.size, io.Fonts->GetGlyphRangesCyrillic (), &font_cfg);

	mov	ecx, DWORD PTR [esi+128]
	lea	eax, DWORD PTR _font_cfg$2[ebp]
	push	eax
	call	?GetGlyphRangesCyrillic@ImFontAtlas@@QAEPBGXZ ; ImFontAtlas::GetGlyphRangesCyrillic
	movss	xmm0, DWORD PTR ?config@@3Usk_config_t@@A+224
	push	eax
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	movss	DWORD PTR [esp+24], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2174 : 		assign(_Right, 0, npos);

	push	-1
	push	0

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2174 : 		assign(_Right, 0, npos);

	push	OFFSET ?config@@3Usk_config_t@@A+200
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2174 : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 11038:     LoadFont (config.imgui.font.cyrillic.file,  config.imgui.font.cyrillic.size, io.Fonts->GetGlyphRangesCyrillic (), &font_cfg);

	lea	ecx, DWORD PTR _LoadFont$3[ebp]
	call	??R<lambda_7a12fd051827e0f33bd65ef841f2c8b8>@@QBEPAUImFont@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MPBGPAUImFontConfig@@@Z ; <lambda_7a12fd051827e0f33bd65ef841f2c8b8>::operator()

; 11039: 
; 11040:     io.Fonts->AddFontDefault ();

	mov	ecx, DWORD PTR [esi+128]
	push	0
	call	?AddFontDefault@ImFontAtlas@@QAEPAUImFont@@PBUImFontConfig@@@Z ; ImFontAtlas::AddFontDefault
$LN2@SK_ImGui_L:
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h

; 248  :     LeaveCriticalSection (cs_);

	push	DWORD PTR ?font_lock@@3VSK_Thread_HybridSpinlock@@A ; font_lock
	call	DWORD PTR __imp__LeaveCriticalSection@4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 11042: }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SK_ImGui_LoadFonts@@YAXXZ$0:
	lea	ecx, DWORD PTR _cs_load_font$[ebp]
	jmp	??1?$lock_guard@VSK_Thread_CriticalSection@@@std@@QAE@XZ ; std::lock_guard<SK_Thread_CriticalSection>::~lock_guard<SK_Thread_CriticalSection>
__ehhandler$?SK_ImGui_LoadFonts@@YAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?SK_ImGui_LoadFonts@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?SK_ImGui_LoadFonts@@YAXXZ ENDP				; SK_ImGui_LoadFonts
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ??__Ffont_lock@@YAXXZ
text$yd	SEGMENT
??__Ffont_lock@@YAXXZ PROC				; `dynamic atexit destructor for 'font_lock'', COMDAT

; 266  :     DeleteCriticalSection (cs_);

	push	DWORD PTR ?font_lock@@3VSK_Thread_HybridSpinlock@@A ; font_lock
	call	DWORD PTR __imp__DeleteCriticalSection@4

; 267  :     delete cs_;

	push	24					; 00000018H
	push	DWORD PTR ?font_lock@@3VSK_Thread_HybridSpinlock@@A ; font_lock
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
??__Ffont_lock@@YAXXZ ENDP				; `dynamic atexit destructor for 'font_lock''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
;	COMDAT ??__Efont_lock@@YAXXZ
text$di	SEGMENT
??__Efont_lock@@YAXXZ PROC				; `dynamic initializer for 'font_lock'', COMDAT
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h

; 259  :                                                      SK_Thread_CriticalSection (new CRITICAL_SECTION)

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 237  :     cs_ = pCS;

	mov	DWORD PTR ?font_lock@@3VSK_Thread_HybridSpinlock@@A, eax ; font_lock

; 261  :     InitializeCriticalSectionAndSpinCount (cs_, spin_count);

	push	300					; 0000012cH
	push	eax
	call	DWORD PTR __imp__InitializeCriticalSectionAndSpinCount@8
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10978: SK_Thread_HybridSpinlock font_lock (300);

	push	OFFSET ??__Ffont_lock@@YAXXZ		; `dynamic atexit destructor for 'font_lock''
	call	_atexit
	pop	ecx
	ret	0
??__Efont_lock@@YAXXZ ENDP				; `dynamic initializer for 'font_lock''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?SK_ImGui_GetGlyphRangesDefaultEx@@YAPBGXZ PROC		; SK_ImGui_GetGlyphRangesDefaultEx

; 10965:   static const ImWchar ranges [] =
; 10966:   {
; 10967:     0x0020, 0x00FF, // Basic Latin + Latin Supplement
; 10968:     0x0100, 0x03FF, // Latin, IPA, Greek
; 10969:     0x2000, 0x206F, // General Punctuation
; 10970:     0x2100, 0x21FF, // Letterlike Symbols
; 10971:     0x2600, 0x26FF, // Misc. Characters
; 10972:     0x2700, 0x27BF, // Dingbats
; 10973:     0
; 10974:   };
; 10975:   return &ranges [0];

	mov	eax, OFFSET ?ranges@?1??SK_ImGui_GetGlyphRangesDefaultEx@@YAPBGXZ@4QBGB

; 10976: }

	ret	0
?SK_ImGui_GetGlyphRangesDefaultEx@@YAPBGXZ ENDP		; SK_ImGui_GetGlyphRangesDefaultEx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ??1SK_Thread_HybridSpinlock@@QAE@XZ
_TEXT	SEGMENT
??1SK_Thread_HybridSpinlock@@QAE@XZ PROC		; SK_Thread_HybridSpinlock::~SK_Thread_HybridSpinlock, COMDAT
; _this$ = ecx

; 265  :   {

	npad	2
	push	esi
	mov	esi, ecx

; 266  :     DeleteCriticalSection (cs_);

	push	DWORD PTR [esi]
	call	DWORD PTR __imp__DeleteCriticalSection@4

; 267  :     delete cs_;

	push	24					; 00000018H
	push	DWORD PTR [esi]
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	pop	esi

; 268  :   }

	ret	0
??1SK_Thread_HybridSpinlock@@QAE@XZ ENDP		; SK_Thread_HybridSpinlock::~SK_Thread_HybridSpinlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ??0SK_Thread_HybridSpinlock@@QAE@H@Z
_TEXT	SEGMENT
_spin_count$ = 8					; size = 4
??0SK_Thread_HybridSpinlock@@QAE@H@Z PROC		; SK_Thread_HybridSpinlock::SK_Thread_HybridSpinlock, COMDAT
; _this$ = ecx

; 260  :   {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 238  :   };
; 239  : 
; 240  :   ~SK_Thread_CriticalSection (void) = default;
; 241  : 
; 242  :   void lock (void) {
; 243  :     EnterCriticalSection (cs_);
; 244  :   }
; 245  : 
; 246  :   void unlock (void)
; 247  :   {
; 248  :     LeaveCriticalSection (cs_);
; 249  :   }
; 250  : 
; 251  : protected:
; 252  :   CRITICAL_SECTION* cs_;
; 253  : };
; 254  : 
; 255  : class SK_Thread_HybridSpinlock : public SK_Thread_CriticalSection
; 256  : {
; 257  : public:
; 258  :   SK_Thread_HybridSpinlock (int spin_count = 3000) :
; 259  :                                                      SK_Thread_CriticalSection (new CRITICAL_SECTION)

	push	24					; 00000018H

; 260  :   {

	mov	esi, ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 237  :     cs_ = pCS;

	mov	DWORD PTR [esi], eax

; 261  :     InitializeCriticalSectionAndSpinCount (cs_, spin_count);

	push	DWORD PTR _spin_count$[ebp]
	push	eax
	call	DWORD PTR __imp__InitializeCriticalSectionAndSpinCount@8

; 262  :   }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0SK_Thread_HybridSpinlock@@QAE@H@Z ENDP		; SK_Thread_HybridSpinlock::SK_Thread_HybridSpinlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ?unlock@SK_Thread_CriticalSection@@QAEXXZ
_TEXT	SEGMENT
?unlock@SK_Thread_CriticalSection@@QAEXXZ PROC		; SK_Thread_CriticalSection::unlock, COMDAT
; _this$ = ecx

; 248  :     LeaveCriticalSection (cs_);

	push	DWORD PTR [ecx]
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 249  :   }

	ret	0
?unlock@SK_Thread_CriticalSection@@QAEXXZ ENDP		; SK_Thread_CriticalSection::unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ?lock@SK_Thread_CriticalSection@@QAEXXZ
_TEXT	SEGMENT
?lock@SK_Thread_CriticalSection@@QAEXXZ PROC		; SK_Thread_CriticalSection::lock, COMDAT
; _this$ = ecx

; 243  :     EnterCriticalSection (cs_);

	push	DWORD PTR [ecx]
	call	DWORD PTR __imp__EnterCriticalSection@4

; 244  :   }

	ret	0
?lock@SK_Thread_CriticalSection@@QAEXXZ ENDP		; SK_Thread_CriticalSection::lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ??0SK_Thread_CriticalSection@@QAE@PAU_RTL_CRITICAL_SECTION@@@Z
_TEXT	SEGMENT
_pCS$ = 8						; size = 4
??0SK_Thread_CriticalSection@@QAE@PAU_RTL_CRITICAL_SECTION@@@Z PROC ; SK_Thread_CriticalSection::SK_Thread_CriticalSection, COMDAT
; _this$ = ecx

; 235  :   SK_Thread_CriticalSection ( CRITICAL_SECTION* pCS )

	npad	2
	push	ebp
	mov	ebp, esp

; 236  :   {
; 237  :     cs_ = pCS;

	mov	eax, DWORD PTR _pCS$[ebp]
	mov	DWORD PTR [ecx], eax

; 238  :   };

	mov	eax, ecx
	pop	ebp
	ret	4
??0SK_Thread_CriticalSection@@QAE@PAU_RTL_CRITICAL_SECTION@@@Z ENDP ; SK_Thread_CriticalSection::SK_Thread_CriticalSection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
;	COMDAT ?NodeWindow@Funcs@?4??ShowMetricsWindow@ImGui@@YAXPA_N@Z@SAXPAUImGuiWindow@@PBD@Z
_TEXT	SEGMENT
_window$ = 8						; size = 4
_label$ = 12						; size = 4
?NodeWindow@Funcs@?4??ShowMetricsWindow@ImGui@@YAXPA_N@Z@SAXPAUImGuiWindow@@PBD@Z PROC ; `ImGui::ShowMetricsWindow'::`5'::Funcs::NodeWindow, COMDAT

; 10894:             {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 10895:                 if (!ImGui::TreeNode(window, "%s '%s', %d @ 0x%p", label, window->Name, window->Active || window->WasActive, window))

	mov	esi, DWORD PTR _window$[ebp]
	cmp	BYTE PTR [esi+132], 0
	jne	SHORT $LN6@NodeWindow
	cmp	BYTE PTR [esi+133], 0
	jne	SHORT $LN6@NodeWindow
	xor	eax, eax
	jmp	SHORT $LN7@NodeWindow
$LN6@NodeWindow:
	mov	eax, 1
$LN7@NodeWindow:
	push	esi
	push	eax
	push	DWORD PTR [esi]
	push	DWORD PTR _label$[ebp]
	push	OFFSET ??_C@_0BD@KOKNLAED@?$CFs?5?8?$CFs?8?0?5?$CFd?5?$EA?50x?$CFp?$AA@
	push	esi
	call	?TreeNode@ImGui@@YA_NPBXPBDZZ		; ImGui::TreeNode
	add	esp, 24					; 00000018H
	test	al, al
	je	$LN1@NodeWindow

; 10896:                     return;
; 10897:                 NodeDrawList(window->DrawList, "DrawList");

	push	OFFSET ??_C@_08IJNCDCKF@DrawList?$AA@
	push	DWORD PTR [esi+624]
	call	?NodeDrawList@Funcs@?4??ShowMetricsWindow@ImGui@@YAXPA_N@Z@SAXPAUImDrawList@@PBD@Z ; `ImGui::ShowMetricsWindow'::`5'::Funcs::NodeDrawList
	movss	xmm0, DWORD PTR [esi+28]

; 10898:                 ImGui::BulletText("Pos: (%.1f,%.1f)", window->Pos.x, window->Pos.y);

	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movss	xmm0, DWORD PTR [esi+24]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BB@OALIFMJB@Pos?3?5?$CI?$CF?41f?0?$CF?41f?$CJ?$AA@
	call	?BulletText@ImGui@@YAXPBDZZ		; ImGui::BulletText
	movss	xmm0, DWORD PTR [esi+52]

; 10899:                 ImGui::BulletText("Size: (%.1f,%.1f), SizeContents (%.1f,%.1f)", window->Size.x, window->Size.y, window->SizeContents.x, window->SizeContents.y);

	sub	esp, 12					; 0000000cH
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+24], xmm0
	movss	xmm0, DWORD PTR [esi+48]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+16], xmm0
	movss	xmm0, DWORD PTR [esi+36]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR [esi+32]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0CM@FNPKCFJC@Size?3?5?$CI?$CF?41f?0?$CF?41f?$CJ?0?5SizeContents?5@
	call	?BulletText@ImGui@@YAXPBDZZ		; ImGui::BulletText
	movss	xmm0, DWORD PTR [esi+96]

; 10900:                 ImGui::BulletText("Scroll: (%.2f,%.2f)", window->Scroll.x, window->Scroll.y);

	add	esp, 20					; 00000014H
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR [esi+92]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BE@LFBJHAFP@Scroll?3?5?$CI?$CF?42f?0?$CF?42f?$CJ?$AA@
	call	?BulletText@ImGui@@YAXPBDZZ		; ImGui::BulletText

; 10901:                 ImGui::BulletText("NavLastId: 0x%08x, NavLayerActiveFlags: %02X", window->NavLastId, window->DC.NavLayerActiveFlags);

	push	DWORD PTR [esi+276]
	push	DWORD PTR [esi+148]
	push	OFFSET ??_C@_0CN@NNMFALIK@NavLastId?3?50x?$CF08x?0?5NavLayerActiv@
	call	?BulletText@ImGui@@YAXPBDZZ		; ImGui::BulletText

; 10902:                 if (window->RootWindow != window) NodeWindow(window->RootWindow, "RootWindow");

	mov	eax, DWORD PTR [esi+632]
	add	esp, 32					; 00000020H
	cmp	eax, esi
	je	SHORT $LN3@NodeWindow
	push	OFFSET ??_C@_0L@EHLMOHOL@RootWindow?$AA@
	push	eax
	call	?NodeWindow@Funcs@?4??ShowMetricsWindow@ImGui@@YAXPA_N@Z@SAXPAUImGuiWindow@@PBD@Z ; `ImGui::ShowMetricsWindow'::`5'::Funcs::NodeWindow
	add	esp, 8
$LN3@NodeWindow:

; 10903:                 if (window->DC.ChildWindows.Size > 0) NodeWindows(window->DC.ChildWindows, "ChildWindows");

	cmp	DWORD PTR [esi+292], 0
	lea	eax, DWORD PTR [esi+292]
	jle	SHORT $LN4@NodeWindow
	push	OFFSET ??_C@_0N@BGDHDNPO@ChildWindows?$AA@
	push	eax
	call	?NodeWindows@Funcs@?4??ShowMetricsWindow@ImGui@@YAXPA_N@Z@SAXAAV?$ImVector@PAUImGuiWindow@@@@PBD@Z ; `ImGui::ShowMetricsWindow'::`5'::Funcs::NodeWindows
	add	esp, 8
$LN4@NodeWindow:

; 10904:                 ImGui::BulletText("Storage: %d bytes", window->StateStorage.Data.Size * (int)sizeof(ImGuiStorage::Pair));

	mov	eax, DWORD PTR [esi+608]
	shl	eax, 3
	push	eax
	push	OFFSET ??_C@_0BC@PDGNHIHG@Storage?3?5?$CFd?5bytes?$AA@
	call	?BulletText@ImGui@@YAXPBDZZ		; ImGui::BulletText
	add	esp, 8
	pop	esi

; 10906:             }

	pop	ebp

; 10905:                 ImGui::TreePop();

	jmp	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN1@NodeWindow:
	pop	esi

; 10906:             }

	pop	ebp
	ret	0
?NodeWindow@Funcs@?4??ShowMetricsWindow@ImGui@@YAXPA_N@Z@SAXPAUImGuiWindow@@PBD@Z ENDP ; `ImGui::ShowMetricsWindow'::`5'::Funcs::NodeWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
;	COMDAT ?NodeWindows@Funcs@?4??ShowMetricsWindow@ImGui@@YAXPA_N@Z@SAXAAV?$ImVector@PAUImGuiWindow@@@@PBD@Z
_TEXT	SEGMENT
_windows$ = 8						; size = 4
_label$ = 12						; size = 4
?NodeWindows@Funcs@?4??ShowMetricsWindow@ImGui@@YAXPA_N@Z@SAXAAV?$ImVector@PAUImGuiWindow@@@@PBD@Z PROC ; `ImGui::ShowMetricsWindow'::`5'::Funcs::NodeWindows, COMDAT

; 10885:             {

	npad	2
	push	ebp
	mov	ebp, esp

; 10886:                 if (!ImGui::TreeNode(label, "%s (%d)", label, windows.Size))

	mov	eax, DWORD PTR _label$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _windows$[ebp]
	push	DWORD PTR [ebx]
	push	eax
	push	OFFSET ??_C@_07JMKCEEPK@?$CFs?5?$CI?$CFd?$CJ?$AA@
	push	eax
	call	?TreeNode@ImGui@@YA_NPBD0ZZ		; ImGui::TreeNode
	add	esp, 16					; 00000010H
	test	al, al
	je	$LN1@NodeWindow

; 10887:                     return;
; 10888:                 for (int i = 0; i < windows.Size; i++)

	push	edi
	xor	edi, edi
	cmp	DWORD PTR [ebx], edi
	jle	$LN3@NodeWindow
	push	esi
$LL4@NodeWindow:

; 10889:                     Funcs::NodeWindow(windows[i], "Window");

	mov	eax, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [eax+edi*4]

; 10895:                 if (!ImGui::TreeNode(window, "%s '%s', %d @ 0x%p", label, window->Name, window->Active || window->WasActive, window))

	cmp	BYTE PTR [esi+132], 0
	jne	SHORT $LN14@NodeWindow
	cmp	BYTE PTR [esi+133], 0
	jne	SHORT $LN14@NodeWindow
	xor	eax, eax
	jmp	SHORT $LN15@NodeWindow
$LN14@NodeWindow:
	mov	eax, 1
$LN15@NodeWindow:
	push	esi
	push	eax
	push	DWORD PTR [esi]
	push	OFFSET ??_C@_06BKKJGDHO@Window?$AA@
	push	OFFSET ??_C@_0BD@KOKNLAED@?$CFs?5?8?$CFs?8?0?5?$CFd?5?$EA?50x?$CFp?$AA@
	push	esi
	call	?TreeNode@ImGui@@YA_NPBXPBDZZ		; ImGui::TreeNode
	add	esp, 24					; 00000018H
	test	al, al
	je	$LN2@NodeWindow

; 10896:                     return;
; 10897:                 NodeDrawList(window->DrawList, "DrawList");

	push	OFFSET ??_C@_08IJNCDCKF@DrawList?$AA@
	push	DWORD PTR [esi+624]
	call	?NodeDrawList@Funcs@?4??ShowMetricsWindow@ImGui@@YAXPA_N@Z@SAXPAUImDrawList@@PBD@Z ; `ImGui::ShowMetricsWindow'::`5'::Funcs::NodeDrawList
	movss	xmm0, DWORD PTR [esi+28]

; 10898:                 ImGui::BulletText("Pos: (%.1f,%.1f)", window->Pos.x, window->Pos.y);

	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movss	xmm0, DWORD PTR [esi+24]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BB@OALIFMJB@Pos?3?5?$CI?$CF?41f?0?$CF?41f?$CJ?$AA@
	call	?BulletText@ImGui@@YAXPBDZZ		; ImGui::BulletText
	movss	xmm0, DWORD PTR [esi+52]

; 10899:                 ImGui::BulletText("Size: (%.1f,%.1f), SizeContents (%.1f,%.1f)", window->Size.x, window->Size.y, window->SizeContents.x, window->SizeContents.y);

	sub	esp, 12					; 0000000cH
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+24], xmm0
	movss	xmm0, DWORD PTR [esi+48]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+16], xmm0
	movss	xmm0, DWORD PTR [esi+36]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR [esi+32]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0CM@FNPKCFJC@Size?3?5?$CI?$CF?41f?0?$CF?41f?$CJ?0?5SizeContents?5@
	call	?BulletText@ImGui@@YAXPBDZZ		; ImGui::BulletText
	movss	xmm0, DWORD PTR [esi+96]

; 10900:                 ImGui::BulletText("Scroll: (%.2f,%.2f)", window->Scroll.x, window->Scroll.y);

	add	esp, 20					; 00000014H
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR [esi+92]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_0BE@LFBJHAFP@Scroll?3?5?$CI?$CF?42f?0?$CF?42f?$CJ?$AA@
	call	?BulletText@ImGui@@YAXPBDZZ		; ImGui::BulletText

; 10901:                 ImGui::BulletText("NavLastId: 0x%08x, NavLayerActiveFlags: %02X", window->NavLastId, window->DC.NavLayerActiveFlags);

	push	DWORD PTR [esi+276]
	push	DWORD PTR [esi+148]
	push	OFFSET ??_C@_0CN@NNMFALIK@NavLastId?3?50x?$CF08x?0?5NavLayerActiv@
	call	?BulletText@ImGui@@YAXPBDZZ		; ImGui::BulletText

; 10902:                 if (window->RootWindow != window) NodeWindow(window->RootWindow, "RootWindow");

	mov	eax, DWORD PTR [esi+632]
	add	esp, 32					; 00000020H
	cmp	eax, esi
	je	SHORT $LN11@NodeWindow
	push	OFFSET ??_C@_0L@EHLMOHOL@RootWindow?$AA@
	push	eax
	call	?NodeWindow@Funcs@?4??ShowMetricsWindow@ImGui@@YAXPA_N@Z@SAXPAUImGuiWindow@@PBD@Z ; `ImGui::ShowMetricsWindow'::`5'::Funcs::NodeWindow
	add	esp, 8
$LN11@NodeWindow:

; 10903:                 if (window->DC.ChildWindows.Size > 0) NodeWindows(window->DC.ChildWindows, "ChildWindows");

	cmp	DWORD PTR [esi+292], 0
	lea	eax, DWORD PTR [esi+292]
	jle	SHORT $LN12@NodeWindow
	push	OFFSET ??_C@_0N@BGDHDNPO@ChildWindows?$AA@
	push	eax
	call	?NodeWindows@Funcs@?4??ShowMetricsWindow@ImGui@@YAXPA_N@Z@SAXAAV?$ImVector@PAUImGuiWindow@@@@PBD@Z ; `ImGui::ShowMetricsWindow'::`5'::Funcs::NodeWindows
	add	esp, 8
$LN12@NodeWindow:

; 10904:                 ImGui::BulletText("Storage: %d bytes", window->StateStorage.Data.Size * (int)sizeof(ImGuiStorage::Pair));

	mov	eax, DWORD PTR [esi+608]
	shl	eax, 3
	push	eax
	push	OFFSET ??_C@_0BC@PDGNHIHG@Storage?3?5?$CFd?5bytes?$AA@
	call	?BulletText@ImGui@@YAXPBDZZ		; ImGui::BulletText
	add	esp, 8

; 10905:                 ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN2@NodeWindow:

; 10887:                     return;
; 10888:                 for (int i = 0; i < windows.Size; i++)

	inc	edi
	cmp	edi, DWORD PTR [ebx]
	jl	$LL4@NodeWindow
	pop	esi
$LN3@NodeWindow:
	pop	edi
	pop	ebx

; 10891:             }

	pop	ebp

; 10890:                 ImGui::TreePop();

	jmp	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN1@NodeWindow:
	pop	ebx

; 10891:             }

	pop	ebp
	ret	0
?NodeWindows@Funcs@?4??ShowMetricsWindow@ImGui@@YAXPA_N@Z@SAXAAV?$ImVector@PAUImGuiWindow@@@@PBD@Z ENDP ; `ImGui::ShowMetricsWindow'::`5'::Funcs::NodeWindows
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
;	COMDAT ?NodeDrawList@Funcs@?4??ShowMetricsWindow@ImGui@@YAXPA_N@Z@SAXPAUImDrawList@@PBD@Z
_TEXT	SEGMENT
_buf$1 = -424						; size = 300
_clipper$2 = -124					; size = 24
_triangles_pos$3 = -100					; size = 24
$T4 = -72						; size = 8
_clip_rect$5 = -64					; size = 16
$T6 = -64						; size = 16
_clipper$2$ = -48					; size = 4
_idx_buffer$1$ = -44					; size = 4
_buf_p$1$ = -40						; size = 4
_overlay_draw_list$1$ = -36				; size = 4
tv1234 = -32						; size = 4
_vtxs_rect$7 = -28					; size = 16
_elem_offset$1$ = -12					; size = 4
tv1233 = -8						; size = 4
_pcmd_node_open$1$ = -1					; size = 1
_draw_list$ = 8						; size = 4
_label$ = 12						; size = 4
?NodeDrawList@Funcs@?4??ShowMetricsWindow@ImGui@@YAXPA_N@Z@SAXPAUImDrawList@@PBD@Z PROC ; `ImGui::ShowMetricsWindow'::`5'::Funcs::NodeDrawList, COMDAT

; 10827:             {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 424				; 000001a8H

; 10828:                 bool node_open = ImGui::TreeNode(draw_list, "%s: '%s' %d vtx, %d indices, %d cmds", label, draw_list->_OwnerName ? draw_list->_OwnerName : "", draw_list->VtxBuffer.Size, draw_list->IdxBuffer.Size, draw_list->CmdBuffer.Size);

	mov	ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
	push	ebx
	push	esi
	mov	esi, DWORD PTR _draw_list$[ebp]
	push	DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+36]
	test	eax, eax
	push	DWORD PTR [esi+12]
	cmovne	ecx, eax
	push	DWORD PTR [esi+24]
	push	ecx
	push	DWORD PTR _label$[ebp]
	push	OFFSET ??_C@_0CF@IMBENNLG@?$CFs?3?5?8?$CFs?8?5?$CFd?5vtx?0?5?$CFd?5indices?0?5?$CFd?5@
	push	esi
	call	?TreeNode@ImGui@@YA_NPBXPBDZZ		; ImGui::TreeNode
	add	esp, 28					; 0000001cH
	mov	bl, al

; 10829:                 if (draw_list == ImGui::GetWindowDrawList())

	call	?GetWindowDrawList@ImGui@@YAPAUImDrawList@@XZ ; ImGui::GetWindowDrawList
	cmp	esi, eax
	jne	SHORT $LN16@NodeDrawLi

; 10830:                 {
; 10831:                     ImGui::SameLine();

	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	movaps	xmm0, XMMWORD PTR __xmm@3f8000003ec8c8ca3ec8c8ca3f800000

; 10832:                     ImGui::TextColored(ImColor(255,100,100), "CURRENTLY APPENDING"); // Can't display stats for active draw list! (we don't have the data double-buffered)

	lea	eax, DWORD PTR $T6[ebp]
	push	OFFSET ??_C@_0BE@LDCFEMCB@CURRENTLY?5APPENDING?$AA@
	push	eax
	movups	XMMWORD PTR $T6[ebp], xmm0
	call	?TextColored@ImGui@@YAXABUImVec4@@PBDZZ	; ImGui::TextColored
	add	esp, 16					; 00000010H

; 10833:                     if (node_open) ImGui::TreePop();

	test	bl, bl
	je	$LN1@NodeDrawLi

; 10881:                 ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
	pop	esi
	pop	ebx

; 10882:             }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@NodeDrawLi:

; 10834:                     return;
; 10835:                 }
; 10836:                 if (!node_open)

	test	bl, bl
	je	$LN1@NodeDrawLi

; 10837:                     return;
; 10838: 
; 10839:                 ImDrawList* overlay_draw_list = &GImGui->OverlayDrawList;   // Render additional visuals into the top-most draw list

	mov	ebx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	add	ebx, 6656				; 00001a00H

; 10840:                 overlay_draw_list->PushClipRectFullScreen();

	mov	ecx, ebx
	mov	DWORD PTR _overlay_draw_list$1$[ebp], ebx
	call	?PushClipRectFullScreen@ImDrawList@@QAEXXZ ; ImDrawList::PushClipRectFullScreen
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 918  :     inline iterator             end()                           { return Data + Size; }

	mov	eax, DWORD PTR [esi]

; 916  :     inline iterator             begin()                         { return Data; }

	mov	ecx, DWORD PTR [esi+8]

; 918  :     inline iterator             end()                           { return Data + Size; }

	shl	eax, 5
	add	eax, ecx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10841:                 int elem_offset = 0;

	mov	DWORD PTR _elem_offset$1$[ebp], 0

; 10842:                 for (const ImDrawCmd* pcmd = draw_list->CmdBuffer.begin(); pcmd < draw_list->CmdBuffer.end(); elem_offset += pcmd->ElemCount, pcmd++)

	cmp	ecx, eax
	jae	$LN3@NodeDrawLi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	lea	ebx, DWORD PTR [ecx+12]
	mov	DWORD PTR tv1233[ebp], ebx
	push	edi
$LL4@NodeDrawLi:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10844:                     if (pcmd->UserCallback)

	mov	eax, DWORD PTR [ebx+12]
	test	eax, eax
	je	SHORT $LN19@NodeDrawLi

; 10845:                     {
; 10846:                         ImGui::BulletText("Callback %p, user_data %p", pcmd->UserCallback, pcmd->UserCallbackData);

	push	DWORD PTR [ebx+16]
	push	eax
	push	OFFSET ??_C@_0BK@FDNBBNBF@Callback?5?$CFp?0?5user_data?5?$CFp?$AA@
	call	?BulletText@ImGui@@YAXPBDZZ		; ImGui::BulletText
	add	esp, 12					; 0000000cH

; 10847:                         continue;

	jmp	$LN2@NodeDrawLi
$LN19@NodeDrawLi:

; 10848:                     }
; 10849:                     ImDrawIdx* idx_buffer = (draw_list->IdxBuffer.Size > 0) ? draw_list->IdxBuffer.Data : NULL;

	mov	edx, DWORD PTR [esi+12]
	test	edx, edx
	jle	SHORT $LN26@NodeDrawLi
	mov	edi, DWORD PTR [esi+20]
	jmp	SHORT $LN130@NodeDrawLi
$LN26@NodeDrawLi:
	xor	edi, edi
$LN130@NodeDrawLi:

; 10850:                     bool pcmd_node_open = ImGui::TreeNode((void*)(pcmd - draw_list->CmdBuffer.begin()), "Draw %-4d %s vtx, tex = %p, clip_rect = (%.0f,%.0f)..(%.0f,%.0f)", pcmd->ElemCount, draw_list->IdxBuffer.Size > 0 ? "indexed" : "non-indexed", pcmd->TextureId, pcmd->ClipRect.x, pcmd->ClipRect.y, pcmd->ClipRect.z, pcmd->ClipRect.w);

	mov	eax, DWORD PTR tv1233[ebp]
	sub	esp, 32					; 00000020H
	test	edx, edx
	mov	DWORD PTR _idx_buffer$1$[ebp], edi
	mov	edx, OFFSET ??_C@_0M@NGJKDAN@non?9indexed?$AA@
	movss	xmm0, DWORD PTR [eax+4]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+24], xmm0
	movss	xmm0, DWORD PTR [eax]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+16], xmm0
	movss	xmm0, DWORD PTR [eax-4]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR [eax-8]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR [eax+8]
	mov	eax, OFFSET ??_C@_07KNEBDGNE@indexed?$AA@
	cmovle	eax, edx
	push	eax
	push	DWORD PTR [ebx-12]
	lea	eax, DWORD PTR [ebx-12]
	sub	eax, ecx
	sar	eax, 5
	push	OFFSET ??_C@_0EB@GBKAKAEN@Draw?5?$CF?94d?5?$CFs?5vtx?0?5tex?5?$DN?5?$CFp?0?5clip@
	push	eax
	call	?TreeNode@ImGui@@YA_NPBXPBDZZ		; ImGui::TreeNode
	add	esp, 52					; 00000034H
	mov	BYTE PTR _pcmd_node_open$1$[ebp], al

; 10851:                     if (show_clip_rects && ImGui::IsItemHovered())

	cmp	BYTE PTR ?show_clip_rects@?4??ShowMetricsWindow@ImGui@@YAXPA_N@Z@4_NA, 0
	je	$LN20@NodeDrawLi
	call	?IsItemHovered@ImGui@@YA_NXZ		; ImGui::IsItemHovered
	test	al, al
	je	$LN127@NodeDrawLi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR tv1233[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10855:                         for (int i = elem_offset; i < elem_offset + (int)pcmd->ElemCount; i++)

	mov	ecx, DWORD PTR _elem_offset$1$[ebp]
	mov	esi, DWORD PTR [ebx-12]
	add	esi, ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR [eax+4]
	movss	xmm5, DWORD PTR [eax-8]
	movss	xmm6, DWORD PTR [eax-4]
	movss	xmm7, DWORD PTR [eax]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10855:                         for (int i = elem_offset; i < elem_offset + (int)pcmd->ElemCount; i++)

	mov	eax, ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _clip_rect$5[ebp+12], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@ff7fffffff7fffff7f7fffff7f7fffff
	movss	DWORD PTR _clip_rect$5[ebp], xmm5
	movss	DWORD PTR _clip_rect$5[ebp+4], xmm6
	movss	DWORD PTR _clip_rect$5[ebp+8], xmm7
	movups	XMMWORD PTR _vtxs_rect$7[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10855:                         for (int i = elem_offset; i < elem_offset + (int)pcmd->ElemCount; i++)

	cmp	ecx, esi
	jge	SHORT $LN6@NodeDrawLi

; 10856:                             vtxs_rect.Add(draw_list->VtxBuffer[idx_buffer ? idx_buffer[i] : i].pos);

	mov	edx, DWORD PTR _draw_list$[ebp]
	movss	xmm1, DWORD PTR _vtxs_rect$7[ebp+12]
	movss	xmm2, DWORD PTR _vtxs_rect$7[ebp+8]
	movss	xmm3, DWORD PTR _vtxs_rect$7[ebp+4]
	mov	edx, DWORD PTR [edx+32]
	movss	xmm4, DWORD PTR _vtxs_rect$7[ebp]
$LL7@NodeDrawLi:
	test	edi, edi
	je	SHORT $LN28@NodeDrawLi
	movzx	ecx, WORD PTR [edi+eax*2]
	jmp	SHORT $LN29@NodeDrawLi
$LN28@NodeDrawLi:
	mov	ecx, eax
$LN29@NodeDrawLi:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	lea	ecx, DWORD PTR [ecx+ecx*4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 255  :     void        Add(const ImVec2& rhs)          { if (Min.x > rhs.x)     Min.x = rhs.x;     if (Min.y > rhs.y) Min.y = rhs.y;         if (Max.x < rhs.x) Max.x = rhs.x;         if (Max.y < rhs.y) Max.y = rhs.y; }

	movss	xmm0, DWORD PTR [edx+ecx*4]
	comiss	xmm4, xmm0
	jbe	SHORT $LN59@NodeDrawLi
	movaps	xmm4, xmm0
	movss	DWORD PTR _vtxs_rect$7[ebp], xmm4
$LN59@NodeDrawLi:
	movss	xmm0, DWORD PTR [edx+ecx*4+4]
	comiss	xmm3, xmm0
	jbe	SHORT $LN60@NodeDrawLi
	movaps	xmm3, xmm0
	movss	DWORD PTR _vtxs_rect$7[ebp+4], xmm3
$LN60@NodeDrawLi:
	movss	xmm0, DWORD PTR [edx+ecx*4]
	comiss	xmm0, xmm2
	jbe	SHORT $LN61@NodeDrawLi
	movaps	xmm2, xmm0
	movss	DWORD PTR _vtxs_rect$7[ebp+8], xmm2
$LN61@NodeDrawLi:
	movss	xmm0, DWORD PTR [edx+ecx*4+4]
	comiss	xmm0, xmm1
	jbe	SHORT $LN5@NodeDrawLi
	movaps	xmm1, xmm0
	movss	DWORD PTR _vtxs_rect$7[ebp+12], xmm1
$LN5@NodeDrawLi:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10855:                         for (int i = elem_offset; i < elem_offset + (int)pcmd->ElemCount; i++)

	inc	eax
	cmp	eax, esi
	jl	SHORT $LL7@NodeDrawLi
$LN6@NodeDrawLi:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 261  :     void        Floor()                         { Min.x = (float)(int)Min.x; Min.y = (float)(int)Min.y; Max.x = (float)(int)Max.x; Max.y = (float)(int)Max.y; }

	cvttss2si eax, xmm5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10857:                         clip_rect.Floor(); overlay_draw_list->AddRect(clip_rect.Min, clip_rect.Max, IM_COL32(255,255,0,255));

	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	-1
	push	ecx
	mov	ecx, DWORD PTR _overlay_draw_list$1$[ebp]
	mov	DWORD PTR [esp], 0
	push	-16711681				; ff00ffffH
	movd	xmm0, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 261  :     void        Floor()                         { Min.x = (float)(int)Min.x; Min.y = (float)(int)Min.y; Max.x = (float)(int)Max.x; Max.y = (float)(int)Max.y; }

	cvtdq2ps xmm0, xmm0
	cvttss2si eax, xmm6
	movss	DWORD PTR _clip_rect$5[ebp], xmm0
	movd	xmm0, eax
	cvttss2si eax, xmm7
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR _clip_rect$5[ebp+4], xmm0
	movd	xmm0, eax
	mov	eax, DWORD PTR tv1233[ebp]
	cvtdq2ps xmm0, xmm0
	cvttss2si eax, DWORD PTR [eax+4]
	movss	DWORD PTR _clip_rect$5[ebp+8], xmm0
	movd	xmm0, eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10857:                         clip_rect.Floor(); overlay_draw_list->AddRect(clip_rect.Min, clip_rect.Max, IM_COL32(255,255,0,255));

	lea	eax, DWORD PTR _clip_rect$5[ebp+8]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 261  :     void        Floor()                         { Min.x = (float)(int)Min.x; Min.y = (float)(int)Min.y; Max.x = (float)(int)Max.x; Max.y = (float)(int)Max.y; }

	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10857:                         clip_rect.Floor(); overlay_draw_list->AddRect(clip_rect.Min, clip_rect.Max, IM_COL32(255,255,0,255));

	push	eax
	lea	eax, DWORD PTR _clip_rect$5[ebp]
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 261  :     void        Floor()                         { Min.x = (float)(int)Min.x; Min.y = (float)(int)Min.y; Max.x = (float)(int)Max.x; Max.y = (float)(int)Max.y; }

	movss	DWORD PTR _clip_rect$5[ebp+12], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10857:                         clip_rect.Floor(); overlay_draw_list->AddRect(clip_rect.Min, clip_rect.Max, IM_COL32(255,255,0,255));

	call	?AddRect@ImDrawList@@QAEXABUImVec2@@0IMHM@Z ; ImDrawList::AddRect
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 261  :     void        Floor()                         { Min.x = (float)(int)Min.x; Min.y = (float)(int)Min.y; Max.x = (float)(int)Max.x; Max.y = (float)(int)Max.y; }

	cvttss2si eax, DWORD PTR _vtxs_rect$7[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10858:                         vtxs_rect.Floor(); overlay_draw_list->AddRect(vtxs_rect.Min, vtxs_rect.Max, IM_COL32(255,0,255,255));

	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	-1
	push	ecx
	mov	ecx, DWORD PTR _overlay_draw_list$1$[ebp]
	mov	DWORD PTR [esp], 0
	push	-65281					; ffff00ffH
	movd	xmm0, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 261  :     void        Floor()                         { Min.x = (float)(int)Min.x; Min.y = (float)(int)Min.y; Max.x = (float)(int)Max.x; Max.y = (float)(int)Max.y; }

	cvttss2si eax, DWORD PTR _vtxs_rect$7[ebp+4]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR _vtxs_rect$7[ebp], xmm0
	movd	xmm0, eax
	cvttss2si eax, DWORD PTR _vtxs_rect$7[ebp+8]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR _vtxs_rect$7[ebp+4], xmm0
	movd	xmm0, eax
	cvttss2si eax, DWORD PTR _vtxs_rect$7[ebp+12]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR _vtxs_rect$7[ebp+8], xmm0
	movd	xmm0, eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10858:                         vtxs_rect.Floor(); overlay_draw_list->AddRect(vtxs_rect.Min, vtxs_rect.Max, IM_COL32(255,0,255,255));

	lea	eax, DWORD PTR _vtxs_rect$7[ebp+8]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 261  :     void        Floor()                         { Min.x = (float)(int)Min.x; Min.y = (float)(int)Min.y; Max.x = (float)(int)Max.x; Max.y = (float)(int)Max.y; }

	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10858:                         vtxs_rect.Floor(); overlay_draw_list->AddRect(vtxs_rect.Min, vtxs_rect.Max, IM_COL32(255,0,255,255));

	push	eax
	lea	eax, DWORD PTR _vtxs_rect$7[ebp]
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 261  :     void        Floor()                         { Min.x = (float)(int)Min.x; Min.y = (float)(int)Min.y; Max.x = (float)(int)Max.x; Max.y = (float)(int)Max.y; }

	movss	DWORD PTR _vtxs_rect$7[ebp+12], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10858:                         vtxs_rect.Floor(); overlay_draw_list->AddRect(vtxs_rect.Min, vtxs_rect.Max, IM_COL32(255,0,255,255));

	call	?AddRect@ImDrawList@@QAEXABUImVec2@@0IMHM@Z ; ImDrawList::AddRect
	mov	esi, DWORD PTR _draw_list$[ebp]
$LN127@NodeDrawLi:
	mov	al, BYTE PTR _pcmd_node_open$1$[ebp]
$LN20@NodeDrawLi:

; 10859:                     }
; 10860:                     if (!pcmd_node_open)

	test	al, al
	je	$LN128@NodeDrawLi

; 10862:                     ImGuiListClipper clipper(pcmd->ElemCount/3); // Manually coarse clip our print out of individual vertices to save CPU, only items that may be visible.

	mov	eax, -1431655765			; aaaaaaabH
	mul	DWORD PTR [ebx-12]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1158 :     ImGuiListClipper(int items_count = -1, float items_height = -1.0f)  { Begin(items_count, items_height); } // NB: Begin() initialize every fields (as we allow user to call Begin/End multiple times on a same instance if they want).

	push	ecx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10862:                     ImGuiListClipper clipper(pcmd->ElemCount/3); // Manually coarse clip our print out of individual vertices to save CPU, only items that may be visible.

	shr	edx, 1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1158 :     ImGuiListClipper(int items_count = -1, float items_height = -1.0f)  { Begin(items_count, items_height); } // NB: Begin() initialize every fields (as we allow user to call Begin/End multiple times on a same instance if they want).

	lea	ecx, DWORD PTR _clipper$2[ebp]
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	push	edx
	call	?Begin@ImGuiListClipper@@QAEXHM@Z	; ImGuiListClipper::Begin
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10863:                     while (clipper.Step())

	lea	ecx, DWORD PTR _clipper$2[ebp]
	call	?Step@ImGuiListClipper@@QAE_NXZ		; ImGuiListClipper::Step
	test	al, al
	je	$LN9@NodeDrawLi
$LL8@NodeDrawLi:

; 10864:                         for (int prim = clipper.DisplayStart, vtx_i = elem_offset + clipper.DisplayStart*3; prim < clipper.DisplayEnd; prim++)

	mov	eax, DWORD PTR _clipper$2[ebp+16]
	mov	ecx, DWORD PTR _elem_offset$1$[ebp]
	lea	esi, DWORD PTR [ecx+eax*2]
	mov	ecx, DWORD PTR _clipper$2[ebp+20]
	add	esi, eax
	cmp	eax, ecx
	jge	$LN11@NodeDrawLi
	sub	ecx, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T4[ebp], 0
	mov	DWORD PTR $T4[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10864:                         for (int prim = clipper.DisplayStart, vtx_i = elem_offset + clipper.DisplayStart*3; prim < clipper.DisplayEnd; prim++)

	mov	DWORD PTR _clipper$2$[ebp], ecx
	npad	4
$LL12@NodeDrawLi:

; 10866:                             char buf[300], *buf_p = buf;

	lea	eax, DWORD PTR _buf$1[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 97   :     ImVec2() { x = y = 0.0f; }

	mov	DWORD PTR _triangles_pos$3[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10866:                             char buf[300], *buf_p = buf;

	mov	DWORD PTR _buf_p$1$[ebp], eax

; 10867:                             ImVec2 triangles_pos[3];
; 10868:                             for (int n = 0; n < 3; n++, vtx_i++)

	xor	ebx, ebx
	lea	eax, DWORD PTR _triangles_pos$3[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 97   :     ImVec2() { x = y = 0.0f; }

	mov	DWORD PTR _triangles_pos$3[ebp], 0
	mov	DWORD PTR _triangles_pos$3[ebp+12], 0
	mov	DWORD PTR _triangles_pos$3[ebp+8], 0
	mov	DWORD PTR _triangles_pos$3[ebp+20], 0
	mov	DWORD PTR _triangles_pos$3[ebp+16], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10866:                             char buf[300], *buf_p = buf;

	mov	DWORD PTR tv1234[ebp], eax
	npad	5
$LL15@NodeDrawLi:

; 10869:                             {
; 10870:                                 ImDrawVert& v = draw_list->VtxBuffer[idx_buffer ? idx_buffer[vtx_i] : vtx_i];

	test	edi, edi
	je	SHORT $LN30@NodeDrawLi
	movzx	eax, WORD PTR [edi+esi*2]
	jmp	SHORT $LN31@NodeDrawLi
$LN30@NodeDrawLi:
	mov	eax, esi
$LN31@NodeDrawLi:

; 10871:                                 triangles_pos[n] = v.pos;

	mov	edi, DWORD PTR tv1234[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR _draw_list$[ebp]
	mov	ecx, DWORD PTR [eax+32]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10871:                                 triangles_pos[n] = v.pos;

	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR [ecx+edx*4+4]
	mov	DWORD PTR [edi+4], eax

; 10872:                                 buf_p += sprintf(buf_p, "%s %04d { pos = (%8.2f,%8.2f), uv = (%.6f,%.6f), col = %08X }\n", (n == 0) ? "vtx" : "   ", vtx_i, v.pos.x, v.pos.y, v.uv.x, v.uv.y, v.col);

	mov	eax, OFFSET ??_C@_03CEPBOMNB@vtx?$AA@
	push	DWORD PTR [ecx+edx*4+16]
	movss	xmm0, DWORD PTR [ecx+edx*4+12]
	cvtps2pd xmm0, xmm0
	sub	esp, 32					; 00000020H
	mov	edi, DWORD PTR _buf_p$1$[ebp]
	test	ebx, ebx
	movsd	QWORD PTR [esp+24], xmm0
	movss	xmm0, DWORD PTR [ecx+edx*4+8]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+16], xmm0
	movss	xmm0, DWORD PTR [ecx+edx*4+4]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR [ecx+edx*4]
	mov	ecx, OFFSET ??_C@_03NDEAONJP@?5?5?5?$AA@
	cvtps2pd xmm0, xmm0
	cmovne	eax, ecx
	movsd	QWORD PTR [esp], xmm0
	push	esi
	push	eax
	push	OFFSET ??_C@_0DP@LIPFHOCP@?$CFs?5?$CF04d?5?$HL?5pos?5?$DN?5?$CI?$CF8?42f?0?$CF8?42f?$CJ?0?5u@
	push	edi
	call	_sprintf
	add	DWORD PTR tv1234[ebp], 8
	add	edi, eax
	inc	ebx
	mov	DWORD PTR _buf_p$1$[ebp], edi
	mov	edi, DWORD PTR _idx_buffer$1$[ebp]
	add	esp, 52					; 00000034H
	inc	esi
	cmp	ebx, 3
	jl	$LL15@NodeDrawLi

; 10873:                             }
; 10874:                             ImGui::Selectable(buf, false);

	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	push	0
	lea	eax, DWORD PTR _buf$1[ebp]
	push	0
	push	eax
	call	?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ; ImGui::Selectable
	add	esp, 16					; 00000010H

; 10875:                             if (ImGui::IsItemHovered())

	call	?IsItemHovered@ImGui@@YA_NXZ		; ImGui::IsItemHovered
	test	al, al
	je	SHORT $LN10@NodeDrawLi

; 10876:                                 overlay_draw_list->AddPolyline(triangles_pos, 3, IM_COL32(255,255,0,255), true, 1.0f, false);  // Add triangle without AA, more readable for large-thin triangle

	push	0
	push	ecx
	mov	ecx, DWORD PTR _overlay_draw_list$1$[ebp]
	lea	eax, DWORD PTR _triangles_pos$3[ebp]
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	1
	push	-16711681				; ff00ffffH
	push	3
	push	eax
	call	?AddPolyline@ImDrawList@@QAEXPBUImVec2@@HI_NM1@Z ; ImDrawList::AddPolyline
$LN10@NodeDrawLi:

; 10864:                         for (int prim = clipper.DisplayStart, vtx_i = elem_offset + clipper.DisplayStart*3; prim < clipper.DisplayEnd; prim++)

	sub	DWORD PTR _clipper$2$[ebp], 1
	jne	$LL12@NodeDrawLi
$LN11@NodeDrawLi:

; 10863:                     while (clipper.Step())

	lea	ecx, DWORD PTR _clipper$2[ebp]
	call	?Step@ImGuiListClipper@@QAE_NXZ		; ImGuiListClipper::Step
	test	al, al
	jne	$LL8@NodeDrawLi
$LN9@NodeDrawLi:

; 10877:                         }
; 10878:                     ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
	mov	esi, DWORD PTR _draw_list$[ebp]
$LN128@NodeDrawLi:
	mov	ebx, DWORD PTR tv1233[ebp]
$LN2@NodeDrawLi:

; 10842:                 for (const ImDrawCmd* pcmd = draw_list->CmdBuffer.begin(); pcmd < draw_list->CmdBuffer.end(); elem_offset += pcmd->ElemCount, pcmd++)

	mov	eax, DWORD PTR _elem_offset$1$[ebp]
	add	eax, DWORD PTR [ebx-12]
	add	ebx, 32					; 00000020H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 918  :     inline iterator             end()                           { return Data + Size; }

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+8]
	shl	edx, 5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10842:                 for (const ImDrawCmd* pcmd = draw_list->CmdBuffer.begin(); pcmd < draw_list->CmdBuffer.end(); elem_offset += pcmd->ElemCount, pcmd++)

	mov	DWORD PTR _elem_offset$1$[ebp], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 918  :     inline iterator             end()                           { return Data + Size; }

	add	edx, ecx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10842:                 for (const ImDrawCmd* pcmd = draw_list->CmdBuffer.begin(); pcmd < draw_list->CmdBuffer.end(); elem_offset += pcmd->ElemCount, pcmd++)

	lea	eax, DWORD PTR [ebx-12]
	mov	DWORD PTR tv1233[ebp], ebx
	cmp	eax, edx
	jb	$LL4@NodeDrawLi
	mov	ebx, DWORD PTR _overlay_draw_list$1$[ebp]
	pop	edi
$LN3@NodeDrawLi:

; 10879:                 }
; 10880:                 overlay_draw_list->PopClipRect();

	mov	ecx, ebx
	call	?PopClipRect@ImDrawList@@QAEXXZ		; ImDrawList::PopClipRect

; 10881:                 ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN1@NodeDrawLi:
	pop	esi
	pop	ebx

; 10882:             }

	mov	esp, ebp
	pop	ebp
	ret	0
?NodeDrawList@Funcs@?4??ShowMetricsWindow@ImGui@@YAXPA_N@Z@SAXPAUImDrawList@@PBD@Z ENDP ; `ImGui::ShowMetricsWindow'::`5'::Funcs::NodeDrawList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??__Fbuf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPBDPAX@Z@YAXXZ
text$yd	SEGMENT
__$EHRec$ = -12						; size = 12
??__Fbuf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPBDPAX@Z@YAXXZ PROC ; `GetClipboardTextFn_DefaultImpl'::`2'::`dynamic atexit destructor for 'buf_local'', COMDAT
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??__Fbuf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPBDPAX@Z@YAXXZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	mov	eax, DWORD PTR ?buf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPBDPAX@Z@4V?$ImVector@D@@A+8
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN4@dynamic
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN4@dynamic:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
text$yd	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??__Fbuf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPBDPAX@Z@YAXXZ:
	mov	eax, OFFSET __ehfuncinfo$??__Fbuf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPBDPAX@Z@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??__Fbuf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPBDPAX@Z@YAXXZ ENDP ; `GetClipboardTextFn_DefaultImpl'::`2'::`dynamic atexit destructor for 'buf_local''
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_data$ = 8						; size = 4
_idx$ = 12						; size = 4
_out_text$ = 16						; size = 4
?Items_SingleStringGetter@@YA_NPAXHPAPBD@Z PROC		; Items_SingleStringGetter

; 9463 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 9464 :     // FIXME-OPT: we could pre-compute the indices to fasten this. But only 1 active combo means the waste is limited.
; 9465 :     const char* items_separated_by_zeros = (const char*)data;
; 9466 :     int items_count = 0;
; 9467 :     const char* p = items_separated_by_zeros;

	mov	edx, DWORD PTR _data$[ebp]
	push	ebx
	push	esi
	xor	esi, esi

; 9468 :     while (*p)

	cmp	BYTE PTR [edx], 0
	push	edi
	je	SHORT $LN13@Items_Sing
	mov	ebx, DWORD PTR _idx$[ebp]
$LL2@Items_Sing:

; 9469 :     {
; 9470 :         if (idx == items_count)

	cmp	ebx, esi
	je	SHORT $LN9@Items_Sing

; 9471 :             break;
; 9472 :         p += strlen(p) + 1;

	mov	eax, edx
	lea	edi, DWORD PTR [eax+1]
	npad	2
$LL14@Items_Sing:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL14@Items_Sing
	sub	eax, edi
	inc	edx
	add	edx, eax

; 9473 :         items_count++;

	inc	esi
	cmp	BYTE PTR [edx], cl
	jne	SHORT $LL2@Items_Sing

; 9476 :         return false;

	pop	edi
	pop	esi
	xor	al, al
	pop	ebx

; 9480 : }

	pop	ebp
	ret	0
$LN9@Items_Sing:

; 9474 :     }
; 9475 :     if (!*p)

	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN5@Items_Sing
$LN13@Items_Sing:
	pop	edi
	pop	esi

; 9476 :         return false;

	xor	al, al
	pop	ebx

; 9480 : }

	pop	ebp
	ret	0
$LN5@Items_Sing:

; 9477 :     if (out_text)

	mov	eax, DWORD PTR _out_text$[ebp]
	test	eax, eax
	je	SHORT $LN6@Items_Sing

; 9478 :         *out_text = p;

	mov	DWORD PTR [eax], edx
$LN6@Items_Sing:
	pop	edi
	pop	esi

; 9479 :     return true;

	mov	al, 1
	pop	ebx

; 9480 : }

	pop	ebp
	ret	0
?Items_SingleStringGetter@@YA_NPAXHPAPBD@Z ENDP		; Items_SingleStringGetter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_data$ = 8						; size = 4
_idx$ = 12						; size = 4
_out_text$ = 16						; size = 4
?Items_ArrayGetter@@YA_NPAXHPAPBD@Z PROC		; Items_ArrayGetter

; 9455 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 9456 :     const char* const* items = (const char* const*)data;
; 9457 :     if (out_text)

	mov	edx, DWORD PTR _out_text$[ebp]
	test	edx, edx
	je	SHORT $LN4@Items_Arra

; 9458 :         *out_text = items[idx];

	mov	ecx, DWORD PTR _idx$[ebp]
	mov	eax, DWORD PTR _data$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edx], eax
$LN4@Items_Arra:

; 9459 :     return true;

	mov	al, 1

; 9460 : }

	pop	ebp
	ret	0
?Items_ArrayGetter@@YA_NPAXHPAPBD@Z ENDP		; Items_ArrayGetter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\textedit.h
_TEXT	SEGMENT
_state$ = 8						; size = 4
_is_single_line$ = 12					; size = 4
?stb_textedit_initialize_state@ImGuiStb@@YAXPAUSTB_TexteditState@1@H@Z PROC ; ImGuiStb::stb_textedit_initialize_state

; 1320 :    stb_textedit_clear_state(state, is_single_line);

	jmp	?stb_textedit_clear_state@ImGuiStb@@YAXPAUSTB_TexteditState@1@H@Z ; ImGuiStb::stb_textedit_clear_state
?stb_textedit_initialize_state@ImGuiStb@@YAXPAUSTB_TexteditState@1@H@Z ENDP ; ImGuiStb::stb_textedit_initialize_state
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\textedit.h
_TEXT	SEGMENT
_state$ = 8						; size = 4
_is_single_line$ = 12					; size = 4
?stb_textedit_clear_state@ImGuiStb@@YAXPAUSTB_TexteditState@1@H@Z PROC ; ImGuiStb::stb_textedit_clear_state

; 1302 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1303 :    state->undostate.undo_point = 0;

	mov	ecx, DWORD PTR _state$[ebp]

; 1304 :    state->undostate.undo_char_point = 0;
; 1305 :    state->undostate.redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;
; 1306 :    state->undostate.redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;
; 1307 :    state->select_end = state->select_start = 0;
; 1308 :    state->cursor = 0;
; 1309 :    state->has_preferred_x = 0;
; 1310 :    state->preferred_x = 0;
; 1311 :    state->cursor_at_end_of_line = 0;
; 1312 :    state->initialized = 1;
; 1313 :    state->single_line = (unsigned char) is_single_line;

	mov	al, BYTE PTR _is_single_line$[ebp]
	mov	DWORD PTR [ecx+3210], 6488064		; 00630000H
	mov	DWORD PTR [ecx+3214], 65470464		; 03e70000H
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx], 0

; 1314 :    state->insert_mode = 0;

	mov	DWORD PTR [ecx+12], 65536		; 00010000H
	mov	DWORD PTR [ecx+20], 0
	mov	BYTE PTR [ecx+16], al

; 1315 : }

	pop	ebp
	ret	0
?stb_textedit_clear_state@ImGuiStb@@YAXPAUSTB_TexteditState@1@H@Z ENDP ; ImGuiStb::stb_textedit_clear_state
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\textedit.h
_TEXT	SEGMENT
_state$ = 8						; size = 4
_pos$ = 12						; size = 4
_insert_len$ = 16					; size = 4
_delete_len$ = 20					; size = 4
?stb_text_createundo@ImGuiStb@@YAPAGPAUStbUndoState@1@HHH@Z PROC ; ImGuiStb::stb_text_createundo

; 1137 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 1138 :    StbUndoRecord *r = stb_text_create_undo_record(state, insert_len);

	mov	esi, DWORD PTR _insert_len$[ebp]
	push	edi
	mov	edi, DWORD PTR _state$[ebp]
	push	esi
	push	edi
	call	?stb_text_create_undo_record@ImGuiStb@@YAPAUStbUndoRecord@1@PAUStbUndoState@1@H@Z ; ImGuiStb::stb_text_create_undo_record
	mov	ecx, eax
	add	esp, 8

; 1139 :    if (r == NULL)

	test	ecx, ecx
	je	SHORT $LN6@stb_text_c

; 1140 :       return NULL;
; 1141 : 
; 1142 :    r->where = pos;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	DWORD PTR [ecx], eax

; 1143 :    r->insert_length = (short) insert_len;
; 1144 :    r->delete_length = (short) delete_len;

	mov	ax, WORD PTR _delete_len$[ebp]
	mov	WORD PTR [ecx+4], si
	mov	WORD PTR [ecx+6], ax

; 1145 : 
; 1146 :    if (insert_len == 0) {

	test	esi, esi
	jne	SHORT $LN3@stb_text_c

; 1147 :       r->char_storage = -1;

	or	eax, -1
	mov	WORD PTR [ecx+8], ax
$LN6@stb_text_c:

; 1148 :       return NULL;

	pop	edi
	xor	eax, eax
	pop	esi

; 1153 :    }
; 1154 : }

	pop	ebp
	ret	0
$LN3@stb_text_c:

; 1149 :    } else {
; 1150 :       r->char_storage = state->undo_char_point;

	mov	ax, WORD PTR [edi+3190]
	mov	WORD PTR [ecx+8], ax

; 1151 :       state->undo_char_point = state->undo_char_point + (short) insert_len;

	add	WORD PTR [edi+3190], si

; 1152 :       return &state->undo_char[r->char_storage];

	movsx	eax, WORD PTR [ecx+8]
	add	eax, 594				; 00000252H
	lea	eax, DWORD PTR [edi+eax*2]
	pop	edi
	pop	esi

; 1153 :    }
; 1154 : }

	pop	ebp
	ret	0
?stb_text_createundo@ImGuiStb@@YAPAGPAUStbUndoState@1@HHH@Z ENDP ; ImGuiStb::stb_text_createundo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\textedit.h
_TEXT	SEGMENT
_state$ = 8						; size = 4
_numchars$ = 12						; size = 4
?stb_text_create_undo_record@ImGuiStb@@YAPAUStbUndoRecord@1@PAUStbUndoState@1@H@Z PROC ; ImGuiStb::stb_text_create_undo_record

; 1113 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 1114 :    // any time we create a new undo record, we discard redo
; 1115 :    stb_textedit_flush_redo(state);

	mov	esi, DWORD PTR _state$[ebp]
	push	edi
	push	esi
	call	?stb_textedit_flush_redo@ImGuiStb@@YAXPAUStbUndoState@1@@Z ; ImGuiStb::stb_textedit_flush_redo
	add	esp, 4

; 1116 : 
; 1117 :    // if we have no free records, we have to make room, by sliding the
; 1118 :    // existing records down
; 1119 :    if (state->undo_point == STB_TEXTEDIT_UNDOSTATECOUNT)

	cmp	WORD PTR [esi+3186], 99			; 00000063H
	jne	SHORT $LN4@stb_text_c

; 1120 :       stb_textedit_discard_undo(state);

	push	esi
	call	?stb_textedit_discard_undo@ImGuiStb@@YAXPAUStbUndoState@1@@Z ; ImGuiStb::stb_textedit_discard_undo
	add	esp, 4
$LN4@stb_text_c:

; 1121 : 
; 1122 :    // if the characters to store won't possibly fit in the buffer, we can't undo
; 1123 :    if (numchars > STB_TEXTEDIT_UNDOCHARCOUNT) {

	mov	edi, DWORD PTR _numchars$[ebp]
	cmp	edi, 999				; 000003e7H
	jle	SHORT $LN7@stb_text_c

; 1124 :       state->undo_point = 0;

	xor	eax, eax
	pop	edi
	mov	WORD PTR [esi+3186], ax

; 1125 :       state->undo_char_point = 0;

	mov	WORD PTR [esi+3190], ax
	pop	esi

; 1134 : }

	pop	ebp
	ret	0
$LN7@stb_text_c:

; 1126 :       return NULL;
; 1127 :    }
; 1128 : 
; 1129 :    // if we don't have enough free characters in the buffer, we have to make room
; 1130 :    while (state->undo_char_point + numchars > STB_TEXTEDIT_UNDOCHARCOUNT)

	movsx	eax, WORD PTR [esi+3190]
	add	eax, edi
	cmp	eax, 999				; 000003e7H
	jle	SHORT $LN3@stb_text_c
$LL2@stb_text_c:

; 1131 :       stb_textedit_discard_undo(state);

	push	esi
	call	?stb_textedit_discard_undo@ImGuiStb@@YAXPAUStbUndoState@1@@Z ; ImGuiStb::stb_textedit_discard_undo
	movsx	eax, WORD PTR [esi+3190]
	add	esp, 4
	add	eax, edi
	cmp	eax, 999				; 000003e7H
	jg	SHORT $LL2@stb_text_c
$LN3@stb_text_c:

; 1132 : 
; 1133 :    return &state->undo_rec[state->undo_point++];

	movzx	ecx, WORD PTR [esi+3186]
	movsx	eax, cx
	inc	ecx
	pop	edi
	mov	WORD PTR [esi+3186], cx
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [esi+eax*4]
	pop	esi

; 1134 : }

	pop	ebp
	ret	0
?stb_text_create_undo_record@ImGuiStb@@YAPAUStbUndoRecord@1@PAUStbUndoState@1@H@Z ENDP ; ImGuiStb::stb_text_create_undo_record
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\textedit.h
_TEXT	SEGMENT
_state$ = 8						; size = 4
?stb_textedit_discard_redo@ImGuiStb@@YAXPAUStbUndoState@1@@Z PROC ; ImGuiStb::stb_textedit_discard_redo

; 1093 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 1094 :    int k = STB_TEXTEDIT_UNDOSTATECOUNT-1;
; 1095 : 
; 1096 :    if (state->redo_point <= k) {

	mov	esi, DWORD PTR _state$[ebp]
	cmp	WORD PTR [esi+3188], 98			; 00000062H
	jg	$LN5@stb_texted

; 1097 :       // if the k'th undo state has characters, clean those up
; 1098 :       if (state->undo_rec[k].char_storage >= 0) {

	cmp	WORD PTR [esi+1184], 0
	jl	SHORT $LN3@stb_texted

; 1099 :          int n = state->undo_rec[k].insert_length, i;

	push	edi
	movsx	edi, WORD PTR [esi+1180]

; 1100 :          // delete n characters from all other records
; 1101 :          state->redo_char_point = state->redo_char_point + (short) n; // vsnet05
; 1102 :          STB_TEXTEDIT_memmove(state->undo_char + state->redo_char_point, state->undo_char + state->redo_char_point-n, (size_t) ((size_t)(STB_TEXTEDIT_UNDOCHARCOUNT - state->redo_char_point)*sizeof(STB_TEXTEDIT_CHARTYPE)));

	mov	eax, 999				; 000003e7H
	add	WORD PTR [esi+3192], di
	movsx	ecx, WORD PTR [esi+3192]
	sub	eax, ecx
	add	eax, eax
	push	eax
	mov	eax, ecx
	add	ecx, 594				; 00000252H
	sub	eax, edi
	add	eax, 594				; 00000252H
	lea	eax, DWORD PTR [esi+eax*2]
	push	eax
	lea	eax, DWORD PTR [esi+ecx*2]
	push	eax
	call	DWORD PTR __imp__memmove

; 1103 :          for (i=state->redo_point; i < k; ++i)

	movsx	ecx, WORD PTR [esi+3188]
	add	esp, 12					; 0000000cH
	cmp	ecx, 98					; 00000062H
	jge	SHORT $LN13@stb_texted

; 1099 :          int n = state->undo_rec[k].insert_length, i;

	lea	eax, DWORD PTR [ecx+1]
	mov	edx, 98					; 00000062H
	lea	eax, DWORD PTR [ecx+eax*2]
	sub	edx, ecx
	lea	eax, DWORD PTR [esi+eax*4]
	npad	3
$LL4@stb_texted:

; 1104 :             if (state->undo_rec[i].char_storage >= 0)

	movzx	ecx, WORD PTR [eax]
	test	cx, cx
	js	SHORT $LN2@stb_texted

; 1105 :                state->undo_rec[i].char_storage = state->undo_rec[i].char_storage + (short) n; // vsnet05

	add	ecx, edi
	mov	WORD PTR [eax], cx
$LN2@stb_texted:

; 1103 :          for (i=state->redo_point; i < k; ++i)

	add	eax, 12					; 0000000cH
	sub	edx, 1
	jne	SHORT $LL4@stb_texted
$LN13@stb_texted:
	pop	edi
$LN3@stb_texted:

; 1106 :       }
; 1107 :       STB_TEXTEDIT_memmove(state->undo_rec + state->redo_point, state->undo_rec + state->redo_point-1, (size_t) ((size_t)(STB_TEXTEDIT_UNDOSTATECOUNT - state->redo_point)*sizeof(state->undo_rec[0])));

	movsx	ecx, WORD PTR [esi+3188]
	lea	eax, DWORD PTR [ecx+ecx*2]
	lea	edx, DWORD PTR [esi+eax*4]
	mov	eax, 1188				; 000004a4H
	lea	ecx, DWORD PTR [ecx+ecx*2]
	shl	ecx, 2
	sub	eax, ecx
	push	eax
	lea	eax, DWORD PTR [edx-12]
	push	eax
	push	edx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 1108 :       ++state->redo_point;

	inc	WORD PTR [esi+3188]
$LN5@stb_texted:
	pop	esi

; 1109 :    }
; 1110 : }

	pop	ebp
	ret	0
?stb_textedit_discard_redo@ImGuiStb@@YAXPAUStbUndoState@1@@Z ENDP ; ImGuiStb::stb_textedit_discard_redo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\textedit.h
_TEXT	SEGMENT
_state$ = 8						; size = 4
?stb_textedit_discard_undo@ImGuiStb@@YAXPAUStbUndoState@1@@Z PROC ; ImGuiStb::stb_textedit_discard_undo

; 1071 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	edi

; 1072 :    if (state->undo_point > 0) {

	mov	edi, DWORD PTR _state$[ebp]
	cmp	WORD PTR [edi+3186], 0
	jle	$LN5@stb_texted

; 1073 :       // if the 0th undo state has characters, clean those up
; 1074 :       if (state->undo_rec[0].char_storage >= 0) {

	cmp	WORD PTR [edi+8], 0
	push	esi
	lea	esi, DWORD PTR [edi+8]
	jl	SHORT $LN3@stb_texted

; 1075 :          int n = state->undo_rec[0].insert_length, i;

	push	ebx
	movsx	ebx, WORD PTR [edi+4]

; 1076 :          // delete n characters from all other records
; 1077 :          state->undo_char_point = state->undo_char_point - (short) n;  // vsnet05

	sub	WORD PTR [edi+3190], bx
	mov	ax, WORD PTR [edi+3190]

; 1078 :          STB_TEXTEDIT_memmove(state->undo_char, state->undo_char + n, (size_t) ((size_t)state->undo_char_point*sizeof(STB_TEXTEDIT_CHARTYPE)));

	cwde
	add	eax, eax
	push	eax
	lea	eax, DWORD PTR [edi+1188]
	lea	eax, DWORD PTR [eax+ebx*2]
	push	eax
	lea	eax, DWORD PTR [edi+1188]
	push	eax
	call	DWORD PTR __imp__memmove
	xor	eax, eax
	add	esp, 12					; 0000000cH

; 1079 :          for (i=0; i < state->undo_point; ++i)

	xor	ecx, ecx
	cmp	ax, WORD PTR [edi+3186]
	jge	SHORT $LN13@stb_texted
$LL4@stb_texted:

; 1080 :             if (state->undo_rec[i].char_storage >= 0)

	movzx	eax, WORD PTR [esi]
	test	ax, ax
	js	SHORT $LN2@stb_texted

; 1081 :                state->undo_rec[i].char_storage = state->undo_rec[i].char_storage - (short) n; // vsnet05 // @OPTIMIZE: get rid of char_storage and infer it

	sub	eax, ebx
	mov	WORD PTR [esi], ax
$LN2@stb_texted:

; 1079 :          for (i=0; i < state->undo_point; ++i)

	movsx	eax, WORD PTR [edi+3186]
	inc	ecx
	add	esi, 12					; 0000000cH
	cmp	ecx, eax
	jl	SHORT $LL4@stb_texted
$LN13@stb_texted:
	pop	ebx
$LN3@stb_texted:

; 1082 :       }
; 1083 :       --state->undo_point;

	dec	WORD PTR [edi+3186]
	mov	ax, WORD PTR [edi+3186]

; 1084 :       STB_TEXTEDIT_memmove(state->undo_rec, state->undo_rec+1, (size_t) ((size_t)state->undo_point*sizeof(state->undo_rec[0])));

	cwde
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 2
	push	eax
	lea	eax, DWORD PTR [edi+12]
	push	eax
	push	edi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	pop	esi
$LN5@stb_texted:
	pop	edi

; 1085 :    }
; 1086 : }

	pop	ebp
	ret	0
?stb_textedit_discard_undo@ImGuiStb@@YAXPAUStbUndoState@1@@Z ENDP ; ImGuiStb::stb_textedit_discard_undo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\textedit.h
_TEXT	SEGMENT
_state$ = 8						; size = 4
?stb_textedit_flush_redo@ImGuiStb@@YAXPAUStbUndoState@1@@Z PROC ; ImGuiStb::stb_textedit_flush_redo

; 1064 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1065 :    state->redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, 99					; 00000063H
	mov	WORD PTR [eax+3188], cx

; 1066 :    state->redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;

	mov	ecx, 999				; 000003e7H
	mov	WORD PTR [eax+3192], cx

; 1067 : }

	pop	ebp
	ret	0
?stb_textedit_flush_redo@ImGuiStb@@YAXPAUStbUndoState@1@@Z ENDP ; ImGuiStb::stb_textedit_flush_redo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\textedit.h
_TEXT	SEGMENT
_row$1 = -52						; size = 24
_row$2 = -52						; size = 24
_find$3 = -28						; size = 24
_find$4 = -28						; size = 24
tv815 = -4						; size = 4
tv814 = -4						; size = 4
_str$ = 8						; size = 4
_state$ = 12						; size = 4
_start$1$ = 16						; size = 4
_ch$5 = 16						; size = 2
_dx$6 = 16						; size = 4
_dx$7 = 16						; size = 4
_key$ = 16						; size = 4
?stb_textedit_key@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@H@Z PROC ; ImGuiStb::stb_textedit_key

; 701  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 834  : 
; 835  :          if (state->single_line) {

	mov	eax, DWORD PTR _key$[ebp]
	sub	esp, 52					; 00000034H
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _state$[ebp]
$retry$141:

; 702  : retry:
; 703  :    switch (key) {

	cmp	eax, 196608				; 00030000H
	jg	SHORT $LN94@stb_texted
	je	$LN34@stb_texted
	lea	ecx, DWORD PTR [eax-65536]
	cmp	ecx, 13					; 0000000dH
	ja	$LN18@stb_texted
	jmp	DWORD PTR $LN139@stb_texted[ecx*4]
$LN94@stb_texted:
	lea	ecx, DWORD PTR [eax-196609]
	cmp	ecx, 12					; 0000000cH
	ja	$LN18@stb_texted
	jmp	DWORD PTR $LN140@stb_texted[ecx*4]
$LN47@stb_texted:

; 826  :          state->has_preferred_x = 0;
; 827  :          break;
; 828  : 
; 829  :       case STB_TEXTEDIT_K_DOWN:
; 830  :       case STB_TEXTEDIT_K_DOWN | STB_TEXTEDIT_K_SHIFT: {
; 831  :          StbFindState find;
; 832  :          StbTexteditRow row;
; 833  :          int i, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;

	mov	esi, eax
	shr	esi, 17					; 00000011H
	and	esi, 1

; 834  : 
; 835  :          if (state->single_line) {

	cmp	BYTE PTR [edi+16], 0
	mov	DWORD PTR tv815[ebp], esi
	je	$LN48@stb_texted

; 836  :             // on windows, up&down in single-line behave like left&right
; 837  :             key = STB_TEXTEDIT_K_RIGHT | (key & STB_TEXTEDIT_K_SHIFT);

	and	eax, 131072				; 00020000H
	or	eax, 65537				; 00010001H

; 838  :             goto retry;

	jmp	SHORT $retry$141
$LN56@stb_texted:

; 876  :          }
; 877  :          break;
; 878  :       }
; 879  :          
; 880  :       case STB_TEXTEDIT_K_UP:
; 881  :       case STB_TEXTEDIT_K_UP | STB_TEXTEDIT_K_SHIFT: {
; 882  :          StbFindState find;
; 883  :          StbTexteditRow row;
; 884  :          int i, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;

	mov	esi, eax
	shr	esi, 17					; 00000011H
	and	esi, 1

; 885  : 
; 886  :          if (state->single_line) {

	cmp	BYTE PTR [edi+16], 0
	mov	DWORD PTR tv814[ebp], esi
	je	$LN57@stb_texted

; 887  :             // on windows, up&down become left&right
; 888  :             key = STB_TEXTEDIT_K_LEFT | (key & STB_TEXTEDIT_K_SHIFT);

	and	eax, 131072				; 00020000H
	or	eax, 65536				; 00010000H

; 889  :             goto retry;

	jmp	SHORT $retry$141
$LN25@stb_texted:

; 726  :                }
; 727  :             }
; 728  :          }
; 729  :          break;
; 730  :       }
; 731  : 
; 732  : #ifdef STB_TEXTEDIT_K_INSERT
; 733  :       case STB_TEXTEDIT_K_INSERT:
; 734  :          state->insert_mode = !state->insert_mode;
; 735  :          break;
; 736  : #endif
; 737  :          
; 738  :       case STB_TEXTEDIT_K_UNDO:
; 739  :          stb_text_undo(str, state);

	push	edi
	push	DWORD PTR _str$[ebp]
	call	?stb_text_undo@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_text_undo
	add	esp, 8
	mov	BYTE PTR [edi+15], 0
	pop	edi
	pop	esi
	pop	ebx

; 1047 :          state->has_preferred_x = 0;
; 1048 :          break;
; 1049 :       }
; 1050 : 
; 1051 : // @TODO:
; 1052 : //    STB_TEXTEDIT_K_PGUP      - move cursor up a page
; 1053 : //    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
; 1054 :    }
; 1055 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@stb_texted:

; 740  :          state->has_preferred_x = 0;
; 741  :          break;
; 742  : 
; 743  :       case STB_TEXTEDIT_K_REDO:
; 744  :          stb_text_redo(str, state);

	push	edi
	push	DWORD PTR _str$[ebp]
	call	?stb_text_redo@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_text_redo
	add	esp, 8
	mov	BYTE PTR [edi+15], 0
	pop	edi
	pop	esi
	pop	ebx

; 1047 :          state->has_preferred_x = 0;
; 1048 :          break;
; 1049 :       }
; 1050 : 
; 1051 : // @TODO:
; 1052 : //    STB_TEXTEDIT_K_PGUP      - move cursor up a page
; 1053 : //    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
; 1054 :    }
; 1055 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@stb_texted:

; 745  :          state->has_preferred_x = 0;
; 746  :          break;
; 747  : 
; 748  :       case STB_TEXTEDIT_K_LEFT:
; 749  :          // if currently there's a selection, move cursor to start of selection
; 750  :          if (STB_TEXT_HAS_SELECTION(state))

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edi+8]
	je	SHORT $LN28@stb_texted

; 751  :             stb_textedit_move_to_first(state);

	push	edi
	call	?stb_textedit_move_to_first@ImGuiStb@@YAXPAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_move_to_first
	add	esp, 4
	mov	BYTE PTR [edi+15], 0
	pop	edi
	pop	esi
	pop	ebx

; 1047 :          state->has_preferred_x = 0;
; 1048 :          break;
; 1049 :       }
; 1050 : 
; 1051 : // @TODO:
; 1052 : //    STB_TEXTEDIT_K_PGUP      - move cursor up a page
; 1053 : //    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
; 1054 :    }
; 1055 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@stb_texted:

; 752  :          else 
; 753  :             if (state->cursor > 0)

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	jle	$LN133@stb_texted

; 754  :                --state->cursor;

	dec	eax
	mov	BYTE PTR [edi+15], 0
	mov	DWORD PTR [edi], eax
	pop	edi
	pop	esi
	pop	ebx

; 1047 :          state->has_preferred_x = 0;
; 1048 :          break;
; 1049 :       }
; 1050 : 
; 1051 : // @TODO:
; 1052 : //    STB_TEXTEDIT_K_PGUP      - move cursor up a page
; 1053 : //    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
; 1054 :    }
; 1055 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@stb_texted:

; 755  :          state->has_preferred_x = 0;
; 756  :          break;
; 757  : 
; 758  :       case STB_TEXTEDIT_K_RIGHT:
; 759  :          // if currently there's a selection, move cursor to end of selection
; 760  :          if (STB_TEXT_HAS_SELECTION(state))

	mov	eax, DWORD PTR [edi+4]
	mov	esi, DWORD PTR _str$[ebp]
	cmp	eax, DWORD PTR [edi+8]
	je	SHORT $LN32@stb_texted

; 761  :             stb_textedit_move_to_last(str, state);

	push	edi
	push	esi
	call	?stb_textedit_move_to_last@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_move_to_last
	add	esp, 8

; 764  :          stb_textedit_clamp(str, state);

	push	edi
	push	esi
	call	?stb_textedit_clamp@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp
	add	esp, 8
	mov	BYTE PTR [edi+15], 0
	pop	edi
	pop	esi
	pop	ebx

; 1047 :          state->has_preferred_x = 0;
; 1048 :          break;
; 1049 :       }
; 1050 : 
; 1051 : // @TODO:
; 1052 : //    STB_TEXTEDIT_K_PGUP      - move cursor up a page
; 1053 : //    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
; 1054 :    }
; 1055 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN32@stb_texted:

; 762  :          else
; 763  :             ++state->cursor;

	inc	DWORD PTR [edi]

; 764  :          stb_textedit_clamp(str, state);

	push	edi
	push	esi
	call	?stb_textedit_clamp@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp
	add	esp, 8
	mov	BYTE PTR [edi+15], 0
	pop	edi
	pop	esi
	pop	ebx

; 1047 :          state->has_preferred_x = 0;
; 1048 :          break;
; 1049 :       }
; 1050 : 
; 1051 : // @TODO:
; 1052 : //    STB_TEXTEDIT_K_PGUP      - move cursor up a page
; 1053 : //    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
; 1054 :    }
; 1055 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN36@stb_texted:

; 775  :          state->has_preferred_x = 0;
; 776  :          break;
; 777  : 
; 778  : #ifdef STB_TEXTEDIT_MOVEWORDLEFT
; 779  :       case STB_TEXTEDIT_K_WORDLEFT:
; 780  :          if (STB_TEXT_HAS_SELECTION(state))

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edi+8]
	je	SHORT $LN37@stb_texted

; 781  :             stb_textedit_move_to_first(state);

	push	edi
	call	?stb_textedit_move_to_first@ImGuiStb@@YAXPAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_move_to_first
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 1047 :          state->has_preferred_x = 0;
; 1048 :          break;
; 1049 :       }
; 1050 : 
; 1051 : // @TODO:
; 1052 : //    STB_TEXTEDIT_K_PGUP      - move cursor up a page
; 1053 : //    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
; 1054 :    }
; 1055 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN37@stb_texted:

; 782  :          else {
; 783  :             state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);

	push	DWORD PTR [edi]
	mov	esi, DWORD PTR _str$[ebp]
	push	esi
	call	?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImGuiStb@@YAHPAUImGuiTextEditState@@H@Z ; ImGuiStb::STB_TEXTEDIT_MOVEWORDLEFT_IMPL

; 784  :             stb_textedit_clamp( str, state );

	push	edi
	push	esi
	mov	DWORD PTR [edi], eax
	call	?stb_textedit_clamp@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	pop	ebx

; 1047 :          state->has_preferred_x = 0;
; 1048 :          break;
; 1049 :       }
; 1050 : 
; 1051 : // @TODO:
; 1052 : //    STB_TEXTEDIT_K_PGUP      - move cursor up a page
; 1053 : //    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
; 1054 :    }
; 1055 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@stb_texted:

; 796  :          break;
; 797  : #endif
; 798  : 
; 799  : #ifdef STB_TEXTEDIT_MOVEWORDRIGHT
; 800  :       case STB_TEXTEDIT_K_WORDRIGHT:
; 801  :          if (STB_TEXT_HAS_SELECTION(state)) 

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edi+8]
	je	SHORT $LN42@stb_texted

; 802  :             stb_textedit_move_to_last(str, state);

	push	edi
	push	DWORD PTR _str$[ebp]
	call	?stb_textedit_move_to_last@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_move_to_last
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx

; 1047 :          state->has_preferred_x = 0;
; 1048 :          break;
; 1049 :       }
; 1050 : 
; 1051 : // @TODO:
; 1052 : //    STB_TEXTEDIT_K_PGUP      - move cursor up a page
; 1053 : //    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
; 1054 :    }
; 1055 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN42@stb_texted:

; 803  :          else {
; 804  :             state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);

	push	DWORD PTR [edi]
	mov	esi, DWORD PTR _str$[ebp]
	push	esi
	call	?STB_TEXTEDIT_MOVEWORDRIGHT_IMPL@ImGuiStb@@YAHPAUImGuiTextEditState@@H@Z ; ImGuiStb::STB_TEXTEDIT_MOVEWORDRIGHT_IMPL

; 805  :             stb_textedit_clamp( str, state );

	push	edi
	push	esi
	mov	DWORD PTR [edi], eax
	call	?stb_textedit_clamp@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	pop	ebx

; 1047 :          state->has_preferred_x = 0;
; 1048 :          break;
; 1049 :       }
; 1050 : 
; 1051 : // @TODO:
; 1052 : //    STB_TEXTEDIT_K_PGUP      - move cursor up a page
; 1053 : //    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
; 1054 :    }
; 1055 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN73@stb_texted:

; 952  :             }
; 953  :          }
; 954  :          state->has_preferred_x = 0;
; 955  :          break;
; 956  :          
; 957  : #ifdef STB_TEXTEDIT_K_TEXTSTART2
; 958  :       case STB_TEXTEDIT_K_TEXTSTART2:
; 959  : #endif
; 960  :       case STB_TEXTEDIT_K_TEXTSTART:
; 961  :          state->cursor = state->select_start = state->select_end = 0;

	mov	DWORD PTR [edi+8], 0
	mov	DWORD PTR [edi+4], 0
$LN136@stb_texted:
	mov	DWORD PTR [edi], 0
	mov	BYTE PTR [edi+15], 0
	pop	edi
	pop	esi
	pop	ebx

; 1047 :          state->has_preferred_x = 0;
; 1048 :          break;
; 1049 :       }
; 1050 : 
; 1051 : // @TODO:
; 1052 : //    STB_TEXTEDIT_K_PGUP      - move cursor up a page
; 1053 : //    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
; 1054 :    }
; 1055 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN74@stb_texted:

; 962  :          state->has_preferred_x = 0;
; 963  :          break;
; 964  : 
; 965  : #ifdef STB_TEXTEDIT_K_TEXTEND2
; 966  :       case STB_TEXTEDIT_K_TEXTEND2:
; 967  : #endif
; 968  :       case STB_TEXTEDIT_K_TEXTEND:
; 969  :          state->cursor = STB_TEXTEDIT_STRINGLEN(str);

	push	DWORD PTR _str$[ebp]
	call	?STB_TEXTEDIT_STRINGLEN@ImGuiStb@@YAHPBUImGuiTextEditState@@@Z ; ImGuiStb::STB_TEXTEDIT_STRINGLEN
	add	esp, 4
	mov	DWORD PTR [edi], eax

; 970  :          state->select_start = state->select_end = 0;

	mov	DWORD PTR [edi+8], 0
	mov	DWORD PTR [edi+4], 0
	mov	BYTE PTR [edi+15], 0
	pop	edi
	pop	esi
	pop	ebx

; 1047 :          state->has_preferred_x = 0;
; 1048 :          break;
; 1049 :       }
; 1050 : 
; 1051 : // @TODO:
; 1052 : //    STB_TEXTEDIT_K_PGUP      - move cursor up a page
; 1053 : //    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
; 1054 :    }
; 1055 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN77@stb_texted:

; 989  :          state->has_preferred_x = 0;
; 990  :          break;
; 991  : 
; 992  : 
; 993  : #ifdef STB_TEXTEDIT_K_LINESTART2
; 994  :       case STB_TEXTEDIT_K_LINESTART2:
; 995  : #endif
; 996  :       case STB_TEXTEDIT_K_LINESTART:
; 997  :          stb_textedit_clamp(str, state);

	mov	esi, DWORD PTR _str$[ebp]
	push	edi
	push	esi
	call	?stb_textedit_clamp@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp

; 998  :          stb_textedit_move_to_first(state);

	push	edi
	call	?stb_textedit_move_to_first@ImGuiStb@@YAXPAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_move_to_first
	add	esp, 12					; 0000000cH

; 999  :          if (state->single_line)

	cmp	BYTE PTR [edi+16], 0
	jne	SHORT $LN136@stb_texted

; 1000 :             state->cursor = 0;
; 1001 :          else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor-1) != STB_TEXTEDIT_NEWLINE)

	cmp	DWORD PTR [edi], 0
	jle	$LN133@stb_texted
	mov	dx, WORD PTR ?STB_TEXTEDIT_NEWLINE@ImGuiStb@@3GA
	npad	4
$LL10@stb_texted:
	mov	eax, DWORD PTR [edi]
	dec	eax
	push	eax
	push	esi
	call	?STB_TEXTEDIT_GETCHAR@ImGuiStb@@YAGPBUImGuiTextEditState@@H@Z ; ImGuiStb::STB_TEXTEDIT_GETCHAR
	add	esp, 8
	cmp	ax, dx
	je	$LN133@stb_texted

; 1002 :             --state->cursor;

	dec	DWORD PTR [edi]
	cmp	DWORD PTR [edi], 0
	jg	SHORT $LL10@stb_texted

; 725  :                   state->has_preferred_x = 0;

	mov	BYTE PTR [edi+15], 0
	pop	edi
	pop	esi
	pop	ebx

; 1047 :          state->has_preferred_x = 0;
; 1048 :          break;
; 1049 :       }
; 1050 : 
; 1051 : // @TODO:
; 1052 : //    STB_TEXTEDIT_K_PGUP      - move cursor up a page
; 1053 : //    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
; 1054 :    }
; 1055 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN80@stb_texted:

; 1003 :          state->has_preferred_x = 0;
; 1004 :          break;
; 1005 : 
; 1006 : #ifdef STB_TEXTEDIT_K_LINEEND2
; 1007 :       case STB_TEXTEDIT_K_LINEEND2:
; 1008 : #endif
; 1009 :       case STB_TEXTEDIT_K_LINEEND: {
; 1010 :          int n = STB_TEXTEDIT_STRINGLEN(str);

	mov	ebx, DWORD PTR _str$[ebp]
	push	ebx
	call	?STB_TEXTEDIT_STRINGLEN@ImGuiStb@@YAHPBUImGuiTextEditState@@@Z ; ImGuiStb::STB_TEXTEDIT_STRINGLEN

; 1011 :          stb_textedit_clamp(str, state);

	push	edi
	push	ebx
	mov	esi, eax
	call	?stb_textedit_clamp@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp

; 1012 :          stb_textedit_move_to_first(state);

	push	edi
	call	?stb_textedit_move_to_first@ImGuiStb@@YAXPAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_move_to_first
	add	esp, 16					; 00000010H

; 1013 :          if (state->single_line)

	cmp	BYTE PTR [edi+16], 0
	je	SHORT $LN98@stb_texted

; 1014 :              state->cursor = n;

	mov	DWORD PTR [edi], esi
	mov	BYTE PTR [edi+15], 0
	pop	edi
	pop	esi
	pop	ebx

; 1047 :          state->has_preferred_x = 0;
; 1048 :          break;
; 1049 :       }
; 1050 : 
; 1051 : // @TODO:
; 1052 : //    STB_TEXTEDIT_K_PGUP      - move cursor up a page
; 1053 : //    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
; 1054 :    }
; 1055 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN98@stb_texted:

; 1015 :          else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)

	cmp	DWORD PTR [edi], esi
	jge	$LN133@stb_texted
	npad	2
$LL12@stb_texted:
	mov	edx, DWORD PTR [edi]
	push	edx
	push	ebx
	call	?STB_TEXTEDIT_GETCHAR@ImGuiStb@@YAGPBUImGuiTextEditState@@H@Z ; ImGuiStb::STB_TEXTEDIT_GETCHAR
	add	esp, 8
	cmp	ax, WORD PTR ?STB_TEXTEDIT_NEWLINE@ImGuiStb@@3GA
	je	$LN133@stb_texted

; 1016 :              ++state->cursor;

	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [edi], eax
	cmp	eax, esi
	jl	SHORT $LL12@stb_texted

; 725  :                   state->has_preferred_x = 0;

	mov	BYTE PTR [edi+15], 0
	pop	edi
	pop	esi
	pop	ebx

; 1047 :          state->has_preferred_x = 0;
; 1048 :          break;
; 1049 :       }
; 1050 : 
; 1051 : // @TODO:
; 1052 : //    STB_TEXTEDIT_K_PGUP      - move cursor up a page
; 1053 : //    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
; 1054 :    }
; 1055 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@stb_texted:

; 765  :          state->has_preferred_x = 0;
; 766  :          break;
; 767  : 
; 768  :       case STB_TEXTEDIT_K_LEFT | STB_TEXTEDIT_K_SHIFT:
; 769  :          stb_textedit_clamp(str, state);

	push	edi
	push	DWORD PTR _str$[ebp]
	call	?stb_textedit_clamp@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp

; 770  :          stb_textedit_prep_selection_at_cursor(state);

	push	edi
	call	?stb_textedit_prep_selection_at_cursor@ImGuiStb@@YAXPAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_prep_selection_at_cursor

; 771  :          // move selection left
; 772  :          if (state->select_end > 0)

	mov	eax, DWORD PTR [edi+8]
	add	esp, 12					; 0000000cH
	test	eax, eax
	jle	SHORT $LN35@stb_texted

; 773  :             --state->select_end;

	dec	eax
	mov	DWORD PTR [edi+8], eax
$LN35@stb_texted:

; 774  :          state->cursor = state->select_end;

	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [edi], eax
	mov	BYTE PTR [edi+15], 0
	pop	edi
	pop	esi
	pop	ebx

; 1047 :          state->has_preferred_x = 0;
; 1048 :          break;
; 1049 :       }
; 1050 : 
; 1051 : // @TODO:
; 1052 : //    STB_TEXTEDIT_K_PGUP      - move cursor up a page
; 1053 : //    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
; 1054 :    }
; 1055 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN48@stb_texted:

; 839  :          }
; 840  : 
; 841  :          if (sel)

	mov	ebx, DWORD PTR _str$[ebp]
	test	esi, esi
	je	SHORT $LN49@stb_texted

; 842  :             stb_textedit_prep_selection_at_cursor(state);

	push	edi
	call	?stb_textedit_prep_selection_at_cursor@ImGuiStb@@YAXPAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_prep_selection_at_cursor
	add	esp, 4
	jmp	SHORT $LN51@stb_texted
$LN49@stb_texted:

; 843  :          else if (STB_TEXT_HAS_SELECTION(state))

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edi+8]
	je	SHORT $LN51@stb_texted

; 844  :             stb_textedit_move_to_last(str,state);

	push	edi
	push	ebx
	call	?stb_textedit_move_to_last@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_move_to_last
	add	esp, 8
$LN51@stb_texted:

; 845  : 
; 846  :          // compute current position of cursor point
; 847  :          stb_textedit_clamp(str, state);

	push	edi
	push	ebx
	call	?stb_textedit_clamp@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp

; 848  :          stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);

	movzx	eax, BYTE PTR [edi+16]
	push	eax
	push	DWORD PTR [edi]
	lea	eax, DWORD PTR _find$4[ebp]
	push	ebx
	push	eax
	call	?stb_textedit_find_charpos@ImGuiStb@@YAXPAUStbFindState@1@PAUImGuiTextEditState@@HH@Z ; ImGuiStb::stb_textedit_find_charpos

; 849  : 
; 850  :          // now find character position down a row
; 851  :          if (find.length) {

	mov	ecx, DWORD PTR _find$4[ebp+16]
	add	esp, 24					; 00000018H
	test	ecx, ecx
	je	$LN24@stb_texted

; 852  :             float goal_x = state->has_preferred_x ? state->preferred_x : find.x;

	cmp	BYTE PTR [edi+15], 0
	je	SHORT $LN90@stb_texted
	movss	xmm5, DWORD PTR [edi+20]
	jmp	SHORT $LN91@stb_texted
$LN90@stb_texted:
	movss	xmm5, DWORD PTR _find$4[ebp]
$LN91@stb_texted:

; 853  :             float x;
; 854  :             int start = find.first_char + find.length;

	mov	eax, DWORD PTR _find$4[ebp+12]
	add	eax, ecx

; 855  :             state->cursor = start;
; 856  :             STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);

	push	eax
	mov	DWORD PTR _start$1$[ebp], eax
	mov	DWORD PTR [edi], eax
	lea	eax, DWORD PTR _row$2[ebp]
	push	ebx
	push	eax
	call	?STB_TEXTEDIT_LAYOUTROW@ImGuiStb@@YAXPAUStbTexteditRow@1@PAUImGuiTextEditState@@H@Z ; ImGuiStb::STB_TEXTEDIT_LAYOUTROW

; 857  :             x = row.x0;

	movss	xmm1, DWORD PTR _row$2[ebp]

; 858  :             for (i=0; i < row.num_chars; ++i) {

	xor	ebx, ebx
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _row$2[ebp+20], ebx
	jle	SHORT $LN103@stb_texted
	movss	xmm2, DWORD PTR __real@bf800000
	mov	esi, DWORD PTR _start$1$[ebp]
$LL6@stb_texted:

; 859  :                float dx = STB_TEXTEDIT_GETWIDTH(str, start, i);

	push	ebx
	push	esi
	push	DWORD PTR _str$[ebp]
	call	?STB_TEXTEDIT_GETWIDTH@ImGuiStb@@YAMPAUImGuiTextEditState@@HH@Z ; ImGuiStb::STB_TEXTEDIT_GETWIDTH
	fstp	DWORD PTR _dx$7[ebp]

; 860  :                #ifdef STB_TEXTEDIT_GETWIDTH_NEWLINE
; 861  :                if (dx == STB_TEXTEDIT_GETWIDTH_NEWLINE)

	movss	xmm0, DWORD PTR _dx$7[ebp]
	add	esp, 12					; 0000000cH
	ucomiss	xmm0, xmm2
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN129@stb_texted

; 862  :                   break;
; 863  :                #endif
; 864  :                x += dx;

	addss	xmm1, xmm0

; 865  :                if (x > goal_x)

	comiss	xmm1, xmm5
	ja	SHORT $LN129@stb_texted

; 866  :                   break;
; 867  :                ++state->cursor;

	inc	DWORD PTR [edi]
	inc	ebx
	cmp	ebx, DWORD PTR _row$2[ebp+20]
	jl	SHORT $LL6@stb_texted
$LN129@stb_texted:
	mov	esi, DWORD PTR tv815[ebp]
$LN103@stb_texted:

; 868  :             }
; 869  :             stb_textedit_clamp(str, state);

	push	edi
	push	DWORD PTR _str$[ebp]
	call	?stb_textedit_clamp@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp
	add	esp, 8

; 870  : 
; 871  :             state->has_preferred_x = 1;

	mov	BYTE PTR [edi+15], 1

; 872  :             state->preferred_x = goal_x;

	movss	DWORD PTR [edi+20], xmm5
	test	esi, esi

; 873  : 
; 874  :             if (sel)

	je	$LN24@stb_texted

; 875  :                state->select_end = state->cursor;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [edi+8], eax
	pop	edi
	pop	esi
	pop	ebx

; 1047 :          state->has_preferred_x = 0;
; 1048 :          break;
; 1049 :       }
; 1050 : 
; 1051 : // @TODO:
; 1052 : //    STB_TEXTEDIT_K_PGUP      - move cursor up a page
; 1053 : //    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
; 1054 :    }
; 1055 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN57@stb_texted:
	test	esi, esi

; 890  :          }
; 891  : 
; 892  :          if (sel)

	je	SHORT $LN58@stb_texted

; 893  :             stb_textedit_prep_selection_at_cursor(state);

	push	edi
	call	?stb_textedit_prep_selection_at_cursor@ImGuiStb@@YAXPAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_prep_selection_at_cursor
	jmp	SHORT $LN134@stb_texted
$LN58@stb_texted:

; 894  :          else if (STB_TEXT_HAS_SELECTION(state))

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edi+8]
	je	SHORT $LN60@stb_texted

; 895  :             stb_textedit_move_to_first(state);

	push	edi
	call	?stb_textedit_move_to_first@ImGuiStb@@YAXPAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_move_to_first
$LN134@stb_texted:
	add	esp, 4
$LN60@stb_texted:

; 896  : 
; 897  :          // compute current position of cursor point
; 898  :          stb_textedit_clamp(str, state);

	mov	ebx, DWORD PTR _str$[ebp]
	push	edi
	push	ebx
	call	?stb_textedit_clamp@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp

; 899  :          stb_textedit_find_charpos(&find, str, state->cursor, state->single_line);

	movzx	eax, BYTE PTR [edi+16]
	push	eax
	push	DWORD PTR [edi]
	lea	eax, DWORD PTR _find$3[ebp]
	push	ebx
	push	eax
	call	?stb_textedit_find_charpos@ImGuiStb@@YAXPAUStbFindState@1@PAUImGuiTextEditState@@HH@Z ; ImGuiStb::stb_textedit_find_charpos

; 900  : 
; 901  :          // can only go up if there's a previous row
; 902  :          if (find.prev_first != find.first_char) {

	mov	eax, DWORD PTR _find$3[ebp+20]
	add	esp, 24					; 00000018H
	cmp	eax, DWORD PTR _find$3[ebp+12]
	je	$LN24@stb_texted

; 903  :             // now find character position up a row
; 904  :             float goal_x = state->has_preferred_x ? state->preferred_x : find.x;

	cmp	BYTE PTR [edi+15], 0
	je	SHORT $LN92@stb_texted
	movss	xmm5, DWORD PTR [edi+20]
	jmp	SHORT $LN93@stb_texted
$LN92@stb_texted:
	movss	xmm5, DWORD PTR _find$3[ebp]
$LN93@stb_texted:

; 905  :             float x;
; 906  :             state->cursor = find.prev_first;
; 907  :             STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);

	push	eax
	mov	DWORD PTR [edi], eax
	lea	eax, DWORD PTR _row$1[ebp]
	push	ebx
	push	eax
	call	?STB_TEXTEDIT_LAYOUTROW@ImGuiStb@@YAXPAUStbTexteditRow@1@PAUImGuiTextEditState@@H@Z ; ImGuiStb::STB_TEXTEDIT_LAYOUTROW

; 908  :             x = row.x0;

	movss	xmm1, DWORD PTR _row$1[ebp]

; 909  :             for (i=0; i < row.num_chars; ++i) {

	xor	ebx, ebx
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _row$1[ebp+20], ebx
	jle	$LN103@stb_texted
	movss	xmm2, DWORD PTR __real@bf800000
	mov	esi, DWORD PTR _find$3[ebp+20]
$LL9@stb_texted:

; 910  :                float dx = STB_TEXTEDIT_GETWIDTH(str, find.prev_first, i);

	push	ebx
	push	esi
	push	DWORD PTR _str$[ebp]
	call	?STB_TEXTEDIT_GETWIDTH@ImGuiStb@@YAMPAUImGuiTextEditState@@HH@Z ; ImGuiStb::STB_TEXTEDIT_GETWIDTH
	fstp	DWORD PTR _dx$6[ebp]

; 911  :                #ifdef STB_TEXTEDIT_GETWIDTH_NEWLINE
; 912  :                if (dx == STB_TEXTEDIT_GETWIDTH_NEWLINE)

	movss	xmm0, DWORD PTR _dx$6[ebp]
	add	esp, 12					; 0000000cH
	ucomiss	xmm0, xmm2
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN130@stb_texted

; 913  :                   break;
; 914  :                #endif
; 915  :                x += dx;

	addss	xmm1, xmm0

; 916  :                if (x > goal_x)

	comiss	xmm1, xmm5
	ja	SHORT $LN130@stb_texted

; 917  :                   break;
; 918  :                ++state->cursor;

	inc	DWORD PTR [edi]
	inc	ebx
	cmp	ebx, DWORD PTR _row$1[ebp+20]
	jl	SHORT $LL9@stb_texted
$LN130@stb_texted:
	mov	esi, DWORD PTR tv814[ebp]

; 919  :             }
; 920  :             stb_textedit_clamp(str, state);
; 921  : 
; 922  :             state->has_preferred_x = 1;
; 923  :             state->preferred_x = goal_x;
; 924  : 
; 925  :             if (sel)
; 926  :                state->select_end = state->cursor;
; 927  :          }
; 928  :          break;

	jmp	$LN103@stb_texted
$LN39@stb_texted:

; 785  :          }
; 786  :          break;
; 787  : 
; 788  :       case STB_TEXTEDIT_K_WORDLEFT | STB_TEXTEDIT_K_SHIFT:
; 789  :          if( !STB_TEXT_HAS_SELECTION( state ) )

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edi+8]
	jne	SHORT $LN40@stb_texted

; 790  :             stb_textedit_prep_selection_at_cursor(state);

	push	edi
	call	?stb_textedit_prep_selection_at_cursor@ImGuiStb@@YAXPAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_prep_selection_at_cursor
	add	esp, 4
$LN40@stb_texted:

; 791  : 
; 792  :          state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);

	push	DWORD PTR [edi]
	mov	esi, DWORD PTR _str$[ebp]
	push	esi
	call	?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImGuiStb@@YAHPAUImGuiTextEditState@@H@Z ; ImGuiStb::STB_TEXTEDIT_MOVEWORDLEFT_IMPL

; 793  :          state->select_end = state->cursor;
; 794  : 
; 795  :          stb_textedit_clamp( str, state );

	push	edi
	push	esi
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+8], eax
	call	?stb_textedit_clamp@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	pop	ebx

; 1047 :          state->has_preferred_x = 0;
; 1048 :          break;
; 1049 :       }
; 1050 : 
; 1051 : // @TODO:
; 1052 : //    STB_TEXTEDIT_K_PGUP      - move cursor up a page
; 1053 : //    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
; 1054 :    }
; 1055 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN44@stb_texted:

; 806  :          }
; 807  :          break;
; 808  : 
; 809  :       case STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT:
; 810  :          if( !STB_TEXT_HAS_SELECTION( state ) )

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edi+8]
	jne	SHORT $LN45@stb_texted

; 811  :             stb_textedit_prep_selection_at_cursor(state);

	push	edi
	call	?stb_textedit_prep_selection_at_cursor@ImGuiStb@@YAXPAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_prep_selection_at_cursor
	add	esp, 4
$LN45@stb_texted:

; 812  : 
; 813  :          state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);

	push	DWORD PTR [edi]
	mov	esi, DWORD PTR _str$[ebp]
	push	esi
	call	?STB_TEXTEDIT_MOVEWORDRIGHT_IMPL@ImGuiStb@@YAHPAUImGuiTextEditState@@H@Z ; ImGuiStb::STB_TEXTEDIT_MOVEWORDRIGHT_IMPL

; 814  :          state->select_end = state->cursor;
; 815  : 
; 816  :          stb_textedit_clamp( str, state );

	push	edi
	push	esi
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+8], eax
	call	?stb_textedit_clamp@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	pop	ebx

; 1047 :          state->has_preferred_x = 0;
; 1048 :          break;
; 1049 :       }
; 1050 : 
; 1051 : // @TODO:
; 1052 : //    STB_TEXTEDIT_K_PGUP      - move cursor up a page
; 1053 : //    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
; 1054 :    }
; 1055 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN46@stb_texted:

; 817  :          break;
; 818  : #endif
; 819  : 
; 820  :       case STB_TEXTEDIT_K_RIGHT | STB_TEXTEDIT_K_SHIFT:
; 821  :          stb_textedit_prep_selection_at_cursor(state);

	push	edi
	call	?stb_textedit_prep_selection_at_cursor@ImGuiStb@@YAXPAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_prep_selection_at_cursor

; 822  :          // move selection right
; 823  :          ++state->select_end;

	inc	DWORD PTR [edi+8]

; 824  :          stb_textedit_clamp(str, state);

	push	edi
	push	DWORD PTR _str$[ebp]
	call	?stb_textedit_clamp@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp

; 825  :          state->cursor = state->select_end;

	mov	eax, DWORD PTR [edi+8]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi], eax
	mov	BYTE PTR [edi+15], 0
	pop	edi
	pop	esi
	pop	ebx

; 1047 :          state->has_preferred_x = 0;
; 1048 :          break;
; 1049 :       }
; 1050 : 
; 1051 : // @TODO:
; 1052 : //    STB_TEXTEDIT_K_PGUP      - move cursor up a page
; 1053 : //    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
; 1054 :    }
; 1055 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN65@stb_texted:

; 929  :       }
; 930  : 
; 931  :       case STB_TEXTEDIT_K_DELETE:
; 932  :       case STB_TEXTEDIT_K_DELETE | STB_TEXTEDIT_K_SHIFT:
; 933  :          if (STB_TEXT_HAS_SELECTION(state))

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edi+8]
	je	SHORT $LN66@stb_texted

; 934  :             stb_textedit_delete_selection(str, state);

	push	edi
$LN137@stb_texted:
	push	DWORD PTR _str$[ebp]
	call	?stb_textedit_delete_selection@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_delete_selection
	add	esp, 8
	mov	BYTE PTR [edi+15], 0
	pop	edi
	pop	esi
	pop	ebx

; 1047 :          state->has_preferred_x = 0;
; 1048 :          break;
; 1049 :       }
; 1050 : 
; 1051 : // @TODO:
; 1052 : //    STB_TEXTEDIT_K_PGUP      - move cursor up a page
; 1053 : //    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
; 1054 :    }
; 1055 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN66@stb_texted:

; 935  :          else {
; 936  :             int n = STB_TEXTEDIT_STRINGLEN(str);

	mov	edx, DWORD PTR _str$[ebp]

; 937  :             if (state->cursor < n)

	mov	ecx, DWORD PTR [edi]
	push	edx
	call	?STB_TEXTEDIT_STRINGLEN@ImGuiStb@@YAHPBUImGuiTextEditState@@@Z ; ImGuiStb::STB_TEXTEDIT_STRINGLEN
	add	esp, 4
	cmp	ecx, eax
	jge	$LN133@stb_texted

; 938  :                stb_textedit_delete(str, state, state->cursor, 1);

	push	1
	push	ecx
	push	edi
	push	edx
	call	?stb_textedit_delete@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@HH@Z ; ImGuiStb::stb_textedit_delete
	add	esp, 16					; 00000010H
	mov	BYTE PTR [edi+15], 0
	pop	edi
	pop	esi
	pop	ebx

; 1047 :          state->has_preferred_x = 0;
; 1048 :          break;
; 1049 :       }
; 1050 : 
; 1051 : // @TODO:
; 1052 : //    STB_TEXTEDIT_K_PGUP      - move cursor up a page
; 1053 : //    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
; 1054 :    }
; 1055 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN69@stb_texted:

; 939  :          }
; 940  :          state->has_preferred_x = 0;
; 941  :          break;
; 942  : 
; 943  :       case STB_TEXTEDIT_K_BACKSPACE:
; 944  :       case STB_TEXTEDIT_K_BACKSPACE | STB_TEXTEDIT_K_SHIFT:
; 945  :          if (STB_TEXT_HAS_SELECTION(state))

	mov	eax, DWORD PTR [edi+4]

; 946  :             stb_textedit_delete_selection(str, state);

	push	edi
	cmp	eax, DWORD PTR [edi+8]
	jne	SHORT $LN137@stb_texted

; 947  :          else {
; 948  :             stb_textedit_clamp(str, state);

	mov	esi, DWORD PTR _str$[ebp]
	push	esi
	call	?stb_textedit_clamp@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp

; 949  :             if (state->cursor > 0) {

	mov	eax, DWORD PTR [edi]
	add	esp, 8
	test	eax, eax
	jle	$LN133@stb_texted

; 950  :                stb_textedit_delete(str, state, state->cursor-1, 1);

	push	1
	dec	eax
	push	eax
	push	edi
	push	esi
	call	?stb_textedit_delete@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@HH@Z ; ImGuiStb::stb_textedit_delete
	add	esp, 16					; 00000010H
	mov	BYTE PTR [edi+15], 0

; 951  :                --state->cursor;

	dec	DWORD PTR [edi]
	pop	edi
	pop	esi
	pop	ebx

; 1047 :          state->has_preferred_x = 0;
; 1048 :          break;
; 1049 :       }
; 1050 : 
; 1051 : // @TODO:
; 1052 : //    STB_TEXTEDIT_K_PGUP      - move cursor up a page
; 1053 : //    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
; 1054 :    }
; 1055 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN75@stb_texted:

; 971  :          state->has_preferred_x = 0;
; 972  :          break;
; 973  :         
; 974  : #ifdef STB_TEXTEDIT_K_TEXTSTART2
; 975  :       case STB_TEXTEDIT_K_TEXTSTART2 | STB_TEXTEDIT_K_SHIFT:
; 976  : #endif
; 977  :       case STB_TEXTEDIT_K_TEXTSTART | STB_TEXTEDIT_K_SHIFT:
; 978  :          stb_textedit_prep_selection_at_cursor(state);

	push	edi
	call	?stb_textedit_prep_selection_at_cursor@ImGuiStb@@YAXPAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_prep_selection_at_cursor
	add	esp, 4

; 979  :          state->cursor = state->select_end = 0;

	mov	DWORD PTR [edi+8], 0
	mov	DWORD PTR [edi], 0
	mov	BYTE PTR [edi+15], 0
	pop	edi
	pop	esi
	pop	ebx

; 1047 :          state->has_preferred_x = 0;
; 1048 :          break;
; 1049 :       }
; 1050 : 
; 1051 : // @TODO:
; 1052 : //    STB_TEXTEDIT_K_PGUP      - move cursor up a page
; 1053 : //    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
; 1054 :    }
; 1055 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN76@stb_texted:

; 980  :          state->has_preferred_x = 0;
; 981  :          break;
; 982  : 
; 983  : #ifdef STB_TEXTEDIT_K_TEXTEND2
; 984  :       case STB_TEXTEDIT_K_TEXTEND2 | STB_TEXTEDIT_K_SHIFT:
; 985  : #endif
; 986  :       case STB_TEXTEDIT_K_TEXTEND | STB_TEXTEDIT_K_SHIFT:
; 987  :          stb_textedit_prep_selection_at_cursor(state);

	push	edi
	call	?stb_textedit_prep_selection_at_cursor@ImGuiStb@@YAXPAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_prep_selection_at_cursor

; 988  :          state->cursor = state->select_end = STB_TEXTEDIT_STRINGLEN(str);

	push	DWORD PTR _str$[ebp]
	call	?STB_TEXTEDIT_STRINGLEN@ImGuiStb@@YAHPBUImGuiTextEditState@@@Z ; ImGuiStb::STB_TEXTEDIT_STRINGLEN
	add	esp, 8
	mov	DWORD PTR [edi+8], eax
	mov	DWORD PTR [edi], eax
	mov	BYTE PTR [edi+15], 0
	pop	edi
	pop	esi
	pop	ebx

; 1047 :          state->has_preferred_x = 0;
; 1048 :          break;
; 1049 :       }
; 1050 : 
; 1051 : // @TODO:
; 1052 : //    STB_TEXTEDIT_K_PGUP      - move cursor up a page
; 1053 : //    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
; 1054 :    }
; 1055 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN83@stb_texted:

; 1017 :          state->has_preferred_x = 0;
; 1018 :          break;
; 1019 :       }
; 1020 : 
; 1021 : #ifdef STB_TEXTEDIT_K_LINESTART2
; 1022 :       case STB_TEXTEDIT_K_LINESTART2 | STB_TEXTEDIT_K_SHIFT:
; 1023 : #endif
; 1024 :       case STB_TEXTEDIT_K_LINESTART | STB_TEXTEDIT_K_SHIFT:
; 1025 :          stb_textedit_clamp(str, state);

	mov	esi, DWORD PTR _str$[ebp]
	push	edi
	push	esi
	call	?stb_textedit_clamp@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp

; 1026 :          stb_textedit_prep_selection_at_cursor(state);

	push	edi
	call	?stb_textedit_prep_selection_at_cursor@ImGuiStb@@YAXPAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_prep_selection_at_cursor
	add	esp, 12					; 0000000cH

; 1027 :          if (state->single_line)

	cmp	BYTE PTR [edi+16], 0
	je	SHORT $LN101@stb_texted

; 1028 :             state->cursor = 0;

	mov	DWORD PTR [edi], 0

; 1031 :          state->select_end = state->cursor;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [edi+8], eax
	mov	BYTE PTR [edi+15], 0
	pop	edi
	pop	esi
	pop	ebx

; 1047 :          state->has_preferred_x = 0;
; 1048 :          break;
; 1049 :       }
; 1050 : 
; 1051 : // @TODO:
; 1052 : //    STB_TEXTEDIT_K_PGUP      - move cursor up a page
; 1053 : //    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
; 1054 :    }
; 1055 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN101@stb_texted:

; 1029 :          else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor-1) != STB_TEXTEDIT_NEWLINE)

	cmp	DWORD PTR [edi], 0
	jle	SHORT $LN131@stb_texted
	mov	dx, WORD PTR ?STB_TEXTEDIT_NEWLINE@ImGuiStb@@3GA
$LL14@stb_texted:
	mov	eax, DWORD PTR [edi]
	dec	eax
	push	eax
	push	esi
	call	?STB_TEXTEDIT_GETCHAR@ImGuiStb@@YAGPBUImGuiTextEditState@@H@Z ; ImGuiStb::STB_TEXTEDIT_GETCHAR
	add	esp, 8
	cmp	ax, dx
	je	SHORT $LN131@stb_texted

; 1030 :             --state->cursor;

	dec	DWORD PTR [edi]
	cmp	DWORD PTR [edi], 0
	jg	SHORT $LL14@stb_texted
$LN131@stb_texted:

; 1031 :          state->select_end = state->cursor;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [edi+8], eax
	mov	BYTE PTR [edi+15], 0
	pop	edi
	pop	esi
	pop	ebx

; 1047 :          state->has_preferred_x = 0;
; 1048 :          break;
; 1049 :       }
; 1050 : 
; 1051 : // @TODO:
; 1052 : //    STB_TEXTEDIT_K_PGUP      - move cursor up a page
; 1053 : //    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
; 1054 :    }
; 1055 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN86@stb_texted:

; 1032 :          state->has_preferred_x = 0;
; 1033 :          break;
; 1034 : 
; 1035 : #ifdef STB_TEXTEDIT_K_LINEEND2
; 1036 :       case STB_TEXTEDIT_K_LINEEND2 | STB_TEXTEDIT_K_SHIFT:
; 1037 : #endif
; 1038 :       case STB_TEXTEDIT_K_LINEEND | STB_TEXTEDIT_K_SHIFT: {
; 1039 :          int n = STB_TEXTEDIT_STRINGLEN(str);

	mov	ebx, DWORD PTR _str$[ebp]
	push	ebx
	call	?STB_TEXTEDIT_STRINGLEN@ImGuiStb@@YAHPBUImGuiTextEditState@@@Z ; ImGuiStb::STB_TEXTEDIT_STRINGLEN

; 1040 :          stb_textedit_clamp(str, state);

	push	edi
	push	ebx
	mov	esi, eax
	call	?stb_textedit_clamp@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp

; 1041 :          stb_textedit_prep_selection_at_cursor(state);

	push	edi
	call	?stb_textedit_prep_selection_at_cursor@ImGuiStb@@YAXPAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_prep_selection_at_cursor
	add	esp, 16					; 00000010H

; 1042 :          if (state->single_line)

	cmp	BYTE PTR [edi+16], 0
	je	SHORT $LN102@stb_texted

; 1043 :              state->cursor = n;

	mov	eax, esi
	mov	DWORD PTR [edi], esi
	mov	DWORD PTR [edi+8], eax
	mov	BYTE PTR [edi+15], 0
	pop	edi
	pop	esi
	pop	ebx

; 1047 :          state->has_preferred_x = 0;
; 1048 :          break;
; 1049 :       }
; 1050 : 
; 1051 : // @TODO:
; 1052 : //    STB_TEXTEDIT_K_PGUP      - move cursor up a page
; 1053 : //    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
; 1054 :    }
; 1055 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN102@stb_texted:

; 1044 :          else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)

	cmp	DWORD PTR [edi], esi
	jge	SHORT $LN131@stb_texted
$LL16@stb_texted:
	mov	edx, DWORD PTR [edi]
	push	edx
	push	ebx
	call	?STB_TEXTEDIT_GETCHAR@ImGuiStb@@YAGPBUImGuiTextEditState@@H@Z ; ImGuiStb::STB_TEXTEDIT_GETCHAR
	add	esp, 8
	cmp	ax, WORD PTR ?STB_TEXTEDIT_NEWLINE@ImGuiStb@@3GA
	je	SHORT $LN131@stb_texted

; 1045 :             ++state->cursor;

	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [edi], eax
	cmp	eax, esi
	jl	SHORT $LL16@stb_texted

; 1046 :          state->select_end = state->cursor;

	mov	DWORD PTR [edi+8], eax
	mov	BYTE PTR [edi+15], 0
	pop	edi
	pop	esi
	pop	ebx

; 1047 :          state->has_preferred_x = 0;
; 1048 :          break;
; 1049 :       }
; 1050 : 
; 1051 : // @TODO:
; 1052 : //    STB_TEXTEDIT_K_PGUP      - move cursor up a page
; 1053 : //    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
; 1054 :    }
; 1055 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN18@stb_texted:

; 704  :       default: {
; 705  :          int c = STB_TEXTEDIT_KEYTOTEXT(key);

	push	eax
	call	?STB_TEXTEDIT_KEYTOTEXT@ImGuiStb@@YAHH@Z ; ImGuiStb::STB_TEXTEDIT_KEYTOTEXT
	add	esp, 4

; 706  :          if (c > 0) {

	test	eax, eax
	jle	$LN24@stb_texted

; 707  :             STB_TEXTEDIT_CHARTYPE ch = (STB_TEXTEDIT_CHARTYPE) c;

	movzx	ecx, ax
	mov	DWORD PTR _ch$5[ebp], ecx

; 708  : 
; 709  :             // can't add newline in single-line mode
; 710  :             if (c == '\n' && state->single_line)

	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN20@stb_texted
	cmp	BYTE PTR [edi+16], 0
	jne	$LN24@stb_texted
$LN20@stb_texted:

; 711  :                break;
; 712  : 
; 713  :             if (state->insert_mode && !STB_TEXT_HAS_SELECTION(state) && state->cursor < STB_TEXTEDIT_STRINGLEN(str)) {

	cmp	BYTE PTR [edi+12], 0
	mov	esi, DWORD PTR _str$[ebp]
	je	SHORT $LN21@stb_texted
	mov	eax, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edi+8]
	jne	SHORT $LN21@stb_texted
	mov	ecx, DWORD PTR [edi]
	push	esi
	call	?STB_TEXTEDIT_STRINGLEN@ImGuiStb@@YAHPBUImGuiTextEditState@@@Z ; ImGuiStb::STB_TEXTEDIT_STRINGLEN
	add	esp, 4
	cmp	ecx, eax
	jge	SHORT $LN21@stb_texted

; 714  :                stb_text_makeundo_replace(str, state, state->cursor, 1, 1);

	push	1
	push	1
	push	ecx
	push	edi
	push	esi
	call	?stb_text_makeundo_replace@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@HHH@Z ; ImGuiStb::stb_text_makeundo_replace

; 715  :                STB_TEXTEDIT_DELETECHARS(str, state->cursor, 1);

	push	1
	push	DWORD PTR [edi]
	push	esi
	call	?STB_TEXTEDIT_DELETECHARS@ImGuiStb@@YAXPAUImGuiTextEditState@@HH@Z ; ImGuiStb::STB_TEXTEDIT_DELETECHARS

; 716  :                if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, &ch, 1)) {

	push	1
	lea	eax, DWORD PTR _ch$5[ebp]
	push	eax
	push	DWORD PTR [edi]
	push	esi
	call	?STB_TEXTEDIT_INSERTCHARS@ImGuiStb@@YA_NPAUImGuiTextEditState@@HPBGH@Z ; ImGuiStb::STB_TEXTEDIT_INSERTCHARS
	add	esp, 48					; 00000030H
	test	al, al
	je	SHORT $LN24@stb_texted

; 724  :                   ++state->cursor;

	inc	DWORD PTR [edi]

; 725  :                   state->has_preferred_x = 0;

	mov	BYTE PTR [edi+15], 0
	pop	edi
	pop	esi
	pop	ebx

; 1047 :          state->has_preferred_x = 0;
; 1048 :          break;
; 1049 :       }
; 1050 : 
; 1051 : // @TODO:
; 1052 : //    STB_TEXTEDIT_K_PGUP      - move cursor up a page
; 1053 : //    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
; 1054 :    }
; 1055 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@stb_texted:

; 717  :                   ++state->cursor;
; 718  :                   state->has_preferred_x = 0;
; 719  :                }
; 720  :             } else {
; 721  :                stb_textedit_delete_selection(str,state); // implicity clamps

	push	edi
	push	esi
	call	?stb_textedit_delete_selection@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_delete_selection

; 722  :                if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, &ch, 1)) {

	push	1
	lea	eax, DWORD PTR _ch$5[ebp]
	push	eax
	push	DWORD PTR [edi]
	push	esi
	call	?STB_TEXTEDIT_INSERTCHARS@ImGuiStb@@YA_NPAUImGuiTextEditState@@HPBGH@Z ; ImGuiStb::STB_TEXTEDIT_INSERTCHARS
	add	esp, 24					; 00000018H
	test	al, al
	je	SHORT $LN24@stb_texted

; 723  :                   stb_text_makeundo_insert(state, state->cursor, 1);

	push	1
	push	DWORD PTR [edi]
	push	edi
	call	?stb_text_makeundo_insert@ImGuiStb@@YAXPAUSTB_TexteditState@1@HH@Z ; ImGuiStb::stb_text_makeundo_insert
	add	esp, 12					; 0000000cH

; 724  :                   ++state->cursor;

	inc	DWORD PTR [edi]
$LN133@stb_texted:

; 725  :                   state->has_preferred_x = 0;

	mov	BYTE PTR [edi+15], 0
$LN24@stb_texted:
	pop	edi
	pop	esi
	pop	ebx

; 1047 :          state->has_preferred_x = 0;
; 1048 :          break;
; 1049 :       }
; 1050 : 
; 1051 : // @TODO:
; 1052 : //    STB_TEXTEDIT_K_PGUP      - move cursor up a page
; 1053 : //    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
; 1054 :    }
; 1055 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN139@stb_texted:
	DD	$LN27@stb_texted
	DD	$LN31@stb_texted
	DD	$LN56@stb_texted
	DD	$LN47@stb_texted
	DD	$LN77@stb_texted
	DD	$LN80@stb_texted
	DD	$LN73@stb_texted
	DD	$LN74@stb_texted
	DD	$LN65@stb_texted
	DD	$LN69@stb_texted
	DD	$LN25@stb_texted
	DD	$LN26@stb_texted
	DD	$LN36@stb_texted
	DD	$LN41@stb_texted
$LN140@stb_texted:
	DD	$LN46@stb_texted
	DD	$LN56@stb_texted
	DD	$LN47@stb_texted
	DD	$LN83@stb_texted
	DD	$LN86@stb_texted
	DD	$LN75@stb_texted
	DD	$LN76@stb_texted
	DD	$LN65@stb_texted
	DD	$LN69@stb_texted
	DD	$LN18@stb_texted
	DD	$LN18@stb_texted
	DD	$LN39@stb_texted
	DD	$LN44@stb_texted
?stb_textedit_key@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@H@Z ENDP ; ImGuiStb::stb_textedit_key
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\textedit.h
_TEXT	SEGMENT
_str$ = 8						; size = 4
_state$ = 12						; size = 4
_ctext$ = 16						; size = 4
_len$ = 20						; size = 4
?stb_textedit_paste@ImGuiStb@@YAHPAUImGuiTextEditState@@PAUSTB_TexteditState@1@PBGH@Z PROC ; ImGuiStb::stb_textedit_paste

; 681  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 682  :    STB_TEXTEDIT_CHARTYPE *text = (STB_TEXTEDIT_CHARTYPE *) ctext;
; 683  :    // if there's a selection, the paste should delete it
; 684  :    stb_textedit_clamp(str, state);

	mov	esi, DWORD PTR _str$[ebp]
	push	edi
	mov	edi, DWORD PTR _state$[ebp]
	push	edi
	push	esi
	call	?stb_textedit_clamp@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp

; 685  :    stb_textedit_delete_selection(str,state);

	push	edi
	push	esi
	call	?stb_textedit_delete_selection@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_delete_selection

; 686  :    // try to insert the characters
; 687  :    if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, text, len)) {

	mov	ebx, DWORD PTR _len$[ebp]
	push	ebx
	push	DWORD PTR _ctext$[ebp]
	push	DWORD PTR [edi]
	push	esi
	call	?STB_TEXTEDIT_INSERTCHARS@ImGuiStb@@YA_NPAUImGuiTextEditState@@HPBGH@Z ; ImGuiStb::STB_TEXTEDIT_INSERTCHARS
	add	esp, 32					; 00000020H
	test	al, al
	je	SHORT $LN2@stb_texted

; 688  :       stb_text_makeundo_insert(state, state->cursor, len);

	push	ebx
	push	DWORD PTR [edi]
	push	edi
	call	?stb_text_makeundo_insert@ImGuiStb@@YAXPAUSTB_TexteditState@1@HH@Z ; ImGuiStb::stb_text_makeundo_insert
	add	esp, 12					; 0000000cH

; 689  :       state->cursor += len;
; 690  :       state->has_preferred_x = 0;

	mov	BYTE PTR [edi+15], 0
	add	DWORD PTR [edi], ebx

; 691  :       return 1;

	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx

; 697  : }

	pop	ebp
	ret	0
$LN2@stb_texted:

; 692  :    }
; 693  :    // remove the undo since we didn't actually insert the characters
; 694  :    if (state->undostate.undo_point)

	movzx	eax, WORD PTR [edi+3210]
	test	ax, ax
	je	SHORT $LN3@stb_texted

; 695  :       --state->undostate.undo_point;

	dec	eax
	mov	WORD PTR [edi+3210], ax
$LN3@stb_texted:

; 696  :    return 0;

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx

; 697  : }

	pop	ebp
	ret	0
?stb_textedit_paste@ImGuiStb@@YAHPAUImGuiTextEditState@@PAUSTB_TexteditState@1@PBGH@Z ENDP ; ImGuiStb::stb_textedit_paste
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\textedit.h
_TEXT	SEGMENT
_str$ = 8						; size = 4
_state$ = 12						; size = 4
?stb_textedit_cut@ImGuiStb@@YAHPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z PROC ; ImGuiStb::stb_textedit_cut

; 670  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 671  :    if (STB_TEXT_HAS_SELECTION(state)) {

	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, DWORD PTR [esi+8]
	je	SHORT $LN2@stb_texted

; 672  :       stb_textedit_delete_selection(str,state); // implicity clamps

	push	esi
	push	DWORD PTR _str$[ebp]
	call	?stb_textedit_delete_selection@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_delete_selection
	add	esp, 8

; 673  :       state->has_preferred_x = 0;

	mov	BYTE PTR [esi+15], 0

; 674  :       return 1;

	mov	eax, 1
	pop	esi

; 677  : }

	pop	ebp
	ret	0
$LN2@stb_texted:

; 675  :    }
; 676  :    return 0;

	xor	eax, eax
	pop	esi

; 677  : }

	pop	ebp
	ret	0
?stb_textedit_cut@ImGuiStb@@YAHPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ENDP ; ImGuiStb::stb_textedit_cut
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\textedit.h
_TEXT	SEGMENT
_state$ = 8						; size = 4
?stb_textedit_prep_selection_at_cursor@ImGuiStb@@YAXPAUSTB_TexteditState@1@@Z PROC ; ImGuiStb::stb_textedit_prep_selection_at_cursor

; 661  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 662  :    if (!STB_TEXT_HAS_SELECTION(state))

	mov	ecx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	cmp	DWORD PTR [ecx+4], eax
	jne	SHORT $LN2@stb_texted

; 663  :       state->select_start = state->select_end = state->cursor;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR [ecx+4], eax

; 666  : }

	pop	ebp
	ret	0
$LN2@stb_texted:

; 664  :    else
; 665  :       state->cursor = state->select_end;

	mov	DWORD PTR [ecx], eax

; 666  : }

	pop	ebp
	ret	0
?stb_textedit_prep_selection_at_cursor@ImGuiStb@@YAXPAUSTB_TexteditState@1@@Z ENDP ; ImGuiStb::stb_textedit_prep_selection_at_cursor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\textedit.h
_TEXT	SEGMENT
_str$ = 8						; size = 4
_state$ = 12						; size = 4
?stb_textedit_move_to_last@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z PROC ; ImGuiStb::stb_textedit_move_to_last

; 610  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 611  :    if (STB_TEXT_HAS_SELECTION(state)) {

	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, DWORD PTR [esi+8]
	je	SHORT $LN2@stb_texted

; 612  :       stb_textedit_sortselection(state);

	push	esi
	call	?stb_textedit_sortselection@ImGuiStb@@YAXPAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_sortselection

; 613  :       stb_textedit_clamp(str, state);

	push	esi
	push	DWORD PTR _str$[ebp]
	call	?stb_textedit_clamp@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp

; 614  :       state->cursor = state->select_end;

	mov	eax, DWORD PTR [esi+8]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi], eax

; 615  :       state->select_start = state->select_end;

	mov	DWORD PTR [esi+4], eax

; 616  :       state->has_preferred_x = 0;

	mov	BYTE PTR [esi+15], 0
$LN2@stb_texted:
	pop	esi

; 617  :    }
; 618  : }

	pop	ebp
	ret	0
?stb_textedit_move_to_last@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ENDP ; ImGuiStb::stb_textedit_move_to_last
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\textedit.h
_TEXT	SEGMENT
_state$ = 8						; size = 4
?stb_textedit_move_to_first@ImGuiStb@@YAXPAUSTB_TexteditState@1@@Z PROC ; ImGuiStb::stb_textedit_move_to_first

; 599  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 600  :    if (STB_TEXT_HAS_SELECTION(state)) {

	mov	esi, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, DWORD PTR [esi+8]
	je	SHORT $LN2@stb_texted

; 601  :       stb_textedit_sortselection(state);

	push	esi
	call	?stb_textedit_sortselection@ImGuiStb@@YAXPAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_sortselection

; 602  :       state->cursor = state->select_start;

	mov	eax, DWORD PTR [esi+4]
	add	esp, 4
	mov	DWORD PTR [esi], eax

; 603  :       state->select_end = state->select_start;

	mov	DWORD PTR [esi+8], eax

; 604  :       state->has_preferred_x = 0;

	mov	BYTE PTR [esi+15], 0
$LN2@stb_texted:
	pop	esi

; 605  :    }
; 606  : }

	pop	ebp
	ret	0
?stb_textedit_move_to_first@ImGuiStb@@YAXPAUSTB_TexteditState@1@@Z ENDP ; ImGuiStb::stb_textedit_move_to_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\textedit.h
_TEXT	SEGMENT
_state$ = 8						; size = 4
?stb_textedit_sortselection@ImGuiStb@@YAXPAUSTB_TexteditState@1@@Z PROC ; ImGuiStb::stb_textedit_sortselection

; 589  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 590  :    if (state->select_end < state->select_start) {

	mov	eax, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR [eax+4]
	cmp	edx, ecx
	jge	SHORT $LN2@stb_texted

; 591  :       int temp = state->select_end;
; 592  :       state->select_end = state->select_start;

	mov	DWORD PTR [eax+8], ecx

; 593  :       state->select_start = temp;

	mov	DWORD PTR [eax+4], edx
$LN2@stb_texted:

; 594  :    }
; 595  : }

	pop	ebp
	ret	0
?stb_textedit_sortselection@ImGuiStb@@YAXPAUSTB_TexteditState@1@@Z ENDP ; ImGuiStb::stb_textedit_sortselection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\textedit.h
_TEXT	SEGMENT
_str$ = 8						; size = 4
_state$ = 12						; size = 4
?stb_textedit_delete_selection@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z PROC ; ImGuiStb::stb_textedit_delete_selection

; 573  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 574  :    stb_textedit_clamp(str, state);

	mov	esi, DWORD PTR _state$[ebp]
	push	edi
	mov	edi, DWORD PTR _str$[ebp]
	push	esi
	push	edi
	call	?stb_textedit_clamp@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_clamp

; 575  :    if (STB_TEXT_HAS_SELECTION(state)) {

	mov	ecx, DWORD PTR [esi+4]
	add	esp, 8
	mov	eax, DWORD PTR [esi+8]
	cmp	ecx, eax
	je	SHORT $LN2@stb_texted

; 576  :       if (state->select_start < state->select_end) {

	jge	SHORT $LN3@stb_texted

; 577  :          stb_textedit_delete(str, state, state->select_start, state->select_end - state->select_start);

	sub	eax, ecx
	push	eax
	push	ecx
	push	esi
	push	edi
	call	?stb_textedit_delete@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@HH@Z ; ImGuiStb::stb_textedit_delete

; 578  :          state->select_end = state->cursor = state->select_start;

	mov	eax, DWORD PTR [esi+4]

; 579  :       } else {
; 580  :          stb_textedit_delete(str, state, state->select_end, state->select_start - state->select_end);

	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], eax

; 581  :          state->select_start = state->cursor = state->select_end;

	mov	DWORD PTR [esi], eax

; 582  :       }
; 583  :       state->has_preferred_x = 0;

	mov	BYTE PTR [esi+15], 0
	pop	edi
	pop	esi

; 584  :    }
; 585  : }

	pop	ebp
	ret	0
$LN3@stb_texted:

; 579  :       } else {
; 580  :          stb_textedit_delete(str, state, state->select_end, state->select_start - state->select_end);

	sub	ecx, eax
	push	ecx
	push	eax
	push	esi
	push	edi
	call	?stb_textedit_delete@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@HH@Z ; ImGuiStb::stb_textedit_delete

; 581  :          state->select_start = state->cursor = state->select_end;

	mov	eax, DWORD PTR [esi+8]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], eax

; 582  :       }
; 583  :       state->has_preferred_x = 0;

	mov	BYTE PTR [esi+15], 0
$LN2@stb_texted:
	pop	edi
	pop	esi

; 584  :    }
; 585  : }

	pop	ebp
	ret	0
?stb_textedit_delete_selection@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ENDP ; ImGuiStb::stb_textedit_delete_selection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\textedit.h
_TEXT	SEGMENT
_str$ = 8						; size = 4
_state$ = 12						; size = 4
_where$ = 16						; size = 4
_len$ = 20						; size = 4
?stb_textedit_delete@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@HH@Z PROC ; ImGuiStb::stb_textedit_delete

; 565  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 566  :    stb_text_makeundo_delete(str, state, where, len);

	push	DWORD PTR _len$[ebp]
	push	DWORD PTR _where$[ebp]
	push	DWORD PTR _state$[ebp]
	push	DWORD PTR _str$[ebp]
	call	?stb_text_makeundo_delete@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@HH@Z ; ImGuiStb::stb_text_makeundo_delete

; 567  :    STB_TEXTEDIT_DELETECHARS(str, where, len);

	push	DWORD PTR _len$[ebp]
	push	DWORD PTR _where$[ebp]
	push	DWORD PTR _str$[ebp]
	call	?STB_TEXTEDIT_DELETECHARS@ImGuiStb@@YAXPAUImGuiTextEditState@@HH@Z ; ImGuiStb::STB_TEXTEDIT_DELETECHARS

; 568  :    state->has_preferred_x = 0;

	mov	eax, DWORD PTR _state$[ebp]
	add	esp, 28					; 0000001cH
	mov	BYTE PTR [eax+15], 0

; 569  : }

	pop	ebp
	ret	0
?stb_textedit_delete@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@HH@Z ENDP ; ImGuiStb::stb_textedit_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\textedit.h
_TEXT	SEGMENT
_str$ = 8						; size = 4
_state$ = 12						; size = 4
?stb_textedit_clamp@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z PROC ; ImGuiStb::stb_textedit_clamp

; 551  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 552  :    int n = STB_TEXTEDIT_STRINGLEN(str);

	push	DWORD PTR _str$[ebp]
	call	?STB_TEXTEDIT_STRINGLEN@ImGuiStb@@YAHPBUImGuiTextEditState@@@Z ; ImGuiStb::STB_TEXTEDIT_STRINGLEN

; 553  :    if (STB_TEXT_HAS_SELECTION(state)) {

	mov	ecx, DWORD PTR _state$[ebp]
	add	esp, 4
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN5@stb_texted

; 554  :       if (state->select_start > n) state->select_start = n;

	cmp	edx, eax
	jle	SHORT $LN3@stb_texted
	mov	DWORD PTR [ecx+4], eax
$LN3@stb_texted:

; 555  :       if (state->select_end   > n) state->select_end = n;

	cmp	DWORD PTR [ecx+8], eax
	jle	SHORT $LN4@stb_texted
	mov	DWORD PTR [ecx+8], eax
$LN4@stb_texted:

; 556  :       // if clamping forced them to be equal, move the cursor to match
; 557  :       if (state->select_start == state->select_end)

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN5@stb_texted

; 558  :          state->cursor = state->select_start;

	mov	DWORD PTR [ecx], edx
$LN5@stb_texted:

; 559  :    }
; 560  :    if (state->cursor > n) state->cursor = n;

	cmp	DWORD PTR [ecx], eax
	jle	SHORT $LN6@stb_texted
	mov	DWORD PTR [ecx], eax
$LN6@stb_texted:

; 561  : }

	pop	ebp
	ret	0
?stb_textedit_clamp@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ENDP ; ImGuiStb::stb_textedit_clamp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\textedit.h
_TEXT	SEGMENT
_r$ = -32						; size = 24
_i$2$ = -8						; size = 4
_prev_start$1$ = -8					; size = 4
_z$1$ = -4						; size = 4
_find$ = 8						; size = 4
_str$ = 12						; size = 4
_n$ = 16						; size = 4
_single_line$ = 20					; size = 4
?stb_textedit_find_charpos@ImGuiStb@@YAXPAUStbFindState@1@PAUImGuiTextEditState@@HH@Z PROC ; ImGuiStb::stb_textedit_find_charpos

; 491  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	ebx

; 492  :    StbTexteditRow r;
; 493  :    int prev_start = 0;
; 494  :    int z = STB_TEXTEDIT_STRINGLEN(str);

	mov	ebx, DWORD PTR _str$[ebp]
	xor	ecx, ecx
	push	esi
	push	edi
	push	ebx
	mov	DWORD PTR _prev_start$1$[ebp], ecx
	call	?STB_TEXTEDIT_STRINGLEN@ImGuiStb@@YAHPBUImGuiTextEditState@@@Z ; ImGuiStb::STB_TEXTEDIT_STRINGLEN
	add	esp, 4
	mov	DWORD PTR _z$1$[ebp], eax

; 495  :    int i=0, first;

	xor	esi, esi

; 496  : 
; 497  :    if (n == z) {

	cmp	DWORD PTR _n$[ebp], eax
	jne	$LN10@stb_texted

; 498  :       // if it's at the end, then find the last line -- simpler than trying to
; 499  :       // explicitly handle this case in the regular code
; 500  :       if (single_line) {

	cmp	DWORD PTR _single_line$[ebp], ecx
	je	SHORT $LN11@stb_texted

; 501  :          STB_TEXTEDIT_LAYOUTROW(&r, str, 0);

	push	esi
	lea	eax, DWORD PTR _r$[ebp]
	push	ebx
	push	eax
	call	?STB_TEXTEDIT_LAYOUTROW@ImGuiStb@@YAXPAUStbTexteditRow@1@PAUImGuiTextEditState@@H@Z ; ImGuiStb::STB_TEXTEDIT_LAYOUTROW

; 502  :          find->y = 0;

	mov	eax, DWORD PTR _find$[ebp]
	add	esp, 12					; 0000000cH

; 503  :          find->first_char = 0;
; 504  :          find->length = z;
; 505  :          find->height = r.ymax - r.ymin;

	movss	xmm0, DWORD PTR _r$[ebp+16]
	subss	xmm0, DWORD PTR _r$[ebp+12]
	mov	ecx, DWORD PTR _z$1$[ebp]
	pop	edi
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax+12], esi
	movss	DWORD PTR [eax+8], xmm0

; 506  :          find->x = r.x1;

	movss	xmm0, DWORD PTR _r$[ebp+4]
	pop	esi
	mov	DWORD PTR [eax+16], ecx
	movss	DWORD PTR [eax], xmm0
	pop	ebx

; 545  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@stb_texted:

; 507  :       } else {
; 508  :          find->y = 0;

	mov	edi, DWORD PTR _find$[ebp]
	mov	DWORD PTR [edi+4], ecx

; 509  :          find->x = 0;

	mov	DWORD PTR [edi], ecx

; 510  :          find->height = 1;

	mov	DWORD PTR [edi+8], 1065353216		; 3f800000H

; 511  :          while (i < z) {

	test	eax, eax
	jle	SHORT $LN3@stb_texted
	mov	edi, eax
$LL2@stb_texted:

; 512  :             STB_TEXTEDIT_LAYOUTROW(&r, str, i);

	push	esi
	lea	eax, DWORD PTR _r$[ebp]
	push	ebx
	push	eax
	call	?STB_TEXTEDIT_LAYOUTROW@ImGuiStb@@YAXPAUStbTexteditRow@1@PAUImGuiTextEditState@@H@Z ; ImGuiStb::STB_TEXTEDIT_LAYOUTROW

; 513  :             prev_start = i;

	mov	ecx, esi
	add	esp, 12					; 0000000cH

; 514  :             i += r.num_chars;

	add	esi, DWORD PTR _r$[ebp+20]
	cmp	esi, edi
	jl	SHORT $LL2@stb_texted
	mov	edi, DWORD PTR _find$[ebp]
$LN3@stb_texted:

; 515  :          }
; 516  :          find->first_char = i;

	mov	DWORD PTR [edi+12], esi

; 517  :          find->length = 0;

	mov	DWORD PTR [edi+16], 0

; 518  :          find->prev_first = prev_start;

	mov	DWORD PTR [edi+20], ecx
	pop	edi
	pop	esi
	pop	ebx

; 545  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@stb_texted:

; 519  :       }
; 520  :       return;
; 521  :    }
; 522  : 
; 523  :    // search rows to find the one that straddles character n
; 524  :    find->y = 0;

	mov	edi, DWORD PTR _find$[ebp]

; 525  : 
; 526  :    for(;;) {
; 527  :       STB_TEXTEDIT_LAYOUTROW(&r, str, i);

	lea	eax, DWORD PTR _r$[ebp]
	push	0
	push	ebx
	push	eax
	mov	DWORD PTR [edi+4], ecx
	call	?STB_TEXTEDIT_LAYOUTROW@ImGuiStb@@YAXPAUStbTexteditRow@1@PAUImGuiTextEditState@@H@Z ; ImGuiStb::STB_TEXTEDIT_LAYOUTROW

; 528  :       if (n < i + r.num_chars)

	mov	ecx, DWORD PTR _r$[ebp+20]
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _n$[ebp], ecx
	jl	SHORT $LN19@stb_texted
	npad	5
$LL4@stb_texted:

; 529  :          break;
; 530  :       prev_start = i;
; 531  :       i += r.num_chars;
; 532  :       find->y += r.baseline_y_delta;

	movss	xmm0, DWORD PTR [edi+4]
	lea	eax, DWORD PTR _r$[ebp]
	addss	xmm0, DWORD PTR _r$[ebp+8]
	mov	DWORD PTR _prev_start$1$[ebp], esi
	add	esi, ecx
	push	esi
	push	ebx
	push	eax
	movss	DWORD PTR [edi+4], xmm0
	call	?STB_TEXTEDIT_LAYOUTROW@ImGuiStb@@YAXPAUStbTexteditRow@1@PAUImGuiTextEditState@@H@Z ; ImGuiStb::STB_TEXTEDIT_LAYOUTROW
	mov	ecx, DWORD PTR _r$[ebp+20]
	add	esp, 12					; 0000000cH
	lea	eax, DWORD PTR [ecx+esi]
	cmp	DWORD PTR _n$[ebp], eax
	jge	SHORT $LL4@stb_texted
$LN19@stb_texted:

; 533  :    }
; 534  : 
; 535  :    find->first_char = first = i;
; 536  :    find->length = r.num_chars;
; 537  :    find->height = r.ymax - r.ymin;

	movss	xmm0, DWORD PTR _r$[ebp+16]
	subss	xmm0, DWORD PTR _r$[ebp+12]

; 538  :    find->prev_first = prev_start;

	mov	eax, DWORD PTR _prev_start$1$[ebp]
	mov	DWORD PTR [edi+16], ecx

; 539  : 
; 540  :    // now scan to find xpos
; 541  :    find->x = r.x0;
; 542  :    i = 0;
; 543  :    for (i=0; first+i < n; ++i)

	xor	ecx, ecx
	mov	DWORD PTR [edi+12], esi
	mov	DWORD PTR [edi+20], eax
	movss	DWORD PTR [edi+8], xmm0
	movss	xmm0, DWORD PTR _r$[ebp]
	movss	DWORD PTR [edi], xmm0
	mov	DWORD PTR _i$2$[ebp], ecx
	cmp	esi, DWORD PTR _n$[ebp]
	jge	SHORT $LN8@stb_texted
	npad	5
$LL9@stb_texted:

; 544  :       find->x += STB_TEXTEDIT_GETWIDTH(str, first, i);

	push	ecx
	push	esi
	push	ebx
	call	?STB_TEXTEDIT_GETWIDTH@ImGuiStb@@YAMPAUImGuiTextEditState@@HH@Z ; ImGuiStb::STB_TEXTEDIT_GETWIDTH
	mov	ecx, DWORD PTR _i$2$[ebp]
	add	esp, 12					; 0000000cH
	fadd	DWORD PTR [edi]
	inc	ecx
	mov	DWORD PTR _i$2$[ebp], ecx
	lea	eax, DWORD PTR [esi+ecx]
	fstp	DWORD PTR [edi]
	cmp	eax, DWORD PTR _n$[ebp]
	jl	SHORT $LL9@stb_texted
$LN8@stb_texted:
	pop	edi
	pop	esi
	pop	ebx

; 545  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?stb_textedit_find_charpos@ImGuiStb@@YAXPAUStbFindState@1@PAUImGuiTextEditState@@HH@Z ENDP ; ImGuiStb::stb_textedit_find_charpos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\textedit.h
_TEXT	SEGMENT
_str$ = 8						; size = 4
_state$ = 12						; size = 4
_where$ = 16						; size = 4
_old_length$ = 20					; size = 4
_new_length$ = 24					; size = 4
?stb_text_makeundo_replace@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@HHH@Z PROC ; ImGuiStb::stb_text_makeundo_replace

; 1291 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1292 :    int i;
; 1293 :    STB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, old_length, new_length);

	mov	eax, DWORD PTR _state$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _old_length$[ebp]
	add	eax, 24					; 00000018H
	push	edi
	push	DWORD PTR _new_length$[ebp]
	mov	edi, DWORD PTR _where$[ebp]
	push	esi
	push	edi
	push	eax
	call	?stb_text_createundo@ImGuiStb@@YAPAGPAUStbUndoState@1@HHH@Z ; ImGuiStb::stb_text_createundo
	mov	ebx, eax
	add	esp, 16					; 00000010H

; 1294 :    if (p) {

	test	ebx, ebx
	je	SHORT $LN3@stb_text_m

; 1295 :       for (i=0; i < old_length; ++i)

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN3@stb_text_m
	npad	2
$LL4@stb_text_m:

; 1296 :          p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);

	lea	eax, DWORD PTR [edx+edi]
	push	eax
	push	DWORD PTR _str$[ebp]
	call	?STB_TEXTEDIT_GETCHAR@ImGuiStb@@YAGPBUImGuiTextEditState@@H@Z ; ImGuiStb::STB_TEXTEDIT_GETCHAR
	mov	WORD PTR [ebx+edx*2], ax
	add	esp, 8
	inc	edx
	cmp	edx, esi
	jl	SHORT $LL4@stb_text_m
$LN3@stb_text_m:
	pop	edi
	pop	esi
	pop	ebx

; 1297 :    }
; 1298 : }

	pop	ebp
	ret	0
?stb_text_makeundo_replace@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@HHH@Z ENDP ; ImGuiStb::stb_text_makeundo_replace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\textedit.h
_TEXT	SEGMENT
_state$ = 8						; size = 4
_where$ = 12						; size = 4
_length$ = 16						; size = 4
?stb_text_makeundo_insert@ImGuiStb@@YAXPAUSTB_TexteditState@1@HH@Z PROC ; ImGuiStb::stb_text_makeundo_insert

; 1276 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1277 :    stb_text_createundo(&state->undostate, where, 0, length);

	push	DWORD PTR _length$[ebp]
	mov	eax, DWORD PTR _state$[ebp]
	push	0
	push	DWORD PTR _where$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	call	?stb_text_createundo@ImGuiStb@@YAPAGPAUStbUndoState@1@HHH@Z ; ImGuiStb::stb_text_createundo
	add	esp, 16					; 00000010H

; 1278 : }

	pop	ebp
	ret	0
?stb_text_makeundo_insert@ImGuiStb@@YAXPAUSTB_TexteditState@1@HH@Z ENDP ; ImGuiStb::stb_text_makeundo_insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\textedit.h
_TEXT	SEGMENT
_str$ = 8						; size = 4
_state$ = 12						; size = 4
_where$ = 16						; size = 4
_length$ = 20						; size = 4
?stb_text_makeundo_delete@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@HH@Z PROC ; ImGuiStb::stb_text_makeundo_delete

; 1281 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1282 :    int i;
; 1283 :    STB_TEXTEDIT_CHARTYPE *p = stb_text_createundo(&state->undostate, where, length, 0);

	mov	eax, DWORD PTR _state$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _length$[ebp]
	add	eax, 24					; 00000018H
	push	edi
	mov	edi, DWORD PTR _where$[ebp]
	push	0
	push	esi
	push	edi
	push	eax
	call	?stb_text_createundo@ImGuiStb@@YAPAGPAUStbUndoState@1@HHH@Z ; ImGuiStb::stb_text_createundo
	mov	ebx, eax
	add	esp, 16					; 00000010H

; 1284 :    if (p) {

	test	ebx, ebx
	je	SHORT $LN3@stb_text_m

; 1285 :       for (i=0; i < length; ++i)

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN3@stb_text_m
	npad	3
$LL4@stb_text_m:

; 1286 :          p[i] = STB_TEXTEDIT_GETCHAR(str, where+i);

	lea	eax, DWORD PTR [edx+edi]
	push	eax
	push	DWORD PTR _str$[ebp]
	call	?STB_TEXTEDIT_GETCHAR@ImGuiStb@@YAGPBUImGuiTextEditState@@H@Z ; ImGuiStb::STB_TEXTEDIT_GETCHAR
	mov	WORD PTR [ebx+edx*2], ax
	add	esp, 8
	inc	edx
	cmp	edx, esi
	jl	SHORT $LL4@stb_text_m
$LN3@stb_text_m:
	pop	edi
	pop	esi
	pop	ebx

; 1287 :    }
; 1288 : }

	pop	ebp
	ret	0
?stb_text_makeundo_delete@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@HH@Z ENDP ; ImGuiStb::stb_text_makeundo_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\textedit.h
_TEXT	SEGMENT
_r$ = -20						; size = 12
tv268 = -8						; size = 4
tv267 = -4						; size = 4
_str$ = 8						; size = 4
_state$ = 12						; size = 4
?stb_text_redo@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z PROC ; ImGuiStb::stb_text_redo

; 1225 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1226 :    StbUndoState *s = &state->undostate;
; 1227 :    StbUndoRecord *u, r;
; 1228 :    if (s->redo_point == STB_TEXTEDIT_UNDOSTATECOUNT)

	mov	edx, DWORD PTR _state$[ebp]
	sub	esp, 20					; 00000014H
	movzx	ecx, WORD PTR [edx+3212]
	cmp	cx, 99					; 00000063H
	je	$LN1@stb_text_r

; 1229 :       return;
; 1230 : 
; 1231 :    // we need to do two things: apply the redo record, and create an undo record
; 1232 :    u = &s->undo_rec[s->undo_point];

	movsx	eax, WORD PTR [edx+3210]
	push	ebx
	push	esi
	push	edi

; 1233 :    r = s->undo_rec[s->redo_point];
; 1234 : 
; 1235 :    // we KNOW there must be room for the undo record, because the redo record
; 1236 :    // was derived from an undo record
; 1237 : 
; 1238 :    u->delete_length = r.insert_length;
; 1239 :    u->insert_length = r.delete_length;
; 1240 :    u->where = r.where;
; 1241 :    u->char_storage = -1;
; 1242 : 
; 1243 :    if (r.delete_length) {

	mov	edi, DWORD PTR _str$[ebp]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	esi, DWORD PTR [edx+eax*4]
	movsx	eax, cx
	lea	eax, DWORD PTR [eax+eax*2]
	movq	xmm0, QWORD PTR [edx+eax*4+24]
	mov	eax, DWORD PTR [edx+eax*4+32]
	movq	QWORD PTR _r$[ebp], xmm0
	mov	bx, WORD PTR _r$[ebp+4]
	mov	DWORD PTR _r$[ebp+8], eax
	mov	eax, DWORD PTR _r$[ebp+4]
	shr	eax, 16					; 00000010H
	mov	ecx, eax
	mov	WORD PTR [esi+30], bx
	mov	DWORD PTR tv267[ebp], ecx
	mov	WORD PTR [esi+28], cx
	mov	ecx, DWORD PTR _r$[ebp]
	mov	DWORD PTR [esi+24], ecx
	or	ecx, -1
	mov	WORD PTR [esi+32], cx
	test	ax, ax
	je	$LN15@stb_text_r

; 1244 :       // the redo record requires us to delete characters, so the undo record
; 1245 :       // needs to store the characters
; 1246 : 
; 1247 :       if (s->undo_char_point + u->insert_length > s->redo_char_point) {

	movzx	eax, WORD PTR [edx+3214]
	movsx	ecx, ax
	mov	DWORD PTR tv268[ebp], eax
	mov	eax, DWORD PTR tv267[ebp]
	cwde
	add	ecx, eax
	movsx	eax, WORD PTR [edx+3216]
	cmp	ecx, eax
	jle	SHORT $LN7@stb_text_r

; 1248 :          u->insert_length = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+28], eax

; 1249 :          u->delete_length = 0;
; 1250 :       } else {

	jmp	SHORT $LN3@stb_text_r
$LN7@stb_text_r:

; 1251 :          int i;
; 1252 :          u->char_storage = s->undo_char_point;

	mov	eax, DWORD PTR tv268[ebp]
	mov	WORD PTR [esi+32], ax

; 1253 :          s->undo_char_point = s->undo_char_point + u->insert_length;

	mov	eax, DWORD PTR tv267[ebp]
	add	WORD PTR [edx+3214], ax
	xor	eax, eax

; 1254 : 
; 1255 :          // now save the characters
; 1256 :          for (i=0; i < u->insert_length; ++i)

	xor	edx, edx
	cmp	ax, WORD PTR [esi+28]
	jge	SHORT $LN3@stb_text_r
$LL4@stb_text_r:

; 1257 :             s->undo_char[u->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u->where + i);

	mov	eax, DWORD PTR [esi+24]
	add	eax, edx
	push	eax
	push	edi
	call	?STB_TEXTEDIT_GETCHAR@ImGuiStb@@YAGPBUImGuiTextEditState@@H@Z ; ImGuiStb::STB_TEXTEDIT_GETCHAR
	movsx	ecx, WORD PTR [esi+32]
	add	esp, 8
	mov	edi, DWORD PTR _state$[ebp]
	add	ecx, edx
	inc	edx
	mov	WORD PTR [edi+ecx*2+1212], ax
	movsx	eax, WORD PTR [esi+28]
	mov	edi, DWORD PTR _str$[ebp]
	cmp	edx, eax
	jl	SHORT $LL4@stb_text_r
$LN3@stb_text_r:

; 1258 :       }
; 1259 : 
; 1260 :       STB_TEXTEDIT_DELETECHARS(str, r.where, r.delete_length);

	movsx	eax, WORD PTR _r$[ebp+6]
	mov	esi, DWORD PTR _r$[ebp]
	push	eax
	push	esi
	push	edi
	call	?STB_TEXTEDIT_DELETECHARS@ImGuiStb@@YAXPAUImGuiTextEditState@@HH@Z ; ImGuiStb::STB_TEXTEDIT_DELETECHARS
	mov	edx, DWORD PTR _state$[ebp]
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN6@stb_text_r
$LN15@stb_text_r:
	mov	esi, DWORD PTR _r$[ebp]
$LN6@stb_text_r:

; 1261 :    }
; 1262 : 
; 1263 :    if (r.insert_length) {

	test	bx, bx
	je	SHORT $LN9@stb_text_r

; 1264 :       // easy case: need to insert n characters
; 1265 :       STB_TEXTEDIT_INSERTCHARS(str, r.where, &s->undo_char[r.char_storage], r.insert_length);

	movsx	eax, bx
	push	eax
	movsx	eax, WORD PTR _r$[ebp+8]
	add	eax, 606				; 0000025eH
	lea	eax, DWORD PTR [edx+eax*2]
	push	eax
	push	esi
	push	edi
	call	?STB_TEXTEDIT_INSERTCHARS@ImGuiStb@@YA_NPAUImGuiTextEditState@@HPBGH@Z ; ImGuiStb::STB_TEXTEDIT_INSERTCHARS

; 1266 :       s->redo_char_point += r.insert_length;

	mov	edx, DWORD PTR _state$[ebp]
	add	esp, 16					; 00000010H
	add	WORD PTR [edx+3216], bx
$LN9@stb_text_r:

; 1267 :    }
; 1268 : 
; 1269 :    state->cursor = r.where + r.insert_length;

	movsx	eax, bx
	add	eax, esi
	pop	edi
	mov	DWORD PTR [edx], eax

; 1270 : 
; 1271 :    s->undo_point++;

	inc	WORD PTR [edx+3210]

; 1272 :    s->redo_point++;

	inc	WORD PTR [edx+3212]
	pop	esi
	pop	ebx
$LN1@stb_text_r:

; 1273 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?stb_text_redo@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ENDP ; ImGuiStb::stb_text_redo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\textedit.h
_TEXT	SEGMENT
_u$ = -16						; size = 12
_r$2$ = -4						; size = 4
_str$ = 8						; size = 4
_state$ = 12						; size = 4
?stb_text_undo@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z PROC ; ImGuiStb::stb_text_undo

; 1157 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi

; 1158 :    StbUndoState *s = &state->undostate;

	mov	esi, DWORD PTR _state$[ebp]
	add	esi, 24					; 00000018H

; 1159 :    StbUndoRecord u, *r;
; 1160 :    if (s->undo_point == 0)

	movzx	eax, WORD PTR [esi+3186]
	test	ax, ax
	je	$LN1@stb_text_u

; 1161 :       return;
; 1162 : 
; 1163 :    // we need to do two things: apply the undo record, and create a redo record
; 1164 :    u = s->undo_rec[s->undo_point-1];

	cwde
	push	ebx
	push	edi
	lea	eax, DWORD PTR [eax+eax*2]
	movq	xmm0, QWORD PTR [esi+eax*4-12]
	mov	eax, DWORD PTR [esi+eax*4-4]
	mov	DWORD PTR _u$[ebp+8], eax

; 1165 :    r = &s->undo_rec[s->redo_point-1];

	movsx	eax, WORD PTR [esi+3188]
	movq	QWORD PTR _u$[ebp], xmm0

; 1166 :    r->char_storage = -1;
; 1167 : 
; 1168 :    r->insert_length = u.delete_length;
; 1169 :    r->delete_length = u.insert_length;

	mov	di, WORD PTR _u$[ebp+4]

; 1170 :    r->where = u.where;

	mov	ebx, DWORD PTR _u$[ebp]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	edx, DWORD PTR [esi+eax*4]
	or	eax, -1
	mov	WORD PTR [edx-6], di
	mov	WORD PTR [edx-4], ax
	mov	eax, DWORD PTR _u$[ebp+4]
	shr	eax, 16					; 00000010H
	mov	WORD PTR [edx-8], ax
	mov	DWORD PTR [edx-12], ebx

; 1171 : 
; 1172 :    if (u.delete_length) {

	test	ax, ax
	je	$LN8@stb_text_u

; 1173 :       // if the undo record says to delete characters, then the redo record will
; 1174 :       // need to re-insert the characters that get deleted, so we need to store
; 1175 :       // them.
; 1176 : 
; 1177 :       // there are three cases:
; 1178 :       //    there's enough room to store the characters
; 1179 :       //    characters stored for *redoing* don't leave room for redo
; 1180 :       //    characters stored for *undoing* don't leave room for redo
; 1181 :       // if the last is true, we have to bail
; 1182 : 
; 1183 :       if (s->undo_char_point + u.delete_length >= STB_TEXTEDIT_UNDOCHARCOUNT) {

	movsx	ecx, WORD PTR [esi+3190]
	mov	di, WORD PTR _u$[ebp+6]
	cwde
	add	ecx, eax
	cmp	ecx, 999				; 000003e7H
	jl	SHORT $LN14@stb_text_u

; 1184 :          // the undo records take up too much character space; there's no space to store the redo characters
; 1185 :          r->insert_length = 0;

	xor	eax, eax
	mov	WORD PTR [edx-8], ax

; 1186 :       } else {

	jmp	$LN5@stb_text_u
$LN14@stb_text_u:

; 1187 :          int i;
; 1188 : 
; 1189 :          // there's definitely room to store the characters eventually
; 1190 :          while (s->undo_char_point + u.delete_length > s->redo_char_point) {

	movsx	eax, WORD PTR [esi+3192]
	cmp	ecx, eax
	jle	SHORT $LN3@stb_text_u
$LL2@stb_text_u:

; 1191 :             // there's currently not enough room, so discard a redo record
; 1192 :             stb_textedit_discard_redo(s);

	push	esi
	call	?stb_textedit_discard_redo@ImGuiStb@@YAXPAUStbUndoState@1@@Z ; ImGuiStb::stb_textedit_discard_redo
	add	esp, 4

; 1193 :             // should never happen:
; 1194 :             if (s->redo_point == STB_TEXTEDIT_UNDOSTATECOUNT)

	cmp	WORD PTR [esi+3188], 99			; 00000063H
	je	$LN22@stb_text_u

; 1187 :          int i;
; 1188 : 
; 1189 :          // there's definitely room to store the characters eventually
; 1190 :          while (s->undo_char_point + u.delete_length > s->redo_char_point) {

	movsx	ecx, WORD PTR [esi+3190]
	movsx	eax, di
	add	ecx, eax
	movsx	eax, WORD PTR [esi+3192]
	cmp	ecx, eax
	jg	SHORT $LL2@stb_text_u
$LN3@stb_text_u:

; 1195 :                return;
; 1196 :          }
; 1197 :          r = &s->undo_rec[s->redo_point-1];

	movsx	ecx, WORD PTR [esi+3188]

; 1198 : 
; 1199 :          r->char_storage = s->redo_char_point - u.delete_length;
; 1200 :          s->redo_char_point = s->redo_char_point - (short) u.delete_length;
; 1201 : 
; 1202 :          // now save the characters
; 1203 :          for (i=0; i < u.delete_length; ++i)

	xor	edx, edx
	mov	ax, WORD PTR [esi+3192]
	dec	ecx
	sub	ax, di
	lea	ecx, DWORD PTR [ecx+ecx*2]
	lea	ecx, DWORD PTR [esi+ecx*4]
	mov	WORD PTR [ecx+8], ax
	sub	WORD PTR [esi+3192], di
	mov	DWORD PTR _r$2$[ebp], ecx
	test	di, di
	jle	SHORT $LN5@stb_text_u
$LL6@stb_text_u:

; 1204 :             s->undo_char[r->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u.where + i);

	lea	eax, DWORD PTR [edx+ebx]
	push	eax
	push	DWORD PTR _str$[ebp]
	call	?STB_TEXTEDIT_GETCHAR@ImGuiStb@@YAGPBUImGuiTextEditState@@H@Z ; ImGuiStb::STB_TEXTEDIT_GETCHAR
	mov	ecx, DWORD PTR _r$2$[ebp]
	add	esp, 8
	movsx	ecx, WORD PTR [ecx+8]
	add	ecx, edx
	inc	edx
	mov	WORD PTR [esi+ecx*2+1188], ax
	movsx	eax, di
	cmp	edx, eax
	jl	SHORT $LL6@stb_text_u
$LN5@stb_text_u:

; 1205 :       }
; 1206 : 
; 1207 :       // now we can carry out the deletion
; 1208 :       STB_TEXTEDIT_DELETECHARS(str, u.where, u.delete_length);

	movsx	eax, di
	push	eax
	push	ebx
	push	DWORD PTR _str$[ebp]
	call	?STB_TEXTEDIT_DELETECHARS@ImGuiStb@@YAXPAUImGuiTextEditState@@HH@Z ; ImGuiStb::STB_TEXTEDIT_DELETECHARS
	mov	di, WORD PTR _u$[ebp+4]
	add	esp, 12					; 0000000cH
$LN8@stb_text_u:

; 1209 :    }
; 1210 : 
; 1211 :    // check type of recorded action:
; 1212 :    if (u.insert_length) {

	test	di, di
	je	SHORT $LN12@stb_text_u

; 1213 :       // easy case: was a deletion, so we need to insert n characters
; 1214 :       STB_TEXTEDIT_INSERTCHARS(str, u.where, &s->undo_char[u.char_storage], u.insert_length);

	movsx	eax, di
	push	eax
	movsx	eax, WORD PTR _u$[ebp+8]
	add	eax, 594				; 00000252H
	lea	eax, DWORD PTR [esi+eax*2]
	push	eax
	push	ebx
	push	DWORD PTR _str$[ebp]
	call	?STB_TEXTEDIT_INSERTCHARS@ImGuiStb@@YA_NPAUImGuiTextEditState@@HPBGH@Z ; ImGuiStb::STB_TEXTEDIT_INSERTCHARS
	add	esp, 16					; 00000010H

; 1215 :       s->undo_char_point -= u.insert_length;

	sub	WORD PTR [esi+3190], di
$LN12@stb_text_u:

; 1216 :    }
; 1217 : 
; 1218 :    state->cursor = u.where + u.insert_length;

	mov	ecx, DWORD PTR _state$[ebp]
	movsx	eax, di
	add	eax, ebx
	mov	DWORD PTR [ecx], eax

; 1219 : 
; 1220 :    s->undo_point--;

	dec	WORD PTR [esi+3186]

; 1221 :    s->redo_point--;

	dec	WORD PTR [esi+3188]
$LN22@stb_text_u:
	pop	edi
	pop	ebx
$LN1@stb_text_u:
	pop	esi

; 1222 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?stb_text_undo@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ENDP ; ImGuiStb::stb_text_undo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\textedit.h
_TEXT	SEGMENT
_str$ = 8						; size = 4
_state$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
?stb_textedit_drag@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@MM@Z PROC ; ImGuiStb::stb_textedit_drag

; 461  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 462  :    int p = stb_text_locate_coord(str, x, y);

	movss	xmm0, DWORD PTR _y$[ebp]
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _str$[ebp]
	call	?stb_text_locate_coord@ImGuiStb@@YAHPAUImGuiTextEditState@@MM@Z ; ImGuiStb::stb_text_locate_coord

; 463  :    if (state->select_start == state->select_end)

	mov	edx, DWORD PTR _state$[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [edx+8]

; 465  :    state->cursor = state->select_end = p;

	mov	DWORD PTR [edx+8], eax
	jne	SHORT $LN4@stb_texted

; 464  :       state->select_start = state->cursor;

	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [edx+4], ecx
$LN4@stb_texted:

; 465  :    state->cursor = state->select_end = p;

	mov	DWORD PTR [edx], eax

; 466  : }

	pop	ebp
	ret	0
?stb_textedit_drag@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@MM@Z ENDP ; ImGuiStb::stb_textedit_drag
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\textedit.h
_TEXT	SEGMENT
_str$ = 8						; size = 4
_state$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
?stb_textedit_click@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@MM@Z PROC ; ImGuiStb::stb_textedit_click

; 452  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 453  :    state->cursor = stb_text_locate_coord(str, x, y);

	movss	xmm0, DWORD PTR _y$[ebp]
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _x$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _str$[ebp]
	call	?stb_text_locate_coord@ImGuiStb@@YAHPAUImGuiTextEditState@@MM@Z ; ImGuiStb::stb_text_locate_coord
	mov	ecx, DWORD PTR _state$[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx], eax

; 454  :    state->select_start = state->cursor;

	mov	DWORD PTR [ecx+4], eax

; 455  :    state->select_end = state->cursor;

	mov	DWORD PTR [ecx+8], eax

; 456  :    state->has_preferred_x = 0;

	mov	BYTE PTR [ecx+15], 0

; 457  : }

	pop	ebp
	ret	0
?stb_textedit_click@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@MM@Z ENDP ; ImGuiStb::stb_textedit_click
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\stb\textedit.h
_TEXT	SEGMENT
_r$ = -28						; size = 24
_w$1 = -4						; size = 4
_str$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
?stb_text_locate_coord@ImGuiStb@@YAHPAUImGuiTextEditState@@MM@Z PROC ; ImGuiStb::stb_text_locate_coord

; 392  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 393  :    StbTexteditRow r;
; 394  :    int n = STB_TEXTEDIT_STRINGLEN(str);

	mov	ecx, DWORD PTR _str$[ebp]
	push	ebx
	push	esi
	push	edi
	push	ecx
	call	?STB_TEXTEDIT_STRINGLEN@ImGuiStb@@YAHPBUImGuiTextEditState@@@Z ; ImGuiStb::STB_TEXTEDIT_STRINGLEN

; 395  :    float base_y = 0, prev_x;
; 396  :    int i=0, k;

	xor	esi, esi
	mov	edi, eax
	add	esp, 4

; 397  : 
; 398  :    r.x0 = r.x1 = 0;

	mov	DWORD PTR _r$[ebp+4], esi
	mov	DWORD PTR _r$[ebp], esi
	xorps	xmm5, xmm5

; 399  :    r.ymin = r.ymax = 0;

	mov	DWORD PTR _r$[ebp+16], esi
	mov	DWORD PTR _r$[ebp+12], esi

; 400  :    r.num_chars = 0;

	mov	DWORD PTR _r$[ebp+20], esi

; 401  : 
; 402  :    // search rows to find one that straddles 'y'
; 403  :    while (i < n) {

	test	edi, edi
	jle	$LN31@stb_text_l
	movss	xmm6, DWORD PTR _y$[ebp]
	npad	6
$LL2@stb_text_l:

; 404  :       STB_TEXTEDIT_LAYOUTROW(&r, str, i);

	push	esi
	push	ecx
	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	call	?STB_TEXTEDIT_LAYOUTROW@ImGuiStb@@YAXPAUStbTexteditRow@1@PAUImGuiTextEditState@@H@Z ; ImGuiStb::STB_TEXTEDIT_LAYOUTROW

; 405  :       if (r.num_chars <= 0)

	mov	ebx, DWORD PTR _r$[ebp+20]
	add	esp, 12					; 0000000cH
	test	ebx, ebx
	jle	$LN31@stb_text_l

; 406  :          return n;
; 407  : 
; 408  :       if (i==0 && y < base_y + r.ymin)

	test	esi, esi
	jne	SHORT $LN8@stb_text_l
	movss	xmm0, DWORD PTR _r$[ebp+12]
	addss	xmm0, xmm5
	comiss	xmm0, xmm6
	ja	SHORT $LN22@stb_text_l
$LN8@stb_text_l:

; 410  : 
; 411  :       if (y < base_y + r.ymax)

	movss	xmm0, DWORD PTR _r$[ebp+16]
	addss	xmm0, xmm5
	comiss	xmm0, xmm6
	ja	SHORT $LN23@stb_text_l

; 412  :          break;
; 413  : 
; 414  :       i += r.num_chars;
; 415  :       base_y += r.baseline_y_delta;

	addss	xmm5, DWORD PTR _r$[ebp+8]
	add	esi, ebx
	cmp	esi, edi
	jge	$LN31@stb_text_l

; 401  : 
; 402  :    // search rows to find one that straddles 'y'
; 403  :    while (i < n) {

	mov	ecx, DWORD PTR _str$[ebp]
	jmp	SHORT $LL2@stb_text_l
$LN22@stb_text_l:
	pop	edi
	pop	esi

; 409  :          return 0;

	xor	eax, eax
	pop	ebx

; 445  :       return i+r.num_chars-1;
; 446  :    else
; 447  :       return i+r.num_chars;
; 448  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@stb_text_l:

; 416  :    }
; 417  : 
; 418  :    // below all text, return 'after' last character
; 419  :    if (i >= n)

	cmp	esi, edi
	jge	$LN31@stb_text_l

; 421  : 
; 422  :    // check if it's before the beginning of the line
; 423  :    if (x < r.x0)

	movss	xmm2, DWORD PTR _r$[ebp]
	movss	xmm3, DWORD PTR _x$[ebp]
	comiss	xmm2, xmm3
	ja	SHORT $LN33@stb_text_l

; 424  :       return i;
; 425  : 
; 426  :    // check if it's before the end of the line
; 427  :    if (x < r.x1) {

	movss	xmm0, DWORD PTR _r$[ebp+4]
	comiss	xmm0, xmm3
	jbe	SHORT $LN5@stb_text_l

; 428  :       // search characters in row for one that straddles 'x'
; 429  :       prev_x = r.x0;
; 430  :       for (k=0; k < r.num_chars; ++k) {

	xor	edi, edi
	test	ebx, ebx
	jle	SHORT $LN5@stb_text_l
	npad	3
$LL6@stb_text_l:

; 431  :          float w = STB_TEXTEDIT_GETWIDTH(str, i, k);

	push	edi
	push	esi
	push	DWORD PTR _str$[ebp]
	call	?STB_TEXTEDIT_GETWIDTH@ImGuiStb@@YAMPAUImGuiTextEditState@@HH@Z ; ImGuiStb::STB_TEXTEDIT_GETWIDTH
	fstp	DWORD PTR _w$1[ebp]

; 432  :          if (x < prev_x+w) {

	movss	xmm1, DWORD PTR _w$1[ebp]
	add	esp, 12					; 0000000cH
	movaps	xmm0, xmm1
	addss	xmm0, xmm2
	comiss	xmm0, xmm3
	ja	SHORT $LN24@stb_text_l

; 437  :          }
; 438  :          prev_x += w;

	inc	edi
	movaps	xmm2, xmm0
	cmp	edi, ebx
	jl	SHORT $LL6@stb_text_l
$LN5@stb_text_l:

; 439  :       }
; 440  :       // shouldn't happen, but if it does, fall through to end-of-line case
; 441  :    }
; 442  : 
; 443  :    // if the last character is a newline, return that. otherwise return 'after' the last character
; 444  :    if (STB_TEXTEDIT_GETCHAR(str, i+r.num_chars-1) == STB_TEXTEDIT_NEWLINE)

	add	esi, ebx
	lea	edx, DWORD PTR [esi-1]
	push	edx
	push	DWORD PTR _str$[ebp]
	call	?STB_TEXTEDIT_GETCHAR@ImGuiStb@@YAGPBUImGuiTextEditState@@H@Z ; ImGuiStb::STB_TEXTEDIT_GETCHAR
	add	esp, 8
	cmp	ax, WORD PTR ?STB_TEXTEDIT_NEWLINE@ImGuiStb@@3GA
	cmove	esi, edx
$LN33@stb_text_l:
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 445  :       return i+r.num_chars-1;
; 446  :    else
; 447  :       return i+r.num_chars;
; 448  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@stb_text_l:

; 433  :             if (x < prev_x+w/2)

	mulss	xmm1, DWORD PTR __real@3f000000
	addss	xmm1, xmm2
	comiss	xmm1, xmm3
	jbe	SHORT $LN14@stb_text_l

; 434  :                return k+i;

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
	pop	ebx

; 445  :       return i+r.num_chars-1;
; 446  :    else
; 447  :       return i+r.num_chars;
; 448  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@stb_text_l:

; 435  :             else
; 436  :                return k+i+1;

	lea	eax, DWORD PTR [esi+1]
	add	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 445  :       return i+r.num_chars-1;
; 446  :    else
; 447  :       return i+r.num_chars;
; 448  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN31@stb_text_l:

; 420  :       return n;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 445  :       return i+r.num_chars-1;
; 446  :    else
; 447  :       return i+r.num_chars;
; 448  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?stb_text_locate_coord@ImGuiStb@@YAHPAUImGuiTextEditState@@MM@Z ENDP ; ImGuiStb::stb_text_locate_coord
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_text$1$ = 8						; size = 4
_obj$ = 8						; size = 4
_pos$ = 12						; size = 4
_new_text$ = 16						; size = 4
_new_text_len_utf8$1$ = 20				; size = 4
_new_text_len$ = 20					; size = 4
?STB_TEXTEDIT_INSERTCHARS@ImGuiStb@@YA_NPAUImGuiTextEditState@@HPBGH@Z PROC ; ImGuiStb::STB_TEXTEDIT_INSERTCHARS

; 8550 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx

; 8551 :     const int text_len = obj->CurLenW;
; 8552 :     IM_ASSERT(pos <= text_len);
; 8553 :     if (new_text_len + text_len + 1 > obj->Text.Size)

	mov	ebx, DWORD PTR _new_text_len$[ebp]
	push	esi
	mov	esi, DWORD PTR _obj$[ebp]
	push	edi
	lea	eax, DWORD PTR [ebx+1]
	mov	edi, DWORD PTR [esi+44]
	add	eax, edi
	cmp	eax, DWORD PTR [esi+4]
	jle	SHORT $LN2@STB_TEXTED
$LN8@STB_TEXTED:
	pop	edi
	pop	esi

; 8554 :         return false;

	xor	al, al
	pop	ebx

; 8570 : }

	pop	ebp
	ret	0
$LN2@STB_TEXTED:

; 8555 : 
; 8556 :     const int new_text_len_utf8 = ImTextCountUtf8BytesFromStr(new_text, new_text + new_text_len);

	mov	ecx, DWORD PTR _new_text$[ebp]
	lea	eax, DWORD PTR [ebx+ebx]
	add	eax, ecx
	push	eax
	push	ecx
	call	?ImTextCountUtf8BytesFromStr@@YAHPBG0@Z	; ImTextCountUtf8BytesFromStr

; 8557 :     if (new_text_len_utf8 + obj->CurLenA + 1 > obj->BufSizeA)

	mov	ecx, DWORD PTR [esi+40]
	add	esp, 8
	inc	ecx
	mov	DWORD PTR _new_text_len_utf8$1$[ebp], eax
	add	ecx, eax
	cmp	ecx, DWORD PTR [esi+48]
	jg	SHORT $LN8@STB_TEXTED

; 8558 :         return false;
; 8559 : 
; 8560 :     ImWchar* text = obj->Text.Data;
; 8561 :     if (pos != text_len)

	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [esi+12]
	mov	DWORD PTR _text$1$[ebp], edx
	cmp	ecx, edi
	je	SHORT $LN4@STB_TEXTED

; 8562 :         memmove(text + pos + new_text_len, text + pos, (size_t)(text_len - pos) * sizeof(ImWchar));

	sub	edi, ecx
	lea	eax, DWORD PTR [edx+ecx*2]
	add	edi, edi
	push	edi
	push	eax
	lea	eax, DWORD PTR [ecx+ebx]
	lea	eax, DWORD PTR [edx+eax*2]
	push	eax
	call	DWORD PTR __imp__memmove
	mov	ecx, DWORD PTR _pos$[ebp]
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _text$1$[ebp]
$LN4@STB_TEXTED:

; 8563 :     memcpy(text + pos, new_text, (size_t)new_text_len * sizeof(ImWchar));

	lea	eax, DWORD PTR [ebx+ebx]
	push	eax
	push	DWORD PTR _new_text$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	push	eax
	call	_memcpy

; 8564 : 
; 8565 :     obj->CurLenW += new_text_len;

	add	DWORD PTR [esi+44], ebx
	add	esp, 12					; 0000000cH

; 8566 :     obj->CurLenA += new_text_len_utf8;

	mov	eax, DWORD PTR _new_text_len_utf8$1$[ebp]
	add	DWORD PTR [esi+40], eax

; 8567 :     obj->Text[obj->CurLenW] = '\0';

	xor	edx, edx
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi+44]
	pop	edi
	pop	esi
	pop	ebx
	mov	WORD PTR [eax+ecx*2], dx

; 8568 : 
; 8569 :     return true;

	mov	al, 1

; 8570 : }

	pop	ebp
	ret	0
?STB_TEXTEDIT_INSERTCHARS@ImGuiStb@@YA_NPAUImGuiTextEditState@@HPBGH@Z ENDP ; ImGuiStb::STB_TEXTEDIT_INSERTCHARS
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
tv181 = -4						; size = 4
_obj$ = 8						; size = 4
_pos$ = 12						; size = 4
_n$ = 16						; size = 4
?STB_TEXTEDIT_DELETECHARS@ImGuiStb@@YAXPAUImGuiTextEditState@@HH@Z PROC ; ImGuiStb::STB_TEXTEDIT_DELETECHARS

; 8535 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 8536 :     ImWchar* dst = obj->Text.Data + pos;

	mov	eax, DWORD PTR _obj$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _pos$[ebp]
	push	esi
	mov	eax, DWORD PTR [eax+12]
	push	edi

; 8537 : 
; 8538 :     // We maintain our buffer length in both UTF-8 and wchar formats
; 8539 :     obj->CurLenA -= ImTextCountUtf8BytesFromStr(dst, dst + n);

	mov	edi, DWORD PTR _n$[ebp]
	mov	DWORD PTR tv181[ebp], eax
	lea	esi, DWORD PTR [eax+ebx*2]
	lea	eax, DWORD PTR [esi+edi*2]
	push	eax
	push	esi
	call	?ImTextCountUtf8BytesFromStr@@YAHPBG0@Z	; ImTextCountUtf8BytesFromStr
	mov	ecx, DWORD PTR _obj$[ebp]
	add	esp, 8
	sub	DWORD PTR [ecx+40], eax

; 8540 :     obj->CurLenW -= n;
; 8541 : 
; 8542 :     // Offset remaining text
; 8543 :     const ImWchar* src = obj->Text.Data + pos + n;

	lea	eax, DWORD PTR [ebx+edi]
	sub	DWORD PTR [ecx+44], edi
	mov	ecx, DWORD PTR tv181[ebp]
	lea	eax, DWORD PTR [ecx+eax*2]

; 8544 :     while (ImWchar c = *src++)

	movzx	ecx, WORD PTR [eax]
	add	eax, 2
	test	cx, cx
	je	SHORT $LN9@STB_TEXTED
$LL2@STB_TEXTED:

; 8545 :         *dst++ = c;

	mov	WORD PTR [esi], cx
	lea	esi, DWORD PTR [esi+2]
	movzx	ecx, WORD PTR [eax]
	lea	eax, DWORD PTR [eax+2]
	test	cx, cx
	jne	SHORT $LL2@STB_TEXTED
$LN9@STB_TEXTED:

; 8546 :     *dst = '\0';

	xor	eax, eax
	pop	edi
	mov	WORD PTR [esi], ax
	pop	esi
	pop	ebx

; 8547 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?STB_TEXTEDIT_DELETECHARS@ImGuiStb@@YAXPAUImGuiTextEditState@@HH@Z ENDP ; ImGuiStb::STB_TEXTEDIT_DELETECHARS
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_obj$ = 8						; size = 4
_idx$ = 12						; size = 4
?STB_TEXTEDIT_MOVEWORDRIGHT_IMPL@ImGuiStb@@YAHPAUImGuiTextEditState@@H@Z PROC ; ImGuiStb::STB_TEXTEDIT_MOVEWORDRIGHT_IMPL

; 8529 : static int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)  { idx++; int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_right(obj, idx)) idx++; return idx > len ? len : idx; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _idx$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _obj$[ebp]
	inc	edx
	mov	esi, DWORD PTR [edi+44]
	cmp	edx, esi
	jge	SHORT $LN10@STB_TEXTED
$LL2@STB_TEXTED:
	push	edx
	push	edi
	call	?is_word_boundary_from_right@ImGuiStb@@YAHPAUImGuiTextEditState@@H@Z ; ImGuiStb::is_word_boundary_from_right
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@STB_TEXTED
	inc	edx
	cmp	edx, esi
	jl	SHORT $LL2@STB_TEXTED
$LN9@STB_TEXTED:
	cmp	edx, esi
$LN10@STB_TEXTED:
	cmovg	edx, esi
	pop	edi
	mov	eax, edx
	pop	esi
	pop	ebp
	ret	0
?STB_TEXTEDIT_MOVEWORDRIGHT_IMPL@ImGuiStb@@YAHPAUImGuiTextEditState@@H@Z ENDP ; ImGuiStb::STB_TEXTEDIT_MOVEWORDRIGHT_IMPL
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_obj$ = 8						; size = 4
_idx$ = 12						; size = 4
?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImGuiStb@@YAHPAUImGuiTextEditState@@H@Z PROC ; ImGuiStb::STB_TEXTEDIT_MOVEWORDLEFT_IMPL

; 8524 : static int  STB_TEXTEDIT_MOVEWORDLEFT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)   { idx--; while (idx >= 0 && !is_word_boundary_from_right(obj, idx)) idx--; return idx < 0 ? 0 : idx; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _idx$[ebp]
	sub	edx, 1
	js	SHORT $LN9@STB_TEXTED
	push	esi
	mov	esi, DWORD PTR _obj$[ebp]
$LL2@STB_TEXTED:
	push	edx
	push	esi
	call	?is_word_boundary_from_right@ImGuiStb@@YAHPAUImGuiTextEditState@@H@Z ; ImGuiStb::is_word_boundary_from_right
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@STB_TEXTED
	sub	edx, 1
	jns	SHORT $LL2@STB_TEXTED
$LN10@STB_TEXTED:
	pop	esi
$LN9@STB_TEXTED:
	xor	eax, eax
	test	edx, edx
	cmovs	edx, eax
	mov	eax, edx
	pop	ebp
	ret	0
?STB_TEXTEDIT_MOVEWORDLEFT_IMPL@ImGuiStb@@YAHPAUImGuiTextEditState@@H@Z ENDP ; ImGuiStb::STB_TEXTEDIT_MOVEWORDLEFT_IMPL
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_obj$ = 8						; size = 4
_idx$ = 12						; size = 4
?is_word_boundary_from_right@ImGuiStb@@YAHPAUImGuiTextEditState@@H@Z PROC ; ImGuiStb::is_word_boundary_from_right

; 8523 : static int  is_word_boundary_from_right(STB_TEXTEDIT_STRING* obj, int idx)      { return idx > 0 ? (is_separator( obj->Text[idx-1] ) && !is_separator( obj->Text[idx] ) ) : 1; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR _idx$[ebp]
	test	ecx, ecx
	jle	SHORT $LN5@is_word_bo
	mov	eax, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [eax+12]
	lea	ecx, DWORD PTR [eax+ecx*2]
	movzx	eax, WORD PTR [ecx-2]
	push	eax
	call	?is_separator@ImGuiStb@@YA_NI@Z		; ImGuiStb::is_separator
	add	esp, 4
	test	al, al
	je	SHORT $LN3@is_word_bo
	movzx	eax, WORD PTR [ecx]
	push	eax
	call	?is_separator@ImGuiStb@@YA_NI@Z		; ImGuiStb::is_separator
	add	esp, 4
	test	al, al
	je	SHORT $LN5@is_word_bo
$LN3@is_word_bo:
	xor	eax, eax
	pop	ebp
	ret	0
$LN5@is_word_bo:
	mov	eax, 1
	pop	ebp
	ret	0
?is_word_boundary_from_right@ImGuiStb@@YAHPAUImGuiTextEditState@@H@Z ENDP ; ImGuiStb::is_word_boundary_from_right
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_c$ = 8							; size = 4
?is_separator@ImGuiStb@@YA_NI@Z PROC			; ImGuiStb::is_separator

; 8522 : static bool is_separator(unsigned int c)                                        { return ImCharIsSpace(c) || c==',' || c==';' || c=='(' || c==')' || c=='{' || c=='}' || c=='[' || c==']' || c=='|'; }

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 96   : static inline bool      ImCharIsSpace(int c)            { return c == ' ' || c == '\t' || c == 0x3000; }

	mov	eax, DWORD PTR _c$[ebp]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN3@is_separat
	cmp	eax, 9
	je	SHORT $LN3@is_separat
	cmp	eax, 12288				; 00003000H
	je	SHORT $LN3@is_separat
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8522 : static bool is_separator(unsigned int c)                                        { return ImCharIsSpace(c) || c==',' || c==';' || c=='(' || c==')' || c=='{' || c=='}' || c=='[' || c==']' || c=='|'; }

	cmp	eax, 44					; 0000002cH
	je	SHORT $LN3@is_separat
	cmp	eax, 59					; 0000003bH
	je	SHORT $LN3@is_separat
	cmp	eax, 40					; 00000028H
	je	SHORT $LN3@is_separat
	cmp	eax, 41					; 00000029H
	je	SHORT $LN3@is_separat
	cmp	eax, 123				; 0000007bH
	je	SHORT $LN3@is_separat
	cmp	eax, 125				; 0000007dH
	je	SHORT $LN3@is_separat
	cmp	eax, 91					; 0000005bH
	je	SHORT $LN3@is_separat
	cmp	eax, 93					; 0000005dH
	je	SHORT $LN3@is_separat
	cmp	eax, 124				; 0000007cH
	je	SHORT $LN3@is_separat
	xor	al, al
	pop	ebp
	ret	0
$LN3@is_separat:
	mov	al, 1
	pop	ebp
	ret	0
?is_separator@ImGuiStb@@YA_NI@Z ENDP			; ImGuiStb::is_separator
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_size$ = -8						; size = 8
_r$ = 8							; size = 4
_text_remaining$ = 12					; size = 4
_obj$ = 12						; size = 4
_line_start_idx$ = 16					; size = 4
?STB_TEXTEDIT_LAYOUTROW@ImGuiStb@@YAXPAUStbTexteditRow@1@PAUImGuiTextEditState@@H@Z PROC ; ImGuiStb::STB_TEXTEDIT_LAYOUTROW

; 8510 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 8511 :     const ImWchar* text = obj->Text.Data;
; 8512 :     const ImWchar* text_remaining = NULL;
; 8513 :     const ImVec2 size = InputTextCalcTextSizeW(text + line_start_idx, text + obj->CurLenW, &text_remaining, NULL, true);

	mov	eax, DWORD PTR _line_start_idx$[ebp]
	mov	ecx, DWORD PTR _obj$[ebp]
	push	esi
	push	edi
	lea	esi, DWORD PTR [eax+eax]
	mov	DWORD PTR _text_remaining$[ebp], 0
	mov	edi, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR _text_remaining$[ebp]
	push	1
	push	0
	push	eax
	mov	eax, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR [edi+eax*2]
	push	eax
	lea	eax, DWORD PTR [esi+edi]
	push	eax
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	call	?InputTextCalcTextSizeW@@YA?AUImVec2@@PBG0PAPBGPAU1@_N@Z ; InputTextCalcTextSizeW

; 8514 :     r->x0 = 0.0f;

	mov	ecx, DWORD PTR _r$[ebp]
	add	esp, 24					; 00000018H

; 8515 :     r->x1 = size.x;
; 8516 :     r->baseline_y_delta = size.y;
; 8517 :     r->ymin = 0.0f;
; 8518 :     r->ymax = size.y;
; 8519 :     r->num_chars = (int)(text_remaining - (text + line_start_idx));

	mov	eax, DWORD PTR _text_remaining$[ebp]
	movss	xmm0, DWORD PTR _size$[ebp]
	sub	eax, esi
	sub	eax, edi
	movss	DWORD PTR [ecx+4], xmm0
	movss	xmm0, DWORD PTR _size$[ebp+4]
	sar	eax, 1
	pop	edi
	mov	DWORD PTR [ecx], 0
	movss	DWORD PTR [ecx+8], xmm0
	mov	DWORD PTR [ecx+12], 0
	movss	DWORD PTR [ecx+16], xmm0
	mov	DWORD PTR [ecx+20], eax
	pop	esi

; 8520 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?STB_TEXTEDIT_LAYOUTROW@ImGuiStb@@YAXPAUStbTexteditRow@1@PAUImGuiTextEditState@@H@Z ENDP ; ImGuiStb::STB_TEXTEDIT_LAYOUTROW
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_key$ = 8						; size = 4
?STB_TEXTEDIT_KEYTOTEXT@ImGuiStb@@YAHH@Z PROC		; ImGuiStb::STB_TEXTEDIT_KEYTOTEXT

; 8507 : static int     STB_TEXTEDIT_KEYTOTEXT(int key)                                                    { return key >= 0x10000 ? 0 : key; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _key$[ebp]
	xor	ecx, ecx
	cmp	eax, 65536				; 00010000H
	cmovge	eax, ecx
	pop	ebp
	ret	0
?STB_TEXTEDIT_KEYTOTEXT@ImGuiStb@@YAHH@Z ENDP		; ImGuiStb::STB_TEXTEDIT_KEYTOTEXT
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_obj$ = 8						; size = 4
_line_start_idx$ = 12					; size = 4
tv91 = 16						; size = 4
_char_idx$ = 16						; size = 4
?STB_TEXTEDIT_GETWIDTH@ImGuiStb@@YAMPAUImGuiTextEditState@@HH@Z PROC ; ImGuiStb::STB_TEXTEDIT_GETWIDTH

; 8506 : static float   STB_TEXTEDIT_GETWIDTH(STB_TEXTEDIT_STRING* obj, int line_start_idx, int char_idx)  { ImWchar c = obj->Text[line_start_idx+char_idx]; if (c == '\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; return GImGui->Font->GetCharAdvance(c) * (GImGui->FontSize / GImGui->Font->FontSize); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR _char_idx$[ebp]
	add	ecx, DWORD PTR _line_start_idx$[ebp]
	mov	eax, DWORD PTR [eax+12]
	movzx	eax, WORD PTR [eax+ecx*2]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN2@STB_TEXTED
	fld	DWORD PTR __real@bf800000
	pop	ebp
	ret	0
$LN2@STB_TEXTED:
	push	esi
	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1437 :     float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexXAdvance.Size) ? IndexXAdvance[(int)c] : FallbackXAdvance; }

	mov	edx, eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8506 : static float   STB_TEXTEDIT_GETWIDTH(STB_TEXTEDIT_STRING* obj, int line_start_idx, int char_idx)  { ImWchar c = obj->Text[line_start_idx+char_idx]; if (c == '\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; return GImGui->Font->GetCharAdvance(c) * (GImGui->FontSize / GImGui->Font->FontSize); }

	mov	ecx, DWORD PTR [esi+6168]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1437 :     float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexXAdvance.Size) ? IndexXAdvance[(int)c] : FallbackXAdvance; }

	cmp	edx, DWORD PTR [ecx+28]
	jge	SHORT $LN8@STB_TEXTED
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8506 : static float   STB_TEXTEDIT_GETWIDTH(STB_TEXTEDIT_STRING* obj, int line_start_idx, int char_idx)  { ImWchar c = obj->Text[line_start_idx+char_idx]; if (c == '\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; return GImGui->Font->GetCharAdvance(c) * (GImGui->FontSize / GImGui->Font->FontSize); }

	fld	DWORD PTR [esi+6172]
	fdiv	DWORD PTR [ecx]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1437 :     float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexXAdvance.Size) ? IndexXAdvance[(int)c] : FallbackXAdvance; }

	mov	eax, DWORD PTR [ecx+36]
	pop	esi
	movss	xmm0, DWORD PTR [eax+edx*4]
	movss	DWORD PTR tv91[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8506 : static float   STB_TEXTEDIT_GETWIDTH(STB_TEXTEDIT_STRING* obj, int line_start_idx, int char_idx)  { ImWchar c = obj->Text[line_start_idx+char_idx]; if (c == '\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; return GImGui->Font->GetCharAdvance(c) * (GImGui->FontSize / GImGui->Font->FontSize); }

	fmul	DWORD PTR tv91[ebp]
	pop	ebp
	ret	0
$LN8@STB_TEXTED:
	fld	DWORD PTR [esi+6172]
	fdiv	DWORD PTR [ecx]
	pop	esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1437 :     float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexXAdvance.Size) ? IndexXAdvance[(int)c] : FallbackXAdvance; }

	movss	xmm0, DWORD PTR [ecx+56]
	movss	DWORD PTR tv91[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8506 : static float   STB_TEXTEDIT_GETWIDTH(STB_TEXTEDIT_STRING* obj, int line_start_idx, int char_idx)  { ImWchar c = obj->Text[line_start_idx+char_idx]; if (c == '\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; return GImGui->Font->GetCharAdvance(c) * (GImGui->FontSize / GImGui->Font->FontSize); }

	fmul	DWORD PTR tv91[ebp]
	pop	ebp
	ret	0
?STB_TEXTEDIT_GETWIDTH@ImGuiStb@@YAMPAUImGuiTextEditState@@HH@Z ENDP ; ImGuiStb::STB_TEXTEDIT_GETWIDTH
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_obj$ = 8						; size = 4
_idx$ = 12						; size = 4
?STB_TEXTEDIT_GETCHAR@ImGuiStb@@YAGPBUImGuiTextEditState@@H@Z PROC ; ImGuiStb::STB_TEXTEDIT_GETCHAR

; 8505 : static ImWchar STB_TEXTEDIT_GETCHAR(const STB_TEXTEDIT_STRING* obj, int idx)                      { return obj->Text[idx]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _obj$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR _idx$[ebp]
	mov	ax, WORD PTR [ecx+eax*2]
	pop	ebp
	ret	0
?STB_TEXTEDIT_GETCHAR@ImGuiStb@@YAGPBUImGuiTextEditState@@H@Z ENDP ; ImGuiStb::STB_TEXTEDIT_GETCHAR
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_obj$ = 8						; size = 4
?STB_TEXTEDIT_STRINGLEN@ImGuiStb@@YAHPBUImGuiTextEditState@@@Z PROC ; ImGuiStb::STB_TEXTEDIT_STRINGLEN

; 8504 : static int     STB_TEXTEDIT_STRINGLEN(const STB_TEXTEDIT_STRING* obj)                             { return obj->CurLenW; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _obj$[ebp]
	mov	eax, DWORD PTR [eax+44]
	pop	ebp
	ret	0
?STB_TEXTEDIT_STRINGLEN@ImGuiStb@@YAHPBUImGuiTextEditState@@@Z ENDP ; ImGuiStb::STB_TEXTEDIT_STRINGLEN
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_data$ = 8						; size = 4
_idx$ = 12						; size = 4
?Plot_ArrayGetter@@YAMPAXH@Z PROC			; Plot_ArrayGetter

; 8246 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 8247 :     ImGuiPlotArrayGetterData* plot_data = (ImGuiPlotArrayGetterData*)data;
; 8248 :     const float v = *(float*)(void*)((unsigned char*)plot_data->Values + (size_t)idx * plot_data->Stride);

	mov	eax, DWORD PTR _data$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, DWORD PTR _idx$[ebp]

; 8249 :     return v;

	mov	eax, DWORD PTR [eax]
	fld	DWORD PTR [ecx+eax]

; 8250 : }

	pop	ebp
	ret	0
?Plot_ArrayGetter@@YAMPAXH@Z ENDP			; Plot_ArrayGetter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
;	COMDAT ??0ImGuiPlotArrayGetterData@@QAE@PBMH@Z
_TEXT	SEGMENT
_values$ = 8						; size = 4
_stride$ = 12						; size = 4
??0ImGuiPlotArrayGetterData@@QAE@PBMH@Z PROC		; ImGuiPlotArrayGetterData::ImGuiPlotArrayGetterData, COMDAT
; _this$ = ecx

; 8242 :     ImGuiPlotArrayGetterData(const float* values, int stride) { Values = values; Stride = stride; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _values$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR _stride$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, ecx
	pop	ebp
	ret	8
??0ImGuiPlotArrayGetterData@@QAE@PBMH@Z ENDP		; ImGuiPlotArrayGetterData::ImGuiPlotArrayGetterData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_v$ = 8							; size = 4
tv222 = 12						; size = 4
tv210 = 12						; size = 4
tv205 = 12						; size = 4
_v_min$ = 12						; size = 4
_v_max$ = 16						; size = 4
_power$ = 20						; size = 4
_linear_zero_pos$ = 24					; size = 4
?SliderBehaviorCalcRatioFromValue@@YAMMMMMM@Z PROC	; SliderBehaviorCalcRatioFromValue

; 7440 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 7441 :     if (v_min == v_max)

	movss	xmm3, DWORD PTR _v_min$[ebp]
	movss	xmm1, DWORD PTR _v_max$[ebp]
	ucomiss	xmm3, xmm1
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@SliderBeha

; 7442 :         return 0.0f;

	fldz

; 7462 : }

	pop	ebp
	ret	0
$LN2@SliderBeha:

; 7443 : 
; 7444 :     const bool is_non_linear = (power < 1.0f-0.00001f) || (power > 1.0f+0.00001f);

	movss	xmm0, DWORD PTR __real@3f7fff58
	movss	xmm4, DWORD PTR _power$[ebp]
	comiss	xmm0, xmm4
	ja	SHORT $LN7@SliderBeha
	comiss	xmm4, DWORD PTR __real@3f800054
	ja	SHORT $LN7@SliderBeha
	xor	al, al
	jmp	SHORT $LN8@SliderBeha
$LN7@SliderBeha:
	mov	al, 1
$LN8@SliderBeha:

; 7445 :     const float v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);

	comiss	xmm1, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	movss	xmm2, DWORD PTR _v$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7445 :     const float v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);

	jbe	SHORT $LN9@SliderBeha
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm3, xmm2
	jbe	SHORT $LN15@SliderBeha
	movaps	xmm2, xmm3
	jmp	SHORT $LN22@SliderBeha
$LN15@SliderBeha:
	minss	xmm2, xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7445 :     const float v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);

	jmp	SHORT $LN22@SliderBeha
$LN9@SliderBeha:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm1, xmm2
	jbe	SHORT $LN21@SliderBeha
	movaps	xmm2, xmm1
	jmp	SHORT $LN22@SliderBeha
$LN21@SliderBeha:
	minss	xmm2, xmm3
$LN22@SliderBeha:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7446 :     if (is_non_linear)

	test	al, al
	je	$LN5@SliderBeha

; 7447 :     {
; 7448 :         if (v_clamped < 0.0f)

	xorps	xmm0, xmm0
	comiss	xmm0, xmm2
	jbe	SHORT $LN4@SliderBeha

; 7449 :         {
; 7450 :             const float f = 1.0f - (v_clamped - v_min) / (ImMin(0.0f,v_max) - v_min);

	minss	xmm1, xmm0
	subss	xmm2, xmm3
	subss	xmm1, xmm3
	divss	xmm2, xmm1
	movss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm0, xmm1

; 7451 :             return (1.0f - powf(f, 1.0f/power)) * linear_zero_pos;

	divss	xmm1, xmm4
	subss	xmm0, xmm2
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 731  :         return (float)pow(_X, _Y);

	call	___libm_sse2_powf
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7451 :             return (1.0f - powf(f, 1.0f/power)) * linear_zero_pos;

	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	mulss	xmm1, DWORD PTR _linear_zero_pos$[ebp]
	movss	DWORD PTR tv222[ebp], xmm1
	fld	DWORD PTR tv222[ebp]

; 7462 : }

	pop	ebp
	ret	0
$LN4@SliderBeha:
	maxss	xmm3, xmm0

; 7452 :         }
; 7453 :         else
; 7454 :         {
; 7455 :             const float f = (v_clamped - ImMax(0.0f,v_min)) / (v_max - ImMax(0.0f,v_min));

	subss	xmm1, xmm3
	subss	xmm2, xmm3
	divss	xmm2, xmm1

; 7456 :             return linear_zero_pos + powf(f, 1.0f/power) * (1.0f - linear_zero_pos);

	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm4
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 731  :         return (float)pow(_X, _Y);

	movaps	xmm0, xmm2
	call	___libm_sse2_powf
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7456 :             return linear_zero_pos + powf(f, 1.0f/power) * (1.0f - linear_zero_pos);

	movss	xmm2, DWORD PTR __real@3f800000
	subss	xmm2, DWORD PTR _linear_zero_pos$[ebp]
	mulss	xmm0, xmm2
	addss	xmm0, DWORD PTR _linear_zero_pos$[ebp]
	movss	DWORD PTR tv210[ebp], xmm0
	fld	DWORD PTR tv210[ebp]

; 7462 : }

	pop	ebp
	ret	0
$LN5@SliderBeha:

; 7457 :         }
; 7458 :     }
; 7459 : 
; 7460 :     // Linear slider
; 7461 :     return (v_clamped - v_min) / (v_max - v_min);

	subss	xmm2, xmm3
	subss	xmm1, xmm3
	divss	xmm2, xmm1
	movss	DWORD PTR tv205[ebp], xmm2
	fld	DWORD PTR tv205[ebp]

; 7462 : }

	pop	ebp
	ret	0
?SliderBehaviorCalcRatioFromValue@@YAMMMMMM@Z ENDP	; SliderBehaviorCalcRatioFromValue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
tv73 = 8						; size = 4
_decimal_precision$ = 8					; size = 4
?GetMinimumStepAtDecimalPrecision@@YAMH@Z PROC		; GetMinimumStepAtDecimalPrecision

; 7418 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 7420 :     return (decimal_precision >= 0 && decimal_precision < 10) ? min_steps[decimal_precision] : powf(10.0f, (float)-decimal_precision);

	mov	eax, DWORD PTR _decimal_precision$[ebp]
	cmp	eax, 9
	ja	SHORT $LN3@GetMinimum
	movss	xmm0, DWORD PTR ?min_steps@?1??GetMinimumStepAtDecimalPrecision@@YAMH@Z@4QBMB[eax*4]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 731  :         return (float)pow(_X, _Y);

	movss	DWORD PTR tv73[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7420 :     return (decimal_precision >= 0 && decimal_precision < 10) ? min_steps[decimal_precision] : powf(10.0f, (float)-decimal_precision);

	fld	DWORD PTR tv73[ebp]

; 7421 : }

	pop	ebp
	ret	0
$LN3@GetMinimum:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 731  :         return (float)pow(_X, _Y);

	movss	xmm0, DWORD PTR __real@41200000
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7420 :     return (decimal_precision >= 0 && decimal_precision < 10) ? min_steps[decimal_precision] : powf(10.0f, (float)-decimal_precision);

	neg	eax
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 731  :         return (float)pow(_X, _Y);

	call	___libm_sse2_powf
	movss	DWORD PTR tv73[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7420 :     return (decimal_precision >= 0 && decimal_precision < 10) ? min_steps[decimal_precision] : powf(10.0f, (float)-decimal_precision);

	fld	DWORD PTR tv73[ebp]

; 7421 : }

	pop	ebp
	ret	0
?GetMinimumStepAtDecimalPrecision@@YAMH@Z ENDP		; GetMinimumStepAtDecimalPrecision
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_idx$ = 8						; size = 4
?GetStyleVarInfo@@YAPBUImGuiStyleVarInfo@@H@Z PROC	; GetStyleVarInfo

; 5693 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 5694 :     IM_ASSERT(idx >= 0 && idx < ImGuiStyleVar_Count_);
; 5695 :     return &GStyleVarInfo[idx];

	mov	eax, DWORD PTR _idx$[ebp]
	lea	eax, DWORD PTR ?GStyleVarInfo@@3QBUImGuiStyleVarInfo@@B[eax*8]

; 5696 : }

	pop	ebp
	ret	0
?GetStyleVarInfo@@YAPBUImGuiStyleVarInfo@@H@Z ENDP	; GetStyleVarInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
;	COMDAT ?GetVarPtr@ImGuiStyleVarInfo@@QBEPAXXZ
_TEXT	SEGMENT
?GetVarPtr@ImGuiStyleVarInfo@@QBEPAXXZ PROC		; ImGuiStyleVarInfo::GetVarPtr, COMDAT
; _this$ = ecx

; 5673 :     void*           GetVarPtr() const { return (void*)((unsigned char*)&GImGui->Style + Offset); }

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	ecx, DWORD PTR [ecx+4]
	add	eax, 5320				; 000014c8H
	add	eax, ecx
	ret	0
?GetVarPtr@ImGuiStyleVarInfo@@QBEPAXXZ ENDP		; ImGuiStyleVarInfo::GetVarPtr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_data$1 = -28						; size = 28
_cr$2 = -16						; size = 16
_window$ = 8						; size = 4
_new_size$ = 12						; size = 8
?ApplySizeFullWithConstraint@@YAXPAUImGuiWindow@@UImVec2@@@Z PROC ; ApplySizeFullWithConstraint

; 4687 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi

; 4688 :     ImGuiContext& g = *GImGui;
; 4689 :     if (g.SetNextWindowSizeConstraint)

	mov	esi, DWORD PTR _window$[ebp]
	push	edi
	mov	edi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	cmp	BYTE PTR [edi+6588], 0
	je	$LN42@ApplySizeF

; 4690 :     {
; 4691 :         // Using -1,-1 on either X/Y axis to preserve the current size.
; 4692 :         ImRect cr = g.SetNextWindowSizeConstraintRect;

	movups	xmm2, XMMWORD PTR [edi+6564]
	xorps	xmm0, xmm0

; 4693 :         new_size.x = (cr.Min.x >= 0 && cr.Max.x >= 0) ? ImClamp(new_size.x, cr.Min.x, cr.Max.x) : window->SizeFull.x;

	comiss	xmm2, xmm0
	movups	XMMWORD PTR _cr$2[ebp], xmm2
	jb	SHORT $LN6@ApplySizeF
	movss	xmm3, DWORD PTR _cr$2[ebp+8]
	comiss	xmm3, xmm0
	jb	SHORT $LN6@ApplySizeF
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	movss	xmm1, DWORD PTR _new_size$[ebp]
	comiss	xmm2, xmm1
	jbe	SHORT $LN14@ApplySizeF
	movaps	xmm1, xmm2
	jmp	SHORT $LN43@ApplySizeF
$LN14@ApplySizeF:
	comiss	xmm1, xmm3
	jbe	SHORT $LN7@ApplySizeF
	movaps	xmm1, xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4693 :         new_size.x = (cr.Min.x >= 0 && cr.Max.x >= 0) ? ImClamp(new_size.x, cr.Min.x, cr.Max.x) : window->SizeFull.x;

	jmp	SHORT $LN43@ApplySizeF
$LN6@ApplySizeF:
	movss	xmm1, DWORD PTR [esi+40]
$LN43@ApplySizeF:
	movss	DWORD PTR _new_size$[ebp], xmm1
$LN7@ApplySizeF:

; 4694 :         new_size.y = (cr.Min.y >= 0 && cr.Max.y >= 0) ? ImClamp(new_size.y, cr.Min.y, cr.Max.y) : window->SizeFull.y;

	movss	xmm3, DWORD PTR _cr$2[ebp+4]
	comiss	xmm3, xmm0
	jb	SHORT $LN8@ApplySizeF
	movss	xmm4, DWORD PTR _cr$2[ebp+12]
	comiss	xmm4, xmm0
	jb	SHORT $LN8@ApplySizeF
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	movss	xmm2, DWORD PTR _new_size$[ebp+4]
	comiss	xmm3, xmm2
	jbe	SHORT $LN20@ApplySizeF
	movaps	xmm2, xmm3
	jmp	SHORT $LN44@ApplySizeF
$LN20@ApplySizeF:
	comiss	xmm2, xmm4
	jbe	SHORT $LN9@ApplySizeF
	movaps	xmm2, xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4694 :         new_size.y = (cr.Min.y >= 0 && cr.Max.y >= 0) ? ImClamp(new_size.y, cr.Min.y, cr.Max.y) : window->SizeFull.y;

	jmp	SHORT $LN44@ApplySizeF
$LN8@ApplySizeF:
	movss	xmm2, DWORD PTR [esi+44]
$LN44@ApplySizeF:
	movss	DWORD PTR _new_size$[ebp+4], xmm2
$LN9@ApplySizeF:

; 4695 :         if (g.SetNextWindowSizeConstraintCallback)

	mov	ecx, DWORD PTR [edi+6580]
	test	ecx, ecx
	je	SHORT $LN3@ApplySizeF

; 4696 :         {
; 4697 :             ImGuiSizeConstraintCallbackData data;
; 4698 :             data.UserData = g.SetNextWindowSizeConstraintCallbackUserData;

	mov	eax, DWORD PTR [edi+6584]
	mov	DWORD PTR _data$1[ebp], eax

; 4699 :             data.Pos = window->Pos;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR _data$1[ebp+4], eax
	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR _data$1[ebp+8], eax

; 4700 :             data.CurrentSize = window->SizeFull;

	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR _data$1[ebp+12], eax
	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR _data$1[ebp+16], eax

; 4701 :             data.DesiredSize = new_size;
; 4702 :             g.SetNextWindowSizeConstraintCallback(&data);

	lea	eax, DWORD PTR _data$1[ebp]
	push	eax
	movss	DWORD PTR _data$1[ebp+20], xmm1
	movss	DWORD PTR _data$1[ebp+24], xmm2
	call	ecx
	movss	xmm1, DWORD PTR _data$1[ebp+20]
	add	esp, 4
	movss	xmm2, DWORD PTR _data$1[ebp+24]
	movss	DWORD PTR _new_size$[ebp], xmm1
	movss	DWORD PTR _new_size$[ebp+4], xmm2
	jmp	SHORT $LN3@ApplySizeF
$LN42@ApplySizeF:
	movss	xmm2, DWORD PTR _new_size$[ebp+4]
	movss	xmm1, DWORD PTR _new_size$[ebp]
$LN3@ApplySizeF:

; 4703 :             new_size = data.DesiredSize;
; 4704 :         }
; 4705 :     }
; 4706 :     if (!(window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_AlwaysAutoResize)))

	test	DWORD PTR [esi+8], 4194368		; 00400040H
	jne	SHORT $LN4@ApplySizeF
	movss	xmm0, DWORD PTR [edi+5336]
	maxss	xmm1, DWORD PTR [edi+5332]
	maxss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movaps	xmm2, xmm0
$LN4@ApplySizeF:
	pop	edi
	movss	DWORD PTR [esi+40], xmm1
	movss	DWORD PTR [esi+44], xmm2
	pop	esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4709 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ApplySizeFullWithConstraint@@YAXPAUImGuiWindow@@UImVec2@@@Z ENDP ; ApplySizeFullWithConstraint
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_title$ = -284						; size = 256
_content_avail$ = -28					; size = 8
_v$ = -20						; size = 8
_parent_window$1$ = -12					; size = 4
_size$ = -8						; size = 8
_name$ = 8						; size = 4
_id$ = 12						; size = 4
_auto_fit_axises$1$ = 16				; size = 4
_size_arg$ = 16						; size = 4
_border$ = 20						; size = 1
_ret$1$ = 23						; size = 1
_extra_flags$ = 24					; size = 4
?BeginChildEx@@YA_NPBDIABUImVec2@@_NH@Z PROC		; BeginChildEx

; 4462 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 284				; 0000011cH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	esi
	push	edi
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4466 :     const ImVec2 content_avail = ImGui::GetContentRegionAvail();

	lea	eax, DWORD PTR _content_avail$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	esi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4466 :     const ImVec2 content_avail = ImGui::GetContentRegionAvail();

	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	DWORD PTR _parent_window$1$[ebp], esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4466 :     const ImVec2 content_avail = ImGui::GetContentRegionAvail();

	call	?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetContentRegionAvail

; 4467 :     ImVec2 size = ImFloor(size_arg);

	mov	ecx, DWORD PTR _size_arg$[ebp]
	add	esp, 4
	xorps	xmm3, xmm3
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _v$[ebp], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _v$[ebp+4], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 141  : static inline ImVec2 ImFloor(ImVec2 v)                                          { return ImVec2((float)(int)v.x, (float)(int)v.y); }

	cvttss2si eax, DWORD PTR _v$[ebp]
	movd	xmm2, eax
	cvttss2si eax, DWORD PTR _v$[ebp+4]
	cvtdq2ps xmm2, xmm2
	movd	xmm1, eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4468 :     const int auto_fit_axises = ((size.x == 0.0f) ? 0x01 : 0x00) | ((size.y == 0.0f) ? 0x02 : 0x00);

	ucomiss	xmm2, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 141  : static inline ImVec2 ImFloor(ImVec2 v)                                          { return ImVec2((float)(int)v.x, (float)(int)v.y); }

	cvtdq2ps xmm1, xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4468 :     const int auto_fit_axises = ((size.x == 0.0f) ? 0x01 : 0x00) | ((size.y == 0.0f) ? 0x02 : 0x00);

	lahf
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _size$[ebp], xmm2
	movss	DWORD PTR _size$[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4468 :     const int auto_fit_axises = ((size.x == 0.0f) ? 0x01 : 0x00) | ((size.y == 0.0f) ? 0x02 : 0x00);

	test	ah, 68					; 00000044H
	jp	SHORT $LN11@BeginChild
	mov	ecx, 1
	jmp	SHORT $LN12@BeginChild
$LN11@BeginChild:
	xor	ecx, ecx
$LN12@BeginChild:
	ucomiss	xmm1, xmm3
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN13@BeginChild
	mov	eax, 2
	jmp	SHORT $LN14@BeginChild
$LN13@BeginChild:
	xor	eax, eax
$LN14@BeginChild:

; 4469 :     if (size.x <= 0.0f)

	movss	xmm4, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
	or	eax, ecx
	comiss	xmm3, xmm2
	mov	DWORD PTR _auto_fit_axises$1$[ebp], eax
	movss	xmm5, DWORD PTR __real@40800000
	jb	SHORT $LN2@BeginChild
	movss	xmm0, DWORD PTR _content_avail$[ebp]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 658  :         return (float)fabs(_X);

	andps	xmm2, xmm4
	maxss	xmm0, xmm5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4470 :         size.x = ImMax(content_avail.x, 4.0f) - fabsf(size.x); // Arbitrary minimum zero-ish child size of 4.0f (0.0f causing too much issues)

	subss	xmm0, xmm2
	movss	DWORD PTR _size$[ebp], xmm0
$LN2@BeginChild:

; 4471 :     if (size.y <= 0.0f)

	comiss	xmm3, xmm1
	jb	SHORT $LN3@BeginChild
	movss	xmm0, DWORD PTR _content_avail$[ebp+4]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 658  :         return (float)fabs(_X);

	andps	xmm1, xmm4
	maxss	xmm0, xmm5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4472 :         size.y = ImMax(content_avail.y, 4.0f) - fabsf(size.y);

	subss	xmm0, xmm1
	movss	DWORD PTR _size$[ebp+4], xmm0
$LN3@BeginChild:

; 4473 :     if (border)
; 4474 :         flags |= ImGuiWindowFlags_ShowBorders;
; 4475 :     flags |= extra_flags;
; 4476 : 
; 4477 :     char title[256];
; 4478 :     if (name)
; 4479 :         ImFormatString(title, IM_ARRAYSIZE(title), "%s.%s.%08X", parent_window->Name, name, id);

	cmp	BYTE PTR _border$[ebp], 0
	mov	eax, 4194563				; 00400103H
	push	DWORD PTR _id$[ebp]
	mov	edi, 4194691				; 00400183H
	cmove	edi, eax
	mov	eax, DWORD PTR _name$[ebp]
	or	edi, DWORD PTR _extra_flags$[ebp]
	test	eax, eax
	je	SHORT $LN5@BeginChild
	push	eax
	push	DWORD PTR [esi]
	lea	eax, DWORD PTR _title$[ebp]
	push	OFFSET $SG117791
	push	256					; 00000100H
	push	eax
	call	?ImFormatString@@YAHPADHPBDZZ		; ImFormatString
	add	esp, 24					; 00000018H

; 4480 :     else

	jmp	SHORT $LN6@BeginChild
$LN5@BeginChild:

; 4481 :         ImFormatString(title, IM_ARRAYSIZE(title), "%s.%08X", parent_window->Name, id);

	push	DWORD PTR [esi]
	lea	eax, DWORD PTR _title$[ebp]
	push	OFFSET $SG117792
	push	256					; 00000100H
	push	eax
	call	?ImFormatString@@YAHPADHPBDZZ		; ImFormatString
	add	esp, 20					; 00000014H
$LN6@BeginChild:

; 4483 :     bool ret = ImGui::Begin(title, NULL, size, -1.0f, flags);

	push	edi
	push	ecx
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	lea	eax, DWORD PTR _title$[ebp]
	push	0
	push	eax
	call	?Begin@ImGui@@YA_NPBDPA_NABUImVec2@@MH@Z ; ImGui::Begin
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	edx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4483 :     bool ret = ImGui::Begin(title, NULL, size, -1.0f, flags);

	add	esp, 20					; 00000014H
	mov	BYTE PTR _ret$1$[ebp], al
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR [edx+6240]
	mov	BYTE PTR [ecx+134], 1
	mov	esi, DWORD PTR [edx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4485 :     child_window->AutoFitChildAxises = auto_fit_axises;

	mov	ecx, DWORD PTR _auto_fit_axises$1$[ebp]
	mov	DWORD PTR [esi+164], ecx

; 4486 :     if (!(parent_window->Flags & ImGuiWindowFlags_ShowBorders))

	mov	ecx, DWORD PTR _parent_window$1$[ebp]
	test	BYTE PTR [ecx+8], 128			; 00000080H
	jne	SHORT $LN7@BeginChild

; 4487 :         child_window->Flags &= ~ImGuiWindowFlags_ShowBorders;

	and	DWORD PTR [esi+8], -129			; ffffff7fH
$LN7@BeginChild:

; 4488 : 
; 4489 :     // Process navigation-in immediately so NavInit can run on first frame
; 4490 :     //const ImGuiID id = parent_window->GetChildID(child_window);
; 4491 :     if (!(flags & ImGuiWindowFlags_NavFlattened) && (child_window->DC.NavLayerActiveFlags != 0 || child_window->DC.NavHasScroll) && GImGui->NavActivateId == id)

	test	edi, 524288				; 00080000H
	jne	SHORT $LN8@BeginChild
	cmp	DWORD PTR [esi+276], 0
	jne	SHORT $LN9@BeginChild
	cmp	BYTE PTR [esi+270], 0
	je	SHORT $LN8@BeginChild
$LN9@BeginChild:
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	edi, DWORD PTR _id$[ebp]
	cmp	DWORD PTR [eax+6388], edi
	jne	SHORT $LN37@BeginChild

; 4492 :     {
; 4493 :         ImGui::FocusWindow(child_window);

	push	esi
	call	?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusWindow

; 4494 :         NavInitWindow(child_window, false);

	push	0
	push	esi
	call	?NavInitWindow@@YAXPAUImGuiWindow@@_N@Z	; NavInitWindow

; 4495 :         ImGui::SetActiveIDNoNav(id+1, child_window); // Steal ActiveId with a dummy id so that key-press won't activate child item

	lea	eax, DWORD PTR [edi+1]
	push	esi
	push	eax
	call	?SetActiveIDNoNav@ImGui@@YAXIPAUImGuiWindow@@@Z ; ImGui::SetActiveIDNoNav

; 4496 :         GImGui->ActiveIdSource = ImGuiInputSource_Nav;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	add	esp, 20					; 00000014H
	mov	DWORD PTR [eax+6292], 2
$LN37@BeginChild:

; 4497 :     }
; 4498 : 
; 4499 :     return ret;

	mov	al, BYTE PTR _ret$1$[ebp]
$LN8@BeginChild:
	pop	edi
	pop	esi

; 4500 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?BeginChildEx@@YA_NPBDIABUImVec2@@_NH@Z ENDP		; BeginChildEx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_window$ = 8						; size = 4
?AddWindowToRenderListSelectLayer@@YAXPAUImGuiWindow@@@Z PROC ; AddWindowToRenderListSelectLayer

; 3381 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 3382 :     // FIXME: Generalize this with a proper layering system so e.g. user can draw in specific layers, below text, ..
; 3383 :     ImGuiContext& g = *GImGui;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 3384 :     g.IO.MetricsActiveWindows++;
; 3385 :     if (window->Flags & ImGuiWindowFlags_Popup)

	mov	ecx, DWORD PTR _window$[ebp]
	inc	DWORD PTR [eax+868]
	mov	edx, DWORD PTR [ecx+8]
	test	edx, 33554432				; 02000000H
	je	SHORT $LN2@AddWindowT

; 3386 :         AddWindowToRenderList(g.RenderDrawLists[1], window);

	add	eax, 6628				; 000019e4H

; 3389 :     else
; 3390 :         AddWindowToRenderList(g.RenderDrawLists[0], window);

	push	ecx
	push	eax
	call	?AddWindowToRenderList@@YAXAAV?$ImVector@PAUImDrawList@@@@PAUImGuiWindow@@@Z ; AddWindowToRenderList
	add	esp, 8

; 3391 : }

	pop	ebp
	ret	0
$LN2@AddWindowT:

; 3387 :     else if (window->Flags & ImGuiWindowFlags_Tooltip)

	test	edx, 16777216				; 01000000H
	je	SHORT $LN4@AddWindowT

; 3388 :         AddWindowToRenderList(g.RenderDrawLists[2], window);

	add	eax, 6640				; 000019f0H

; 3389 :     else
; 3390 :         AddWindowToRenderList(g.RenderDrawLists[0], window);

	push	ecx
	push	eax
	call	?AddWindowToRenderList@@YAXAAV?$ImVector@PAUImDrawList@@@@PAUImGuiWindow@@@Z ; AddWindowToRenderList
	add	esp, 8

; 3391 : }

	pop	ebp
	ret	0
$LN4@AddWindowT:

; 3389 :     else
; 3390 :         AddWindowToRenderList(g.RenderDrawLists[0], window);

	add	eax, 6616				; 000019d8H
	push	ecx
	push	eax
	call	?AddWindowToRenderList@@YAXAAV?$ImVector@PAUImDrawList@@@@PAUImGuiWindow@@@Z ; AddWindowToRenderList
	add	esp, 8

; 3391 : }

	pop	ebp
	ret	0
?AddWindowToRenderListSelectLayer@@YAXPAUImGuiWindow@@@Z ENDP ; AddWindowToRenderListSelectLayer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
?ChildWindowComparer@@YAHPBX0@Z PROC			; ChildWindowComparer

; 3309 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 3310 :     const ImGuiWindow* a = *(const ImGuiWindow**)lhs;

	mov	eax, DWORD PTR _lhs$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR [eax]

; 3311 :     const ImGuiWindow* b = *(const ImGuiWindow**)rhs;

	mov	eax, DWORD PTR _rhs$[ebp]
	mov	ebx, DWORD PTR [eax]

; 3312 :     if (int d = (a->Flags & ImGuiWindowFlags_Popup) - (b->Flags & ImGuiWindowFlags_Popup))

	mov	eax, DWORD PTR [edi+8]
	mov	edx, eax
	and	edx, 33554432				; 02000000H
	mov	esi, DWORD PTR [ebx+8]
	mov	ecx, esi
	and	ecx, 33554432				; 02000000H
	sub	edx, ecx
	je	SHORT $LN2@ChildWindo
$LN6@ChildWindo:
	pop	edi
	pop	esi

; 3313 :         return d;

	mov	eax, edx
	pop	ebx

; 3319 : }

	pop	ebp
	ret	0
$LN2@ChildWindo:

; 3314 :     if (int d = (a->Flags & ImGuiWindowFlags_Tooltip) - (b->Flags & ImGuiWindowFlags_Tooltip))

	mov	edx, eax
	mov	ecx, esi
	and	edx, 16777216				; 01000000H
	and	ecx, 16777216				; 01000000H
	sub	edx, ecx
	jne	SHORT $LN6@ChildWindo

; 3315 :         return d;
; 3316 :     if (int d = (a->Flags & ImGuiWindowFlags_ComboBox) - (b->Flags & ImGuiWindowFlags_ComboBox))

	and	eax, 8388608				; 00800000H
	and	esi, 8388608				; 00800000H
	sub	eax, esi
	jne	SHORT $LN1@ChildWindo

; 3317 :         return d;
; 3318 :     return (a->IndexWithinParent - b->IndexWithinParent);

	mov	eax, DWORD PTR [edi+12]
	sub	eax, DWORD PTR [ebx+12]
$LN1@ChildWindo:
	pop	edi
	pop	esi
	pop	ebx

; 3319 : }

	pop	ebp
	ret	0
?ChildWindowComparer@@YAHPBX0@Z ENDP			; ChildWindowComparer
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0show_eula_s@@QAE@XZ
_TEXT	SEGMENT
??0show_eula_s@@QAE@XZ PROC				; show_eula_s::show_eula_s, COMDAT
; _this$ = ecx
	mov	WORD PTR [ecx], 0
	mov	eax, ecx
	ret	0
??0show_eula_s@@QAE@XZ ENDP				; show_eula_s::show_eula_s
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\input\input.h
;	COMDAT ?markRead@sk_input_api_context_s@@QAEXW4sk_input_dev_type@@@Z
_TEXT	SEGMENT
_type$ = 8						; size = 4
?markRead@sk_input_api_context_s@@QAEXW4sk_input_dev_type@@@Z PROC ; sk_input_api_context_s::markRead, COMDAT
; _this$ = ecx

; 103  :   void markRead  (sk_input_dev_type type) { InterlockedIncrement (&last_frame.reads    [ type == sk_input_dev_type::Mouse    ? 0 :

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _type$[ebp]
	cmp	edx, 1
	jne	SHORT $LN5@markRead
	xor	eax, eax
	lock	 inc	 DWORD PTR [ecx+eax*4+32]

; 104  :                                                                                          type == sk_input_dev_type::Keyboard ? 1 :
; 105  :                                                                                          type == sk_input_dev_type::Gamepad  ? 2 : 3 ] ); }

	pop	ebp
	ret	4
$LN5@markRead:

; 103  :   void markRead  (sk_input_dev_type type) { InterlockedIncrement (&last_frame.reads    [ type == sk_input_dev_type::Mouse    ? 0 :

	cmp	edx, 2
	jne	SHORT $LN3@markRead
	mov	eax, 1
	lock	 inc	 DWORD PTR [ecx+eax*4+32]

; 104  :                                                                                          type == sk_input_dev_type::Keyboard ? 1 :
; 105  :                                                                                          type == sk_input_dev_type::Gamepad  ? 2 : 3 ] ); }

	pop	ebp
	ret	4
$LN3@markRead:

; 103  :   void markRead  (sk_input_dev_type type) { InterlockedIncrement (&last_frame.reads    [ type == sk_input_dev_type::Mouse    ? 0 :

	xor	eax, eax
	cmp	edx, 4
	setne	al
	lock	 inc	 DWORD PTR [ecx+eax*4+40]

; 104  :                                                                                          type == sk_input_dev_type::Keyboard ? 1 :
; 105  :                                                                                          type == sk_input_dev_type::Gamepad  ? 2 : 3 ] ); }

	pop	ebp
	ret	4
?markRead@sk_input_api_context_s@@QAEXW4sk_input_dev_type@@@Z ENDP ; sk_input_api_context_s::markRead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\console.h
;	COMDAT ?isVisible@SK_Console@@QAE_NXZ
_TEXT	SEGMENT
?isVisible@SK_Console@@QAE_NXZ PROC			; SK_Console::isVisible, COMDAT
; _this$ = ecx

; 69   :   bool isVisible (void) { return visible; }

	mov	al, BYTE PTR [ecx+4356]
	ret	0
?isVisible@SK_Console@@QAE_NXZ ENDP			; SK_Console::isVisible
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 3605 : 		{	// initialize buffer, deallocating any storage

	npad	2
	push	esi
	mov	esi, ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 8

; 3606 : 		this->_Orphan_all();
; 3607 : 		auto& _My_data = this->_Get_data();
; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN2@Tidy_deall
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN2@Tidy_deall:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [esi], ax
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3621 : 		}

	ret	0
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN13@c_str

; 3003 : 		return (this->_Myptr());

	mov	eax, DWORD PTR [ecx]

; 3004 : 		}

	ret	0
$LN13@c_str:

; 3003 : 		return (this->_Myptr());

	mov	eax, ecx

; 3004 : 		}

	ret	0
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 2215 : 		{	// destroy the string

	npad	2
	push	esi
	mov	esi, ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 8

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN4@basic_stri
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN4@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 7
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 326  : 		_Left = _Right;

	mov	WORD PTR [esi], ax
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2217 : 		}

	ret	0
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >, COMDAT
; _this$ = ecx
	ret	0
??1?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 343  : 		return (_Myval2);

	mov	eax, ecx

; 344  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 338  : 		return (_Myval2);

	mov	eax, ecx

; 339  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 318  : 		return (*this);

	mov	eax, ecx

; 319  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@_W@std@@@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<wchar_t> >,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data, COMDAT
; _this$ = ecx

; 1834 : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 1835 : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data, COMDAT
; _this$ = ecx

; 1829 : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 1830 : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal, COMDAT
; _this$ = ecx

; 1819 : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 1820 : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Orphan_all@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 1809 : 		_Get_data()._Orphan_all();
; 1810 : 		}

	ret	0
?_Orphan_all@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ PROC ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN11@Myptr

; 1690 : 		return (_Get_data()._Myptr());

	mov	eax, DWORD PTR [ecx]

; 1691 : 		}

	ret	0
$LN11@Myptr:

; 1690 : 		return (_Get_data()._Myptr());

	mov	eax, ecx

; 1691 : 		}

	ret	0
?_Myptr@?$_String_alloc@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBEPB_WXZ ENDP ; std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 1639 : 			}

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 1627 : 		{	// returns whether the large string mode (allocated memory) is engaged

	cmp	DWORD PTR [ecx+20], 8
	setae	al

; 1628 : 		return (this->_BUF_SIZE <= _Myres);
; 1629 : 		}

	ret	0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 8

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx]

; 1622 : 			? _Unfancy(_Bx._Ptr)
; 1623 : 			: _Bx._Buf);
; 1624 : 		}

	ret	0
$LN3@Myptr:

; 1621 : 		return (_Large_string_engaged()

	mov	eax, ecx

; 1622 : 			? _Unfancy(_Bx._Ptr)
; 1623 : 			: _Bx._Buf);
; 1624 : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z PROC ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate, COMDAT
; _this$ = ecx

; 1087 : 		{	// deallocate object at _Ptr, ignore size

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 1088 : 		_Mybase::deallocate(_Ptr, _Count);
; 1089 : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ENDP ; std::_Wrap_alloc<std::allocator<wchar_t> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z PROC	; std::allocator<wchar_t>::deallocate, COMDAT
; _this$ = ecx

; 822  : 		{	// deallocate object at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	2
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 824  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ENDP	; std::allocator<wchar_t>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT

; 3646 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN4@Xran:
$LN3@Xran:
	int	3
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset, COMDAT
; _this$ = ecx

; 3629 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

	npad	2
	push	ebp
	mov	ebp, esp

; 3630 : 		if (this->_Mysize() < _Off)

	mov	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Off$[ebp]
	jb	SHORT $LN14@Check_offs

; 3633 : 			}
; 3634 : 		}

	pop	ebp
	ret	4
$LN14@Check_offs:

; 3631 : 			{
; 3632 : 			_Xran();

	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN16@Check_offs:
$LN13@Check_offs:
	int	3
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT

; 3625 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 3605 : 		{	// initialize buffer, deallocating any storage

	npad	2
	push	esi
	mov	esi, ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H

; 3606 : 		this->_Orphan_all();
; 3607 : 		auto& _My_data = this->_Get_data();
; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN2@Tidy_deall
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN2@Tidy_deall:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3621 : 		}

	ret	0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 3596 : 		auto& _My_data = this->_Get_data();
; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [ecx+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3602 : 		}

	ret	0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 3572 : 		{	// ensure buffer is big enough

	npad	2
	push	ebp
	mov	ebp, esp

; 3573 : 		if (_Newsize == 0)

	mov	eax, DWORD PTR __Newsize$[ebp]
	test	eax, eax
	jne	SHORT $LN2@Grow

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN16@Grow
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN16@Grow:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3576 : 			return (false);

	xor	al, al

; 3585 : 		}

	pop	ebp
	ret	4
$LN2@Grow:

; 3577 : 			}
; 3578 : 
; 3579 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [ecx+20], eax
	jae	SHORT $LN3@Grow

; 3580 : 			{	// reallocate to grow
; 3581 : 			_Copy(_Newsize);

	push	eax
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
$LN3@Grow:

; 3582 : 			}
; 3583 : 
; 3584 : 		return (true);	// return true only if more work to do

	mov	al, 1

; 3585 : 		}

	pop	ebp
	ret	4
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 3566 : 		{	// set new length and null terminator

	npad	2
	push	ebp
	mov	ebp, esp

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 3567 : 		auto& _My_data = this->_Get_data();
; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN11@Eos
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3569 : 		}

	pop	ebp
	ret	4
$LN11@Eos:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [ecx+edx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3569 : 		}

	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Oldres$ = -28						; size = 4
_this$ = -24						; size = 4
__Ptr$1$ = -20						; size = 4
__Ptr$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newres$ = 8						; size = 4
__Newsize$ = 8						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 3514 : 		{	// reallocate to new buffer of at least _Newsize, copying existing elements there

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H

; 3515 : 		const auto _Max = max_size();
; 3516 : 		if (_Newsize > _Max)

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	cmp	eax, -2					; fffffffeH
	jbe	SHORT $LN2@Copy

; 3517 : 			{	// too long
; 3518 : 			_Xlen();

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
$LN94@Copy:
$LN2@Copy:

; 3519 : 			}
; 3520 : 
; 3521 : 		auto& _My_data = this->_Get_data();
; 3522 : 		const size_type _Oldres = _My_data._Myres;

	mov	ebx, DWORD PTR [esi+20]

; 3523 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	edi, eax
	or	edi, 15					; 0000000fH
	mov	DWORD PTR __Oldres$[ebp], ebx

; 3524 : 		if (_Max < _Newres)

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN3@Copy

; 3525 : 			{
; 3526 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	edi, eax
	jmp	SHORT $LN8@Copy
$LN3@Copy:

; 3527 : 			}
; 3528 : 		else if (_Oldres / 2 <= _Newres / 3)

	mov	eax, -1431655765			; aaaaaaabH
	mov	ecx, ebx
	mul	edi
	shr	ecx, 1
	shr	edx, 1
	cmp	ecx, edx
	jbe	SHORT $LN8@Copy

; 3529 : 			;
; 3530 : 		else if (_Oldres <= _Max - _Oldres / 2)

	mov	eax, -2					; fffffffeH

; 3531 : 			{
; 3532 : 			_Newres = _Oldres + _Oldres / 2;	// grow exponentially if possible

	lea	edi, DWORD PTR [ecx+ebx]
	sub	eax, ecx
	cmp	ebx, eax
	jbe	SHORT $LN8@Copy

; 3533 : 			}
; 3534 : 		else
; 3535 : 			{
; 3536 : 			_Newres = _Max;	// settle for max_size()

	mov	edi, -2					; fffffffeH
$LN8@Copy:

; 3537 : 			}
; 3538 : 
; 3539 : 		auto& _Al = this->_Getal();
; 3540 : 		pointer _Ptr;
; 3541 : 		_TRY_BEGIN
; 3542 : 			_Ptr = _Al.allocate(_Newres + 1);

	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	push	eax
	mov	ecx, esi
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	ecx, eax
	jmp	SHORT $LN92@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z$0:

; 3543 : 		_CATCH_ALL
; 3544 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	eax, DWORD PTR __Newsize$[ebp]

; 3545 : 			_Ptr = _Al.allocate(_Newres + 1);	// if throws, *this unmodified

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR __Newres$[ebp], eax
	inc	eax
	push	eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR __Ptr$[ebp], eax

; 3546 : 		_CATCH_END

	mov	eax, $LN89@Copy
	ret	0
$LN89@Copy:
	mov	esi, DWORD PTR _this$[ebp]
	mov	ebx, DWORD PTR __Oldres$[ebp]
	mov	edi, DWORD PTR __Newres$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
$LN92@Copy:

; 3551 : 			{	// copy and deallocate old buffer
; 3552 : 			_Traits::copy(_Unfancy(_Ptr), _Unfancy(_My_data._Bx._Ptr), _My_data._Mysize + 1);

	mov	eax, DWORD PTR [esi+16]
	inc	eax
	mov	DWORD PTR __Ptr$1$[ebp], ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3550 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN10@Copy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	DWORD PTR [esi]
	push	ecx
	call	_memcpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3553 : 			_Al.deallocate(_My_data._Bx._Ptr, _Oldres + 1);

	lea	eax, DWORD PTR [ebx+1]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3556 : 		else

	jmp	SHORT $LN93@Copy
$LN10@Copy:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	esi
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN93@Copy:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3563 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3562 : 		_My_data._Myres = _Newres;

	mov	DWORD PTR [esi+20], edi

; 3563 : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN91@Copy:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Size$ = 12						; size = 4
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 3410 : 		{	// trims _Size to the longest it can be assuming a string at/after _Off

	npad	2
	push	ebp
	mov	ebp, esp

; 3411 : 		return (_Min_value(_Size, this->_Mysize() - _Off));

	mov	ecx, DWORD PTR [ecx+16]
	sub	ecx, DWORD PTR __Off$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

	mov	eax, DWORD PTR __Size$[ebp]
	cmp	ecx, eax
	cmovb	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3412 : 		}

	pop	ebp
	ret	8
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3030 : 		const size_type _Num = this->_Getal().max_size();
; 3031 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	eax, -2					; fffffffeH

; 3032 : 		}

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN13@c_str

; 3003 : 		return (this->_Myptr());

	mov	eax, DWORD PTR [ecx]

; 3004 : 		}

	ret	0
$LN13@c_str:

; 3003 : 		return (this->_Myptr());

	mov	eax, ecx

; 3004 : 		}

	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 2592 : 		{	// erase elements [_Off, _Off + _Count)

	npad	2
	push	ebp
	mov	ebp, esp

; 3630 : 		if (this->_Mysize() < _Off)

	mov	edx, DWORD PTR __Off$[ebp]
	push	ebx
	push	esi

; 2592 : 		{	// erase elements [_Off, _Off + _Count)

	mov	esi, ecx
	push	edi

; 3630 : 		if (this->_Mysize() < _Off)

	mov	edi, DWORD PTR [esi+16]
	cmp	edi, edx
	jb	SHORT $LN95@erase

; 2593 : 		_Check_offset(_Off);
; 2594 : 		if (this->_Mysize() - _Off <= _Count)

	mov	ebx, DWORD PTR __Count$[ebp]
	mov	eax, edi
	sub	eax, edx
	cmp	eax, ebx
	ja	SHORT $LN2@erase

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN38@erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2606 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2607 : 		}

	pop	ebp
	ret	8
$LN38@erase:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2607 : 		}

	pop	ebp
	ret	8
$LN2@erase:

; 2595 : 			{
; 2596 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 2597 : 			}
; 2598 : 		else if (_Count != 0)

	test	ebx, ebx
	je	SHORT $LN92@erase

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN57@erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN58@erase
$LN57@erase:
	mov	eax, esi
$LN58@erase:

; 2599 : 			{	// move elements down
; 2600 : 			value_type *_Ptr = this->_Myptr() + _Off;

	lea	ecx, DWORD PTR [eax+edx]

; 2601 : 			size_type _Newsize = this->_Mysize() - _Count;

	sub	edi, ebx

; 2602 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	eax, edi
	sub	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2602 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	lea	eax, DWORD PTR [ecx+ebx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

	push	eax
	push	ecx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN85@erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2606 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 2607 : 		}

	pop	ebp
	ret	8
$LN85@erase:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN92@erase:
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2606 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2607 : 		}

	pop	ebp
	ret	8
$LN95@erase:

; 3632 : 			_Xran();

	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN97@erase:
$LN94@erase:
	int	3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 2585 : 		{	// erase elements [_Off, ...)

	npad	2
	push	ebp
	mov	ebp, esp

; 3630 : 		if (this->_Mysize() < _Off)

	mov	eax, DWORD PTR __Off$[ebp]
	cmp	DWORD PTR [ecx+16], eax
	jb	SHORT $LN36@erase

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN26@erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2588 : 		return (*this);

	mov	eax, ecx

; 2589 : 		}

	pop	ebp
	ret	4
$LN26@erase:

; 1614 : 		return (_Large_string_engaged()

	mov	edx, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2588 : 		return (*this);

	mov	eax, ecx

; 2589 : 		}

	pop	ebp
	ret	4
$LN36@erase:

; 3632 : 			_Xran();

	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN38@erase:
$LN35@erase:
	int	3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 2378 : 		{	// assign _Right [_Roff, _Roff + _Count)

	npad	2
	push	ebp
	mov	ebp, esp

; 3630 : 		if (this->_Mysize() < _Off)

	mov	eax, DWORD PTR __Roff$[ebp]
	push	ebx
	mov	ebx, DWORD PTR __Right$[ebp]
	push	esi

; 2378 : 		{	// assign _Right [_Roff, _Roff + _Count)

	mov	esi, ecx
	push	edi

; 3630 : 		if (this->_Mysize() < _Off)

	mov	ecx, DWORD PTR [ebx+16]
	cmp	ecx, eax
	jb	$LN159@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

	mov	edi, DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3411 : 		return (_Min_value(_Size, this->_Mysize() - _Off));

	sub	ecx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

	cmp	ecx, edi
	cmovb	edi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2382 : 		if (this == _STD addressof(_Right))

	cmp	esi, ebx
	jne	SHORT $LN2@assign

; 2383 : 			{	// substring
; 2384 : 			erase(_Roff + _Count);

	lea	ecx, DWORD PTR [eax+edi]

; 3630 : 		if (this->_Mysize() < _Off)

	cmp	DWORD PTR [esi+16], ecx
	jb	$LN161@assign

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN62@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2385 : 			erase(0, _Roff);

	push	eax
	push	0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [edx+ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2385 : 			erase(0, _Roff);

	mov	ecx, esi
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi

; 2393 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN62@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	edx, esi

; 2385 : 			erase(0, _Roff);

	push	eax
	push	0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [edx+ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2385 : 			erase(0, _Roff);

	mov	ecx, esi
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi

; 2393 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN2@assign:

; 3573 : 		if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN72@assign

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN85@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2393 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN85@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN72@assign:

; 3579 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN73@assign

; 3580 : 			{	// reallocate to grow
; 3581 : 			_Copy(_Newsize);

	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	eax, DWORD PTR __Roff$[ebp]
$LN73@assign:

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ebx+20], 16			; 00000010H

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN113@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ebx, DWORD PTR [ebx]
$LN113@assign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN129@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 1614 : 		return (_Large_string_engaged()

	jmp	SHORT $LN130@assign
$LN129@assign:
	mov	ecx, esi
$LN130@assign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2389 : 			_Traits::copy(this->_Myptr(), _Right._Myptr() + _Roff, _Count);

	add	eax, ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	eax
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3568 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN148@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2393 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN148@assign:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2394 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN159@assign:

; 3632 : 			_Xran();

	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN162@assign:
$LN161@assign:
	call	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
$LN163@assign:
$LN158@assign:
	int	3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2215 : 		{	// destroy the string

	npad	2
	push	esi
	mov	esi, ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H

; 3608 : 		if (_My_data._Large_string_engaged())

	jb	SHORT $LN4@basic_stri
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3613 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN4@basic_stri:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 3616 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3617 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2217 : 		}

	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Assign_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Assign_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_lv_contents, COMDAT
; _this$ = ecx

; 2172 : 		{	// assign by copying the data stored in _Right

	npad	2
	push	ebp
	mov	ebp, esp

; 2173 : 			// pre: *this is in a valid but unspecified state
; 2174 : 		assign(_Right, 0, npos);

	push	-1
	push	0
	push	DWORD PTR __Right$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2175 : 		}

	pop	ebp
	ret	4
?_Assign_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_lv_contents
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1925 : 		{	// construct by copying _Right

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 2174 : 		assign(_Right, 0, npos);

	push	-1
	push	0
	push	DWORD PTR __Right$[ebp]

; 3597 : 		_My_data._Mysize = 0;

	mov	DWORD PTR [esi+16], 0

; 3598 : 		_My_data._Myres = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd

; 517  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring

; 2174 : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1926 : 		_Tidy_init();
; 1927 : 		_Assign_lv_contents(_Right);
; 1928 : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx
	ret	0
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 343  : 		return (_Myval2);

	mov	eax, ecx

; 344  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 338  : 		return (_Myval2);

	mov	eax, ecx

; 339  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 323  : 		return (*this);

	mov	eax, ecx

; 324  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 318  : 		return (*this);

	mov	eax, ecx

; 319  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres, COMDAT
; _this$ = ecx

; 1849 : 		return (_Get_data()._Myres);

	lea	eax, DWORD PTR [ecx+20]

; 1850 : 		}

	ret	0
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 1844 : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 1845 : 		}

	ret	0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 1839 : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 1840 : 		}

	ret	0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 1834 : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 1835 : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 1829 : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 1830 : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 1824 : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 1825 : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 1819 : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 1820 : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 1809 : 		_Get_data()._Orphan_all();
; 1810 : 		}

	ret	0
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN11@Myptr

; 1690 : 		return (_Get_data()._Myptr());

	mov	eax, DWORD PTR [ecx]

; 1691 : 		}

	ret	0
$LN11@Myptr:

; 1690 : 		return (_Get_data()._Myptr());

	mov	eax, ecx

; 1691 : 		}

	ret	0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN11@Myptr

; 1685 : 		return (_Get_data()._Myptr());

	mov	eax, DWORD PTR [ecx]

; 1686 : 		}

	ret	0
$LN11@Myptr:

; 1685 : 		return (_Get_data()._Myptr());

	mov	eax, ecx

; 1686 : 		}

	ret	0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 1639 : 			}

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 1634 : 			{	// user-provided, for fancy pointers
; 1635 : 			}

	mov	eax, ecx
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 1627 : 		{	// returns whether the large string mode (allocated memory) is engaged

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	setae	al

; 1628 : 		return (this->_BUF_SIZE <= _Myres);
; 1629 : 		}

	ret	0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1621 : 		return (_Large_string_engaged()

	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx]

; 1622 : 			? _Unfancy(_Bx._Ptr)
; 1623 : 			: _Bx._Buf);
; 1624 : 		}

	ret	0
$LN3@Myptr:

; 1621 : 		return (_Large_string_engaged()

	mov	eax, ecx

; 1622 : 			? _Unfancy(_Bx._Ptr)
; 1623 : 			: _Bx._Buf);
; 1624 : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1628 : 		return (this->_BUF_SIZE <= _Myres);

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1614 : 		return (_Large_string_engaged()

	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx]

; 1615 : 			? _Unfancy(_Bx._Ptr)
; 1616 : 			: _Bx._Buf);
; 1617 : 		}

	ret	0
$LN3@Myptr:

; 1614 : 		return (_Large_string_engaged()

	mov	eax, ecx

; 1615 : 			? _Unfancy(_Bx._Ptr)
; 1616 : 			: _Bx._Buf);
; 1617 : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 1595 : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 1598 : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+20], 0
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1108 : 		return (_Mytraits::max_size(*this));

	or	eax, -1

; 1109 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 1087 : 		{	// deallocate object at _Ptr, ignore size

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 1088 : 		_Mybase::deallocate(_Ptr, _Count);
; 1089 : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 1076 : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 53   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN6@allocate
$LN15@allocate:

; 1077 : 		return (_Mybase::allocate(_Count));
; 1078 : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN8@allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN10@allocate

; 69   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN18@allocate:
$LN10@allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN11@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN19@allocate:
$LN11@allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 1077 : 		return (_Mybase::allocate(_Count));
; 1078 : 		}

	pop	ebp
	ret	4
$LN8@allocate:

; 87   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN15@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN20@allocate:
$LN17@allocate:
	int	3
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 1048 : 		}

	mov	eax, ecx
	ret	4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 1
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 1013 : 		{	// get allocator to use

	npad	2
	push	ebp
	mov	ebp, esp

; 1014 : 		return (_Mytraits::select_on_container_copy_construction(*this));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1015 : 		}

	pop	ebp
	ret	8
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 975  : 		{	// get allocator to use

	npad	2
	push	ebp
	mov	ebp, esp

; 976  : 		return (_Al);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 977  : 		}

	pop	ebp
	ret	0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 970  : 		return (_Al.max_size());

	or	eax, -1

; 971  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 851  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 852  : 		}

	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 827  : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 53   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 69   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN8@allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN9@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN16@allocate:
$LN9@allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 87   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@allocate:
$LN14@allocate:
	int	3
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 822  : 		{	// deallocate object at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 824  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 807  : 		{	// construct by copying (do nothing)
; 808  : 		}

	mov	eax, ecx
	ret	4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 96   : 	{	// deallocate storage for _Count elements of size _Sz

	npad	2
	push	ebp
	mov	ebp, esp

; 97   :  #if defined(_M_IX86) || defined(_M_X64)
; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	or	eax, -1
	mov	ecx, DWORD PTR __Count$[ebp]
	xor	edx, edx
	div	DWORD PTR __Sz$[ebp]
	cmp	ecx, eax
	jbe	SHORT $LN2@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2@Deallocate:

; 99   : 	const size_t _User_size = _Count * _Sz;

	imul	ecx, DWORD PTR __Sz$[ebp]

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN9@Deallocate

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	al, 31					; 0000001fH
	je	SHORT $LN4@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4@Deallocate:

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	ecx, DWORD PTR [eax-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	ecx, eax
	jb	SHORT $LN5@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN5@Deallocate:

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	eax, ecx
	cmp	eax, 4
	jae	SHORT $LN6@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN6@Deallocate:

; 126  : 			<= _Ptr_user - _Ptr_container);
; 127  :  #endif /* _DEBUG */
; 128  : 
; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	eax, 35					; 00000023H
	jbe	SHORT $LN3@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 130  : 			<= _NON_USER_SIZE);
; 131  : 
; 132  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 133  : 		}
; 134  : 
; 135  :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 136  : 	static_cast<void>(_Count);
; 137  : 	static_cast<void>(_Sz);
; 138  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 139  : 
; 140  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 	}

	pop	ebp
	ret	0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 50   : 	{	// allocate storage for _Count elements of size _Sz

	npad	2
	push	ebp
	mov	ebp, esp

; 51   : 	void *_Ptr = 0;
; 52   : 
; 53   : 	if (_Count == 0)

	mov	ecx, DWORD PTR __Count$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@Allocate

; 54   : 		return (_Ptr);

	xor	eax, eax
$LN1@Allocate:

; 89   : 		}
; 90   : 	return (_Ptr);
; 91   : 	}

	pop	ebp
	ret	0
$LN2@Allocate:

; 55   : 
; 56   : 	// check overflow of multiply
; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Sz$[ebp]
	cmp	eax, ecx
	jae	SHORT $LN3@Allocate

; 58   : 		_Xbad_alloc();	// report no memory

	jmp	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN3@Allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	imul	ecx, DWORD PTR __Sz$[ebp]

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	BYTE PTR __Try_aligned_allocation$[ebp], 0
	je	SHORT $LN4@Allocate
	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN4@Allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	eax, DWORD PTR [ecx+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	eax, ecx
	ja	SHORT $LN6@Allocate

; 69   : 			_Xbad_alloc();	// report no memory

	jmp	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN6@Allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	eax
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN7@Allocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN7@Allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 89   : 		}
; 90   : 	return (_Ptr);
; 91   : 	}

	pop	ebp
	ret	0
$LN4@Allocate:

; 76   : 
; 77   :  #ifdef _DEBUG
; 78   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 79   :  #endif /* _DEBUG */
; 80   : 		}
; 81   : 	else
; 82   :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 83   : 	static_cast<void>(_Try_aligned_allocation);
; 84   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 85   : 
; 86   : 		{	// allocate normal block
; 87   : 		_Ptr = ::operator new(_User_size);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN1@Allocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 64   : 		}

	ret	0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 516  : 		{	// assign an element

	npad	2
	push	ebp
	mov	ebp, esp

; 517  : 		_Left = _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	eax, DWORD PTR __Left$[ebp]
	mov	BYTE PTR [eax], cl

; 518  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADQADQBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 505  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	npad	2
	push	ebp
	mov	ebp, esp

; 507  : 		}

	pop	ebp

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

	jmp	DWORD PTR __imp__memmove
?move@?$char_traits@D@std@@SAPADQADQBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADQADQBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 485  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	npad	2
	push	ebp
	mov	ebp, esp

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __First2$[ebp]
	push	DWORD PTR __First1$[ebp]
	call	_memcpy
	add	esp, 12					; 0000000cH

; 487  : 		}

	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADQADQBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\iosfwd
;	COMDAT ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z PROC	; std::char_traits<wchar_t>::assign, COMDAT

; 325  : 		{	// assign an element

	npad	2
	push	ebp
	mov	ebp, esp

; 326  : 		_Left = _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	cx, WORD PTR [eax]
	mov	eax, DWORD PTR __Left$[ebp]
	mov	WORD PTR [eax], cx

; 327  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ENDP	; std::char_traits<wchar_t>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 91   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 92   :         (void)_Size;
; 93   :         return _Where;

	mov	eax, DWORD PTR __Where$[ebp]

; 94   :     }

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\um\winbase.h
;	COMDAT ?_InterlockedCompareExchange@@YAKPCKKK@Z
_TEXT	SEGMENT
_Destination$ = 8					; size = 4
_Exchange$ = 12						; size = 4
_Comperand$ = 16					; size = 4
?_InterlockedCompareExchange@@YAKPCKKK@Z PROC		; _InterlockedCompareExchange, COMDAT

; 9002 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 9003 :     return (unsigned long) _InterlockedCompareExchange((volatile long*) Destination, (long) Exchange, (long) Comperand);

	mov	edx, DWORD PTR _Exchange$[ebp]
	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	eax, DWORD PTR _Comperand$[ebp]
	lock	 cmpxchg DWORD PTR [ecx], edx

; 9004 : }

	pop	ebp
	ret	0
?_InterlockedCompareExchange@@YAKPCKKK@Z ENDP		; _InterlockedCompareExchange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T10 = -32						; size = 16
$T11 = -32						; size = 16
_window_rect_rel$12 = -32				; size = 16
$T13 = -32						; size = 16
$T14 = -32						; size = 16
$T15 = -16						; size = 8
$T16 = -16						; size = 8
_scroll_dir$17 = -16					; size = 8
_move_delta$18 = -16					; size = 8
$T19 = -16						; size = 8
_next_scroll$20 = -16					; size = 8
_parent_window$1$ = -12					; size = 4
_i_current$1$ = -12					; size = 4
$T21 = -8						; size = 8
$T22 = -8						; size = 8
_scroll_speed$1$ = -4					; size = 4
_allowed_dir_flags$1$ = -4				; size = 4
_focus_change_dir$1$ = -4				; size = 4
?NavUpdate@@YAXXZ PROC					; NavUpdate

; 2534 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	edi

; 2535 :     ImGuiContext& g = *GImGui;

	mov	edi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 2536 :     g.IO.WantMoveMouse = false;
; 2537 : 
; 2538 :     // Process navigation init request (select first/default focus)
; 2539 :     if (g.NavInitDefaultResultId != 0 && (!g.NavDisableHighlight || g.NavInitDefaultResultExplicit))

	mov	eax, DWORD PTR [edi+6460]
	mov	BYTE PTR [edi+847], 0
	test	eax, eax
	je	SHORT $LN4@NavUpdate
	cmp	BYTE PTR [edi+6454], 0
	je	SHORT $LN3@NavUpdate
	cmp	BYTE PTR [edi+6480], 0
	je	SHORT $LN4@NavUpdate
$LN3@NavUpdate:

; 2540 :     {
; 2541 :         // Apply result from previous navigation init request (typically select the first item, unless SetItemDefaultFocus() has been called)
; 2542 :         IM_ASSERT(g.NavWindow);
; 2543 :         SetNavId(g.NavInitDefaultResultId);

	push	eax
	call	?SetNavId@@YAXI@Z			; SetNavId

; 2544 :         g.NavRefRectRel = g.NavInitDefaultResultRectRel;

	movups	xmm0, XMMWORD PTR [edi+6464]
	add	esp, 4

; 2545 :         if (g.NavDisableMouseHover)

	cmp	BYTE PTR [edi+6455], 0
	movups	XMMWORD PTR [edi+6400], xmm0
	je	SHORT $LN4@NavUpdate

; 2546 :             g.NavMousePosDirty = true;

	mov	BYTE PTR [edi+6453], 1
$LN4@NavUpdate:

; 2547 :     }
; 2548 :     g.NavInitDefaultRequest = false;
; 2549 :     g.NavInitDefaultResultExplicit = false;
; 2550 :     g.NavInitDefaultResultId = 0;
; 2551 : 
; 2552 :     // Process navigation move request
; 2553 :     if (g.NavMoveRequest && g.NavMoveResultId != 0)

	cmp	BYTE PTR [edi+6481], 0
	push	esi
	mov	BYTE PTR [edi+6456], 0
	mov	BYTE PTR [edi+6480], 0
	mov	DWORD PTR [edi+6460], 0
	je	$LN5@NavUpdate
	cmp	DWORD PTR [edi+6488], 0
	je	$LN5@NavUpdate

; 2560 :         if (g.NavLayer == 0 && !window_rect_rel.Contains(g.NavMoveResultRectRel))

	cmp	DWORD PTR [edi+6444], 0
	mov	eax, DWORD PTR [edi+6380]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR __real@3f800000

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm3, DWORD PTR [eax+512]
	movss	xmm5, DWORD PTR [eax+516]
	movss	xmm2, DWORD PTR [eax+504]
	movss	xmm4, DWORD PTR [eax+508]
	subss	xmm3, DWORD PTR [eax+24]
	subss	xmm5, DWORD PTR [eax+28]
	subss	xmm2, DWORD PTR [eax+24]
	subss	xmm4, DWORD PTR [eax+28]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm3, xmm0
	addss	xmm5, xmm0

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm2, xmm0
	subss	xmm4, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2560 :         if (g.NavLayer == 0 && !window_rect_rel.Contains(g.NavMoveResultRectRel))

	jne	$LN6@NavUpdate
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 253  :     bool        Contains(const ImRect& r) const { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x < Max.x && r.Max.y < Max.y; }

	movss	xmm0, DWORD PTR [edi+6504]
	comiss	xmm0, xmm2
	jb	SHORT $LN105@NavUpdate
	movss	xmm0, DWORD PTR [edi+6508]
	comiss	xmm0, xmm4
	jb	SHORT $LN105@NavUpdate
	comiss	xmm3, DWORD PTR [edi+6512]
	jbe	SHORT $LN105@NavUpdate
	comiss	xmm5, DWORD PTR [edi+6516]
	ja	$LN6@NavUpdate
$LN105@NavUpdate:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2562 :             if (g.NavWindow->ScrollbarX && g.NavMoveResultRectRel.Min.x < window_rect_rel.Min.x)

	mov	cl, BYTE PTR [eax+116]
	test	cl, cl
	je	SHORT $LN9@NavUpdate
	movss	xmm1, DWORD PTR [edi+6504]
	comiss	xmm2, xmm1
	jbe	SHORT $LN7@NavUpdate

; 2563 :             {
; 2564 :                 g.NavWindow->ScrollTarget.x = g.NavMoveResultRectRel.Min.x + g.NavWindow->Scroll.x - g.Style.ItemSpacing.x;

	movss	xmm0, DWORD PTR [eax+92]
	addss	xmm0, xmm1
	subss	xmm0, DWORD PTR [edi+5368]
	movss	DWORD PTR [eax+100], xmm0

; 2565 :                 g.NavWindow->ScrollTargetCenterRatio.x = 0.0f;

	mov	eax, DWORD PTR [edi+6380]
	mov	DWORD PTR [eax+108], 0
	jmp	SHORT $LN9@NavUpdate
$LN7@NavUpdate:

; 2566 :             }
; 2567 :             else if (g.NavWindow->ScrollbarX && g.NavMoveResultRectRel.Max.x >= window_rect_rel.Max.x)

	test	cl, cl
	je	SHORT $LN9@NavUpdate
	movss	xmm1, DWORD PTR [edi+6512]
	comiss	xmm1, xmm3
	jb	SHORT $LN9@NavUpdate

; 2568 :             {
; 2569 :                 g.NavWindow->ScrollTarget.x = g.NavMoveResultRectRel.Max.x + g.NavWindow->Scroll.x + g.Style.ItemSpacing.x;

	movss	xmm0, DWORD PTR [eax+92]
	addss	xmm0, xmm1
	addss	xmm0, DWORD PTR [edi+5368]
	movss	DWORD PTR [eax+100], xmm0

; 2570 :                 g.NavWindow->ScrollTargetCenterRatio.x = 1.0f;

	mov	eax, DWORD PTR [edi+6380]
	mov	DWORD PTR [eax+108], 1065353216		; 3f800000H
$LN9@NavUpdate:

; 2571 :             }
; 2572 :             if (g.NavMoveResultRectRel.Min.y < window_rect_rel.Min.y)

	movss	xmm1, DWORD PTR [edi+6508]
	comiss	xmm4, xmm1
	jbe	SHORT $LN10@NavUpdate

; 2573 :             {
; 2574 :                 g.NavWindow->ScrollTarget.y = g.NavMoveResultRectRel.Min.y + g.NavWindow->Scroll.y - g.Style.ItemSpacing.y;

	mov	eax, DWORD PTR [edi+6380]
	movss	xmm0, DWORD PTR [eax+96]
	addss	xmm0, xmm1
	subss	xmm0, DWORD PTR [edi+5372]
	movss	DWORD PTR [eax+104], xmm0

; 2575 :                 g.NavWindow->ScrollTargetCenterRatio.y = 0.0f;

	mov	eax, DWORD PTR [edi+6380]
	mov	DWORD PTR [eax+112], 0
	jmp	SHORT $LN12@NavUpdate
$LN10@NavUpdate:

; 2576 :             }
; 2577 :             else if (g.NavMoveResultRectRel.Max.y >= window_rect_rel.Max.y)

	movss	xmm1, DWORD PTR [edi+6516]
	comiss	xmm1, xmm5
	jb	SHORT $LN12@NavUpdate

; 2578 :             {
; 2579 :                 g.NavWindow->ScrollTarget.y = g.NavMoveResultRectRel.Max.y + g.NavWindow->Scroll.y + g.Style.ItemSpacing.y;

	mov	eax, DWORD PTR [edi+6380]
	movss	xmm0, DWORD PTR [eax+96]
	addss	xmm0, xmm1
	addss	xmm0, DWORD PTR [edi+5372]
	movss	DWORD PTR [eax+104], xmm0

; 2580 :                 g.NavWindow->ScrollTargetCenterRatio.y = 1.0f;

	mov	eax, DWORD PTR [edi+6380]
	mov	DWORD PTR [eax+112], 1065353216		; 3f800000H
$LN12@NavUpdate:

; 2584 :             ImVec2 next_scroll = CalcNextScrollFromScrollTargetAndClamp(g.NavWindow);

	mov	esi, DWORD PTR [edi+6380]
	lea	eax, DWORD PTR _next_scroll$20[ebp]
	push	esi
	push	eax
	call	?CalcNextScrollFromScrollTargetAndClamp@@YA?AUImVec2@@PAUImGuiWindow@@@Z ; CalcNextScrollFromScrollTargetAndClamp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm1, DWORD PTR [esi+92]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2584 :             ImVec2 next_scroll = CalcNextScrollFromScrollTargetAndClamp(g.NavWindow);

	add	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm1, DWORD PTR _next_scroll$20[ebp]

; 259  :     void        Translate(const ImVec2& v)      { Min.x += v.x; Min.y += v.y; Max.x += v.x; Max.y += v.y; }

	movss	xmm0, DWORD PTR [edi+6504]

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm2, DWORD PTR [esi+96]
	subss	xmm2, DWORD PTR _next_scroll$20[ebp+4]

; 259  :     void        Translate(const ImVec2& v)      { Min.x += v.x; Min.y += v.y; Max.x += v.x; Max.y += v.y; }

	addss	xmm0, xmm1
	movss	DWORD PTR [edi+6504], xmm0
	movss	xmm0, DWORD PTR [edi+6508]
	addss	xmm0, xmm2
	movss	DWORD PTR [edi+6508], xmm0
	movss	xmm0, DWORD PTR [edi+6512]
	addss	xmm0, xmm1
	movss	DWORD PTR [edi+6512], xmm0
	movss	xmm0, DWORD PTR [edi+6516]
	addss	xmm0, xmm2
	movss	DWORD PTR [edi+6516], xmm0
$LN6@NavUpdate:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2589 :         ImGui::ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID

; 2590 :         SetNavIdAndMoveMouse(g.NavMoveResultId, g.NavMoveResultRectRel);

	lea	eax, DWORD PTR [edi+6504]
	push	eax
	push	DWORD PTR [edi+6488]
	call	?SetNavIdAndMoveMouse@@YAXIABUImRect@@@Z ; SetNavIdAndMoveMouse
	add	esp, 8

; 2591 :         g.NavMoveFromClampedRefRect = false;

	mov	BYTE PTR [edi+6482], 0
$LN5@NavUpdate:

; 2592 :     }
; 2593 : 
; 2594 :     // Apply application mouse position movement, after we had a chance to process move request result.
; 2595 :     if (g.NavMousePosDirty && g.NavIdIsAlive)

	cmp	BYTE PTR [edi+6453], 0
	je	SHORT $LN13@NavUpdate
	cmp	BYTE PTR [edi+6452], 0
	je	SHORT $LN13@NavUpdate

; 2596 :     {
; 2597 :         // Set mouse position given our knowledge of the nav widget position from last frame
; 2598 :         if (g.IO.NavMovesMouse)

	cmp	BYTE PTR [edi+124], 0
	je	SHORT $LN14@NavUpdate

; 2599 :         {
; 2600 :             g.IO.MousePos = g.IO.MousePosPrev = NavCalcPreferredMousePos();

	lea	eax, DWORD PTR $T19[ebp]
	push	eax
	call	?NavCalcPreferredMousePos@@YA?AUImVec2@@XZ ; NavCalcPreferredMousePos
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edi+880], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+884], ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edi+208], ecx
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+212], eax

; 2601 :             g.IO.WantMoveMouse = true;

	mov	BYTE PTR [edi+847], 1
$LN14@NavUpdate:

; 2602 :         }
; 2603 :         g.NavMousePosDirty = false;

	mov	BYTE PTR [edi+6453], 0
$LN13@NavUpdate:

; 2604 :     }
; 2605 :     g.NavIdIsAlive = false;
; 2606 :     g.NavTabbedId = 0;
; 2607 : 
; 2608 :     // Navigation windowing mode (change focus, move/resize window)
; 2609 :     if (!g.NavWindowingTarget && IsNavInputPressed(ImGuiNavInput_PadMenu, ImGuiNavReadMode_Pressed))

	cmp	DWORD PTR [edi+6432], 0
	mov	BYTE PTR [edi+6452], 0
	mov	DWORD PTR [edi+6396], 0
	jne	SHORT $LN17@NavUpdate
	push	1
	push	3
	call	?IsNavInputPressed@@YA_NHW4ImGuiNavReadMode@@@Z ; IsNavInputPressed
	add	esp, 8
	test	al, al
	je	SHORT $LN17@NavUpdate

; 2610 :     {
; 2611 :         ImGuiWindow* window = g.NavWindow;

	mov	eax, DWORD PTR [edi+6380]

; 2612 :         if (!window)

	test	eax, eax
	jne	SHORT $LN247@NavUpdate

; 2613 :             window = FindWindowNavigable(g.Windows.Size-1, -1, -1);

	mov	eax, DWORD PTR [edi+6204]
	push	-1
	dec	eax
	push	-1
	push	eax
	call	?FindWindowNavigable@@YAPAUImGuiWindow@@HHH@Z ; FindWindowNavigable
	add	esp, 12					; 0000000cH

; 2614 :         if (window)

	test	eax, eax
	je	SHORT $LN17@NavUpdate
$LN247@NavUpdate:

; 2615 :         {
; 2616 :             g.NavWindowingTarget = window->RootNonPopupWindow;

	mov	eax, DWORD PTR [eax+636]
	mov	DWORD PTR [edi+6432], eax

; 2617 :             g.NavWindowingDisplayAlpha = 0.0f;

	mov	DWORD PTR [edi+6436], 0

; 2618 :             g.NavWindowingToggleLayer = true;

	mov	BYTE PTR [edi+6440], 1
$LN17@NavUpdate:

; 2619 :         }
; 2620 :     }
; 2621 :     if (g.NavWindowingTarget)

	mov	eax, DWORD PTR [edi+6432]
	test	eax, eax
	je	$LN24@NavUpdate

; 2622 :     {
; 2623 :         // Visuals only appears after a brief time holding the button, so that a fast tap (to toggle NavLayer) doesn't add visual noise
; 2624 :         const float pressed_duration = g.IO.NavInputsDownDuration[ImGuiNavInput_PadMenu];
; 2625 :         g.NavWindowingDisplayAlpha = ImMax(g.NavWindowingDisplayAlpha, ImSaturate((pressed_duration - 0.20f) / 0.05f));

	movss	xmm0, DWORD PTR [edi+5140]
	xorps	xmm1, xmm1
	subss	xmm0, DWORD PTR __real@3e4ccccd
	mulss	xmm0, DWORD PTR __real@41a00000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 134  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm1, xmm0
	movss	xmm1, DWORD PTR __real@3f800000
	jbe	SHORT $LN117@NavUpdate
	xorps	xmm0, xmm0
	jmp	SHORT $LN118@NavUpdate
$LN117@NavUpdate:
	minss	xmm0, xmm1
$LN118@NavUpdate:
	maxss	xmm0, DWORD PTR [edi+6436]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2629 :         const int focus_change_dir = (int)IsNavInputPressed(ImGuiNavInput_PadFocusPrev, ImGuiNavReadMode_RepeatSlow) - (int)IsNavInputPressed(ImGuiNavInput_PadFocusNext, ImGuiNavReadMode_RepeatSlow);

	push	4
	push	13					; 0000000dH
	comiss	xmm1, xmm0
	movss	DWORD PTR [edi+6436], xmm0
	seta	al
	and	BYTE PTR [edi+6440], al
	call	?IsNavInputPressed@@YA_NHW4ImGuiNavReadMode@@@Z ; IsNavInputPressed
	push	4
	push	12					; 0000000cH
	movzx	esi, al
	call	?IsNavInputPressed@@YA_NHW4ImGuiNavReadMode@@@Z ; IsNavInputPressed
	movzx	eax, al
	add	esp, 16					; 00000010H
	sub	eax, esi
	mov	DWORD PTR _focus_change_dir$1$[ebp], eax

; 2630 :         if (focus_change_dir != 0 && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_Modal))

	je	SHORT $LN19@NavUpdate
	mov	eax, DWORD PTR [edi+6432]
	test	DWORD PTR [eax+8], 67108864		; 04000000H
	jne	SHORT $LN19@NavUpdate

; 2631 :         {
; 2632 :             const int i_current = FindWindowIndex(g.NavWindowingTarget);

	push	eax
	call	?FindWindowIndex@@YAHPAUImGuiWindow@@@Z	; FindWindowIndex

; 2633 :             ImGuiWindow* window_target = FindWindowNavigable(i_current + focus_change_dir, -1, focus_change_dir);

	mov	esi, DWORD PTR _focus_change_dir$1$[ebp]
	push	esi
	push	-1
	mov	DWORD PTR _i_current$1$[ebp], eax
	lea	ecx, DWORD PTR [eax+esi]
	push	ecx
	call	?FindWindowNavigable@@YAPAUImGuiWindow@@HHH@Z ; FindWindowNavigable
	add	esp, 16					; 00000010H

; 2634 :             if (!window_target)

	test	eax, eax
	jne	SHORT $LN20@NavUpdate

; 2635 :                 window_target = FindWindowNavigable((focus_change_dir < 0) ? (g.Windows.Size-1) : 0, i_current, focus_change_dir);

	test	esi, esi
	jns	SHORT $LN62@NavUpdate
	mov	eax, DWORD PTR [edi+6204]
	dec	eax
	jmp	SHORT $LN63@NavUpdate
$LN62@NavUpdate:
	xor	eax, eax
$LN63@NavUpdate:
	push	esi
	push	DWORD PTR _i_current$1$[ebp]
	push	eax
	call	?FindWindowNavigable@@YAPAUImGuiWindow@@HHH@Z ; FindWindowNavigable
	add	esp, 12					; 0000000cH
$LN20@NavUpdate:

; 2636 :             g.NavWindowingTarget = window_target;

	mov	DWORD PTR [edi+6432], eax

; 2637 :             g.NavWindowingToggleLayer = false;

	mov	BYTE PTR [edi+6440], 0

; 2638 :             g.NavWindowingDisplayAlpha = 1.0f;

	mov	DWORD PTR [edi+6436], 1065353216	; 3f800000H
$LN19@NavUpdate:

; 2639 :         }
; 2640 : 
; 2641 :         // Move window
; 2642 :         if (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoMove))

	mov	esi, DWORD PTR [edi+6432]
	test	esi, esi
	je	$LN22@NavUpdate
	test	BYTE PTR [esi+8], 4
	jne	$LN22@NavUpdate

; 2643 :         {
; 2644 :             const ImVec2 move_delta = GetNavInputAmount2d(1, ImGuiNavReadMode_Down);

	sub	esp, 8
	lea	eax, DWORD PTR _move_delta$18[ebp]
	mov	DWORD PTR [esp+4], 0
	mov	DWORD PTR [esp], 0
	push	0
	push	1
	push	eax
	call	?GetNavInputAmount2d@@YA?AUImVec2@@HW4ImGuiNavReadMode@@MM@Z ; GetNavInputAmount2d

; 2645 :             if (move_delta.x != 0.0f || move_delta.y != 0.0f)

	movss	xmm3, DWORD PTR _move_delta$18[ebp]
	add	esp, 20					; 00000014H
	movss	xmm2, DWORD PTR _move_delta$18[ebp+4]
	xorps	xmm0, xmm0
	ucomiss	xmm3, xmm0
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN23@NavUpdate
	ucomiss	xmm2, xmm0
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN22@NavUpdate
$LN23@NavUpdate:
	movss	xmm1, DWORD PTR [edi+152]
	minss	xmm1, DWORD PTR [edi+148]

; 2646 :             {
; 2647 :                 const float move_speed = ImFloor(600 * g.IO.DeltaTime * ImMin(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y));

	movss	xmm0, DWORD PTR [edi+12]
	mulss	xmm0, DWORD PTR __real@44160000
	mulss	xmm1, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 140  : static inline float  ImFloor(float f)                                           { return (float)(int)f; }

	cvttss2si eax, xmm1
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	movaps	xmm0, xmm1
	mulss	xmm1, xmm2
	mulss	xmm0, xmm3

; 118  : static inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }

	addss	xmm0, DWORD PTR [esi+16]
	movss	DWORD PTR [esi+16], xmm0
	movss	xmm0, DWORD PTR [esi+20]
	addss	xmm0, xmm1
	movss	DWORD PTR [esi+20], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2650 :                 MarkIniSettingsDirty(g.NavWindowingTarget);

	push	DWORD PTR [edi+6432]
	mov	BYTE PTR [edi+6455], 1
	call	?MarkIniSettingsDirty@@YAXPAUImGuiWindow@@@Z ; MarkIniSettingsDirty
	add	esp, 4
$LN22@NavUpdate:

; 2651 :             }
; 2652 :         }
; 2653 : 
; 2654 :         if (!IsNavInputDown(ImGuiNavInput_PadMenu))

	push	3
	call	?IsNavInputDown@@YA_NH@Z		; IsNavInputDown
	add	esp, 4
	test	al, al
	jne	$LN24@NavUpdate

; 2655 :         {
; 2656 :             // Apply actual focus only when releasing the NavMenu button (until then the window was merely rendered front-most)
; 2657 :             if (g.NavWindowingTarget && !g.NavWindowingToggleLayer && (!g.NavWindow || g.NavWindowingTarget != g.NavWindow->RootNonPopupWindow))

	mov	eax, DWORD PTR [edi+6432]
	test	eax, eax
	je	SHORT $LN27@NavUpdate
	cmp	BYTE PTR [edi+6440], 0
	jne	SHORT $LN261@NavUpdate
	mov	ecx, DWORD PTR [edi+6380]
	test	ecx, ecx
	je	SHORT $LN26@NavUpdate
	cmp	eax, DWORD PTR [ecx+636]
	je	SHORT $LN27@NavUpdate
$LN26@NavUpdate:

; 2658 :             {
; 2659 :                 ImGui::FocusWindow(g.NavWindowingTarget);

	push	eax
	call	?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusWindow

; 2660 :                 g.NavDisableHighlight = false;
; 2661 :                 g.NavDisableMouseHover = true;
; 2662 :                 if (g.NavWindowingTarget->NavLastId == 0)

	mov	eax, DWORD PTR [edi+6432]
	add	esp, 4
	mov	WORD PTR [edi+6454], 256		; 00000100H
	cmp	DWORD PTR [eax+148], 0
	jne	SHORT $LN27@NavUpdate

; 2663 :                     NavInitWindow(g.NavWindowingTarget, false);

	push	0
	push	eax
	call	?NavInitWindow@@YAXPAUImGuiWindow@@_N@Z	; NavInitWindow
	add	esp, 8
$LN27@NavUpdate:

; 2664 :             }
; 2665 : 
; 2666 :             // Single press toggles NavLayer
; 2667 :             if (g.NavWindowingToggleLayer && g.NavWindow)

	cmp	BYTE PTR [edi+6440], 0
	je	$LN31@NavUpdate
$LN261@NavUpdate:
	mov	eax, DWORD PTR [edi+6380]
	test	eax, eax
	je	SHORT $LN31@NavUpdate

; 2668 :             {
; 2669 :                 if ((g.NavWindow->DC.NavLayerActiveFlags & (1<<1)) == 0 && (g.NavWindow->RootWindow->DC.NavLayerActiveFlags & (1<<1)) != 0)

	test	BYTE PTR [eax+276], 2
	jne	SHORT $LN29@NavUpdate
	mov	eax, DWORD PTR [eax+632]
	test	BYTE PTR [eax+276], 2
	je	SHORT $LN29@NavUpdate

; 2670 :                     ImGui::FocusWindow(g.NavWindow->RootWindow);

	push	eax
	call	?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusWindow
	add	esp, 4
$LN29@NavUpdate:

; 2671 :                 g.NavLayer = (g.NavWindow->DC.NavLayerActiveFlags & (1<<1)) ? (g.NavLayer ^ 1) : 0;

	mov	ecx, DWORD PTR [edi+6380]
	test	BYTE PTR [ecx+276], 2
	je	SHORT $LN64@NavUpdate
	mov	eax, DWORD PTR [edi+6444]
	xor	eax, 1
	jmp	SHORT $LN65@NavUpdate
$LN64@NavUpdate:
	xor	eax, eax
$LN65@NavUpdate:
	mov	DWORD PTR [edi+6444], eax

; 2672 :                 g.NavDisableHighlight = false;

	mov	WORD PTR [edi+6454], 256		; 00000100H

; 2673 :                 g.NavDisableMouseHover = true;
; 2674 :                 if (g.NavLayer == 0 && g.NavWindow->NavLastId)

	test	eax, eax
	jne	SHORT $LN30@NavUpdate
	mov	eax, DWORD PTR [ecx+148]
	test	eax, eax
	je	SHORT $LN30@NavUpdate

; 2675 :                     SetNavIdAndMoveMouse(g.NavWindow->NavLastId, ImRect());

	movaps	xmm0, XMMWORD PTR __xmm@ff7fffffff7fffff7f7fffff7f7fffff
	lea	ecx, DWORD PTR $T14[ebp]
	push	ecx
	push	eax
	movups	XMMWORD PTR $T14[ebp], xmm0
	call	?SetNavIdAndMoveMouse@@YAXIABUImRect@@@Z ; SetNavIdAndMoveMouse

; 2676 :                 else

	jmp	SHORT $LN262@NavUpdate
$LN30@NavUpdate:

; 2677 :                     NavInitWindow(g.NavWindow, true);

	push	1
	push	ecx
	call	?NavInitWindow@@YAXPAUImGuiWindow@@_N@Z	; NavInitWindow
$LN262@NavUpdate:
	add	esp, 8
$LN31@NavUpdate:

; 2678 :             }
; 2679 :             g.NavWindowingTarget = NULL;

	mov	DWORD PTR [edi+6432], 0
$LN24@NavUpdate:

; 2680 :         }
; 2681 :     }
; 2682 : 
; 2683 :     // Set output flags for user application
; 2684 :     g.IO.NavUsable = g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs);

	mov	esi, DWORD PTR [edi+6380]
	test	esi, esi
	je	SHORT $LN66@NavUpdate
	test	DWORD PTR [esi+8], 262144		; 00040000H
	jne	SHORT $LN66@NavUpdate
	mov	eax, 1
	jmp	SHORT $LN67@NavUpdate
$LN66@NavUpdate:
	xor	eax, eax
$LN67@NavUpdate:
	mov	BYTE PTR [edi+848], al

; 2685 :     g.IO.NavActive = (g.IO.NavUsable && g.NavId != 0 && !g.NavDisableHighlight) || (g.NavWindowingTarget != NULL) || g.NavInitDefaultRequest;

	test	al, al
	je	SHORT $LN68@NavUpdate
	cmp	DWORD PTR [edi+6384], 0
	je	SHORT $LN68@NavUpdate
	cmp	BYTE PTR [edi+6454], 0
	je	SHORT $LN69@NavUpdate
$LN68@NavUpdate:
	cmp	DWORD PTR [edi+6432], 0
	jne	SHORT $LN69@NavUpdate
	cmp	BYTE PTR [edi+6456], 0
	jne	SHORT $LN69@NavUpdate
	xor	eax, eax
	jmp	SHORT $LN70@NavUpdate
$LN69@NavUpdate:
	mov	eax, 1
$LN70@NavUpdate:

; 2686 : 
; 2687 :     // Process NavCancel input (to close a popup, get back to parent, clear focus)
; 2688 :     if (IsNavInputPressed(ImGuiNavInput_PadCancel, ImGuiNavReadMode_Pressed))

	push	1
	push	1
	mov	BYTE PTR [edi+849], al
	call	?IsNavInputPressed@@YA_NHW4ImGuiNavReadMode@@@Z ; IsNavInputPressed
	add	esp, 8
	test	al, al
	je	$LN41@NavUpdate

; 2689 :     {
; 2690 :         if (g.ActiveId != 0)

	cmp	DWORD PTR [edi+6264], 0
	je	SHORT $LN33@NavUpdate

; 2691 :         {
; 2692 :             ImGui::ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
	jmp	$LN41@NavUpdate
$LN33@NavUpdate:

; 2693 :         }
; 2694 :         else if (g.NavWindow && (g.NavWindow->Flags & ImGuiWindowFlags_ChildWindow) && !(g.NavWindow->Flags & ImGuiWindowFlags_Popup) && g.NavWindow->ParentWindow)

	test	esi, esi
	je	SHORT $LN35@NavUpdate
	mov	eax, DWORD PTR [esi+8]
	and	eax, 37748736				; 02400000H
	cmp	eax, 4194304				; 00400000H
	jne	SHORT $LN35@NavUpdate
	mov	eax, DWORD PTR [esi+628]
	mov	DWORD PTR _parent_window$1$[ebp], eax
	test	eax, eax
	je	SHORT $LN35@NavUpdate

; 2695 :         {
; 2696 :             // Exit child window
; 2697 :             ImGuiWindow* child_window = g.NavWindow;
; 2698 :             ImGuiWindow* parent_window = g.NavWindow->ParentWindow;
; 2699 :             ImGui::FocusWindow(parent_window);

	push	eax
	call	?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusWindow

; 2700 :             SetNavId(parent_window->GetChildID(child_window));

	mov	ecx, DWORD PTR _parent_window$1$[ebp]
	add	esp, 4
	push	esi
	call	?GetChildID@ImGuiWindow@@QAEIPAU1@@Z	; ImGuiWindow::GetChildID
	push	eax
	call	?SetNavId@@YAXI@Z			; SetNavId
	add	esp, 4

; 2701 :             g.NavIdIsAlive = false;

	mov	BYTE PTR [edi+6452], 0

; 2702 :             if (g.NavDisableMouseHover)

	cmp	BYTE PTR [edi+6455], 0
	je	$LN41@NavUpdate

; 2703 :                 g.NavMousePosDirty = true;

	mov	BYTE PTR [edi+6453], 1

; 2704 :         }

	jmp	$LN41@NavUpdate
$LN35@NavUpdate:

; 2705 :         else if (g.OpenPopupStack.Size > 0)

	mov	eax, DWORD PTR [edi+6356]
	test	eax, eax
	jle	SHORT $LN38@NavUpdate

; 2706 :         {
; 2707 :             // Close open popup/menu
; 2708 :             ClosePopupToLevel(g.OpenPopupStack.Size - 1);

	dec	eax
	push	eax
	call	?ClosePopupToLevel@@YAXH@Z		; ClosePopupToLevel
	add	esp, 4
	jmp	SHORT $LN41@NavUpdate
$LN38@NavUpdate:

; 2709 :         }
; 2710 :         else if (g.NavLayer != 0)

	cmp	DWORD PTR [edi+6444], 0
	je	SHORT $LN40@NavUpdate

; 2711 :         {
; 2712 :             // Leave the "menu" layer
; 2713 :             g.NavLayer = 0;

	mov	DWORD PTR [edi+6444], 0

; 2714 :             if (g.NavWindow && g.NavWindow->NavLastId)

	test	esi, esi
	je	SHORT $LN42@NavUpdate
	mov	eax, DWORD PTR [esi+148]
	test	eax, eax
	je	SHORT $LN42@NavUpdate

; 2715 :                 SetNavIdAndMoveMouse(g.NavWindow->NavLastId, ImRect());

	movaps	xmm0, XMMWORD PTR __xmm@ff7fffffff7fffff7f7fffff7f7fffff
	lea	ecx, DWORD PTR $T13[ebp]
	push	ecx
	push	eax
	movups	XMMWORD PTR $T13[ebp], xmm0
	call	?SetNavIdAndMoveMouse@@YAXIABUImRect@@@Z ; SetNavIdAndMoveMouse
	add	esp, 8

; 2716 :             else

	jmp	SHORT $LN41@NavUpdate
$LN42@NavUpdate:

; 2717 :                 NavInitWindow(g.NavWindow, true);

	push	1
	push	esi
	call	?NavInitWindow@@YAXPAUImGuiWindow@@_N@Z	; NavInitWindow
	add	esp, 8

; 2718 :         }
; 2719 :         else

	jmp	SHORT $LN41@NavUpdate
$LN40@NavUpdate:

; 2720 :         {
; 2721 :             // Clear NavLastId for popups but keep it for regular child window so we can leave one and come back where we were
; 2722 :             if (g.NavWindow && ((g.NavWindow->Flags & ImGuiWindowFlags_Popup) || !(g.NavWindow->Flags & ImGuiWindowFlags_ChildWindow)))

	test	esi, esi
	je	SHORT $LN44@NavUpdate
	mov	eax, DWORD PTR [esi+8]
	test	eax, 33554432				; 02000000H
	jne	SHORT $LN45@NavUpdate
	test	eax, 4194304				; 00400000H
	jne	SHORT $LN44@NavUpdate
$LN45@NavUpdate:

; 2723 :                 g.NavWindow->NavLastId = 0;

	mov	DWORD PTR [esi+148], 0
$LN44@NavUpdate:

; 2724 :             g.NavId = 0;

	mov	DWORD PTR [edi+6384], 0
$LN41@NavUpdate:

; 2725 :         }
; 2726 :     }
; 2727 : 
; 2728 :     g.NavActivateId = (g.NavId && !g.NavDisableHighlight && !g.NavWindowingTarget && g.ActiveId == 0 && IsNavInputPressed(ImGuiNavInput_PadActivate, ImGuiNavReadMode_Pressed)) ? g.NavId : 0;

	mov	esi, DWORD PTR [edi+6384]
	test	esi, esi
	je	SHORT $LN71@NavUpdate
	cmp	BYTE PTR [edi+6454], 0
	jne	SHORT $LN71@NavUpdate
	cmp	DWORD PTR [edi+6432], 0
	jne	SHORT $LN71@NavUpdate
	cmp	DWORD PTR [edi+6264], 0
	jne	SHORT $LN71@NavUpdate
	push	1
	push	0
	call	?IsNavInputPressed@@YA_NHW4ImGuiNavReadMode@@@Z ; IsNavInputPressed
	add	esp, 8
	test	al, al
	je	SHORT $LN71@NavUpdate
	mov	eax, esi
	jmp	SHORT $LN72@NavUpdate
$LN71@NavUpdate:
	xor	eax, eax
$LN72@NavUpdate:
	mov	DWORD PTR [edi+6388], eax

; 2729 :     g.NavInputId = (g.NavId && !g.NavDisableHighlight && !g.NavWindowingTarget && g.ActiveId == 0 && IsNavInputPressed(ImGuiNavInput_PadInput, ImGuiNavReadMode_Pressed)) ? g.NavId : 0;

	test	esi, esi
	je	SHORT $LN73@NavUpdate
	cmp	BYTE PTR [edi+6454], 0
	jne	SHORT $LN73@NavUpdate
	cmp	DWORD PTR [edi+6432], 0
	jne	SHORT $LN73@NavUpdate
	cmp	DWORD PTR [edi+6264], 0
	jne	SHORT $LN73@NavUpdate
	push	1
	push	2
	call	?IsNavInputPressed@@YA_NHW4ImGuiNavReadMode@@@Z ; IsNavInputPressed
	add	esp, 8
	test	al, al
	jne	SHORT $LN74@NavUpdate
$LN73@NavUpdate:
	xor	esi, esi
$LN74@NavUpdate:
	mov	DWORD PTR [edi+6392], esi

; 2730 :     if (g.NavWindow && (g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))

	mov	esi, DWORD PTR [edi+6380]
	test	esi, esi
	je	SHORT $LN46@NavUpdate
	test	DWORD PTR [esi+8], 262144		; 00040000H
	je	SHORT $LN46@NavUpdate

; 2731 :     {
; 2732 :         g.NavActivateId = g.NavInputId = 0;

	mov	DWORD PTR [edi+6392], 0
	mov	DWORD PTR [edi+6388], 0

; 2733 :         g.NavDisableHighlight = true;

	mov	BYTE PTR [edi+6454], 1
$LN46@NavUpdate:

; 2734 :     }
; 2735 :     g.NavMoveRequest = false;
; 2736 : 
; 2737 :     // Initiate directional inputs request
; 2738 :     const int allowed_dir_flags = (g.ActiveId == 0) ? ~0 : g.ActiveIdAllowNavDirFlags;

	cmp	DWORD PTR [edi+6264], 0
	mov	BYTE PTR [edi+6481], 0
	jne	SHORT $LN75@NavUpdate
	or	eax, -1
	jmp	SHORT $LN263@NavUpdate
$LN75@NavUpdate:
	mov	eax, DWORD PTR [edi+6276]
$LN263@NavUpdate:
	mov	DWORD PTR _allowed_dir_flags$1$[ebp], eax

; 2739 :     g.NavMoveDir = ImGuiNavDir_None;

	mov	DWORD PTR [edi+6484], -1

; 2740 :     if (g.NavWindow && !g.NavWindowingTarget && allowed_dir_flags && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))

	test	esi, esi
	je	$LN51@NavUpdate
	cmp	DWORD PTR [edi+6432], 0
	jne	$LN51@NavUpdate
	test	eax, eax
	je	$LN51@NavUpdate
	test	DWORD PTR [esi+8], 262144		; 00040000H
	jne	$LN51@NavUpdate

; 2741 :     {
; 2742 :         if ((allowed_dir_flags & (1<<ImGuiNavDir_Left))  && IsNavInputPressed(ImGuiNavInput_PadLeft,  ImGuiNavReadMode_Repeat)) g.NavMoveDir = ImGuiNavDir_Left;

	test	al, 1
	je	SHORT $LN48@NavUpdate
	push	3
	push	6
	call	?IsNavInputPressed@@YA_NHW4ImGuiNavReadMode@@@Z ; IsNavInputPressed
	add	esp, 8
	test	al, al
	mov	eax, DWORD PTR _allowed_dir_flags$1$[ebp]
	je	SHORT $LN48@NavUpdate
	mov	DWORD PTR [edi+6484], 0
$LN48@NavUpdate:

; 2743 :         if ((allowed_dir_flags & (1<<ImGuiNavDir_Right)) && IsNavInputPressed(ImGuiNavInput_PadRight, ImGuiNavReadMode_Repeat)) g.NavMoveDir = ImGuiNavDir_Right;

	test	al, 2
	je	SHORT $LN49@NavUpdate
	push	3
	push	7
	call	?IsNavInputPressed@@YA_NHW4ImGuiNavReadMode@@@Z ; IsNavInputPressed
	add	esp, 8
	test	al, al
	mov	eax, DWORD PTR _allowed_dir_flags$1$[ebp]
	je	SHORT $LN49@NavUpdate
	mov	DWORD PTR [edi+6484], 1
$LN49@NavUpdate:

; 2744 :         if ((allowed_dir_flags & (1<<ImGuiNavDir_Up))    && IsNavInputPressed(ImGuiNavInput_PadUp,    ImGuiNavReadMode_Repeat)) g.NavMoveDir = ImGuiNavDir_Up;

	test	al, 4
	je	SHORT $LN50@NavUpdate
	push	3
	push	4
	call	?IsNavInputPressed@@YA_NHW4ImGuiNavReadMode@@@Z ; IsNavInputPressed
	add	esp, 8
	test	al, al
	mov	eax, DWORD PTR _allowed_dir_flags$1$[ebp]
	je	SHORT $LN50@NavUpdate
	mov	DWORD PTR [edi+6484], 2
$LN50@NavUpdate:

; 2745 :         if ((allowed_dir_flags & (1<<ImGuiNavDir_Down))  && IsNavInputPressed(ImGuiNavInput_PadDown,  ImGuiNavReadMode_Repeat)) g.NavMoveDir = ImGuiNavDir_Down;

	test	al, 8
	je	SHORT $LN51@NavUpdate
	push	3
	push	5
	call	?IsNavInputPressed@@YA_NHW4ImGuiNavReadMode@@@Z ; IsNavInputPressed
	add	esp, 8
	test	al, al
	je	SHORT $LN51@NavUpdate
	mov	DWORD PTR [edi+6484], 3
$LN51@NavUpdate:

; 2746 :     }
; 2747 :     if (g.NavMoveDir != ImGuiNavDir_None)

	mov	ecx, DWORD PTR [edi+6484]
	cmp	ecx, -1
	je	SHORT $LN52@NavUpdate

; 2748 :         g.NavMoveRequest = true;

	mov	BYTE PTR [edi+6481], 1
$LN52@NavUpdate:

; 2749 : 
; 2750 :     // If we initiate a movement request and have no current NavId, we initiate a InitDefautRequest that will be used as a fallback if the direction fails to find a match
; 2751 :     if (g.NavMoveRequest && g.NavId == 0)

	mov	dl, BYTE PTR [edi+6481]
	test	dl, dl
	je	SHORT $LN53@NavUpdate
	cmp	DWORD PTR [edi+6384], 0
	jne	SHORT $LN53@NavUpdate

; 2752 :     {
; 2753 :         g.NavInitDefaultRequest = g.NavInitDefaultResultExplicit = true;

	mov	BYTE PTR [edi+6480], 1
	mov	BYTE PTR [edi+6456], 1

; 2754 :         g.NavInitDefaultResultId = 0;

	mov	DWORD PTR [edi+6460], 0

; 2755 :         g.NavDisableHighlight = false;

	mov	BYTE PTR [edi+6454], 0
$LN53@NavUpdate:

; 2756 :     }
; 2757 : 
; 2758 :     // Scrolling
; 2759 :     if (g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.NavWindowingTarget)

	movss	xmm2, DWORD PTR __real@3f000000
	test	esi, esi
	je	$LN58@NavUpdate
	test	DWORD PTR [esi+8], 262144		; 00040000H
	jne	$LN58@NavUpdate
	cmp	DWORD PTR [edi+6432], 0
	jne	$LN58@NavUpdate

; 2763 :         if (!g.NavWindow->DC.NavLayerActiveFlags && g.NavWindow->DC.NavHasScroll && g.NavMoveRequest && (g.NavMoveDir == ImGuiNavDir_Up || g.NavMoveDir == ImGuiNavDir_Down))

	cmp	DWORD PTR [esi+276], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	movss	xmm0, DWORD PTR [esi+620]
	mulss	xmm0, DWORD PTR [eax+6176]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2762 :         const float scroll_speed = ImFloor(g.NavWindow->CalcFontSize() * 100 * g.IO.DeltaTime + 0.5f); // We need round the scrolling speed because sub-pixel scroll isn't reliably supported.

	mulss	xmm0, DWORD PTR __real@42c80000
	mulss	xmm0, DWORD PTR [edi+12]
	addss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 140  : static inline float  ImFloor(float f)                                           { return (float)(int)f; }

	cvttss2si eax, xmm0
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	movss	DWORD PTR _scroll_speed$1$[ebp], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2763 :         if (!g.NavWindow->DC.NavLayerActiveFlags && g.NavWindow->DC.NavHasScroll && g.NavMoveRequest && (g.NavMoveDir == ImGuiNavDir_Up || g.NavMoveDir == ImGuiNavDir_Down))

	jne	SHORT $LN55@NavUpdate
	cmp	BYTE PTR [esi+270], 0
	je	SHORT $LN55@NavUpdate
	test	dl, dl
	je	SHORT $LN55@NavUpdate
	cmp	ecx, 2
	je	SHORT $LN265@NavUpdate
	cmp	ecx, 3
	jne	SHORT $LN55@NavUpdate

; 2764 :             SetWindowScrollY(g.NavWindow, ImFloor(g.NavWindow->Scroll.y + ((g.NavMoveDir == ImGuiNavDir_Up) ? -1.0f : +1.0f) * scroll_speed));

	cmp	ecx, 2
	jne	SHORT $LN77@NavUpdate
$LN265@NavUpdate:
	movss	xmm0, DWORD PTR __real@bf800000
	jmp	SHORT $LN78@NavUpdate
$LN77@NavUpdate:
	movss	xmm0, DWORD PTR __real@3f800000
$LN78@NavUpdate:
	mulss	xmm0, xmm1
	push	ecx
	addss	xmm0, DWORD PTR [esi+96]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 140  : static inline float  ImFloor(float f)                                           { return (float)(int)f; }

	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2764 :             SetWindowScrollY(g.NavWindow, ImFloor(g.NavWindow->Scroll.y + ((g.NavMoveDir == ImGuiNavDir_Up) ? -1.0f : +1.0f) * scroll_speed));

	movss	DWORD PTR [esp], xmm0
	push	esi
	call	?SetWindowScrollY@@YAXPAUImGuiWindow@@M@Z ; SetWindowScrollY
	add	esp, 8
$LN55@NavUpdate:

; 2765 : 
; 2766 :         // Manual scroll with NavScrollXXX keys
; 2767 :         ImVec2 scroll_dir = GetNavInputAmount2d(1, ImGuiNavReadMode_Down, 1.0f/10.0f, 10.0f);

	sub	esp, 8
	lea	eax, DWORD PTR _scroll_dir$17[ebp]
	mov	DWORD PTR [esp+4], 1092616192		; 41200000H
	mov	DWORD PTR [esp], 1036831949		; 3dcccccdH
	push	0
	push	1
	push	eax
	call	?GetNavInputAmount2d@@YA?AUImVec2@@HW4ImGuiNavReadMode@@MM@Z ; GetNavInputAmount2d

; 2768 :         if (scroll_dir.x != 0.0f && g.NavWindow->ScrollbarX)

	movss	xmm0, DWORD PTR _scroll_dir$17[ebp]
	add	esp, 20					; 00000014H

; 2770 :             SetWindowScrollX(g.NavWindow, ImFloor(g.NavWindow->Scroll.x + scroll_dir.x * scroll_speed));

	movss	xmm2, DWORD PTR _scroll_speed$1$[ebp]
	xorps	xmm3, xmm3
	ucomiss	xmm0, xmm3
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN57@NavUpdate

; 2768 :         if (scroll_dir.x != 0.0f && g.NavWindow->ScrollbarX)

	mov	ecx, DWORD PTR [edi+6380]
	cmp	BYTE PTR [ecx+116], 0
	je	SHORT $LN57@NavUpdate

; 2770 :             SetWindowScrollX(g.NavWindow, ImFloor(g.NavWindow->Scroll.x + scroll_dir.x * scroll_speed));

	mulss	xmm0, xmm2
	push	ecx
	addss	xmm0, DWORD PTR [ecx+92]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 140  : static inline float  ImFloor(float f)                                           { return (float)(int)f; }

	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2770 :             SetWindowScrollX(g.NavWindow, ImFloor(g.NavWindow->Scroll.x + scroll_dir.x * scroll_speed));

	movss	DWORD PTR [esp], xmm0
	push	ecx
	call	?SetWindowScrollX@@YAXPAUImGuiWindow@@M@Z ; SetWindowScrollX
	add	esp, 8

; 2771 :             g.NavMoveFromClampedRefRect = true;

	mov	BYTE PTR [edi+6482], 1
$LN57@NavUpdate:

; 2772 :         }
; 2773 :         if (scroll_dir.y != 0.0f)

	movss	xmm0, DWORD PTR _scroll_dir$17[ebp+4]
	ucomiss	xmm0, xmm3
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN252@NavUpdate

; 2775 :             SetWindowScrollY(g.NavWindow, ImFloor(g.NavWindow->Scroll.y + scroll_dir.y * scroll_speed));

	mov	ecx, DWORD PTR [edi+6380]
	mulss	xmm0, xmm2
	push	ecx
	addss	xmm0, DWORD PTR [ecx+96]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 140  : static inline float  ImFloor(float f)                                           { return (float)(int)f; }

	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2775 :             SetWindowScrollY(g.NavWindow, ImFloor(g.NavWindow->Scroll.y + scroll_dir.y * scroll_speed));

	movss	DWORD PTR [esp], xmm0
	push	ecx
	call	?SetWindowScrollY@@YAXPAUImGuiWindow@@M@Z ; SetWindowScrollY
	add	esp, 8

; 2776 :             g.NavMoveFromClampedRefRect = true;

	mov	BYTE PTR [edi+6482], 1
$LN252@NavUpdate:
	movss	xmm2, DWORD PTR __real@3f000000
$LN58@NavUpdate:

; 2783 :     if (g.NavMoveRequest && g.NavMoveFromClampedRefRect && g.NavLayer == 0)

	cmp	BYTE PTR [edi+6481], 0
	mov	DWORD PTR [edi+6488], 0
	mov	DWORD PTR [edi+6496], 2139095039	; 7f7fffffH
	mov	DWORD PTR [edi+6492], 2139095039	; 7f7fffffH
	mov	DWORD PTR [edi+6500], 2139095039	; 7f7fffffH
	pop	esi
	je	$LN255@NavUpdate
	cmp	BYTE PTR [edi+6482], 0
	je	$LN255@NavUpdate
	cmp	DWORD PTR [edi+6444], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm7, DWORD PTR __real@3f800000
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2783 :     if (g.NavMoveRequest && g.NavMoveFromClampedRefRect && g.NavLayer == 0)

	jne	$LN59@NavUpdate

; 2784 :     {
; 2785 :         // When we have manually scrolled and NavId is out of bounds, we clamp its bounding box (used for search) to the visible area to restart navigation within visible items
; 2786 :         ImRect window_rect_rel(g.NavWindow->InnerRect.Min - g.NavWindow->Pos - ImVec2(1,1), g.NavWindow->InnerRect.Max - g.NavWindow->Pos + ImVec2(1,1));

	mov	ecx, DWORD PTR [edi+6380]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 253  :     bool        Contains(const ImRect& r) const { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x < Max.x && r.Max.y < Max.y; }

	movss	xmm0, DWORD PTR [edi+6400]

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm3, DWORD PTR [ecx+504]
	subss	xmm3, DWORD PTR [ecx+24]
	movss	xmm6, DWORD PTR [ecx+508]
	movss	xmm5, DWORD PTR [ecx+512]
	subss	xmm6, DWORD PTR [ecx+28]
	subss	xmm5, DWORD PTR [ecx+24]
	movss	xmm4, DWORD PTR [ecx+516]
	subss	xmm3, xmm7
	subss	xmm4, DWORD PTR [ecx+28]
	subss	xmm6, xmm7

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm5, xmm7

; 253  :     bool        Contains(const ImRect& r) const { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x < Max.x && r.Max.y < Max.y; }

	comiss	xmm0, xmm3

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm4, xmm7
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T16[ebp], xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T16[ebp]
	mov	DWORD PTR _window_rect_rel$12[ebp], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T16[ebp+4], xmm6
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T16[ebp+4]
	mov	DWORD PTR _window_rect_rel$12[ebp+4], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T22[ebp], xmm5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T22[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T22[ebp+4], xmm4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _window_rect_rel$12[ebp+8], eax
	mov	eax, DWORD PTR $T22[ebp+4]
	mov	DWORD PTR _window_rect_rel$12[ebp+12], eax

; 253  :     bool        Contains(const ImRect& r) const { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x < Max.x && r.Max.y < Max.y; }

	jb	SHORT $LN181@NavUpdate
	movss	xmm0, DWORD PTR [edi+6404]
	comiss	xmm0, xmm6
	jb	SHORT $LN181@NavUpdate
	comiss	xmm5, DWORD PTR [edi+6408]
	jbe	SHORT $LN181@NavUpdate
	comiss	xmm4, DWORD PTR [edi+6412]
	ja	$LN60@NavUpdate
$LN181@NavUpdate:

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 247  :     float       GetHeight() const               { return Max.y-Min.y; }

	subss	xmm4, xmm6

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm1, DWORD PTR [ecx+620]

; 258  :     void        Expand(const ImVec2& amount)    { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }

	movss	xmm0, DWORD PTR _window_rect_rel$12[ebp+4]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm1, DWORD PTR [eax+6176]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2789 :             float pad = g.NavWindow->CalcFontSize() * 0.5f;

	mulss	xmm1, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 246  :     float       GetWidth() const                { return Max.x-Min.x; }

	movaps	xmm2, xmm5
	subss	xmm2, xmm3
	minss	xmm4, xmm1
	minss	xmm2, xmm1

; 258  :     void        Expand(const ImVec2& amount)    { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }

	movss	xmm1, DWORD PTR _window_rect_rel$12[ebp+12]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2790 :             window_rect_rel.Expand(ImVec2(-ImMin(window_rect_rel.GetWidth(), pad), -ImMin(window_rect_rel.GetHeight(), pad))); // Terrible approximation for the intend of starting navigation from first fully visible item

	xorps	xmm4, DWORD PTR __xmm@80000000800000008000000080000000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 258  :     void        Expand(const ImVec2& amount)    { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }

	subss	xmm0, xmm4
	addss	xmm1, xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2790 :             window_rect_rel.Expand(ImVec2(-ImMin(window_rect_rel.GetWidth(), pad), -ImMin(window_rect_rel.GetHeight(), pad))); // Terrible approximation for the intend of starting navigation from first fully visible item

	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 258  :     void        Expand(const ImVec2& amount)    { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }

	subss	xmm3, xmm2
	addss	xmm2, xmm5

; 260  :     void        Clip(ImRect& r) const           { r.Min.x = ImClamp(r.Min.x, Min.x, Max.x); r.Min.y = ImClamp(r.Min.y, Min.y, Max.y); r.Max.x = ImClamp(r.Max.x, Min.x, Max.x); r.Max.y = ImClamp(r.Max.y, Min.y, Max.y); }

	movss	xmm5, DWORD PTR [edi+6400]

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm3, xmm5
	jbe	SHORT $LN207@NavUpdate
	movaps	xmm4, xmm3
	jmp	SHORT $LN208@NavUpdate
$LN207@NavUpdate:
	movaps	xmm4, xmm2
	minss	xmm4, xmm5
$LN208@NavUpdate:

; 260  :     void        Clip(ImRect& r) const           { r.Min.x = ImClamp(r.Min.x, Min.x, Max.x); r.Min.y = ImClamp(r.Min.y, Min.y, Max.y); r.Max.x = ImClamp(r.Max.x, Min.x, Max.x); r.Max.y = ImClamp(r.Max.y, Min.y, Max.y); }

	movss	xmm5, DWORD PTR [edi+6404]

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm0, xmm5

; 260  :     void        Clip(ImRect& r) const           { r.Min.x = ImClamp(r.Min.x, Min.x, Max.x); r.Min.y = ImClamp(r.Min.y, Min.y, Max.y); r.Max.x = ImClamp(r.Max.x, Min.x, Max.x); r.Max.y = ImClamp(r.Max.y, Min.y, Max.y); }

	movss	DWORD PTR [edi+6400], xmm4

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	jbe	SHORT $LN213@NavUpdate
	movaps	xmm4, xmm0
	jmp	SHORT $LN214@NavUpdate
$LN213@NavUpdate:
	movaps	xmm4, xmm1
	minss	xmm4, xmm5
$LN214@NavUpdate:

; 260  :     void        Clip(ImRect& r) const           { r.Min.x = ImClamp(r.Min.x, Min.x, Max.x); r.Min.y = ImClamp(r.Min.y, Min.y, Max.y); r.Max.x = ImClamp(r.Max.x, Min.x, Max.x); r.Max.y = ImClamp(r.Max.y, Min.y, Max.y); }

	movss	DWORD PTR [edi+6404], xmm4
	movss	xmm4, DWORD PTR [edi+6408]

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm3, xmm4
	ja	SHORT $LN220@NavUpdate
	minss	xmm2, xmm4
	movaps	xmm3, xmm2
$LN220@NavUpdate:

; 260  :     void        Clip(ImRect& r) const           { r.Min.x = ImClamp(r.Min.x, Min.x, Max.x); r.Min.y = ImClamp(r.Min.y, Min.y, Max.y); r.Max.x = ImClamp(r.Max.x, Min.x, Max.x); r.Max.y = ImClamp(r.Max.y, Min.y, Max.y); }

	movss	xmm2, DWORD PTR [edi+6412]

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm0, xmm2

; 260  :     void        Clip(ImRect& r) const           { r.Min.x = ImClamp(r.Min.x, Min.x, Max.x); r.Min.y = ImClamp(r.Min.y, Min.y, Max.y); r.Max.x = ImClamp(r.Max.x, Min.x, Max.x); r.Max.y = ImClamp(r.Max.y, Min.y, Max.y); }

	movss	DWORD PTR [edi+6408], xmm3

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	ja	SHORT $LN226@NavUpdate
	minss	xmm1, xmm2
	movaps	xmm0, xmm1
$LN226@NavUpdate:

; 260  :     void        Clip(ImRect& r) const           { r.Min.x = ImClamp(r.Min.x, Min.x, Max.x); r.Min.y = ImClamp(r.Min.y, Min.y, Max.y); r.Max.x = ImClamp(r.Max.x, Min.x, Max.x); r.Max.y = ImClamp(r.Max.y, Min.y, Max.y); }

	movss	DWORD PTR [edi+6412], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2792 :             g.NavId = 0;

	mov	DWORD PTR [edi+6384], 0
$LN60@NavUpdate:

; 2793 :         }
; 2794 :         g.NavMoveFromClampedRefRect = false;

	mov	BYTE PTR [edi+6482], 0
	jmp	SHORT $LN59@NavUpdate
$LN255@NavUpdate:
	movss	xmm7, DWORD PTR __real@3f800000
$LN59@NavUpdate:

; 2798 :     g.NavScoringRectScreen = g.NavWindow ? ImRect(g.NavWindow->Pos + g.NavRefRectRel.Min, g.NavWindow->Pos + g.NavRefRectRel.Max) : ImRect();

	mov	eax, DWORD PTR [edi+6380]
	test	eax, eax
	je	SHORT $LN79@NavUpdate
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [eax+24]
	addss	xmm0, DWORD PTR [edi+6408]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T21[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [eax+28]
	addss	xmm0, DWORD PTR [edi+6412]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T21[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [eax+24]
	addss	xmm0, DWORD PTR [edi+6400]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T15[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [eax+28]
	addss	xmm0, DWORD PTR [edi+6404]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T15[ebp]
	mov	DWORD PTR $T11[ebp], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T15[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T15[ebp+4]
	mov	DWORD PTR $T11[ebp+4], eax
	mov	eax, DWORD PTR $T21[ebp]
	mov	DWORD PTR $T11[ebp+8], eax
	mov	eax, DWORD PTR $T21[ebp+4]
	mov	DWORD PTR $T11[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2798 :     g.NavScoringRectScreen = g.NavWindow ? ImRect(g.NavWindow->Pos + g.NavRefRectRel.Min, g.NavWindow->Pos + g.NavRefRectRel.Max) : ImRect();

	jmp	SHORT $LN266@NavUpdate
$LN79@NavUpdate:
	movaps	xmm0, XMMWORD PTR __xmm@ff7fffffff7fffff7f7fffff7f7fffff
	movups	XMMWORD PTR $T10[ebp], xmm0
$LN266@NavUpdate:
	lea	eax, DWORD PTR $T10[ebp]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [edi+6416], xmm0

; 2799 :     g.NavScoringRectScreen.Min.x = ImMin(g.NavScoringRectScreen.Min.x + 1.0f, g.NavScoringRectScreen.Max.x);

	movss	xmm0, DWORD PTR [edi+6416]
	addss	xmm0, xmm7
	minss	xmm0, DWORD PTR [edi+6424]
	movss	DWORD PTR [edi+6416], xmm0

; 2800 :     g.NavScoringRectScreen.Max.x = g.NavScoringRectScreen.Min.x;

	movss	DWORD PTR [edi+6424], xmm0
	pop	edi

; 2801 :     //g.OverlayDrawList.AddRect(g.NavScoringRectScreen.Min, g.NavScoringRectScreen.Max, IM_COL32(255,200,0,255)); // [DEBUG]
; 2802 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?NavUpdate@@YAXXZ ENDP					; NavUpdate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
tv211 = 8						; size = 4
tv204 = 8						; size = 4
___$ReturnUdt$ = 8					; size = 4
_stick_no$ = 12						; size = 4
_mode$ = 16						; size = 4
_slow_factor$ = 20					; size = 4
_fast_factor$ = 24					; size = 4
?GetNavInputAmount2d@@YA?AUImVec2@@HW4ImGuiNavReadMode@@MM@Z PROC ; GetNavInputAmount2d

; 2519 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 97   :     ImVec2() { x = y = 0.0f; }

	mov	ebx, DWORD PTR ___$ReturnUdt$[ebp]
	push	esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2524 :     delta.x = GetNavInputAmount(ImGuiNavInput_PadRight + stick_no*4, mode) - GetNavInputAmount(ImGuiNavInput_PadLeft + stick_no*4, mode); 

	mov	esi, DWORD PTR _mode$[ebp]
	push	edi
	mov	edi, DWORD PTR _stick_no$[ebp]
	push	esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 97   :     ImVec2() { x = y = 0.0f; }

	mov	DWORD PTR [ebx+4], 0
	mov	DWORD PTR [ebx], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2524 :     delta.x = GetNavInputAmount(ImGuiNavInput_PadRight + stick_no*4, mode) - GetNavInputAmount(ImGuiNavInput_PadLeft + stick_no*4, mode); 

	lea	eax, DWORD PTR [edi*4+7]
	push	eax
	call	?GetNavInputAmount@@YAMHW4ImGuiNavReadMode@@@Z ; GetNavInputAmount
	lea	eax, DWORD PTR [edi*4+6]
	push	esi
	fstp	DWORD PTR tv204[ebp]
	push	eax
	call	?GetNavInputAmount@@YAMHW4ImGuiNavReadMode@@@Z ; GetNavInputAmount
	fsubr	DWORD PTR tv204[ebp]

; 2525 :     delta.y = GetNavInputAmount(ImGuiNavInput_PadDown  + stick_no*4, mode) - GetNavInputAmount(ImGuiNavInput_PadUp   + stick_no*4, mode); 

	lea	eax, DWORD PTR [edi*4+5]
	push	esi
	push	eax
	fstp	DWORD PTR [ebx]
	call	?GetNavInputAmount@@YAMHW4ImGuiNavReadMode@@@Z ; GetNavInputAmount
	lea	eax, DWORD PTR [edi*4+4]
	push	esi
	fstp	DWORD PTR tv211[ebp]
	push	eax
	call	?GetNavInputAmount@@YAMHW4ImGuiNavReadMode@@@Z ; GetNavInputAmount

; 2526 :     if (slow_factor != 0.0f && IsNavInputDown(ImGuiNavInput_PadTweakSlow))

	movss	xmm1, DWORD PTR _slow_factor$[ebp]
	add	esp, 32					; 00000020H
	fsubr	DWORD PTR tv211[ebp]
	xorps	xmm2, xmm2
	ucomiss	xmm1, xmm2
	fstp	DWORD PTR [ebx+4]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@GetNavInpu
	push	14					; 0000000eH
	call	?IsNavInputDown@@YA_NH@Z		; IsNavInputDown
	add	esp, 4
	test	al, al
	je	SHORT $LN2@GetNavInpu
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 120  : static inline ImVec2& operator*=(ImVec2& lhs, const float rhs)                  { lhs.x *= rhs; lhs.y *= rhs; return lhs; }

	movss	xmm0, DWORD PTR [ebx]
	mulss	xmm0, xmm1
	mulss	xmm1, DWORD PTR [ebx+4]
	movss	DWORD PTR [ebx], xmm0
	movss	DWORD PTR [ebx+4], xmm1
$LN2@GetNavInpu:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2528 :     if (fast_factor != 0.0f && IsNavInputDown(ImGuiNavInput_PadTweakFast))

	movss	xmm1, DWORD PTR _fast_factor$[ebp]
	ucomiss	xmm1, xmm2
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN11@GetNavInpu
	push	15					; 0000000fH
	call	?IsNavInputDown@@YA_NH@Z		; IsNavInputDown
	add	esp, 4
	test	al, al

; 2529 :         delta *= fast_factor;
; 2530 :     return delta;

	mov	eax, ebx
	je	SHORT $LN3@GetNavInpu
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 120  : static inline ImVec2& operator*=(ImVec2& lhs, const float rhs)                  { lhs.x *= rhs; lhs.y *= rhs; return lhs; }

	movss	xmm0, DWORD PTR [ebx]
	mulss	xmm0, xmm1
	pop	edi
	mulss	xmm1, DWORD PTR [ebx+4]
	pop	esi
	movss	DWORD PTR [ebx], xmm0
	movss	DWORD PTR [ebx+4], xmm1
	pop	ebx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2531 : }

	pop	ebp
	ret	0
$LN11@GetNavInpu:

; 2529 :         delta *= fast_factor;
; 2530 :     return delta;

	mov	eax, ebx
$LN3@GetNavInpu:
	pop	edi
	pop	esi
	pop	ebx

; 2531 : }

	pop	ebp
	ret	0
?GetNavInputAmount2d@@YA?AUImVec2@@HW4ImGuiNavReadMode@@MM@Z ENDP ; GetNavInputAmount2d
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
tv71 = -4						; size = 4
_n$ = 8							; size = 4
_mode$ = 12						; size = 4
?IsNavInputPressed@@YA_NHW4ImGuiNavReadMode@@@Z PROC	; IsNavInputPressed

; 2513 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 2514 :     return GetNavInputAmount(n, mode) > 0.0f;

	push	DWORD PTR _mode$[ebp]
	push	DWORD PTR _n$[ebp]
	call	?GetNavInputAmount@@YAMHW4ImGuiNavReadMode@@@Z ; GetNavInputAmount
	fstp	DWORD PTR tv71[ebp]
	movss	xmm0, DWORD PTR tv71[ebp]
	xor	eax, eax
	add	esp, 8
	comiss	xmm0, DWORD PTR __real@00000000
	seta	al

; 2515 :     // XXX: Nonsensical for released read mode -- what to do?
; 2516 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsNavInputPressed@@YA_NHW4ImGuiNavReadMode@@@Z ENDP	; IsNavInputPressed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_n$ = 8							; size = 4
?IsNavInputDown@@YA_NH@Z PROC				; IsNavInputDown

; 2507 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2508 :     return GImGui->IO.NavInputs[n] > 0.0f;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	ecx, DWORD PTR _n$[ebp]
	movss	xmm0, DWORD PTR [eax+ecx*4+780]
	xor	eax, eax
	comiss	xmm0, DWORD PTR __real@00000000
	seta	al

; 2509 : }

	pop	ebp
	ret	0
?IsNavInputDown@@YA_NH@Z ENDP				; IsNavInputDown
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_n$ = 8							; size = 4
tv275 = 12						; size = 4
tv263 = 12						; size = 4
tv252 = 12						; size = 4
tv164 = 12						; size = 4
tv75 = 12						; size = 4
_mode$ = 12						; size = 4
?GetNavInputAmount@@YAMHW4ImGuiNavReadMode@@@Z PROC	; GetNavInputAmount

; 2486 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2487 :     ImGuiContext& g = *GImGui;
; 2488 :     if (mode == ImGuiNavReadMode_Down)

	mov	eax, DWORD PTR _mode$[ebp]
	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	test	eax, eax
	jne	SHORT $LN2@GetNavInpu

; 2489 :         return g.IO.NavInputs[n];                   // Instant, read analog input (0.0f..1.0f, as provided by user)

	mov	eax, DWORD PTR _n$[ebp]
	fld	DWORD PTR [ecx+eax*4+780]

; 2503 : }

	pop	ebp
	ret	0
$LN2@GetNavInpu:

; 2490 :     const float t = g.IO.NavInputsDownDuration[n];  // Duration pressed

	mov	edx, DWORD PTR _n$[ebp]
	movss	xmm2, DWORD PTR [ecx+edx*4+5128]

; 2491 :     if (mode == ImGuiNavReadMode_Pressed)           // Return 1.0f when just pressed, no repeat, ignore analog input (we don't need it for Pressed logic)

	cmp	eax, 1
	jne	SHORT $LN3@GetNavInpu

; 2492 :         return (t == 0.0f) ? 1.0f : 0.0f;

	xorps	xmm0, xmm0
	mov	DWORD PTR tv75[ebp], 1065353216		; 3f800000H
	ucomiss	xmm2, xmm0
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN10@GetNavInpu
	mov	DWORD PTR tv75[ebp], 0
$LN10@GetNavInpu:
	fld	DWORD PTR tv75[ebp]

; 2503 : }

	pop	ebp
	ret	0
$LN3@GetNavInpu:

; 2493 :     if (mode == ImGuiNavReadMode_Repeat)

	cmp	eax, 3
	jne	SHORT $LN4@GetNavInpu

; 2494 :         return (float)ImGui::CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, g.IO.KeyRepeatDelay * 0.80f, g.IO.KeyRepeatRate * 0.80f);

	movss	xmm0, DWORD PTR [ecx+120]
	sub	esp, 16					; 00000010H
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp+12], xmm0
	movss	xmm0, DWORD PTR [ecx+116]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp+8], xmm0
	movaps	xmm0, xmm2
	subss	xmm0, DWORD PTR [ecx+12]
	movss	DWORD PTR [esp+4], xmm0
	movss	DWORD PTR [esp], xmm2
	call	?CalcTypematicPressedRepeatAmount@ImGui@@YAHMMMM@Z ; ImGui::CalcTypematicPressedRepeatAmount
	mov	DWORD PTR tv275[ebp], eax
	add	esp, 16					; 00000010H
	fild	DWORD PTR tv275[ebp]

; 2503 : }

	pop	ebp
	ret	0
$LN4@GetNavInpu:

; 2495 :     if (mode == ImGuiNavReadMode_RepeatSlow)

	cmp	eax, 4
	jne	SHORT $LN5@GetNavInpu

; 2496 :         return (float)ImGui::CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, g.IO.KeyRepeatDelay * 1.00f, g.IO.KeyRepeatRate * 2.00f);

	movss	xmm0, DWORD PTR [ecx+120]
	sub	esp, 16					; 00000010H
	addss	xmm0, xmm0
	movss	DWORD PTR [esp+12], xmm0
	movss	xmm0, DWORD PTR [ecx+116]
	movss	DWORD PTR [esp+8], xmm0
	movaps	xmm0, xmm2
	subss	xmm0, DWORD PTR [ecx+12]
	movss	DWORD PTR [esp+4], xmm0
	movss	DWORD PTR [esp], xmm2
	call	?CalcTypematicPressedRepeatAmount@ImGui@@YAHMMMM@Z ; ImGui::CalcTypematicPressedRepeatAmount
	mov	DWORD PTR tv263[ebp], eax
	add	esp, 16					; 00000010H
	fild	DWORD PTR tv263[ebp]

; 2503 : }

	pop	ebp
	ret	0
$LN5@GetNavInpu:

; 2497 :     if (mode == ImGuiNavReadMode_RepeatFast)

	cmp	eax, 5
	jne	SHORT $LN6@GetNavInpu

; 2498 :         return (float)ImGui::CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, g.IO.KeyRepeatDelay * 0.80f, g.IO.KeyRepeatRate * 0.30f);

	movss	xmm0, DWORD PTR [ecx+120]
	sub	esp, 16					; 00000010H
	mulss	xmm0, DWORD PTR __real@3e99999a
	movss	DWORD PTR [esp+12], xmm0
	movss	xmm0, DWORD PTR [ecx+116]
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	movss	DWORD PTR [esp+8], xmm0
	movaps	xmm0, xmm2
	subss	xmm0, DWORD PTR [ecx+12]
	movss	DWORD PTR [esp+4], xmm0
	movss	DWORD PTR [esp], xmm2
	call	?CalcTypematicPressedRepeatAmount@ImGui@@YAHMMMM@Z ; ImGui::CalcTypematicPressedRepeatAmount
	mov	DWORD PTR tv252[ebp], eax
	add	esp, 16					; 00000010H
	fild	DWORD PTR tv252[ebp]

; 2503 : }

	pop	ebp
	ret	0
$LN6@GetNavInpu:

; 2499 :     const float tp = g.IO.NavInputsDownDurationPrev[n];

	movss	xmm0, DWORD PTR [ecx+edx*4+5192]

; 2500 :     if (mode == ImGuiNavReadMode_Released)

	cmp	eax, 2
	jne	SHORT $LN7@GetNavInpu

; 2501 :         return (tp > t && t == 0.0f) ? tp : std::numeric_limits <float>::max ();

	comiss	xmm0, xmm2
	jbe	SHORT $LN11@GetNavInpu
	ucomiss	xmm2, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN11@GetNavInpu
	movss	DWORD PTR tv164[ebp], xmm0
	fld	DWORD PTR tv164[ebp]

; 2503 : }

	pop	ebp
	ret	0
$LN11@GetNavInpu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits

; 1089 : 		return (_FLT_MAX);

	mov	DWORD PTR tv164[ebp], 2139095039	; 7f7fffffH
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2501 :         return (tp > t && t == 0.0f) ? tp : std::numeric_limits <float>::max ();

	fld	DWORD PTR tv164[ebp]

; 2503 : }

	pop	ebp
	ret	0
$LN7@GetNavInpu:

; 2502 :     return 0.0f;

	fldz

; 2503 : }

	pop	ebp
	ret	0
?GetNavInputAmount@@YAMHW4ImGuiNavReadMode@@@Z ENDP	; GetNavInputAmount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_i_start$ = 8						; size = 4
_i_stop$ = 12						; size = 4
_dir$ = 16						; size = 4
?FindWindowNavigable@@YAPAUImGuiWindow@@HHH@Z PROC	; FindWindowNavigable

; 2463 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2464 :     ImGuiContext& g = *GImGui;
; 2465 :     for (int i = i_start; i >= 0 && i < g.Windows.Size && i != i_stop; i += dir)

	mov	ecx, DWORD PTR _i_start$[ebp]
	mov	edx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	ebx
	push	esi
	push	edi
	test	ecx, ecx
	js	SHORT $LN14@FindWindow
	mov	esi, DWORD PTR [edx+6204]

; 2468 :         if (window->Active && window == window->RootNonPopupWindow && (!(window->Flags & ImGuiWindowFlags_NoNavFocus) || window == g.NavWindow))

	mov	edi, DWORD PTR _dir$[ebp]
	mov	ebx, DWORD PTR _i_stop$[ebp]
$LL4@FindWindow:

; 2464 :     ImGuiContext& g = *GImGui;
; 2465 :     for (int i = i_start; i >= 0 && i < g.Windows.Size && i != i_stop; i += dir)

	cmp	ecx, esi
	jge	SHORT $LN14@FindWindow
	cmp	ecx, ebx
	je	SHORT $LN14@FindWindow

; 2466 :     {
; 2467 :         ImGuiWindow* window = g.Windows[i];

	mov	eax, DWORD PTR [edx+6212]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2468 :         if (window->Active && window == window->RootNonPopupWindow && (!(window->Flags & ImGuiWindowFlags_NoNavFocus) || window == g.NavWindow))

	cmp	BYTE PTR [eax+132], 0
	je	SHORT $LN2@FindWindow
	cmp	eax, DWORD PTR [eax+636]
	jne	SHORT $LN2@FindWindow
	test	DWORD PTR [eax+8], 131072		; 00020000H
	je	SHORT $LN1@FindWindow
	cmp	eax, DWORD PTR [edx+6380]
	je	SHORT $LN1@FindWindow
$LN2@FindWindow:

; 2464 :     ImGuiContext& g = *GImGui;
; 2465 :     for (int i = i_start; i >= 0 && i < g.Windows.Size && i != i_stop; i += dir)

	add	ecx, edi
	jns	SHORT $LL4@FindWindow
$LN14@FindWindow:

; 2469 :             return window;
; 2470 :     }
; 2471 :     return NULL;

	xor	eax, eax
$LN1@FindWindow:
	pop	edi
	pop	esi
	pop	ebx

; 2472 : }

	pop	ebp
	ret	0
?FindWindowNavigable@@YAPAUImGuiWindow@@HHH@Z ENDP	; FindWindowNavigable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_window$ = 8						; size = 4
?FindWindowIndex@@YAHPAUImGuiWindow@@@Z PROC		; FindWindowIndex

; 2454 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2455 :     ImGuiContext& g = *GImGui;

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 2456 :     for (int i = g.Windows.Size-1; i >= 0; i--)

	mov	eax, DWORD PTR [ecx+6204]
	sub	eax, 1
	js	SHORT $LN3@FindWindow
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	mov	ecx, DWORD PTR [ecx+6212]
	mov	edx, DWORD PTR _window$[ebp]
	lea	ecx, DWORD PTR [ecx+eax*4]
$LL4@FindWindow:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2457 :         if (g.Windows[i] == window)

	cmp	DWORD PTR [ecx], edx
	je	SHORT $LN1@FindWindow

; 2456 :     for (int i = g.Windows.Size-1; i >= 0; i--)

	sub	ecx, 4
	sub	eax, 1
	jns	SHORT $LL4@FindWindow
$LN3@FindWindow:

; 2458 :             return i;
; 2459 :     return -1;

	or	eax, -1
$LN1@FindWindow:

; 2460 : }

	pop	ebp
	ret	0
?FindWindowIndex@@YAHPAUImGuiWindow@@@Z ENDP		; FindWindowIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_r$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
?NavCalcPreferredMousePos@@YA?AUImVec2@@XZ PROC		; NavCalcPreferredMousePos

; 2444 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2445 :     ImGuiContext& g = *GImGui;

	mov	edx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	sub	esp, 16					; 00000010H

; 2446 :     if (!g.NavWindow)

	mov	eax, DWORD PTR [edx+6380]
	test	eax, eax
	jne	SHORT $LN2@NavCalcPre

; 2447 :         return g.IO.MousePos;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [edx+208]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+212]
	mov	DWORD PTR [eax+4], ecx

; 2451 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@NavCalcPre:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 246  :     float       GetWidth() const                { return Max.x-Min.x; }

	movss	xmm2, DWORD PTR [edx+6408]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2448 :     ImVec2 p = g.NavWindow->Pos + ImVec2(g.NavRefRectRel.Min.x + ImMin(g.Style.FramePadding.x*4, g.NavRefRectRel.GetWidth()), g.NavRefRectRel.Max.y - ImMin(g.Style.FramePadding.y, g.NavRefRectRel.GetHeight()));

	movss	xmm0, DWORD PTR [edx+5356]
	mulss	xmm0, DWORD PTR __real@40800000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 246  :     float       GetWidth() const                { return Max.x-Min.x; }

	subss	xmm2, DWORD PTR [edx+6400]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2448 :     ImVec2 p = g.NavWindow->Pos + ImVec2(g.NavRefRectRel.Min.x + ImMin(g.Style.FramePadding.x*4, g.NavRefRectRel.GetWidth()), g.NavRefRectRel.Max.y - ImMin(g.Style.FramePadding.y, g.NavRefRectRel.GetHeight()));

	movss	xmm1, DWORD PTR [edx+6412]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm3, DWORD PTR [eax+24]
	movss	xmm4, DWORD PTR [eax+28]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2449 :     ImRect r = GetVisibleRect();

	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	minss	xmm2, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 247  :     float       GetHeight() const               { return Max.y-Min.y; }

	movss	xmm0, DWORD PTR [edx+6412]
	subss	xmm0, DWORD PTR [edx+6404]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2448 :     ImVec2 p = g.NavWindow->Pos + ImVec2(g.NavRefRectRel.Min.x + ImMin(g.Style.FramePadding.x*4, g.NavRefRectRel.GetWidth()), g.NavRefRectRel.Max.y - ImMin(g.Style.FramePadding.y, g.NavRefRectRel.GetHeight()));

	addss	xmm2, DWORD PTR [edx+6400]
	minss	xmm0, DWORD PTR [edx+5360]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm3, xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2448 :     ImVec2 p = g.NavWindow->Pos + ImVec2(g.NavRefRectRel.Min.x + ImMin(g.Style.FramePadding.x*4, g.NavRefRectRel.GetWidth()), g.NavRefRectRel.Max.y - ImMin(g.Style.FramePadding.y, g.NavRefRectRel.GetHeight()));

	subss	xmm1, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm4, xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2449 :     ImRect r = GetVisibleRect();

	call	?GetVisibleRect@@YA?AUImRect@@XZ	; GetVisibleRect
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	movss	xmm1, DWORD PTR _r$[ebp+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2449 :     ImRect r = GetVisibleRect();

	add	esp, 4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm1, xmm4
	ja	SHORT $LN29@NavCalcPre
	movss	xmm1, DWORD PTR _r$[ebp+12]
	minss	xmm1, xmm4
$LN29@NavCalcPre:
	movss	xmm0, DWORD PTR _r$[ebp]
	comiss	xmm0, xmm3
	ja	SHORT $LN35@NavCalcPre
	movss	xmm0, DWORD PTR _r$[ebp+8]
	minss	xmm0, xmm3
$LN35@NavCalcPre:

; 141  : static inline ImVec2 ImFloor(ImVec2 v)                                          { return ImVec2((float)(int)v.x, (float)(int)v.y); }

	cvttss2si eax, xmm0
	cvttss2si ecx, xmm1
	movd	xmm0, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 141  : static inline ImVec2 ImFloor(ImVec2 v)                                          { return ImVec2((float)(int)v.x, (float)(int)v.y); }

	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax], xmm0
	movd	xmm0, ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 141  : static inline ImVec2 ImFloor(ImVec2 v)                                          { return ImVec2((float)(int)v.x, (float)(int)v.y); }

	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2451 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?NavCalcPreferredMousePos@@YA?AUImVec2@@XZ ENDP		; NavCalcPreferredMousePos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_window$ = 8						; size = 4
_force_reinit$ = 12					; size = 1
?NavInitWindow@@YAXPAUImGuiWindow@@_N@Z PROC		; NavInitWindow

; 2426 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR _window$[ebp]

; 2427 :     ImGuiContext& g = *GImGui;

	mov	edx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [ecx+8]
	and	eax, 37748736				; 02400000H
	cmp	eax, 4194304				; 00400000H

; 2428 :     IM_ASSERT(window == g.NavWindow);
; 2429 :     if (!(window->Flags & ImGuiWindowFlags_ChildWindow) || (window->Flags & ImGuiWindowFlags_Popup) || (window->NavLastId == 0) || force_reinit)

	jne	SHORT $LN4@NavInitWin
	mov	eax, DWORD PTR [ecx+148]
	test	eax, eax
	je	SHORT $LN4@NavInitWin
	cmp	BYTE PTR _force_reinit$[ebp], 0
	jne	SHORT $LN4@NavInitWin

; 2436 :     }
; 2437 :     else
; 2438 :     {
; 2439 :         g.NavId = window->NavLastId;

	mov	DWORD PTR [edx+6384], eax

; 2440 :     }
; 2441 : }

	pop	ebp
	ret	0
$LN4@NavInitWin:

; 2430 :     {
; 2431 :         SetNavId(0);

	push	0
	call	?SetNavId@@YAXI@Z			; SetNavId
	movaps	xmm0, XMMWORD PTR __xmm@ff7fffffff7fffff7f7fffff7f7fffff
	add	esp, 4

; 2432 :         g.NavInitDefaultRequest = true;

	mov	BYTE PTR [edx+6456], 1

; 2433 :         g.NavInitDefaultResultId = 0;

	mov	DWORD PTR [edx+6460], 0

; 2434 :         g.NavInitDefaultResultExplicit = false;

	mov	BYTE PTR [edx+6480], 0

; 2435 :         g.NavInitDefaultResultRectRel = ImRect();

	movups	XMMWORD PTR [edx+6464], xmm0

; 2440 :     }
; 2441 : }

	pop	ebp
	ret	0
?NavInitWindow@@YAXPAUImGuiWindow@@_N@Z ENDP		; NavInitWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_id$ = 8						; size = 4
_rect_rel$ = 12						; size = 4
?SetNavIdAndMoveMouse@@YAXIABUImRect@@@Z PROC		; SetNavIdAndMoveMouse

; 2415 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2416 :     ImGuiContext& g = *GImGui;
; 2417 :     SetNavId(id);

	push	DWORD PTR _id$[ebp]
	mov	edx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	call	?SetNavId@@YAXI@Z			; SetNavId

; 2418 :     g.NavRefRectRel = rect_rel;

	mov	eax, DWORD PTR _rect_rel$[ebp]
	add	esp, 4
	movups	xmm0, XMMWORD PTR [eax]

; 2419 :     g.NavMousePosDirty = true;

	mov	WORD PTR [edx+6453], 1

; 2420 :     g.NavDisableHighlight = false;
; 2421 :     g.NavDisableMouseHover = true;

	mov	BYTE PTR [edx+6455], 1
	movups	XMMWORD PTR [edx+6400], xmm0

; 2422 : }

	pop	ebp
	ret	0
?SetNavIdAndMoveMouse@@YAXIABUImRect@@@Z ENDP		; SetNavIdAndMoveMouse
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_id$ = 8						; size = 4
?SetNavId@@YAXI@Z PROC					; SetNavId

; 2406 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2407 :     ImGuiContext& g = *GImGui;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 2408 :     IM_ASSERT(g.NavWindow);
; 2409 :     g.NavId = id;

	mov	ecx, DWORD PTR _id$[ebp]

; 2410 :     if (g.NavLayer == 0 && g.NavWindow)

	cmp	DWORD PTR [eax+6444], 0
	mov	DWORD PTR [eax+6384], ecx
	jne	SHORT $LN2@SetNavId
	mov	eax, DWORD PTR [eax+6380]
	test	eax, eax
	je	SHORT $LN2@SetNavId

; 2411 :         g.NavWindow->NavLastId = g.NavId;

	mov	DWORD PTR [eax+148], ecx
$LN2@SetNavId:

; 2412 : }

	pop	ebp
	ret	0
?SetNavId@@YAXI@Z ENDP					; SetNavId
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_day$1$ = -20						; size = 4
_a$1$ = -20						; size = 4
_dist_box$1$ = -16					; size = 4
_dist_center$1$ = -12					; size = 4
tv270 = -12						; size = 4
_dist_axial$1$ = -8					; size = 4
_dbx$ = -8						; size = 4
tv440 = -4						; size = 4
_dby$ = -4						; size = 4
_cand$ = 8						; size = 16
?NavScoreItem@@YA_NUImRect@@@Z PROC			; NavScoreItem

; 2027 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2028 :     ImGuiContext& g = *GImGui;

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	sub	esp, 20					; 00000014H

; 2029 :     ImGuiWindow* window = g.NavWindow;

	mov	edx, DWORD PTR [ecx+6380]

; 2030 :     if (g.NavLayer != window->DC.NavLayerCurrent)

	mov	eax, DWORD PTR [ecx+6444]
	cmp	eax, DWORD PTR [edx+272]
	je	SHORT $LN2@NavScoreIt

; 2031 :         return false;

	xor	al, al

; 2133 : 
; 2134 :     return new_best;
; 2135 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@NavScoreIt:

; 2032 : 
; 2033 :     const ImRect& curr = g.NavScoringRectScreen; // Current modified source rect (NB: we've applied Max.x = Min.x in NavUpdate() to inhibit the effect of having lots of items with varied width)
; 2034 : 
; 2035 :     // We perform scoring on items bounding box clipped by their parent window on the other axis (clipping on our movement axis would give us equal scores for all clipped items)
; 2036 :     if (g.NavMoveDir == ImGuiNavDir_Left || g.NavMoveDir == ImGuiNavDir_Right)

	mov	eax, DWORD PTR [ecx+6484]
	test	eax, eax
	je	SHORT $LN5@NavScoreIt
	cmp	eax, 1
	je	SHORT $LN5@NavScoreIt

; 2043 :         cand.Min.x = ImClamp(cand.Min.x, window->ClipRect.Min.x, window->ClipRect.Max.x);

	movss	xmm2, DWORD PTR [edx+472]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	movss	xmm0, DWORD PTR _cand$[ebp]
	comiss	xmm2, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2043 :         cand.Min.x = ImClamp(cand.Min.x, window->ClipRect.Min.x, window->ClipRect.Max.x);

	movss	xmm1, DWORD PTR [edx+480]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	jbe	SHORT $LN48@NavScoreIt
	movaps	xmm0, xmm2
	movss	DWORD PTR _cand$[ebp], xmm0
	jmp	SHORT $LN46@NavScoreIt
$LN48@NavScoreIt:
	comiss	xmm0, xmm1
	jbe	SHORT $LN46@NavScoreIt
	movss	DWORD PTR _cand$[ebp], xmm1
$LN46@NavScoreIt:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2044 :         cand.Max.x = ImClamp(cand.Max.x, window->ClipRect.Min.x, window->ClipRect.Max.x);

	movss	xmm1, DWORD PTR [edx+472]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	movss	xmm4, DWORD PTR _cand$[ebp+8]
	comiss	xmm1, xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2044 :         cand.Max.x = ImClamp(cand.Max.x, window->ClipRect.Min.x, window->ClipRect.Max.x);

	movss	xmm0, DWORD PTR [edx+480]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	movss	xmm5, DWORD PTR _cand$[ebp+12]
	jbe	SHORT $LN54@NavScoreIt
	movaps	xmm4, xmm1
	movss	DWORD PTR _cand$[ebp+8], xmm4
	jmp	SHORT $LN40@NavScoreIt
$LN54@NavScoreIt:
	comiss	xmm4, xmm0
	jbe	SHORT $LN40@NavScoreIt
	movaps	xmm4, xmm0
	movss	DWORD PTR _cand$[ebp+8], xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2044 :         cand.Max.x = ImClamp(cand.Max.x, window->ClipRect.Min.x, window->ClipRect.Max.x);

	jmp	SHORT $LN40@NavScoreIt
$LN5@NavScoreIt:

; 2038 :         cand.Min.y = ImClamp(cand.Min.y, window->ClipRect.Min.y, window->ClipRect.Max.y);

	movss	xmm2, DWORD PTR [edx+476]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	movss	xmm0, DWORD PTR _cand$[ebp+4]
	comiss	xmm2, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2038 :         cand.Min.y = ImClamp(cand.Min.y, window->ClipRect.Min.y, window->ClipRect.Max.y);

	movss	xmm1, DWORD PTR [edx+484]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	jbe	SHORT $LN36@NavScoreIt
	movaps	xmm0, xmm2
	movss	DWORD PTR _cand$[ebp+4], xmm0
	jmp	SHORT $LN34@NavScoreIt
$LN36@NavScoreIt:
	comiss	xmm0, xmm1
	jbe	SHORT $LN34@NavScoreIt
	movss	DWORD PTR _cand$[ebp+4], xmm1
$LN34@NavScoreIt:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2039 :         cand.Max.y = ImClamp(cand.Max.y, window->ClipRect.Min.y, window->ClipRect.Max.y);

	movss	xmm1, DWORD PTR [edx+476]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	movss	xmm5, DWORD PTR _cand$[ebp+12]
	comiss	xmm1, xmm5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2039 :         cand.Max.y = ImClamp(cand.Max.y, window->ClipRect.Min.y, window->ClipRect.Max.y);

	movss	xmm0, DWORD PTR [edx+484]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	jbe	SHORT $LN42@NavScoreIt
	movaps	xmm5, xmm1
	jmp	SHORT $LN82@NavScoreIt
$LN42@NavScoreIt:
	comiss	xmm5, xmm0
	jbe	SHORT $LN72@NavScoreIt
	movaps	xmm5, xmm0
$LN82@NavScoreIt:
	movss	DWORD PTR _cand$[ebp+12], xmm5
$LN72@NavScoreIt:
	movss	xmm4, DWORD PTR _cand$[ebp+8]
$LN40@NavScoreIt:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2049 :     float dbx = NavScoreItemDistInterval(cand.Min.x, cand.Max.x, curr.Min.x, curr.Max.x);

	movss	xmm1, DWORD PTR [ecx+6424]
	sub	esp, 16					; 00000010H
	movss	xmm0, DWORD PTR [ecx+6416]
	movss	DWORD PTR tv270[ebp], xmm1
	movss	DWORD PTR [esp+12], xmm1
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _cand$[ebp]
	movss	DWORD PTR [esp+4], xmm4
	movss	DWORD PTR [esp], xmm0
	call	?NavScoreItemDistInterval@@YAMMMMM@Z	; NavScoreItemDistInterval

; 2050 :     float dby = NavScoreItemDistInterval(ImLerp(cand.Min.y, cand.Max.y, 0.2f), ImLerp(cand.Min.y, cand.Max.y, 0.8f), ImLerp(curr.Min.y, curr.Max.y, 0.2f), ImLerp(curr.Min.y, curr.Max.y, 0.8f)); // Clamp down on Y to keep using box-distance for vertically touching items

	movss	xmm6, DWORD PTR [ecx+6420]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 135  : static inline float  ImLerp(float a, float b, float t)                          { return a + (b - a) * t; }

	movaps	xmm3, xmm5
	movss	xmm1, DWORD PTR [ecx+6428]
	movaps	xmm0, xmm1
	movss	xmm2, DWORD PTR _cand$[ebp+4]
	subss	xmm0, xmm6
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2050 :     float dby = NavScoreItemDistInterval(ImLerp(cand.Min.y, cand.Max.y, 0.2f), ImLerp(cand.Min.y, cand.Max.y, 0.8f), ImLerp(curr.Min.y, curr.Max.y, 0.2f), ImLerp(curr.Min.y, curr.Max.y, 0.8f)); // Clamp down on Y to keep using box-distance for vertically touching items

	movss	DWORD PTR _a$1$[ebp], xmm6
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 135  : static inline float  ImLerp(float a, float b, float t)                          { return a + (b - a) * t; }

	subss	xmm3, DWORD PTR _cand$[ebp+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2049 :     float dbx = NavScoreItemDistInterval(cand.Min.x, cand.Max.x, curr.Min.x, curr.Max.x);

	fstp	DWORD PTR _dbx$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 135  : static inline float  ImLerp(float a, float b, float t)                          { return a + (b - a) * t; }

	mulss	xmm0, DWORD PTR __real@3f4ccccd
	addss	xmm0, xmm6
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2050 :     float dby = NavScoreItemDistInterval(ImLerp(cand.Min.y, cand.Max.y, 0.2f), ImLerp(cand.Min.y, cand.Max.y, 0.8f), ImLerp(curr.Min.y, curr.Max.y, 0.2f), ImLerp(curr.Min.y, curr.Max.y, 0.8f)); // Clamp down on Y to keep using box-distance for vertically touching items

	movss	DWORD PTR [esp+12], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 135  : static inline float  ImLerp(float a, float b, float t)                          { return a + (b - a) * t; }

	movaps	xmm0, xmm1
	subss	xmm0, xmm6
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	addss	xmm0, xmm6
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2050 :     float dby = NavScoreItemDistInterval(ImLerp(cand.Min.y, cand.Max.y, 0.2f), ImLerp(cand.Min.y, cand.Max.y, 0.8f), ImLerp(curr.Min.y, curr.Max.y, 0.2f), ImLerp(curr.Min.y, curr.Max.y, 0.8f)); // Clamp down on Y to keep using box-distance for vertically touching items

	movss	DWORD PTR [esp+8], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 135  : static inline float  ImLerp(float a, float b, float t)                          { return a + (b - a) * t; }

	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR __real@3f4ccccd
	mulss	xmm3, DWORD PTR __real@3e4ccccd
	addss	xmm0, xmm2
	addss	xmm3, xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2050 :     float dby = NavScoreItemDistInterval(ImLerp(cand.Min.y, cand.Max.y, 0.2f), ImLerp(cand.Min.y, cand.Max.y, 0.8f), ImLerp(curr.Min.y, curr.Max.y, 0.2f), ImLerp(curr.Min.y, curr.Max.y, 0.8f)); // Clamp down on Y to keep using box-distance for vertically touching items

	movss	DWORD PTR [esp+4], xmm0
	movss	DWORD PTR [esp], xmm3
	call	?NavScoreItemDistInterval@@YAMMMMM@Z	; NavScoreItemDistInterval

; 2051 :     if (dby && dbx)

	movss	xmm6, DWORD PTR _dbx$[ebp]
	add	esp, 16					; 00000010H
	fstp	DWORD PTR _dby$[ebp]
	movss	xmm0, DWORD PTR _dby$[ebp]
	xorps	xmm7, xmm7
	ucomiss	xmm0, xmm7
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@NavScoreIt
	ucomiss	xmm6, xmm7
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@NavScoreIt

; 2052 :        dbx = (dbx/1000.0f) + ((dbx > 0.0f) ? +1.0f : -1.0f);

	comiss	xmm6, xmm7
	jbe	SHORT $LN28@NavScoreIt
	movss	xmm1, DWORD PTR __real@3f800000
	jmp	SHORT $LN29@NavScoreIt
$LN28@NavScoreIt:
	movss	xmm1, DWORD PTR __real@bf800000
$LN29@NavScoreIt:
	mulss	xmm6, DWORD PTR __real@3a83126f
	addss	xmm6, xmm1
$LN6@NavScoreIt:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 658  :         return (float)fabs(_X);

	movss	xmm1, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2057 :     float dcy = (cand.Min.y + cand.Max.y) - (curr.Min.y + curr.Max.y);

	addss	xmm5, xmm2
	addss	xmm4, DWORD PTR _cand$[ebp]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 658  :         return (float)fabs(_X);

	andps	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2062 :     float dax = 0.0f, day = 0.0f, dist_axial = 0.0f;

	movss	DWORD PTR _dist_axial$1$[ebp], xmm7
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 658  :         return (float)fabs(_X);

	movaps	xmm3, xmm6
	andps	xmm3, xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2053 :     float dist_box = fabsf(dbx) + fabsf(dby);

	addss	xmm3, xmm0

; 2054 : 
; 2055 :     // Compute distance between centers (this is off by a factor of 2, but we only compare center distances with each other so it doesn't matter)
; 2056 :     float dcx = (cand.Min.x + cand.Max.x) - (curr.Min.x + curr.Max.x);

	movss	xmm0, DWORD PTR [ecx+6416]
	addss	xmm0, DWORD PTR tv270[ebp]

; 2063 :     if (dbx || dby) 

	ucomiss	xmm6, xmm7
	subss	xmm4, xmm0
	movss	DWORD PTR _dist_box$1$[ebp], xmm3
	movss	xmm0, DWORD PTR [ecx+6428]
	addss	xmm0, DWORD PTR _a$1$[ebp]
	lahf
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 658  :         return (float)fabs(_X);

	movaps	xmm2, xmm4
	andps	xmm2, xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2057 :     float dcy = (cand.Min.y + cand.Max.y) - (curr.Min.y + curr.Max.y);

	subss	xmm5, xmm0
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 658  :         return (float)fabs(_X);

	movaps	xmm0, xmm5
	andps	xmm0, xmm1
	xorps	xmm1, xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2058 :     float dist_center = fabsf(dcx) + fabsf(dcy); // L1 metric (need this for our connectedness guarantee)

	addss	xmm2, xmm0

; 2063 :     if (dbx || dby) 

	movss	xmm0, DWORD PTR _dby$[ebp]
	movss	DWORD PTR _dist_center$1$[ebp], xmm2
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@NavScoreIt
	ucomiss	xmm0, xmm7
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@NavScoreIt

; 2070 :     } 
; 2071 :     else if (dcx || dcy) 

	ucomiss	xmm4, xmm7
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN12@NavScoreIt
	ucomiss	xmm5, xmm7
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN12@NavScoreIt

; 2080 :     {
; 2081 :         // Degenerate case: two overlapping buttons with same center, break ties using order
; 2082 :         quadrant = (window->DC.LastItemId < g.NavId) ? ImGuiNavDir_Left : ImGuiNavDir_Right;

	mov	eax, DWORD PTR [edx+248]
	xorps	xmm5, xmm5
	cmp	eax, DWORD PTR [ecx+6384]
	sbb	eax, eax
	inc	eax
	jmp	SHORT $LN11@NavScoreIt
$LN12@NavScoreIt:

; 2072 :     { 
; 2073 :         // For overlapping boxes with different centers, use distance between centers
; 2074 :         dax = dcx;
; 2075 :         day = dcy;
; 2076 :         dist_axial = dist_center;
; 2077 :         quadrant = NavScoreItemGetQuadrant(dcx, dcy);

	sub	esp, 8
	movss	DWORD PTR _dist_axial$1$[ebp], xmm2
	movaps	xmm0, xmm5
	movaps	xmm1, xmm4
	movss	DWORD PTR _day$1$[ebp], xmm0
	movss	DWORD PTR [esp+4], xmm5
	movss	DWORD PTR [esp], xmm4
	call	?NavScoreItemGetQuadrant@@YA?AW4ImGuiNavDir@@MM@Z ; NavScoreItemGetQuadrant

; 2078 :     } 
; 2079 :     else

	jmp	SHORT $LN80@NavScoreIt
$LN9@NavScoreIt:

; 2064 :     { 
; 2065 :         // For non-overlapping boxes, use distance between boxes
; 2066 :         dax = dbx;
; 2067 :         day = dby;
; 2068 :         dist_axial = dist_box;
; 2069 :         quadrant = NavScoreItemGetQuadrant(dbx, dby);

	sub	esp, 8
	movss	DWORD PTR _dist_axial$1$[ebp], xmm3
	movaps	xmm1, xmm6
	movaps	xmm5, xmm0
	movss	DWORD PTR [esp+4], xmm0
	movss	DWORD PTR [esp], xmm6
	call	?NavScoreItemGetQuadrant@@YA?AW4ImGuiNavDir@@MM@Z ; NavScoreItemGetQuadrant
$LN80@NavScoreIt:
	movss	xmm0, DWORD PTR _dby$[ebp]
	add	esp, 8
	movss	xmm3, DWORD PTR _dist_box$1$[ebp]
	movss	xmm2, DWORD PTR _dist_center$1$[ebp]
$LN11@NavScoreIt:

; 2083 :     }
; 2084 : 
; 2085 : #if 0 // [DEBUG]
; 2086 :     if (ImGui::IsMouseHoveringRect(cand.Min, cand.Max))
; 2087 :     {
; 2088 :         char buf[128];
; 2089 :         ImFormatString(buf, IM_ARRAYSIZE(buf), "db (%.0f,%.0f->%.5f) dc (%.0f,%.0f->%.5f) da (%.0f,%.0f->%.5f) quad %c", dbx, dby, dist_box, dcx, dcy, dist_center, dax, day, dist_axial, "WENS"[quadrant]);
; 2090 :         g.OverlayDrawList.AddRect(cand.Min, cand.Max, IM_COL32(255,255,0,200));
; 2091 :         g.OverlayDrawList.AddRectFilled(cand.Max-ImVec2(4,4), cand.Max+ImGui::CalcTextSize(buf)+ImVec2(4,4), IM_COL32(40,0,0,150));
; 2092 :         g.OverlayDrawList.AddText(cand.Max, ~0U, buf);
; 2093 :     }
; 2094 :  #endif
; 2095 : 
; 2096 :     // Is it in the quadrant we're interesting in moving to?
; 2097 :     bool new_best = false;
; 2098 :     if (quadrant == g.NavMoveDir) 

	mov	edx, DWORD PTR [ecx+6484]
	mov	BYTE PTR tv440[ebp], 0
	cmp	eax, edx
	jne	SHORT $LN19@NavScoreIt

; 2099 :     {
; 2100 :         // Does it beat the current best candidate?
; 2101 :         if (dist_box < g.NavMoveResultDistBox) 

	movss	xmm4, DWORD PTR [ecx+6492]
	comiss	xmm4, xmm3
	jbe	SHORT $LN14@NavScoreIt

; 2102 :         {
; 2103 :             g.NavMoveResultDistBox = dist_box;

	movss	DWORD PTR [ecx+6492], xmm3

; 2104 :             g.NavMoveResultDistCenter = dist_center;
; 2105 :             return true;

	mov	al, 1
	movss	DWORD PTR [ecx+6496], xmm2

; 2133 : 
; 2134 :     return new_best;
; 2135 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@NavScoreIt:

; 2106 :         } 
; 2107 :         if (dist_box == g.NavMoveResultDistBox) 

	ucomiss	xmm3, xmm4
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN19@NavScoreIt

; 2108 :         {
; 2109 :             // Try using distance between center points to break ties
; 2110 :             if (dist_center < g.NavMoveResultDistCenter) 

	movss	xmm3, DWORD PTR [ecx+6496]
	comiss	xmm3, xmm2
	jbe	SHORT $LN16@NavScoreIt

; 2111 :             {
; 2112 :                 g.NavMoveResultDistCenter = dist_center;

	movss	DWORD PTR [ecx+6496], xmm2

; 2113 :                 new_best = true;

	mov	BYTE PTR tv440[ebp], 1
	jmp	SHORT $LN19@NavScoreIt
$LN16@NavScoreIt:

; 2114 :             } 
; 2115 :             else if (dist_center == g.NavMoveResultDistCenter) 

	ucomiss	xmm2, xmm3
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN19@NavScoreIt

; 2116 :             {
; 2117 :                 // Still tied! we need to be extra-careful to make sure everything gets linked properly. We consistently break ties by symbolically moving "later" buttons 
; 2118 :                 // (with higher index) to the right/downwards by an infinitesimal amount since we the current "best" button already (so it must have a lower index), 
; 2119 :                 // this is fairly easy. This rule ensures that all buttons with dx==dy==0 will end up being linked in order of appearance along the x axis.
; 2120 :                 if (((g.NavMoveDir == ImGuiNavDir_Up || g.NavMoveDir == ImGuiNavDir_Down) ? dby : dbx) < 0.0f) // moving bj to the right/down decreases distance

	cmp	edx, 2
	je	SHORT $LN30@NavScoreIt
	cmp	edx, 3
	jne	SHORT $LN31@NavScoreIt
$LN30@NavScoreIt:
	movaps	xmm6, xmm0
$LN31@NavScoreIt:
	mov	eax, DWORD PTR tv440[ebp]
	comiss	xmm7, xmm6
	push	esi
	mov	esi, 1
	movzx	eax, al
	cmova	eax, esi
	mov	DWORD PTR tv440[ebp], eax
	pop	esi
$LN19@NavScoreIt:

; 2121 :                     new_best = true;
; 2122 :             }
; 2123 :         }
; 2124 :     }
; 2125 : 
; 2126 :     // Axial check: if 'curr' has no link at all in some direction and 'cand' lies roughly in that direction, add a tentative link. This will only be kept if no "real" matches
; 2127 :     // are found, so it only augments the graph produced by the above method using extra links. (important, since it doesn't guarantee strong connectedness)
; 2128 :     // This is just to avoid buttons having no links in a particular direction when there's a suitable neighbor. you get good graphs without this too.
; 2129 :     if (g.NavMoveResultDistBox == FLT_MAX) 

	movss	xmm0, DWORD PTR [ecx+6492]
	ucomiss	xmm0, DWORD PTR __real@7f7fffff
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN79@NavScoreIt

; 2130 :         if (dist_axial < g.NavMoveResultDistAxial) // Check axial match

	movss	xmm0, DWORD PTR [ecx+6500]
	movss	xmm2, DWORD PTR _dist_axial$1$[ebp]
	comiss	xmm0, xmm2
	jbe	SHORT $LN79@NavScoreIt

; 2131 :             if ((g.NavMoveDir == ImGuiNavDir_Left && dax < 0.0f) || (g.NavMoveDir == ImGuiNavDir_Right && dax > 0.0f) || (g.NavMoveDir == ImGuiNavDir_Up && day < 0.0f) || (g.NavMoveDir == ImGuiNavDir_Down && day > 0.0f))

	test	edx, edx
	jne	SHORT $LN24@NavScoreIt
	comiss	xmm7, xmm1
	ja	SHORT $LN23@NavScoreIt
$LN24@NavScoreIt:
	cmp	edx, 1
	jne	SHORT $LN25@NavScoreIt
	comiss	xmm1, xmm7
	ja	SHORT $LN23@NavScoreIt
$LN25@NavScoreIt:
	cmp	edx, 2
	jne	SHORT $LN26@NavScoreIt
	comiss	xmm7, xmm5
	ja	SHORT $LN23@NavScoreIt
$LN26@NavScoreIt:
	cmp	edx, 3
	jne	SHORT $LN79@NavScoreIt
	comiss	xmm5, xmm7
	jbe	SHORT $LN79@NavScoreIt
$LN23@NavScoreIt:

; 2132 :                 g.NavMoveResultDistAxial = dist_axial, new_best = true;

	movss	DWORD PTR [ecx+6500], xmm2
	mov	al, 1

; 2133 : 
; 2134 :     return new_best;
; 2135 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN79@NavScoreIt:
	mov	eax, DWORD PTR tv440[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?NavScoreItem@@YA_NUImRect@@@Z ENDP			; NavScoreItem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_a0$ = 8						; size = 4
_a1$ = 12						; size = 4
_b0$ = 16						; size = 4
_b1$ = 20						; size = 4
?NavScoreItemDistInterval@@YAMMMMM@Z PROC		; NavScoreItemDistInterval

; 2018 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2019 :     if (a1 < b0) return a1 - b0;

	movss	xmm0, DWORD PTR _b0$[ebp]
	comiss	xmm0, DWORD PTR _a1$[ebp]
	jbe	SHORT $LN2@NavScoreIt
	fld	DWORD PTR _a1$[ebp]
	fsub	DWORD PTR _b0$[ebp]

; 2022 : }

	pop	ebp
	ret	0
$LN2@NavScoreIt:

; 2020 :     if (b1 < a0) return a0 - b1;

	movss	xmm0, DWORD PTR _a0$[ebp]
	comiss	xmm0, DWORD PTR _b1$[ebp]
	jbe	SHORT $LN3@NavScoreIt
	fld	DWORD PTR _a0$[ebp]
	fsub	DWORD PTR _b1$[ebp]

; 2022 : }

	pop	ebp
	ret	0
$LN3@NavScoreIt:

; 2021 :     return 0.0f;

	fldz

; 2022 : }

	pop	ebp
	ret	0
?NavScoreItemDistInterval@@YAMMMMM@Z ENDP		; NavScoreItemDistInterval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_dx$ = 8						; size = 4
_dy$ = 12						; size = 4
?NavScoreItemGetQuadrant@@YA?AW4ImGuiNavDir@@MM@Z PROC	; NavScoreItemGetQuadrant

; 2011 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 658  :         return (float)fabs(_X);

	movss	xmm3, DWORD PTR _dx$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2013 :         return (dx > 0.0f) ? ImGuiNavDir_Right : ImGuiNavDir_Left;

	xor	eax, eax
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 658  :         return (float)fabs(_X);

	movss	xmm4, DWORD PTR _dy$[ebp]
	movaps	xmm2, xmm3
	andps	xmm2, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
	movaps	xmm0, xmm4
	andps	xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2012 :     if (fabsf(dx) > fabsf(dy))

	comiss	xmm2, xmm0
	jbe	SHORT $LN2@NavScoreIt

; 2013 :         return (dx > 0.0f) ? ImGuiNavDir_Right : ImGuiNavDir_Left;

	comiss	xmm3, DWORD PTR __real@00000000
	seta	al

; 2015 : }

	pop	ebp
	ret	0
$LN2@NavScoreIt:

; 2014 :     return (dy > 0.0f) ? ImGuiNavDir_Down : ImGuiNavDir_Up;

	comiss	xmm4, DWORD PTR __real@00000000
	seta	al
	add	eax, 2

; 2015 : }

	pop	ebp
	ret	0
?NavScoreItemGetQuadrant@@YA?AW4ImGuiNavDir@@MM@Z ENDP	; NavScoreItemGetQuadrant
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_pos_y$ = 8						; size = 4
_line_height$ = 12					; size = 4
?SetCursorPosYAndSetupDummyPrevLine@@YAXMM@Z PROC	; SetCursorPosYAndSetupDummyPrevLine

; 1738 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1741 :     ImGui::SetCursorPosY(pos_y);

	movss	xmm0, DWORD PTR _pos_y$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?SetCursorPosY@ImGui@@YAXM@Z		; ImGui::SetCursorPosY
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1741 :     ImGui::SetCursorPosY(pos_y);

	add	esp, 4

; 1742 :     ImGuiWindow* window = ImGui::GetCurrentWindow();
; 1743 :     window->DC.CursorPosPrevLine.y = window->DC.CursorPos.y - line_height;      // Setting those fields so that SetScrollHere() can properly function after the end of our clipper usage.

	movss	xmm1, DWORD PTR _line_height$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	ecx, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1745 :     if (window->DC.ColumnsCount > 1)

	cmp	DWORD PTR [ecx+416], 1
	movss	xmm2, DWORD PTR [ecx+196]
	movaps	xmm0, xmm2
	subss	xmm0, xmm1
	movss	DWORD PTR [ecx+204], xmm0
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	subss	xmm1, DWORD PTR [eax+5372]
	movss	DWORD PTR [ecx+232], xmm1
	jle	SHORT $LN2@SetCursorP

; 1746 :         window->DC.ColumnsCellMinY = window->DC.CursorPos.y;                    // Setting this so that cell Y position are set properly

	movss	DWORD PTR [ecx+432], xmm2
$LN2@SetCursorP:

; 1747 : }

	pop	ebp
	ret	0
?SetCursorPosYAndSetupDummyPrevLine@@YAXMM@Z ENDP	; SetCursorPosYAndSetupDummyPrevLine
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_data$ = 8						; size = 4
_key$ = 12						; size = 4
?LowerBound@@YAPAUPair@ImGuiStorage@@AAV?$ImVector@UPair@ImGuiStorage@@@@I@Z PROC ; LowerBound

; 1423 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 916  :     inline iterator             begin()                         { return Data; }

	mov	ecx, DWORD PTR _data$[ebp]
	push	esi
	mov	esi, DWORD PTR [ecx+8]

; 918  :     inline iterator             end()                           { return Data + Size; }

	mov	ecx, DWORD PTR [ecx]
	shl	ecx, 3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1426 :     int count = (int)(last - first);

	sar	ecx, 3

; 1427 :     while (count > 0)

	test	ecx, ecx
	jle	SHORT $LN14@LowerBound
	push	edi
	mov	edi, DWORD PTR _key$[ebp]
	npad	4
$LL2@LowerBound:

; 1428 :     {
; 1429 :         int count2 = count / 2;

	mov	eax, ecx
	cdq
	sub	eax, edx
	mov	edx, eax
	sar	edx, 1

; 1430 :         ImVector<ImGuiStorage::Pair>::iterator mid = first + count2;
; 1431 :         if (mid->key < key)

	cmp	DWORD PTR [esi+edx*8], edi
	lea	eax, DWORD PTR [esi+edx*8]
	jae	SHORT $LN4@LowerBound

; 1432 :         {
; 1433 :             first = ++mid;

	lea	esi, DWORD PTR [eax+8]

; 1434 :             count -= count2 + 1;

	or	eax, -1
	sub	eax, edx
	add	ecx, eax

; 1435 :         }
; 1436 :         else

	jmp	SHORT $LN5@LowerBound
$LN4@LowerBound:

; 1437 :         {
; 1438 :             count = count2;

	mov	ecx, edx
$LN5@LowerBound:

; 1427 :     while (count > 0)

	test	ecx, ecx
	jg	SHORT $LL2@LowerBound
	pop	edi
$LN14@LowerBound:

; 1439 :         }
; 1440 :     }
; 1441 :     return first;

	mov	eax, esi
	pop	esi

; 1442 : }

	pop	ebp
	ret	0
?LowerBound@@YAPAUPair@ImGuiStorage@@AAV?$ImVector@UPair@ImGuiStorage@@@@I@Z ENDP ; LowerBound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_c$ = 8							; size = 4
?ImTextCountUtf8BytesFromChar@@YAHI@Z PROC		; ImTextCountUtf8BytesFromChar

; 1230 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1231 :     if (c < 0x80) return 1;

	mov	ecx, DWORD PTR _c$[ebp]
	cmp	ecx, 128				; 00000080H
	jae	SHORT $LN2@ImTextCoun
	mov	eax, 1

; 1235 :     return 3;
; 1236 : }

	pop	ebp
	ret	0
$LN2@ImTextCoun:

; 1232 :     if (c < 0x800) return 2;

	cmp	ecx, 2048				; 00000800H
	jae	SHORT $LN3@ImTextCoun
	mov	eax, 2

; 1235 :     return 3;
; 1236 : }

	pop	ebp
	ret	0
$LN3@ImTextCoun:

; 1233 :     if (c >= 0xdc00 && c < 0xe000) return 0;

	lea	eax, DWORD PTR [ecx-56320]
	cmp	eax, 1023				; 000003ffH
	ja	SHORT $LN4@ImTextCoun
	xor	eax, eax

; 1235 :     return 3;
; 1236 : }

	pop	ebp
	ret	0
$LN4@ImTextCoun:

; 1234 :     if (c >= 0xd800 && c < 0xdc00) return 4;

	lea	eax, DWORD PTR [ecx-55296]
	mov	ecx, 1023				; 000003ffH
	cmp	ecx, eax
	sbb	eax, eax
	add	eax, 4

; 1235 :     return 3;
; 1236 : }

	pop	ebp
	ret	0
?ImTextCountUtf8BytesFromChar@@YAHI@Z ENDP		; ImTextCountUtf8BytesFromChar
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_buf_size$ = 12						; size = 4
_c$ = 16						; size = 4
?ImTextCharToUtf8@@YAHPADHI@Z PROC			; ImTextCharToUtf8

; 1193 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1194 :     if (c < 0x80)

	mov	edx, DWORD PTR _c$[ebp]
	cmp	edx, 128				; 00000080H
	jae	SHORT $LN2@ImTextChar

; 1195 :     {
; 1196 :         buf[0] = (char)c;

	mov	eax, DWORD PTR _buf$[ebp]
	mov	BYTE PTR [eax], dl

; 1197 :         return 1;

	mov	eax, 1

; 1226 :     }
; 1227 : }

	pop	ebp
	ret	0
$LN2@ImTextChar:

; 1198 :     }
; 1199 :     if (c < 0x800)

	cmp	edx, 2048				; 00000800H
	jae	SHORT $LN3@ImTextChar

; 1200 :     {
; 1201 :         if (buf_size < 2) return 0;

	cmp	DWORD PTR _buf_size$[ebp], 2
	jge	SHORT $LN4@ImTextChar
$LN10@ImTextChar:
	xor	eax, eax

; 1226 :     }
; 1227 : }

	pop	ebp
	ret	0
$LN4@ImTextChar:

; 1202 :         buf[0] = (char)(0xc0 + (c >> 6));

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	eax, edx
	shr	eax, 6

; 1203 :         buf[1] = (char)(0x80 + (c & 0x3f));

	and	dl, 63					; 0000003fH
	sub	al, 64					; 00000040H
	add	dl, -128				; ffffff80H
	mov	BYTE PTR [ecx], al

; 1204 :         return 2;

	mov	eax, 2
	mov	BYTE PTR [ecx+1], dl

; 1226 :     }
; 1227 : }

	pop	ebp
	ret	0
$LN3@ImTextChar:

; 1205 :     }
; 1206 :     if (c >= 0xdc00 && c < 0xe000)

	lea	eax, DWORD PTR [edx-56320]
	cmp	eax, 1023				; 000003ffH
	jbe	SHORT $LN10@ImTextChar

; 1207 :     {
; 1208 :         return 0;
; 1209 :     }
; 1210 :     if (c >= 0xd800 && c < 0xdc00)

	lea	eax, DWORD PTR [edx-55296]
	cmp	eax, 1023				; 000003ffH
	ja	SHORT $LN6@ImTextChar

; 1211 :     {
; 1212 :         if (buf_size < 4) return 0;

	cmp	DWORD PTR _buf_size$[ebp], 4
	jl	SHORT $LN10@ImTextChar

; 1213 :         buf[0] = (char)(0xf0 + (c >> 18));

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	eax, edx
	shr	eax, 18					; 00000012H
	sub	al, 16					; 00000010H
	mov	BYTE PTR [ecx], al

; 1214 :         buf[1] = (char)(0x80 + ((c >> 12) & 0x3f));

	mov	eax, edx
	shr	eax, 12					; 0000000cH
	and	al, 63					; 0000003fH
	add	al, -128				; ffffff80H
	mov	BYTE PTR [ecx+1], al

; 1215 :         buf[2] = (char)(0x80 + ((c >> 6) & 0x3f));

	mov	eax, edx
	shr	eax, 6

; 1216 :         buf[3] = (char)(0x80 + ((c ) & 0x3f));

	and	dl, 63					; 0000003fH
	and	al, 63					; 0000003fH
	add	al, -128				; ffffff80H
	add	dl, -128				; ffffff80H
	mov	BYTE PTR [ecx+2], al

; 1217 :         return 4;

	mov	eax, 4
	mov	BYTE PTR [ecx+3], dl

; 1226 :     }
; 1227 : }

	pop	ebp
	ret	0
$LN6@ImTextChar:

; 1218 :     }
; 1219 :     //else if (c < 0x10000)
; 1220 :     {
; 1221 :         if (buf_size < 3) return 0;

	cmp	DWORD PTR _buf_size$[ebp], 3
	jl	SHORT $LN10@ImTextChar

; 1222 :         buf[0] = (char)(0xe0 + (c >> 12));

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	eax, edx
	shr	eax, 12					; 0000000cH
	sub	al, 32					; 00000020H
	mov	BYTE PTR [ecx], al

; 1223 :         buf[1] = (char)(0x80 + ((c>> 6) & 0x3f));

	mov	eax, edx
	shr	eax, 6

; 1224 :         buf[2] = (char)(0x80 + ((c ) & 0x3f));

	and	dl, 63					; 0000003fH
	and	al, 63					; 0000003fH
	add	al, -128				; ffffff80H
	add	dl, -128				; ffffff80H
	mov	BYTE PTR [ecx+1], al

; 1225 :         return 3;

	mov	eax, 3
	mov	BYTE PTR [ecx+2], dl

; 1226 :     }
; 1227 : }

	pop	ebp
	ret	0
?ImTextCharToUtf8@@YAHPADHI@Z ENDP			; ImTextCharToUtf8
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const *>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

	ret	0
??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_count$ = 16						; size = 4
?ImStrncpy@@YAXPADPBDH@Z PROC				; ImStrncpy

; 973  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	edi

; 974  :     if (count < 1) return;

	mov	edi, DWORD PTR _count$[ebp]
	cmp	edi, 1
	jl	SHORT $LN1@ImStrncpy

; 975  :     strncpy(dst, src, (size_t)count);

	push	esi
	mov	esi, DWORD PTR _dst$[ebp]
	push	edi
	push	DWORD PTR _src$[ebp]
	push	esi
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 976  :     dst[count-1] = 0;

	mov	BYTE PTR [esi+edi-1], 0
	pop	esi
$LN1@ImStrncpy:
	pop	edi

; 977  : }

	pop	ebp
	ret	0
?ImStrncpy@@YAXPADPBDH@Z ENDP				; ImStrncpy
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__FGImDefaultContext@@YAXXZ
text$yd	SEGMENT
??__FGImDefaultContext@@YAXXZ PROC			; `dynamic atexit destructor for 'GImDefaultContext'', COMDAT
	mov	ecx, OFFSET ?GImDefaultContext@@3UImGuiContext@@A
	jmp	??1ImGuiContext@@QAE@XZ
??__FGImDefaultContext@@YAXXZ ENDP			; `dynamic atexit destructor for 'GImDefaultContext''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
;	COMDAT ??__EGImDefaultContext@@YAXXZ
text$di	SEGMENT
??__EGImDefaultContext@@YAXXZ PROC			; `dynamic initializer for 'GImDefaultContext'', COMDAT

; 781  : static ImGuiContext     GImDefaultContext;

	mov	ecx, OFFSET ?GImDefaultContext@@3UImGuiContext@@A
	call	??0ImGuiContext@@QAE@XZ			; ImGuiContext::ImGuiContext
	push	OFFSET ??__FGImDefaultContext@@YAXXZ	; `dynamic atexit destructor for 'GImDefaultContext''
	call	_atexit
	pop	ecx
	ret	0
??__EGImDefaultContext@@YAXXZ ENDP			; `dynamic initializer for 'GImDefaultContext''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__FGImDefaultFontAtlas@@YAXXZ
text$yd	SEGMENT
??__FGImDefaultFontAtlas@@YAXXZ PROC			; `dynamic atexit destructor for 'GImDefaultFontAtlas'', COMDAT
	mov	ecx, OFFSET ?GImDefaultFontAtlas@@3UImFontAtlas@@A
	jmp	??1ImFontAtlas@@QAE@XZ			; ImFontAtlas::~ImFontAtlas
??__FGImDefaultFontAtlas@@YAXXZ ENDP			; `dynamic atexit destructor for 'GImDefaultFontAtlas''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
;	COMDAT ??__EGImDefaultFontAtlas@@YAXXZ
text$di	SEGMENT
??__EGImDefaultFontAtlas@@YAXXZ PROC			; `dynamic initializer for 'GImDefaultFontAtlas'', COMDAT

; 773  : static ImFontAtlas      GImDefaultFontAtlas;

	mov	ecx, OFFSET ?GImDefaultFontAtlas@@3UImFontAtlas@@A
	call	??0ImFontAtlas@@QAE@XZ			; ImFontAtlas::ImFontAtlas
	push	OFFSET ??__FGImDefaultFontAtlas@@YAXXZ	; `dynamic atexit destructor for 'GImDefaultFontAtlas''
	call	_atexit
	pop	ecx
	ret	0
??__EGImDefaultFontAtlas@@YAXXZ ENDP			; `dynamic initializer for 'GImDefaultFontAtlas''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_cf$1 = -28						; size = 28
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?ImeSetInputScreenPosFn_DefaultImpl@@YAXHH@Z PROC	; ImeSetInputScreenPosFn_DefaultImpl

; 10788: {

	npad	2
	push	ebp
	mov	ebp, esp

; 10789:     // Notify OS Input Method Editor of text input position
; 10790:     if (HWND hwnd = (HWND)GImGui->IO.ImeWindowHandle)

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR [eax+204]
	test	eax, eax
	je	SHORT $LN3@ImeSetInpu

; 10791:         if (HIMC himc = ImmGetContext(hwnd))

	push	eax
	call	_ImmGetContext@4
	test	eax, eax
	je	SHORT $LN3@ImeSetInpu

; 10792:         {
; 10793:             COMPOSITIONFORM cf;
; 10794:             cf.ptCurrentPos.x = x;

	mov	ecx, DWORD PTR _x$[ebp]
	mov	DWORD PTR _cf$1[ebp+4], ecx

; 10795:             cf.ptCurrentPos.y = y;

	mov	ecx, DWORD PTR _y$[ebp]
	mov	DWORD PTR _cf$1[ebp+8], ecx

; 10796:             cf.dwStyle = CFS_FORCE_POSITION;
; 10797:             ImmSetCompositionWindow(himc, &cf);

	lea	ecx, DWORD PTR _cf$1[ebp]
	push	ecx
	push	eax
	mov	DWORD PTR _cf$1[ebp], 32		; 00000020H
	call	_ImmSetCompositionWindow@8
$LN3@ImeSetInpu:

; 10798:         }
; 10799: }

	mov	esp, ebp
	pop	ebp
	ret	0
?ImeSetInputScreenPosFn_DefaultImpl@@YAXHH@Z ENDP	; ImeSetInputScreenPosFn_DefaultImpl
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_text$ = 12						; size = 4
?SetClipboardTextFn_DefaultImpl@@YAXPAXPBD@Z PROC	; SetClipboardTextFn_DefaultImpl

; 10742: {

	npad	2
	push	ebp
	mov	ebp, esp

; 10743:     if (!OpenClipboard(NULL))

	push	0
	call	DWORD PTR __imp__OpenClipboard@4
	test	eax, eax
	je	SHORT $LN1@SetClipboa

; 10744:         return;
; 10745:     const int wbuf_length = ImTextCountCharsFromUtf8(text, NULL) + 1;

	push	esi
	push	edi
	push	0
	push	DWORD PTR _text$[ebp]
	call	?ImTextCountCharsFromUtf8@@YAHPBD0@Z	; ImTextCountCharsFromUtf8
	add	esp, 8
	lea	edi, DWORD PTR [eax+1]

; 10746:     HGLOBAL wbuf_handle = GlobalAlloc(GMEM_MOVEABLE, (SIZE_T)wbuf_length * sizeof(ImWchar));

	lea	ecx, DWORD PTR [edi+edi]
	push	ecx
	push	2
	call	DWORD PTR __imp__GlobalAlloc@8
	mov	esi, eax

; 10747:     if (wbuf_handle == NULL)

	test	esi, esi
	je	SHORT $LN5@SetClipboa

; 10748:         return;
; 10749:     ImWchar* wbuf_global = (ImWchar*)GlobalLock(wbuf_handle);

	push	esi
	call	DWORD PTR __imp__GlobalLock@4

; 10750:     ImTextStrFromUtf8(wbuf_global, wbuf_length, text, NULL);

	push	0
	push	0
	push	DWORD PTR _text$[ebp]
	push	edi
	push	eax
	call	?ImTextStrFromUtf8@@YAHPAGHPBD1PAPBD@Z	; ImTextStrFromUtf8
	add	esp, 20					; 00000014H

; 10751:     GlobalUnlock(wbuf_handle);

	push	esi
	call	DWORD PTR __imp__GlobalUnlock@4

; 10752:     EmptyClipboard();

	call	DWORD PTR __imp__EmptyClipboard@0

; 10753:     SetClipboardData(CF_UNICODETEXT, wbuf_handle);

	push	esi
	push	13					; 0000000dH
	call	DWORD PTR __imp__SetClipboardData@8
	pop	edi
	pop	esi

; 10755: }

	pop	ebp

; 10754:     CloseClipboard();

	jmp	DWORD PTR __imp__CloseClipboard@0
$LN5@SetClipboa:
	pop	edi
	pop	esi
$LN1@SetClipboa:

; 10755: }

	pop	ebp
	ret	0
?SetClipboardTextFn_DefaultImpl@@YAXPAXPBD@Z ENDP	; SetClipboardTextFn_DefaultImpl
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?GetClipboardTextFn_DefaultImpl@@YAPBDPAX@Z PROC	; GetClipboardTextFn_DefaultImpl

; 10723:     static ImVector<char> buf_local;

	mov	eax, DWORD PTR fs:__tls_array
	mov	ecx, DWORD PTR __tls_index
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ?$TSS0@?1??GetClipboardTextFn_DefaultImpl@@YAPBDPAX@Z@4HA
	cmp	eax, DWORD PTR __Init_thread_epoch[ecx]
	jg	$LN14@GetClipboa
$LN2@GetClipboa:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	mov	eax, DWORD PTR ?buf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPBDPAX@Z@4V?$ImVector@D@@A+8
	test	eax, eax
	je	SHORT $LN11@GetClipboa
	push	eax
	mov	DWORD PTR ?buf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPBDPAX@Z@4V?$ImVector@D@@A+4, 0
	mov	DWORD PTR ?buf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPBDPAX@Z@4V?$ImVector@D@@A, 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR ?buf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPBDPAX@Z@4V?$ImVector@D@@A+8, 0
$LN11@GetClipboa:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10725:     if (!OpenClipboard(NULL))

	push	0
	call	DWORD PTR __imp__OpenClipboard@4
	test	eax, eax
	jne	SHORT $LN3@GetClipboa

; 10739: }

	ret	0
$LN3@GetClipboa:
	push	edi

; 10726:         return NULL;
; 10727:     HANDLE wbuf_handle = GetClipboardData(CF_UNICODETEXT);

	push	13					; 0000000dH
	call	DWORD PTR __imp__GetClipboardData@4
	mov	edi, eax

; 10728:     if (wbuf_handle == NULL)

	test	edi, edi
	jne	SHORT $LN4@GetClipboa
	pop	edi

; 10739: }

	ret	0
$LN4@GetClipboa:
	push	ebx

; 10729:         return NULL;
; 10730:     if (ImWchar* wbuf_global = (ImWchar*)GlobalLock(wbuf_handle))

	push	edi
	call	DWORD PTR __imp__GlobalLock@4
	mov	ebx, eax
	test	ebx, ebx
	je	SHORT $LN5@GetClipboa

; 10731:     {
; 10732:         int buf_len = ImTextCountUtf8BytesFromStr(wbuf_global, NULL) + 1;

	push	esi
	push	0
	push	ebx
	call	?ImTextCountUtf8BytesFromStr@@YAHPBG0@Z	; ImTextCountUtf8BytesFromStr
	add	esp, 8

; 10733:         buf_local.resize(buf_len);

	mov	ecx, OFFSET ?buf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPBDPAX@Z@4V?$ImVector@D@@A
	lea	esi, DWORD PTR [eax+1]
	push	esi
	call	?resize@?$ImVector@D@@QAEXH@Z		; ImVector<char>::resize

; 10734:         ImTextStrToUtf8(buf_local.Data, buf_len, wbuf_global, NULL);

	push	0
	push	ebx
	push	esi
	push	DWORD PTR ?buf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPBDPAX@Z@4V?$ImVector@D@@A+8
	call	?ImTextStrToUtf8@@YAHPADHPBG1@Z		; ImTextStrToUtf8
	add	esp, 16					; 00000010H
	pop	esi
$LN5@GetClipboa:

; 10735:     }
; 10736:     GlobalUnlock(wbuf_handle);

	push	edi
	call	DWORD PTR __imp__GlobalUnlock@4

; 10737:     CloseClipboard();

	call	DWORD PTR __imp__CloseClipboard@0

; 10738:     return buf_local.Data;

	mov	eax, DWORD PTR ?buf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPBDPAX@Z@4V?$ImVector@D@@A+8
	pop	ebx
	pop	edi

; 10739: }

	ret	0
$LN14@GetClipboa:

; 10723:     static ImVector<char> buf_local;

	push	OFFSET ?$TSS0@?1??GetClipboardTextFn_DefaultImpl@@YAPBDPAX@Z@4HA
	call	__Init_thread_header
	add	esp, 4
	cmp	DWORD PTR ?$TSS0@?1??GetClipboardTextFn_DefaultImpl@@YAPBDPAX@Z@4HA, -1
	jne	$LN2@GetClipboa
	push	OFFSET ??__Fbuf_local@?1??GetClipboardTextFn_DefaultImpl@@YAPBDPAX@Z@YAXXZ ; `GetClipboardTextFn_DefaultImpl'::`2'::`dynamic atexit destructor for 'buf_local''
	call	_atexit
	push	OFFSET ?$TSS0@?1??GetClipboardTextFn_DefaultImpl@@YAPBDPAX@Z@4HA
	call	__Init_thread_footer
	add	esp, 8
	jmp	$LN2@GetClipboa
?GetClipboardTextFn_DefaultImpl@@YAPBDPAX@Z ENDP	; GetClipboardTextFn_DefaultImpl
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_old_v$1$ = -12						; size = 4
tv346 = -12						; size = 4
tv342 = -8						; size = 4
_arg0$1 = -4						; size = 4
_arg0$2 = -4						; size = 4
_arg1$3 = 8						; size = 4
_arg1$4 = 8						; size = 4
_buf$ = 8						; size = 4
_initial_value_buf$ = 12				; size = 4
_data_type$ = 16					; size = 4
_data_ptr$ = 20						; size = 4
_scalar_format$ = 24					; size = 4
?DataTypeApplyOpFromText@@YA_NPBD0W4ImGuiDataType@@PAX0@Z PROC ; DataTypeApplyOpFromText

; 7308 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, DWORD PTR _buf$[ebp]
	npad	3
$LL2@DataTypeAp:

; 7309 :     while (ImCharIsSpace(*buf))

	movsx	eax, BYTE PTR [esi]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 96   : static inline bool      ImCharIsSpace(int c)            { return c == ' ' || c == '\t' || c == 0x3000; }

	cmp	eax, 32					; 00000020H
	je	SHORT $LN39@DataTypeAp
	cmp	eax, 9
	je	SHORT $LN39@DataTypeAp
	cmp	eax, 12288				; 00003000H
	jne	SHORT $LN53@DataTypeAp
$LN39@DataTypeAp:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7310 :         buf++;

	inc	esi
	jmp	SHORT $LL2@DataTypeAp
$LN53@DataTypeAp:

; 7311 : 
; 7312 :     // We don't support '-' op because it would conflict with inputing negative value.
; 7313 :     // Instead you can use +-100 to subtract from an existing value
; 7314 :     char op = buf[0];

	mov	bl, BYTE PTR [esi]

; 7315 :     if (op == '+' || op == '*' || op == '/')

	cmp	bl, 43					; 0000002bH
	je	SHORT $LN8@DataTypeAp
	cmp	bl, 42					; 0000002aH
	je	SHORT $LN8@DataTypeAp
	cmp	bl, 47					; 0000002fH
	je	SHORT $LN8@DataTypeAp

; 7319 :             buf++;
; 7320 :     }
; 7321 :     else
; 7322 :     {
; 7323 :         op = 0;

	xor	bl, bl
	jmp	SHORT $LN57@DataTypeAp
$LN8@DataTypeAp:

; 7316 :     {
; 7317 :         buf++;
; 7318 :         while (ImCharIsSpace(*buf))

	movsx	eax, BYTE PTR [esi+1]
	inc	esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 96   : static inline bool      ImCharIsSpace(int c)            { return c == ' ' || c == '\t' || c == 0x3000; }

	cmp	eax, 32					; 00000020H
	je	SHORT $LN8@DataTypeAp
	cmp	eax, 9
	je	SHORT $LN8@DataTypeAp
	cmp	eax, 12288				; 00003000H
	je	SHORT $LN8@DataTypeAp
$LN57@DataTypeAp:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7325 :     if (!buf[0])

	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN9@DataTypeAp

; 7326 :         return false;

	pop	esi
	xor	al, al
	pop	ebx

; 7367 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@DataTypeAp:

; 7327 : 
; 7328 :     if (data_type == ImGuiDataType_Int)

	mov	eax, DWORD PTR _data_type$[ebp]
	push	edi
	test	eax, eax
	jne	$LN10@DataTypeAp

; 7329 :     {
; 7330 :         if (!scalar_format)
; 7331 :             scalar_format = "%d";
; 7332 :         int* v = (int*)data_ptr;
; 7333 :         const int old_v = *v;

	mov	eax, DWORD PTR _scalar_format$[ebp]
	mov	ecx, OFFSET $SG119822
	mov	edi, DWORD PTR _data_ptr$[ebp]
	test	eax, eax
	cmovne	ecx, eax
	mov	DWORD PTR tv342[ebp], ecx
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR tv346[ebp], eax

; 7334 :         int arg0 = *v;

	mov	DWORD PTR _arg0$2[ebp], eax

; 7335 :         if (op && sscanf(initial_value_buf, scalar_format, &arg0) < 1)

	test	bl, bl
	je	SHORT $LN13@DataTypeAp
	lea	eax, DWORD PTR _arg0$2[ebp]
	push	eax
	push	ecx
	push	DWORD PTR _initial_value_buf$[ebp]
	call	_sscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jl	$LN24@DataTypeAp
	mov	ecx, DWORD PTR tv342[ebp]
$LN13@DataTypeAp:

; 7336 :             return false;
; 7337 : 
; 7338 :         // Store operand in a float so we can use fractional value for multipliers (*1.1), but constant always parsed as integer so we can fit big integers (e.g. 2000000003) past float precision
; 7339 :         float arg1 = 0.0f;

	mov	DWORD PTR _arg1$4[ebp], 0

; 7340 :         if (op == '+')      { if (sscanf(buf, "%f", &arg1) == 1) *v = (int)(arg0 + arg1); }                // Add (use "+-" to subtract)

	cmp	bl, 43					; 0000002bH
	jne	SHORT $LN14@DataTypeAp
	lea	eax, DWORD PTR _arg1$4[ebp]
	push	eax
	push	OFFSET $SG119827
	push	esi
	call	_sscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jne	$LN23@DataTypeAp
	movd	xmm0, DWORD PTR _arg0$2[ebp]
	cvtdq2ps xmm0, xmm0
	addss	xmm0, DWORD PTR _arg1$4[ebp]
	cvttss2si eax, xmm0

; 7343 :         else                { if (sscanf(buf, scalar_format, &arg0) == 1) *v = arg0; }                     // Assign constant

	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR tv346[ebp]
	cmp	eax, DWORD PTR [edi]
	pop	edi
	pop	esi
	setne	al
	pop	ebx

; 7367 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@DataTypeAp:

; 7341 :         else if (op == '*') { if (sscanf(buf, "%f", &arg1) == 1) *v = (int)(arg0 * arg1); }                // Multiply

	cmp	bl, 42					; 0000002aH
	jne	SHORT $LN17@DataTypeAp
	lea	eax, DWORD PTR _arg1$4[ebp]
	push	eax
	push	OFFSET $SG119831
	push	esi
	call	_sscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jne	$LN23@DataTypeAp
	movd	xmm0, DWORD PTR _arg0$2[ebp]
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR _arg1$4[ebp]
	cvttss2si eax, xmm0

; 7343 :         else                { if (sscanf(buf, scalar_format, &arg0) == 1) *v = arg0; }                     // Assign constant

	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR tv346[ebp]
	cmp	eax, DWORD PTR [edi]
	pop	edi
	pop	esi
	setne	al
	pop	ebx

; 7367 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@DataTypeAp:

; 7342 :         else if (op == '/') { if (sscanf(buf, "%f", &arg1) == 1 && arg1 != 0.0f) *v = (int)(arg0 / arg1); }// Divide

	cmp	bl, 47					; 0000002fH
	jne	SHORT $LN20@DataTypeAp
	lea	eax, DWORD PTR _arg1$4[ebp]
	push	eax
	push	OFFSET $SG119835
	push	esi
	call	_sscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jne	SHORT $LN23@DataTypeAp
	movss	xmm1, DWORD PTR _arg1$4[ebp]
	xorps	xmm0, xmm0
	ucomiss	xmm1, xmm0
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN23@DataTypeAp
	movd	xmm0, DWORD PTR _arg0$2[ebp]
	cvtdq2ps xmm0, xmm0
	divss	xmm0, xmm1
	cvttss2si eax, xmm0

; 7343 :         else                { if (sscanf(buf, scalar_format, &arg0) == 1) *v = arg0; }                     // Assign constant

	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR tv346[ebp]
	cmp	eax, DWORD PTR [edi]
	pop	edi
	pop	esi
	setne	al
	pop	ebx

; 7367 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@DataTypeAp:

; 7343 :         else                { if (sscanf(buf, scalar_format, &arg0) == 1) *v = arg0; }                     // Assign constant

	lea	eax, DWORD PTR _arg0$2[ebp]
	push	eax
	push	ecx
	push	esi
	call	_sscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jne	SHORT $LN23@DataTypeAp
	mov	eax, DWORD PTR _arg0$2[ebp]
	mov	DWORD PTR [edi], eax
$LN23@DataTypeAp:
	mov	eax, DWORD PTR tv346[ebp]
	cmp	eax, DWORD PTR [edi]
	pop	edi
	pop	esi
	setne	al
	pop	ebx

; 7367 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@DataTypeAp:

; 7344 :         return (old_v != *v);
; 7345 :     }
; 7346 :     else if (data_type == ImGuiDataType_Float)

	cmp	eax, 1
	jne	$LN24@DataTypeAp

; 7347 :     {
; 7348 :         // For floats we have to ignore format with precision (e.g. "%.2f") because sscanf doesn't take them in
; 7349 :         scalar_format = "%f";
; 7350 :         float* v = (float*)data_ptr;
; 7351 :         const float old_v = *v;

	mov	edi, DWORD PTR _data_ptr$[ebp]
	movss	xmm0, DWORD PTR [edi]
	movss	DWORD PTR _old_v$1$[ebp], xmm0

; 7352 :         float arg0 = *v;

	movss	DWORD PTR _arg0$1[ebp], xmm0

; 7353 :         if (op && sscanf(initial_value_buf, scalar_format, &arg0) < 1)

	test	bl, bl
	je	SHORT $LN25@DataTypeAp
	lea	eax, DWORD PTR _arg0$1[ebp]
	push	eax
	push	OFFSET $SG119838
	push	DWORD PTR _initial_value_buf$[ebp]
	call	_sscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jl	$LN24@DataTypeAp
$LN25@DataTypeAp:

; 7354 :             return false;
; 7355 : 
; 7356 :         float arg1 = 0.0f;
; 7357 :         if (sscanf(buf, scalar_format, &arg1) < 1)

	lea	eax, DWORD PTR _arg1$3[ebp]
	mov	DWORD PTR _arg1$3[ebp], 0
	push	eax
	push	OFFSET $SG119838
	push	esi
	call	_sscanf
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	jl	SHORT $LN24@DataTypeAp

; 7358 :             return false;
; 7359 :         if (op == '+')      { *v = arg0 + arg1; }                    // Add (use "+-" to subtract)

	cmp	bl, 43					; 0000002bH
	jne	SHORT $LN27@DataTypeAp
	movss	xmm0, DWORD PTR _arg1$3[ebp]
	addss	xmm0, DWORD PTR _arg0$1[ebp]
	jmp	SHORT $LN61@DataTypeAp
$LN27@DataTypeAp:

; 7360 :         else if (op == '*') { *v = arg0 * arg1; }                    // Multiply

	cmp	bl, 42					; 0000002aH
	jne	SHORT $LN29@DataTypeAp
	movss	xmm0, DWORD PTR _arg1$3[ebp]
	mulss	xmm0, DWORD PTR _arg0$1[ebp]
	jmp	SHORT $LN61@DataTypeAp
$LN29@DataTypeAp:

; 7361 :         else if (op == '/') { if (arg1 != 0.0f) *v = arg0 / arg1; }  // Divide

	cmp	bl, 47					; 0000002fH
	jne	SHORT $LN31@DataTypeAp
	movss	xmm1, DWORD PTR _arg1$3[ebp]
	xorps	xmm0, xmm0
	ucomiss	xmm1, xmm0
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN32@DataTypeAp
	movss	xmm0, DWORD PTR _arg0$1[ebp]
	divss	xmm0, xmm1
	jmp	SHORT $LN61@DataTypeAp
$LN31@DataTypeAp:

; 7362 :         else                { *v = arg1; }                           // Assign constant

	movss	xmm0, DWORD PTR _arg1$3[ebp]
$LN61@DataTypeAp:
	movss	DWORD PTR [edi], xmm0
$LN32@DataTypeAp:

; 7363 :         return (old_v != *v);

	movss	xmm0, DWORD PTR _old_v$1$[ebp]
	ucomiss	xmm0, DWORD PTR [edi]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN35@DataTypeAp
	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebx

; 7367 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@DataTypeAp:
	pop	edi
	pop	esi

; 7363 :         return (old_v != *v);

	xor	eax, eax
	pop	ebx

; 7367 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@DataTypeAp:
	pop	edi
	pop	esi

; 7364 :     }
; 7365 : 
; 7366 :     return false;

	xor	al, al
	pop	ebx

; 7367 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DataTypeApplyOpFromText@@YA_NPBD0W4ImGuiDataType@@PAX0@Z ENDP ; DataTypeApplyOpFromText
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_data_type$ = 8						; size = 4
_op$ = 12						; size = 4
_value1$ = 16						; size = 4
_value2$ = 20						; size = 4
?DataTypeApplyOp@@YAXW4ImGuiDataType@@HPAXPBX@Z PROC	; DataTypeApplyOp

; 7289 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 7290 :     if (data_type == ImGuiDataType_Int)

	mov	eax, DWORD PTR _data_type$[ebp]
	test	eax, eax
	jne	SHORT $LN2@DataTypeAp

; 7291 :     {
; 7292 :         if (op == '+')

	mov	eax, DWORD PTR _op$[ebp]
	cmp	eax, 43					; 0000002bH
	jne	SHORT $LN4@DataTypeAp

; 7293 :             *(int*)value1 = *(int*)value1 + *(const int*)value2;

	mov	eax, DWORD PTR _value2$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _value1$[ebp]
	add	DWORD PTR [eax], ecx

; 7303 :     }
; 7304 : }

	pop	ebp
	ret	0
$LN4@DataTypeAp:

; 7294 :         else if (op == '-')

	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN10@DataTypeAp

; 7295 :             *(int*)value1 = *(int*)value1 - *(const int*)value2;

	mov	eax, DWORD PTR _value2$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _value1$[ebp]
	sub	DWORD PTR [eax], ecx

; 7303 :     }
; 7304 : }

	pop	ebp
	ret	0
$LN2@DataTypeAp:

; 7296 :     }
; 7297 :     else if (data_type == ImGuiDataType_Float)

	cmp	eax, 1
	jne	SHORT $LN10@DataTypeAp

; 7298 :     {
; 7299 :         if (op == '+')

	mov	eax, DWORD PTR _op$[ebp]
	cmp	eax, 43					; 0000002bH
	jne	SHORT $LN8@DataTypeAp

; 7300 :             *(float*)value1 = *(float*)value1 + *(const float*)value2;

	mov	ecx, DWORD PTR _value1$[ebp]
	mov	eax, DWORD PTR _value2$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	addss	xmm0, DWORD PTR [eax]

; 7302 :             *(float*)value1 = *(float*)value1 - *(const float*)value2;

	movss	DWORD PTR [ecx], xmm0

; 7303 :     }
; 7304 : }

	pop	ebp
	ret	0
$LN8@DataTypeAp:

; 7301 :         else if (op == '-')

	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN10@DataTypeAp

; 7302 :             *(float*)value1 = *(float*)value1 - *(const float*)value2;

	mov	ecx, DWORD PTR _value1$[ebp]
	mov	eax, DWORD PTR _value2$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	subss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [ecx], xmm0
$LN10@DataTypeAp:

; 7303 :     }
; 7304 : }

	pop	ebp
	ret	0
?DataTypeApplyOp@@YAXW4ImGuiDataType@@HPAXPBX@Z ENDP	; DataTypeApplyOp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_data_type$ = 8						; size = 4
_data_ptr$ = 12						; size = 4
_decimal_precision$ = 16				; size = 4
_buf$ = 20						; size = 4
_buf_size$ = 24						; size = 4
?DataTypeFormatString@@YAXW4ImGuiDataType@@PAXHPADH@Z PROC ; DataTypeFormatString

; 7271 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 7272 :     if (data_type == ImGuiDataType_Int)

	mov	eax, DWORD PTR _data_type$[ebp]
	test	eax, eax
	jne	SHORT $LN2@DataTypeFo

; 7273 :     {
; 7274 :         if (decimal_precision < 0)
; 7275 :             ImFormatString(buf, buf_size, "%d", *(int*)data_ptr);

	mov	eax, DWORD PTR _data_ptr$[ebp]
	mov	ecx, DWORD PTR _decimal_precision$[ebp]
	push	DWORD PTR [eax]
	test	ecx, ecx
	jns	SHORT $LN4@DataTypeFo
	push	OFFSET $SG119756
	push	DWORD PTR _buf_size$[ebp]
	push	DWORD PTR _buf$[ebp]
	call	?ImFormatString@@YAHPADHPBDZZ		; ImFormatString
	add	esp, 16					; 00000010H

; 7285 :     }
; 7286 : }

	pop	ebp
	ret	0
$LN4@DataTypeFo:

; 7276 :         else
; 7277 :             ImFormatString(buf, buf_size, "%.*d", decimal_precision, *(int*)data_ptr);

	push	ecx
	push	OFFSET $SG119757
	push	DWORD PTR _buf_size$[ebp]
	push	DWORD PTR _buf$[ebp]
	call	?ImFormatString@@YAHPADHPBDZZ		; ImFormatString
	add	esp, 20					; 00000014H

; 7285 :     }
; 7286 : }

	pop	ebp
	ret	0
$LN2@DataTypeFo:

; 7278 :     }
; 7279 :     else if (data_type == ImGuiDataType_Float)

	cmp	eax, 1
	jne	SHORT $LN8@DataTypeFo

; 7280 :     {
; 7281 :         if (decimal_precision < 0)
; 7282 :             ImFormatString(buf, buf_size, "%f", *(float*)data_ptr);     // Ideally we'd have a minimum decimal precision of 1 to visually denote that it is a float, while hiding non-significant digits?

	mov	eax, DWORD PTR _data_ptr$[ebp]
	sub	esp, 8
	mov	ecx, DWORD PTR _decimal_precision$[ebp]
	movss	xmm0, DWORD PTR [eax]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	test	ecx, ecx
	jns	SHORT $LN7@DataTypeFo
	push	OFFSET $SG119761
	push	DWORD PTR _buf_size$[ebp]
	push	DWORD PTR _buf$[ebp]
	call	?ImFormatString@@YAHPADHPBDZZ		; ImFormatString
	add	esp, 20					; 00000014H

; 7285 :     }
; 7286 : }

	pop	ebp
	ret	0
$LN7@DataTypeFo:

; 7283 :         else
; 7284 :             ImFormatString(buf, buf_size, "%.*f", decimal_precision, *(float*)data_ptr);

	push	ecx
	push	OFFSET $SG119762
	push	DWORD PTR _buf_size$[ebp]
	push	DWORD PTR _buf$[ebp]
	call	?ImFormatString@@YAHPADHPBDZZ		; ImFormatString
	add	esp, 24					; 00000018H
$LN8@DataTypeFo:

; 7285 :     }
; 7286 : }

	pop	ebp
	ret	0
?DataTypeFormatString@@YAXW4ImGuiDataType@@PAXHPADH@Z ENDP ; DataTypeFormatString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_data_type$ = 8						; size = 4
_data_ptr$ = 12						; size = 4
_display_format$ = 16					; size = 4
_buf$ = 20						; size = 4
_buf_size$ = 24						; size = 4
?DataTypeFormatString@@YAXW4ImGuiDataType@@PAXPBDPADH@Z PROC ; DataTypeFormatString

; 7263 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 7264 :     if (data_type == ImGuiDataType_Int)

	mov	eax, DWORD PTR _data_type$[ebp]
	test	eax, eax
	jne	SHORT $LN2@DataTypeFo

; 7265 :         ImFormatString(buf, buf_size, display_format, *(int*)data_ptr);

	mov	eax, DWORD PTR _data_ptr$[ebp]
	push	DWORD PTR [eax]
	push	DWORD PTR _display_format$[ebp]
	push	DWORD PTR _buf_size$[ebp]
	push	DWORD PTR _buf$[ebp]
	call	?ImFormatString@@YAHPADHPBDZZ		; ImFormatString
	add	esp, 16					; 00000010H

; 7268 : }

	pop	ebp
	ret	0
$LN2@DataTypeFo:

; 7266 :     else if (data_type == ImGuiDataType_Float)

	cmp	eax, 1
	jne	SHORT $LN4@DataTypeFo

; 7267 :         ImFormatString(buf, buf_size, display_format, *(float*)data_ptr);

	mov	eax, DWORD PTR _data_ptr$[ebp]
	sub	esp, 8
	movss	xmm0, DWORD PTR [eax]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR _display_format$[ebp]
	push	DWORD PTR _buf_size$[ebp]
	push	DWORD PTR _buf$[ebp]
	call	?ImFormatString@@YAHPADHPBDZZ		; ImFormatString
	add	esp, 20					; 00000014H
$LN4@DataTypeFo:

; 7268 : }

	pop	ebp
	ret	0
?DataTypeFormatString@@YAXW4ImGuiDataType@@PAXPBDPADH@Z ENDP ; DataTypeFormatString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
_text_begin$ = 12					; size = 4
_text_end$ = 16						; size = 4
_remaining$ = 20					; size = 4
_out_offset$ = 24					; size = 4
_stop_on_new_line$ = 28					; size = 1
?InputTextCalcTextSizeW@@YA?AUImVec2@@PBG0PAPBGPAU1@_N@Z PROC ; InputTextCalcTextSizeW

; 8457 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 8458 :     ImFont* font = GImGui->Font;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	sub	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	xorps	xmm2, xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8465 :     const ImWchar* s = text_begin;

	mov	edx, DWORD PTR _text_begin$[ebp]
	xorps	xmm1, xmm1
	movss	xmm3, DWORD PTR [eax+6172]
	push	ebx

; 8466 :     while (s < text_end)

	mov	ebx, DWORD PTR _text_end$[ebp]
	movaps	xmm4, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0
	push	esi
	push	edi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8458 :     ImFont* font = GImGui->Font;

	mov	edi, DWORD PTR [eax+6168]

; 8459 :     const float line_height = GImGui->FontSize;
; 8460 :     const float scale = line_height / font->FontSize;

	divss	xmm4, DWORD PTR [edi]

; 8466 :     while (s < text_end)

	cmp	edx, ebx
	jae	SHORT $LN7@InputTextC
$LL2@InputTextC:

; 8467 :     {
; 8468 :         unsigned int c = (unsigned int)(*s++);

	movzx	eax, WORD PTR [edx]
	add	edx, 2

; 8469 :         if (c == '\n')

	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN4@InputTextC

; 8470 :         {
; 8471 :             text_size.x = ImMax(text_size.x, line_width);
; 8472 :             text_size.y += line_height;
; 8473 :             line_width = 0.0f;
; 8474 :             if (stop_on_new_line)

	cmp	BYTE PTR _stop_on_new_line$[ebp], 0
	movss	xmm0, DWORD PTR [ecx]
	maxss	xmm0, xmm1
	movaps	xmm1, xmm2
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR [ecx+4]
	addss	xmm0, xmm3
	movss	DWORD PTR [ecx+4], xmm0
	jne	SHORT $LN30@InputTextC

; 8475 :                 break;
; 8476 :             continue;

	jmp	SHORT $LN31@InputTextC
$LN4@InputTextC:

; 8477 :         }
; 8478 :         if (c == '\r')

	cmp	eax, 13					; 0000000dH
	je	SHORT $LN31@InputTextC
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1437 :     float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexXAdvance.Size) ? IndexXAdvance[(int)c] : FallbackXAdvance; }

	mov	esi, eax
	cmp	esi, DWORD PTR [edi+28]
	jge	SHORT $LN21@InputTextC
	mov	eax, DWORD PTR [edi+36]
	movss	xmm0, DWORD PTR [eax+esi*4]
	jmp	SHORT $LN22@InputTextC
$LN21@InputTextC:
	movss	xmm0, DWORD PTR [edi+56]
$LN22@InputTextC:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8481 :         const float char_width = font->GetCharAdvance((unsigned short)c) * scale;

	mulss	xmm0, xmm4

; 8482 :         line_width += char_width;

	addss	xmm1, xmm0
$LN31@InputTextC:

; 8466 :     while (s < text_end)

	cmp	edx, ebx
	jb	SHORT $LL2@InputTextC
$LN30@InputTextC:

; 8483 :     }
; 8484 : 
; 8485 :     if (text_size.x < line_width)

	comiss	xmm1, DWORD PTR [ecx]
	jbe	SHORT $LN7@InputTextC

; 8486 :         text_size.x = line_width;

	movss	DWORD PTR [ecx], xmm1
$LN7@InputTextC:

; 8487 : 
; 8488 :     if (out_offset)

	mov	esi, DWORD PTR _out_offset$[ebp]
	test	esi, esi
	je	SHORT $LN8@InputTextC

; 8489 :         *out_offset = ImVec2(line_width, text_size.y + line_height);  // offset allow for the possibility of sitting after a trailing \n

	movss	xmm0, DWORD PTR [ecx+4]
	addss	xmm0, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8489 :         *out_offset = ImVec2(line_width, text_size.y + line_height);  // offset allow for the possibility of sitting after a trailing \n

	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR [esi], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8489 :         *out_offset = ImVec2(line_width, text_size.y + line_height);  // offset allow for the possibility of sitting after a trailing \n

	mov	eax, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR [esi+4], eax
$LN8@InputTextC:

; 8490 : 
; 8491 :     if (line_width > 0 || text_size.y == 0.0f)                        // whereas size.y will ignore the trailing \n

	comiss	xmm1, xmm2
	pop	edi
	pop	esi
	pop	ebx
	ja	SHORT $LN10@InputTextC
	movss	xmm0, DWORD PTR [ecx+4]
	ucomiss	xmm0, xmm2
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@InputTextC
$LN10@InputTextC:

; 8492 :         text_size.y += line_height;

	movss	xmm0, DWORD PTR [ecx+4]
	addss	xmm0, xmm3
	movss	DWORD PTR [ecx+4], xmm0
$LN9@InputTextC:

; 8493 : 
; 8494 :     if (remaining)

	mov	eax, DWORD PTR _remaining$[ebp]
	test	eax, eax
	je	SHORT $LN34@InputTextC

; 8495 :         *remaining = s;

	mov	DWORD PTR [eax], edx
$LN34@InputTextC:

; 8496 : 
; 8497 :     return text_size;

	mov	eax, ecx

; 8498 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InputTextCalcTextSizeW@@YA?AUImVec2@@PBG0PAPBGPAU1@_N@Z ENDP ; InputTextCalcTextSizeW
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_text_begin$ = 8					; size = 4
_out_text_end$ = 12					; size = 4
?InputTextCalcTextLenAndLineCount@@YAHPBDPAPBD@Z PROC	; InputTextCalcTextLenAndLineCount

; 8443 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 8444 :     int line_count = 0;
; 8445 :     const char* s = text_begin;
; 8446 :     while (char c = *s++) // We are only matching for \n so we can ignore UTF-8 decoding

	mov	eax, DWORD PTR _text_begin$[ebp]
	push	esi
	xor	esi, esi
	mov	cl, BYTE PTR [eax]
	lea	edx, DWORD PTR [eax+1]
	test	cl, cl
	je	SHORT $LN3@InputTextC
$LL2@InputTextC:
	cmp	cl, 10					; 0000000aH
	lea	eax, DWORD PTR [esi+1]
	mov	cl, BYTE PTR [edx]
	cmovne	eax, esi
	inc	edx
	mov	esi, eax
	test	cl, cl
	jne	SHORT $LL2@InputTextC
$LN3@InputTextC:

; 8447 :         if (c == '\n')
; 8448 :             line_count++;
; 8449 :     s--;
; 8450 :     if (s[0] != '\n' && s[0] != '\r')

	mov	al, BYTE PTR [edx-1]
	dec	edx
	cmp	al, 10					; 0000000aH
	je	SHORT $LN10@InputTextC
	cmp	al, 13					; 0000000dH
	je	SHORT $LN10@InputTextC

; 8451 :         line_count++;
; 8452 :     *out_text_end = s;

	mov	ecx, DWORD PTR _out_text_end$[ebp]
	lea	eax, DWORD PTR [esi+1]
	pop	esi
	mov	DWORD PTR [ecx], edx

; 8454 : }

	pop	ebp
	ret	0
$LN10@InputTextC:

; 8451 :         line_count++;
; 8452 :     *out_text_end = s;

	mov	eax, DWORD PTR _out_text_end$[ebp]
	mov	DWORD PTR [eax], edx

; 8453 :     return line_count;

	mov	eax, esi
	pop	esi

; 8454 : }

	pop	ebp
	ret	0
?InputTextCalcTextLenAndLineCount@@YAHPBDPAPBD@Z ENDP	; InputTextCalcTextLenAndLineCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_callback_data$1 = -48					; size = 48
_p_char$ = 8						; size = 4
_flags$ = 12						; size = 4
_callback$ = 16						; size = 4
_user_data$ = 20					; size = 4
?InputTextFilterCharacter@@YA_NPAIHP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z PROC ; InputTextFilterCharacter

; 8642 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	ebx
	push	esi

; 8643 :     unsigned int c = *p_char;

	mov	esi, DWORD PTR _p_char$[ebp]
	mov	ebx, DWORD PTR [esi]

; 8644 : 
; 8645 :     if (c < 128 && c != ' ' && !isprint((int)(c & 0xFF)))

	cmp	ebx, 128				; 00000080H
	jae	SHORT $LN3@InputTextF
	cmp	ebx, 32					; 00000020H
	je	SHORT $LN3@InputTextF
	movzx	eax, bl
	push	eax
	call	DWORD PTR __imp__isprint
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN3@InputTextF

; 8646 :     {
; 8647 :         bool pass = false;
; 8648 :         pass |= (c == '\n' && (flags & ImGuiInputTextFlags_Multiline));

	mov	eax, DWORD PTR _flags$[ebp]
	cmp	ebx, 10					; 0000000aH
	jne	SHORT $LN22@InputTextF
	test	eax, 1048576				; 00100000H
	je	SHORT $LN22@InputTextF
	mov	cl, 1
$LN24@InputTextF:

; 8649 :         pass |= (c == '\t' && (flags & ImGuiInputTextFlags_AllowTabInput));

	xor	eax, eax
$LN25@InputTextF:
	or	al, cl

; 8650 :         if (!pass)

	jne	SHORT $LN3@InputTextF
$LN32@InputTextF:
	pop	esi

; 8651 :             return false;

	xor	al, al
	pop	ebx

; 8692 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@InputTextF:

; 8646 :     {
; 8647 :         bool pass = false;
; 8648 :         pass |= (c == '\n' && (flags & ImGuiInputTextFlags_Multiline));

	xor	cl, cl

; 8649 :         pass |= (c == '\t' && (flags & ImGuiInputTextFlags_AllowTabInput));

	cmp	ebx, 9
	jne	SHORT $LN24@InputTextF
	test	eax, 1024				; 00000400H
	je	SHORT $LN24@InputTextF
	lea	eax, DWORD PTR [ebx-8]
	jmp	SHORT $LN25@InputTextF
$LN3@InputTextF:

; 8652 :     }
; 8653 : 
; 8654 :     if (c >= 0xE000 && c <= 0xF8FF) // Filter private Unicode range. I don't imagine anybody would want to input them. GLFW on OSX seems to send private characters for special keys like arrow keys.

	lea	eax, DWORD PTR [ebx-57344]
	cmp	eax, 6399				; 000018ffH
	jbe	SHORT $LN32@InputTextF

; 8655 :         return false;
; 8656 : 
; 8657 :     if (flags & (ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase | ImGuiInputTextFlags_CharsNoBlank))

	mov	ecx, DWORD PTR _flags$[ebp]
	test	cl, 15					; 0000000fH
	je	$LN17@InputTextF

; 8658 :     {
; 8659 :         if (flags & ImGuiInputTextFlags_CharsDecimal)

	test	cl, 1
	je	SHORT $LN7@InputTextF

; 8660 :             if (!(c >= '0' && c <= '9') && (c != '.') && (c != '-') && (c != '+') && (c != '*') && (c != '/'))

	cmp	ebx, 48					; 00000030H
	jb	SHORT $LN8@InputTextF
	cmp	ebx, 57					; 00000039H
	jbe	SHORT $LN7@InputTextF
$LN8@InputTextF:
	cmp	ebx, 46					; 0000002eH
	je	SHORT $LN7@InputTextF
	cmp	ebx, 45					; 0000002dH
	je	SHORT $LN7@InputTextF
	cmp	ebx, 43					; 0000002bH
	je	SHORT $LN7@InputTextF
	cmp	ebx, 42					; 0000002aH
	je	SHORT $LN7@InputTextF
	cmp	ebx, 47					; 0000002fH
	jne	SHORT $LN32@InputTextF
$LN7@InputTextF:

; 8661 :                 return false;
; 8662 : 
; 8663 :         if (flags & ImGuiInputTextFlags_CharsHexadecimal)

	test	cl, 2
	je	SHORT $LN10@InputTextF

; 8664 :             if (!(c >= '0' && c <= '9') && !(c >= 'a' && c <= 'f') && !(c >= 'A' && c <= 'F'))

	cmp	ebx, 48					; 00000030H
	jb	SHORT $LN11@InputTextF
	cmp	ebx, 57					; 00000039H
	jbe	SHORT $LN10@InputTextF
$LN11@InputTextF:
	cmp	ebx, 97					; 00000061H
	jb	SHORT $LN12@InputTextF
	cmp	ebx, 102				; 00000066H
	jbe	SHORT $LN10@InputTextF
$LN12@InputTextF:
	cmp	ebx, 65					; 00000041H
	jb	SHORT $LN32@InputTextF
	cmp	ebx, 70					; 00000046H
	ja	SHORT $LN32@InputTextF
$LN10@InputTextF:

; 8665 :                 return false;
; 8666 : 
; 8667 :         if (flags & ImGuiInputTextFlags_CharsUppercase)

	test	cl, 4
	je	SHORT $LN15@InputTextF

; 8668 :             if (c >= 'a' && c <= 'z')

	lea	eax, DWORD PTR [ebx-97]
	cmp	eax, 25					; 00000019H
	ja	SHORT $LN15@InputTextF

; 8669 :                 *p_char = (c += (unsigned int)('A'-'a'));

	sub	ebx, 32					; 00000020H
	mov	DWORD PTR [esi], ebx
$LN15@InputTextF:

; 8670 : 
; 8671 :         if (flags & ImGuiInputTextFlags_CharsNoBlank)

	test	cl, 8
	je	SHORT $LN17@InputTextF
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 96   : static inline bool      ImCharIsSpace(int c)            { return c == ' ' || c == '\t' || c == 0x3000; }

	cmp	ebx, 32					; 00000020H
	je	$LN32@InputTextF
	cmp	ebx, 9
	je	$LN32@InputTextF
	cmp	ebx, 12288				; 00003000H
	je	$LN32@InputTextF
$LN17@InputTextF:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8676 :     if (flags & ImGuiInputTextFlags_CallbackCharFilter)

	test	ecx, 512				; 00000200H
	je	SHORT $LN20@InputTextF

; 8677 :     {
; 8678 :         ImGuiTextEditCallbackData callback_data;
; 8679 :         memset(&callback_data, 0, sizeof(ImGuiTextEditCallbackData));

	push	48					; 00000030H
	lea	eax, DWORD PTR _callback_data$1[ebp]
	push	0
	push	eax
	call	_memset

; 8680 :         callback_data.EventFlag = ImGuiInputTextFlags_CallbackCharFilter;
; 8681 :         callback_data.EventChar = (ImWchar)c;
; 8682 :         callback_data.Flags = flags;

	mov	eax, DWORD PTR _flags$[ebp]
	mov	DWORD PTR _callback_data$1[ebp+4], eax

; 8683 :         callback_data.UserData = user_data;

	mov	eax, DWORD PTR _user_data$[ebp]
	mov	DWORD PTR _callback_data$1[ebp+8], eax

; 8684 :         if (callback(&callback_data) != 0)

	lea	eax, DWORD PTR _callback_data$1[ebp]
	push	eax
	mov	DWORD PTR _callback_data$1[ebp], 512	; 00000200H
	mov	WORD PTR _callback_data$1[ebp+14], bx
	call	DWORD PTR _callback$[ebp]
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	$LN32@InputTextF

; 8685 :             return false;
; 8686 :         *p_char = callback_data.EventChar;

	mov	cx, WORD PTR _callback_data$1[ebp+14]
	movzx	eax, cx
	mov	DWORD PTR [esi], eax

; 8687 :         if (!callback_data.EventChar)

	test	cx, cx
	je	$LN32@InputTextF
$LN20@InputTextF:
	pop	esi

; 8688 :             return false;
; 8689 :     }
; 8690 : 
; 8691 :     return true;

	mov	al, 1
	pop	ebx

; 8692 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InputTextFilterCharacter@@YA_NPAIHP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ENDP ; InputTextFilterCharacter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_r_outer$ = -24						; size = 16
_safe_padding$ = -8					; size = 8
_r_outer$8$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_base_pos$ = 12						; size = 4
_r_outer$2$ = 16					; size = 4
_size$ = 16						; size = 4
_last_dir$ = 20						; size = 4
_r_inner$ = 24						; size = 4
?FindBestPopupWindowPos@@YA?AUImVec2@@ABU1@0PAHABUImRect@@@Z PROC ; FindBestPopupWindowPos

; 4582 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 4583 :     const ImGuiStyle& style = GImGui->Style;
; 4584 : 
; 4585 :     // Clamp into visible area while not overlapping the cursor. Safety padding is optional if our popup size won't fit without it.
; 4586 :     ImVec2 safe_padding = style.DisplaySafeAreaPadding;

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	esi
	push	edi
	mov	eax, DWORD PTR [ecx+5432]
	mov	DWORD PTR _safe_padding$[ebp], eax
	mov	eax, DWORD PTR [ecx+5436]
	mov	DWORD PTR _safe_padding$[ebp+4], eax

; 4587 :     ImRect r_outer(GetVisibleRect());

	lea	eax, DWORD PTR _r_outer$[ebp]
	push	eax
	call	?GetVisibleRect@@YA?AUImRect@@XZ	; GetVisibleRect
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 247  :     float       GetHeight() const               { return Max.y-Min.y; }

	movss	xmm6, DWORD PTR _r_outer$[ebp+12]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4587 :     ImRect r_outer(GetVisibleRect());

	add	esp, 4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 247  :     float       GetHeight() const               { return Max.y-Min.y; }

	movss	xmm4, DWORD PTR _r_outer$[ebp+4]
	movaps	xmm0, xmm6
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4588 :     r_outer.Expand(ImVec2((size.x - r_outer.GetWidth() > safe_padding.x*2) ? -safe_padding.x : 0.0f, (size.y - r_outer.GetHeight() > safe_padding.y*2) ? -safe_padding.y : 0.0f));

	mov	esi, DWORD PTR _size$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 247  :     float       GetHeight() const               { return Max.y-Min.y; }

	subss	xmm0, xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4588 :     r_outer.Expand(ImVec2((size.x - r_outer.GetWidth() > safe_padding.x*2) ? -safe_padding.x : 0.0f, (size.y - r_outer.GetHeight() > safe_padding.y*2) ? -safe_padding.y : 0.0f));

	movss	xmm5, DWORD PTR _safe_padding$[ebp+4]
	movss	xmm3, DWORD PTR __real@40000000
	movss	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm1, DWORD PTR [esi+4]
	subss	xmm1, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm3
	comiss	xmm1, xmm0
	jbe	SHORT $LN8@FindBestPo
	xorps	xmm5, xmm2
	jmp	SHORT $LN91@FindBestPo
$LN8@FindBestPo:
	xorps	xmm5, xmm5
$LN91@FindBestPo:
	movss	xmm1, DWORD PTR [esi]
	movss	xmm7, DWORD PTR _safe_padding$[ebp]
	movss	DWORD PTR _r_outer$2$[ebp], xmm5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 246  :     float       GetWidth() const                { return Max.x-Min.x; }

	movss	xmm5, DWORD PTR _r_outer$[ebp+8]
	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR _r_outer$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4588 :     r_outer.Expand(ImVec2((size.x - r_outer.GetWidth() > safe_padding.x*2) ? -safe_padding.x : 0.0f, (size.y - r_outer.GetHeight() > safe_padding.y*2) ? -safe_padding.y : 0.0f));

	subss	xmm1, xmm0
	movaps	xmm0, xmm7
	mulss	xmm0, xmm3
	comiss	xmm1, xmm0
	jbe	SHORT $LN10@FindBestPo
	xorps	xmm7, xmm2
	jmp	SHORT $LN11@FindBestPo
$LN10@FindBestPo:
	xorps	xmm7, xmm7
$LN11@FindBestPo:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 258  :     void        Expand(const ImVec2& amount)    { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }

	movss	xmm1, DWORD PTR _r_outer$2$[ebp]
	movss	xmm2, DWORD PTR _r_outer$[ebp]
	subss	xmm4, xmm1

; 133  : static inline ImVec2 ImClamp(const ImVec2& f, const ImVec2& mn, ImVec2 mx)      { return ImVec2(ImClamp(f.x,mn.x,mx.x), ImClamp(f.y,mn.y,mx.y)); }

	mov	eax, DWORD PTR _base_pos$[ebp]

; 258  :     void        Expand(const ImVec2& amount)    { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }

	addss	xmm1, xmm6
	subss	xmm2, xmm7
	addss	xmm7, xmm5

; 133  : static inline ImVec2 ImClamp(const ImVec2& f, const ImVec2& mn, ImVec2 mx)      { return ImVec2(ImClamp(f.x,mn.x,mx.x), ImClamp(f.y,mn.y,mx.y)); }

	movss	xmm0, DWORD PTR [eax+4]

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm4, xmm0

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movaps	xmm5, xmm1

; 258  :     void        Expand(const ImVec2& amount)    { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }

	movss	DWORD PTR _r_outer$8$[ebp], xmm2

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm5, DWORD PTR [esi+4]
	movaps	xmm6, xmm7

; 258  :     void        Expand(const ImVec2& amount)    { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }

	movss	DWORD PTR _r_outer$2$[ebp], xmm1

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm6, DWORD PTR [esi]

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	jbe	SHORT $LN48@FindBestPo
	movaps	xmm5, xmm4
	jmp	SHORT $LN49@FindBestPo
$LN48@FindBestPo:
	minss	xmm5, xmm0
$LN49@FindBestPo:

; 133  : static inline ImVec2 ImClamp(const ImVec2& f, const ImVec2& mn, ImVec2 mx)      { return ImVec2(ImClamp(f.x,mn.x,mx.x), ImClamp(f.y,mn.y,mx.y)); }

	movss	xmm0, DWORD PTR [eax]

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm2, xmm0
	jbe	SHORT $LN54@FindBestPo
	movaps	xmm6, xmm2
	jmp	SHORT $LN55@FindBestPo
$LN54@FindBestPo:
	minss	xmm6, xmm0
$LN55@FindBestPo:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4591 :     for (int n = (*last_dir != -1) ? -1 : 0; n < 4; n++)   // Last, Right, down, up, left. (Favor last used direction).

	mov	eax, DWORD PTR _last_dir$[ebp]

; 4594 :         ImRect rect(dir == 0 ? r_inner.Max.x : r_outer.Min.x, dir == 1 ? r_inner.Max.y : r_outer.Min.y, dir == 3 ? r_inner.Min.x : r_outer.Max.x, dir == 2 ? r_inner.Min.y : r_outer.Max.y);

	mov	edx, DWORD PTR _r_inner$[ebp]
	mov	edi, DWORD PTR [eax]
	lea	ecx, DWORD PTR [edi+1]
	neg	ecx
	sbb	ecx, ecx
$LL4@FindBestPo:

; 4592 :     {
; 4593 :         const int dir = (n == -1) ? *last_dir : n;

	cmp	ecx, -1
	mov	eax, ecx
	cmove	eax, edi

; 4594 :         ImRect rect(dir == 0 ? r_inner.Max.x : r_outer.Min.x, dir == 1 ? r_inner.Max.y : r_outer.Min.y, dir == 3 ? r_inner.Min.x : r_outer.Max.x, dir == 2 ? r_inner.Min.y : r_outer.Max.y);

	cmp	eax, 2
	jne	SHORT $LN14@FindBestPo
	movss	xmm3, DWORD PTR [edx+4]
	movaps	xmm1, xmm7
	movaps	xmm0, xmm4
	jmp	SHORT $LN20@FindBestPo
$LN14@FindBestPo:
	movaps	xmm3, xmm1
	cmp	eax, 3
	jne	SHORT $LN16@FindBestPo
	movss	xmm1, DWORD PTR [edx]
	movaps	xmm0, xmm4
	jmp	SHORT $LN20@FindBestPo
$LN16@FindBestPo:
	movaps	xmm1, xmm7
	cmp	eax, 1
	jne	SHORT $LN18@FindBestPo
	movss	xmm0, DWORD PTR [edx+12]
	jmp	SHORT $LN20@FindBestPo
$LN18@FindBestPo:
	movaps	xmm0, xmm4
	test	eax, eax
	jne	SHORT $LN20@FindBestPo
	movss	xmm2, DWORD PTR [edx+8]
$LN20@FindBestPo:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 246  :     float       GetWidth() const                { return Max.x-Min.x; }

	subss	xmm1, xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4595 :         if (rect.GetWidth() < size.x || rect.GetHeight() < size.y)

	movss	xmm2, DWORD PTR [esi]
	comiss	xmm2, xmm1
	ja	SHORT $LN2@FindBestPo
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 247  :     float       GetHeight() const               { return Max.y-Min.y; }

	subss	xmm3, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4595 :         if (rect.GetWidth() < size.x || rect.GetHeight() < size.y)

	movss	xmm0, DWORD PTR [esi+4]
	comiss	xmm0, xmm3
	jbe	SHORT $LN5@FindBestPo
$LN2@FindBestPo:

; 4591 :     for (int n = (*last_dir != -1) ? -1 : 0; n < 4; n++)   // Last, Right, down, up, left. (Favor last used direction).

	inc	ecx
	cmp	ecx, 4
	jge	$LN90@FindBestPo
	movss	xmm1, DWORD PTR _r_outer$2$[ebp]
	movss	xmm2, DWORD PTR _r_outer$8$[ebp]
	jmp	SHORT $LL4@FindBestPo
$LN5@FindBestPo:

; 4596 :             continue;
; 4597 :         *last_dir = dir;

	mov	ecx, DWORD PTR _last_dir$[ebp]
	mov	DWORD PTR [ecx], eax

; 4598 :         return ImVec2(dir == 0 ? r_inner.Max.x : dir == 3 ? r_inner.Min.x - size.x : base_pos_clamped.x, dir == 1 ? r_inner.Max.y : dir == 2 ? r_inner.Min.y - size.y : base_pos_clamped.y);

	cmp	eax, 1
	jne	SHORT $LN24@FindBestPo
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4598 :         return ImVec2(dir == 0 ? r_inner.Max.x : dir == 3 ? r_inner.Min.x - size.x : base_pos_clamped.x, dir == 1 ? r_inner.Max.y : dir == 2 ? r_inner.Min.y - size.y : base_pos_clamped.y);

	movss	xmm5, DWORD PTR [edx+12]
	pop	edi
	pop	esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax], xmm6
	movss	DWORD PTR [eax+4], xmm5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4607 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@FindBestPo:

; 4598 :         return ImVec2(dir == 0 ? r_inner.Max.x : dir == 3 ? r_inner.Min.x - size.x : base_pos_clamped.x, dir == 1 ? r_inner.Max.y : dir == 2 ? r_inner.Min.y - size.y : base_pos_clamped.y);

	cmp	eax, 2
	jne	SHORT $LN22@FindBestPo
	movss	xmm5, DWORD PTR [edx+4]
	subss	xmm5, DWORD PTR [esi+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	movss	DWORD PTR [eax], xmm6
	movss	DWORD PTR [eax+4], xmm5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4607 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN22@FindBestPo:

; 4598 :         return ImVec2(dir == 0 ? r_inner.Max.x : dir == 3 ? r_inner.Min.x - size.x : base_pos_clamped.x, dir == 1 ? r_inner.Max.y : dir == 2 ? r_inner.Min.y - size.y : base_pos_clamped.y);

	test	eax, eax
	jne	SHORT $LN28@FindBestPo
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4598 :         return ImVec2(dir == 0 ? r_inner.Max.x : dir == 3 ? r_inner.Min.x - size.x : base_pos_clamped.x, dir == 1 ? r_inner.Max.y : dir == 2 ? r_inner.Min.y - size.y : base_pos_clamped.y);

	movss	xmm6, DWORD PTR [edx+8]
	pop	edi
	pop	esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax], xmm6
	movss	DWORD PTR [eax+4], xmm5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4607 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@FindBestPo:

; 4598 :         return ImVec2(dir == 0 ? r_inner.Max.x : dir == 3 ? r_inner.Min.x - size.x : base_pos_clamped.x, dir == 1 ? r_inner.Max.y : dir == 2 ? r_inner.Min.y - size.y : base_pos_clamped.y);

	cmp	eax, 3
	jne	SHORT $LN26@FindBestPo
	movss	xmm6, DWORD PTR [edx]
	subss	xmm6, DWORD PTR [esi]
$LN26@FindBestPo:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	movss	DWORD PTR [eax], xmm6
	movss	DWORD PTR [eax+4], xmm5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4607 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN90@FindBestPo:

; 4602 :     *last_dir = -1;

	mov	eax, DWORD PTR _last_dir$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 128  : static inline float  ImMax(float lhs, float rhs)                                { return lhs >= rhs ? lhs : rhs; }

	movss	xmm1, DWORD PTR _r_outer$8$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4602 :     *last_dir = -1;

	mov	DWORD PTR [eax], -1

; 4603 :     ImVec2 pos = base_pos;
; 4604 :     pos.x = ImMax(ImMin(pos.x + size.x, r_outer.Max.x) - size.x, r_outer.Min.x);

	mov	eax, DWORD PTR _base_pos$[ebp]
	movss	xmm2, DWORD PTR [esi]
	addss	xmm2, DWORD PTR [eax]
	minss	xmm2, xmm7
	subss	xmm2, DWORD PTR [esi]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 128  : static inline float  ImMax(float lhs, float rhs)                                { return lhs >= rhs ? lhs : rhs; }

	comiss	xmm2, xmm1
	jae	SHORT $LN77@FindBestPo
	movaps	xmm2, xmm1
$LN77@FindBestPo:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4605 :     pos.y = ImMax(ImMin(pos.y + size.y, r_outer.Max.y) - size.y, r_outer.Min.y);

	movss	xmm1, DWORD PTR [esi+4]
	addss	xmm1, DWORD PTR [eax+4]
	minss	xmm1, DWORD PTR _r_outer$2$[ebp]
	subss	xmm1, DWORD PTR [esi+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 128  : static inline float  ImMax(float lhs, float rhs)                                { return lhs >= rhs ? lhs : rhs; }

	comiss	xmm1, xmm4
	jae	SHORT $LN85@FindBestPo
	movaps	xmm1, xmm4
$LN85@FindBestPo:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	movss	DWORD PTR [eax], xmm2
	movss	DWORD PTR [eax+4], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4607 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FindBestPopupWindowPos@@YA?AUImVec2@@ABU1@0PAHABUImRect@@@Z ENDP ; FindBestPopupWindowPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?GetFrontMostModalRootWindow@@YAPAUImGuiWindow@@XZ PROC	; GetFrontMostModalRootWindow

; 4311 :     ImGuiContext& g = *GImGui;

	mov	edx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 4312 :     for (int n = g.OpenPopupStack.Size-1; n >= 0; n--)

	mov	eax, DWORD PTR [edx+6356]
	sub	eax, 1
	js	SHORT $LN13@GetFrontMo

; 4313 :         if (ImGuiWindow* front_most_popup = g.OpenPopupStack.Data[n].Window)

	mov	edx, DWORD PTR [edx+6364]
	mov	ecx, eax
	shl	ecx, 5
	add	edx, 4
	add	ecx, edx
$LL4@GetFrontMo:
	mov	edx, DWORD PTR [ecx]
	test	edx, edx
	je	SHORT $LN2@GetFrontMo

; 4314 :             if (front_most_popup->Flags & ImGuiWindowFlags_Modal)

	test	DWORD PTR [edx+8], 67108864		; 04000000H
	jne	SHORT $LN9@GetFrontMo
$LN2@GetFrontMo:

; 4312 :     for (int n = g.OpenPopupStack.Size-1; n >= 0; n--)

	sub	ecx, 32					; 00000020H
	sub	eax, 1
	jns	SHORT $LL4@GetFrontMo
$LN13@GetFrontMo:

; 4316 :     return NULL;

	xor	eax, eax

; 4317 : }

	ret	0
$LN9@GetFrontMo:

; 4315 :                 return front_most_popup;

	mov	eax, edx

; 4317 : }

	ret	0
?GetFrontMostModalRootWindow@@YAPAUImGuiWindow@@XZ ENDP	; GetFrontMostModalRootWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_id$ = 8						; size = 4
?IsPopupOpen@@YA_NI@Z PROC				; IsPopupOpen

; 4246 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 4247 :     ImGuiContext& g = *GImGui;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 4248 :     return g.OpenPopupStack.Size > g.CurrentPopupStack.Size && g.OpenPopupStack[g.CurrentPopupStack.Size].PopupId == id;

	mov	ecx, DWORD PTR [eax+6368]
	cmp	DWORD PTR [eax+6356], ecx
	jle	SHORT $LN3@IsPopupOpe
	mov	eax, DWORD PTR [eax+6364]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	shl	ecx, 5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4248 :     return g.OpenPopupStack.Size > g.CurrentPopupStack.Size && g.OpenPopupStack[g.CurrentPopupStack.Size].PopupId == id;

	mov	eax, DWORD PTR [ecx+eax]
	cmp	eax, DWORD PTR _id$[ebp]
	jne	SHORT $LN3@IsPopupOpe
	mov	al, 1

; 4249 : }

	pop	ebp
	ret	0
$LN3@IsPopupOpe:

; 4248 :     return g.OpenPopupStack.Size > g.CurrentPopupStack.Size && g.OpenPopupStack[g.CurrentPopupStack.Size].PopupId == id;

	xor	al, al

; 4249 : }

	pop	ebp
	ret	0
?IsPopupOpen@@YA_NI@Z ENDP				; IsPopupOpen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_id$ = 8						; size = 4
?ClosePopup@@YAXI@Z PROC				; ClosePopup

; 4330 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 4331 :     if (!IsPopupOpen(id))

	push	DWORD PTR _id$[ebp]
	call	?IsPopupOpen@@YA_NI@Z			; IsPopupOpen
	add	esp, 4
	test	al, al
	je	SHORT $LN1@ClosePopup

; 4332 :         return;
; 4333 :     ImGuiContext& g = *GImGui;
; 4334 :     ClosePopupToLevel(g.OpenPopupStack.Size - 1);

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [eax+6356]
	dec	eax
	mov	DWORD PTR _id$[ebp], eax

; 4335 : }

	pop	ebp

; 4332 :         return;
; 4333 :     ImGuiContext& g = *GImGui;
; 4334 :     ClosePopupToLevel(g.OpenPopupStack.Size - 1);

	jmp	?ClosePopupToLevel@@YAXH@Z		; ClosePopupToLevel
$LN1@ClosePopup:

; 4335 : }

	pop	ebp
	ret	0
?ClosePopup@@YAXI@Z ENDP				; ClosePopup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_remaining$ = 8						; size = 4
?ClosePopupToLevel@@YAXH@Z PROC				; ClosePopupToLevel

; 4320 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 4321 :     ImGuiContext& g = *GImGui;
; 4322 :     if (remaining > 0)

	mov	esi, DWORD PTR _remaining$[ebp]
	push	edi
	mov	edi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 4323 :         ImGui::FocusWindow(g.OpenPopupStack[remaining-1].Window);

	mov	eax, DWORD PTR [edi+6364]
	test	esi, esi
	jle	SHORT $LN2@ClosePopup
	mov	ecx, esi
	shl	ecx, 5
	push	DWORD PTR [eax+ecx-28]

; 4324 :     else

	jmp	SHORT $LN9@ClosePopup
$LN2@ClosePopup:

; 4325 :         ImGui::FocusWindow(g.OpenPopupStack[0].ParentWindow);

	push	DWORD PTR [eax+8]
$LN9@ClosePopup:
	call	?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusWindow
	add	esp, 4

; 4326 :     g.OpenPopupStack.resize(remaining);

	lea	ecx, DWORD PTR [edi+6356]
	push	esi
	call	?resize@?$ImVector@UImGuiPopupRef@@@@QAEXH@Z ; ImVector<ImGuiPopupRef>::resize
	pop	edi
	pop	esi

; 4327 : }

	pop	ebp
	ret	0
?ClosePopupToLevel@@YAXH@Z ENDP				; ClosePopupToLevel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
tv381 = -16						; size = 4
$T1 = -12						; size = 4
tv379 = -8						; size = 4
tv378 = -4						; size = 4
?CloseInactivePopups@@YAXXZ PROC			; CloseInactivePopups

; 4279 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 4280 :     ImGuiContext& g = *GImGui;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	lea	edx, DWORD PTR [eax+6356]
	push	edi
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR tv381[ebp], edx
	mov	DWORD PTR $T1[ebp], edi
	test	edi, edi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4281 :     if (g.OpenPopupStack.empty())

	je	$LN13@CloseInact

; 4282 :         return;
; 4283 : 
; 4284 :     // When popups are stacked, clicking on a lower level popups puts focus back to it and close popups above it.
; 4285 :     // Don't close our own child popup windows
; 4286 :     int n = 0;
; 4287 :     if (g.NavWindow)

	mov	ecx, DWORD PTR [eax+6380]
	push	esi
	xor	esi, esi
	mov	DWORD PTR tv379[ebp], ecx
	test	ecx, ecx
	je	SHORT $LN27@CloseInact

; 4288 :     {
; 4289 :         for (n = 0; n < g.OpenPopupStack.Size; n++)

	test	edi, edi
	jle	SHORT $LN27@CloseInact
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	mov	eax, DWORD PTR [eax+6364]
	push	ebx
	mov	DWORD PTR tv378[ebp], eax
	lea	ebx, DWORD PTR [eax+4]
$LL4@CloseInact:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4292 :             if (!popup.Window)

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN2@CloseInact

; 4293 :                 continue;
; 4294 :             IM_ASSERT((popup.Window->Flags & ImGuiWindowFlags_Popup) != 0);
; 4295 :             if (popup.Window->Flags & ImGuiWindowFlags_ChildWindow)

	test	DWORD PTR [eax+8], 4194304		; 00400000H
	jne	SHORT $LN2@CloseInact

; 4296 :                 continue;
; 4297 : 
; 4298 :             bool has_focus = false;

	xor	al, al

; 4299 :             for (int m = n; m < g.OpenPopupStack.Size && !has_focus; m++)

	mov	edx, esi
	cmp	esi, edi
	jge	SHORT $LN34@CloseInact

; 4288 :     {
; 4289 :         for (n = 0; n < g.OpenPopupStack.Size; n++)

	mov	ecx, esi
	shl	ecx, 5
$LL7@CloseInact:

; 4299 :             for (int m = n; m < g.OpenPopupStack.Size && !has_focus; m++)

	test	al, al
	jne	SHORT $LN2@CloseInact

; 4300 :                 has_focus = (g.OpenPopupStack[m].Window && g.OpenPopupStack[m].Window->RootWindow == g.NavWindow->RootWindow);

	mov	eax, DWORD PTR tv378[ebp]
	mov	eax, DWORD PTR [ecx+eax+4]
	test	eax, eax
	je	SHORT $LN15@CloseInact
	mov	edi, DWORD PTR tv379[ebp]
	mov	eax, DWORD PTR [eax+632]
	cmp	eax, DWORD PTR [edi+632]
	mov	edi, DWORD PTR $T1[ebp]
	jne	SHORT $LN15@CloseInact
	mov	al, 1
	jmp	SHORT $LN16@CloseInact
$LN15@CloseInact:
	xor	al, al
$LN16@CloseInact:

; 4299 :             for (int m = n; m < g.OpenPopupStack.Size && !has_focus; m++)

	inc	edx
	add	ecx, 32					; 00000020H
	cmp	edx, edi
	jl	SHORT $LL7@CloseInact

; 4301 :             if (!has_focus)

	test	al, al
	je	SHORT $LN34@CloseInact
$LN2@CloseInact:

; 4288 :     {
; 4289 :         for (n = 0; n < g.OpenPopupStack.Size; n++)

	inc	esi
	add	ebx, 32					; 00000020H
	cmp	esi, edi
	jl	SHORT $LL4@CloseInact
$LN34@CloseInact:
	mov	edx, DWORD PTR tv381[ebp]
	pop	ebx
$LN27@CloseInact:

; 4302 :                 break;
; 4303 :         }
; 4304 :     }
; 4305 :     if (n < g.OpenPopupStack.Size)   // This test is not required but it allows to set a useful breakpoint on the line below

	cmp	esi, edi
	jge	SHORT $LN35@CloseInact

; 4306 :         g.OpenPopupStack.resize(n);

	push	esi
	mov	ecx, edx
	call	?resize@?$ImVector@UImGuiPopupRef@@@@QAEXH@Z ; ImVector<ImGuiPopupRef>::resize
$LN35@CloseInact:
	pop	esi
$LN13@CloseInact:
	pop	edi

; 4307 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CloseInactivePopups@@YAXXZ ENDP			; CloseInactivePopups
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_name$ = -24						; size = 20
_window$1$ = -4						; size = 4
_str_id$ = 8						; size = 4
_extra_flags$ = 12					; size = 4
?BeginPopupEx@@YA_NPBDH@Z PROC				; BeginPopupEx

; 4357 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	edi

; 4358 :     ImGuiContext& g = *GImGui;

	mov	edi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 4359 :     ImGuiWindow* window = g.CurrentWindow;
; 4360 :     const ImGuiID id = window->GetID(str_id);

	push	0
	push	DWORD PTR _str_id$[ebp]
	mov	eax, DWORD PTR [edi+6240]
	mov	ecx, eax
	mov	DWORD PTR _window$1$[ebp], eax
	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID
	mov	ebx, eax

; 4361 :     if (!IsPopupOpen(id))

	push	ebx
	call	?IsPopupOpen@@YA_NI@Z			; IsPopupOpen
	add	esp, 4
	test	al, al
	jne	SHORT $LN2@BeginPopup

; 4351 :     ImGuiContext& g = *GImGui;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	pop	edi
	pop	ebx

; 4352 :     g.SetNextWindowPosCond = g.SetNextWindowSizeCond = g.SetNextWindowContentSizeCond = g.SetNextWindowCollapsedCond = 0;

	mov	DWORD PTR [eax+6560], 0
	mov	DWORD PTR [eax+6556], 0
	mov	DWORD PTR [eax+6552], 0
	mov	DWORD PTR [eax+6548], 0

; 4353 :     g.SetNextWindowSizeConstraint = g.SetNextWindowFocus = false;

	mov	WORD PTR [eax+6588], 0

; 4362 :     {
; 4363 :         ClearSetNextWindowData(); // We behave like Begin() and need to consume those values
; 4364 :         return false;

	xor	al, al

; 4383 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@BeginPopup:
	push	esi

; 4365 :     }
; 4366 : 
; 4367 :     ImGui::PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);

	push	ecx
	mov	DWORD PTR [esp], 0
	push	2
	call	?PushStyleVar@ImGui@@YAXHM@Z		; ImGui::PushStyleVar

; 4368 :     ImGuiWindowFlags flags = extra_flags|ImGuiWindowFlags_Popup|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoMove|ImGuiWindowFlags_NoResize|ImGuiWindowFlags_NoSavedSettings|ImGuiWindowFlags_AlwaysAutoResize;

	mov	esi, DWORD PTR _extra_flags$[ebp]

; 4369 : 
; 4370 :     char name[20];
; 4371 :     if (flags & ImGuiWindowFlags_ChildMenu)
; 4372 :         ImFormatString(name, IM_ARRAYSIZE(name), "##menu_%d", g.CurrentPopupStack.Size);    // Recycle windows based on depth

	lea	eax, DWORD PTR _name$[ebp]
	or	esi, 33554759				; 02000147H
	add	esp, 8
	test	esi, 134217728				; 08000000H
	je	SHORT $LN3@BeginPopup
	push	DWORD PTR [edi+6368]
	push	OFFSET $SG117717

; 4373 :     else

	jmp	SHORT $LN10@BeginPopup
$LN3@BeginPopup:

; 4374 :         ImFormatString(name, IM_ARRAYSIZE(name), "##popup_%08x", id); // Not recycling, so we can close/open during the same frame

	push	ebx
	push	OFFSET $SG117718
$LN10@BeginPopup:
	push	20					; 00000014H
	push	eax
	call	?ImFormatString@@YAHPADHPBDZZ		; ImFormatString
	add	esp, 16					; 00000010H

; 4375 : 
; 4376 :     bool is_open = ImGui::Begin(name, NULL, flags);

	lea	eax, DWORD PTR _name$[ebp]
	push	esi
	push	0
	push	eax
	call	?Begin@ImGui@@YA_NPBDPA_NH@Z		; ImGui::Begin
	mov	bl, al
	add	esp, 12					; 0000000cH

; 4377 :     if (!(window->Flags & ImGuiWindowFlags_ShowBorders))

	mov	eax, DWORD PTR _window$1$[ebp]
	pop	esi
	test	BYTE PTR [eax+8], 128			; 00000080H
	jne	SHORT $LN5@BeginPopup

; 4378 :         g.CurrentWindow->Flags &= ~ImGuiWindowFlags_ShowBorders;

	mov	ecx, DWORD PTR [edi+6240]
	and	DWORD PTR [ecx+8], -129			; ffffff7fH
$LN5@BeginPopup:

; 4379 :     if (!is_open) // NB: is_open can be 'false' when the popup is completely clipped (e.g. zero size display)

	test	bl, bl
	jne	SHORT $LN6@BeginPopup

; 4380 :         ImGui::EndPopup();

	call	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup
$LN6@BeginPopup:
	pop	edi

; 4381 : 
; 4382 :     return is_open;

	mov	al, bl
	pop	ebx

; 4383 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?BeginPopupEx@@YA_NPBDH@Z ENDP				; BeginPopupEx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetVisibleRect@@YA?AUImRect@@XZ PROC			; GetVisibleRect

; 4226 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 4227 :     ImGuiContext& g = *GImGui;

	mov	edx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 4228 :     if (g.IO.DisplayVisibleMin.x != g.IO.DisplayVisibleMax.x && g.IO.DisplayVisibleMin.y != g.IO.DisplayVisibleMax.y)

	movss	xmm0, DWORD PTR [edx+156]
	ucomiss	xmm0, DWORD PTR [edx+164]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@GetVisible
	movss	xmm0, DWORD PTR [edx+160]
	ucomiss	xmm0, DWORD PTR [edx+168]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@GetVisible
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [edx+156]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+160]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+164]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+168]
	mov	DWORD PTR [eax+12], ecx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4231 : }

	pop	ebp
	ret	0
$LN2@GetVisible:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4230 :     return ImRect(0.0f, 0.0f, g.IO.DisplaySize.x, g.IO.DisplaySize.y);

	movss	xmm1, DWORD PTR [edx+4]
	movss	xmm2, DWORD PTR [edx+8]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	movss	DWORD PTR [eax+8], xmm1
	movss	DWORD PTR [eax+12], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4231 : }

	pop	ebp
	ret	0
?GetVisibleRect@@YA?AUImRect@@XZ ENDP			; GetVisibleRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -16						; size = 8
$T2 = -8						; size = 8
_f$ = -4						; size = 4
tv182 = 8						; size = 4
tv177 = 8						; size = 4
tv175 = 8						; size = 4
_column_index$ = 8					; size = 4
?PushColumnClipRect@@YAXH@Z PROC			; PushColumnClipRect

; 10510: {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10510: {

	sub	esp, 16					; 00000010H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	push	esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10512:     if (column_index < 0)

	mov	esi, DWORD PTR _column_index$[ebp]
	push	edi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	BYTE PTR [eax+134], 1
	mov	edi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10512:     if (column_index < 0)

	test	esi, esi
	jns	SHORT $LN2@PushColumn

; 10513:         column_index = window->DC.ColumnsCurrent;

	mov	esi, DWORD PTR [edi+412]
$LN2@PushColumn:

; 10514: 
; 10515:     float x1 = ImFloor(0.5f + window->Pos.x + ImGui::GetColumnOffset(column_index) - 1.0f);

	push	esi
	call	?GetColumnOffset@ImGui@@YAMH@Z		; ImGui::GetColumnOffset
	movss	xmm0, DWORD PTR [edi+24]

; 10516:     float x2 = ImFloor(0.5f + window->Pos.x + ImGui::GetColumnOffset(column_index+1) - 1.0f);

	lea	eax, DWORD PTR [esi+1]
	addss	xmm0, DWORD PTR __real@3f000000
	push	eax
	movss	DWORD PTR tv182[ebp], xmm0
	fadd	DWORD PTR tv182[ebp]
	fld1
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _f$[ebp]
	call	?GetColumnOffset@ImGui@@YAMH@Z		; ImGui::GetColumnOffset
	movss	xmm0, DWORD PTR [edi+24]
	addss	xmm0, DWORD PTR __real@3f000000

; 10517:     ImGui::PushClipRect(ImVec2(x1,-FLT_MAX), ImVec2(x2,+FLT_MAX), true);

	push	1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp+4], 2139095039	; 7f7fffffH
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10516:     float x2 = ImFloor(0.5f + window->Pos.x + ImGui::GetColumnOffset(column_index+1) - 1.0f);

	movss	DWORD PTR tv177[ebp], xmm0
	fadd	DWORD PTR tv177[ebp]
	fld1
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR tv175[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 140  : static inline float  ImFloor(float f)                                           { return (float)(int)f; }

	cvttss2si eax, DWORD PTR tv175[ebp]
	movd	xmm0, eax
	cvttss2si eax, DWORD PTR _f$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T2[ebp+4], -8388609		; ff7fffffH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 140  : static inline float  ImFloor(float f)                                           { return (float)(int)f; }

	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm0
	movd	xmm0, eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10517:     ImGui::PushClipRect(ImVec2(x1,-FLT_MAX), ImVec2(x2,+FLT_MAX), true);

	lea	eax, DWORD PTR $T1[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 140  : static inline float  ImFloor(float f)                                           { return (float)(int)f; }

	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10517:     ImGui::PushClipRect(ImVec2(x1,-FLT_MAX), ImVec2(x2,+FLT_MAX), true);

	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10517:     ImGui::PushClipRect(ImVec2(x1,-FLT_MAX), ImVec2(x2,+FLT_MAX), true);

	call	?PushClipRect@ImGui@@YAXABUImVec2@@0_N@Z ; ImGui::PushClipRect
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi

; 10518: }

	mov	esp, ebp
	pop	ebp
	ret	0
?PushColumnClipRect@@YAXH@Z ENDP			; PushColumnClipRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_window$ = 8						; size = 4
?MarkIniSettingsDirty@@YAXPAUImGuiWindow@@@Z PROC	; MarkIniSettingsDirty

; 3300 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 3301 :     ImGuiContext& g = *GImGui;
; 3302 :     if (!(window->Flags & ImGuiWindowFlags_NoSavedSettings))

	mov	eax, DWORD PTR _window$[ebp]
	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	test	DWORD PTR [eax+8], 256			; 00000100H
	jne	SHORT $LN3@MarkIniSet

; 3303 :         if (g.SettingsDirtyTimer <= 0.0f)

	xorps	xmm0, xmm0
	comiss	xmm0, DWORD PTR [ecx+6316]
	jb	SHORT $LN3@MarkIniSet

; 3304 :             g.SettingsDirtyTimer = g.IO.IniSavingRate;

	mov	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR [ecx+6316], eax
$LN3@MarkIniSet:

; 3305 : }

	pop	ebp
	ret	0
?MarkIniSettingsDirty@@YAXPAUImGuiWindow@@@Z ENDP	; MarkIniSettingsDirty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 8
$T2 = -8						; size = 8
_name$ = 8						; size = 4
?AddWindowSettings@@YAPAUImGuiIniData@@PBD@Z PROC	; AddWindowSettings

; 3199 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx

; 3200 :     GImGui->Settings.resize(GImGui->Settings.Size + 1);

	mov	ebx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	esi
	push	edi
	mov	esi, DWORD PTR [ebx+6304]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	edi, DWORD PTR [ebx+6308]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3200 :     GImGui->Settings.resize(GImGui->Settings.Size + 1);

	inc	esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	cmp	esi, edi
	jle	SHORT $LN4@AddWindowS

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	edi, edi
	je	SHORT $LN8@AddWindowS
	mov	eax, edi
	cdq
	sub	eax, edx
	mov	ecx, eax
	sar	ecx, 1
	add	ecx, edi
	jmp	SHORT $LN9@AddWindowS
$LN8@AddWindowS:
	mov	ecx, 8
$LN9@AddWindowS:
	cmp	ecx, esi
	mov	eax, esi
	cmovg	eax, ecx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	lea	ecx, DWORD PTR [ebx+6304]
	push	eax
	call	?reserve@?$ImVector@UImGuiIniData@@@@QAEXH@Z ; ImVector<ImGuiIniData>::reserve
$LN4@AddWindowS:
	mov	DWORD PTR [ebx+6304], esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3201 :     ImGuiIniData* ini = &GImGui->Settings.back();

	mov	edx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 3202 :     ini->Name = ImStrdup(name);

	mov	esi, DWORD PTR _name$[ebp]
	push	esi
	mov	eax, DWORD PTR [edx+6304]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR [edx+6312]
	lea	edi, DWORD PTR [eax+ecx*4]
	call	?ImStrdup@@YAPADPBD@Z			; ImStrdup

; 3203 :     ini->Id = ImHash(name, 0);

	push	0
	push	0
	push	esi
	mov	DWORD PTR [edi-28], eax
	call	?ImHash@@YAIPBXHI@Z			; ImHash
	mov	DWORD PTR [edi-24], eax
	add	esp, 16					; 00000010H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T2[ebp], 2139095039		; 7f7fffffH
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3205 :     ini->Pos = ImVec2(FLT_MAX,FLT_MAX);

	mov	eax, DWORD PTR $T2[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T2[ebp+4], 2139095039	; 7f7fffffH
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3205 :     ini->Pos = ImVec2(FLT_MAX,FLT_MAX);

	mov	ecx, DWORD PTR $T2[ebp+4]
	mov	DWORD PTR [edi-16], ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3206 :     ini->Size = ImVec2(0,0);

	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [edi-12], ecx
	mov	DWORD PTR [edi-20], eax

; 3207 :     return ini;

	lea	eax, DWORD PTR [edi-28]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3206 :     ini->Size = ImVec2(0,0);

	mov	ecx, DWORD PTR $T1[ebp+4]
	mov	BYTE PTR [edi-4], 0
	mov	DWORD PTR [edi-8], ecx
	pop	edi
	pop	esi
	pop	ebx

; 3208 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AddWindowSettings@@YAPAUImGuiIniData@@PBD@Z ENDP	; AddWindowSettings
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_name$ = 8						; size = 4
?FindWindowSettings@@YAPAUImGuiIniData@@PBD@Z PROC	; FindWindowSettings

; 3186 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 3187 :     ImGuiContext& g = *GImGui;

	mov	edi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 3188 :     ImGuiID id = ImHash(name, 0);

	push	0
	push	0
	push	DWORD PTR _name$[ebp]
	call	?ImHash@@YAIPBXHI@Z			; ImHash
	mov	edx, DWORD PTR [edi+6304]
	add	esp, 12					; 0000000cH

; 3189 :     for (int i = 0; i != g.Settings.Size; i++)

	xor	ecx, ecx
	mov	esi, eax
	test	edx, edx
	je	SHORT $LN3@FindWindow
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	mov	eax, DWORD PTR [edi+6312]
$LL4@FindWindow:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3192 :         if (ini->Id == id)

	cmp	DWORD PTR [eax+4], esi
	je	SHORT $LN1@FindWindow

; 3189 :     for (int i = 0; i != g.Settings.Size; i++)

	inc	ecx
	add	eax, 28					; 0000001cH
	cmp	ecx, edx
	jne	SHORT $LL4@FindWindow
$LN3@FindWindow:

; 3193 :             return ini;
; 3194 :     }
; 3195 :     return NULL;

	xor	eax, eax
$LN1@FindWindow:
	pop	edi
	pop	esi

; 3196 : }

	pop	ebp
	ret	0
?FindWindowSettings@@YAPAUImGuiIniData@@PBD@Z ENDP	; FindWindowSettings
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_out_sorted_windows$ = 8				; size = 4
_window$ = 12						; size = 4
?AddWindowToSortedBuffer@@YAXAAV?$ImVector@PAUImGuiWindow@@@@PAUImGuiWindow@@@Z PROC ; AddWindowToSortedBuffer

; 3322 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 3323 :     out_sorted_windows.push_back(window);

	mov	ecx, DWORD PTR _out_sorted_windows$[ebp]
	lea	eax, DWORD PTR _window$[ebp]
	push	ebx
	push	eax
	call	?push_back@?$ImVector@PAUImGuiWindow@@@@QAEXABQAUImGuiWindow@@@Z ; ImVector<ImGuiWindow *>::push_back

; 3324 :     if (window->Active)

	mov	ebx, DWORD PTR _window$[ebp]
	cmp	BYTE PTR [ebx+132], 0
	je	SHORT $LN3@AddWindowT

; 3325 :     {
; 3326 :         int count = window->DC.ChildWindows.Size;

	push	edi
	mov	edi, DWORD PTR [ebx+292]

; 3327 :         if (count > 1)

	cmp	edi, 1
	jle	SHORT $LN6@AddWindowT

; 3328 :             qsort(window->DC.ChildWindows.begin(), (size_t)count, sizeof(ImGuiWindow*), ChildWindowComparer);

	push	OFFSET ?ChildWindowComparer@@YAHPBX0@Z	; ChildWindowComparer
	push	4
	push	edi
	push	DWORD PTR [ebx+300]
	call	DWORD PTR __imp__qsort
	add	esp, 16					; 00000010H
$LN6@AddWindowT:

; 3329 :         for (int i = 0; i < count; i++)

	push	esi
	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN18@AddWindowT
	npad	8
$LL4@AddWindowT:

; 3330 :         {
; 3331 :             ImGuiWindow* child = window->DC.ChildWindows[i];

	mov	eax, DWORD PTR [ebx+300]
	mov	eax, DWORD PTR [eax+esi*4]

; 3332 :             if (child->Active)

	cmp	BYTE PTR [eax+132], 0
	je	SHORT $LN2@AddWindowT

; 3333 :                 AddWindowToSortedBuffer(out_sorted_windows, child);

	push	eax
	push	DWORD PTR _out_sorted_windows$[ebp]
	call	?AddWindowToSortedBuffer@@YAXAAV?$ImVector@PAUImGuiWindow@@@@PAUImGuiWindow@@@Z ; AddWindowToSortedBuffer
	add	esp, 8
$LN2@AddWindowT:

; 3329 :         for (int i = 0; i < count; i++)

	inc	esi
	cmp	esi, edi
	jl	SHORT $LL4@AddWindowT
$LN18@AddWindowT:
	pop	esi
	pop	edi
$LN3@AddWindowT:
	pop	ebx

; 3334 :         }
; 3335 :     }
; 3336 : }

	pop	ebp
	ret	0
?AddWindowToSortedBuffer@@YAXAAV?$ImVector@PAUImGuiWindow@@@@PAUImGuiWindow@@@Z ENDP ; AddWindowToSortedBuffer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_out_render_list$ = 8					; size = 4
_window$ = 12						; size = 4
?AddWindowToRenderList@@YAXAAV?$ImVector@PAUImDrawList@@@@PAUImGuiWindow@@@Z PROC ; AddWindowToRenderList

; 3367 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx

; 3368 :     AddDrawListToRenderList(out_render_list, window->DrawList);

	mov	ebx, DWORD PTR _out_render_list$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _window$[ebp]
	push	DWORD PTR [edi+624]
	push	ebx
	call	?AddDrawListToRenderList@@YAXAAV?$ImVector@PAUImDrawList@@@@PAUImDrawList@@@Z ; AddDrawListToRenderList

; 3369 :     for (int i = 0; i < window->DC.ChildWindows.Size; i++)

	xor	esi, esi
	add	esp, 8
	cmp	DWORD PTR [edi+292], esi
	jle	SHORT $LN3@AddWindowT
	npad	9
$LL4@AddWindowT:

; 3370 :     {
; 3371 :         ImGuiWindow* child = window->DC.ChildWindows[i];

	mov	eax, DWORD PTR [edi+300]
	mov	eax, DWORD PTR [eax+esi*4]

; 3372 :         if (!child->Active) // clipped children may have been marked not active

	cmp	BYTE PTR [eax+132], 0
	je	SHORT $LN2@AddWindowT

; 3373 :             continue;
; 3374 :         if ((child->Flags & ImGuiWindowFlags_Popup) && child->HiddenFrames > 0)

	test	DWORD PTR [eax+8], 33554432		; 02000000H
	je	SHORT $LN6@AddWindowT
	cmp	DWORD PTR [eax+172], 0
	jg	SHORT $LN2@AddWindowT
$LN6@AddWindowT:

; 3375 :             continue;
; 3376 :         AddWindowToRenderList(out_render_list, child);

	push	eax
	push	ebx
	call	?AddWindowToRenderList@@YAXAAV?$ImVector@PAUImDrawList@@@@PAUImGuiWindow@@@Z ; AddWindowToRenderList
	add	esp, 8
$LN2@AddWindowT:

; 3369 :     for (int i = 0; i < window->DC.ChildWindows.Size; i++)

	inc	esi
	cmp	esi, DWORD PTR [edi+292]
	jl	SHORT $LL4@AddWindowT
$LN3@AddWindowT:
	pop	edi
	pop	esi
	pop	ebx

; 3377 :     }
; 3378 : }

	pop	ebp
	ret	0
?AddWindowToRenderList@@YAXAAV?$ImVector@PAUImDrawList@@@@PAUImGuiWindow@@@Z ENDP ; AddWindowToRenderList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_out_render_list$ = 8					; size = 4
_draw_list$ = 12					; size = 4
?AddDrawListToRenderList@@YAXAAV?$ImVector@PAUImDrawList@@@@PAUImDrawList@@@Z PROC ; AddDrawListToRenderList

; 3339 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	mov	esi, DWORD PTR _draw_list$[ebp]
	mov	edx, DWORD PTR [esi]
	test	edx, edx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3340 :     if (draw_list->CmdBuffer.empty())

	je	SHORT $LN1@AddDrawLis

; 3341 :         return;
; 3342 : 
; 3343 :     // Remove trailing command if unused
; 3344 :     ImDrawCmd& last_cmd = draw_list->CmdBuffer.back();

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, edx
	shl	ecx, 5

; 3345 :     if (last_cmd.ElemCount == 0 && last_cmd.UserCallback == NULL)

	cmp	DWORD PTR [ecx+eax-32], 0
	jne	SHORT $LN4@AddDrawLis
	cmp	DWORD PTR [ecx+eax-8], 0
	jne	SHORT $LN4@AddDrawLis
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	lea	eax, DWORD PTR [edx-1]
	mov	DWORD PTR [esi], eax

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	test	eax, eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3348 :         if (draw_list->CmdBuffer.empty())

	je	SHORT $LN1@AddDrawLis
$LN4@AddDrawLis:

; 3349 :             return;
; 3350 :     }
; 3351 : 
; 3352 :     // Draw list sanity check. Detect mismatch between PrimReserve() calls and incrementing _VtxCurrentIdx, _VtxWritePtr etc.
; 3353 :     IM_ASSERT(draw_list->VtxBuffer.Size == 0 || draw_list->_VtxWritePtr == draw_list->VtxBuffer.Data + draw_list->VtxBuffer.Size);
; 3354 :     IM_ASSERT(draw_list->IdxBuffer.Size == 0 || draw_list->_IdxWritePtr == draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size);
; 3355 :     IM_ASSERT((int)draw_list->_VtxCurrentIdx == draw_list->VtxBuffer.Size);
; 3356 : 
; 3357 :     // Check that draw_list doesn't use more vertices than indexable (default ImDrawIdx = 2 bytes = 64K vertices)
; 3358 :     // If this assert triggers because you are drawing lots of stuff manually, A) workaround by calling BeginChild()/EndChild() to put your draw commands in multiple draw lists, B) #define ImDrawIdx to a 'unsigned int' in imconfig.h and render accordingly.
; 3359 :     IM_ASSERT((int64_t)draw_list->_VtxCurrentIdx <= ((int64_t)1L << (sizeof(ImDrawIdx)*8)));  // Too many vertices in same ImDrawList. See comment above.
; 3360 :     
; 3361 :     out_render_list.push_back(draw_list);

	mov	ecx, DWORD PTR _out_render_list$[ebp]
	lea	eax, DWORD PTR _draw_list$[ebp]
	push	eax
	call	?push_back@?$ImVector@PAUImDrawList@@@@QAEXABQAUImDrawList@@@Z ; ImVector<ImDrawList *>::push_back

; 3362 :     GImGui->IO.MetricsRenderVertices += draw_list->VtxBuffer.Size;

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [esi+24]
	add	DWORD PTR [ecx+860], eax

; 3363 :     GImGui->IO.MetricsRenderIndices += draw_list->IdxBuffer.Size;

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [esi+12]
	add	DWORD PTR [ecx+864], eax
$LN1@AddDrawLis:
	pop	esi

; 3364 : }

	pop	ebp
	ret	0
?AddDrawListToRenderList@@YAXAAV?$ImVector@PAUImDrawList@@@@PAUImDrawList@@@Z ENDP ; AddDrawListToRenderList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T3 = -8						; size = 8
$T4 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
_window$ = 12						; size = 4
?CalcNextScrollFromScrollTargetAndClamp@@YA?AUImVec2@@PAUImGuiWindow@@@Z PROC ; CalcNextScrollFromScrollTargetAndClamp

; 4712 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 4713 :     ImVec2 scroll = window->Scroll;

	mov	ecx, DWORD PTR _window$[ebp]
	sub	esp, 8
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]

; 4714 :     if (window->ScrollTarget.x < FLT_MAX)

	movss	xmm2, DWORD PTR __real@7f7fffff
	mov	eax, DWORD PTR [ecx+92]
	movss	xmm1, DWORD PTR [ecx+100]
	comiss	xmm2, xmm1
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+96]
	mov	DWORD PTR [edx+4], eax
	jbe	SHORT $LN2@CalcNextSc

; 4715 :         scroll.x = window->ScrollTarget.x - (window->ScrollTargetCenterRatio.x * window->SizeFull.x);

	movss	xmm0, DWORD PTR [ecx+108]
	mulss	xmm0, DWORD PTR [ecx+40]
	subss	xmm1, xmm0
	movss	DWORD PTR [edx], xmm1
$LN2@CalcNextSc:

; 4716 :     if (window->ScrollTarget.y < FLT_MAX)

	movss	xmm4, DWORD PTR [ecx+104]
	xorps	xmm5, xmm5
	comiss	xmm2, xmm4
	jbe	$LN3@CalcNextSc
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	test	BYTE PTR [ecx+8], 1
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	je	SHORT $LN8@CalcNextSc
	xorps	xmm3, xmm3
	jmp	SHORT $LN9@CalcNextSc
$LN8@CalcNextSc:
	movss	xmm0, DWORD PTR [eax+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm3, DWORD PTR [eax+6176]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm0, xmm0

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm3, DWORD PTR [ecx+620]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm3, xmm0
$LN9@CalcNextSc:

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	test	DWORD PTR [ecx+8], 1024			; 00000400H
	je	SHORT $LN14@CalcNextSc
	movss	xmm0, DWORD PTR [eax+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm2, DWORD PTR [eax+6176]

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	addss	xmm0, xmm0

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm2, DWORD PTR [ecx+620]

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	addss	xmm2, xmm0
	jmp	SHORT $LN15@CalcNextSc
$LN14@CalcNextSc:
	xorps	xmm2, xmm2
$LN15@CalcNextSc:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4717 :         scroll.y = window->ScrollTarget.y - ((1.0f - window->ScrollTargetCenterRatio.y) * (window->TitleBarHeight() + window->MenuBarHeight())) - (window->ScrollTargetCenterRatio.y * window->SizeFull.y);

	movss	xmm0, DWORD PTR __real@3f800000
	addss	xmm2, xmm3
	subss	xmm0, DWORD PTR [ecx+112]
	mulss	xmm2, xmm0
	movss	xmm0, DWORD PTR [ecx+44]
	mulss	xmm0, DWORD PTR [ecx+112]
	subss	xmm4, xmm2
	subss	xmm4, xmm0
	movss	DWORD PTR [edx+4], xmm4
$LN3@CalcNextSc:

; 4719 :     if (!window->Collapsed && !window->SkipItems)

	cmp	BYTE PTR [ecx+135], 0
	movss	xmm0, DWORD PTR [edx]
	maxss	xmm0, xmm5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp], xmm0
	movss	xmm0, DWORD PTR [edx+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4718 :     scroll = ImMax(scroll, ImVec2(0.0f, 0.0f));

	mov	eax, DWORD PTR $T4[ebp]
	maxss	xmm0, xmm5
	mov	DWORD PTR [edx], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4718 :     scroll = ImMax(scroll, ImVec2(0.0f, 0.0f));

	mov	eax, DWORD PTR $T4[ebp+4]
	mov	DWORD PTR [edx+4], eax

; 4721 :     return scroll;

	mov	eax, edx
	jne	SHORT $LN4@CalcNextSc

; 4719 :     if (!window->Collapsed && !window->SkipItems)

	cmp	BYTE PTR [ecx+137], 0
	jne	SHORT $LN4@CalcNextSc
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [ecx+48]
	subss	xmm0, DWORD PTR [ecx+40]
	movss	xmm1, DWORD PTR [ecx+52]
	subss	xmm1, DWORD PTR [ecx+44]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm3, DWORD PTR [ecx+120]
	movss	xmm2, DWORD PTR [ecx+124]
	addss	xmm3, xmm0
	movss	xmm0, DWORD PTR [edx+4]
	addss	xmm2, xmm1
	maxss	xmm3, xmm5
	maxss	xmm2, xmm5
	minss	xmm3, DWORD PTR [edx]
	minss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp], xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4720 :         scroll = ImMin(scroll, ImMax(ImVec2(0.0f, 0.0f), window->SizeContents - window->SizeFull + window->ScrollbarSizes));

	mov	ecx, DWORD PTR $T3[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4720 :         scroll = ImMin(scroll, ImMax(ImVec2(0.0f, 0.0f), window->SizeContents - window->SizeFull + window->ScrollbarSizes));

	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR $T3[ebp+4]
	mov	DWORD PTR [edx+4], ecx
$LN4@CalcNextSc:

; 4722 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CalcNextScrollFromScrollTargetAndClamp@@YA?AUImVec2@@PAUImGuiWindow@@@Z ENDP ; CalcNextScrollFromScrollTargetAndClamp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -72						; size = 16
_bb$ = -72						; size = 16
$T2 = -56						; size = 16
$T3 = -48						; size = 8
$T4 = -48						; size = 8
_f$1$ = -44						; size = 4
$T5 = -40						; size = 8
$T6 = -40						; size = 8
tv854 = -36						; size = 4
tv730 = -36						; size = 4
_id$1$ = -32						; size = 4
_grab_h_pixels$1$ = -28					; size = 4
_grab_h_norm$1$ = -24					; size = 4
_clicked_v_norm$1$ = -20				; size = 4
_scroll_v$1$ = -20					; size = 4
_grab_v_norm$1$ = -16					; size = 4
_win_size_avail_v$1$ = -16				; size = 4
_scrollbar_size_v$1$ = -12				; size = 4
_scroll_max$1$ = -8					; size = 4
_previously_held$1$ = -2				; size = 1
_hovered$ = -1						; size = 1
_other_scrollbar_size_w$1$ = 8				; size = 4
_click_delta_to_grab_center_v$1$ = 8			; size = 4
_window$ = 8						; size = 4
_held$ = 11						; size = 1
_horizontal$ = 12					; size = 1
?Scrollbar@@YAXPAUImGuiWindow@@_N@Z PROC		; Scrollbar

; 5382 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 5383 :     ImGuiContext& g = *GImGui;
; 5384 :     const ImGuiStyle& style = g.Style;
; 5385 :     const ImGuiID id = window->GetID(horizontal ? "#SCROLLX" : "#SCROLLY");

	cmp	BYTE PTR _horizontal$[ebp], 0
	mov	ecx, OFFSET $SG118366
	push	esi
	mov	esi, DWORD PTR _window$[ebp]
	mov	eax, OFFSET $SG118365
	push	edi
	mov	edi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	cmove	eax, ecx
	push	0
	push	eax
	mov	ecx, esi
	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID
	mov	DWORD PTR _id$1$[ebp], eax

; 5386 : 
; 5387 :     // Render background
; 5388 :     bool other_scrollbar = (horizontal ? window->ScrollbarY : window->ScrollbarX);

	mov	al, BYTE PTR _horizontal$[ebp]
	test	al, al
	je	SHORT $LN15@Scrollbar
	mov	dl, BYTE PTR [esi+117]
	jmp	SHORT $LN16@Scrollbar
$LN15@Scrollbar:
	mov	dl, BYTE PTR [esi+116]
$LN16@Scrollbar:
	xorps	xmm1, xmm1

; 5389 :     float other_scrollbar_size_w = other_scrollbar ? style.ScrollbarSize : 0.0f;

	test	dl, dl
	je	SHORT $LN17@Scrollbar
	movss	xmm6, DWORD PTR [edi+5400]
	jmp	SHORT $LN158@Scrollbar
$LN17@Scrollbar:
	xorps	xmm6, xmm6
$LN158@Scrollbar:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 773  :     ImRect      Rect() const                            { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }

	movss	xmm0, DWORD PTR [esi+24]
	movss	xmm5, DWORD PTR [esi+28]
	movaps	xmm2, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5391 :     const float border_size = window->BorderSize;

	movss	xmm4, DWORD PTR [esi+128]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 773  :     ImRect      Rect() const                            { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }

	movaps	xmm3, xmm5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5389 :     float other_scrollbar_size_w = other_scrollbar ? style.ScrollbarSize : 0.0f;

	movss	DWORD PTR _other_scrollbar_size_w$1$[ebp], xmm6
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 773  :     ImRect      Rect() const                            { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }

	addss	xmm2, DWORD PTR [esi+32]
	addss	xmm3, DWORD PTR [esi+36]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5392 :     ImRect bb = horizontal

	test	al, al
	je	SHORT $LN19@Scrollbar
	addss	xmm0, xmm4
	subss	xmm2, xmm6
	lea	ecx, DWORD PTR $T2[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5392 :     ImRect bb = horizontal

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [edi+5400]
	subss	xmm2, xmm4
	subss	xmm3, xmm4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp+4], xmm0
	movss	DWORD PTR $T2[ebp+8], xmm2
	movss	DWORD PTR $T2[ebp+12], xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5392 :     ImRect bb = horizontal

	jmp	SHORT $LN20@Scrollbar
$LN19@Scrollbar:
	subss	xmm3, xmm6
	movaps	xmm0, xmm2
	subss	xmm0, DWORD PTR [edi+5400]
	addss	xmm5, xmm4
	subss	xmm2, xmm4
	lea	ecx, DWORD PTR $T1[ebp]
	subss	xmm3, xmm4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm0
	movss	DWORD PTR $T1[ebp+4], xmm5
	movss	DWORD PTR $T1[ebp+8], xmm2
	movss	DWORD PTR $T1[ebp+12], xmm3
$LN20@Scrollbar:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5392 :     ImRect bb = horizontal

	movups	xmm0, XMMWORD PTR [ecx]
	movups	XMMWORD PTR _bb$[ebp], xmm0

; 5393 :         ? ImRect(window->Pos.x + border_size, window_rect.Max.y - style.ScrollbarSize, window_rect.Max.x - other_scrollbar_size_w - border_size, window_rect.Max.y - border_size)
; 5394 :         : ImRect(window_rect.Max.x - style.ScrollbarSize, window->Pos.y + border_size, window_rect.Max.x - border_size, window_rect.Max.y - other_scrollbar_size_w - border_size);
; 5395 :     if (!horizontal)

	test	al, al
	jne	SHORT $LN2@Scrollbar

; 5396 :         bb.Min.y += window->TitleBarHeight() + ((window->Flags & ImGuiWindowFlags_MenuBar) ? window->MenuBarHeight() : 0.0f);

	test	DWORD PTR [esi+8], 1024			; 00000400H
	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	je	SHORT $LN21@Scrollbar
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	movss	xmm0, DWORD PTR [ecx+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm2, DWORD PTR [ecx+6176]

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	addss	xmm0, xmm0

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm2, DWORD PTR [esi+620]

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	addss	xmm2, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5396 :         bb.Min.y += window->TitleBarHeight() + ((window->Flags & ImGuiWindowFlags_MenuBar) ? window->MenuBarHeight() : 0.0f);

	jmp	SHORT $LN22@Scrollbar
$LN21@Scrollbar:
	xorps	xmm2, xmm2
$LN22@Scrollbar:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	test	BYTE PTR [esi+8], 1
	jne	SHORT $LN72@Scrollbar
	movss	xmm0, DWORD PTR [ecx+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm1, DWORD PTR [ecx+6176]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm0, xmm0

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm1, DWORD PTR [esi+620]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm1, xmm0
$LN72@Scrollbar:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5396 :         bb.Min.y += window->TitleBarHeight() + ((window->Flags & ImGuiWindowFlags_MenuBar) ? window->MenuBarHeight() : 0.0f);

	addss	xmm1, xmm2
	addss	xmm1, DWORD PTR _bb$[ebp+4]
	movss	DWORD PTR _bb$[ebp+4], xmm1
$LN2@Scrollbar:

; 5397 : 
; 5398 :     float window_rounding = (window->Flags & ImGuiWindowFlags_ChildWindow) ? style.ChildWindowRounding : style.WindowRounding;

	mov	ecx, DWORD PTR [esi+8]
	test	ecx, 4194304				; 00400000H
	je	SHORT $LN23@Scrollbar
	movss	xmm0, DWORD PTR [edi+5352]
	jmp	SHORT $LN24@Scrollbar
$LN23@Scrollbar:
	movss	xmm0, DWORD PTR [edi+5340]
$LN24@Scrollbar:

; 5399 :     int window_rounding_corners;
; 5400 :     if (horizontal)

	test	al, al
	je	SHORT $LN3@Scrollbar

; 5401 :         window_rounding_corners = ImGuiCorner_BottomLeft | (other_scrollbar ? 0 : ImGuiCorner_BottomRight);
; 5402 :     else

	xor	ecx, ecx
	test	dl, dl
	sete	cl
	lea	ecx, DWORD PTR [ecx*4+8]
	jmp	SHORT $LN4@Scrollbar
$LN3@Scrollbar:
	and	ecx, 1025				; 00000401H

; 5403 :         window_rounding_corners = (((window->Flags & ImGuiWindowFlags_NoTitleBar) && !(window->Flags & ImGuiWindowFlags_MenuBar)) ? ImGuiCorner_TopRight : 0) | (other_scrollbar ? 0 : ImGuiCorner_BottomRight);

	mov	DWORD PTR tv730[ebp], 0
	dec	ecx
	mov	eax, 4
	neg	ecx
	sbb	ecx, ecx
	and	ecx, -2					; fffffffeH
	add	ecx, 2
	test	dl, dl
	cmovne	eax, DWORD PTR tv730[ebp]
	or	ecx, eax
$LN4@Scrollbar:

; 5404 :     window->DrawList->AddRectFilled(bb.Min, bb.Max, ImGui::GetColorU32(ImGuiCol_ScrollbarBg), window_rounding, window_rounding_corners);

	push	ecx
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	14					; 0000000eH
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	ecx, DWORD PTR [esi+624]
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR _bb$[ebp+8]
	push	eax
	lea	eax, DWORD PTR _bb$[ebp]
	push	eax
	call	?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 5405 :     bb.Expand(ImVec2(-ImClamp((float)(int)((bb.Max.x - bb.Min.x - 2.0f) * 0.5f), 0.0f, 3.0f), -ImClamp((float)(int)((bb.Max.y - bb.Min.y - 2.0f) * 0.5f), 0.0f, 3.0f)));

	movss	xmm0, DWORD PTR _bb$[ebp+12]
	xorps	xmm1, xmm1
	movss	xmm6, DWORD PTR _bb$[ebp+4]
	movss	xmm2, DWORD PTR __real@40000000
	subss	xmm0, xmm6
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	movss	xmm5, DWORD PTR __real@40400000
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5405 :     bb.Expand(ImVec2(-ImClamp((float)(int)((bb.Max.x - bb.Min.x - 2.0f) * 0.5f), 0.0f, 3.0f), -ImClamp((float)(int)((bb.Max.y - bb.Min.y - 2.0f) * 0.5f), 0.0f, 3.0f)));

	subss	xmm0, xmm2
	mulss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	movd	xmm3, eax
	cvtdq2ps xmm3, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm1, xmm3
	jbe	SHORT $LN79@Scrollbar
	xorps	xmm3, xmm3
	jmp	SHORT $LN80@Scrollbar
$LN79@Scrollbar:
	minss	xmm3, xmm5
$LN80@Scrollbar:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5405 :     bb.Expand(ImVec2(-ImClamp((float)(int)((bb.Max.x - bb.Min.x - 2.0f) * 0.5f), 0.0f, 3.0f), -ImClamp((float)(int)((bb.Max.y - bb.Min.y - 2.0f) * 0.5f), 0.0f, 3.0f)));

	movss	xmm7, DWORD PTR _bb$[ebp+8]
	movss	xmm4, DWORD PTR _bb$[ebp]
	movaps	xmm0, xmm7
	subss	xmm0, xmm4
	subss	xmm0, xmm2
	mulss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	movd	xmm2, eax
	cvtdq2ps xmm2, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm1, xmm2
	jbe	SHORT $LN85@Scrollbar
	xorps	xmm2, xmm2
	jmp	SHORT $LN86@Scrollbar
$LN85@Scrollbar:
	minss	xmm2, xmm5
$LN86@Scrollbar:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5405 :     bb.Expand(ImVec2(-ImClamp((float)(int)((bb.Max.x - bb.Min.x - 2.0f) * 0.5f), 0.0f, 3.0f), -ImClamp((float)(int)((bb.Max.y - bb.Min.y - 2.0f) * 0.5f), 0.0f, 3.0f)));

	xorps	xmm2, DWORD PTR __xmm@80000000800000008000000080000000
	xorps	xmm3, DWORD PTR __xmm@80000000800000008000000080000000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 258  :     void        Expand(const ImVec2& amount)    { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }

	subss	xmm4, xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5408 :     float scrollbar_size_v = horizontal ? bb.GetWidth() : bb.GetHeight();

	mov	al, BYTE PTR _horizontal$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 258  :     void        Expand(const ImVec2& amount)    { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }

	subss	xmm6, xmm3
	addss	xmm2, xmm7
	addss	xmm3, DWORD PTR _bb$[ebp+12]
	movss	DWORD PTR _bb$[ebp], xmm4
	movss	DWORD PTR _bb$[ebp+4], xmm6
	movss	DWORD PTR _bb$[ebp+8], xmm2
	movss	DWORD PTR _bb$[ebp+12], xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5408 :     float scrollbar_size_v = horizontal ? bb.GetWidth() : bb.GetHeight();

	test	al, al
	je	SHORT $LN27@Scrollbar

; 5409 :     float scroll_v = horizontal ? window->Scroll.x : window->Scroll.y;

	movss	xmm0, DWORD PTR [esi+92]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 246  :     float       GetWidth() const                { return Max.x-Min.x; }

	subss	xmm2, xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5410 :     float win_size_avail_v = (horizontal ? window->Size.x : window->Size.y) - other_scrollbar_size_w;

	movss	xmm3, DWORD PTR [esi+32]
	jmp	SHORT $LN159@Scrollbar
$LN27@Scrollbar:

; 5409 :     float scroll_v = horizontal ? window->Scroll.x : window->Scroll.y;

	movss	xmm0, DWORD PTR [esi+96]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 247  :     float       GetHeight() const               { return Max.y-Min.y; }

	movaps	xmm2, xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5410 :     float win_size_avail_v = (horizontal ? window->Size.x : window->Size.y) - other_scrollbar_size_w;

	movss	xmm3, DWORD PTR [esi+36]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 247  :     float       GetHeight() const               { return Max.y-Min.y; }

	subss	xmm2, xmm6
$LN159@Scrollbar:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5409 :     float scroll_v = horizontal ? window->Scroll.x : window->Scroll.y;

	movss	DWORD PTR _scroll_v$1$[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 247  :     float       GetHeight() const               { return Max.y-Min.y; }

	movss	DWORD PTR _scrollbar_size_v$1$[ebp], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5410 :     float win_size_avail_v = (horizontal ? window->Size.x : window->Size.y) - other_scrollbar_size_w;

	subss	xmm3, DWORD PTR _other_scrollbar_size_w$1$[ebp]
	movss	DWORD PTR _win_size_avail_v$1$[ebp], xmm3

; 5411 :     float win_size_contents_v = horizontal ? window->SizeContents.x : window->SizeContents.y;

	test	al, al
	je	SHORT $LN33@Scrollbar
	movss	xmm6, DWORD PTR [esi+48]
	jmp	SHORT $LN160@Scrollbar
$LN33@Scrollbar:
	movss	xmm6, DWORD PTR [esi+52]
$LN160@Scrollbar:
	movaps	xmm0, xmm6
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 134  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	movss	xmm4, DWORD PTR __real@3f800000
	maxss	xmm0, xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5411 :     float win_size_contents_v = horizontal ? window->SizeContents.x : window->SizeContents.y;

	movss	DWORD PTR _scroll_max$1$[ebp], xmm6

; 5412 : 
; 5413 :     // The grabable box size generally represent the amount visible (vs the total scrollable amount)
; 5414 :     // But we maintain a minimum size in pixel to allow for the user to still aim inside.
; 5415 :     const float grab_h_pixels = ImMin(ImMax(scrollbar_size_v * ImSaturate(win_size_avail_v / ImMax(win_size_contents_v, win_size_avail_v)), style.GrabMinSize), scrollbar_size_v);

	divss	xmm3, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 134  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm1, xmm3
	jbe	SHORT $LN103@Scrollbar
	xorps	xmm3, xmm3
	jmp	SHORT $LN104@Scrollbar
$LN103@Scrollbar:
	minss	xmm3, xmm4
$LN104@Scrollbar:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5416 :     const float grab_h_norm = grab_h_pixels / scrollbar_size_v;

	movaps	xmm0, xmm4

; 5417 : 
; 5418 :     // Handle input right away. None of the code of Begin() is relying on scrolling position before calling Scrollbar().
; 5419 :     bool held = false;
; 5420 :     bool hovered = false;
; 5421 :     const bool previously_held = (g.ActiveId == id);

	mov	eax, DWORD PTR _id$1$[ebp]
	divss	xmm0, xmm2
	cmp	DWORD PTR [edi+6264], eax

; 5422 :     ImGui::ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_NoNavOverride);

	lea	ecx, DWORD PTR _held$[ebp]
	push	2048					; 00000800H
	push	ecx
	lea	ecx, DWORD PTR _hovered$[ebp]
	mov	BYTE PTR _held$[ebp], 0
	push	ecx
	push	eax
	lea	eax, DWORD PTR _bb$[ebp]
	mov	BYTE PTR _hovered$[ebp], 0
	push	eax
	mulss	xmm3, xmm2
	sete	BYTE PTR _previously_held$1$[ebp]
	movss	DWORD PTR tv854[ebp], xmm0
	maxss	xmm3, DWORD PTR [edi+5408]
	minss	xmm3, xmm2
	mulss	xmm0, xmm3
	movss	DWORD PTR _grab_h_pixels$1$[ebp], xmm3
	movss	DWORD PTR _grab_h_norm$1$[ebp], xmm0
	call	?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z ; ImGui::ButtonBehavior

; 5423 : 
; 5424 :     float scroll_max = ImMax(1.0f, win_size_contents_v - win_size_avail_v);

	movss	xmm0, DWORD PTR _scroll_max$1$[ebp]
	add	esp, 20					; 00000014H
	subss	xmm0, DWORD PTR _win_size_avail_v$1$[ebp]
	movss	xmm4, DWORD PTR __real@3f800000

; 5425 :     float scroll_ratio = ImSaturate(scroll_v / scroll_max);

	movaps	xmm1, xmm4
	maxss	xmm0, xmm4
	divss	xmm1, xmm0
	movss	DWORD PTR _scroll_max$1$[ebp], xmm0
	movaps	xmm2, xmm1
	movss	DWORD PTR _f$1$[ebp], xmm1
	mulss	xmm2, DWORD PTR _scroll_v$1$[ebp]
	xorps	xmm1, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 134  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm1, xmm2
	jbe	SHORT $LN121@Scrollbar
	xorps	xmm2, xmm2
	jmp	SHORT $LN122@Scrollbar
$LN121@Scrollbar:
	minss	xmm2, xmm4
$LN122@Scrollbar:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5427 :     if (held && grab_h_norm < 1.0f)

	cmp	BYTE PTR _held$[ebp], 0
	movss	xmm0, DWORD PTR _scrollbar_size_v$1$[ebp]
	subss	xmm0, DWORD PTR _grab_h_pixels$1$[ebp]
	movss	xmm5, DWORD PTR tv854[ebp]
	movaps	xmm3, xmm0
	movss	DWORD PTR _scrollbar_size_v$1$[ebp], xmm0
	mulss	xmm3, xmm2
	mulss	xmm3, xmm5
	movss	DWORD PTR _grab_v_norm$1$[ebp], xmm3
	je	$LN41@Scrollbar
	comiss	xmm4, DWORD PTR _grab_h_norm$1$[ebp]
	jbe	$LN11@Scrollbar

; 5428 :     {
; 5429 :         float scrollbar_pos_v = horizontal ? bb.Min.x : bb.Min.y;

	cmp	BYTE PTR _horizontal$[ebp], 0
	je	SHORT $LN35@Scrollbar
	movss	xmm2, DWORD PTR _bb$[ebp]

; 5430 :         float mouse_pos_v = horizontal ? g.IO.MousePos.x : g.IO.MousePos.y;
; 5431 :         float* click_delta_to_grab_center_v = horizontal ? &g.ScrollbarClickDeltaToGrabCenter.x : &g.ScrollbarClickDeltaToGrabCenter.y;

	lea	eax, DWORD PTR [edi+10540]
	movss	xmm0, DWORD PTR [edi+208]
	jmp	SHORT $LN161@Scrollbar
$LN35@Scrollbar:

; 5428 :     {
; 5429 :         float scrollbar_pos_v = horizontal ? bb.Min.x : bb.Min.y;

	movss	xmm2, DWORD PTR _bb$[ebp+4]

; 5430 :         float mouse_pos_v = horizontal ? g.IO.MousePos.x : g.IO.MousePos.y;
; 5431 :         float* click_delta_to_grab_center_v = horizontal ? &g.ScrollbarClickDeltaToGrabCenter.x : &g.ScrollbarClickDeltaToGrabCenter.y;

	lea	eax, DWORD PTR [edi+10544]
	movss	xmm0, DWORD PTR [edi+212]
$LN161@Scrollbar:

; 5432 : 
; 5433 :         // Click position in scrollbar normalized space (0.0f->1.0f)
; 5434 :         const float clicked_v_norm = ImSaturate((mouse_pos_v - scrollbar_pos_v) / scrollbar_size_v);

	subss	xmm0, xmm2
	mov	DWORD PTR _click_delta_to_grab_center_v$1$[ebp], eax
	mulss	xmm0, xmm5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 134  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm1, xmm0
	jbe	SHORT $LN127@Scrollbar
	movss	DWORD PTR _clicked_v_norm$1$[ebp], xmm1
	jmp	SHORT $LN128@Scrollbar
$LN127@Scrollbar:
	minss	xmm0, xmm4
	movss	DWORD PTR _clicked_v_norm$1$[ebp], xmm0
$LN128@Scrollbar:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5435 :         ImGui::SetHoveredID(id);

	mov	eax, DWORD PTR _id$1$[ebp]
	push	eax
	call	?SetHoveredID@ImGui@@YAXI@Z		; ImGui::SetHoveredID

; 5436 : 
; 5437 :         bool seek_absolute = false;
; 5438 :         if (!previously_held)
; 5439 :         {
; 5440 :             // On initial click calculate the distance between mouse and the center of the grab
; 5441 :             if (clicked_v_norm >= grab_v_norm && clicked_v_norm <= grab_v_norm + grab_h_norm)

	movss	xmm2, DWORD PTR _clicked_v_norm$1$[ebp]
	xor	dl, dl
	add	esp, 4
	cmp	BYTE PTR _previously_held$1$[ebp], dl
	jne	SHORT $LN157@Scrollbar
	movss	xmm3, DWORD PTR _grab_v_norm$1$[ebp]
	comiss	xmm2, xmm3
	jb	SHORT $LN7@Scrollbar
	movss	xmm4, DWORD PTR _grab_h_norm$1$[ebp]
	movaps	xmm0, xmm3
	addss	xmm0, xmm4
	comiss	xmm0, xmm2
	jb	SHORT $LN7@Scrollbar

; 5442 :             {
; 5443 :                 *click_delta_to_grab_center_v = clicked_v_norm - grab_v_norm - grab_h_norm*0.5f;

	mov	ecx, DWORD PTR _click_delta_to_grab_center_v$1$[ebp]
	movaps	xmm1, xmm2
	movaps	xmm0, xmm4
	subss	xmm1, xmm3
	mulss	xmm0, DWORD PTR __real@3f000000
	subss	xmm1, xmm0
	movss	DWORD PTR [ecx], xmm1

; 5444 :             }
; 5445 :             else

	jmp	SHORT $LN8@Scrollbar
$LN7@Scrollbar:

; 5446 :             {
; 5447 :                 seek_absolute = true;
; 5448 :                 *click_delta_to_grab_center_v = 0.0f;

	mov	ecx, DWORD PTR _click_delta_to_grab_center_v$1$[ebp]
	mov	dl, 1
	mov	DWORD PTR [ecx], 0
	jmp	SHORT $LN8@Scrollbar
$LN157@Scrollbar:
	mov	ecx, DWORD PTR _click_delta_to_grab_center_v$1$[ebp]
$LN8@Scrollbar:

; 5449 :             }
; 5450 :         }
; 5451 : 
; 5452 :         // Apply scroll
; 5453 :         // It is ok to modify Scroll here because we are being called in Begin() after the calculation of SizeContents and before setting up our starting position
; 5454 :         const float scroll_v_norm = ImSaturate((clicked_v_norm - *click_delta_to_grab_center_v - grab_h_norm*0.5f) / (1.0f - grab_h_norm));

	movss	xmm5, DWORD PTR _grab_h_norm$1$[ebp]
	movaps	xmm1, xmm2
	subss	xmm1, DWORD PTR [ecx]
	mulss	xmm5, DWORD PTR __real@3f000000
	movss	xmm4, DWORD PTR __real@3f800000
	movaps	xmm0, xmm4
	subss	xmm0, DWORD PTR _grab_h_norm$1$[ebp]
	subss	xmm1, xmm5
	divss	xmm1, xmm0
	xorps	xmm0, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 134  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm0, xmm1
	jbe	SHORT $LN133@Scrollbar
	xorps	xmm1, xmm1
	jmp	SHORT $LN134@Scrollbar
$LN133@Scrollbar:
	minss	xmm1, xmm4
$LN134@Scrollbar:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5456 :         if (horizontal)

	cmp	BYTE PTR _horizontal$[ebp], 0
	mulss	xmm1, DWORD PTR _scroll_max$1$[ebp]
	addss	xmm1, DWORD PTR __real@3f000000
	cvttss2si eax, xmm1
	movd	xmm1, eax
	cvtdq2ps xmm1, xmm1
	je	SHORT $LN9@Scrollbar

; 5457 :             window->Scroll.x = scroll_v;

	movss	DWORD PTR [esi+92], xmm1

; 5458 :         else

	jmp	SHORT $LN10@Scrollbar
$LN9@Scrollbar:

; 5459 :             window->Scroll.y = scroll_v;

	movss	DWORD PTR [esi+96], xmm1
$LN10@Scrollbar:

; 5460 : 
; 5461 :         // Update values for rendering
; 5462 :         scroll_ratio = ImSaturate(scroll_v / scroll_max);

	movss	xmm3, DWORD PTR _f$1$[ebp]
	mulss	xmm3, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 134  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm0, xmm3
	ja	SHORT $LN140@Scrollbar
	movaps	xmm0, xmm3
	minss	xmm0, xmm4
$LN140@Scrollbar:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5463 :         grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;

	movss	xmm3, DWORD PTR _scrollbar_size_v$1$[ebp]
	mulss	xmm3, xmm0
	mulss	xmm3, DWORD PTR tv854[ebp]
	movss	DWORD PTR _grab_v_norm$1$[ebp], xmm3

; 5464 : 
; 5465 :         // Update distance to grab now that we have seeked and saturated
; 5466 :         if (seek_absolute)

	test	dl, dl
	je	SHORT $LN11@Scrollbar

; 5467 :             *click_delta_to_grab_center_v = clicked_v_norm - grab_v_norm - grab_h_norm*0.5f;

	subss	xmm2, xmm3
	subss	xmm2, xmm5
	movss	DWORD PTR [ecx], xmm2
$LN11@Scrollbar:

; 5468 :     }
; 5469 : 
; 5470 :     // Render
; 5471 :     const ImU32 grab_col = ImGui::GetColorU32(held ? ImGuiCol_ScrollbarGrabActive : hovered ? ImGuiCol_ScrollbarGrabHovered : ImGuiCol_ScrollbarGrab);

	mov	eax, 17					; 00000011H
	jmp	SHORT $LN42@Scrollbar
$LN41@Scrollbar:
	xor	eax, eax
	cmp	BYTE PTR _hovered$[ebp], al
	setne	al
	add	eax, 15					; 0000000fH
$LN42@Scrollbar:
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	eax
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	add	esp, 8

; 5472 :     if (horizontal)

	cmp	BYTE PTR _horizontal$[ebp], 0

; 5473 :         window->DrawList->AddRectFilled(ImVec2(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm), bb.Min.y), ImVec2(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm) + grab_h_pixels, bb.Max.y), grab_col, style.ScrollbarRounding);

	push	-1
	push	ecx
	mov	ecx, DWORD PTR [esi+624]
	je	SHORT $LN12@Scrollbar
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 135  : static inline float  ImLerp(float a, float b, float t)                          { return a + (b - a) * t; }

	movss	xmm1, DWORD PTR _bb$[ebp+8]
	subss	xmm1, DWORD PTR _bb$[ebp]
	mulss	xmm1, DWORD PTR _grab_v_norm$1$[ebp]
	addss	xmm1, DWORD PTR _bb$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5473 :         window->DrawList->AddRectFilled(ImVec2(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm), bb.Min.y), ImVec2(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm) + grab_h_pixels, bb.Max.y), grab_col, style.ScrollbarRounding);

	movaps	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T6[ebp], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5473 :         window->DrawList->AddRectFilled(ImVec2(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm), bb.Min.y), ImVec2(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm) + grab_h_pixels, bb.Max.y), grab_col, style.ScrollbarRounding);

	addss	xmm0, DWORD PTR _grab_h_pixels$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp], xmm0
	movss	xmm0, DWORD PTR _bb$[ebp+12]
	movss	DWORD PTR $T4[ebp+4], xmm0
	movss	xmm0, DWORD PTR _bb$[ebp+4]
	movss	DWORD PTR $T6[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5474 :     else

	jmp	SHORT $LN162@Scrollbar
$LN12@Scrollbar:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 135  : static inline float  ImLerp(float a, float b, float t)                          { return a + (b - a) * t; }

	movss	xmm1, DWORD PTR _bb$[ebp+12]
	subss	xmm1, DWORD PTR _bb$[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR _bb$[ebp+8]
	movss	DWORD PTR $T3[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 135  : static inline float  ImLerp(float a, float b, float t)                          { return a + (b - a) * t; }

	mulss	xmm1, DWORD PTR _grab_v_norm$1$[ebp]
	addss	xmm1, DWORD PTR _bb$[ebp+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5475 :         window->DrawList->AddRectFilled(ImVec2(bb.Min.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm)), ImVec2(bb.Max.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm) + grab_h_pixels), grab_col, style.ScrollbarRounding);

	movaps	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T5[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5475 :         window->DrawList->AddRectFilled(ImVec2(bb.Min.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm)), ImVec2(bb.Max.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm) + grab_h_pixels), grab_col, style.ScrollbarRounding);

	addss	xmm0, DWORD PTR _grab_h_pixels$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp+4], xmm0
	movss	xmm0, DWORD PTR _bb$[ebp]
	movss	DWORD PTR $T5[ebp], xmm0
$LN162@Scrollbar:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5475 :         window->DrawList->AddRectFilled(ImVec2(bb.Min.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm)), ImVec2(bb.Max.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm) + grab_h_pixels), grab_col, style.ScrollbarRounding);

	movss	xmm0, DWORD PTR [edi+5404]
	movss	DWORD PTR [esp], xmm0
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	pop	edi
	pop	esi

; 5476 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Scrollbar@@YAXPAUImGuiWindow@@_N@Z ENDP		; Scrollbar
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_window$ = 8						; size = 4
_write$ = 12						; size = 1
?CheckStacksSize@@YAXPAUImGuiWindow@@_N@Z PROC		; CheckStacksSize

; 4568 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 4569 :     // NOT checking: DC.ItemWidth, DC.AllowKeyboardFocus, DC.ButtonRepeat, DC.TextWrapPos (per window) to allow user to conveniently push once and not pop (they are cleared on Begin)
; 4570 :     ImGuiContext& g = *GImGui;
; 4571 :     int* p_backup = &window->DC.StackSizesBackup[0];
; 4572 :     { int current = window->IDStack.Size;       if (write) *p_backup = current; else IM_ASSERT(*p_backup == current && "PushID/PopID Mismatch!");                   p_backup++; }    // User forgot PopID()

	mov	dl, BYTE PTR _write$[ebp]
	push	esi
	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	edi
	mov	edi, DWORD PTR _window$[ebp]
	lea	ecx, DWORD PTR [edi+376]
	test	dl, dl
	je	SHORT $LN12@CheckStack
	mov	eax, DWORD PTR [edi+460]
	mov	DWORD PTR [ecx], eax

; 4573 :     { int current = window->DC.GroupStack.Size; if (write) *p_backup = current; else IM_ASSERT(*p_backup == current && "BeginGroup/EndGroup Mismatch!");            p_backup++; }    // User forgot EndGroup()

	mov	eax, DWORD PTR [edi+360]
	mov	DWORD PTR [ecx+4], eax

; 4574 :     { int current = g.CurrentPopupStack.Size;   if (write) *p_backup = current; else IM_ASSERT(*p_backup == current && "BeginMenu/EndMenu or BeginPopup/EndPopup Mismatch"); p_backup++; }// User forgot EndPopup()/EndMenu()

	mov	eax, DWORD PTR [esi+6368]
	mov	DWORD PTR [ecx+8], eax

; 4575 :     { int current = g.ColorModifiers.Size;      if (write) *p_backup = current; else IM_ASSERT(*p_backup == current && "PushStyleColor/PopStyleColor Mismatch!");   p_backup++; }    // User forgot PopStyleColor()

	mov	eax, DWORD PTR [esi+6320]
	mov	DWORD PTR [ecx+12], eax

; 4576 :     { int current = g.StyleModifiers.Size;      if (write) *p_backup = current; else IM_ASSERT(*p_backup == current && "PushStyleVar/PopStyleVar Mismatch!");       p_backup++; }    // User forgot PopStyleVar()

	mov	eax, DWORD PTR [esi+6332]
	mov	DWORD PTR [ecx+16], eax

; 4577 :     { int current = g.FontStack.Size;           if (write) *p_backup = current; else IM_ASSERT(*p_backup == current && "PushFont/PopFont Mismatch!");               p_backup++; }    // User forgot PopFont()

	mov	eax, DWORD PTR [esi+6344]
	mov	DWORD PTR [ecx+20], eax
$LN12@CheckStack:
	pop	edi
	pop	esi

; 4578 :     IM_ASSERT(p_backup == window->DC.StackSizesBackup + IM_ARRAYSIZE(window->DC.StackSizesBackup));
; 4579 : }

	pop	ebp
	ret	0
?CheckStacksSize@@YAXPAUImGuiWindow@@_N@Z ENDP		; CheckStacksSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?ClearSetNextWindowData@@YAXXZ PROC			; ClearSetNextWindowData

; 4351 :     ImGuiContext& g = *GImGui;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 4352 :     g.SetNextWindowPosCond = g.SetNextWindowSizeCond = g.SetNextWindowContentSizeCond = g.SetNextWindowCollapsedCond = 0;

	mov	DWORD PTR [eax+6560], 0
	mov	DWORD PTR [eax+6556], 0
	mov	DWORD PTR [eax+6552], 0
	mov	DWORD PTR [eax+6548], 0

; 4353 :     g.SetNextWindowSizeConstraint = g.SetNextWindowFocus = false;

	mov	WORD PTR [eax+6588], 0

; 4354 : }

	ret	0
?ClearSetNextWindowData@@YAXXZ ENDP			; ClearSetNextWindowData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_window$ = 8						; size = 4
?IsWindowContentHoverable@@YA_NPAUImGuiWindow@@@Z PROC	; IsWindowContentHoverable

; 6476 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 6477 :     // An active popup disable hovering on other windows (apart from its own children)
; 6478 :     ImGuiContext& g = *GImGui;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 6479 :     if (g.NavWindow)

	mov	ecx, DWORD PTR [eax+6380]
	test	ecx, ecx
	je	SHORT $LN4@IsWindowCo

; 6480 :         if (ImGuiWindow* focused_root_window = g.NavWindow->RootWindow)

	mov	ecx, DWORD PTR [ecx+632]
	test	ecx, ecx
	je	SHORT $LN4@IsWindowCo

; 6481 :             if ((focused_root_window->Flags & ImGuiWindowFlags_Popup) != 0 && focused_root_window->WasActive && focused_root_window != window->RootWindow)

	test	DWORD PTR [ecx+8], 33554432		; 02000000H
	je	SHORT $LN4@IsWindowCo
	cmp	BYTE PTR [ecx+133], 0
	je	SHORT $LN4@IsWindowCo
	mov	eax, DWORD PTR _window$[ebp]
	cmp	ecx, DWORD PTR [eax+632]
	je	SHORT $LN4@IsWindowCo

; 6482 :                 return false;

	xor	al, al

; 6485 : }

	pop	ebp
	ret	0
$LN4@IsWindowCo:

; 6483 : 
; 6484 :     return true;

	mov	al, 1

; 6485 : }

	pop	ebp
	ret	0
?IsWindowContentHoverable@@YA_NPAUImGuiWindow@@@Z ENDP	; IsWindowContentHoverable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T2 = -36						; size = 8
$T3 = -36						; size = 8
$T4 = -36						; size = 8
$T5 = -32						; size = 4
$T6 = -28						; size = 4
_g$1$ = -24						; size = 4
_window$ = -20						; size = 4
$T7 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_name$ = 8						; size = 4
_size$ = 12						; size = 8
_flags$ = 20						; size = 4
?CreateNewWindow@@YAPAUImGuiWindow@@PBDUImVec2@@H@Z PROC ; CreateNewWindow

; 4621 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CreateNewWindow@@YAPAUImGuiWindow@@PBDUImVec2@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 24					; 00000018H

; 4622 :     ImGuiContext& g = *GImGui;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	esi
	push	edi

; 4623 : 
; 4624 :     // Create window the first time
; 4625 :     ImGuiWindow* window = (ImGuiWindow*)ImGui::MemAlloc(sizeof(ImGuiWindow));

	push	668					; 0000029cH
	mov	DWORD PTR _g$1$[ebp], eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR _window$[ebp], esi

; 4626 :     IM_PLACEMENT_NEW(window) ImGuiWindow(name);

	lea	eax, DWORD PTR $T7[ebp]
	mov	DWORD PTR $T6[ebp], eax
	mov	DWORD PTR $T5[ebp], esi
	mov	edi, DWORD PTR _name$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	esi, esi
	je	SHORT $LN15@CreateNewW
	push	edi
	mov	ecx, esi
	call	??0ImGuiWindow@@QAE@PBD@Z		; ImGuiWindow::ImGuiWindow
$LN15@CreateNewW:

; 4627 :     window->Flags = flags;

	push	ebx
	mov	ebx, DWORD PTR _flags$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [esi+8], ebx

; 4628 : 
; 4629 :     if (flags & ImGuiWindowFlags_NoSavedSettings)

	test	ebx, 256				; 00000100H
	je	SHORT $LN2@CreateNewW

; 4630 :     {
; 4631 :         // User can disable loading and saving of settings. Tooltip and child windows also don't store settings.
; 4632 :         window->Size = window->SizeFull = size;

	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR [esi+40], eax

; 4633 :     }
; 4634 :     else

	jmp	$LN34@CreateNewW
$LN2@CreateNewW:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T4[ebp], 1114636288		; 42700000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4638 :         window->PosFloat = ImVec2(60, 60);

	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR [esi+16], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T4[ebp+4], 1114636288	; 42700000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4638 :         window->PosFloat = ImVec2(60, 60);

	mov	eax, DWORD PTR $T4[ebp+4]
	mov	DWORD PTR [esi+20], eax

; 4639 :         window->Pos = ImVec2((float)(int)window->PosFloat.x, (float)(int)window->PosFloat.y);

	cvttss2si eax, DWORD PTR [esi+16]

; 4640 : 
; 4641 :         ImGuiIniData* settings = FindWindowSettings(name);

	push	edi
	movd	xmm0, eax
	cvttss2si eax, DWORD PTR [esi+20]
	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp], xmm0
	movd	xmm0, eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4639 :         window->Pos = ImVec2((float)(int)window->PosFloat.x, (float)(int)window->PosFloat.y);

	mov	eax, DWORD PTR $T3[ebp]
	cvtdq2ps xmm0, xmm0
	mov	DWORD PTR [esi+24], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4639 :         window->Pos = ImVec2((float)(int)window->PosFloat.x, (float)(int)window->PosFloat.y);

	mov	eax, DWORD PTR $T3[ebp+4]
	mov	DWORD PTR [esi+28], eax

; 4640 : 
; 4641 :         ImGuiIniData* settings = FindWindowSettings(name);

	call	?FindWindowSettings@@YAPAUImGuiIniData@@PBD@Z ; FindWindowSettings
	mov	ecx, eax
	add	esp, 4

; 4642 :         if (!settings)

	test	ecx, ecx
	jne	SHORT $LN4@CreateNewW

; 4643 :         {
; 4644 :             settings = AddWindowSettings(name);

	push	edi
	call	?AddWindowSettings@@YAPAUImGuiIniData@@PBD@Z ; AddWindowSettings
	add	esp, 4
	mov	ecx, eax

; 4645 :         }
; 4646 :         else

	jmp	SHORT $LN5@CreateNewW
$LN4@CreateNewW:

; 4647 :         {
; 4648 :             window->SetWindowPosAllowFlags &= ~ImGuiSetCond_FirstUseEver;

	and	DWORD PTR [esi+176], -5			; fffffffbH

; 4649 :             window->SetWindowSizeAllowFlags &= ~ImGuiSetCond_FirstUseEver;

	and	DWORD PTR [esi+180], -5			; fffffffbH

; 4650 :             window->SetWindowCollapsedAllowFlags &= ~ImGuiSetCond_FirstUseEver;

	and	DWORD PTR [esi+184], -5			; fffffffbH
$LN5@CreateNewW:

; 4651 :         }
; 4652 : 
; 4653 :         if (settings->Pos.x != FLT_MAX)

	movss	xmm0, DWORD PTR [ecx+8]
	ucomiss	xmm0, DWORD PTR __real@7f7fffff
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN6@CreateNewW

; 4654 :         {
; 4655 :             window->PosFloat = settings->Pos;

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [esi+20], eax

; 4656 :             window->Pos = ImVec2((float)(int)window->PosFloat.x, (float)(int)window->PosFloat.y);

	cvttss2si eax, DWORD PTR [esi+16]
	movd	xmm0, eax
	cvttss2si eax, DWORD PTR [esi+20]
	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp], xmm0
	movd	xmm0, eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4656 :             window->Pos = ImVec2((float)(int)window->PosFloat.x, (float)(int)window->PosFloat.y);

	mov	eax, DWORD PTR $T2[ebp]
	cvtdq2ps xmm0, xmm0
	mov	DWORD PTR [esi+24], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4656 :             window->Pos = ImVec2((float)(int)window->PosFloat.x, (float)(int)window->PosFloat.y);

	mov	eax, DWORD PTR $T2[ebp+4]
	mov	DWORD PTR [esi+28], eax

; 4657 :             window->Collapsed = settings->Collapsed;

	mov	al, BYTE PTR [ecx+24]
	mov	BYTE PTR [esi+135], al
$LN6@CreateNewW:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 137  : static inline float  ImLengthSqr(const ImVec2& lhs)                             { return lhs.x*lhs.x + lhs.y*lhs.y; }

	movss	xmm1, DWORD PTR [ecx+20]
	movss	xmm0, DWORD PTR [ecx+16]
	mulss	xmm0, xmm0
	mulss	xmm1, xmm1
	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4660 :         if (ImLengthSqr(settings->Size) > 0.00001f && !(flags & ImGuiWindowFlags_NoResize))

	comiss	xmm0, DWORD PTR __real@3727c5ac
	jbe	SHORT $LN32@CreateNewW
	test	bl, 2
	jne	SHORT $LN32@CreateNewW

; 4661 :             size = settings->Size;

	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _size$[ebp], edx
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR _size$[ebp+4], eax
	jmp	SHORT $LN7@CreateNewW
$LN32@CreateNewW:
	mov	edx, DWORD PTR _size$[ebp]
$LN7@CreateNewW:

; 4662 :         window->Size = window->SizeFull = size;

	mov	DWORD PTR [esi+40], edx
$LN34@CreateNewW:
	mov	eax, DWORD PTR _size$[ebp+4]
	mov	DWORD PTR [esi+44], eax
	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR [esi+32], eax
	mov	eax, DWORD PTR _size$[ebp+4]
	mov	DWORD PTR [esi+36], eax

; 4663 :     }
; 4664 : 
; 4665 :     if ((flags & ImGuiWindowFlags_AlwaysAutoResize) != 0)

	test	bl, 64					; 00000040H
	je	SHORT $LN8@CreateNewW

; 4666 :     {
; 4667 :         window->AutoFitFramesX = window->AutoFitFramesY = 2;

	mov	DWORD PTR [esi+156], 2
	mov	DWORD PTR [esi+152], 2

; 4668 :         window->AutoFitOnlyGrows = false;

	mov	BYTE PTR [esi+160], 0

; 4669 :     }
; 4670 :     else

	jmp	SHORT $LN9@CreateNewW
$LN8@CreateNewW:
	xorps	xmm0, xmm0

; 4671 :     {
; 4672 :         if (window->Size.x <= 0.0f)

	comiss	xmm0, DWORD PTR [esi+32]
	jb	SHORT $LN10@CreateNewW

; 4673 :             window->AutoFitFramesX = 2;

	mov	DWORD PTR [esi+152], 2
$LN10@CreateNewW:

; 4674 :         if (window->Size.y <= 0.0f)

	comiss	xmm0, DWORD PTR [esi+36]
	jb	SHORT $LN11@CreateNewW

; 4675 :             window->AutoFitFramesY = 2;

	mov	DWORD PTR [esi+156], 2
$LN11@CreateNewW:

; 4676 :         window->AutoFitOnlyGrows = (window->AutoFitFramesX > 0) || (window->AutoFitFramesY > 0);

	cmp	DWORD PTR [esi+152], 0
	jg	SHORT $LN17@CreateNewW
	cmp	DWORD PTR [esi+156], 0
	jg	SHORT $LN17@CreateNewW
	xor	eax, eax
	jmp	SHORT $LN18@CreateNewW
$LN17@CreateNewW:
	mov	eax, 1
$LN18@CreateNewW:
	mov	BYTE PTR [esi+160], al
$LN9@CreateNewW:

; 4677 :     }
; 4678 : 
; 4679 :     if (flags & ImGuiWindowFlags_NoBringToFrontOnFocus)

	test	ebx, 8192				; 00002000H

; 4680 :         g.Windows.insert(g.Windows.begin(), window); // Quite slow but rare and only once

	lea	eax, DWORD PTR _window$[ebp]
	pop	ebx
	push	eax
	je	SHORT $LN12@CreateNewW
	mov	eax, DWORD PTR _g$1$[ebp]
	push	DWORD PTR [eax+6212]
	lea	ecx, DWORD PTR [eax+6204]
	call	?insert@?$ImVector@PAUImGuiWindow@@@@QAEPAPAUImGuiWindow@@PBQAU2@ABQAU2@@Z ; ImVector<ImGuiWindow *>::insert
	pop	edi

; 4683 :     return window;

	mov	eax, esi
	pop	esi

; 4684 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@CreateNewW:

; 4681 :     else
; 4682 :         g.Windows.push_back(window);

	mov	ecx, DWORD PTR _g$1$[ebp]
	add	ecx, 6204				; 0000183cH
	call	?push_back@?$ImVector@PAUImGuiWindow@@@@QAEXABQAUImGuiWindow@@@Z ; ImVector<ImGuiWindow *>::push_back

; 4684 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?CreateNewWindow@@YAPAUImGuiWindow@@PBDUImVec2@@H@Z$0:
	mov	eax, DWORD PTR _window$[ebp]
	push	eax
	mov	eax, DWORD PTR $T6[ebp]
	movzx	eax, BYTE PTR [eax]
	push	eax
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAXUImPlacementNewDummy@@0@Z	; operator delete
	add	esp, 12					; 0000000cH
	ret	0
__ehhandler$?CreateNewWindow@@YAPAUImGuiWindow@@PBDUImVec2@@H@Z:
	mov	eax, OFFSET __ehfuncinfo$?CreateNewWindow@@YAPAUImGuiWindow@@PBDUImVec2@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CreateNewWindow@@YAPAUImGuiWindow@@PBDUImVec2@@H@Z ENDP ; CreateNewWindow
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_pos$ = 8						; size = 8
_excluding_childs$ = 16					; size = 1
?FindHoveredWindow@@YAPAUImGuiWindow@@UImVec2@@_N@Z PROC ; FindHoveredWindow

; 3859 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi

; 3860 :     ImGuiContext& g = *GImGui;

	mov	edi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 3861 :     for (int i = g.Windows.Size-1; i >= 0; i--)

	mov	ecx, DWORD PTR [edi+6204]
	sub	ecx, 1
	js	$LN3@FindHovere
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	mov	eax, DWORD PTR [edi+6212]
	mov	bl, BYTE PTR _excluding_childs$[ebp]
	movss	xmm1, DWORD PTR _pos$[ebp+4]
	movss	xmm5, DWORD PTR _pos$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
$LL4@FindHovere:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3863 :         ImGuiWindow* window = g.Windows[i];

	mov	eax, DWORD PTR [edx]

; 3864 :         if (!window->Active)

	cmp	BYTE PTR [eax+132], 0
	je	SHORT $LN2@FindHovere

; 3865 :             continue;
; 3866 :         if (window->Flags & ImGuiWindowFlags_NoInputs)

	mov	esi, DWORD PTR [eax+8]
	test	esi, 512				; 00000200H
	jne	SHORT $LN2@FindHovere

; 3867 :             continue;
; 3868 :         if (excluding_childs && (window->Flags & ImGuiWindowFlags_ChildWindow) != 0)

	test	bl, bl
	je	SHORT $LN7@FindHovere
	test	esi, 4194304				; 00400000H
	jne	SHORT $LN2@FindHovere
$LN7@FindHovere:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [eax+488]
	subss	xmm0, DWORD PTR [edi+5384]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm3, DWORD PTR [edi+5384]
	movss	xmm4, DWORD PTR [edi+5388]

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm2, DWORD PTR [eax+492]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm3, DWORD PTR [eax+496]

; 252  :     bool        Contains(const ImVec2& p) const { return p.x >= Min.x     && p.y >= Min.y     && p.x < Max.x     && p.y < Max.y; }

	comiss	xmm5, xmm0

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm4, DWORD PTR [eax+500]

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm2, DWORD PTR [edi+5388]

; 252  :     bool        Contains(const ImVec2& p) const { return p.x >= Min.x     && p.y >= Min.y     && p.x < Max.x     && p.y < Max.y; }

	jb	SHORT $LN2@FindHovere
	comiss	xmm1, xmm2
	jb	SHORT $LN2@FindHovere
	comiss	xmm3, xmm5
	jbe	SHORT $LN2@FindHovere
	comiss	xmm4, xmm1
	ja	SHORT $LN1@FindHovere
$LN2@FindHovere:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3861 :     for (int i = g.Windows.Size-1; i >= 0; i--)

	sub	edx, 4
	sub	ecx, 1
	jns	SHORT $LL4@FindHovere
$LN3@FindHovere:

; 3869 :             continue;
; 3870 : 
; 3871 :         // Using the clipped AABB so a child window will typically be clipped by its parent.
; 3872 :         ImRect bb(window->WindowRectClipped.Min - g.Style.TouchExtraPadding, window->WindowRectClipped.Max + g.Style.TouchExtraPadding);
; 3873 :         if (bb.Contains(pos))
; 3874 :             return window;
; 3875 :     }
; 3876 :     return NULL;

	xor	eax, eax
$LN1@FindHovere:
	pop	edi
	pop	esi
	pop	ebx

; 3877 : }

	pop	ebp
	ret	0
?FindHoveredWindow@@YAPAUImGuiWindow@@UImVec2@@_N@Z ENDP ; FindHoveredWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_window$ = 8						; size = 4
_collapsed$ = 12					; size = 1
_cond$ = 16						; size = 4
?SetWindowCollapsed@@YAXPAUImGuiWindow@@_NH@Z PROC	; SetWindowCollapsed

; 5934 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 5935 :     // Test condition (NB: bit 0 is always true) and clear flags for next time
; 5936 :     if (cond && (window->SetWindowCollapsedAllowFlags & cond) == 0)

	mov	eax, DWORD PTR _cond$[ebp]
	mov	ecx, DWORD PTR _window$[ebp]
	test	eax, eax
	je	SHORT $LN2@SetWindowC
	test	DWORD PTR [ecx+184], eax
	je	SHORT $LN1@SetWindowC
$LN2@SetWindowC:

; 5937 :         return;
; 5938 :     window->SetWindowCollapsedAllowFlags &= ~(ImGuiSetCond_Once | ImGuiSetCond_FirstUseEver | ImGuiSetCond_Appearing);
; 5939 : 
; 5940 :     // Set
; 5941 :     window->Collapsed = collapsed;

	mov	al, BYTE PTR _collapsed$[ebp]
	and	DWORD PTR [ecx+184], -15		; fffffff1H
	mov	BYTE PTR [ecx+135], al
$LN1@SetWindowC:

; 5942 : }

	pop	ebp
	ret	0
?SetWindowCollapsed@@YAXPAUImGuiWindow@@_NH@Z ENDP	; SetWindowCollapsed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_window$ = 8						; size = 4
_size$ = 12						; size = 4
_cond$ = 16						; size = 4
?SetWindowSize@@YAXPAUImGuiWindow@@ABUImVec2@@H@Z PROC	; SetWindowSize

; 5892 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 5893 :     // Test condition (NB: bit 0 is always true) and clear flags for next time
; 5894 :     if (cond && (window->SetWindowSizeAllowFlags & cond) == 0)

	mov	eax, DWORD PTR _cond$[ebp]
	mov	ecx, DWORD PTR _window$[ebp]
	test	eax, eax
	je	SHORT $LN2@SetWindowS
	test	DWORD PTR [ecx+180], eax
	je	SHORT $LN6@SetWindowS
$LN2@SetWindowS:

; 5895 :         return;
; 5896 :     window->SetWindowSizeAllowFlags &= ~(ImGuiSetCond_Once | ImGuiSetCond_FirstUseEver | ImGuiSetCond_Appearing);
; 5897 : 
; 5898 :     // Set
; 5899 :     if (size.x > 0.0f)

	mov	edx, DWORD PTR _size$[ebp]
	xorps	xmm1, xmm1
	and	DWORD PTR [ecx+180], -15		; fffffff1H
	movss	xmm0, DWORD PTR [edx]
	comiss	xmm0, xmm1
	jbe	SHORT $LN3@SetWindowS

; 5900 :     {
; 5901 :         window->AutoFitFramesX = 0;

	mov	DWORD PTR [ecx+152], 0

; 5902 :         window->SizeFull.x = size.x;

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+40], eax

; 5903 :     }
; 5904 :     else

	jmp	SHORT $LN4@SetWindowS
$LN3@SetWindowS:

; 5905 :     {
; 5906 :         window->AutoFitFramesX = 2;

	mov	DWORD PTR [ecx+152], 2

; 5907 :         window->AutoFitOnlyGrows = false;

	mov	BYTE PTR [ecx+160], 0
$LN4@SetWindowS:

; 5908 :     }
; 5909 :     if (size.y > 0.0f)

	movss	xmm0, DWORD PTR [edx+4]
	comiss	xmm0, xmm1
	jbe	SHORT $LN5@SetWindowS

; 5910 :     {
; 5911 :         window->AutoFitFramesY = 0;

	mov	DWORD PTR [ecx+156], 0

; 5912 :         window->SizeFull.y = size.y;

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+44], eax

; 5918 :     }
; 5919 : }

	pop	ebp
	ret	0
$LN5@SetWindowS:

; 5913 :     }
; 5914 :     else
; 5915 :     {
; 5916 :         window->AutoFitFramesY = 2;

	mov	DWORD PTR [ecx+156], 2

; 5917 :         window->AutoFitOnlyGrows = false;

	mov	BYTE PTR [ecx+160], 0
$LN6@SetWindowS:

; 5918 :     }
; 5919 : }

	pop	ebp
	ret	0
?SetWindowSize@@YAXPAUImGuiWindow@@ABUImVec2@@H@Z ENDP	; SetWindowSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_old_pos$ = -16						; size = 8
$T3 = -8						; size = 8
_window$ = 8						; size = 4
_pos$ = 12						; size = 4
_cond$ = 16						; size = 4
?SetWindowPos@@YAXPAUImGuiWindow@@ABUImVec2@@H@Z PROC	; SetWindowPos

; 5858 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 5859 :     // Test condition (NB: bit 0 is always true) and clear flags for next time
; 5860 :     if (cond && (window->SetWindowPosAllowFlags & cond) == 0)

	mov	eax, DWORD PTR _cond$[ebp]
	sub	esp, 16					; 00000010H
	mov	edx, DWORD PTR _window$[ebp]
	test	eax, eax
	je	SHORT $LN2@SetWindowP
	test	DWORD PTR [edx+176], eax
	je	$LN1@SetWindowP
$LN2@SetWindowP:

; 5861 :         return;
; 5862 :     window->SetWindowPosAllowFlags &= ~(ImGuiSetCond_Once | ImGuiSetCond_FirstUseEver | ImGuiSetCond_Appearing);

	and	DWORD PTR [edx+176], -15		; fffffff1H

; 5863 :     window->SetWindowPosCenterWanted = false;
; 5864 : 
; 5865 :     // Set
; 5866 :     const ImVec2 old_pos = window->Pos;

	mov	eax, DWORD PTR [edx+24]

; 5867 :     window->PosFloat = pos;

	mov	ecx, DWORD PTR _pos$[ebp]
	mov	BYTE PTR [edx+188], 0
	mov	DWORD PTR _old_pos$[ebp], eax
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR _old_pos$[ebp+4], eax
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+20], eax

; 5868 :     window->Pos = ImVec2((float)(int)window->PosFloat.x, (float)(int)window->PosFloat.y);

	cvttss2si eax, DWORD PTR [edx+16]
	movd	xmm0, eax
	cvttss2si eax, DWORD PTR [edx+20]
	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp], xmm0
	movd	xmm0, eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5868 :     window->Pos = ImVec2((float)(int)window->PosFloat.x, (float)(int)window->PosFloat.y);

	mov	eax, DWORD PTR $T3[ebp]
	cvtdq2ps xmm0, xmm0
	mov	DWORD PTR [edx+24], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5868 :     window->Pos = ImVec2((float)(int)window->PosFloat.x, (float)(int)window->PosFloat.y);

	mov	eax, DWORD PTR $T3[ebp+4]
	mov	DWORD PTR [edx+28], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm1, DWORD PTR [edx+24]
	movss	xmm2, DWORD PTR [edx+28]
	subss	xmm1, DWORD PTR _old_pos$[ebp]
	subss	xmm2, DWORD PTR _old_pos$[ebp+4]

; 118  : static inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }

	movss	xmm0, DWORD PTR [edx+192]
	addss	xmm0, xmm1
	addss	xmm2, DWORD PTR [edx+196]
	movss	DWORD PTR [edx+192], xmm0
	movss	DWORD PTR [edx+196], xmm2

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [edx+24]
	subss	xmm0, DWORD PTR _old_pos$[ebp]
	movss	xmm1, DWORD PTR [edx+28]
	subss	xmm1, DWORD PTR _old_pos$[ebp+4]

; 118  : static inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }

	addss	xmm0, DWORD PTR [edx+216]
	movss	DWORD PTR [edx+216], xmm0
	movss	xmm0, DWORD PTR [edx+220]
	addss	xmm0, xmm1
	movss	DWORD PTR [edx+220], xmm0
$LN1@SetWindowP:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5871 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetWindowPos@@YAXPAUImGuiWindow@@ABUImVec2@@H@Z ENDP	; SetWindowPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_window$ = 8						; size = 4
_new_scroll_y$ = 12					; size = 4
?SetWindowScrollY@@YAXPAUImGuiWindow@@M@Z PROC		; SetWindowScrollY

; 5851 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 5852 :     window->DC.CursorMaxPos.y += window->Scroll.y; // SizeContents is generally computed based on CursorMaxPos which is affected by scroll position, so we need to apply our change to it.

	mov	eax, DWORD PTR _window$[ebp]

; 5853 :     window->Scroll.y = new_scroll_y;

	movss	xmm1, DWORD PTR _new_scroll_y$[ebp]
	movss	xmm0, DWORD PTR [eax+96]
	addss	xmm0, DWORD PTR [eax+220]
	movss	DWORD PTR [eax+96], xmm1

; 5854 :     window->DC.CursorMaxPos.y -= window->Scroll.y;

	subss	xmm0, xmm1
	movss	DWORD PTR [eax+220], xmm0

; 5855 : }

	pop	ebp
	ret	0
?SetWindowScrollY@@YAXPAUImGuiWindow@@M@Z ENDP		; SetWindowScrollY
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_window$ = 8						; size = 4
_new_scroll_x$ = 12					; size = 4
?SetWindowScrollX@@YAXPAUImGuiWindow@@M@Z PROC		; SetWindowScrollX

; 5844 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 5845 :     window->DC.CursorMaxPos.x += window->Scroll.x; // SizeContents is generally computed based on CursorMaxPos which is affected by scroll position, so we need to apply our change to it.

	mov	eax, DWORD PTR _window$[ebp]

; 5846 :     window->Scroll.x = new_scroll_x;

	movss	xmm1, DWORD PTR _new_scroll_x$[ebp]
	movss	xmm0, DWORD PTR [eax+92]
	addss	xmm0, DWORD PTR [eax+216]
	movss	DWORD PTR [eax+92], xmm1

; 5847 :     window->DC.CursorMaxPos.x -= window->Scroll.x;

	subss	xmm0, xmm1
	movss	DWORD PTR [eax+216], xmm0

; 5848 : }

	pop	ebp
	ret	0
?SetWindowScrollX@@YAXPAUImGuiWindow@@M@Z ENDP		; SetWindowScrollX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_window$ = 8						; size = 4
?SetCurrentWindow@@YAXPAUImGuiWindow@@@Z PROC		; SetCurrentWindow

; 1914 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1915 :     ImGuiContext& g = *GImGui;

	mov	edx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 1916 :     g.CurrentWindow = window;

	mov	ecx, DWORD PTR _window$[ebp]
	mov	DWORD PTR [edx+6240], ecx

; 1917 :     if (window)

	test	ecx, ecx
	je	SHORT $LN2@SetCurrent
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	movss	xmm0, DWORD PTR [eax+6176]
	mulss	xmm0, DWORD PTR [ecx+620]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1918 :         g.FontSize = window->CalcFontSize();

	movss	DWORD PTR [edx+6172], xmm0
$LN2@SetCurrent:

; 1919 : }

	pop	ebp
	ret	0
?SetCurrentWindow@@YAXPAUImGuiWindow@@@Z ENDP		; SetCurrentWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_font$ = 8						; size = 4
?SetCurrentFont@@YAXPAUImFont@@@Z PROC			; SetCurrentFont

; 5568 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 5569 :     ImGuiContext& g = *GImGui;

	mov	edx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	ecx, DWORD PTR _font$[ebp]
	push	esi

; 5570 :     IM_ASSERT(font && font->IsLoaded());    // Font Atlas not created. Did you call io.Fonts->GetTexDataAsRGBA32 / GetTexDataAsAlpha8 ?
; 5571 :     IM_ASSERT(font->Scale > 0.0f);
; 5572 :     g.Font = font;
; 5573 :     g.FontBaseSize = g.IO.FontGlobalScale * g.Font->FontSize * g.Font->Scale;

	movss	xmm0, DWORD PTR [edx+136]

; 5574 :     g.FontSize = g.CurrentWindow ? g.CurrentWindow->CalcFontSize() : 0.0f;

	mov	esi, DWORD PTR [edx+6240]
	mov	DWORD PTR [edx+6168], ecx
	mulss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR [ecx+4]
	movss	DWORD PTR [edx+6176], xmm0
	test	esi, esi
	je	SHORT $LN3@SetCurrent
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	movss	xmm0, DWORD PTR [eax+6176]
	mulss	xmm0, DWORD PTR [esi+620]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5574 :     g.FontSize = g.CurrentWindow ? g.CurrentWindow->CalcFontSize() : 0.0f;

	jmp	SHORT $LN4@SetCurrent
$LN3@SetCurrent:
	xorps	xmm0, xmm0
$LN4@SetCurrent:
	movss	DWORD PTR [edx+6172], xmm0

; 5575 :     g.FontTexUvWhitePixel = g.Font->ContainerAtlas->TexUvWhitePixel;

	mov	ecx, DWORD PTR [ecx+68]
	pop	esi
	mov	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR [edx+6180], eax
	mov	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR [edx+6184], eax

; 5576 : }

	pop	ebp
	ret	0
?SetCurrentFont@@YAXPAUImFont@@@Z ENDP			; SetCurrentFont
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?GetDefaultFont@@YAPAUImFont@@XZ PROC			; GetDefaultFont

; 5563 :     ImGuiContext& g = *GImGui;

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 5564 :     return g.IO.FontDefault ? g.IO.FontDefault : g.IO.Fonts->Fonts[0];

	mov	eax, DWORD PTR [ecx+144]
	test	eax, eax
	jne	SHORT $LN4@GetDefault
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	mov	eax, DWORD PTR [ecx+132]
	mov	eax, DWORD PTR [eax+40]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5564 :     return g.IO.FontDefault ? g.IO.FontDefault : g.IO.Fonts->Fonts[0];

	mov	eax, DWORD PTR [eax]
$LN4@GetDefault:

; 5565 : }

	ret	0
?GetDefaultFont@@YAPAUImFont@@XZ ENDP			; GetDefaultFont
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_key$ = 8						; size = 4
_repeat$ = 12						; size = 1
?IsKeyPressedMap@@YA_NH_N@Z PROC			; IsKeyPressedMap

; 3918 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 3919 :     const int key_index = GImGui->IO.KeyMap[key];

	mov	ecx, DWORD PTR _key$[ebp]
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [eax+ecx*4+40]

; 3920 :     return (key_index >= 0) ? ImGui::IsKeyPressed(key_index, repeat) : false;

	test	eax, eax
	js	SHORT $LN3@IsKeyPress
	mov	DWORD PTR _key$[ebp], eax

; 3921 : }

	pop	ebp

; 3920 :     return (key_index >= 0) ? ImGui::IsKeyPressed(key_index, repeat) : false;

	jmp	?IsKeyPressed@ImGui@@YA_NH_N@Z		; ImGui::IsKeyPressed
$LN3@IsKeyPress:
	xor	al, al

; 3921 : }

	pop	ebp
	ret	0
?IsKeyPressedMap@@YA_NH_N@Z ENDP			; IsKeyPressedMap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_mx$ = -8						; size = 4
_x$1$ = -4						; size = 4
tv187 = 8						; size = 4
_mn$ = 8						; size = 4
_column_index$ = 8					; size = 4
?GetDraggedColumnOffset@@YAMH@Z PROC			; GetDraggedColumnOffset

; 10451: {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 10460:     x = ImClamp(x, ImGui::GetColumnOffset(column_index-1)+g.Style.ColumnsMinSpacing, ImGui::GetColumnOffset(column_index+1)-g.Style.ColumnsMinSpacing);

	mov	esi, DWORD PTR _column_index$[ebp]
	push	edi
	mov	edi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	movss	xmm0, DWORD PTR [edi+208]
	subss	xmm0, DWORD PTR [edi+6280]
	mov	eax, DWORD PTR [edi+6240]
	subss	xmm0, DWORD PTR [eax+24]
	lea	eax, DWORD PTR [esi-1]
	push	eax
	movss	DWORD PTR _x$1$[ebp], xmm0
	call	?GetColumnOffset@ImGui@@YAMH@Z		; ImGui::GetColumnOffset
	fadd	DWORD PTR [edi+5396]
	lea	eax, DWORD PTR [esi+1]
	push	eax
	fstp	DWORD PTR _mn$[ebp]
	call	?GetColumnOffset@ImGui@@YAMH@Z		; ImGui::GetColumnOffset
	fsub	DWORD PTR [edi+5396]
	add	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	movss	xmm0, DWORD PTR _mn$[ebp]
	movss	xmm1, DWORD PTR _x$1$[ebp]
	comiss	xmm0, xmm1
	pop	edi
	pop	esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10460:     x = ImClamp(x, ImGui::GetColumnOffset(column_index-1)+g.Style.ColumnsMinSpacing, ImGui::GetColumnOffset(column_index+1)-g.Style.ColumnsMinSpacing);

	fstp	DWORD PTR _mx$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	ja	SHORT $LN7@GetDragged
	movss	xmm0, DWORD PTR _mx$[ebp]
	minss	xmm0, xmm1
$LN7@GetDragged:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10462:     return (float)(int)x;

	cvttss2si eax, xmm0
	mov	DWORD PTR tv187[ebp], eax
	fild	DWORD PTR tv187[ebp]

; 10463: }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetDraggedColumnOffset@@YAMH@Z ENDP			; GetDraggedColumnOffset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_window$1$ = -8						; size = 4
_w_item_last$ = -4					; size = 4
tv360 = 8						; size = 4
_components$ = 8					; size = 4
_w_item_one$1$ = 12					; size = 4
_w_full$ = 12						; size = 4
?PushMultiItemsWidths@@YAXHM@Z PROC			; PushMultiItemsWidths

; 5527 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	xorps	xmm0, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5530 :     if (w_full <= 0.0f)

	movss	xmm4, DWORD PTR _w_full$[ebp]
	comiss	xmm0, xmm4
	push	ebx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	push	esi
	push	edi
	mov	BYTE PTR [eax+134], 1
	mov	edi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5529 :     const ImGuiStyle& style = GImGui->Style;

	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	DWORD PTR _window$1$[ebp], edi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5530 :     if (w_full <= 0.0f)

	jb	SHORT $LN5@PushMultiI

; 5531 :         w_full = ImGui::CalcItemWidth();

	call	?CalcItemWidth@ImGui@@YAMXZ		; ImGui::CalcItemWidth
	fstp	DWORD PTR _w_full$[ebp]
	movss	xmm4, DWORD PTR _w_full$[ebp]
$LN5@PushMultiI:

; 5532 :     const float w_item_one  = ImMax(1.0f, (float)(int)((w_full - (style.ItemInnerSpacing.x) * (components-1)) / (float)components));

	mov	eax, DWORD PTR _components$[ebp]
	movaps	xmm1, xmm4
	movss	xmm3, DWORD PTR [esi+5376]

; 5534 :     window->DC.ItemWidthStack.push_back(w_item_last);

	lea	esi, DWORD PTR [edi+336]
	mov	ecx, esi
	lea	ebx, DWORD PTR [eax-1]
	movd	xmm2, ebx
	cvtdq2ps xmm2, xmm2
	mov	DWORD PTR tv360[ebp], ebx
	movaps	xmm0, xmm2
	mulss	xmm0, xmm3
	subss	xmm1, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	divss	xmm1, xmm0
	cvttss2si eax, xmm1
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	maxss	xmm0, DWORD PTR __real@3f800000
	addss	xmm3, xmm0
	movss	DWORD PTR _w_item_one$1$[ebp], xmm0
	mulss	xmm3, xmm2
	subss	xmm4, xmm3
	cvttss2si eax, xmm4
	movd	xmm0, eax
	lea	eax, DWORD PTR _w_item_last$[ebp]
	cvtdq2ps xmm0, xmm0
	push	eax
	maxss	xmm0, DWORD PTR __real@3f800000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 128  : static inline float  ImMax(float lhs, float rhs)                                { return lhs >= rhs ? lhs : rhs; }

	movss	DWORD PTR _w_item_last$[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5534 :     window->DC.ItemWidthStack.push_back(w_item_last);

	call	?push_back@?$ImVector@M@@QAEXABM@Z	; ImVector<float>::push_back

; 5535 :     for (int i = 0; i < components-1; i++)

	test	ebx, ebx
	jle	$LN3@PushMultiI
	movss	xmm0, DWORD PTR _w_item_one$1$[ebp]
$LL4@PushMultiI:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	edi, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jne	SHORT $LN24@PushMultiI
	inc	edi

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN22@PushMultiI
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN23@PushMultiI
$LN22@PushMultiI:
	mov	eax, 8
$LN23@PushMultiI:
	cmp	eax, edi
	cmovg	edi, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	edi, ecx
	jle	SHORT $LN24@PushMultiI

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*4]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN26@PushMultiI

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN26@PushMultiI:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	movss	xmm0, DWORD PTR _w_item_one$1$[ebp]
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx
	mov	ebx, DWORD PTR tv360[ebp]

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
$LN24@PushMultiI:

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+8]
	movss	DWORD PTR [eax+ecx*4], xmm0
	inc	DWORD PTR [esi]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5535 :     for (int i = 0; i < components-1; i++)

	sub	ebx, 1
	mov	DWORD PTR tv360[ebp], ebx
	jne	SHORT $LL4@PushMultiI
	mov	edi, DWORD PTR _window$1$[ebp]
$LN3@PushMultiI:

; 5536 :         window->DC.ItemWidthStack.push_back(w_item_one);
; 5537 :     window->DC.ItemWidth = window->DC.ItemWidthStack.back();

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	mov	DWORD PTR [edi+316], eax
	pop	edi
	pop	esi
	pop	ebx

; 5538 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PushMultiItemsWidths@@YAXHM@Z ENDP			; PushMultiItemsWidths
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_tree_depth$1$ = 8					; size = 4
_ref_pos$ = 8						; size = 4
_text$ = 12						; size = 4
_text_end$ = 16						; size = 4
_log_new_line$1$ = 19					; size = 1
?LogRenderedText@@YAXABUImVec2@@PBD1@Z PROC		; LogRenderedText

; 3591 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 3595 :     if (!text_end)

	mov	eax, DWORD PTR _text$[ebp]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _text_end$[ebp]
	push	edi
	mov	edi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 792  :     inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }

	mov	ebx, DWORD PTR [edi+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3595 :     if (!text_end)

	test	esi, esi
	jne	SHORT $LN7@LogRendere

; 3596 :         text_end = ImGui::FindRenderedTextEnd(text, text_end);

	push	0
	push	eax
	call	?FindRenderedTextEnd@ImGui@@YAPBDPBD0@Z	; ImGui::FindRenderedTextEnd
	mov	esi, eax
	add	esp, 8
	mov	eax, DWORD PTR _text$[ebp]
$LN7@LogRendere:

; 3597 : 
; 3598 :     const bool log_new_line = ref_pos.y > window->DC.LogLinePosY+1;

	movss	xmm0, DWORD PTR [ebx+240]
	mov	ecx, DWORD PTR _ref_pos$[ebp]
	addss	xmm0, DWORD PTR __real@3f800000
	movss	xmm1, DWORD PTR [ecx+4]

; 3599 :     window->DC.LogLinePosY = ref_pos.y;
; 3600 : 
; 3601 :     const char* text_remaining = text;

	mov	ecx, eax

; 3602 :     if (g.LogStartDepth > window->DC.TreeDepth)  // Re-adjust padding if we have popped out of our starting depth

	mov	eax, DWORD PTR [ebx+244]
	comiss	xmm1, xmm0
	movss	DWORD PTR [ebx+240], xmm1
	seta	BYTE PTR _log_new_line$1$[ebp]
	cmp	DWORD PTR [edi+11612], eax
	jle	SHORT $LN8@LogRendere

; 3603 :         g.LogStartDepth = window->DC.TreeDepth;

	mov	DWORD PTR [edi+11612], eax
$LN8@LogRendere:

; 3604 :     const int tree_depth = (window->DC.TreeDepth - g.LogStartDepth);

	mov	edx, DWORD PTR [ebx+244]
	sub	edx, DWORD PTR [edi+11612]
	mov	DWORD PTR _tree_depth$1$[ebp], edx
	npad	6
$LL2@LogRendere:

; 3605 :     for (;;)
; 3606 :     {
; 3607 :         // Split the string. Each new line (after a '\n') is followed by spacing corresponding to the current depth of our log entry.
; 3608 :         const char* line_end = text_remaining;

	mov	eax, ecx

; 3609 :         while (line_end < text_end)

	cmp	ecx, esi
	jae	SHORT $LN31@LogRendere
$LL5@LogRendere:

; 3610 :             if (*line_end == '\n')

	cmp	BYTE PTR [eax], 10			; 0000000aH
	je	SHORT $LN31@LogRendere

; 3611 :                 break;
; 3612 :             else
; 3613 :                 line_end++;

	inc	eax
	cmp	eax, esi
	jb	SHORT $LL5@LogRendere
$LN31@LogRendere:
	cmp	eax, esi
	sbb	ebx, ebx
	and	ebx, eax

; 3614 :         if (line_end >= text_end)
; 3615 :             line_end = NULL;
; 3616 : 
; 3617 :         const bool is_first_line = (text == text_remaining);
; 3618 :         bool is_last_line = false;
; 3619 :         if (line_end == NULL)

	mov	edi, ebx
	cmove	edi, esi

; 3620 :         {
; 3621 :             is_last_line = true;
; 3622 :             line_end = text_end;
; 3623 :         }
; 3624 :         if (line_end != NULL && !(is_last_line && (line_end - text_remaining)==0))

	test	edi, edi
	je	SHORT $LN16@LogRendere
	test	ebx, ebx
	jne	SHORT $LN14@LogRendere
	mov	eax, edi
	sub	eax, ecx
	je	SHORT $LN16@LogRendere
$LN14@LogRendere:

; 3625 :         {
; 3626 :             const int char_count = (int)(line_end - text_remaining);

	mov	eax, edi
	sub	eax, ecx

; 3627 :             if (log_new_line || !is_first_line)

	cmp	BYTE PTR _log_new_line$1$[ebp], 0
	jne	SHORT $LN17@LogRendere
	cmp	DWORD PTR _text$[ebp], ecx
	jne	SHORT $LN17@LogRendere

; 3629 :             else
; 3630 :                 ImGui::LogText(" %.*s", char_count, text_remaining);

	push	ecx
	push	eax
	push	OFFSET $SG117183
	call	?LogText@ImGui@@YAXPBDZZ		; ImGui::LogText
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN32@LogRendere
$LN17@LogRendere:

; 3628 :                 ImGui::LogText(IM_NEWLINE "%*s%.*s", tree_depth*4, "", char_count, text_remaining);

	push	ecx
	push	eax
	push	OFFSET $SG117181
	lea	eax, DWORD PTR [edx*4]
	push	eax
	push	OFFSET $SG117182
	call	?LogText@ImGui@@YAXPBDZZ		; ImGui::LogText
	add	esp, 20					; 00000014H
$LN32@LogRendere:
	mov	edx, DWORD PTR _tree_depth$1$[ebp]
$LN16@LogRendere:
	test	ebx, ebx

; 3631 :         }
; 3632 : 
; 3633 :         if (is_last_line)

	je	SHORT $LN26@LogRendere

; 3634 :             break;
; 3635 :         text_remaining = line_end + 1;

	lea	ecx, DWORD PTR [edi+1]

; 3636 :     }

	jmp	SHORT $LL2@LogRendere
$LN26@LogRendere:
	pop	edi
	pop	esi
	pop	ebx

; 3637 : }

	pop	ebp
	ret	0
?LogRenderedText@@YAXABUImVec2@@PBD1@Z ENDP		; LogRenderedText
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits
;	COMDAT ?max@?$numeric_limits@M@std@@SAMXZ
_TEXT	SEGMENT
?max@?$numeric_limits@M@std@@SAMXZ PROC			; std::numeric_limits<float>::max, COMDAT

; 1089 : 		return (_FLT_MAX);

	fld	DWORD PTR __real@7f7fffff

; 1090 : 		}

	ret	0
?max@?$numeric_limits@M@std@@SAMXZ ENDP			; std::numeric_limits<float>::max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits
;	COMDAT ?min@?$numeric_limits@M@std@@SAMXZ
_TEXT	SEGMENT
?min@?$numeric_limits@M@std@@SAMXZ PROC			; std::numeric_limits<float>::min, COMDAT

; 1084 : 		return (_FLT_MIN);

	fld	DWORD PTR __real@00800000

; 1085 : 		}

	ret	0
?min@?$numeric_limits@M@std@@SAMXZ ENDP			; std::numeric_limits<float>::min
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\cmath
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\cmath
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
tv68 = 8						; size = 4
__Xx$ = 8						; size = 4
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 286  : 	{

	npad	2
	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR __Xx$[ebp]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 746  :         return (float)sqrt(_X);

	sqrtss	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\cmath

; 287  : 	return (_CSTD sqrtf(_Xx));

	movss	DWORD PTR tv68[ebp], xmm0
	fld	DWORD PTR tv68[ebp]

; 288  : 	}

	pop	ebp
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdlib.h
;	COMDAT ?abs@@YAJJ@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?abs@@YAJJ@Z PROC					; abs, COMDAT

; 355  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 356  :         return labs(_X);

	mov	eax, DWORD PTR __X$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx

; 357  :     }

	pop	ebp
	ret	0
?abs@@YAJJ@Z ENDP					; abs
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_remainder$ = -12					; size = 4
_min_step$ = -8						; size = 4
_negative$1$ = -1					; size = 1
tv82 = 8						; size = 4
_value$ = 8						; size = 4
_decimal_precision$ = 12				; size = 4
?RoundScalar@ImGui@@YAMMH@Z PROC			; ImGui::RoundScalar

; 7424 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 7428 :     const float min_step = GetMinimumStepAtDecimalPrecision(decimal_precision);

	push	DWORD PTR _decimal_precision$[ebp]
	call	?GetMinimumStepAtDecimalPrecision@@YAMH@Z ; GetMinimumStepAtDecimalPrecision

; 7429 :     bool negative = value < 0.0f;

	movss	xmm1, DWORD PTR _value$[ebp]
	xorps	xmm0, xmm0
	add	esp, 4
	comiss	xmm0, xmm1
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 658  :         return (float)fabs(_X);

	andps	xmm1, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7428 :     const float min_step = GetMinimumStepAtDecimalPrecision(decimal_precision);

	fst	DWORD PTR _min_step$[ebp]

; 7430 :     value = fabsf(value);

	movss	DWORD PTR _value$[ebp], xmm1
	seta	BYTE PTR _negative$1$[ebp]
	fld	DWORD PTR _value$[ebp]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 677  :         return (float)fmod(_X, _Y);

	fxch	ST(1)
	call	__CIfmod
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7432 :     if (remainder <= min_step*0.5f)

	movss	xmm1, DWORD PTR _min_step$[ebp]
	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR __real@3f000000
	fstp	DWORD PTR _remainder$[ebp]
	movss	xmm2, DWORD PTR _remainder$[ebp]
	comiss	xmm0, xmm2

; 7433 :         value -= remainder;

	movss	xmm0, DWORD PTR _value$[ebp]
	jb	SHORT $LN2@RoundScala
	subss	xmm0, xmm2

; 7434 :     else

	jmp	SHORT $LN3@RoundScala
$LN2@RoundScala:

; 7435 :         value += (min_step - remainder);

	subss	xmm1, xmm2
	addss	xmm0, xmm1
$LN3@RoundScala:

; 7436 :     return negative ? -value : value;

	cmp	BYTE PTR _negative$1$[ebp], 0
	je	SHORT $LN5@RoundScala
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
$LN5@RoundScala:
	movss	DWORD PTR tv82[ebp], xmm0
	fld	DWORD PTR tv82[ebp]

; 7437 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RoundScalar@ImGui@@YAMMH@Z ENDP			; ImGui::RoundScalar
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_fmt$ = 8						; size = 4
_default_precision$ = 12				; size = 4
?ParseFormatPrecision@ImGui@@YAHPBDH@Z PROC		; ImGui::ParseFormatPrecision

; 7398 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 7399 :     int precision = default_precision;

	mov	esi, DWORD PTR _default_precision$[ebp]
	push	edi

; 7400 :     while ((fmt = strchr(fmt, '%')) != NULL)

	mov	edi, DWORD PTR __imp__strchr
	push	37					; 00000025H
	push	DWORD PTR _fmt$[ebp]
	call	edi
	add	esp, 8
	test	eax, eax
	je	SHORT $LN21@ParseForma
	npad	2
$LL2@ParseForma:

; 7401 :     {
; 7402 :         fmt++;

	inc	eax

; 7403 :         if (fmt[0] == '%') { fmt++; continue; } // Ignore "%%"

	cmp	BYTE PTR [eax], 37			; 00000025H
	jne	SHORT $LN12@ParseForma
	inc	eax
	push	37					; 00000025H
	push	eax
	call	edi
	add	esp, 8
	test	eax, eax
	jne	SHORT $LL2@ParseForma

; 7410 :                 precision = default_precision;
; 7411 :         }
; 7412 :         break;
; 7413 :     }
; 7414 :     return precision;

	pop	edi
	mov	eax, esi
	pop	esi

; 7415 : }

	pop	ebp
	ret	0
$LN12@ParseForma:

; 7404 :         while (*fmt >= '0' && *fmt <= '9')

	mov	cl, BYTE PTR [eax]
	cmp	cl, 48					; 00000030H
	jl	SHORT $LN22@ParseForma
$LL4@ParseForma:
	cmp	cl, 57					; 00000039H
	jg	SHORT $LN22@ParseForma
	mov	cl, BYTE PTR [eax+1]

; 7405 :             fmt++;

	inc	eax
	cmp	cl, 48					; 00000030H
	jge	SHORT $LL4@ParseForma
$LN22@ParseForma:

; 7406 :         if (*fmt == '.')

	cmp	BYTE PTR [eax], 46			; 0000002eH
	jne	SHORT $LN21@ParseForma

; 7407 :         {
; 7408 :             precision = atoi(fmt + 1);

	inc	eax
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4

; 7409 :             if (precision < 0 || precision > 10)

	test	eax, eax
	js	SHORT $LN21@ParseForma
	cmp	eax, 10					; 0000000aH
	jle	SHORT $LN8@ParseForma
$LN21@ParseForma:

; 7410 :                 precision = default_precision;
; 7411 :         }
; 7412 :         break;
; 7413 :     }
; 7414 :     return precision;

	mov	eax, esi
$LN8@ParseForma:
	pop	edi
	pop	esi

; 7415 : }

	pop	ebp
	ret	0
?ParseFormatPrecision@ImGui@@YAHPBDH@Z ENDP		; ImGui::ParseFormatPrecision
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T5 = -140						; size = 16
tv588 = -124						; size = 4
_b$6 = -120						; size = 4
_g$7 = -116						; size = 4
_r$8 = -112						; size = 4
tv716 = -108						; size = 4
tv713 = -104						; size = 4
_t_step$1$ = -100					; size = 4
_total_bb$ = -96					; size = 16
$T9 = -88						; size = 8
_pos0$10 = -88						; size = 8
$T11 = -80						; size = 8
_pos1$12 = -80						; size = 8
_tp0$3$sroa$298$1$ = -72				; size = 4
_t1$1$ = -68						; size = 4
$T2$sroa$466$1$ = -64					; size = 4
_frame_bb$ = -60					; size = 16
$T13 = -44						; size = 8
_label_size$ = -44					; size = 8
$T2$sroa$398$1$ = -36					; size = 4
$T1$sroa$468$1$ = -32					; size = 4
$T1$sroa$469$1$ = -28					; size = 4
$T14 = -24						; size = 8
$T15 = -24						; size = 8
tv715 = -20						; size = 4
_tp1$4$sroa$402$1$ = -16				; size = 4
_v0$16 = -16						; size = 4
_v$17 = -16						; size = 4
_tp0$3$sroa$297$1$ = -12				; size = 4
_v_min$1$ = -12						; size = 4
_v0$1$ = -8						; size = 4
_v_max$1$ = -8						; size = 4
_res_w$1$ = -4						; size = 4
_window$1$ = -4						; size = 4
_v1$18 = -4						; size = 4
___formal$ = 8						; size = 4
_label$ = 12						; size = 4
_values_getter$ = 16					; size = 4
_data$ = 20						; size = 4
_values_count$ = 24					; size = 4
_values_offset$ = 28					; size = 4
_overlay_text$ = 32					; size = 4
_scale_min$ = 36					; size = 4
_scale_max$ = 40					; size = 4
_graph_size$ = 44					; size = 8
___formal$ = 52						; size = 4
___formal$ = 56						; size = 4
___formal$ = 60						; size = 4
_inverse$ = 64						; size = 1
?PlotCEx@ImGui@@YAXW4ImGuiPlotType@@PBDP6AMPAXH@Z2HH1MMUImVec2@@MMM_N@Z PROC ; ImGui::PlotCEx

; 12508: {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	esi
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	esi, DWORD PTR [ecx+6240]
	mov	DWORD PTR _window$1$[ebp], esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12512:   if (window->SkipItems)

	cmp	BYTE PTR [esi+137], 0
	jne	$LN18@PlotCEx

; 12513:     return;
; 12514: 
; 12515:   ImGuiContext&     g     = *GImGui;
; 12516:   const ImGuiStyle& style = g.Style;

	push	ebx
	mov	ebx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 12517: 
; 12518:   const ImVec2 label_size =
; 12519:     CalcTextSize (label, nullptr, true);

	lea	eax, DWORD PTR _label_size$[ebp]
	push	ecx
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	push	1
	push	0
	push	DWORD PTR _label$[ebp]
	mov	DWORD PTR tv588[ebp], ebx
	push	eax
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize

; 12520: 
; 12521:   if (graph_size.x == 0.0f)

	movss	xmm3, DWORD PTR _graph_size$[ebp]
	add	esp, 20					; 00000014H
	xorps	xmm1, xmm1
	ucomiss	xmm3, xmm1
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@PlotCEx

; 12522:       graph_size.x = CalcItemWidth ();

	call	?CalcItemWidth@ImGui@@YAMXZ		; ImGui::CalcItemWidth
	fstp	DWORD PTR _graph_size$[ebp]
	movss	xmm3, DWORD PTR _graph_size$[ebp]
	xorps	xmm1, xmm1
$LN9@PlotCEx:

; 12523:   if (graph_size.y == 0.0f)

	movss	xmm0, DWORD PTR _graph_size$[ebp+4]
	ucomiss	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@PlotCEx

; 12524:       graph_size.y = label_size.y + (style.FramePadding.y * 2.0f);

	movss	xmm0, DWORD PTR [ebx+5360]
	addss	xmm0, xmm0
	addss	xmm0, DWORD PTR _label_size$[ebp+4]
	movss	DWORD PTR _graph_size$[ebp+4], xmm0
$LN10@PlotCEx:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm2, DWORD PTR [esi+192]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [esi+192]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm2, xmm3
	movss	xmm3, DWORD PTR [esi+196]
	addss	xmm3, xmm0

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _frame_bb$[ebp], eax
	mov	eax, DWORD PTR [esi+196]
	mov	DWORD PTR _frame_bb$[ebp+4], eax

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movaps	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T15[ebp], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm0, DWORD PTR [ebx+5356]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T15[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T15[ebp+4], xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _frame_bb$[ebp+8], eax
	mov	eax, DWORD PTR $T15[ebp+4]

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	DWORD PTR $T1$sroa$469$1$[ebp], xmm0
	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [ebx+5360]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _frame_bb$[ebp+12], eax

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	DWORD PTR $T1$sroa$468$1$[ebp], xmm0

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [ebx+5356]
	addss	xmm0, DWORD PTR _frame_bb$[ebp]
	movss	DWORD PTR $T2$sroa$466$1$[ebp], xmm0
	movss	xmm0, DWORD PTR [ebx+5360]
	addss	xmm0, DWORD PTR _frame_bb$[ebp+4]
	movss	DWORD PTR $T2$sroa$398$1$[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12531:   const ImRect total_bb ( frame_bb.Min,

	movss	xmm0, DWORD PTR _label_size$[ebp]
	comiss	xmm0, xmm1
	jbe	SHORT $LN20@PlotCEx
	movss	xmm1, DWORD PTR [ebx+5376]
	addss	xmm1, xmm0
$LN20@PlotCEx:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [esi+192]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm2, xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12541:   ItemSize (total_bb, style.FramePadding.y);

	movss	xmm0, DWORD PTR [ebx+5360]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _total_bb$[ebp], eax
	mov	eax, DWORD PTR [esi+196]
	mov	DWORD PTR _total_bb$[ebp+4], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T14[ebp], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T14[ebp]
	mov	DWORD PTR _total_bb$[ebp+8], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T14[ebp+4], xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T14[ebp+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12541:   ItemSize (total_bb, style.FramePadding.y);

	push	ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _total_bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12541:   ItemSize (total_bb, style.FramePadding.y);

	lea	eax, DWORD PTR _total_bb$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	eax
	call	?ItemSize@ImGui@@YAXABUImRect@@M@Z	; ImGui::ItemSize

; 12542: 
; 12543:   if (! ItemAdd (total_bb, nullptr, &frame_bb))

	lea	eax, DWORD PTR _frame_bb$[ebp]
	push	eax
	lea	eax, DWORD PTR _total_bb$[ebp]
	push	0
	push	eax
	call	?ItemAdd@ImGui@@YA_NABUImRect@@PBIPBU2@@Z ; ImGui::ItemAdd
	add	esp, 20					; 00000014H
	test	al, al
	je	$LN138@PlotCEx

; 12544:     return;
; 12545: 
; 12546:   // Determine scale from values if not specified
; 12547:   if ( scale_min == std::numeric_limits <float>::max () ||

	movss	xmm3, DWORD PTR __real@7f7fffff
	movss	xmm0, DWORD PTR _scale_min$[ebp]
	ucomiss	xmm0, xmm3
	push	edi
	mov	edi, DWORD PTR _values_count$[ebp]
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN13@PlotCEx
	movss	xmm0, DWORD PTR _scale_max$[ebp]
	ucomiss	xmm0, xmm3
	lahf
	test	ah, 68					; 00000044H
	jp	$LN15@PlotCEx
$LN13@PlotCEx:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits

; 1084 : 		return (_FLT_MIN);

	movss	xmm0, DWORD PTR __real@00800000

; 1089 : 		return (_FLT_MAX);

	movaps	xmm2, xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12553:     for (int i = 0; i < values_count; i++)

	xor	esi, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\limits

; 1089 : 		return (_FLT_MAX);

	movss	DWORD PTR _v_min$1$[ebp], xmm2

; 1084 : 		return (_FLT_MIN);

	movss	DWORD PTR _v_max$1$[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12553:     for (int i = 0; i < values_count; i++)

	test	edi, edi
	jle	SHORT $LN3@PlotCEx
	npad	3
$LL4@PlotCEx:

; 12556:         values_getter (data, i);

	push	esi
	push	DWORD PTR _data$[ebp]
	call	DWORD PTR _values_getter$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 127  : static inline float  ImMin(float lhs, float rhs)                                { return lhs < rhs ? lhs : rhs; }

	movss	xmm2, DWORD PTR _v_min$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12556:         values_getter (data, i);

	add	esp, 8
	fstp	DWORD PTR _v$17[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 127  : static inline float  ImMin(float lhs, float rhs)                                { return lhs < rhs ? lhs : rhs; }

	movss	xmm0, DWORD PTR _v$17[ebp]
	comiss	xmm0, xmm2
	ja	SHORT $LN69@PlotCEx
	movaps	xmm2, xmm0
	movss	DWORD PTR _v_min$1$[ebp], xmm2
$LN69@PlotCEx:

; 128  : static inline float  ImMax(float lhs, float rhs)                                { return lhs >= rhs ? lhs : rhs; }

	movss	xmm1, DWORD PTR _v_max$1$[ebp]
	comiss	xmm1, xmm0
	jae	SHORT $LN136@PlotCEx
	movss	DWORD PTR _v_max$1$[ebp], xmm0
	jmp	SHORT $LN73@PlotCEx
$LN136@PlotCEx:
	movss	xmm0, DWORD PTR _v_max$1$[ebp]
$LN73@PlotCEx:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12553:     for (int i = 0; i < values_count; i++)

	inc	esi
	cmp	esi, edi
	jl	SHORT $LL4@PlotCEx
	movss	xmm3, DWORD PTR __real@7f7fffff
$LN3@PlotCEx:

; 12557: 
; 12558:       v_min = ImMin (v_min, v);
; 12559:       v_max = ImMax (v_max, v);
; 12560:     }
; 12561: 
; 12562:     if (scale_min == std::numeric_limits <float>::max ())

	movss	xmm1, DWORD PTR _scale_min$[ebp]
	ucomiss	xmm1, xmm3
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN14@PlotCEx

; 12563:         scale_min = v_min;

	movss	DWORD PTR _scale_min$[ebp], xmm2
$LN14@PlotCEx:

; 12564:     if (scale_max == std::numeric_limits <float>::max ())

	movss	xmm1, DWORD PTR _scale_max$[ebp]
	mov	esi, DWORD PTR _window$1$[ebp]
	ucomiss	xmm1, xmm3
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN15@PlotCEx

; 12565:         scale_max = v_max;

	movss	DWORD PTR _scale_max$[ebp], xmm0
$LN15@PlotCEx:

; 12566:   }
; 12567: 
; 12568:   RenderFrame ( frame_bb.Min,

	movss	xmm0, DWORD PTR [ebx+5364]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	1
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	7
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	add	esp, 8
	push	eax
	push	DWORD PTR _frame_bb$[ebp+12]
	push	DWORD PTR _frame_bb$[ebp+8]
	push	DWORD PTR _frame_bb$[ebp+4]
	push	DWORD PTR _frame_bb$[ebp]
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame
	add	esp, 28					; 0000001cH

; 12569:                 frame_bb.Max,
; 12570:                   GetColorU32 (ImGuiCol_FrameBg),
; 12571:                     true,
; 12572:                       style.FrameRounding );
; 12573: 
; 12574:   if (values_count > 0)

	test	edi, edi
	jle	$LN6@PlotCEx

; 12575:   {
; 12576:     int    res_w      = ImMin ( static_cast <int> ( graph_size.x ),
; 12577:                                                     values_count ) - 1;

	cvttss2si eax, DWORD PTR _graph_size$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 125  : static inline int    ImMin(int lhs, int rhs)                                    { return lhs < rhs ? lhs : rhs; }

	mov	ecx, edi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12581:            t_step     = 1.0f / static_cast <float> (res_w);

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 125  : static inline int    ImMin(int lhs, int rhs)                                    { return lhs < rhs ? lhs : rhs; }

	cmp	eax, edi
	cmovl	ecx, eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12584:     float  v0         = values_getter (

	mov	eax, DWORD PTR _values_offset$[ebp]
	cdq
	dec	ecx
	idiv	edi
	movd	xmm0, ecx
	cvtdq2ps xmm0, xmm0
	push	edx
	mov	DWORD PTR _res_w$1$[ebp], ecx
	push	DWORD PTR _data$[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _t_step$1$[ebp], xmm1
	call	DWORD PTR _values_getter$[ebp]

; 12590:     ImVec2 tp0 ( t0, 1.0f - ImSaturate ( (v0        - scale_min) /

	movss	xmm2, DWORD PTR _scale_max$[ebp]
	add	esp, 8
	movss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm0, xmm2
	subss	xmm0, DWORD PTR _scale_min$[ebp]
	movaps	xmm5, xmm1
	fstp	DWORD PTR _v0$16[ebp]
	divss	xmm5, xmm0
	movss	xmm0, DWORD PTR _v0$16[ebp]
	movaps	xmm3, xmm0
	movss	DWORD PTR _v0$1$[ebp], xmm0
	subss	xmm3, DWORD PTR _scale_min$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR tv713[ebp], xmm5
	mulss	xmm3, xmm5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 134  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm0, xmm3
	jbe	SHORT $LN86@PlotCEx
	xorps	xmm3, xmm3
	jmp	SHORT $LN87@PlotCEx
$LN86@PlotCEx:
	minss	xmm3, xmm1
$LN87@PlotCEx:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12593:     for (int n = 0; n < res_w; n++)

	cmp	DWORD PTR _res_w$1$[ebp], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _tp0$3$sroa$298$1$[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12590:     ImVec2 tp0 ( t0, 1.0f - ImSaturate ( (v0        - scale_min) /

	movaps	xmm0, xmm1
	subss	xmm0, xmm3
	movss	DWORD PTR _tp0$3$sroa$297$1$[ebp], xmm0

; 12593:     for (int n = 0; n < res_w; n++)

	jle	$LN6@PlotCEx
	movss	xmm0, DWORD PTR $T1$sroa$469$1$[ebp]
	lea	eax, DWORD PTR [edi-1]
	subss	xmm0, DWORD PTR $T2$sroa$466$1$[ebp]
	divss	xmm1, xmm2
	mov	ebx, DWORD PTR _res_w$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	mov	DWORD PTR $T5[ebp+12], 1065353216	; 3f800000H
	movss	DWORD PTR $T1$sroa$469$1$[ebp], xmm0
	movss	xmm0, DWORD PTR $T2$sroa$398$1$[ebp]
	movss	DWORD PTR tv716[ebp], xmm1
	movss	xmm1, DWORD PTR $T1$sroa$468$1$[ebp]
	movd	xmm3, eax
	subss	xmm1, xmm0
	cvtdq2ps xmm3, xmm3
	movss	DWORD PTR $T1$sroa$468$1$[ebp], xmm1
	xorps	xmm1, xmm1
	movss	DWORD PTR tv715[ebp], xmm3
$LL7@PlotCEx:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12601:         values_getter (data, (v1_idx + values_offset + 1) % values_count);

	mov	ecx, DWORD PTR _values_offset$[ebp]
	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR _t_step$1$[ebp]
	inc	ecx
	movss	DWORD PTR _t1$1$[ebp], xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	add	eax, ecx
	cdq
	idiv	edi
	push	edx
	push	DWORD PTR _data$[ebp]
	call	DWORD PTR _values_getter$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 134  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	movss	xmm3, DWORD PTR __real@3f800000
	xorps	xmm1, xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12601:         values_getter (data, (v1_idx + values_offset + 1) % values_count);

	fstp	DWORD PTR _v1$18[ebp]

; 12602: 
; 12603:       const ImVec2 tp1 ( t1, 1.0f - ImSaturate ( (v1        - scale_min) /

	movss	xmm4, DWORD PTR _v1$18[ebp]
	add	esp, 8
	movaps	xmm0, xmm4
	subss	xmm0, DWORD PTR _scale_min$[ebp]
	mulss	xmm0, DWORD PTR tv713[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 134  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm1, xmm0
	jbe	SHORT $LN94@PlotCEx
	xorps	xmm0, xmm0
	jmp	SHORT $LN95@PlotCEx
$LN94@PlotCEx:
	minss	xmm0, xmm3
$LN95@PlotCEx:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12606:       float col_v0 = ( inverse ? scale_max - v0 : v0 );

	cmp	BYTE PTR _inverse$[ebp], 0
	movaps	xmm1, xmm3
	subss	xmm1, xmm0
	movss	DWORD PTR _tp1$4$sroa$402$1$[ebp], xmm1
	je	SHORT $LN22@PlotCEx
	movss	xmm0, DWORD PTR _scale_max$[ebp]
	movaps	xmm2, xmm0

; 12607:       float col_v1 = ( inverse ? scale_max - v1 : v1 );

	subss	xmm0, xmm4
	subss	xmm2, DWORD PTR _v0$1$[ebp]
	jmp	SHORT $LN25@PlotCEx
$LN22@PlotCEx:

; 12606:       float col_v0 = ( inverse ? scale_max - v0 : v0 );

	movss	xmm2, DWORD PTR _v0$1$[ebp]

; 12607:       float col_v1 = ( inverse ? scale_max - v1 : v1 );

	movaps	xmm0, xmm4
$LN25@PlotCEx:

; 12610:         ImColor::HSV (

	movss	xmm1, DWORD PTR tv716[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	lea	eax, DWORD PTR _b$6[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12610:         ImColor::HSV (

	mulss	xmm1, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	push	eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12610:         ImColor::HSV (

	movss	xmm0, DWORD PTR tv716[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	lea	eax, DWORD PTR _g$7[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12610:         ImColor::HSV (

	mulss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	push	eax
	minss	xmm1, xmm3
	lea	eax, DWORD PTR _r$8[ebp]
	minss	xmm0, xmm3
	push	eax
	sub	esp, 12					; 0000000cH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 135  : static inline float  ImLerp(float a, float b, float t)                          { return a + (b - a) * t; }

	subss	xmm1, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	mov	DWORD PTR [esp+8], 1064514355		; 3f733333H
	mov	DWORD PTR [esp+4], 1063004406		; 3f5c28f6H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 135  : static inline float  ImLerp(float a, float b, float t)                          { return a + (b - a) * t; }

	mulss	xmm1, DWORD PTR _tp0$3$sroa$297$1$[ebp]
	addss	xmm1, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12610:         ImColor::HSV (

	movss	xmm0, DWORD PTR __real@3e9eb852
	mulss	xmm1, xmm0
	subss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	movss	DWORD PTR [esp], xmm0
	call	?ColorConvertHSVtoRGB@ImGui@@YAXMMMAAM00@Z ; ImGui::ColorConvertHSVtoRGB

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	movss	xmm0, DWORD PTR _r$8[ebp]

; 1128 :     inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }

	lea	eax, DWORD PTR $T5[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 136  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }

	movss	xmm2, DWORD PTR $T1$sroa$469$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12623:       window->DrawList->AddLine (pos0, pos1, col_base);

	add	esp, 20					; 00000014H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	movss	DWORD PTR $T5[ebp], xmm0
	movss	xmm0, DWORD PTR _g$7[ebp]
	movss	DWORD PTR $T5[ebp+4], xmm0
	movss	xmm0, DWORD PTR _b$6[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 136  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }

	movss	xmm1, DWORD PTR $T2$sroa$398$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	movss	DWORD PTR $T5[ebp+8], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 136  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR _tp0$3$sroa$298$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12623:       window->DrawList->AddLine (pos0, pos1, col_base);

	mov	DWORD PTR [esp], 1065353216		; 3f800000H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1128 :     inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }

	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 136  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }

	addss	xmm0, DWORD PTR $T2$sroa$466$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _pos0$10[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 136  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }

	movss	xmm0, DWORD PTR $T1$sroa$468$1$[ebp]
	mulss	xmm0, DWORD PTR _tp0$3$sroa$297$1$[ebp]
	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _pos0$10[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 136  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR _t1$1$[ebp]
	addss	xmm0, DWORD PTR $T2$sroa$466$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _pos1$12[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 136  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }

	movss	xmm0, DWORD PTR $T1$sroa$468$1$[ebp]
	mulss	xmm0, DWORD PTR _tp1$4$sroa$402$1$[ebp]
	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _pos1$12[ebp+4], xmm0

; 1128 :     inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }

	call	?ColorConvertFloat4ToU32@ImGui@@YAIABUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12623:       window->DrawList->AddLine (pos0, pos1, col_base);

	mov	ecx, DWORD PTR [esi+624]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1128 :     inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }

	add	esp, 4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12623:       window->DrawList->AddLine (pos0, pos1, col_base);

	push	eax
	lea	eax, DWORD PTR _pos1$12[ebp]
	push	eax
	lea	eax, DWORD PTR _pos0$10[ebp]
	push	eax
	call	?AddLine@ImDrawList@@QAEXABUImVec2@@0IM@Z ; ImDrawList::AddLine

; 12624: 
; 12625:       v0  = v1;

	movss	xmm0, DWORD PTR _v1$18[ebp]
	movss	xmm3, DWORD PTR tv715[ebp]
	movss	DWORD PTR _v0$1$[ebp], xmm0

; 12626:       t0  = t1;

	movss	xmm0, DWORD PTR _t1$1$[ebp]
	movss	DWORD PTR _tp0$3$sroa$298$1$[ebp], xmm0
	movaps	xmm1, xmm0
	movss	xmm0, DWORD PTR _tp1$4$sroa$402$1$[ebp]
	movss	DWORD PTR _tp0$3$sroa$297$1$[ebp], xmm0
	sub	ebx, 1
	jne	$LL7@PlotCEx
	mov	ebx, DWORD PTR tv588[ebp]
$LN6@PlotCEx:

; 12627:       tp0 = tp1;
; 12628:     }
; 12629:   }
; 12630: 
; 12631:   // Text overlay
; 12632:   if (overlay_text)

	mov	eax, DWORD PTR _overlay_text$[ebp]
	pop	edi
	test	eax, eax
	je	SHORT $LN17@PlotCEx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR _frame_bb$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12634:     RenderTextClipped ( ImVec2 ( frame_bb.Min.x,

	lea	ecx, DWORD PTR $T9[ebp]
	push	0
	push	ecx
	push	0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T11[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12634:     RenderTextClipped ( ImVec2 ( frame_bb.Min.x,

	movss	xmm0, DWORD PTR _frame_bb$[ebp+4]
	addss	xmm0, DWORD PTR [ebx+5360]
	push	0
	push	eax
	lea	eax, DWORD PTR _frame_bb$[ebp+8]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T9[ebp], 1056964608		; 3f000000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12634:     RenderTextClipped ( ImVec2 ( frame_bb.Min.x,

	push	eax
	lea	eax, DWORD PTR $T11[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T9[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12634:     RenderTextClipped ( ImVec2 ( frame_bb.Min.x,

	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T11[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12634:     RenderTextClipped ( ImVec2 ( frame_bb.Min.x,

	call	?RenderTextClipped@ImGui@@YAXABUImVec2@@0PBD1PBU2@0PBUImRect@@@Z ; ImGui::RenderTextClipped
	add	esp, 28					; 0000001cH
$LN17@PlotCEx:

; 12635:                                  frame_bb.Min.y + style.FramePadding.y ),
; 12636:                           frame_bb.Max,
; 12637:                             overlay_text,
; 12638:                               nullptr, nullptr,
; 12639:                                 ImVec2 (0.5f, 0.0f) );
; 12640:   }
; 12641: 
; 12642:   if (label_size.x > 0.0f)

	movss	xmm0, DWORD PTR _label_size$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN138@PlotCEx

; 12644:     RenderText ( ImVec2 ( frame_bb.Max.x + style.ItemInnerSpacing.x,

	movss	xmm0, DWORD PTR [ebx+5376]
	addss	xmm0, DWORD PTR _frame_bb$[ebp+8]
	push	1
	push	0
	push	DWORD PTR _label$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T13[ebp], xmm0
	movss	xmm0, DWORD PTR $T2$sroa$398$1$[ebp]
	movss	DWORD PTR $T13[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 12644:     RenderText ( ImVec2 ( frame_bb.Max.x + style.ItemInnerSpacing.x,

	push	DWORD PTR $T13[ebp+4]
	push	DWORD PTR $T13[ebp]
	call	?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z	; ImGui::RenderText
	add	esp, 20					; 00000014H
$LN138@PlotCEx:
	pop	ebx
$LN18@PlotCEx:
	pop	esi

; 12645:                           inner_bb.Min.y ),
; 12646:                    label );
; 12647:   }
; 12648: }

	mov	esp, ebp
	pop	ebp
	ret	0
?PlotCEx@ImGui@@YAXW4ImGuiPlotType@@PBDP6AMPAXH@Z2HH1MMUImVec2@@MMM_N@Z ENDP ; ImGui::PlotCEx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_tp0$1 = -164						; size = 8
_pos0$2 = -156						; size = 8
_tp1$3 = -148						; size = 8
_f$ = -140						; size = 4
_t_step$1$ = -136					; size = 4
_inner_bb$ = -132					; size = 16
$T4 = -124						; size = 8
$T5 = -124						; size = 8
_total_bb$ = -116					; size = 16
$T6 = -108						; size = 8
$T7 = -108						; size = 8
$T8 = -100						; size = 8
tv675 = -96						; size = 4
_tp0$2$ = -92						; size = 4
_res_w$1$ = -88						; size = 4
_window$1$ = -84					; size = 4
_col_hovered$1$ = -80					; size = 4
_v1_idx$1$ = -76					; size = 4
_col_base$1$ = -72					; size = 4
_frame_bb$ = -68					; size = 16
$T9 = -52						; size = 8
_label_size$ = -52					; size = 8
$T10 = -44						; size = 4
$T11 = -40						; size = 4
$T12 = -36						; size = 4
_t1$1$ = -32						; size = 4
_t0$1$ = -32						; size = 4
$T13 = -28						; size = 4
_v_min$1$ = -24						; size = 4
tv632 = -24						; size = 4
_g$1$ = -20						; size = 4
_tp0$1$ = -16						; size = 4
_f$ = -16						; size = 4
_v$14 = -16						; size = 4
_v_max$1$ = -12						; size = 4
_v_hovered$1$ = -12					; size = 4
_pos1$15 = -8						; size = 8
$T16 = -8						; size = 8
$T17 = -8						; size = 8
$T18 = -8						; size = 8
_plot_type$ = 8						; size = 4
_label$ = 12						; size = 4
_values_getter$ = 16					; size = 4
_data$ = 20						; size = 4
_values_count$ = 24					; size = 4
_values_offset$ = 28					; size = 4
_overlay_text$ = 32					; size = 4
_scale_min$ = 36					; size = 4
_scale_max$ = 40					; size = 4
_graph_size$ = 44					; size = 8
?PlotEx@ImGui@@YAXW4ImGuiPlotType@@PBDP6AMPAXH@Z2HH1MMUImVec2@@@Z PROC ; ImGui::PlotEx

; 8125 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	ebx
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	ebx, DWORD PTR [ecx+6240]
	mov	DWORD PTR _window$1$[ebp], ebx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8127 :     if (window->SkipItems)

	cmp	BYTE PTR [ebx+137], 0
	jne	$LN23@PlotEx

; 8128 :         return;
; 8129 : 
; 8130 :     ImGuiContext& g = *GImGui;

	push	esi
	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 8131 :     const ImGuiStyle& style = g.Style;
; 8132 : 
; 8133 :     const ImVec2 label_size = CalcTextSize(label, NULL, true);

	lea	eax, DWORD PTR _label_size$[ebp]
	push	ecx
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	push	1
	push	0
	push	DWORD PTR _label$[ebp]
	mov	DWORD PTR _g$1$[ebp], esi
	push	eax
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize

; 8134 :     if (graph_size.x == 0.0f)

	movss	xmm2, DWORD PTR _graph_size$[ebp]
	add	esp, 20					; 00000014H
	xorps	xmm3, xmm3
	ucomiss	xmm2, xmm3
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@PlotEx

; 8135 :         graph_size.x = CalcItemWidth();

	call	?CalcItemWidth@ImGui@@YAMXZ		; ImGui::CalcItemWidth
	fstp	DWORD PTR _graph_size$[ebp]
	movss	xmm2, DWORD PTR _graph_size$[ebp]
	xorps	xmm3, xmm3
$LN9@PlotEx:

; 8136 :     if (graph_size.y == 0.0f)

	movss	xmm0, DWORD PTR _graph_size$[ebp+4]
	ucomiss	xmm0, xmm3
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@PlotEx

; 8137 :         graph_size.y = label_size.y + (style.FramePadding.y * 2);

	movss	xmm0, DWORD PTR [esi+5360]
	addss	xmm0, xmm0
	addss	xmm0, DWORD PTR _label_size$[ebp+4]
	movss	DWORD PTR _graph_size$[ebp+4], xmm0
$LN10@PlotEx:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm1, DWORD PTR [ebx+192]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [ebx+192]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm1, xmm2
	movss	xmm2, DWORD PTR [ebx+196]
	addss	xmm2, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8141 :     const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0));

	movss	xmm4, DWORD PTR _label_size$[ebp]
	comiss	xmm4, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _frame_bb$[ebp], eax
	mov	eax, DWORD PTR [ebx+196]
	mov	DWORD PTR _frame_bb$[ebp+4], eax

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movaps	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T18[ebp], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm0, DWORD PTR [esi+5356]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T18[ebp]
	mov	DWORD PTR _frame_bb$[ebp+8], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T18[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T18[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T8[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	DWORD PTR $T13[ebp], xmm0
	movaps	xmm0, xmm2
	subss	xmm0, DWORD PTR [esi+5360]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _frame_bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T8[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	DWORD PTR $T11[ebp], xmm0

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [esi+5356]
	addss	xmm0, DWORD PTR _frame_bb$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T17[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T17[ebp]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	DWORD PTR $T12[ebp], xmm0
	movss	xmm0, DWORD PTR [esi+5360]
	addss	xmm0, DWORD PTR _frame_bb$[ebp+4]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _inner_bb$[ebp], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T17[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T17[ebp+4]
	mov	DWORD PTR _inner_bb$[ebp+4], eax
	mov	eax, DWORD PTR $T8[ebp]
	mov	DWORD PTR _inner_bb$[ebp+8], eax
	mov	eax, DWORD PTR $T8[ebp+4]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	DWORD PTR $T10[ebp], xmm0

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _inner_bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8141 :     const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0));

	jbe	SHORT $LN25@PlotEx
	movss	xmm0, DWORD PTR [esi+5376]
	addss	xmm0, xmm4
	jmp	SHORT $LN26@PlotEx
$LN25@PlotEx:
	xorps	xmm0, xmm0
$LN26@PlotEx:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [ebx+192]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm1, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8142 :     ItemSize(total_bb, style.FramePadding.y);

	movss	xmm0, DWORD PTR [esi+5360]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _total_bb$[ebp], eax
	mov	eax, DWORD PTR [ebx+196]
	mov	DWORD PTR _total_bb$[ebp+4], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T16[ebp], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T16[ebp]
	mov	DWORD PTR _total_bb$[ebp+8], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T16[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T16[ebp+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8142 :     ItemSize(total_bb, style.FramePadding.y);

	push	ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _total_bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8142 :     ItemSize(total_bb, style.FramePadding.y);

	lea	eax, DWORD PTR _total_bb$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	eax
	call	?ItemSize@ImGui@@YAXABUImRect@@M@Z	; ImGui::ItemSize

; 8143 :     if (!ItemAdd(total_bb, NULL, &frame_bb))

	lea	eax, DWORD PTR _frame_bb$[ebp]
	push	eax
	lea	eax, DWORD PTR _total_bb$[ebp]
	push	0
	push	eax
	call	?ItemAdd@ImGui@@YA_NABUImRect@@PBIPBU2@@Z ; ImGui::ItemAdd
	add	esp, 20					; 00000014H
	test	al, al
	je	$LN122@PlotEx

; 8144 :         return;
; 8145 : 
; 8146 :     // Determine scale from values if not specified
; 8147 :     if (scale_min == FLT_MAX || scale_max == FLT_MAX)

	movss	xmm1, DWORD PTR __real@7f7fffff
	movss	xmm0, DWORD PTR _scale_min$[ebp]
	ucomiss	xmm0, xmm1
	push	edi
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN13@PlotEx
	movss	xmm0, DWORD PTR _scale_max$[ebp]
	ucomiss	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jp	$LN119@PlotEx
$LN13@PlotEx:

; 8148 :     {
; 8149 :         float v_min = FLT_MAX;
; 8150 :         float v_max = -FLT_MAX;

	movss	xmm0, DWORD PTR __real@ff7fffff
	movaps	xmm2, xmm1

; 8151 :         for (int i = 0; i < values_count; i++)

	mov	edi, DWORD PTR _values_count$[ebp]
	xor	esi, esi
	movss	DWORD PTR _v_min$1$[ebp], xmm2
	movss	DWORD PTR _v_max$1$[ebp], xmm0
	test	edi, edi
	jle	SHORT $LN3@PlotEx
$LL4@PlotEx:

; 8153 :             const float v = values_getter(data, i);

	push	esi
	push	DWORD PTR _data$[ebp]
	call	DWORD PTR _values_getter$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 127  : static inline float  ImMin(float lhs, float rhs)                                { return lhs < rhs ? lhs : rhs; }

	movss	xmm2, DWORD PTR _v_min$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8153 :             const float v = values_getter(data, i);

	add	esp, 8
	fstp	DWORD PTR _v$14[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 127  : static inline float  ImMin(float lhs, float rhs)                                { return lhs < rhs ? lhs : rhs; }

	movss	xmm0, DWORD PTR _v$14[ebp]
	comiss	xmm0, xmm2
	ja	SHORT $LN60@PlotEx
	movaps	xmm2, xmm0
	movss	DWORD PTR _v_min$1$[ebp], xmm2
$LN60@PlotEx:

; 128  : static inline float  ImMax(float lhs, float rhs)                                { return lhs >= rhs ? lhs : rhs; }

	movss	xmm1, DWORD PTR _v_max$1$[ebp]
	comiss	xmm1, xmm0
	jae	SHORT $LN117@PlotEx
	movss	DWORD PTR _v_max$1$[ebp], xmm0
	jmp	SHORT $LN64@PlotEx
$LN117@PlotEx:
	movss	xmm0, DWORD PTR _v_max$1$[ebp]
$LN64@PlotEx:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8151 :         for (int i = 0; i < values_count; i++)

	inc	esi
	cmp	esi, edi
	jl	SHORT $LL4@PlotEx
	movss	xmm1, DWORD PTR __real@7f7fffff
$LN3@PlotEx:

; 8154 :             v_min = ImMin(v_min, v);
; 8155 :             v_max = ImMax(v_max, v);
; 8156 :         }
; 8157 :         if (scale_min == FLT_MAX)

	movss	xmm3, DWORD PTR _scale_min$[ebp]
	ucomiss	xmm3, xmm1
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN14@PlotEx

; 8158 :             scale_min = v_min;

	movss	DWORD PTR _scale_min$[ebp], xmm2
$LN14@PlotEx:

; 8159 :         if (scale_max == FLT_MAX)

	movss	xmm2, DWORD PTR _scale_max$[ebp]

; 8160 :             scale_max = v_max;

	mov	esi, DWORD PTR _g$1$[ebp]
	ucomiss	xmm2, xmm1
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN15@PlotEx
	movss	DWORD PTR _scale_max$[ebp], xmm0
	jmp	SHORT $LN15@PlotEx
$LN119@PlotEx:
	mov	edi, DWORD PTR _values_count$[ebp]
$LN15@PlotEx:

; 8161 :     }
; 8162 : 
; 8163 :     RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);

	movss	xmm0, DWORD PTR [esi+5364]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	1
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	7
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	add	esp, 8
	push	eax
	push	DWORD PTR _frame_bb$[ebp+12]
	push	DWORD PTR _frame_bb$[ebp+8]
	push	DWORD PTR _frame_bb$[ebp+4]
	push	DWORD PTR _frame_bb$[ebp]
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame
	add	esp, 28					; 0000001cH

; 8164 : 
; 8165 :     if (values_count > 0)

	test	edi, edi
	jle	$LN115@PlotEx

; 8167 :         int res_w      = ImMin((int)graph_size.x, values_count) + ((plot_type == ImGuiPlotType_Lines) ? -1 : 0);

	cvttss2si eax, DWORD PTR _graph_size$[ebp]
	mov	ebx, DWORD PTR _plot_type$[ebp]
	mov	ecx, ebx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 125  : static inline int    ImMin(int lhs, int rhs)                                    { return lhs < rhs ? lhs : rhs; }

	mov	edx, DWORD PTR _values_count$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8167 :         int res_w      = ImMin((int)graph_size.x, values_count) + ((plot_type == ImGuiPlotType_Lines) ? -1 : 0);

	neg	ecx

; 8172 :         if (IsHovered(inner_bb, 0))

	push	0
	sbb	ecx, ecx
	mov	DWORD PTR _v_hovered$1$[ebp], -1
	neg	ecx
	dec	ecx
	push	0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 125  : static inline int    ImMin(int lhs, int rhs)                                    { return lhs < rhs ? lhs : rhs; }

	cmp	eax, edx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8168 :         int item_count = values_count + ((plot_type == ImGuiPlotType_Lines) ? -1 : 0);

	lea	esi, DWORD PTR [ecx+edx]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 125  : static inline int    ImMin(int lhs, int rhs)                                    { return lhs < rhs ? lhs : rhs; }

	cmovl	edi, eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8172 :         if (IsHovered(inner_bb, 0))

	lea	eax, DWORD PTR _inner_bb$[ebp]
	add	edi, ecx
	push	eax
	mov	DWORD PTR _res_w$1$[ebp], edi
	call	?IsHovered@ImGui@@YA_NABUImRect@@I_N@Z	; ImGui::IsHovered
	add	esp, 12					; 0000000cH
	xorps	xmm2, xmm2
	test	al, al
	je	SHORT $LN17@PlotEx

; 8173 :         {
; 8174 :             const float t     = ImClamp((g.IO.MousePos.x - inner_bb.Min.x) / (inner_bb.Max.x - inner_bb.Min.x), 0.0f, 0.9999f);

	mov	eax, DWORD PTR _g$1$[ebp]
	movss	xmm0, DWORD PTR $T13[ebp]
	subss	xmm0, DWORD PTR $T12[ebp]
	movss	xmm1, DWORD PTR [eax+208]
	subss	xmm1, DWORD PTR $T12[ebp]
	divss	xmm1, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm2, xmm1
	jbe	SHORT $LN71@PlotEx
	xorps	xmm1, xmm1
	jmp	SHORT $LN72@PlotEx
$LN71@PlotEx:
	minss	xmm1, DWORD PTR __real@3f7ff972
$LN72@PlotEx:
	movd	xmm0, esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8175 :             const int   v_idx = (int)(t * item_count);

	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	cvttss2si eax, xmm0
	mov	DWORD PTR _v_hovered$1$[ebp], eax
$LN17@PlotEx:

; 8176 : 
; 8177 :             IM_ASSERT(v_idx >= 0 && v_idx < values_count);
; 8178 : 
; 8179 :             // XXX: Add flag for this
; 8180 : #if 0
; 8181 :             const float v0 = values_getter (data, (v_idx     + values_offset) % values_count);
; 8182 :             const float v1 = values_getter (data, (v_idx + 1 + values_offset) % values_count);
; 8183 : 
; 8184 :             if (plot_type == ImGuiPlotType_Lines)
; 8185 :                 SetTooltip("%d: %8.4g\n%d: %8.4g", v_idx, v0, v_idx+1, v1);
; 8186 :             else if (plot_type == ImGuiPlotType_Histogram)
; 8187 :                 SetTooltip("%d: %8.4g", v_idx, v0);
; 8188 : #endif
; 8189 : 
; 8190 :             v_hovered = v_idx;
; 8191 :         }
; 8192 : 
; 8193 :         const float t_step = 1.0f / (float)res_w;
; 8194 : 
; 8195 :         float v0 = values_getter(data, (0 + values_offset) % values_count);

	mov	eax, DWORD PTR _values_offset$[ebp]
	movss	xmm3, DWORD PTR __real@3f800000
	cdq
	idiv	DWORD PTR _values_count$[ebp]
	movd	xmm0, edi
	cvtdq2ps xmm0, xmm0
	push	edx

; 8196 :         float t0 = 0.0f;

	movss	DWORD PTR _t0$1$[ebp], xmm2

; 8197 :         ImVec2 tp0 = ImVec2( t0, 1.0f - ImSaturate((v0 - scale_min) / (scale_max - scale_min)) );    // Point in the normalized space of our target rectangle

	movss	xmm2, DWORD PTR _scale_max$[ebp]
	subss	xmm2, DWORD PTR _scale_min$[ebp]
	divss	xmm3, xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, xmm2
	push	DWORD PTR _data$[ebp]
	movss	DWORD PTR _t_step$1$[ebp], xmm3
	movss	DWORD PTR tv632[ebp], xmm0
	call	DWORD PTR _values_getter$[ebp]
	fsub	DWORD PTR _scale_min$[ebp]
	add	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 134  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	movss	xmm2, DWORD PTR __real@3f800000
	xorps	xmm0, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8197 :         ImVec2 tp0 = ImVec2( t0, 1.0f - ImSaturate((v0 - scale_min) / (scale_max - scale_min)) );    // Point in the normalized space of our target rectangle

	fmul	DWORD PTR tv632[ebp]
	fstp	DWORD PTR _f$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 134  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	movss	xmm1, DWORD PTR _f$[ebp]
	comiss	xmm0, xmm1
	jbe	SHORT $LN77@PlotEx
	xorps	xmm1, xmm1
	jmp	SHORT $LN78@PlotEx
$LN77@PlotEx:
	minss	xmm1, xmm2
$LN78@PlotEx:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8199 :         const ImU32 col_base    = GetColorU32((plot_type == ImGuiPlotType_Lines) ? ImGuiCol_PlotLines        : ImGuiCol_PlotHistogram);

	xor	eax, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _tp0$1$[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8199 :         const ImU32 col_base    = GetColorU32((plot_type == ImGuiPlotType_Lines) ? ImGuiCol_PlotLines        : ImGuiCol_PlotHistogram);

	test	ebx, ebx
	movaps	xmm0, xmm2
	subss	xmm0, xmm1
	setne	al
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	lea	eax, DWORD PTR [eax*2+37]
	movss	DWORD PTR _tp0$2$[ebp], xmm0
	push	eax
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32

; 8200 :         const ImU32 col_hovered = GetColorU32((plot_type == ImGuiPlotType_Lines) ? ImGuiCol_PlotLinesHovered : ImGuiCol_PlotHistogramHovered);

	xor	ecx, ecx
	mov	DWORD PTR [esp+4], 1065353216		; 3f800000H
	add	esp, 4
	mov	DWORD PTR _col_base$1$[ebp], eax
	test	ebx, ebx
	setne	cl
	lea	ecx, DWORD PTR [ecx*2+38]
	push	ecx
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	add	esp, 8
	mov	DWORD PTR _col_hovered$1$[ebp], eax

; 8201 : 
; 8202 :         for (int n = 0; n < res_w; n++)

	test	edi, edi
	jle	$LN120@PlotEx
	movss	xmm1, DWORD PTR $T11[ebp]
	movss	xmm0, DWORD PTR $T13[ebp]
	subss	xmm1, DWORD PTR $T10[ebp]
	subss	xmm0, DWORD PTR $T12[ebp]
	movd	xmm2, esi
	cvtdq2ps xmm2, xmm2
	movss	DWORD PTR $T11[ebp], xmm1
	movss	xmm1, DWORD PTR _t0$1$[ebp]
	movss	DWORD PTR tv675[ebp], xmm2
	movss	DWORD PTR $T13[ebp], xmm0
	npad	8
$LL7@PlotEx:

; 8203 :         {
; 8204 :             const float t1 = t0 + t_step;
; 8205 :             const int v1_idx = (int)(t0 * item_count + 0.5f);
; 8206 :             IM_ASSERT(v1_idx >= 0 && v1_idx < values_count);
; 8207 :             const float v1 = values_getter(data, (v1_idx + values_offset + 1) % values_count);

	mov	ecx, DWORD PTR _values_offset$[ebp]
	movaps	xmm0, xmm1
	addss	xmm0, DWORD PTR _t_step$1$[ebp]
	inc	ecx
	movss	DWORD PTR _t1$1$[ebp], xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	mov	DWORD PTR _v1_idx$1$[ebp], eax
	add	eax, ecx
	cdq
	idiv	DWORD PTR _values_count$[ebp]
	push	edx
	push	DWORD PTR _data$[ebp]
	call	DWORD PTR _values_getter$[ebp]

; 8208 :             const ImVec2 tp1 = ImVec2( t1, 1.0f - ImSaturate((v1 - scale_min) / (scale_max - scale_min)) );

	fsub	DWORD PTR _scale_min$[ebp]
	add	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 134  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	movss	xmm4, DWORD PTR __real@3f800000
	xorps	xmm0, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8208 :             const ImVec2 tp1 = ImVec2( t1, 1.0f - ImSaturate((v1 - scale_min) / (scale_max - scale_min)) );

	fmul	DWORD PTR tv632[ebp]
	fstp	DWORD PTR _f$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 134  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	movss	xmm1, DWORD PTR _f$[ebp]
	comiss	xmm0, xmm1
	jbe	SHORT $LN85@PlotEx
	xorps	xmm1, xmm1
	jmp	SHORT $LN86@PlotEx
$LN85@PlotEx:
	minss	xmm1, xmm4
$LN86@PlotEx:

; 136  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }

	movss	xmm7, DWORD PTR $T11[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8208 :             const ImVec2 tp1 = ImVec2( t1, 1.0f - ImSaturate((v1 - scale_min) / (scale_max - scale_min)) );

	movaps	xmm0, xmm4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 136  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }

	movss	xmm5, DWORD PTR $T12[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8208 :             const ImVec2 tp1 = ImVec2( t1, 1.0f - ImSaturate((v1 - scale_min) / (scale_max - scale_min)) );

	subss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 136  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }

	movss	xmm1, DWORD PTR $T13[ebp]
	movss	xmm6, DWORD PTR $T10[ebp]
	movaps	xmm2, xmm1
	mulss	xmm2, DWORD PTR _tp0$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm3, DWORD PTR _t1$1$[ebp]
	movss	DWORD PTR _tp1$3[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 136  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }

	movaps	xmm0, xmm7
	mulss	xmm0, DWORD PTR _tp0$2$[ebp]
	addss	xmm2, xmm5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8212 :             ImVec2 pos1 = ImLerp(inner_bb.Min, inner_bb.Max, (plot_type == ImGuiPlotType_Lines) ? tp1 : ImVec2(tp1.x, 1.0f));

	mov	esi, DWORD PTR _tp1$3[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _tp1$3[ebp], xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8212 :             ImVec2 pos1 = ImLerp(inner_bb.Min, inner_bb.Max, (plot_type == ImGuiPlotType_Lines) ? tp1 : ImVec2(tp1.x, 1.0f));

	mov	edi, DWORD PTR _tp1$3[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 136  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }

	addss	xmm0, xmm6
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _pos0$2[ebp], xmm2
	movss	DWORD PTR _pos0$2[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8212 :             ImVec2 pos1 = ImLerp(inner_bb.Min, inner_bb.Max, (plot_type == ImGuiPlotType_Lines) ? tp1 : ImVec2(tp1.x, 1.0f));

	test	ebx, ebx
	jne	SHORT $LN27@PlotEx
	mov	DWORD PTR $T5[ebp], edi
	lea	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR $T5[ebp+4], esi
	jmp	SHORT $LN28@PlotEx
$LN27@PlotEx:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T7[ebp], xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8212 :             ImVec2 pos1 = ImLerp(inner_bb.Min, inner_bb.Max, (plot_type == ImGuiPlotType_Lines) ? tp1 : ImVec2(tp1.x, 1.0f));

	lea	eax, DWORD PTR $T7[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T7[ebp+4], 1065353216	; 3f800000H
$LN28@PlotEx:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 136  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }

	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm1, DWORD PTR [eax]
	mulss	xmm0, xmm7
	addss	xmm1, xmm5
	addss	xmm0, xmm6
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _pos1$15[ebp], xmm1
	movss	DWORD PTR _pos1$15[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8213 :             if (plot_type == ImGuiPlotType_Lines)

	test	ebx, ebx
	jne	SHORT $LN18@PlotEx

; 8214 :             {
; 8215 :                 window->DrawList->AddLine(pos0, pos1, v_hovered == v1_idx ? col_hovered : col_base);

	mov	eax, DWORD PTR _col_base$1$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _v_hovered$1$[ebp]
	cmp	ecx, DWORD PTR _v1_idx$1$[ebp]
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	cmove	eax, DWORD PTR _col_hovered$1$[ebp]
	push	eax
	lea	eax, DWORD PTR _pos1$15[ebp]
	push	eax
	lea	eax, DWORD PTR _pos0$2[ebp]
	push	eax
	mov	eax, DWORD PTR _window$1$[ebp]
	mov	ecx, DWORD PTR [eax+624]
	call	?AddLine@ImDrawList@@QAEXABUImVec2@@0IM@Z ; ImDrawList::AddLine
	jmp	SHORT $LN20@PlotEx
$LN18@PlotEx:

; 8216 :             }
; 8217 :             else if (plot_type == ImGuiPlotType_Histogram)

	cmp	ebx, 1
	jne	SHORT $LN20@PlotEx

; 8218 :             {
; 8219 :                 if (pos1.x >= pos0.x + 2.0f)

	addss	xmm2, DWORD PTR __real@40000000
	comiss	xmm1, xmm2
	jb	SHORT $LN21@PlotEx

; 8220 :                     pos1.x -= 1.0f;

	subss	xmm1, xmm4
	movss	DWORD PTR _pos1$15[ebp], xmm1
$LN21@PlotEx:

; 8221 :                 window->DrawList->AddRectFilled(pos0, pos1, v_hovered == v1_idx ? col_hovered : col_base);

	mov	eax, DWORD PTR _col_base$1$[ebp]
	push	-1
	push	ecx
	mov	ecx, DWORD PTR _v_hovered$1$[ebp]
	cmp	ecx, DWORD PTR _v1_idx$1$[ebp]
	mov	DWORD PTR [esp], 0
	cmove	eax, DWORD PTR _col_hovered$1$[ebp]
	push	eax
	lea	eax, DWORD PTR _pos1$15[ebp]
	push	eax
	lea	eax, DWORD PTR _pos0$2[ebp]
	push	eax
	mov	eax, DWORD PTR _window$1$[ebp]
	mov	ecx, DWORD PTR [eax+624]
	call	?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
$LN20@PlotEx:

; 8222 :             }
; 8223 : 
; 8224 :             t0 = t1;

	sub	DWORD PTR _res_w$1$[ebp], 1
	movss	xmm1, DWORD PTR _t1$1$[ebp]

; 8225 :             tp0 = tp1;

	mov	DWORD PTR _tp0$1[ebp], edi
	mov	DWORD PTR _tp0$1[ebp+4], esi
	je	SHORT $LN120@PlotEx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR _tp0$1[ebp+4]
	movss	xmm2, DWORD PTR tv675[ebp]
	movss	DWORD PTR _tp0$2$[ebp], xmm0
	movss	xmm0, DWORD PTR _tp0$1[ebp]
	movss	DWORD PTR _tp0$1$[ebp], xmm0
	jmp	$LL7@PlotEx
$LN120@PlotEx:
	mov	esi, DWORD PTR _g$1$[ebp]
$LN115@PlotEx:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8230 :     if (overlay_text)

	mov	eax, DWORD PTR _overlay_text$[ebp]
	pop	edi
	test	eax, eax
	je	SHORT $LN22@PlotEx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR _frame_bb$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8231 :         RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, overlay_text, NULL, NULL, ImVec2(0.5f,0.0f));

	lea	ecx, DWORD PTR $T6[ebp]
	push	0
	push	ecx
	push	0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8231 :         RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, overlay_text, NULL, NULL, ImVec2(0.5f,0.0f));

	movss	xmm0, DWORD PTR _frame_bb$[ebp+4]
	addss	xmm0, DWORD PTR [esi+5360]
	push	0
	push	eax
	lea	eax, DWORD PTR _frame_bb$[ebp+8]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T6[ebp], 1056964608		; 3f000000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8231 :         RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, overlay_text, NULL, NULL, ImVec2(0.5f,0.0f));

	push	eax
	lea	eax, DWORD PTR $T4[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T6[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8231 :         RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, overlay_text, NULL, NULL, ImVec2(0.5f,0.0f));

	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8231 :         RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, overlay_text, NULL, NULL, ImVec2(0.5f,0.0f));

	call	?RenderTextClipped@ImGui@@YAXABUImVec2@@0PBD1PBU2@0PBUImRect@@@Z ; ImGui::RenderTextClipped
	add	esp, 28					; 0000001cH
$LN22@PlotEx:

; 8232 : 
; 8233 :     if (label_size.x > 0.0f)

	movss	xmm0, DWORD PTR _label_size$[ebp]
	xorps	xmm2, xmm2
	comiss	xmm0, xmm2
	jbe	SHORT $LN122@PlotEx

; 8234 :         RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, inner_bb.Min.y), label);

	movss	xmm0, DWORD PTR [esi+5376]
	addss	xmm0, DWORD PTR _frame_bb$[ebp+8]
	push	1
	push	0
	push	DWORD PTR _label$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T9[ebp], xmm0
	movss	xmm0, DWORD PTR $T10[ebp]
	movss	DWORD PTR $T9[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8234 :         RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, inner_bb.Min.y), label);

	push	DWORD PTR $T9[ebp+4]
	push	DWORD PTR $T9[ebp]
	call	?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z	; ImGui::RenderText
	add	esp, 20					; 00000014H
$LN122@PlotEx:
	pop	esi
$LN23@PlotEx:
	pop	ebx

; 8235 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PlotEx@ImGui@@YAXW4ImGuiPlotType@@PBDP6AMPAXH@Z2HH1MMUImVec2@@@Z ENDP ; ImGui::PlotEx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_id$ = 8						; size = 4
?TreePushRawID@ImGui@@YAXI@Z PROC			; ImGui::TreePushRawID

; 10645: {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10647:     Indent();

	push	ecx
	mov	DWORD PTR [esp], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	esi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10647:     Indent();

	call	?Indent@ImGui@@YAXM@Z			; ImGui::Indent

; 10648:     window->DC.TreeDepth++;

	inc	DWORD PTR [esi+244]

; 10649:     window->IDStack.push_back(id);

	lea	eax, DWORD PTR _id$[ebp]
	add	esp, 4
	lea	ecx, DWORD PTR [esi+460]
	push	eax
	call	?push_back@?$ImVector@I@@QAEXABI@Z	; ImVector<unsigned int>::push_back
	pop	esi

; 10650: }

	pop	ebp
	ret	0
?TreePushRawID@ImGui@@YAXI@Z ENDP			; ImGui::TreePushRawID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_window$1$ = -4						; size = 4
_id$ = 8						; size = 4
_flags$ = 12						; size = 4
?TreeNodeBehaviorIsOpen@ImGui@@YA_NIH@Z PROC		; ImGui::TreeNodeBehaviorIsOpen

; 6868 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 6869 :     if (flags & ImGuiTreeNodeFlags_Leaf)

	mov	eax, DWORD PTR _flags$[ebp]
	test	eax, 256				; 00000100H
	je	SHORT $LN2@TreeNodeBe

; 6870 :         return true;

	mov	al, 1

; 6912 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@TreeNodeBe:
	push	ebx
	push	esi

; 6871 : 
; 6872 :     // We only write to the tree storage if the user clicks (or explicitely use SetNextTreeNode*** functions)
; 6873 :     ImGuiContext& g = *GImGui;

	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	edi

; 6874 :     ImGuiWindow* window = g.CurrentWindow;

	mov	ecx, DWORD PTR [esi+6240]
	mov	DWORD PTR _window$1$[ebp], ecx

; 6875 :     ImGuiStorage* storage = window->DC.StateStorage;

	mov	edi, DWORD PTR [ecx+304]

; 6876 : 
; 6877 :     bool is_open;
; 6878 :     if (g.SetNextTreeNodeOpenCond != 0)

	mov	ecx, DWORD PTR [esi+6592]
	test	ecx, ecx
	je	SHORT $LN3@TreeNodeBe

; 6879 :     {
; 6880 :         if (g.SetNextTreeNodeOpenCond & ImGuiSetCond_Always)

	test	cl, 1

; 6881 :         {
; 6882 :             is_open = g.SetNextTreeNodeOpenVal;
; 6883 :             storage->SetInt(id, is_open);

	mov	ecx, edi
	je	SHORT $LN5@TreeNodeBe
	mov	bl, BYTE PTR [esi+6590]
	movzx	eax, bl
	push	eax
	push	DWORD PTR _id$[ebp]
	call	?SetInt@ImGuiStorage@@QAEXIH@Z		; ImGuiStorage::SetInt

; 6897 :             }
; 6898 :         }
; 6899 :         g.SetNextTreeNodeOpenCond = 0;

	mov	DWORD PTR [esi+6592], 0

; 6900 :     }
; 6901 :     else

	jmp	SHORT $LN4@TreeNodeBe
$LN5@TreeNodeBe:

; 6884 :         }
; 6885 :         else
; 6886 :         {
; 6887 :             // We treat ImGuiSetCondition_Once and ImGuiSetCondition_FirstUseEver the same because tree node state are not saved persistently.
; 6888 :             const int stored_value = storage->GetInt(id, -1);

	push	-1
	push	DWORD PTR _id$[ebp]
	call	?GetInt@ImGuiStorage@@QBEHIH@Z		; ImGuiStorage::GetInt

; 6889 :             if (stored_value == -1)

	cmp	eax, -1
	jne	SHORT $LN7@TreeNodeBe

; 6890 :             {
; 6891 :                 is_open = g.SetNextTreeNodeOpenVal;

	mov	bl, BYTE PTR [esi+6590]

; 6892 :                 storage->SetInt(id, is_open);

	mov	ecx, edi
	movzx	eax, bl
	push	eax
	push	DWORD PTR _id$[ebp]
	call	?SetInt@ImGuiStorage@@QAEXIH@Z		; ImGuiStorage::SetInt

; 6897 :             }
; 6898 :         }
; 6899 :         g.SetNextTreeNodeOpenCond = 0;

	mov	DWORD PTR [esi+6592], 0

; 6900 :     }
; 6901 :     else

	jmp	SHORT $LN4@TreeNodeBe
$LN7@TreeNodeBe:

; 6893 :             }
; 6894 :             else
; 6895 :             {
; 6896 :                 is_open = stored_value != 0;

	test	eax, eax

; 6897 :             }
; 6898 :         }
; 6899 :         g.SetNextTreeNodeOpenCond = 0;

	mov	DWORD PTR [esi+6592], 0
	setne	bl

; 6900 :     }
; 6901 :     else

	jmp	SHORT $LN4@TreeNodeBe
$LN3@TreeNodeBe:

; 6902 :     {
; 6903 :         is_open = storage->GetInt(id, (flags & ImGuiTreeNodeFlags_DefaultOpen) ? 1 : 0) != 0;

	shr	eax, 5
	mov	ecx, edi
	and	eax, 1
	push	eax
	push	DWORD PTR _id$[ebp]
	call	?GetInt@ImGuiStorage@@QBEHIH@Z		; ImGuiStorage::GetInt
	test	eax, eax
	setne	bl
$LN4@TreeNodeBe:

; 6904 :     }
; 6905 : 
; 6906 :     // When logging is enabled, we automatically expand tree nodes (but *NOT* collapsing headers.. seems like sensible behavior).
; 6907 :     // NB- If we are above max depth we still allow manually opened nodes to be logged.
; 6908 :     if (g.LogEnabled && !(flags & ImGuiTreeNodeFlags_NoAutoOpenOnLog) && window->DC.TreeDepth < g.LogAutoExpandMaxDepth)

	cmp	BYTE PTR [esi+11600], 0
	je	SHORT $LN9@TreeNodeBe
	test	BYTE PTR _flags$[ebp], 16		; 00000010H
	jne	SHORT $LN9@TreeNodeBe
	mov	ecx, DWORD PTR _window$1$[ebp]
	mov	eax, 1
	movzx	ebx, bl
	mov	ecx, DWORD PTR [ecx+244]
	cmp	ecx, DWORD PTR [esi+11616]
	cmovl	ebx, eax
$LN9@TreeNodeBe:

; 6909 :         is_open = true;
; 6910 : 
; 6911 :     return is_open;

	pop	edi
	pop	esi
	mov	al, bl
	pop	ebx

; 6912 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TreeNodeBehaviorIsOpen@ImGui@@YA_NIH@Z ENDP		; ImGui::TreeNodeBehaviorIsOpen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T5 = -112						; size = 16
$T6 = -112						; size = 16
_interact_bb$ = -112					; size = 16
_bb$ = -96						; size = 16
$T7 = -80						; size = 8
$T8 = -80						; size = 8
$T9 = -80						; size = 8
$T10 = -80						; size = 8
$T11 = -72						; size = 8
$T12 = -72						; size = 8
_label_size$ = -72					; size = 8
$T13 = -72						; size = 8
$T14 = -72						; size = 8
$T15 = -64						; size = 8
$T16 = -64						; size = 8
_padding$ = -56						; size = 8
_text_pos$ = -48					; size = 8
$T17 = -48						; size = 8
tv833 = -44						; size = 4
tv832 = -40						; size = 4
_bb$4$ = -36						; size = 4
_frame_height$1$ = -36					; size = 4
_text_offset_x$1$ = -32					; size = 4
_log_prefix$18 = -32					; size = 4
_bb$3$ = -28						; size = 4
_bb$5$ = -24						; size = 4
tv712 = -20						; size = 4
_window$1$ = -16					; size = 4
_is_open$ = -12						; size = 1
_text_base_offset_y$1$ = -8				; size = 4
_log_suffix$19 = -8					; size = 3
_held$ = -3						; size = 1
_toggled$1$ = -2					; size = 1
_hovered$ = -1						; size = 1
_id$ = 8						; size = 4
_flags$ = 12						; size = 4
_label$ = 16						; size = 4
_label_end$ = 20					; size = 4
?TreeNodeBehavior@ImGui@@YA_NIHPBD0@Z PROC		; ImGui::TreeNodeBehavior

; 6915 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	eax, DWORD PTR [ecx+6240]
	mov	DWORD PTR _window$1$[ebp], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6917 :     if (window->SkipItems)

	cmp	BYTE PTR [eax+137], 0
	je	SHORT $LN2@TreeNodeBe

; 6918 :         return false;

	xor	al, al

; 7019 :     return is_open;
; 7020 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@TreeNodeBe:
	push	ebx

; 6919 : 
; 6920 :     ImGuiContext& g = *GImGui;
; 6921 :     const ImGuiStyle& style = g.Style;
; 6922 :     const bool display_frame = (flags & ImGuiTreeNodeFlags_Framed) != 0;

	mov	ebx, DWORD PTR _flags$[ebp]

; 6923 :     const ImVec2 padding = display_frame ? style.FramePadding : ImVec2(style.FramePadding.x, 0.0f);

	lea	ecx, DWORD PTR $T14[ebp]
	mov	eax, ebx
	shr	eax, 1
	and	al, 1
	push	esi
	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	DWORD PTR tv712[ebp], eax
	je	SHORT $LN25@TreeNodeBe
	mov	eax, DWORD PTR [esi+5356]
	mov	DWORD PTR $T14[ebp], eax
	mov	eax, DWORD PTR [esi+5360]
	mov	DWORD PTR $T14[ebp+4], eax
	jmp	SHORT $LN26@TreeNodeBe
$LN25@TreeNodeBe:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR [esi+5356]
	movss	DWORD PTR $T13[ebp], xmm0
	mov	DWORD PTR $T13[ebp+4], 0
$LN26@TreeNodeBe:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6923 :     const ImVec2 padding = display_frame ? style.FramePadding : ImVec2(style.FramePadding.x, 0.0f);

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _padding$[ebp], eax
	mov	eax, DWORD PTR [ecx+4]
	push	edi

; 6924 : 
; 6925 :     if (!label_end)

	mov	edi, DWORD PTR _label_end$[ebp]
	mov	DWORD PTR _padding$[ebp+4], eax
	mov	eax, DWORD PTR _label$[ebp]
	test	edi, edi
	jne	SHORT $LN3@TreeNodeBe

; 6926 :         label_end = FindRenderedTextEnd(label);

	push	0
	push	eax
	call	?FindRenderedTextEnd@ImGui@@YAPBDPBD0@Z	; ImGui::FindRenderedTextEnd
	mov	edi, eax
	add	esp, 8
	mov	eax, DWORD PTR _label$[ebp]
$LN3@TreeNodeBe:

; 6927 :     const ImVec2 label_size = CalcTextSize(label, label_end, false);

	push	ecx
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	push	0
	push	edi
	push	eax
	lea	eax, DWORD PTR _label_size$[ebp]
	push	eax
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize

; 6928 : 
; 6929 :     // We vertically grow up to current line height up the typical widget height.
; 6930 :     const float text_base_offset_y = ImMax(0.0f, window->DC.CurrentLineTextBaseOffset - padding.y); // Latch before ItemSize changes it

	mov	ecx, DWORD PTR _window$1$[ebp]

; 6932 :     ImRect bb = ImRect(window->DC.CursorPos, ImVec2(window->Pos.x + GetContentRegionMax().x, window->DC.CursorPos.y + frame_height));

	lea	eax, DWORD PTR $T10[ebp]
	movss	xmm1, DWORD PTR [esi+5360]
	mulss	xmm1, DWORD PTR __real@40000000
	push	eax
	movss	xmm0, DWORD PTR [ecx+228]
	subss	xmm0, DWORD PTR _padding$[ebp+4]
	addss	xmm1, DWORD PTR [esi+6172]
	maxss	xmm0, DWORD PTR __real@00000000
	minss	xmm1, DWORD PTR [ecx+224]
	movss	DWORD PTR _text_base_offset_y$1$[ebp], xmm0
	movss	xmm0, DWORD PTR _padding$[ebp+4]
	mulss	xmm0, DWORD PTR __real@40000000
	addss	xmm0, DWORD PTR _label_size$[ebp+4]
	maxss	xmm1, xmm0
	movss	DWORD PTR _frame_height$1$[ebp], xmm1
	call	?GetContentRegionMax@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetContentRegionMax
	mov	ecx, DWORD PTR _window$1$[ebp]
	add	esp, 24					; 00000018H

; 6933 :     if (display_frame)

	cmp	BYTE PTR tv712[ebp], 0
	movss	xmm3, DWORD PTR _frame_height$1$[ebp]

; 6938 :     }
; 6939 : 
; 6940 :     const float text_offset_x = (g.FontSize + (display_frame ? padding.x*3 : padding.x*2));   // Collapser arrow width + Spacing

	movss	xmm5, DWORD PTR _padding$[ebp]
	movss	xmm2, DWORD PTR [ecx+24]
	addss	xmm2, DWORD PTR [eax]
	movss	xmm0, DWORD PTR [ecx+196]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [ecx+192]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6932 :     ImRect bb = ImRect(window->DC.CursorPos, ImVec2(window->Pos.x + GetContentRegionMax().x, window->DC.CursorPos.y + frame_height));

	addss	xmm0, xmm3

; 6938 :     }
; 6939 : 
; 6940 :     const float text_offset_x = (g.FontSize + (display_frame ? padding.x*3 : padding.x*2));   // Collapser arrow width + Spacing

	movss	xmm4, DWORD PTR __real@40000000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _bb$3$[ebp], eax
	mov	DWORD PTR _bb$[ebp], eax
	mov	eax, DWORD PTR [ecx+196]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T16[ebp], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	edx, DWORD PTR $T16[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T16[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _bb$4$[ebp], eax
	mov	DWORD PTR _bb$[ebp+4], eax
	mov	eax, DWORD PTR $T16[ebp+4]
	mov	DWORD PTR _bb$5$[ebp], edx
	mov	DWORD PTR _bb$[ebp+8], edx
	mov	DWORD PTR _bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6933 :     if (display_frame)

	je	SHORT $LN27@TreeNodeBe

; 6934 :     {
; 6935 :         // Framed header expand a little outside the default padding
; 6936 :         bb.Min.x -= (float)(int)(window->WindowPadding.x*0.5f) - 1;

	movss	xmm0, DWORD PTR [ecx+80]
	mulss	xmm0, DWORD PTR __real@3f000000
	movss	xmm1, DWORD PTR _bb$[ebp]
	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	subss	xmm0, DWORD PTR __real@3f800000
	subss	xmm1, xmm0

; 6937 :         bb.Max.x += (float)(int)(window->WindowPadding.x*0.5f) - 1;

	addss	xmm0, xmm2
	movss	DWORD PTR _bb$[ebp], xmm1
	movss	DWORD PTR _bb$[ebp+8], xmm0

; 6938 :     }
; 6939 : 
; 6940 :     const float text_offset_x = (g.FontSize + (display_frame ? padding.x*3 : padding.x*2));   // Collapser arrow width + Spacing

	movaps	xmm0, xmm5
	mov	eax, DWORD PTR _bb$[ebp+8]
	mulss	xmm0, DWORD PTR __real@40400000
	mov	DWORD PTR _bb$5$[ebp], eax
	mov	eax, DWORD PTR _bb$[ebp]
	mov	DWORD PTR _bb$3$[ebp], eax
	jmp	SHORT $LN28@TreeNodeBe
$LN27@TreeNodeBe:
	movaps	xmm0, xmm5
	mulss	xmm0, xmm4
$LN28@TreeNodeBe:
	movss	xmm1, DWORD PTR [esi+6172]
	movaps	xmm2, xmm1
	addss	xmm2, xmm0
	xorps	xmm0, xmm0
	movss	DWORD PTR _text_offset_x$1$[ebp], xmm2

; 6941 :     const float text_width = g.FontSize + (label_size.x > 0.0f ? label_size.x + padding.x*2 : 0.0f);   // Include collapser

	movss	xmm2, DWORD PTR _label_size$[ebp]
	comiss	xmm2, xmm0
	jbe	SHORT $LN29@TreeNodeBe
	movaps	xmm0, xmm5
	mulss	xmm0, xmm4
	addss	xmm0, xmm2
$LN29@TreeNodeBe:
	addss	xmm1, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T17[ebp+4], xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6942 :     ItemSize(ImVec2(text_width, frame_height), text_base_offset_y);

	push	ecx
	lea	eax, DWORD PTR $T17[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T17[ebp], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6942 :     ItemSize(ImVec2(text_width, frame_height), text_base_offset_y);

	movss	xmm1, DWORD PTR _text_base_offset_y$1$[ebp]
	movss	DWORD PTR [esp], xmm1
	push	eax
	call	?ItemSize@ImGui@@YAXABUImVec2@@M@Z	; ImGui::ItemSize

; 6946 :     const ImRect interact_bb = display_frame ? bb : ImRect(bb.Min.x, bb.Min.y, bb.Min.x + text_width + style.ItemSpacing.x*2, bb.Max.y);

	movss	xmm1, DWORD PTR _bb$[ebp+4]
	lea	eax, DWORD PTR $T6[ebp]
	add	esp, 8
	cmp	BYTE PTR tv712[ebp], 0
	je	SHORT $LN31@TreeNodeBe
	movups	xmm0, XMMWORD PTR _bb$[ebp]
	movups	XMMWORD PTR $T6[ebp], xmm0
	jmp	SHORT $LN32@TreeNodeBe
$LN31@TreeNodeBe:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR _bb$[ebp]
	movss	DWORD PTR $T5[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6946 :     const ImRect interact_bb = display_frame ? bb : ImRect(bb.Min.x, bb.Min.y, bb.Min.x + text_width + style.ItemSpacing.x*2, bb.Max.y);

	movss	xmm1, DWORD PTR $T17[ebp]
	addss	xmm1, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T5[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6946 :     const ImRect interact_bb = display_frame ? bb : ImRect(bb.Min.x, bb.Min.y, bb.Min.x + text_width + style.ItemSpacing.x*2, bb.Max.y);

	movss	xmm0, DWORD PTR [esi+5368]
	mulss	xmm0, DWORD PTR __real@40000000
	addss	xmm1, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR _bb$[ebp+12]
	movss	DWORD PTR $T5[ebp+12], xmm0
	movss	DWORD PTR $T5[ebp+8], xmm1
$LN32@TreeNodeBe:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6946 :     const ImRect interact_bb = display_frame ? bb : ImRect(bb.Min.x, bb.Min.y, bb.Min.x + text_width + style.ItemSpacing.x*2, bb.Max.y);

	movups	xmm0, XMMWORD PTR [eax]

; 6947 :     bool is_open = TreeNodeBehaviorIsOpen(id, flags);

	push	ebx
	push	DWORD PTR _id$[ebp]
	movups	XMMWORD PTR _interact_bb$[ebp], xmm0
	call	?TreeNodeBehaviorIsOpen@ImGui@@YA_NIH@Z	; ImGui::TreeNodeBehaviorIsOpen
	mov	BYTE PTR _is_open$[ebp], al

; 6948 :     if (!ItemAdd(interact_bb, &id))

	lea	eax, DWORD PTR _id$[ebp]
	push	0
	push	eax
	lea	eax, DWORD PTR _interact_bb$[ebp]
	push	eax
	call	?ItemAdd@ImGui@@YA_NABUImRect@@PBIPBU2@@Z ; ImGui::ItemAdd
	add	esp, 20					; 00000014H
	test	al, al
	je	$LN14@TreeNodeBe

; 6949 :     {
; 6950 :         if (is_open && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))
; 6951 :             TreePushRawID(id);
; 6952 :         return is_open;
; 6953 :     }
; 6954 : 
; 6955 :     // Flags that affects opening behavior:
; 6956 :     // - 0(default) ..................... single-click anywhere to open
; 6957 :     // - OpenOnDoubleClick .............. double-click anywhere to open
; 6958 :     // - OpenOnArrow .................... single-click on arrow to open
; 6959 :     // - OpenOnDoubleClick|OpenOnArrow .. single-click on arrow or double-click anywhere to open
; 6960 :     ImGuiButtonFlags button_flags = ImGuiButtonFlags_NoKeyModifiers | ((flags & ImGuiTreeNodeFlags_AllowOverlapMode) ? ImGuiButtonFlags_AllowOverlapMode : 0);

	mov	eax, ebx
	and	eax, 4
	mov	ecx, eax
	mov	DWORD PTR tv833[ebp], eax
	or	ecx, 2

; 6961 :     if (flags & ImGuiTreeNodeFlags_OpenOnDoubleClick)

	mov	eax, ebx
	shl	ecx, 8
	and	eax, 64					; 00000040H
	mov	DWORD PTR tv832[ebp], eax
	je	SHORT $LN7@TreeNodeBe

; 6962 :         button_flags |= ImGuiButtonFlags_PressedOnDoubleClick | ((flags & ImGuiTreeNodeFlags_OpenOnArrow) ? ImGuiButtonFlags_PressedOnClickRelease : 0);

	mov	eax, ebx
	and	eax, 128				; 00000080H
	or	eax, 1024				; 00000400H
	shr	eax, 6
	or	ecx, eax
$LN7@TreeNodeBe:

; 6963 :     bool hovered, held, pressed = ButtonBehavior(interact_bb, id, &hovered, &held, button_flags);

	push	ecx
	lea	eax, DWORD PTR _held$[ebp]
	push	eax
	lea	eax, DWORD PTR _hovered$[ebp]
	push	eax
	push	DWORD PTR _id$[ebp]
	lea	eax, DWORD PTR _interact_bb$[ebp]
	push	eax
	call	?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z ; ImGui::ButtonBehavior
	add	esp, 20					; 00000014H

; 6964 :     if (pressed && !(flags & ImGuiTreeNodeFlags_Leaf))

	test	al, al
	je	$LN11@TreeNodeBe
	test	ebx, 256				; 00000100H
	jne	$LN11@TreeNodeBe

; 6965 :     {
; 6966 :         bool toggled = !(flags & (ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick)) || (g.NavActivateId == id);

	test	bl, 192					; 000000c0H
	je	SHORT $LN33@TreeNodeBe
	mov	eax, DWORD PTR _id$[ebp]
	cmp	DWORD PTR [esi+6388], eax
	je	SHORT $LN33@TreeNodeBe
	xor	al, al
	jmp	SHORT $LN118@TreeNodeBe
$LN33@TreeNodeBe:
	mov	al, 1
$LN118@TreeNodeBe:
	mov	BYTE PTR _toggled$1$[ebp], al

; 6967 :         if (flags & ImGuiTreeNodeFlags_OpenOnArrow)

	test	bl, bl
	jns	SHORT $LN9@TreeNodeBe

; 6968 :             toggled |= IsMouseHoveringRect(interact_bb.Min, ImVec2(interact_bb.Min.x + text_offset_x, interact_bb.Max.y)) && (!g.NavDisableMouseHover);

	movss	xmm0, DWORD PTR _interact_bb$[ebp]
	lea	eax, DWORD PTR $T9[ebp]
	addss	xmm0, DWORD PTR _text_offset_x$1$[ebp]
	push	1
	push	eax
	lea	eax, DWORD PTR _interact_bb$[ebp]
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T9[ebp], xmm0
	movss	xmm0, DWORD PTR _interact_bb$[ebp+12]
	movss	DWORD PTR $T9[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6968 :             toggled |= IsMouseHoveringRect(interact_bb.Min, ImVec2(interact_bb.Min.x + text_offset_x, interact_bb.Max.y)) && (!g.NavDisableMouseHover);

	call	?IsMouseHoveringRect@ImGui@@YA_NABUImVec2@@0_N@Z ; ImGui::IsMouseHoveringRect
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN35@TreeNodeBe
	cmp	BYTE PTR [esi+6455], 0
	jne	SHORT $LN35@TreeNodeBe
	mov	ecx, 1
	jmp	SHORT $LN36@TreeNodeBe
$LN35@TreeNodeBe:
	xor	ecx, ecx
$LN36@TreeNodeBe:
	mov	al, BYTE PTR _toggled$1$[ebp]
	or	al, cl
$LN9@TreeNodeBe:
	cmp	DWORD PTR tv832[ebp], 0

; 6969 :         if (flags & ImGuiTreeNodeFlags_OpenOnDoubleClick)

	je	SHORT $LN10@TreeNodeBe

; 6970 :             toggled |= g.IO.MouseDoubleClicked[0];

	or	al, BYTE PTR [esi+956]
$LN10@TreeNodeBe:

; 6971 :         if (toggled)

	test	al, al
	je	SHORT $LN11@TreeNodeBe

; 6972 :         {
; 6973 :             is_open = !is_open;

	cmp	BYTE PTR _is_open$[ebp], 0

; 6974 :             window->DC.StateStorage->SetInt(id, is_open);

	mov	ecx, DWORD PTR _window$1$[ebp]
	sete	al
	mov	BYTE PTR _is_open$[ebp], al
	movzx	eax, al
	mov	ecx, DWORD PTR [ecx+304]
	push	eax
	push	DWORD PTR _id$[ebp]
	call	?SetInt@ImGuiStorage@@QAEXIH@Z		; ImGuiStorage::SetInt
$LN11@TreeNodeBe:
	cmp	DWORD PTR tv833[ebp], 0

; 6975 :         }
; 6976 :     }
; 6977 :     if (flags & ImGuiTreeNodeFlags_AllowOverlapMode)

	je	SHORT $LN12@TreeNodeBe

; 6978 :         SetItemAllowOverlap();

	call	?SetItemAllowOverlap@ImGui@@YAXXZ	; ImGui::SetItemAllowOverlap
$LN12@TreeNodeBe:

; 6979 : 
; 6980 :     // Render
; 6981 :     const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);

	cmp	BYTE PTR _held$[ebp], 0
	mov	cl, BYTE PTR _hovered$[ebp]
	je	SHORT $LN37@TreeNodeBe
	test	cl, cl
	je	SHORT $LN37@TreeNodeBe
	mov	eax, 27					; 0000001bH
	jmp	SHORT $LN38@TreeNodeBe
$LN37@TreeNodeBe:
	xor	eax, eax
	test	cl, cl
	setne	al
	add	eax, 25					; 00000019H
$LN38@TreeNodeBe:
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	eax
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32

; 6982 :     const ImVec2 text_pos = bb.Min + ImVec2(text_offset_x, padding.y + text_base_offset_y);

	movss	xmm1, DWORD PTR _padding$[ebp+4]
	add	esp, 8

; 6983 :     if (display_frame)

	cmp	BYTE PTR tv712[ebp], 0
	movss	xmm5, DWORD PTR _text_base_offset_y$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm2, DWORD PTR _text_offset_x$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6982 :     const ImVec2 text_pos = bb.Min + ImVec2(text_offset_x, padding.y + text_base_offset_y);

	addss	xmm1, xmm5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm3, DWORD PTR _bb$[ebp]
	movaps	xmm0, xmm2
	movss	xmm4, DWORD PTR _bb$[ebp+4]
	addss	xmm0, xmm3
	addss	xmm1, xmm4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _text_pos$[ebp], xmm0
	movss	DWORD PTR _text_pos$[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6983 :     if (display_frame)

	je	$LN13@TreeNodeBe

; 6984 :     {
; 6985 :         // Framed type
; 6986 :         RenderFrame(bb.Min, bb.Max, col, true, style.FrameRounding);

	movss	xmm0, DWORD PTR [esi+5364]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	1
	push	eax
	push	DWORD PTR $T16[ebp+4]
	push	DWORD PTR _bb$5$[ebp]
	push	DWORD PTR _bb$4$[ebp]
	push	DWORD PTR _bb$3$[ebp]
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR _bb$[ebp+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6987 :         RenderCollapseTriangle(bb.Min + padding + ImVec2(0.0f, text_base_offset_y), is_open, 1.0f);

	add	esp, 24					; 00000018H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, DWORD PTR _padding$[ebp+4]
	movss	xmm1, DWORD PTR _padding$[ebp]
	addss	xmm1, DWORD PTR _bb$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6987 :         RenderCollapseTriangle(bb.Min + padding + ImVec2(0.0f, text_base_offset_y), is_open, 1.0f);

	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	DWORD PTR _is_open$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, DWORD PTR _text_base_offset_y$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T15[ebp], xmm1
	movss	DWORD PTR $T15[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6987 :         RenderCollapseTriangle(bb.Min + padding + ImVec2(0.0f, text_base_offset_y), is_open, 1.0f);

	push	DWORD PTR $T15[ebp+4]
	push	DWORD PTR $T15[ebp]
	call	?RenderCollapseTriangle@ImGui@@YAXUImVec2@@_NM@Z ; ImGui::RenderCollapseTriangle
	add	esp, 16					; 00000010H

; 6988 :         if (g.LogEnabled)

	cmp	BYTE PTR [esi+11600], 0
	je	SHORT $LN15@TreeNodeBe

; 6989 :         {
; 6990 :             // NB: '##' is normally used to hide text (as a library-wide feature), so we need to specify the text range to make sure the ## aren't stripped out here.
; 6991 :             const char log_prefix[] = "\n##";
; 6992 :             const char log_suffix[] = "##";

	mov	ax, WORD PTR $SG119495
	mov	WORD PTR _log_suffix$19[ebp], ax
	mov	al, BYTE PTR $SG119495+2
	mov	BYTE PTR _log_suffix$19[ebp+2], al

; 6993 :             LogRenderedText(text_pos, log_prefix, log_prefix+3);

	lea	eax, DWORD PTR _log_prefix$18[ebp+3]
	push	eax
	lea	eax, DWORD PTR _log_prefix$18[ebp]
	mov	DWORD PTR _log_prefix$18[ebp], 2302730	; 0023230aH
	push	eax
	lea	eax, DWORD PTR _text_pos$[ebp]
	push	eax
	call	?LogRenderedText@@YAXABUImVec2@@PBD1@Z	; LogRenderedText

; 6994 :             RenderTextClipped(text_pos, bb.Max, label, label_end, &label_size);

	push	0
	lea	eax, DWORD PTR $T8[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T8[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6994 :             RenderTextClipped(text_pos, bb.Max, label, label_end, &label_size);

	push	eax
	lea	eax, DWORD PTR _label_size$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T8[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6994 :             RenderTextClipped(text_pos, bb.Max, label, label_end, &label_size);

	push	eax
	mov	eax, DWORD PTR _label$[ebp]
	push	edi
	push	eax
	lea	eax, DWORD PTR _bb$[ebp+8]
	push	eax
	lea	eax, DWORD PTR _text_pos$[ebp]
	push	eax
	call	?RenderTextClipped@ImGui@@YAXABUImVec2@@0PBD1PBU2@0PBUImRect@@@Z ; ImGui::RenderTextClipped

; 6995 :             LogRenderedText(text_pos, log_suffix+1, log_suffix+3);

	lea	eax, DWORD PTR _log_suffix$19[ebp+3]
	push	eax
	lea	eax, DWORD PTR _log_suffix$19[ebp+1]
	push	eax
	lea	eax, DWORD PTR _text_pos$[ebp]
	push	eax
	call	?LogRenderedText@@YAXABUImVec2@@PBD1@Z	; LogRenderedText
	add	esp, 52					; 00000034H

; 6996 :         }
; 6997 :         else

	jmp	$LN14@TreeNodeBe
$LN15@TreeNodeBe:

; 6999 :             RenderTextClipped(text_pos, bb.Max, label, label_end, &label_size);

	push	0
	lea	eax, DWORD PTR $T7[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T7[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6999 :             RenderTextClipped(text_pos, bb.Max, label, label_end, &label_size);

	push	eax
	lea	eax, DWORD PTR _label_size$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T7[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6999 :             RenderTextClipped(text_pos, bb.Max, label, label_end, &label_size);

	push	eax
	mov	eax, DWORD PTR _label$[ebp]
	push	edi
	push	eax
	lea	eax, DWORD PTR _bb$[ebp+8]
	push	eax
	lea	eax, DWORD PTR _text_pos$[ebp]
	push	eax
	call	?RenderTextClipped@ImGui@@YAXABUImVec2@@0PBD1PBU2@0PBUImRect@@@Z ; ImGui::RenderTextClipped
	add	esp, 28					; 0000001cH

; 7000 :         }
; 7001 :     }
; 7002 :     else

	jmp	$LN14@TreeNodeBe
$LN13@TreeNodeBe:

; 7003 :     {
; 7004 :         // Unframed typed for tree nodes
; 7005 :         if (hovered || (flags & ImGuiTreeNodeFlags_Selected))

	cmp	BYTE PTR _hovered$[ebp], 0
	jne	SHORT $LN18@TreeNodeBe
	test	bl, 1
	je	SHORT $LN17@TreeNodeBe
$LN18@TreeNodeBe:

; 7006 :             RenderFrame(bb.Min, bb.Max, col, false);

	push	ecx
	mov	DWORD PTR [esp], 0
	push	0
	push	eax
	push	DWORD PTR $T16[ebp+4]
	push	DWORD PTR _bb$5$[ebp]
	push	DWORD PTR _bb$4$[ebp]
	push	DWORD PTR _bb$3$[ebp]
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame
	movss	xmm2, DWORD PTR _text_offset_x$1$[ebp]
	add	esp, 28					; 0000001cH
	movss	xmm3, DWORD PTR _bb$[ebp]
	movss	xmm4, DWORD PTR _bb$[ebp+4]
	movss	xmm5, DWORD PTR _text_base_offset_y$1$[ebp]
$LN17@TreeNodeBe:

; 7007 : 
; 7008 :         if (flags & ImGuiTreeNodeFlags_Bullet)

	test	ebx, 512				; 00000200H
	je	SHORT $LN19@TreeNodeBe

; 7009 :             RenderBullet(bb.Min + ImVec2(text_offset_x * 0.5f, g.FontSize*0.50f + text_base_offset_y));

	movss	xmm0, DWORD PTR [esi+6172]
	mulss	xmm0, DWORD PTR __real@3f000000
	mulss	xmm2, DWORD PTR __real@3f000000
	addss	xmm0, xmm5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm2, xmm3
	addss	xmm0, xmm4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T12[ebp], xmm2
	movss	DWORD PTR $T12[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7009 :             RenderBullet(bb.Min + ImVec2(text_offset_x * 0.5f, g.FontSize*0.50f + text_base_offset_y));

	push	DWORD PTR $T12[ebp+4]
	push	DWORD PTR $T12[ebp]
	call	?RenderBullet@ImGui@@YAXUImVec2@@@Z	; ImGui::RenderBullet
	add	esp, 8
	jmp	SHORT $LN21@TreeNodeBe
$LN19@TreeNodeBe:

; 7010 :         else if (!(flags & ImGuiTreeNodeFlags_Leaf))

	test	ebx, 256				; 00000100H
	jne	SHORT $LN21@TreeNodeBe

; 7011 :             RenderCollapseTriangle(bb.Min + ImVec2(padding.x, g.FontSize*0.15f + text_base_offset_y), is_open, 0.70f);

	movss	xmm0, DWORD PTR [esi+6172]
	mulss	xmm0, DWORD PTR __real@3e19999a
	push	ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm1, DWORD PTR _padding$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7011 :             RenderCollapseTriangle(bb.Min + ImVec2(padding.x, g.FontSize*0.15f + text_base_offset_y), is_open, 0.70f);

	mov	DWORD PTR [esp], 1060320051		; 3f333333H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm1, xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7011 :             RenderCollapseTriangle(bb.Min + ImVec2(padding.x, g.FontSize*0.15f + text_base_offset_y), is_open, 0.70f);

	push	DWORD PTR _is_open$[ebp]
	addss	xmm0, xmm5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T11[ebp], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T11[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7011 :             RenderCollapseTriangle(bb.Min + ImVec2(padding.x, g.FontSize*0.15f + text_base_offset_y), is_open, 0.70f);

	push	DWORD PTR $T11[ebp+4]
	push	DWORD PTR $T11[ebp]
	call	?RenderCollapseTriangle@ImGui@@YAXUImVec2@@_NM@Z ; ImGui::RenderCollapseTriangle
	add	esp, 16					; 00000010H
$LN21@TreeNodeBe:

; 7012 :         if (g.LogEnabled)

	cmp	BYTE PTR [esi+11600], 0
	je	SHORT $LN22@TreeNodeBe

; 7013 :             LogRenderedText(text_pos, ">");

	push	0
	lea	eax, DWORD PTR _text_pos$[ebp]
	push	OFFSET $SG119502
	push	eax
	call	?LogRenderedText@@YAXABUImVec2@@PBD1@Z	; LogRenderedText
	add	esp, 12					; 0000000cH
$LN22@TreeNodeBe:

; 7014 :         RenderText(text_pos, label, label_end, false);

	mov	eax, DWORD PTR _label$[ebp]
	push	0
	push	edi
	push	eax
	push	DWORD PTR _text_pos$[ebp+4]
	push	DWORD PTR _text_pos$[ebp]
	call	?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z	; ImGui::RenderText
	add	esp, 20					; 00000014H
$LN14@TreeNodeBe:

; 7015 :     }
; 7016 : 
; 7017 :     if (is_open && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))

	mov	al, BYTE PTR _is_open$[ebp]
	test	al, al
	je	SHORT $LN115@TreeNodeBe
	test	bl, 8
	jne	SHORT $LN115@TreeNodeBe

; 7018 :         TreePushRawID(id);

	push	DWORD PTR _id$[ebp]
	call	?TreePushRawID@ImGui@@YAXI@Z		; ImGui::TreePushRawID
	mov	al, BYTE PTR _is_open$[ebp]
	add	esp, 4
$LN115@TreeNodeBe:
	pop	edi
	pop	esi
	pop	ebx

; 7019 :     return is_open;
; 7020 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TreeNodeBehavior@ImGui@@YA_NIHPBD0@Z ENDP		; ImGui::TreeNodeBehavior
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_buf$ = -40						; size = 32
$T1 = -8						; size = 8
_aabb$ = 8						; size = 4
_label$ = 12						; size = 4
_data_type$ = 16					; size = 4
_data_ptr$ = 20						; size = 4
_id$ = 24						; size = 4
_decimal_precision$ = 28				; size = 4
?InputScalarAsWidgetReplacement@ImGui@@YA_NABUImRect@@PBDW4ImGuiDataType@@PAXIH@Z PROC ; ImGui::InputScalarAsWidgetReplacement

; 7372 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi

; 7373 :     ImGuiContext& g = *GImGui;

	mov	edi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [edi+6240]
	mov	BYTE PTR [eax+134], 1
	mov	esi, DWORD PTR [edi+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7377 :     SetActiveIDNoNav(g.ScalarAsInputTextId, window);

	push	esi
	push	DWORD PTR [edi+10500]
	call	?SetActiveIDNoNav@ImGui@@YAXIPAUImGuiWindow@@@Z ; ImGui::SetActiveIDNoNav

; 7378 :     g.ActiveIdAllowNavDirFlags = (1 << ImGuiNavDir_Up) | (1 << ImGuiNavDir_Down);
; 7379 :     SetHoveredID(0);

	push	0
	mov	DWORD PTR [edi+6276], 12		; 0000000cH
	call	?SetHoveredID@ImGui@@YAXI@Z		; ImGui::SetHoveredID

; 7380 :     FocusableItemUnregister(window);

	push	esi
	call	?FocusableItemUnregister@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusableItemUnregister

; 7381 : 
; 7382 :     char buf[32];
; 7383 :     DataTypeFormatString(data_type, data_ptr, decimal_precision, buf, IM_ARRAYSIZE(buf));

	mov	esi, DWORD PTR _data_ptr$[ebp]
	lea	eax, DWORD PTR _buf$[ebp]
	push	32					; 00000020H
	push	eax
	push	DWORD PTR _decimal_precision$[ebp]
	push	esi
	push	DWORD PTR _data_type$[ebp]
	call	?DataTypeFormatString@@YAXW4ImGuiDataType@@PAXHPADH@Z ; DataTypeFormatString
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 245  :     ImVec2      GetSize() const                 { return ImVec2(Max.x-Min.x, Max.y-Min.y); }

	mov	eax, DWORD PTR _aabb$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7384 :     bool text_value_changed = InputTextEx(label, buf, IM_ARRAYSIZE(buf), aabb.GetSize(), ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_AutoSelectAll);

	push	0
	push	0
	push	17					; 00000011H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 245  :     ImVec2      GetSize() const                 { return ImVec2(Max.x-Min.x, Max.y-Min.y); }

	movss	xmm0, DWORD PTR [eax+8]
	subss	xmm0, DWORD PTR [eax]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 245  :     ImVec2      GetSize() const                 { return ImVec2(Max.x-Min.x, Max.y-Min.y); }

	movss	xmm0, DWORD PTR [eax+12]
	subss	xmm0, DWORD PTR [eax+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7384 :     bool text_value_changed = InputTextEx(label, buf, IM_ARRAYSIZE(buf), aabb.GetSize(), ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_AutoSelectAll);

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	push	32					; 00000020H
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	push	DWORD PTR _label$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7384 :     bool text_value_changed = InputTextEx(label, buf, IM_ARRAYSIZE(buf), aabb.GetSize(), ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_AutoSelectAll);

	call	?InputTextEx@ImGui@@YA_NPBDPADHABUImVec2@@HP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ; ImGui::InputTextEx
	add	esp, 64					; 00000040H
	mov	bl, al

; 7385 :     if (g.ScalarAsInputTextId == 0)     // First frame we started displaying the InputText widget

	cmp	DWORD PTR [edi+10500], 0
	jne	SHORT $LN2@InputScala

; 7386 :     {
; 7387 :         IM_ASSERT(g.ActiveId == id);    // InputText ID expected to match the Slider ID (else we'd need to store them both, which is also possible)
; 7388 :         g.ScalarAsInputTextId = g.ActiveId;

	mov	ecx, DWORD PTR [edi+6264]

; 7389 :         SetHoveredID(id);

	push	DWORD PTR _id$[ebp]
	mov	DWORD PTR [edi+10500], ecx
	call	?SetHoveredID@ImGui@@YAXI@Z		; ImGui::SetHoveredID
	add	esp, 4
$LN2@InputScala:

; 7390 :     }
; 7391 :     if (text_value_changed)

	test	bl, bl
	je	SHORT $LN3@InputScala
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 916  :     inline iterator             begin()                         { return Data; }

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7392 :         return DataTypeApplyOpFromText(buf, GImGui->InputTextState.InitialText.begin(), data_type, data_ptr, NULL);

	push	0
	push	esi
	push	DWORD PTR _data_type$[ebp]
	push	DWORD PTR [eax+7156]
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	?DataTypeApplyOpFromText@@YA_NPBD0W4ImGuiDataType@@PAX0@Z ; DataTypeApplyOpFromText
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi
	pop	ebx

; 7394 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@InputScala:
	pop	edi
	pop	esi

; 7393 :     return false;

	xor	al, al
	pop	ebx

; 7394 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InputScalarAsWidgetReplacement@ImGui@@YA_NABUImRect@@PBDW4ImGuiDataType@@PAXIH@Z ENDP ; ImGui::InputScalarAsWidgetReplacement
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_buf$ = -96						; size = 64
_label_size$ = -32					; size = 8
$T3 = -24						; size = 8
_button_sz$ = -24					; size = 8
_window$1$ = -16					; size = 4
_button_sz$1$ = -12					; size = 4
tv466 = -12						; size = 4
tv463 = -12						; size = 4
tv376 = -8						; size = 4
_value_changed$1$ = -1					; size = 1
_label$ = 8						; size = 4
_data_type$ = 12					; size = 4
_data_ptr$ = 16						; size = 4
_step_ptr$ = 20						; size = 4
_step_fast_ptr$ = 24					; size = 4
_scalar_format$ = 28					; size = 4
_extra_flags$ = 32					; size = 4
?InputScalarEx@ImGui@@YA_NPBDW4ImGuiDataType@@PAX220H@Z PROC ; ImGui::InputScalarEx

; 9296 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	eax, DWORD PTR [ecx+6240]
	mov	DWORD PTR _window$1$[ebp], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9298 :     if (window->SkipItems)

	cmp	BYTE PTR [eax+137], 0
	je	SHORT $LN2@InputScala

; 9299 :         return false;

	xor	al, al

; 9349 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@InputScala:
	push	ebx

; 9300 : 
; 9301 :     ImGuiContext& g = *GImGui;
; 9302 :     const ImGuiStyle& style = g.Style;
; 9303 :     const ImVec2 label_size = CalcTextSize(label, NULL, true);

	mov	ebx, DWORD PTR _label$[ebp]
	lea	eax, DWORD PTR _label_size$[ebp]
	push	esi
	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	ecx
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	push	1
	push	0
	push	ebx
	push	eax
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize

; 9304 : 
; 9305 :     BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup

; 9306 :     PushID(label);

	push	ebx
	call	?PushID@ImGui@@YAXPBD@Z			; ImGui::PushID
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	movss	xmm2, DWORD PTR [esi+5356]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9306 :     PushID(label);

	add	esp, 24					; 00000018H

; 9308 :     if (step_ptr)

	cmp	DWORD PTR _step_ptr$[ebp], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	addss	xmm2, xmm2
	movss	xmm1, DWORD PTR [esi+5360]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR [esi+6172]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	addss	xmm1, xmm1

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm2, xmm0
	addss	xmm1, xmm0
	movss	DWORD PTR _button_sz$1$[ebp], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _button_sz$[ebp], xmm2
	movss	DWORD PTR _button_sz$[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9308 :     if (step_ptr)

	je	SHORT $LN3@InputScala

; 9309 :         PushItemWidth(ImMax(1.0f, CalcItemWidth() - (button_sz.x + style.ItemInnerSpacing.x)*2));

	movss	xmm0, DWORD PTR [esi+5376]
	movss	DWORD PTR tv376[ebp], xmm0
	call	?CalcItemWidth@ImGui@@YAMXZ		; ImGui::CalcItemWidth
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 128  : static inline float  ImMax(float lhs, float rhs)                                { return lhs >= rhs ? lhs : rhs; }

	movss	xmm0, DWORD PTR tv376[ebp]
	addss	xmm0, DWORD PTR _button_sz$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9309 :         PushItemWidth(ImMax(1.0f, CalcItemWidth() - (button_sz.x + style.ItemInnerSpacing.x)*2));

	push	ecx
	mulss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR tv466[ebp], xmm0
	fsub	DWORD PTR tv466[ebp]
	fstp	DWORD PTR tv463[ebp]
	movss	xmm0, DWORD PTR tv463[ebp]
	maxss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [esp], xmm0
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth
	add	esp, 4
$LN3@InputScala:

; 7264 :     if (data_type == ImGuiDataType_Int)

	mov	ebx, DWORD PTR _data_type$[ebp]
	mov	eax, DWORD PTR _scalar_format$[ebp]
	push	edi

; 7265 :         ImFormatString(buf, buf_size, display_format, *(int*)data_ptr);

	mov	edi, DWORD PTR _data_ptr$[ebp]
	test	ebx, ebx
	jne	SHORT $LN32@InputScala
	push	DWORD PTR [edi]
	push	eax
	lea	eax, DWORD PTR _buf$[ebp]
	push	64					; 00000040H
	push	eax
	call	?ImFormatString@@YAHPADHPBDZZ		; ImFormatString
	add	esp, 16					; 00000010H
	jmp	SHORT $LN34@InputScala
$LN32@InputScala:

; 7266 :     else if (data_type == ImGuiDataType_Float)

	cmp	ebx, 1
	jne	SHORT $LN34@InputScala
	movss	xmm0, DWORD PTR [edi]

; 7267 :         ImFormatString(buf, buf_size, display_format, *(float*)data_ptr);

	sub	esp, 8
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	eax
	lea	eax, DWORD PTR _buf$[ebp]
	push	64					; 00000040H
	push	eax
	call	?ImFormatString@@YAHPADHPBDZZ		; ImFormatString
	add	esp, 20					; 00000014H
$LN34@InputScala:

; 9310 : 
; 9311 :     char buf[64];
; 9312 :     DataTypeFormatString(data_type, data_ptr, scalar_format, buf, IM_ARRAYSIZE(buf));
; 9313 : 
; 9314 :     bool value_changed = false;
; 9315 :     if (!(extra_flags & ImGuiInputTextFlags_CharsHexadecimal))

	mov	ecx, DWORD PTR _extra_flags$[ebp]
	xor	al, al
	mov	BYTE PTR _value_changed$1$[ebp], al
	mov	edx, ecx
	mov	eax, ecx
	or	edx, 1
	and	al, 2

; 9316 :         extra_flags |= ImGuiInputTextFlags_CharsDecimal;
; 9317 :     extra_flags |= ImGuiInputTextFlags_AutoSelectAll;
; 9318 :     if (InputText("", buf, IM_ARRAYSIZE(buf), extra_flags)) // PushId(label) + "" gives us the expected ID from outside point of view

	push	0
	push	0
	cmovne	edx, ecx
	lea	eax, DWORD PTR _buf$[ebp]
	or	edx, 16					; 00000010H
	push	edx
	push	64					; 00000040H
	push	eax
	push	OFFSET $SG121691
	call	?InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ; ImGui::InputText
	add	esp, 24					; 00000018H
	test	al, al
	je	SHORT $LN5@InputScala

; 9319 :         value_changed = DataTypeApplyOpFromText(buf, GImGui->InputTextState.InitialText.begin(), data_type, data_ptr, scalar_format);

	push	DWORD PTR _scalar_format$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 916  :     inline iterator             begin()                         { return Data; }

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9319 :         value_changed = DataTypeApplyOpFromText(buf, GImGui->InputTextState.InitialText.begin(), data_type, data_ptr, scalar_format);

	push	edi
	push	ebx
	push	DWORD PTR [eax+7156]
	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	?DataTypeApplyOpFromText@@YA_NPBD0W4ImGuiDataType@@PAX0@Z ; DataTypeApplyOpFromText
	add	esp, 20					; 00000014H
	mov	BYTE PTR _value_changed$1$[ebp], al
$LN5@InputScala:

; 9320 : 
; 9321 :     // Step buttons
; 9322 :     if (step_ptr)

	cmp	DWORD PTR _step_ptr$[ebp], 0
	je	$LN42@InputScala

; 9323 :     {
; 9324 :         PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 9325 :         SameLine(0, style.ItemInnerSpacing.x);

	movss	xmm0, DWORD PTR [esi+5376]
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 9326 :         if (ButtonEx("-", button_sz, ImGuiButtonFlags_Repeat | ImGuiButtonFlags_DontClosePopups))

	push	65					; 00000041H
	lea	eax, DWORD PTR _button_sz$[ebp]
	push	eax
	push	OFFSET $SG121694
	call	?ButtonEx@ImGui@@YA_NPBDABUImVec2@@H@Z	; ImGui::ButtonEx
	mov	edi, DWORD PTR _step_fast_ptr$[ebp]
	add	esp, 20					; 00000014H
	test	al, al
	je	SHORT $LN7@InputScala

; 9327 :         {
; 9328 :             DataTypeApplyOp(data_type, '-', data_ptr, g.IO.KeyCtrl && step_fast_ptr ? step_fast_ptr : step_ptr);

	cmp	BYTE PTR [esi+229], 0
	je	SHORT $LN11@InputScala
	mov	eax, edi
	test	edi, edi
	jne	SHORT $LN12@InputScala
$LN11@InputScala:
	mov	eax, DWORD PTR _step_ptr$[ebp]
$LN12@InputScala:
	push	eax
	push	DWORD PTR _data_ptr$[ebp]
	push	45					; 0000002dH
	push	ebx
	call	?DataTypeApplyOp@@YAXW4ImGuiDataType@@HPAXPBX@Z ; DataTypeApplyOp
	add	esp, 16					; 00000010H

; 9329 :             value_changed = true;

	mov	BYTE PTR _value_changed$1$[ebp], 1
$LN7@InputScala:

; 9330 :         }
; 9331 :         SameLine(0, style.ItemInnerSpacing.x);

	movss	xmm0, DWORD PTR [esi+5376]
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 9332 :         if (ButtonEx("+", button_sz, ImGuiButtonFlags_Repeat | ImGuiButtonFlags_DontClosePopups))

	push	65					; 00000041H
	lea	eax, DWORD PTR _button_sz$[ebp]
	push	eax
	push	OFFSET $SG121696
	call	?ButtonEx@ImGui@@YA_NPBDABUImVec2@@H@Z	; ImGui::ButtonEx
	add	esp, 20					; 00000014H
	test	al, al
	je	SHORT $LN42@InputScala

; 9333 :         {
; 9334 :             DataTypeApplyOp(data_type, '+', data_ptr, g.IO.KeyCtrl && step_fast_ptr ? step_fast_ptr : step_ptr);

	cmp	BYTE PTR [esi+229], 0
	je	SHORT $LN13@InputScala
	test	edi, edi
	jne	SHORT $LN14@InputScala
$LN13@InputScala:
	mov	edi, DWORD PTR _step_ptr$[ebp]
$LN14@InputScala:
	push	edi
	push	DWORD PTR _data_ptr$[ebp]
	push	43					; 0000002bH
	push	ebx
	call	?DataTypeApplyOp@@YAXW4ImGuiDataType@@HPAXPBX@Z ; DataTypeApplyOp
	add	esp, 16					; 00000010H

; 9335 :             value_changed = true;

	mov	bl, 1
	jmp	SHORT $LN8@InputScala
$LN42@InputScala:
	mov	bl, BYTE PTR _value_changed$1$[ebp]
$LN8@InputScala:

; 9336 :         }
; 9337 :     }
; 9338 :     PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 9339 : 
; 9340 :     if (label_size.x > 0)

	movss	xmm0, DWORD PTR _label_size$[ebp]
	xorps	xmm1, xmm1
	comiss	xmm0, xmm1
	pop	edi
	jbe	SHORT $LN9@InputScala

; 9341 :     {
; 9342 :         SameLine(0, style.ItemInnerSpacing.x);

	movss	xmm0, DWORD PTR [esi+5376]
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR _window$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9343 :         RenderText(ImVec2(window->DC.CursorPos.x, window->DC.CursorPos.y + style.FramePadding.y), label);

	push	1
	push	0
	push	DWORD PTR _label$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR [eax+192]
	movss	DWORD PTR $T3[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9343 :         RenderText(ImVec2(window->DC.CursorPos.x, window->DC.CursorPos.y + style.FramePadding.y), label);

	movss	xmm0, DWORD PTR [eax+196]
	addss	xmm0, DWORD PTR [esi+5360]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9343 :         RenderText(ImVec2(window->DC.CursorPos.x, window->DC.CursorPos.y + style.FramePadding.y), label);

	push	DWORD PTR $T3[ebp+4]
	push	DWORD PTR $T3[ebp]
	call	?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z	; ImGui::RenderText

; 9344 :         ItemSize(label_size, style.FramePadding.y);

	movss	xmm0, DWORD PTR [esi+5360]
	lea	eax, DWORD PTR _label_size$[ebp]
	add	esp, 24					; 00000018H
	movss	DWORD PTR [esp], xmm0
	push	eax
	call	?ItemSize@ImGui@@YAXABUImVec2@@M@Z	; ImGui::ItemSize
	add	esp, 8
$LN9@InputScala:

; 9345 :     }
; 9346 :     EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup
	pop	esi

; 9347 : 
; 9348 :     return value_changed;

	mov	al, bl
	pop	ebx

; 9349 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InputScalarEx@ImGui@@YA_NPBDW4ImGuiDataType@@PAX220H@Z ENDP ; ImGui::InputScalarEx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_window$1$ = -8						; size = 4
_g$1$ = -4						; size = 4
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_components$ = 16					; size = 4
_extra_flags$ = 20					; size = 4
?InputIntN@ImGui@@YA_NPBDPAHHH@Z PROC			; ImGui::InputIntN

; 9412 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	eax, DWORD PTR [ecx+6240]
	mov	DWORD PTR _window$1$[ebp], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9414 :     if (window->SkipItems)

	cmp	BYTE PTR [eax+137], 0
	je	SHORT $LN5@InputIntN

; 9415 :         return false;

	xor	al, al

; 9437 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@InputIntN:

; 9416 : 
; 9417 :     ImGuiContext& g = *GImGui;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _g$1$[ebp], eax

; 9418 :     bool value_changed = false;

	xor	bl, bl

; 9419 :     BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup

; 9420 :     PushID(label);

	push	DWORD PTR _label$[ebp]
	call	?PushID@ImGui@@YAXPBD@Z			; ImGui::PushID

; 9421 :     PushMultiItemsWidths(components);

	mov	edi, DWORD PTR _components$[ebp]
	mov	DWORD PTR [esp], 0
	push	edi
	call	?PushMultiItemsWidths@@YAXHM@Z		; PushMultiItemsWidths
	add	esp, 8

; 9422 :     for (int i = 0; i < components; i++)

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN3@InputIntN

; 9416 : 
; 9417 :     ImGuiContext& g = *GImGui;

	mov	edi, DWORD PTR _v$[ebp]
	npad	7
$LL4@InputIntN:

; 9423 :     {
; 9424 :         PushID(i);

	push	esi
	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID

; 9425 :         value_changed |= InputInt("##v", &v[i], 0, 0, extra_flags);

	push	DWORD PTR _extra_flags$[ebp]
	push	0
	push	0
	push	edi
	push	OFFSET $SG121776
	call	?InputInt@ImGui@@YA_NPBDPAHHHH@Z	; ImGui::InputInt
	or	bl, al

; 9426 :         SameLine(0, g.Style.ItemInnerSpacing.x);

	add	esp, 16					; 00000010H
	mov	eax, DWORD PTR _g$1$[ebp]
	movss	xmm0, DWORD PTR [eax+5376]
	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	add	esp, 8

; 9427 :         PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 9428 :         PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth
	inc	esi
	add	edi, 4
	cmp	esi, DWORD PTR _components$[ebp]
	jl	SHORT $LL4@InputIntN
$LN3@InputIntN:

; 9429 :     }
; 9430 :     PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID
	mov	eax, DWORD PTR _g$1$[ebp]

; 9431 : 
; 9432 :     window->DC.CurrentLineTextBaseOffset = ImMax(window->DC.CurrentLineTextBaseOffset, g.Style.FramePadding.y);
; 9433 :     TextUnformatted(label, FindRenderedTextEnd(label));

	mov	esi, DWORD PTR _label$[ebp]
	push	0
	push	esi
	movss	xmm0, DWORD PTR [eax+5360]
	mov	eax, DWORD PTR _window$1$[ebp]
	maxss	xmm0, DWORD PTR [eax+228]
	movss	DWORD PTR [eax+228], xmm0
	call	?FindRenderedTextEnd@ImGui@@YAPBDPBD0@Z	; ImGui::FindRenderedTextEnd
	push	eax
	push	esi
	call	?TextUnformatted@ImGui@@YAXPBD0@Z	; ImGui::TextUnformatted
	add	esp, 16					; 00000010H

; 9434 :     EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup
	pop	edi
	pop	esi

; 9435 : 
; 9436 :     return value_changed;

	mov	al, bl
	pop	ebx

; 9437 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InputIntN@ImGui@@YA_NPBDPAHHH@Z ENDP			; ImGui::InputIntN
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_window$1$ = -8						; size = 4
_g$1$ = -4						; size = 4
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_components$ = 16					; size = 4
_decimal_precision$ = 20				; size = 4
_extra_flags$ = 24					; size = 4
?InputFloatN@ImGui@@YA_NPBDPAMHHH@Z PROC		; ImGui::InputFloatN

; 9369 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	eax, DWORD PTR [ecx+6240]
	mov	DWORD PTR _window$1$[ebp], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9371 :     if (window->SkipItems)

	cmp	BYTE PTR [eax+137], 0
	je	SHORT $LN5@InputFloat

; 9372 :         return false;

	xor	al, al

; 9394 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@InputFloat:

; 9373 : 
; 9374 :     ImGuiContext& g = *GImGui;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _g$1$[ebp], eax

; 9375 :     bool value_changed = false;

	xor	bl, bl

; 9376 :     BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup

; 9377 :     PushID(label);

	push	DWORD PTR _label$[ebp]
	call	?PushID@ImGui@@YAXPBD@Z			; ImGui::PushID

; 9378 :     PushMultiItemsWidths(components);

	mov	edi, DWORD PTR _components$[ebp]
	mov	DWORD PTR [esp], 0
	push	edi
	call	?PushMultiItemsWidths@@YAXHM@Z		; PushMultiItemsWidths
	add	esp, 8

; 9379 :     for (int i = 0; i < components; i++)

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN3@InputFloat

; 9373 : 
; 9374 :     ImGuiContext& g = *GImGui;

	mov	edi, DWORD PTR _v$[ebp]
	npad	7
$LL4@InputFloat:

; 9380 :     {
; 9381 :         PushID(i);

	push	esi
	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID
	add	esp, 4

; 9382 :         value_changed |= InputFloat("##v", &v[i], 0, 0, decimal_precision, extra_flags);

	push	DWORD PTR _extra_flags$[ebp]
	push	DWORD PTR _decimal_precision$[ebp]
	sub	esp, 8
	mov	DWORD PTR [esp+4], 0
	mov	DWORD PTR [esp], 0
	push	edi
	push	OFFSET $SG121743
	call	?InputFloat@ImGui@@YA_NPBDPAMMMHH@Z	; ImGui::InputFloat
	or	bl, al

; 9383 :         SameLine(0, g.Style.ItemInnerSpacing.x);

	add	esp, 16					; 00000010H
	mov	eax, DWORD PTR _g$1$[ebp]
	movss	xmm0, DWORD PTR [eax+5376]
	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	add	esp, 8

; 9384 :         PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 9385 :         PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth
	inc	esi
	add	edi, 4
	cmp	esi, DWORD PTR _components$[ebp]
	jl	SHORT $LL4@InputFloat
$LN3@InputFloat:

; 9386 :     }
; 9387 :     PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID
	mov	eax, DWORD PTR _g$1$[ebp]

; 9388 : 
; 9389 :     window->DC.CurrentLineTextBaseOffset = ImMax(window->DC.CurrentLineTextBaseOffset, g.Style.FramePadding.y);
; 9390 :     TextUnformatted(label, FindRenderedTextEnd(label));

	mov	esi, DWORD PTR _label$[ebp]
	push	0
	push	esi
	movss	xmm0, DWORD PTR [eax+5360]
	mov	eax, DWORD PTR _window$1$[ebp]
	maxss	xmm0, DWORD PTR [eax+228]
	movss	DWORD PTR [eax+228], xmm0
	call	?FindRenderedTextEnd@ImGui@@YAPBDPBD0@Z	; ImGui::FindRenderedTextEnd
	push	eax
	push	esi
	call	?TextUnformatted@ImGui@@YAXPBD0@Z	; ImGui::TextUnformatted
	add	esp, 16					; 00000010H

; 9391 :     EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup
	pop	edi
	pop	esi

; 9392 : 
; 9393 :     return value_changed;

	mov	al, bl
	pop	ebx

; 9394 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InputFloatN@ImGui@@YA_NPBDPAMHHH@Z ENDP		; ImGui::InputFloatN
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_cursor_screen_rect$14 = -236				; size = 16
_callback_data$15 = -220				; size = 48
$T16 = -172						; size = 8
_label_size$ = -172					; size = 8
$T17 = -164						; size = 8
$T18 = -164						; size = 8
_select_start_offset$2$sroa$1431$1$ = -160		; size = 4
_frame_bb$ = -156					; size = 16
_clip_rect$ = -140					; size = 16
tv2797 = -124						; size = 4
_cursor_rect$19 = -120					; size = 16
_total_bb$ = -120					; size = 16
_render_pos$ = -104					; size = 8
_bg_offy_dn$1$ = -96					; size = 4
_searches_input_ptr$3$sroa$1437$1$ = -96		; size = 4
_bg_offy_up$1$ = -92					; size = 4
tv3317 = -92						; size = 4
tv2915 = -92						; size = 4
_text_size$$sroa$1442$1$ = -88				; size = 4
_ib$1$ = -88						; size = 4
tv3226 = -81						; size = 1
_bg_color$1$ = -80					; size = 4
_text_begin$1$ = -80					; size = 4
_searches_input_ptr$3$sroa$1436$1$ = -76		; size = 4
_text_selected_end$1$ = -76				; size = 4
_buf_end$20 = -76					; size = 4
$T21 = -72						; size = 8
$T22 = -72						; size = 8
$T23 = -72						; size = 8
$T24 = -72						; size = 8
$T25 = -72						; size = 8
_size$ = -72						; size = 8
_render_scroll$7$sroa$1428$1$ = -64			; size = 4
_size$1$ = -64						; size = 4
_draw_window$1$ = -60					; size = 4
$T26 = -56						; size = 8
$T27 = -56						; size = 8
$T28 = -56						; size = 8
$T29 = -56						; size = 8
$T30 = -56						; size = 8
$T31 = -56						; size = 8
_cursor_screen_pos$12$sroa$1412$1$ = -52		; size = 4
_cursor_offset$5$sroa$1433$1$ = -52			; size = 4
_utf8_selection_start$1$ = -52				; size = 4
_prev_len_w$1$ = -52					; size = 4
tv3611 = -52						; size = 4
tv95 = -52						; size = 4
_cut$1$ = -45						; size = 1
tv3216 = -45						; size = 1
_rect_pos$9$sroa$1419$1$ = -44				; size = 4
_clipboard_filtered$1$ = -44				; size = 4
tv2867 = -44						; size = 4
_cursor_screen_pos$12$sroa$1944$1$ = -40		; size = 4
_g$1$ = -40						; size = 4
tv2793 = -36						; size = 4
_enter_pressed$1$ = -30					; size = 1
_focus_requested$1$ = -30				; size = 1
_is_shortcut_key_only$1$ = -29				; size = 1
_hovered$1$ = -29					; size = 1
tv2795 = -28						; size = 4
_searches_result_line_number$4$sroa$1268$2$ = -24	; size = 4
_event_key$1$ = -24					; size = 4
_window$1$ = -24					; size = 4
_p$32 = -24						; size = 4
_c$33 = -24						; size = 4
_text_size$$sroa$2013$1$ = -20				; size = 4
_clipboard_filtered_len$1$ = -20			; size = 4
_ie$1$ = -20						; size = 4
_c$34 = -20						; size = 4
_c$35 = -20						; size = 4
_c$36 = -20						; size = 4
_buf_end$37 = -20					; size = 4
_buf_end$38 = -20					; size = 4
_rect_size$39 = -16					; size = 8
_searches_result_line_number$4$sroa$885$2$ = -12	; size = 4
_id$ = -12						; size = 4
_value_changed$1$ = -5					; size = 1
_focus_requested_by_code$1$ = -5			; size = 1
_is_wordmove_key_down$1$ = -4				; size = 1
_user_clicked$1$ = -4					; size = 1
_is_startend_key_down$1$ = -3				; size = 1
_focus_requested_by_tab$1$ = -3				; size = 1
_cancel_edit$1$ = -2					; size = 1
_clear_active_id$1$ = -1				; size = 1
_label$ = 8						; size = 4
_buf$ = 12						; size = 4
_buf_size$ = 16						; size = 4
_size_arg$ = 20						; size = 4
_flags$ = 24						; size = 4
_callback$ = 28						; size = 4
_user_data$ = 32					; size = 4
?InputTextEx@ImGui@@YA_NPBDPADHABUImVec2@@HP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z PROC ; ImGui::InputTextEx

; 8698 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 236				; 000000ecH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	ebx
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	ebx, DWORD PTR [ecx+6240]
	mov	DWORD PTR _window$1$[ebp], ebx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8700 :     if (window->SkipItems)

	cmp	BYTE PTR [ebx+137], 0
	je	SHORT $LN16@InputTextE

; 8701 :         return false;

	xor	al, al
	pop	ebx

; 9278 :         return enter_pressed;
; 9279 :     else
; 9280 :         return value_changed;
; 9281 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@InputTextE:

; 8702 : 
; 8703 :     IM_ASSERT(!((flags & ImGuiInputTextFlags_CallbackHistory) && (flags & ImGuiInputTextFlags_Multiline))); // Can't use both together (they both use up/down keys)
; 8704 :     IM_ASSERT(!((flags & ImGuiInputTextFlags_CallbackCompletion) && (flags & ImGuiInputTextFlags_AllowTabInput))); // Can't use both together (they both use tab key)
; 8705 : 
; 8706 :     ImGuiContext& g = *GImGui;
; 8707 :     const ImGuiIO& io = g.IO;
; 8708 :     const ImGuiStyle& style = g.Style;
; 8709 : 
; 8710 :     const bool is_multiline = (flags & ImGuiInputTextFlags_Multiline) != 0;

	mov	ecx, DWORD PTR _flags$[ebp]
	mov	eax, ecx

; 8711 :     const bool is_editable = (flags & ImGuiInputTextFlags_ReadOnly) == 0;

	mov	edx, ecx
	shr	eax, 20					; 00000014H
	shr	edx, 14					; 0000000eH
	and	eax, -255				; ffffff01H

; 8712 :     const bool is_password = (flags & ImGuiInputTextFlags_Password) != 0;

	shr	ecx, 15					; 0000000fH
	not	dl
	and	edx, -255				; ffffff01H
	mov	DWORD PTR tv2793[ebp], eax
	and	ecx, -255				; ffffff01H
	mov	DWORD PTR tv2795[ebp], edx
	mov	DWORD PTR tv2797[ebp], ecx
	push	edi
	mov	edi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	DWORD PTR _g$1$[ebp], edi

; 8713 : 
; 8714 :     if (is_multiline) // Open group before calling GetID() because groups tracks id created during their spawn

	test	al, al
	je	SHORT $LN17@InputTextE

; 8715 :         BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup
$LN17@InputTextE:
	push	esi

; 8716 :     const ImGuiID id = window->GetID(label);

	mov	esi, DWORD PTR _label$[ebp]
	mov	ecx, ebx
	push	0
	push	esi
	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID

; 8717 :     const ImVec2 label_size = CalcTextSize(label, NULL, true);

	movss	xmm0, DWORD PTR __real@bf800000
	push	ecx
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	push	1
	push	0
	mov	DWORD PTR _id$[ebp], eax
	lea	eax, DWORD PTR _label_size$[ebp]
	push	esi
	push	eax
	movss	DWORD PTR _bg_offy_up$1$[ebp], xmm0
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
	add	esp, 20					; 00000014H

; 8718 :     ImVec2 size = CalcItemSize(size_arg, CalcItemWidth(), (is_multiline ? GetTextLineHeight() * 8.0f : label_size.y) + style.FramePadding.y*2.0f); // Arbitrary default of 8 lines high for multi-line

	cmp	BYTE PTR tv2793[ebp], 0
	je	SHORT $LN172@InputTextE
	call	?GetTextLineHeight@ImGui@@YAMXZ		; ImGui::GetTextLineHeight
	fmul	DWORD PTR __real@41000000
	fstp	DWORD PTR tv95[ebp]
	movss	xmm1, DWORD PTR tv95[ebp]
	jmp	SHORT $LN173@InputTextE
$LN172@InputTextE:
	movss	xmm1, DWORD PTR _label_size$[ebp+4]
$LN173@InputTextE:
	movss	xmm0, DWORD PTR [edi+5360]
	addss	xmm0, xmm0
	push	ecx
	addss	xmm0, xmm1
	movss	DWORD PTR [esp], xmm0
	call	?CalcItemWidth@ImGui@@YAMXZ		; ImGui::CalcItemWidth
	mov	eax, DWORD PTR _size_arg$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	call	?CalcItemSize@ImGui@@YA?AUImVec2@@U2@MM@Z ; ImGui::CalcItemSize
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR _size$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8718 :     ImVec2 size = CalcItemSize(size_arg, CalcItemWidth(), (is_multiline ? GetTextLineHeight() * 8.0f : label_size.y) + style.FramePadding.y*2.0f); // Arbitrary default of 8 lines high for multi-line

	add	esp, 20					; 00000014H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm1, DWORD PTR [ebx+192]
	movss	xmm2, DWORD PTR [ebx+196]
	addss	xmm1, xmm0
	addss	xmm2, DWORD PTR _size$[ebp+4]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [ebx+192]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8720 :     const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? (style.ItemInnerSpacing.x + label_size.x) : 0.0f, 0.0f));

	movss	xmm3, DWORD PTR _label_size$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _frame_bb$[ebp], eax
	mov	eax, DWORD PTR [ebx+196]
	mov	DWORD PTR _frame_bb$[ebp+4], eax

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	DWORD PTR _size$1$[ebp], xmm0
	xorps	xmm0, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8720 :     const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? (style.ItemInnerSpacing.x + label_size.x) : 0.0f, 0.0f));

	comiss	xmm3, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T31[ebp], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T31[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T31[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _frame_bb$[ebp+8], eax
	mov	eax, DWORD PTR $T31[ebp+4]
	mov	DWORD PTR _frame_bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8720 :     const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? (style.ItemInnerSpacing.x + label_size.x) : 0.0f, 0.0f));

	jbe	SHORT $LN174@InputTextE
	movss	xmm0, DWORD PTR [edi+5376]
	addss	xmm0, xmm3
$LN174@InputTextE:

; 8723 :     if (is_multiline)

	cmp	BYTE PTR tv2793[ebp], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm1

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [ebx+192]
	mov	DWORD PTR _total_bb$[ebp], eax
	mov	eax, DWORD PTR [ebx+196]
	mov	DWORD PTR _total_bb$[ebp+4], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T30[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T30[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T30[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _total_bb$[ebp+8], eax
	mov	eax, DWORD PTR $T30[ebp+4]
	mov	DWORD PTR _total_bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8722 :     ImGuiWindow* draw_window = window;

	mov	DWORD PTR _draw_window$1$[ebp], ebx

; 8723 :     if (is_multiline)

	je	SHORT $LN18@InputTextE
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 245  :     ImVec2      GetSize() const                 { return ImVec2(Max.x-Min.x, Max.y-Min.y); }

	subss	xmm1, DWORD PTR _frame_bb$[ebp]
	subss	xmm2, DWORD PTR _frame_bb$[ebp+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8725 :         if (!BeginChildFrame(id, frame_bb.GetSize()))

	push	0
	lea	eax, DWORD PTR $T29[ebp]
	push	eax
	push	DWORD PTR _id$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T29[ebp], xmm1
	movss	DWORD PTR $T29[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8725 :         if (!BeginChildFrame(id, frame_bb.GetSize()))

	call	?BeginChildFrame@ImGui@@YA_NIABUImVec2@@H@Z ; ImGui::BeginChildFrame
	add	esp, 12					; 0000000cH
	test	al, al
	jne	SHORT $LN20@InputTextE

; 8726 :         {
; 8727 :             EndChildFrame();

	call	?EndChildFrame@ImGui@@YAXXZ		; ImGui::EndChildFrame

; 8728 :             EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup
$LN514@InputTextE:

; 8729 :             return false;

	pop	esi
	pop	edi
	xor	al, al
	pop	ebx

; 9278 :         return enter_pressed;
; 9279 :     else
; 9280 :         return value_changed;
; 9281 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN20@InputTextE:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8732 :         size.x -= draw_window->ScrollbarSizes.x;

	movss	xmm0, DWORD PTR _size$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	ebx, DWORD PTR [ecx+6240]
	mov	DWORD PTR _draw_window$1$[ebp], ebx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8732 :         size.x -= draw_window->ScrollbarSizes.x;

	subss	xmm0, DWORD PTR [ebx+120]
	movss	DWORD PTR _size$1$[ebp], xmm0

; 8733 :     }
; 8734 :     else

	jmp	SHORT $LN466@InputTextE
$LN18@InputTextE:

; 8735 :     {
; 8736 :         ItemSize(total_bb, style.FramePadding.y);

	movss	xmm0, DWORD PTR [edi+5360]
	lea	eax, DWORD PTR _total_bb$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	eax
	call	?ItemSize@ImGui@@YAXABUImRect@@M@Z	; ImGui::ItemSize

; 8737 :         if (!ItemAdd(total_bb, &id, &frame_bb))

	lea	eax, DWORD PTR _frame_bb$[ebp]
	push	eax
	lea	eax, DWORD PTR _id$[ebp]
	push	eax
	lea	eax, DWORD PTR _total_bb$[ebp]
	push	eax
	call	?ItemAdd@ImGui@@YA_NABUImRect@@PBIPBU2@@Z ; ImGui::ItemAdd
	add	esp, 20					; 00000014H
	test	al, al
	je	SHORT $LN514@InputTextE
$LN466@InputTextE:

; 8738 :             return false;
; 8739 :     }
; 8740 : 
; 8741 :     // Password pushes a temporary font with only a fallback glyph
; 8742 :     if (is_password)

	cmp	BYTE PTR tv2797[ebp], 0
	je	SHORT $LN22@InputTextE

; 8743 :     {
; 8744 :         const ImFont::Glyph* glyph = g.Font->FindGlyph('*');

	mov	ecx, DWORD PTR [edi+6168]
	push	42					; 0000002aH
	call	?FindGlyph@ImFont@@QBEPBUGlyph@1@G@Z	; ImFont::FindGlyph

; 8745 :         ImFont* password_font = &g.InputTextPasswordFont;
; 8746 :         password_font->FontSize = g.Font->FontSize;

	mov	ecx, DWORD PTR [edi+6168]
	lea	esi, DWORD PTR [edi+10416]
	mov	edx, eax

; 8747 :         password_font->Scale = g.Font->Scale;
; 8748 :         password_font->DisplayOffset = g.Font->DisplayOffset;
; 8749 :         password_font->Ascent = g.Font->Ascent;
; 8750 :         password_font->Descent = g.Font->Descent;
; 8751 :         password_font->ContainerAtlas = g.Font->ContainerAtlas;
; 8752 :         password_font->FallbackGlyph = glyph;
; 8753 :         password_font->FallbackXAdvance = glyph->XAdvance;
; 8754 :         IM_ASSERT(password_font->Glyphs.empty() && password_font->IndexXAdvance.empty() && password_font->IndexLookup.empty());
; 8755 :         PushFont(password_font);

	push	esi
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [esi], ecx
	mov	ecx, DWORD PTR [edi+6168]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], ecx
	mov	ecx, DWORD PTR [edi+6168]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [edi+6168]
	mov	eax, DWORD PTR [eax+72]
	mov	DWORD PTR [esi+72], eax
	mov	eax, DWORD PTR [edi+6168]
	mov	eax, DWORD PTR [eax+76]
	mov	DWORD PTR [esi+76], eax
	mov	eax, DWORD PTR [edi+6168]
	mov	eax, DWORD PTR [eax+68]
	mov	DWORD PTR [esi+68], eax
	mov	DWORD PTR [esi+52], edx
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+56], eax
	call	?PushFont@ImGui@@YAXPAUImFont@@@Z	; ImGui::PushFont
	add	esp, 4
$LN22@InputTextE:

; 8756 :     }
; 8757 : 
; 8758 :     // NB: we are only allowed to access 'edit_state' if we are the active widget.
; 8759 :     ImGuiTextEditState& edit_state = g.InputTextState;
; 8760 : 
; 8761 :     const bool focus_requested = FocusableItemRegister(window, id, (flags & (ImGuiInputTextFlags_CallbackCompletion|ImGuiInputTextFlags_AllowTabInput)) == 0);    // Using completion callback disable keyboard tabbing

	test	DWORD PTR _flags$[ebp], 1088		; 00000440H
	lea	ebx, DWORD PTR [edi+7132]
	mov	esi, DWORD PTR _id$[ebp]
	sete	al
	movzx	eax, al
	push	eax
	push	esi
	push	DWORD PTR _window$1$[ebp]
	call	?FocusableItemRegister@ImGui@@YA_NPAUImGuiWindow@@I_N@Z ; ImGui::FocusableItemRegister
	mov	dl, al
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _focus_requested$1$[ebp], dl

; 8762 :     const bool focus_requested_by_code = focus_requested && (window->FocusIdxAllCounter == window->FocusIdxAllRequestCurrent);

	test	dl, dl
	je	SHORT $LN176@InputTextE
	mov	eax, DWORD PTR _window$1$[ebp]
	mov	ecx, DWORD PTR [eax+644]
	cmp	ecx, DWORD PTR [eax+652]
	jne	SHORT $LN176@InputTextE
	mov	al, 1
	jmp	SHORT $LN501@InputTextE
$LN176@InputTextE:
	xor	al, al
$LN501@InputTextE:
	mov	BYTE PTR _focus_requested_by_code$1$[ebp], al

; 8763 :     const bool focus_requested_by_tab = focus_requested && !focus_requested_by_code;

	test	dl, dl
	je	SHORT $LN178@InputTextE
	mov	BYTE PTR _focus_requested_by_tab$1$[ebp], 1
	test	al, al
	je	SHORT $LN179@InputTextE
$LN178@InputTextE:
	mov	BYTE PTR _focus_requested_by_tab$1$[ebp], 0
$LN179@InputTextE:

; 8764 : 
; 8765 :     const bool hovered = IsHovered(frame_bb, id);

	push	0
	lea	eax, DWORD PTR _frame_bb$[ebp]
	push	esi
	push	eax
	call	?IsHovered@ImGui@@YA_NABUImRect@@I_N@Z	; ImGui::IsHovered
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _hovered$1$[ebp], al

; 8766 :     if (hovered)

	test	al, al
	je	SHORT $LN180@InputTextE

; 8767 :     {
; 8768 :         SetHoveredID(id);

	push	esi
	call	?SetHoveredID@ImGui@@YAXI@Z		; ImGui::SetHoveredID
	add	esp, 4

; 8769 :         g.MouseCursor = ImGuiMouseCursor_TextInput;

	mov	DWORD PTR [edi+6764], 1

; 8770 :     }
; 8771 :     const bool user_clicked = hovered && io.MouseClicked[0];

	cmp	BYTE PTR [edi+888], 0
	mov	BYTE PTR _user_clicked$1$[ebp], 1
	jne	SHORT $LN181@InputTextE
$LN180@InputTextE:
	mov	BYTE PTR _user_clicked$1$[ebp], 0
$LN181@InputTextE:

; 8772 :     const bool user_scrolled = is_multiline && g.ActiveId == 0 && edit_state.Id == id && g.ActiveIdPreviousFrame == draw_window->GetIDNoKeepAlive("#SCROLLY");

	cmp	BYTE PTR tv2793[ebp], 0
	je	SHORT $LN182@InputTextE
	cmp	DWORD PTR [edi+6264], 0
	jne	SHORT $LN182@InputTextE
	mov	eax, DWORD PTR _id$[ebp]
	cmp	DWORD PTR [ebx], eax
	jne	SHORT $LN182@InputTextE
	mov	ecx, DWORD PTR _draw_window$1$[ebp]
	push	0
	push	OFFSET $SG121494
	call	?GetIDNoKeepAlive@ImGuiWindow@@QAEIPBD0@Z ; ImGuiWindow::GetIDNoKeepAlive
	cmp	DWORD PTR [edi+6268], eax
	jne	SHORT $LN182@InputTextE
	mov	al, 1
	jmp	SHORT $LN183@InputTextE
$LN182@InputTextE:
	xor	al, al
$LN183@InputTextE:

; 8773 : 
; 8774 :     bool clear_active_id = false;
; 8775 : 
; 8776 :     bool select_all = (g.ActiveId != id) && (((flags & ImGuiInputTextFlags_AutoSelectAll) != 0) || (g.NavInputId == id));

	mov	edx, DWORD PTR _id$[ebp]
	xor	cl, cl
	mov	BYTE PTR _clear_active_id$1$[ebp], cl
	mov	ecx, DWORD PTR [edi+6264]
	cmp	ecx, edx
	je	SHORT $LN185@InputTextE
	test	BYTE PTR _flags$[ebp], 16		; 00000010H
	jne	SHORT $LN184@InputTextE
	cmp	DWORD PTR [edi+6392], edx
	jne	SHORT $LN185@InputTextE
$LN184@InputTextE:
	mov	BYTE PTR tv2867[ebp], 1
	jmp	SHORT $LN186@InputTextE
$LN185@InputTextE:
	mov	BYTE PTR tv2867[ebp], 0
$LN186@InputTextE:

; 8777 :     if (focus_requested || user_clicked || user_scrolled || g.NavInputId == id)

	cmp	BYTE PTR _focus_requested$1$[ebp], 0
	jne	SHORT $LN26@InputTextE
	cmp	BYTE PTR _user_clicked$1$[ebp], 0
	jne	SHORT $LN26@InputTextE
	test	al, al
	jne	SHORT $LN26@InputTextE
	cmp	DWORD PTR [edi+6392], edx
	je	SHORT $LN26@InputTextE

; 8819 :     }
; 8820 :     else if (io.MouseClicked[0])

	cmp	BYTE PTR [edi+888], al
	je	$LN35@InputTextE

; 8821 :     {
; 8822 :         // Release focus when we click outside
; 8823 :         clear_active_id = true;

	mov	cl, 1
	mov	BYTE PTR _clear_active_id$1$[ebp], cl
	jmp	$LN35@InputTextE
$LN26@InputTextE:

; 8778 :     {
; 8779 :         if (g.ActiveId != id)

	cmp	ecx, edx
	je	$LN32@InputTextE

; 8780 :         {
; 8781 :             // Start edition
; 8782 :             // Take a copy of the initial buffer value (both in original UTF-8 format and converted to wchar)
; 8783 :             // From the moment we focused we are ignoring the content of 'buf' (unless we are in read-only mode)
; 8784 :             const int prev_len_w = edit_state.CurLenW;
; 8785 :             edit_state.Text.resize(buf_size+1);        // wchar count <= UTF-8 count. we use +1 to make sure that .Data isn't NULL so it doesn't crash.

	mov	edi, DWORD PTR _buf_size$[ebp]
	lea	ecx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [ebx+44]
	inc	edi
	push	edi
	mov	DWORD PTR _prev_len_w$1$[ebp], eax
	call	?resize@?$ImVector@G@@QAEXH@Z		; ImVector<unsigned short>::resize

; 8786 :             edit_state.InitialText.resize(buf_size+1); // UTF-8. we use +1 to make sure that .Data isn't NULL so it doesn't crash.

	mov	esi, DWORD PTR _g$1$[ebp]
	push	edi
	lea	ecx, DWORD PTR [esi+7148]
	call	?resize@?$ImVector@D@@QAEXH@Z		; ImVector<char>::resize

; 8787 :             ImStrncpy(edit_state.InitialText.Data, buf, edit_state.InitialText.Size);

	push	DWORD PTR [esi+7148]
	mov	edi, DWORD PTR _g$1$[ebp]
	mov	esi, DWORD PTR _buf$[ebp]
	push	esi
	push	DWORD PTR [edi+7156]
	call	?ImStrncpy@@YAXPADPBDH@Z		; ImStrncpy

; 8788 :             const char* buf_end = NULL;
; 8789 :             edit_state.CurLenW = ImTextStrFromUtf8(edit_state.Text.Data, edit_state.Text.Size, buf, NULL, &buf_end);

	lea	eax, DWORD PTR _buf_end$38[ebp]
	mov	DWORD PTR _buf_end$38[ebp], 0
	push	eax
	push	0
	push	esi
	push	DWORD PTR [ebx+4]
	lea	ebx, DWORD PTR [edi+7132]
	push	DWORD PTR [ebx+12]
	call	?ImTextStrFromUtf8@@YAHPAGHPBD1PAPBD@Z	; ImTextStrFromUtf8

; 8790 :             edit_state.CurLenA = (int)(buf_end - buf); // We can't get the result from ImFormatString() above because it is not UTF-8 aware. Here we'll cut off malformed UTF-8.

	mov	ecx, DWORD PTR _buf_end$38[ebp]
	add	esp, 32					; 00000020H
	sub	ecx, esi
	mov	DWORD PTR [ebx+44], eax
	mov	DWORD PTR [ebx+40], ecx

; 8795 :             const bool recycle_state = (edit_state.Id == id) && (prev_len_w == edit_state.CurLenW);

	mov	ecx, DWORD PTR _id$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 342  :     void                CursorAnimReset()           { CursorAnim = -0.30f; }                                   // After a user-input the cursor stays on for a while without blinking

	mov	DWORD PTR [ebx+3276], -1097229926	; be99999aH
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8795 :             const bool recycle_state = (edit_state.Id == id) && (prev_len_w == edit_state.CurLenW);

	cmp	DWORD PTR [ebx], ecx
	jne	SHORT $LN28@InputTextE
	cmp	DWORD PTR _prev_len_w$1$[ebp], eax
	jne	SHORT $LN28@InputTextE

; 8796 :             if (recycle_state)
; 8797 :             {
; 8798 :                 // Recycle existing cursor/selection/undo stack but clamp position
; 8799 :                 // Note a single mouse click will override the cursor/position immediately by calling stb_textedit_click handler.
; 8800 :                 edit_state.CursorClamp();

	mov	ecx, ebx
	call	?CursorClamp@ImGuiTextEditState@@QAEXXZ	; ImGuiTextEditState::CursorClamp

; 8801 :             }
; 8802 :             else

	mov	edx, DWORD PTR tv2793[ebp]
	jmp	SHORT $LN30@InputTextE
$LN28@InputTextE:

; 8803 :             {
; 8804 :                 edit_state.Id = id;
; 8805 :                 edit_state.ScrollX = 0.0f;
; 8806 :                 stb_textedit_initialize_state(&edit_state.StbState, !is_multiline);

	mov	edx, DWORD PTR tv2793[ebp]
	movzx	eax, dl
	xor	eax, 1
	mov	DWORD PTR [ebx], ecx
	push	eax
	lea	eax, DWORD PTR [ebx+56]
	mov	DWORD PTR [ebx+52], 0
	push	eax
	call	?stb_textedit_initialize_state@ImGuiStb@@YAXPAUSTB_TexteditState@1@H@Z ; ImGuiStb::stb_textedit_initialize_state
	add	esp, 8

; 8807 :                 if (!is_multiline && focus_requested_by_code)

	test	dl, dl
	jne	SHORT $LN30@InputTextE
	mov	eax, DWORD PTR tv2867[ebp]
	mov	ecx, 1
	cmp	BYTE PTR _focus_requested_by_code$1$[ebp], dl
	movzx	eax, al
	cmovne	eax, ecx
	mov	DWORD PTR tv2867[ebp], eax
$LN30@InputTextE:

; 8808 :                     select_all = true;
; 8809 :             }
; 8810 :             if (flags & ImGuiInputTextFlags_AlwaysInsertMode)

	test	DWORD PTR _flags$[ebp], 8192		; 00002000H
	je	SHORT $LN31@InputTextE

; 8811 :                 edit_state.StbState.insert_mode = true;

	mov	BYTE PTR [ebx+68], 1
$LN31@InputTextE:

; 8812 :             if (!is_multiline && (focus_requested_by_tab || (user_clicked && io.KeyCtrl)))

	test	dl, dl
	jne	SHORT $LN32@InputTextE
	cmp	BYTE PTR _focus_requested_by_tab$1$[ebp], dl
	jne	SHORT $LN33@InputTextE
	cmp	BYTE PTR _user_clicked$1$[ebp], dl
	je	SHORT $LN32@InputTextE
	cmp	BYTE PTR [edi+229], dl
	je	SHORT $LN32@InputTextE
$LN33@InputTextE:

; 8813 :                 select_all = true;

	mov	BYTE PTR tv2867[ebp], 1
$LN32@InputTextE:

; 8814 :         }
; 8815 :         SetActiveID(id, window);

	mov	esi, DWORD PTR _window$1$[ebp]
	push	esi
	push	DWORD PTR _id$[ebp]
	call	?SetActiveID@ImGui@@YAXIPAUImGuiWindow@@@Z ; ImGui::SetActiveID
	add	esp, 8

; 8816 :         if (!is_multiline)

	cmp	BYTE PTR tv2793[ebp], 0
	jne	SHORT $LN34@InputTextE

; 8817 :             g.ActiveIdAllowNavDirFlags = ((1 << ImGuiNavDir_Up) | (1 << ImGuiNavDir_Down));

	mov	DWORD PTR [edi+6276], 12		; 0000000cH
$LN34@InputTextE:

; 8818 :         FocusWindow(window);

	push	esi
	call	?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusWindow
	mov	edx, DWORD PTR _id$[ebp]
	add	esp, 4
$LN35@InputTextE:

; 8824 :     }
; 8825 : 
; 8826 :     bool value_changed = false;

	mov	BYTE PTR _value_changed$1$[ebp], 0

; 8827 :     bool enter_pressed = false;

	mov	BYTE PTR _enter_pressed$1$[ebp], 0

; 8828 : 
; 8829 :     if (g.ActiveId == id)

	cmp	DWORD PTR [edi+6264], edx
	jne	$LN48@InputTextE

; 8830 :     {
; 8831 :         if (!is_editable && !g.ActiveIdIsJustActivated)

	cmp	BYTE PTR tv2795[ebp], 0
	jne	SHORT $LN37@InputTextE
	cmp	BYTE PTR [edi+6273], 0
	jne	SHORT $LN37@InputTextE

; 8832 :         {
; 8833 :             // When read-only we always use the live data passed to the function
; 8834 :             edit_state.Text.resize(buf_size+1);

	mov	eax, DWORD PTR _buf_size$[ebp]
	lea	ecx, DWORD PTR [ebx+4]
	inc	eax
	push	eax
	call	?resize@?$ImVector@G@@QAEXH@Z		; ImVector<unsigned short>::resize

; 8835 :             const char* buf_end = NULL;
; 8836 :             edit_state.CurLenW = ImTextStrFromUtf8(edit_state.Text.Data, edit_state.Text.Size, buf, NULL, &buf_end);

	lea	eax, DWORD PTR _buf_end$37[ebp]
	mov	DWORD PTR _buf_end$37[ebp], 0
	push	eax
	push	0
	push	DWORD PTR _buf$[ebp]
	push	DWORD PTR [ebx+4]
	push	DWORD PTR [ebx+12]
	call	?ImTextStrFromUtf8@@YAHPAGHPBD1PAPBD@Z	; ImTextStrFromUtf8
	mov	DWORD PTR [ebx+44], eax
	add	esp, 20					; 00000014H

; 8837 :             edit_state.CurLenA = (int)(buf_end - buf);

	mov	eax, DWORD PTR _buf_end$37[ebp]

; 8838 :             edit_state.CursorClamp();

	mov	ecx, ebx
	sub	eax, DWORD PTR _buf$[ebp]
	mov	DWORD PTR [ebx+40], eax
	call	?CursorClamp@ImGuiTextEditState@@QAEXXZ	; ImGuiTextEditState::CursorClamp
$LN37@InputTextE:

; 8839 :         }
; 8840 : 
; 8841 :         edit_state.BufSizeA = buf_size;

	mov	eax, DWORD PTR _buf_size$[ebp]
	mov	DWORD PTR [ebx+48], eax

; 8842 : 
; 8843 :         // Although we are active we don't prevent mouse from hovering other elements unless we are interacting right now with the widget.
; 8844 :         // Down the line we should have a cleaner library-wide concept of Selected vs Active.
; 8845 :         g.ActiveIdAllowOverlap = !io.MouseDown[0];

	cmp	BYTE PTR [edi+216], 0
	sete	al

; 8846 : 
; 8847 :         // Edit in progress
; 8848 :         const float mouse_x = (io.MousePos.x - frame_bb.Min.x - style.FramePadding.x) + edit_state.ScrollX;
; 8849 :         const float mouse_y = (is_multiline ? (io.MousePos.y - draw_window->DC.CursorPos.y - style.FramePadding.y) : (g.FontSize*0.5f));

	cmp	BYTE PTR tv2793[ebp], 0
	mov	BYTE PTR [edi+6274], al
	movss	xmm2, DWORD PTR [edi+208]
	subss	xmm2, DWORD PTR _frame_bb$[ebp]
	subss	xmm2, DWORD PTR [edi+5356]
	addss	xmm2, DWORD PTR [ebx+52]
	je	SHORT $LN189@InputTextE
	mov	eax, DWORD PTR _draw_window$1$[ebp]
	movss	xmm1, DWORD PTR [edi+212]
	subss	xmm1, DWORD PTR [eax+196]
	subss	xmm1, DWORD PTR [edi+5360]
	jmp	SHORT $LN190@InputTextE
$LN189@InputTextE:
	movss	xmm1, DWORD PTR [edi+6172]
	mulss	xmm1, DWORD PTR __real@3f000000
$LN190@InputTextE:

; 8850 : 
; 8851 :         const bool osx_double_click_selects_words = io.OSXBehaviors;      // OS X style: Double click selects by word instead of selecting whole text
; 8852 :         if (select_all || (hovered && !osx_double_click_selects_words && io.MouseDoubleClicked[0]))

	cmp	BYTE PTR tv2867[ebp], 0
	mov	al, BYTE PTR [edi+172]
	jne	$LN40@InputTextE
	cmp	BYTE PTR _hovered$1$[ebp], 0
	je	SHORT $LN41@InputTextE
	test	al, al
	jne	SHORT $LN458@InputTextE
	cmp	BYTE PTR [edi+956], al
	jne	$LN40@InputTextE
$LN41@InputTextE:

; 8862 :         }
; 8863 :         else if (io.MouseClicked[0] && !edit_state.SelectedAllMouseLock)

	cmp	BYTE PTR [edi+888], 0
	je	SHORT $LN43@InputTextE
	cmp	BYTE PTR [ebx+3281], 0
	jne	SHORT $LN43@InputTextE

; 8864 :         {
; 8865 :             stb_textedit_click(&edit_state, &edit_state.StbState, mouse_x, mouse_y);

	sub	esp, 8
	lea	eax, DWORD PTR [ebx+56]
	movss	DWORD PTR [esp+4], xmm1
	movss	DWORD PTR [esp], xmm2
	push	eax
	push	ebx
	call	?stb_textedit_click@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@MM@Z ; ImGuiStb::stb_textedit_click
	add	esp, 16					; 00000010H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 342  :     void                CursorAnimReset()           { CursorAnim = -0.30f; }                                   // After a user-input the cursor stays on for a while without blinking

	mov	DWORD PTR [ebx+3276], -1097229926	; be99999aH
	jmp	$LN45@InputTextE
$LN458@InputTextE:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8857 :         else if (hovered && osx_double_click_selects_words && io.MouseDoubleClicked[0])

	cmp	BYTE PTR [edi+956], 0
	je	SHORT $LN41@InputTextE

; 8858 :         {
; 8859 :             // Select a word only, OS X style (by simulating keystrokes)
; 8860 :             edit_state.OnKeyPressed(STB_TEXTEDIT_K_WORDLEFT);

	push	65548					; 0001000cH
	mov	ecx, ebx
	call	?OnKeyPressed@ImGuiTextEditState@@QAEXH@Z ; ImGuiTextEditState::OnKeyPressed

; 8861 :             edit_state.OnKeyPressed(STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT);

	push	196621					; 0003000dH
	mov	ecx, ebx
	call	?OnKeyPressed@ImGuiTextEditState@@QAEXH@Z ; ImGuiTextEditState::OnKeyPressed
	jmp	$LN45@InputTextE
$LN43@InputTextE:

; 8866 :             edit_state.CursorAnimReset();
; 8867 :         }
; 8868 :         else if (io.MouseDown[0] && !edit_state.SelectedAllMouseLock && (io.MouseDelta.x != 0.0f || io.MouseDelta.y != 0.0f))

	cmp	BYTE PTR [edi+216], 0
	je	SHORT $LN45@InputTextE
	cmp	BYTE PTR [ebx+3281], 0
	jne	SHORT $LN503@InputTextE
	movss	xmm0, DWORD PTR [edi+872]
	xorps	xmm3, xmm3
	ucomiss	xmm0, xmm3
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN46@InputTextE
	movss	xmm0, DWORD PTR [edi+876]
	ucomiss	xmm0, xmm3
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN45@InputTextE
$LN46@InputTextE:

; 8869 :         {
; 8870 :             stb_textedit_drag(&edit_state, &edit_state.StbState, mouse_x, mouse_y);

	sub	esp, 8
	lea	eax, DWORD PTR [ebx+56]
	movss	DWORD PTR [esp+4], xmm1
	movss	DWORD PTR [esp], xmm2
	push	eax
	push	ebx
	call	?stb_textedit_drag@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@MM@Z ; ImGuiStb::stb_textedit_drag
	add	esp, 16					; 00000010H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 342  :     void                CursorAnimReset()           { CursorAnim = -0.30f; }                                   // After a user-input the cursor stays on for a while without blinking

	mov	DWORD PTR [ebx+3276], -1097229926	; be99999aH
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8872 :             edit_state.CursorFollow = true;

	mov	BYTE PTR [ebx+3280], 1
	jmp	SHORT $LN45@InputTextE
$LN40@InputTextE:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 346  :     void                SelectAll()                 { StbState.select_start = 0; StbState.select_end = CurLenW; StbState.cursor = StbState.select_end; StbState.has_preferred_x = false; }

	mov	eax, DWORD PTR [ebx+44]
	mov	DWORD PTR [ebx+60], 0
	mov	DWORD PTR [ebx+64], eax
	mov	DWORD PTR [ebx+56], eax
	mov	BYTE PTR [ebx+71], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8855 :             edit_state.SelectedAllMouseLock = true;

	mov	BYTE PTR [ebx+3281], 1
$LN45@InputTextE:

; 8873 :         }
; 8874 :         if (edit_state.SelectedAllMouseLock && !io.MouseDown[0])

	cmp	BYTE PTR [ebx+3281], 0
	je	SHORT $LN47@InputTextE
$LN503@InputTextE:
	cmp	BYTE PTR [edi+216], 0
	jne	SHORT $LN47@InputTextE

; 8875 :             edit_state.SelectedAllMouseLock = false;

	mov	BYTE PTR [ebx+3281], 0
$LN47@InputTextE:

; 8876 : 
; 8877 :         if (io.InputCharacters[0])

	cmp	WORD PTR [edi+746], 0
	lea	esi, DWORD PTR [edi+746]
	je	SHORT $LN490@InputTextE

; 8878 :         {
; 8879 :             // Process text input (before we check for Return because using some IME will effectively send a Return?)
; 8880 :             // We ignore CTRL inputs, but need to allow CTRL+ALT as some keyboards (e.g. German) use AltGR - which is Alt+Ctrl - to input certain characters.
; 8881 :             if (!(io.KeyCtrl && !io.KeyAlt) && is_editable)

	cmp	BYTE PTR [edi+229], 0
	je	SHORT $LN50@InputTextE
	cmp	BYTE PTR [edi+231], 0
	je	SHORT $LN3@InputTextE
$LN50@InputTextE:
	cmp	BYTE PTR tv2795[ebp], 0
	je	SHORT $LN3@InputTextE

; 8882 :             {
; 8883 :                 for (int n = 0; n < IM_ARRAYSIZE(io.InputCharacters) && io.InputCharacters[n]; n++)

	xor	edi, edi
$LL4@InputTextE:
	movzx	eax, WORD PTR [esi]
	test	ax, ax
	je	SHORT $LN471@InputTextE

; 8884 :                     if (unsigned int c = (unsigned int)io.InputCharacters[n])

	mov	DWORD PTR _c$36[ebp], eax
	test	eax, eax
	je	SHORT $LN2@InputTextE

; 8885 :                     {
; 8886 :                         // Insert character if they pass filtering
; 8887 :                         if (!InputTextFilterCharacter(&c, flags, callback, user_data))

	push	DWORD PTR _user_data$[ebp]
	lea	eax, DWORD PTR _c$36[ebp]
	push	DWORD PTR _callback$[ebp]
	push	DWORD PTR _flags$[ebp]
	push	eax
	call	?InputTextFilterCharacter@@YA_NPAIHP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ; InputTextFilterCharacter
	add	esp, 16					; 00000010H
	test	al, al
	je	SHORT $LN2@InputTextE

; 8888 :                             continue;
; 8889 :                         edit_state.OnKeyPressed((int)c);

	push	DWORD PTR _c$36[ebp]
	mov	ecx, ebx
	call	?OnKeyPressed@ImGuiTextEditState@@QAEXH@Z ; ImGuiTextEditState::OnKeyPressed
$LN2@InputTextE:

; 8882 :             {
; 8883 :                 for (int n = 0; n < IM_ARRAYSIZE(io.InputCharacters) && io.InputCharacters[n]; n++)

	inc	edi
	add	esi, 2
	cmp	edi, 17					; 00000011H
	jl	SHORT $LL4@InputTextE
$LN471@InputTextE:
	mov	edi, DWORD PTR _g$1$[ebp]
$LN3@InputTextE:
	xorps	xmm0, xmm0

; 8890 :                     }
; 8891 :             }
; 8892 : 
; 8893 :             // Consume characters
; 8894 :             memset(g.IO.InputCharacters, 0, sizeof(g.IO.InputCharacters));

	movups	XMMWORD PTR [edi+746], xmm0
	movups	XMMWORD PTR [edi+762], xmm0
	mov	WORD PTR [edi+778], 0
$LN490@InputTextE:
	mov	edx, DWORD PTR _id$[ebp]
$LN48@InputTextE:

; 8895 :         }
; 8896 :     }
; 8897 : 
; 8898 :     bool cancel_edit = false;
; 8899 :     if (g.ActiveId == id && !g.ActiveIdIsJustActivated && !clear_active_id)

	mov	cl, BYTE PTR _clear_active_id$1$[ebp]
	xor	al, al
	mov	BYTE PTR _cancel_edit$1$[ebp], al
	cmp	DWORD PTR [edi+6264], edx
	jne	$LN129@InputTextE
	cmp	BYTE PTR [edi+6273], al
	jne	$LN106@InputTextE
	test	cl, cl
	jne	$LN106@InputTextE

; 8900 :     {
; 8901 :         // Handle key-presses
; 8902 :         const int k_mask = (io.KeyShift ? STB_TEXTEDIT_K_SHIFT : 0);

	mov	al, BYTE PTR [edi+230]
	xor	esi, esi
	test	al, al
	mov	BYTE PTR tv3216[ebp], al
	mov	ecx, 131072				; 00020000H
	cmovne	esi, ecx

; 8903 :         const bool is_shortcut_key_only = (io.OSXBehaviors ? (io.KeySuper && !io.KeyCtrl) : (io.KeyCtrl && !io.KeySuper)) && !io.KeyAlt && !io.KeyShift; // OS X style: Shortcuts using Cmd/Super instead of Ctrl

	mov	cl, BYTE PTR [edi+172]
	mov	BYTE PTR tv3226[ebp], cl
	test	cl, cl
	je	SHORT $LN195@InputTextE
	cmp	BYTE PTR [edi+232], 0
	je	SHORT $LN197@InputTextE
	cmp	BYTE PTR [edi+229], 0
	je	SHORT $LN459@InputTextE
	jmp	SHORT $LN197@InputTextE
$LN195@InputTextE:
	cmp	BYTE PTR [edi+229], 0
	je	SHORT $LN197@InputTextE
	cmp	BYTE PTR [edi+232], 0
	jne	SHORT $LN197@InputTextE
$LN459@InputTextE:
	cmp	BYTE PTR [edi+231], 0
	jne	SHORT $LN197@InputTextE
	mov	BYTE PTR _is_shortcut_key_only$1$[ebp], 1
	test	al, al
	je	SHORT $LN198@InputTextE
$LN197@InputTextE:
	mov	BYTE PTR _is_shortcut_key_only$1$[ebp], 0
$LN198@InputTextE:

; 8904 :         const bool is_wordmove_key_down = io.OSXBehaviors ? io.KeyAlt : io.KeyCtrl;                     // OS X style: Text editing cursor movement using Alt instead of Ctrl

	test	cl, cl
	je	SHORT $LN199@InputTextE
	mov	al, BYTE PTR [edi+231]
	jmp	SHORT $LN504@InputTextE
$LN199@InputTextE:
	mov	al, BYTE PTR [edi+229]
$LN504@InputTextE:
	mov	BYTE PTR _is_wordmove_key_down$1$[ebp], al

; 8905 :         const bool is_startend_key_down = io.OSXBehaviors && io.KeySuper && !io.KeyCtrl && !io.KeyAlt;  // OS X style: Line/Text Start and End using Cmd+Arrows instead of Home/End

	test	cl, cl
	je	SHORT $LN201@InputTextE
	cmp	BYTE PTR [edi+232], 0
	je	SHORT $LN201@InputTextE
	cmp	BYTE PTR [edi+229], 0
	jne	SHORT $LN201@InputTextE
	cmp	BYTE PTR [edi+231], 0
	mov	BYTE PTR _is_startend_key_down$1$[ebp], 1
	je	SHORT $LN202@InputTextE
$LN201@InputTextE:
	mov	BYTE PTR _is_startend_key_down$1$[ebp], 0
$LN202@InputTextE:

; 8906 : 
; 8907 :         if (IsKeyPressedMap(ImGuiKey_LeftArrow))                        { edit_state.OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINESTART : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDLEFT : STB_TEXTEDIT_K_LEFT) | k_mask); }

	push	1
	push	3
	call	?IsKeyPressedMap@@YA_NH_N@Z		; IsKeyPressedMap
	add	esp, 8
	test	al, al
	je	SHORT $LN54@InputTextE
	cmp	BYTE PTR _is_startend_key_down$1$[ebp], 0
	je	SHORT $LN203@InputTextE
	mov	eax, 65540				; 00010004H

; 8908 :         else if (IsKeyPressedMap(ImGuiKey_RightArrow))                  { edit_state.OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINEEND : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDRIGHT : STB_TEXTEDIT_K_RIGHT) | k_mask); }

	mov	ecx, ebx
	or	eax, esi
	push	eax
	call	?OnKeyPressed@ImGuiTextEditState@@QAEXH@Z ; ImGuiTextEditState::OnKeyPressed
	jmp	$LN489@InputTextE
$LN203@InputTextE:

; 8906 : 
; 8907 :         if (IsKeyPressedMap(ImGuiKey_LeftArrow))                        { edit_state.OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINESTART : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDLEFT : STB_TEXTEDIT_K_LEFT) | k_mask); }

	mov	eax, 65536				; 00010000H
	lea	ecx, DWORD PTR [eax+12]
	jmp	SHORT $LN518@InputTextE
$LN54@InputTextE:

; 8908 :         else if (IsKeyPressedMap(ImGuiKey_RightArrow))                  { edit_state.OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINEEND : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDRIGHT : STB_TEXTEDIT_K_RIGHT) | k_mask); }

	push	1
	push	4
	call	?IsKeyPressedMap@@YA_NH_N@Z		; IsKeyPressedMap
	add	esp, 8
	test	al, al
	je	SHORT $LN56@InputTextE
	cmp	BYTE PTR _is_startend_key_down$1$[ebp], 0
	je	SHORT $LN205@InputTextE
	mov	eax, 65541				; 00010005H
	mov	ecx, ebx
	or	eax, esi
	push	eax
	call	?OnKeyPressed@ImGuiTextEditState@@QAEXH@Z ; ImGuiTextEditState::OnKeyPressed
	jmp	$LN489@InputTextE
$LN205@InputTextE:
	mov	eax, 65537				; 00010001H
	mov	ecx, 65549				; 0001000dH
$LN518@InputTextE:
	cmp	BYTE PTR _is_wordmove_key_down$1$[ebp], 0
	cmovne	eax, ecx
	mov	ecx, ebx
	or	eax, esi
	push	eax
	call	?OnKeyPressed@ImGuiTextEditState@@QAEXH@Z ; ImGuiTextEditState::OnKeyPressed
	jmp	$LN489@InputTextE
$LN56@InputTextE:

; 8909 :         else if (IsKeyPressedMap(ImGuiKey_UpArrow) && is_multiline)     { if (io.KeyCtrl) SetWindowScrollY(draw_window, ImMax(draw_window->Scroll.y - g.FontSize, 0.0f)); else edit_state.OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTSTART : STB_TEXTEDIT_K_UP) | k_mask); }

	push	1
	push	1
	call	?IsKeyPressedMap@@YA_NH_N@Z		; IsKeyPressedMap
	add	esp, 8
	test	al, al
	je	SHORT $LN58@InputTextE
	cmp	BYTE PTR tv2793[ebp], 0
	je	SHORT $LN58@InputTextE
	cmp	BYTE PTR [edi+229], 0
	je	SHORT $LN60@InputTextE
	mov	esi, DWORD PTR _draw_window$1$[ebp]
	push	ecx
	movss	xmm0, DWORD PTR [esi+96]
	subss	xmm0, DWORD PTR [edi+6172]
	maxss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR [esp], xmm0
	push	esi
	call	?SetWindowScrollY@@YAXPAUImGuiWindow@@M@Z ; SetWindowScrollY
	add	esp, 8
	jmp	$LN489@InputTextE
$LN60@InputTextE:
	xor	eax, eax
	mov	ecx, ebx
	cmp	BYTE PTR _is_startend_key_down$1$[ebp], al
	setne	al
	lea	eax, DWORD PTR [eax*4+65538]
	or	eax, esi
	push	eax
	call	?OnKeyPressed@ImGuiTextEditState@@QAEXH@Z ; ImGuiTextEditState::OnKeyPressed
	jmp	$LN489@InputTextE
$LN58@InputTextE:

; 8910 :         else if (IsKeyPressedMap(ImGuiKey_DownArrow) && is_multiline)   { if (io.KeyCtrl) SetWindowScrollY(draw_window, ImMin(draw_window->Scroll.y + g.FontSize, GetScrollMaxY())); else edit_state.OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTEND : STB_TEXTEDIT_K_DOWN) | k_mask); }

	push	1
	push	2
	call	?IsKeyPressedMap@@YA_NH_N@Z		; IsKeyPressedMap
	add	esp, 8
	test	al, al
	je	SHORT $LN62@InputTextE
	cmp	BYTE PTR tv2793[ebp], 0
	je	SHORT $LN62@InputTextE
	cmp	BYTE PTR [edi+229], 0
	je	SHORT $LN64@InputTextE
	call	?GetScrollMaxY@ImGui@@YAMXZ		; ImGui::GetScrollMaxY
	mov	eax, DWORD PTR _draw_window$1$[ebp]
	movss	xmm0, DWORD PTR [edi+6172]
	fstp	DWORD PTR tv3611[ebp]
	movss	xmm1, DWORD PTR tv3611[ebp]
	addss	xmm0, DWORD PTR [eax+96]
	push	ecx
	minss	xmm1, xmm0
	movss	DWORD PTR [esp], xmm1
	push	eax
	call	?SetWindowScrollY@@YAXPAUImGuiWindow@@M@Z ; SetWindowScrollY
	add	esp, 8
	jmp	$LN489@InputTextE
$LN64@InputTextE:
	xor	eax, eax
	mov	ecx, ebx
	cmp	BYTE PTR _is_startend_key_down$1$[ebp], al
	setne	al
	lea	eax, DWORD PTR [eax*4+65539]
	or	eax, esi
	push	eax
	call	?OnKeyPressed@ImGuiTextEditState@@QAEXH@Z ; ImGuiTextEditState::OnKeyPressed
	jmp	$LN489@InputTextE
$LN62@InputTextE:

; 8911 :         else if (IsKeyPressedMap(ImGuiKey_Home))                        { edit_state.OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTSTART | k_mask : STB_TEXTEDIT_K_LINESTART | k_mask); }

	push	1
	push	7
	call	?IsKeyPressedMap@@YA_NH_N@Z		; IsKeyPressedMap
	add	esp, 8
	test	al, al
	je	SHORT $LN66@InputTextE
	xor	eax, eax
	mov	ecx, ebx
	cmp	BYTE PTR [edi+229], al
	setne	al
	lea	eax, DWORD PTR [eax*2+65540]
	or	eax, esi
	push	eax
	call	?OnKeyPressed@ImGuiTextEditState@@QAEXH@Z ; ImGuiTextEditState::OnKeyPressed
	jmp	$LN489@InputTextE
$LN66@InputTextE:

; 8912 :         else if (IsKeyPressedMap(ImGuiKey_End))                         { edit_state.OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTEND | k_mask : STB_TEXTEDIT_K_LINEEND | k_mask); }

	push	1
	push	8
	call	?IsKeyPressedMap@@YA_NH_N@Z		; IsKeyPressedMap
	add	esp, 8
	test	al, al
	je	SHORT $LN68@InputTextE
	xor	eax, eax
	mov	ecx, ebx
	cmp	BYTE PTR [edi+229], al
	setne	al
	lea	eax, DWORD PTR [eax*2+65541]
	or	eax, esi
	push	eax
	call	?OnKeyPressed@ImGuiTextEditState@@QAEXH@Z ; ImGuiTextEditState::OnKeyPressed
	jmp	$LN489@InputTextE
$LN68@InputTextE:

; 8913 :         else if (IsKeyPressedMap(ImGuiKey_Delete) && is_editable)       { edit_state.OnKeyPressed(STB_TEXTEDIT_K_DELETE | k_mask); }

	push	1
	push	9
	call	?IsKeyPressedMap@@YA_NH_N@Z		; IsKeyPressedMap
	add	esp, 8
	test	al, al
	je	SHORT $LN70@InputTextE
	cmp	BYTE PTR tv2795[ebp], 0
	je	SHORT $LN70@InputTextE
	or	esi, 65544				; 00010008H
	mov	ecx, ebx
	push	esi
	call	?OnKeyPressed@ImGuiTextEditState@@QAEXH@Z ; ImGuiTextEditState::OnKeyPressed
	jmp	$LN489@InputTextE
$LN70@InputTextE:

; 8914 :         else if (IsKeyPressedMap(ImGuiKey_Backspace) && is_editable)

	push	1
	push	10					; 0000000aH
	call	?IsKeyPressedMap@@YA_NH_N@Z		; IsKeyPressedMap
	add	esp, 8
	test	al, al
	je	SHORT $LN72@InputTextE
	cmp	BYTE PTR tv2795[ebp], 0
	je	SHORT $LN72@InputTextE
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 344  :     bool                HasSelection() const        { return StbState.select_start != StbState.select_end; }

	mov	eax, DWORD PTR [ebx+60]
	cmp	eax, DWORD PTR [ebx+64]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8916 :             if (!edit_state.HasSelection())

	jne	SHORT $LN77@InputTextE

; 8917 :             {
; 8918 :                 if (is_wordmove_key_down) edit_state.OnKeyPressed(STB_TEXTEDIT_K_WORDLEFT|STB_TEXTEDIT_K_SHIFT);

	cmp	BYTE PTR _is_wordmove_key_down$1$[ebp], 0
	je	SHORT $LN75@InputTextE
	push	196620					; 0003000cH
	jmp	SHORT $LN505@InputTextE
$LN75@InputTextE:

; 8919 :                 else if (io.OSXBehaviors && io.KeySuper && !io.KeyAlt && !io.KeyCtrl) edit_state.OnKeyPressed(STB_TEXTEDIT_K_LINESTART|STB_TEXTEDIT_K_SHIFT);

	cmp	BYTE PTR tv3226[ebp], 0
	je	SHORT $LN77@InputTextE
	cmp	BYTE PTR [edi+232], 0
	je	SHORT $LN77@InputTextE
	cmp	BYTE PTR [edi+231], 0
	jne	SHORT $LN77@InputTextE
	cmp	BYTE PTR [edi+229], 0
	jne	SHORT $LN77@InputTextE
	push	196612					; 00030004H
$LN505@InputTextE:
	mov	ecx, ebx
	call	?OnKeyPressed@ImGuiTextEditState@@QAEXH@Z ; ImGuiTextEditState::OnKeyPressed
$LN77@InputTextE:

; 8920 :             }
; 8921 :             edit_state.OnKeyPressed(STB_TEXTEDIT_K_BACKSPACE | k_mask);

	or	esi, 65545				; 00010009H
	mov	ecx, ebx
	push	esi
	call	?OnKeyPressed@ImGuiTextEditState@@QAEXH@Z ; ImGuiTextEditState::OnKeyPressed
	jmp	$LN489@InputTextE
$LN72@InputTextE:

; 8922 :         }
; 8923 :         else if (IsKeyPressedMap(ImGuiKey_Enter))

	push	1
	push	11					; 0000000bH
	call	?IsKeyPressedMap@@YA_NH_N@Z		; IsKeyPressedMap
	add	esp, 8
	test	al, al
	je	SHORT $LN78@InputTextE

; 8924 :         {
; 8925 :             bool ctrl_enter_for_new_line = (flags & ImGuiInputTextFlags_CtrlEnterForNewLine) != 0;

	mov	ecx, DWORD PTR _flags$[ebp]
	mov	eax, ecx
	shr	eax, 11					; 0000000bH
	and	al, 1

; 8926 :             if (!is_multiline || (ctrl_enter_for_new_line && !io.KeyCtrl) || (!ctrl_enter_for_new_line && io.KeyCtrl))

	cmp	BYTE PTR tv2793[ebp], 0
	je	SHORT $LN82@InputTextE
	test	al, al
	je	SHORT $LN454@InputTextE
	cmp	BYTE PTR [edi+229], 0
	jne	SHORT $LN80@InputTextE
$LN82@InputTextE:

; 8927 :             {
; 8928 :                 enter_pressed = clear_active_id = true;

	mov	cl, 1
	mov	BYTE PTR _clear_active_id$1$[ebp], cl
	mov	BYTE PTR _enter_pressed$1$[ebp], cl

; 8935 :             }
; 8936 :         }

	jmp	$LN516@InputTextE
$LN454@InputTextE:

; 8926 :             if (!is_multiline || (ctrl_enter_for_new_line && !io.KeyCtrl) || (!ctrl_enter_for_new_line && io.KeyCtrl))

	cmp	BYTE PTR [edi+229], 0
	jne	SHORT $LN82@InputTextE
$LN80@InputTextE:

; 8929 :             }
; 8930 :             else if (is_editable)

	cmp	BYTE PTR tv2795[ebp], 0
	je	$LN489@InputTextE

; 8931 :             {
; 8932 :                 unsigned int c = '\n'; // Insert new line
; 8933 :                 if (InputTextFilterCharacter(&c, flags, callback, user_data))

	push	DWORD PTR _user_data$[ebp]
	lea	eax, DWORD PTR _c$35[ebp]
	mov	DWORD PTR _c$35[ebp], 10		; 0000000aH
	push	DWORD PTR _callback$[ebp]
	push	ecx
	push	eax
	call	?InputTextFilterCharacter@@YA_NPAIHP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ; InputTextFilterCharacter
	add	esp, 16					; 00000010H
	test	al, al
	je	$LN489@InputTextE

; 8934 :                     edit_state.OnKeyPressed((int)c);

	push	DWORD PTR _c$35[ebp]
	mov	ecx, ebx
	call	?OnKeyPressed@ImGuiTextEditState@@QAEXH@Z ; ImGuiTextEditState::OnKeyPressed
	jmp	$LN489@InputTextE
$LN78@InputTextE:

; 8937 :         else if ((flags & ImGuiInputTextFlags_AllowTabInput) && IsKeyPressedMap(ImGuiKey_Tab) && !io.KeyCtrl && !io.KeyShift && !io.KeyAlt && is_editable)

	test	DWORD PTR _flags$[ebp], 1024		; 00000400H
	je	SHORT $LN86@InputTextE
	push	1
	push	0
	call	?IsKeyPressedMap@@YA_NH_N@Z		; IsKeyPressedMap
	add	esp, 8
	test	al, al
	je	SHORT $LN86@InputTextE
	cmp	BYTE PTR [edi+229], 0
	jne	SHORT $LN86@InputTextE
	cmp	BYTE PTR tv3216[ebp], 0
	jne	SHORT $LN86@InputTextE
	cmp	BYTE PTR [edi+231], 0
	jne	SHORT $LN86@InputTextE
	cmp	BYTE PTR tv2795[ebp], 0
	je	SHORT $LN86@InputTextE

; 8938 :         {
; 8939 :             unsigned int c = '\t'; // Insert TAB
; 8940 :             if (InputTextFilterCharacter(&c, flags, callback, user_data))

	push	DWORD PTR _user_data$[ebp]
	lea	eax, DWORD PTR _c$34[ebp]
	mov	DWORD PTR _c$34[ebp], 9
	push	DWORD PTR _callback$[ebp]
	push	DWORD PTR _flags$[ebp]
	push	eax
	call	?InputTextFilterCharacter@@YA_NPAIHP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ; InputTextFilterCharacter
	add	esp, 16					; 00000010H
	test	al, al
	je	$LN489@InputTextE

; 8941 :                 edit_state.OnKeyPressed((int)c);

	push	DWORD PTR _c$34[ebp]
	mov	ecx, ebx
	call	?OnKeyPressed@ImGuiTextEditState@@QAEXH@Z ; ImGuiTextEditState::OnKeyPressed

; 8942 :         }

	jmp	$LN489@InputTextE
$LN86@InputTextE:

; 8943 :         else if (IsKeyPressedMap(ImGuiKey_Escape))                                      { clear_active_id = cancel_edit = true; }

	push	1
	push	12					; 0000000cH
	call	?IsKeyPressedMap@@YA_NH_N@Z		; IsKeyPressedMap
	add	esp, 8
	test	al, al
	je	SHORT $LN89@InputTextE
	mov	al, 1
	mov	cl, al
	mov	BYTE PTR _clear_active_id$1$[ebp], cl
	jmp	$LN517@InputTextE
$LN89@InputTextE:

; 8944 :         else if (is_shortcut_key_only && IsKeyPressedMap(ImGuiKey_Z) && is_editable)    { edit_state.OnKeyPressed(STB_TEXTEDIT_K_UNDO); edit_state.ClearSelection(); }

	cmp	BYTE PTR _is_shortcut_key_only$1$[ebp], 0
	je	$LN489@InputTextE
	push	1
	push	18					; 00000012H
	call	?IsKeyPressedMap@@YA_NH_N@Z		; IsKeyPressedMap
	add	esp, 8
	test	al, al
	je	SHORT $LN91@InputTextE
	cmp	BYTE PTR tv2795[ebp], 0
	je	SHORT $LN91@InputTextE
	push	65546					; 0001000aH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 345  :     void                ClearSelection()            { StbState.select_start = StbState.select_end = StbState.cursor; }

	jmp	SHORT $LN508@InputTextE
$LN91@InputTextE:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8945 :         else if (is_shortcut_key_only && IsKeyPressedMap(ImGuiKey_Y) && is_editable)    { edit_state.OnKeyPressed(STB_TEXTEDIT_K_REDO); edit_state.ClearSelection(); }

	push	1
	push	17					; 00000011H
	call	?IsKeyPressedMap@@YA_NH_N@Z		; IsKeyPressedMap
	add	esp, 8
	test	al, al
	je	SHORT $LN93@InputTextE
	cmp	BYTE PTR tv2795[ebp], 0
	je	SHORT $LN93@InputTextE
	push	65547					; 0001000bH
$LN508@InputTextE:
	mov	ecx, ebx
	call	?OnKeyPressed@ImGuiTextEditState@@QAEXH@Z ; ImGuiTextEditState::OnKeyPressed
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 345  :     void                ClearSelection()            { StbState.select_start = StbState.select_end = StbState.cursor; }

	mov	eax, DWORD PTR [ebx+56]
	mov	DWORD PTR [ebx+64], eax
	mov	DWORD PTR [ebx+60], eax
	jmp	$LN489@InputTextE
$LN93@InputTextE:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8946 :         else if (is_shortcut_key_only && IsKeyPressedMap(ImGuiKey_A))                   { edit_state.SelectAll(); edit_state.CursorFollow = true; }

	push	1
	push	13					; 0000000dH
	call	?IsKeyPressedMap@@YA_NH_N@Z		; IsKeyPressedMap
	add	esp, 8
	test	al, al
	je	SHORT $LN95@InputTextE
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 346  :     void                SelectAll()                 { StbState.select_start = 0; StbState.select_end = CurLenW; StbState.cursor = StbState.select_end; StbState.has_preferred_x = false; }

	mov	eax, DWORD PTR [ebx+44]
	mov	DWORD PTR [ebx+60], 0
	mov	DWORD PTR [ebx+64], eax
	mov	DWORD PTR [ebx+56], eax
	mov	BYTE PTR [ebx+71], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8946 :         else if (is_shortcut_key_only && IsKeyPressedMap(ImGuiKey_A))                   { edit_state.SelectAll(); edit_state.CursorFollow = true; }

	mov	BYTE PTR [ebx+3280], 1
	jmp	$LN489@InputTextE
$LN95@InputTextE:

; 8947 :         else if (is_shortcut_key_only && !is_password && ((IsKeyPressedMap(ImGuiKey_X) && is_editable) || IsKeyPressedMap(ImGuiKey_C)) && (!is_multiline || edit_state.HasSelection()))

	cmp	BYTE PTR tv2797[ebp], 0
	jne	$LN97@InputTextE
	push	1
	push	16					; 00000010H
	call	?IsKeyPressedMap@@YA_NH_N@Z		; IsKeyPressedMap
	add	esp, 8
	test	al, al
	je	SHORT $LN100@InputTextE
	cmp	BYTE PTR tv2795[ebp], 0
	jne	SHORT $LN99@InputTextE
$LN100@InputTextE:
	push	1
	push	14					; 0000000eH
	call	?IsKeyPressedMap@@YA_NH_N@Z		; IsKeyPressedMap
	add	esp, 8
	test	al, al
	je	$LN97@InputTextE
$LN99@InputTextE:
	cmp	BYTE PTR tv2793[ebp], 0
	je	SHORT $LN101@InputTextE
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 344  :     bool                HasSelection() const        { return StbState.select_start != StbState.select_end; }

	mov	eax, DWORD PTR [ebx+60]
	cmp	eax, DWORD PTR [ebx+64]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8947 :         else if (is_shortcut_key_only && !is_password && ((IsKeyPressedMap(ImGuiKey_X) && is_editable) || IsKeyPressedMap(ImGuiKey_C)) && (!is_multiline || edit_state.HasSelection()))

	je	$LN97@InputTextE
$LN101@InputTextE:

; 8948 :         {
; 8949 :             // Cut, Copy
; 8950 :             const bool cut = IsKeyPressedMap(ImGuiKey_X);

	push	1
	push	16					; 00000010H
	call	?IsKeyPressedMap@@YA_NH_N@Z		; IsKeyPressedMap
	add	esp, 8
	mov	BYTE PTR _cut$1$[ebp], al

; 8951 :             if (cut && !edit_state.HasSelection())

	test	al, al
	je	SHORT $LN102@InputTextE
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 344  :     bool                HasSelection() const        { return StbState.select_start != StbState.select_end; }

	mov	ecx, DWORD PTR [ebx+60]
	cmp	ecx, DWORD PTR [ebx+64]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8951 :             if (cut && !edit_state.HasSelection())

	jne	SHORT $LN102@InputTextE
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 346  :     void                SelectAll()                 { StbState.select_start = 0; StbState.select_end = CurLenW; StbState.cursor = StbState.select_end; StbState.has_preferred_x = false; }

	mov	eax, DWORD PTR [ebx+44]
	mov	DWORD PTR [ebx+60], 0
	mov	DWORD PTR [ebx+64], eax
	mov	DWORD PTR [ebx+56], eax
	mov	BYTE PTR [ebx+71], 0
$LN102@InputTextE:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8954 :             if (io.SetClipboardTextFn)

	cmp	DWORD PTR [edi+184], 0
	je	SHORT $LN103@InputTextE
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 344  :     bool                HasSelection() const        { return StbState.select_start != StbState.select_end; }

	mov	ecx, DWORD PTR [ebx+60]
	mov	eax, DWORD PTR [ebx+64]
	cmp	ecx, eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8956 :                 const int ib = edit_state.HasSelection() ? ImMin(edit_state.StbState.select_start, edit_state.StbState.select_end) : 0;

	je	SHORT $LN211@InputTextE
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 125  : static inline int    ImMin(int lhs, int rhs)                                    { return lhs < rhs ? lhs : rhs; }

	mov	edx, eax
	cmovl	edx, ecx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8956 :                 const int ib = edit_state.HasSelection() ? ImMin(edit_state.StbState.select_start, edit_state.StbState.select_end) : 0;

	jmp	SHORT $LN506@InputTextE
$LN211@InputTextE:
	xor	edx, edx
$LN506@InputTextE:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 344  :     bool                HasSelection() const        { return StbState.select_start != StbState.select_end; }

	cmp	ecx, eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8956 :                 const int ib = edit_state.HasSelection() ? ImMin(edit_state.StbState.select_start, edit_state.StbState.select_end) : 0;

	mov	DWORD PTR _ib$1$[ebp], edx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 126  : static inline int    ImMax(int lhs, int rhs)                                    { return lhs >= rhs ? lhs : rhs; }

	cmovge	eax, ecx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8957 :                 const int ie = edit_state.HasSelection() ? ImMax(edit_state.StbState.select_start, edit_state.StbState.select_end) : edit_state.CurLenW;

	jne	SHORT $LN507@InputTextE
	mov	eax, DWORD PTR [ebx+44]
$LN507@InputTextE:
	mov	DWORD PTR _ie$1$[ebp], eax

; 8958 :                 edit_state.TempTextBuffer.resize((ie-ib) * 4 + 1);

	lea	ecx, DWORD PTR [ebx+28]
	sub	eax, edx
	lea	eax, DWORD PTR [eax*4+1]
	push	eax
	call	?resize@?$ImVector@D@@QAEXH@Z		; ImVector<char>::resize

; 8959 :                 ImTextStrToUtf8(edit_state.TempTextBuffer.Data, edit_state.TempTextBuffer.Size, edit_state.Text.Data+ib, edit_state.Text.Data+ie);

	mov	ecx, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR _ie$1$[ebp]
	lea	eax, DWORD PTR [ecx+eax*2]
	push	eax
	mov	eax, DWORD PTR _ib$1$[ebp]
	lea	eax, DWORD PTR [ecx+eax*2]
	push	eax
	push	DWORD PTR [ebx+28]
	push	DWORD PTR [ebx+36]
	call	?ImTextStrToUtf8@@YAHPADHPBG1@Z		; ImTextStrToUtf8

; 8960 :                 SetClipboardText(edit_state.TempTextBuffer.Data);

	push	DWORD PTR [ebx+36]
	call	?SetClipboardText@ImGui@@YAXPBD@Z	; ImGui::SetClipboardText
	add	esp, 20					; 00000014H
$LN103@InputTextE:

; 8961 :             }
; 8962 : 
; 8963 :             if (cut)

	cmp	BYTE PTR _cut$1$[ebp], 0
	je	$LN489@InputTextE

; 8964 :             {
; 8965 :                 edit_state.CursorFollow = true;
; 8966 :                 stb_textedit_cut(&edit_state, &edit_state.StbState);

	lea	eax, DWORD PTR [ebx+56]
	mov	BYTE PTR [ebx+3280], 1
	push	eax
	push	ebx
	call	?stb_textedit_cut@ImGuiStb@@YAHPAUImGuiTextEditState@@PAUSTB_TexteditState@1@@Z ; ImGuiStb::stb_textedit_cut
	add	esp, 8

; 8967 :             }
; 8968 :         }

	jmp	$LN489@InputTextE
$LN97@InputTextE:

; 8969 :         else if (is_shortcut_key_only && IsKeyPressedMap(ImGuiKey_V) && is_editable)

	push	1
	push	15					; 0000000fH
	call	?IsKeyPressedMap@@YA_NH_N@Z		; IsKeyPressedMap
	add	esp, 8
	test	al, al
	je	$LN489@InputTextE
	cmp	BYTE PTR tv2795[ebp], 0
	je	$LN489@InputTextE

; 8970 :         {
; 8971 :             // Paste
; 8972 :             if (const char* clipboard = GetClipboardText())

	call	?GetClipboardText@ImGui@@YAPBDXZ	; ImGui::GetClipboardText
	mov	esi, eax
	test	esi, esi
	je	$LN489@InputTextE

; 8973 :             {
; 8974 :                 // Filter pasted buffer
; 8975 :                 const int clipboard_len = (int)strlen(clipboard);

	mov	ecx, esi
	lea	edx, DWORD PTR [ecx+1]
$LL461@InputTextE:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL461@InputTextE
	sub	ecx, edx

; 8976 :                 ImWchar* clipboard_filtered = (ImWchar*)ImGui::MemAlloc((clipboard_len+1) * sizeof(ImWchar));

	lea	eax, DWORD PTR [ecx*2+2]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 8977 :                 int clipboard_filtered_len = 0;

	xor	ecx, ecx
	mov	DWORD PTR _clipboard_filtered$1$[ebp], eax
	add	esp, 4

; 8978 :                 for (const char* s = clipboard; *s; )

	cmp	BYTE PTR [esi], cl
	je	SHORT $LN434@InputTextE
	xor	edi, edi
	npad	4
$LL5@InputTextE:

; 8979 :                 {
; 8980 :                     unsigned int c;
; 8981 :                     s += ImTextCharFromUtf8(&c, s, NULL);

	push	0
	lea	eax, DWORD PTR _c$33[ebp]
	push	esi
	push	eax
	call	?ImTextCharFromUtf8@@YAHPAIPBD1@Z	; ImTextCharFromUtf8
	add	esi, eax
	add	esp, 12					; 0000000cH

; 8982 :                     if (c == 0)

	mov	eax, DWORD PTR _c$33[ebp]
	test	eax, eax
	je	SHORT $LN472@InputTextE

; 8983 :                         break;
; 8984 :                     if (c >= 0x10000 || !InputTextFilterCharacter(&c, flags, callback, user_data))

	cmp	eax, 65536				; 00010000H
	jae	SHORT $LN109@InputTextE
	push	DWORD PTR _user_data$[ebp]
	lea	eax, DWORD PTR _c$33[ebp]
	push	DWORD PTR _callback$[ebp]
	push	DWORD PTR _flags$[ebp]
	push	eax
	call	?InputTextFilterCharacter@@YA_NPAIHP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ; InputTextFilterCharacter
	add	esp, 16					; 00000010H
	test	al, al
	je	SHORT $LN109@InputTextE

; 8985 :                         continue;
; 8986 :                     clipboard_filtered[clipboard_filtered_len++] = (ImWchar)c;

	mov	ecx, DWORD PTR _clipboard_filtered$1$[ebp]
	mov	ax, WORD PTR _c$33[ebp]
	mov	WORD PTR [ecx+edi*2], ax
	inc	edi
$LN109@InputTextE:

; 8978 :                 for (const char* s = clipboard; *s; )

	cmp	BYTE PTR [esi], 0
	jne	SHORT $LL5@InputTextE
$LN472@InputTextE:
	mov	eax, DWORD PTR _clipboard_filtered$1$[ebp]
	mov	DWORD PTR _clipboard_filtered_len$1$[ebp], edi
	mov	edi, DWORD PTR _g$1$[ebp]
	mov	ecx, DWORD PTR _clipboard_filtered_len$1$[ebp]
$LN434@InputTextE:

; 8987 :                 }
; 8988 :                 clipboard_filtered[clipboard_filtered_len] = 0;

	xor	edx, edx
	mov	WORD PTR [eax+ecx*2], dx

; 8989 :                 if (clipboard_filtered_len > 0) // If everything was filtered, ignore the pasting operation

	test	ecx, ecx
	jle	SHORT $LN110@InputTextE

; 8990 :                 {
; 8991 :                     stb_textedit_paste(&edit_state, &edit_state.StbState, clipboard_filtered, clipboard_filtered_len);

	push	ecx
	push	eax
	lea	eax, DWORD PTR [ebx+56]
	push	eax
	push	ebx
	call	?stb_textedit_paste@ImGuiStb@@YAHPAUImGuiTextEditState@@PAUSTB_TexteditState@1@PBGH@Z ; ImGuiStb::stb_textedit_paste
	mov	eax, DWORD PTR _clipboard_filtered$1$[ebp]
	add	esp, 16					; 00000010H

; 8992 :                     edit_state.CursorFollow = true;

	mov	BYTE PTR [ebx+3280], 1
$LN110@InputTextE:

; 8993 :                 }
; 8994 :                 ImGui::MemFree(clipboard_filtered);

	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN489@InputTextE:
	mov	cl, BYTE PTR _clear_active_id$1$[ebp]
$LN516@InputTextE:
	mov	al, BYTE PTR _cancel_edit$1$[ebp]
$LN517@InputTextE:
	mov	edx, DWORD PTR _id$[ebp]
$LN106@InputTextE:

; 8995 :             }
; 8996 :         }
; 8997 :     }
; 8998 : 
; 8999 :     if (g.ActiveId == id)

	cmp	DWORD PTR [edi+6264], edx
	jne	SHORT $LN129@InputTextE

; 9000 :     {
; 9001 :         if (cancel_edit)

	test	al, al
	je	$LN453@InputTextE

; 9002 :         {
; 9003 :             // Restore initial value
; 9004 :             if (is_editable)

	cmp	BYTE PTR tv2795[ebp], 0
	je	SHORT $LN129@InputTextE

; 9005 :             {
; 9006 :                 ImStrncpy(buf, edit_state.InitialText.Data, buf_size);

	push	DWORD PTR _buf_size$[ebp]
	push	DWORD PTR [ebx+24]
	push	DWORD PTR _buf$[ebp]
	call	?ImStrncpy@@YAXPADPBDH@Z		; ImStrncpy

; 9007 :                 value_changed = true;
; 9008 :             }
; 9009 :         }
; 9010 :         if (!cancel_edit && !clear_active_id)

	mov	edx, DWORD PTR _id$[ebp]
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _value_changed$1$[ebp], 1
$LN129@InputTextE:

; 9094 :             }
; 9095 :         }
; 9096 :     }
; 9097 : 
; 9098 :     // Release active ID at the end of the function (so e.g. pressing Return still does a final application of the value)
; 9099 :     if (clear_active_id && g.ActiveId == id)

	mov	cl, BYTE PTR _clear_active_id$1$[ebp]
	test	cl, cl
	je	SHORT $LN497@InputTextE
$LN452@InputTextE:
	cmp	DWORD PTR [edi+6264], edx
	jne	SHORT $LN497@InputTextE

; 9100 :         ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
$LN497@InputTextE:
	mov	ecx, DWORD PTR tv2795[ebp]
$LN130@InputTextE:

; 9101 : 
; 9102 :     // Render
; 9103 :     // Select which buffer we are going to display. When ImGuiInputTextFlags_NoLiveEdit is set 'buf' might still be the old value. We set buf to NULL to prevent accidental usage from now on.
; 9104 :     const char* buf_display = (g.ActiveId == id && is_editable) ? edit_state.TempTextBuffer.Data : buf; buf = NULL; 

	mov	eax, DWORD PTR _id$[ebp]
	cmp	DWORD PTR [edi+6264], eax
	jne	SHORT $LN215@InputTextE
	test	cl, cl
	je	SHORT $LN215@InputTextE
	mov	ecx, DWORD PTR [ebx+36]
	mov	DWORD PTR _buf$[ebp], ecx
$LN215@InputTextE:

; 9105 : 
; 9106 :     RenderNavHighlight(frame_bb, id);

	push	eax
	lea	eax, DWORD PTR _frame_bb$[ebp]
	push	eax
	call	?RenderNavHighlight@ImGui@@YAXABUImRect@@I@Z ; ImGui::RenderNavHighlight

; 9107 :     if (!is_multiline)

	mov	edx, DWORD PTR tv2793[ebp]
	add	esp, 8
	test	dl, dl
	jne	SHORT $LN131@InputTextE

; 9108 :         RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);

	movss	xmm0, DWORD PTR [edi+5364]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	1
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	7
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	add	esp, 8
	push	eax
	push	DWORD PTR _frame_bb$[ebp+12]
	push	DWORD PTR _frame_bb$[ebp+8]
	push	DWORD PTR _frame_bb$[ebp+4]
	push	DWORD PTR _frame_bb$[ebp]
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame
	mov	edx, DWORD PTR tv2793[ebp]
	add	esp, 28					; 0000001cH
$LN131@InputTextE:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 109  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

	movss	xmm1, DWORD PTR _frame_bb$[ebp]
	movss	xmm2, DWORD PTR _frame_bb$[ebp+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9110 :     const ImVec4 clip_rect(frame_bb.Min.x, frame_bb.Min.y, frame_bb.Min.x + size.x, frame_bb.Min.y + size.y); // Not using frame_bb.Max because we have adjusted size

	movaps	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 109  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

	movss	DWORD PTR _clip_rect$[ebp], xmm1
	movss	DWORD PTR _clip_rect$[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9110 :     const ImVec4 clip_rect(frame_bb.Min.x, frame_bb.Min.y, frame_bb.Min.x + size.x, frame_bb.Min.y + size.y); // Not using frame_bb.Max because we have adjusted size

	addss	xmm0, DWORD PTR _size$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 109  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

	movss	DWORD PTR _clip_rect$[ebp+8], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9110 :     const ImVec4 clip_rect(frame_bb.Min.x, frame_bb.Min.y, frame_bb.Min.x + size.x, frame_bb.Min.y + size.y); // Not using frame_bb.Max because we have adjusted size

	movss	xmm0, DWORD PTR _size$[ebp+4]
	addss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 109  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

	movss	DWORD PTR _clip_rect$[ebp+12], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9111 :     ImVec2 render_pos = is_multiline ? draw_window->DC.CursorPos : frame_bb.Min + style.FramePadding;

	test	dl, dl
	je	$LN217@InputTextE
	mov	ecx, DWORD PTR _draw_window$1$[ebp]
	mov	eax, DWORD PTR [ecx+192]
	mov	DWORD PTR $T28[ebp], eax
	mov	eax, DWORD PTR [ecx+196]
	mov	DWORD PTR $T28[ebp+4], eax
	jmp	$LN510@InputTextE
$LN453@InputTextE:

; 9007 :                 value_changed = true;
; 9008 :             }
; 9009 :         }
; 9010 :         if (!cancel_edit && !clear_active_id)

	test	cl, cl
	jne	$LN452@InputTextE

; 9011 :         {
; 9012 :             // Apply new value immediately - copy modified buffer back
; 9013 :             // Note that as soon as the input box is active, the in-widget value gets priority over any underlying modification of the input buffer
; 9014 :             // FIXME: We actually always render 'buf' when calling DrawList->AddText, making the comment above incorrect.
; 9015 :             // FIXME-OPT: CPU waste to do this every time the widget is active, should mark dirty state from the stb_textedit callbacks.
; 9016 :             if (is_editable)

	cmp	BYTE PTR tv2795[ebp], cl
	je	SHORT $LN115@InputTextE

; 9017 :             {
; 9018 :                 edit_state.TempTextBuffer.resize(edit_state.Text.Size * 4);

	mov	eax, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [ebx+28]
	shl	eax, 2
	push	eax
	call	?resize@?$ImVector@D@@QAEXH@Z		; ImVector<char>::resize

; 9019 :                 ImTextStrToUtf8(edit_state.TempTextBuffer.Data, edit_state.TempTextBuffer.Size, edit_state.Text.Data, NULL);

	push	0
	push	DWORD PTR [ebx+12]
	push	DWORD PTR [ebx+28]
	push	DWORD PTR [ebx+36]
	call	?ImTextStrToUtf8@@YAHPADHPBG1@Z		; ImTextStrToUtf8
	add	esp, 16					; 00000010H
$LN115@InputTextE:

; 9020 :             }
; 9021 : 
; 9022 :             // User callback
; 9023 :             if ((flags & (ImGuiInputTextFlags_CallbackCompletion | ImGuiInputTextFlags_CallbackHistory | ImGuiInputTextFlags_CallbackAlways)) != 0)

	mov	eax, DWORD PTR _flags$[ebp]
	test	eax, 448				; 000001c0H
	je	$LN128@InputTextE

; 9024 :             {
; 9025 :                 IM_ASSERT(callback != NULL);
; 9026 : 
; 9027 :                 // The reason we specify the usage semantic (Completion/History) is that Completion needs to disable keyboard TABBING at the moment.
; 9028 :                 ImGuiInputTextFlags event_flag = 0;
; 9029 :                 ImGuiKey event_key = ImGuiKey_COUNT;

	mov	DWORD PTR _event_key$1$[ebp], 19	; 00000013H

; 9030 :                 if ((flags & ImGuiInputTextFlags_CallbackCompletion) != 0 && IsKeyPressedMap(ImGuiKey_Tab))

	test	al, 64					; 00000040H
	je	SHORT $LN117@InputTextE
	push	1
	push	0
	call	?IsKeyPressedMap@@YA_NH_N@Z		; IsKeyPressedMap
	add	esp, 8
	test	al, al
	je	SHORT $LN494@InputTextE

; 9031 :                 {
; 9032 :                     event_flag = ImGuiInputTextFlags_CallbackCompletion;

	mov	esi, 64					; 00000040H

; 9033 :                     event_key = ImGuiKey_Tab;

	mov	DWORD PTR _event_key$1$[ebp], 0
	jmp	SHORT $LN460@InputTextE
$LN494@InputTextE:
	mov	eax, DWORD PTR _flags$[ebp]
$LN117@InputTextE:

; 9034 :                 }
; 9035 :                 else if ((flags & ImGuiInputTextFlags_CallbackHistory) != 0 && IsKeyPressedMap(ImGuiKey_UpArrow))

	test	al, al
	jns	SHORT $LN121@InputTextE
	push	1
	push	1
	call	?IsKeyPressedMap@@YA_NH_N@Z		; IsKeyPressedMap
	add	esp, 8
	test	al, al
	je	SHORT $LN119@InputTextE

; 9036 :                 {
; 9037 :                     event_flag = ImGuiInputTextFlags_CallbackHistory;

	mov	esi, 128				; 00000080H

; 9038 :                     event_key = ImGuiKey_UpArrow;

	mov	DWORD PTR _event_key$1$[ebp], 1
	jmp	SHORT $LN460@InputTextE
$LN119@InputTextE:

; 9039 :                 }
; 9040 :                 else if ((flags & ImGuiInputTextFlags_CallbackHistory) != 0 && IsKeyPressedMap(ImGuiKey_DownArrow))

	push	1
	push	2
	call	?IsKeyPressedMap@@YA_NH_N@Z		; IsKeyPressedMap
	add	esp, 8
	test	al, al
	je	SHORT $LN493@InputTextE

; 9041 :                 {
; 9042 :                     event_flag = ImGuiInputTextFlags_CallbackHistory;

	mov	esi, 128				; 00000080H

; 9043 :                     event_key = ImGuiKey_DownArrow;

	mov	DWORD PTR _event_key$1$[ebp], 2
	jmp	SHORT $LN460@InputTextE
$LN493@InputTextE:
	mov	eax, DWORD PTR _flags$[ebp]
$LN121@InputTextE:

; 9044 :                 }
; 9045 :                 else if (flags & ImGuiInputTextFlags_CallbackAlways)

	test	eax, 256				; 00000100H
	je	$LN128@InputTextE

; 9046 :                     event_flag = ImGuiInputTextFlags_CallbackAlways;

	mov	esi, 256				; 00000100H
$LN460@InputTextE:

; 9047 : 
; 9048 :                 if (event_flag)
; 9049 :                 {
; 9050 :                     ImGuiTextEditCallbackData callback_data;
; 9051 :                     memset(&callback_data, 0, sizeof(ImGuiTextEditCallbackData));

	push	48					; 00000030H
	lea	eax, DWORD PTR _callback_data$15[ebp]
	push	0
	push	eax
	call	_memset

; 9052 :                     callback_data.EventFlag = event_flag;
; 9053 :                     callback_data.Flags = flags;

	mov	eax, DWORD PTR _flags$[ebp]
	mov	DWORD PTR _callback_data$15[ebp+4], eax

; 9054 :                     callback_data.UserData = user_data;

	mov	eax, DWORD PTR _user_data$[ebp]
	mov	DWORD PTR _callback_data$15[ebp+8], eax

; 9055 :                     callback_data.ReadOnly = !is_editable;

	mov	al, BYTE PTR tv2795[ebp]
	xor	al, 1
	mov	DWORD PTR _callback_data$15[ebp], esi

; 9056 : 
; 9057 :                     callback_data.EventKey = event_key;
; 9058 :                     callback_data.Buf = edit_state.TempTextBuffer.Data;
; 9059 :                     callback_data.BufTextLen = edit_state.CurLenA;
; 9060 :                     callback_data.BufSize = edit_state.BufSizeA;
; 9061 :                     callback_data.BufDirty = false;
; 9062 : 
; 9063 :                     // We have to convert from wchar-positions to UTF-8-positions, which can be pretty slow (an incentive to ditch the ImWchar buffer, see https://github.com/nothings/stb/issues/188)
; 9064 :                     ImWchar* text = edit_state.Text.Data;

	mov	esi, DWORD PTR [ebx+12]
	mov	BYTE PTR _callback_data$15[ebp+12], al
	mov	eax, DWORD PTR _event_key$1$[ebp]
	mov	DWORD PTR _callback_data$15[ebp+16], eax
	mov	eax, DWORD PTR [ebx+36]
	mov	DWORD PTR _callback_data$15[ebp+20], eax
	mov	eax, DWORD PTR [ebx+40]
	mov	DWORD PTR _callback_data$15[ebp+24], eax
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR _callback_data$15[ebp+28], eax

; 9065 :                     const int utf8_cursor_pos = callback_data.CursorPos = ImTextCountUtf8BytesFromStr(text, text + edit_state.StbState.cursor);

	mov	eax, DWORD PTR [ebx+56]
	mov	BYTE PTR _callback_data$15[ebp+32], 0
	lea	eax, DWORD PTR [esi+eax*2]
	push	eax
	push	esi
	call	?ImTextCountUtf8BytesFromStr@@YAHPBG0@Z	; ImTextCountUtf8BytesFromStr

; 9066 :                     const int utf8_selection_start = callback_data.SelectionStart = ImTextCountUtf8BytesFromStr(text, text + edit_state.StbState.select_start);

	mov	ecx, DWORD PTR [ebx+60]
	mov	edi, eax
	mov	DWORD PTR _callback_data$15[ebp+36], edi
	lea	ecx, DWORD PTR [esi+ecx*2]
	push	ecx
	push	esi
	call	?ImTextCountUtf8BytesFromStr@@YAHPBG0@Z	; ImTextCountUtf8BytesFromStr

; 9067 :                     const int utf8_selection_end = callback_data.SelectionEnd = ImTextCountUtf8BytesFromStr(text, text + edit_state.StbState.select_end);

	mov	ecx, DWORD PTR [ebx+64]
	mov	DWORD PTR _utf8_selection_start$1$[ebp], eax
	mov	DWORD PTR _callback_data$15[ebp+40], eax
	lea	ecx, DWORD PTR [esi+ecx*2]
	push	ecx
	push	esi
	call	?ImTextCountUtf8BytesFromStr@@YAHPBG0@Z	; ImTextCountUtf8BytesFromStr
	mov	esi, eax

; 9068 : 
; 9069 :                     // Call user code
; 9070 :                     callback(&callback_data);

	lea	eax, DWORD PTR _callback_data$15[ebp]
	push	eax
	mov	DWORD PTR _callback_data$15[ebp+44], esi
	call	DWORD PTR _callback$[ebp]

; 9071 : 
; 9072 :                     // Read back what user may have modified
; 9073 :                     IM_ASSERT(callback_data.Buf == edit_state.TempTextBuffer.Data);  // Invalid to modify those fields
; 9074 :                     IM_ASSERT(callback_data.BufSize == edit_state.BufSizeA);
; 9075 :                     IM_ASSERT(callback_data.Flags == flags);
; 9076 :                     if (callback_data.CursorPos != utf8_cursor_pos)            edit_state.StbState.cursor = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.CursorPos);

	mov	edx, DWORD PTR _callback_data$15[ebp+36]
	add	esp, 40					; 00000028H
	cmp	edx, edi
	je	SHORT $LN125@InputTextE
	mov	ecx, DWORD PTR _callback_data$15[ebp+20]
	lea	eax, DWORD PTR [edx+ecx]
	push	eax
	push	ecx
	call	?ImTextCountCharsFromUtf8@@YAHPBD0@Z	; ImTextCountCharsFromUtf8
	add	esp, 8
	mov	DWORD PTR [ebx+56], eax
$LN125@InputTextE:

; 9077 :                     if (callback_data.SelectionStart != utf8_selection_start)  edit_state.StbState.select_start = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.SelectionStart);

	mov	eax, DWORD PTR _callback_data$15[ebp+40]
	cmp	eax, DWORD PTR _utf8_selection_start$1$[ebp]
	je	SHORT $LN126@InputTextE
	mov	ecx, DWORD PTR _callback_data$15[ebp+20]
	add	eax, ecx
	push	eax
	push	ecx
	call	?ImTextCountCharsFromUtf8@@YAHPBD0@Z	; ImTextCountCharsFromUtf8
	add	esp, 8
	mov	DWORD PTR [ebx+60], eax
$LN126@InputTextE:

; 9078 :                     if (callback_data.SelectionEnd != utf8_selection_end)      edit_state.StbState.select_end = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.SelectionEnd);

	mov	eax, DWORD PTR _callback_data$15[ebp+44]
	cmp	eax, esi
	je	SHORT $LN127@InputTextE
	mov	ecx, DWORD PTR _callback_data$15[ebp+20]
	add	eax, ecx
	push	eax
	push	ecx
	call	?ImTextCountCharsFromUtf8@@YAHPBD0@Z	; ImTextCountCharsFromUtf8
	add	esp, 8
	mov	DWORD PTR [ebx+64], eax
$LN127@InputTextE:

; 9079 :                     if (callback_data.BufDirty)

	cmp	BYTE PTR _callback_data$15[ebp+32], 0
	je	SHORT $LN481@InputTextE

; 9080 :                     {
; 9081 :                         IM_ASSERT(callback_data.BufTextLen == (int)strlen(callback_data.Buf)); // You need to maintain BufTextLen if you change the text!
; 9082 :                         edit_state.CurLenW = ImTextStrFromUtf8(edit_state.Text.Data, edit_state.Text.Size, callback_data.Buf, NULL);

	push	0
	push	0
	push	DWORD PTR _callback_data$15[ebp+20]
	push	DWORD PTR [ebx+4]
	push	DWORD PTR [ebx+12]
	call	?ImTextStrFromUtf8@@YAHPAGHPBD1PAPBD@Z	; ImTextStrFromUtf8
	mov	DWORD PTR [ebx+44], eax
	add	esp, 20					; 00000014H

; 9083 :                         edit_state.CurLenA = callback_data.BufTextLen;  // Assume correct length and valid UTF-8 from user, saves us an extra strlen()

	mov	eax, DWORD PTR _callback_data$15[ebp+24]
	mov	DWORD PTR [ebx+40], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 342  :     void                CursorAnimReset()           { CursorAnim = -0.30f; }                                   // After a user-input the cursor stays on for a while without blinking

	mov	DWORD PTR [ebx+3276], -1097229926	; be99999aH
$LN481@InputTextE:
	mov	edi, DWORD PTR _g$1$[ebp]
$LN128@InputTextE:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9090 :             if (is_editable && strcmp(edit_state.TempTextBuffer.Data, buf) != 0)

	mov	ecx, DWORD PTR tv2795[ebp]
	test	cl, cl
	je	$LN130@InputTextE
	mov	esi, DWORD PTR [ebx+36]
	mov	eax, esi
	mov	ecx, DWORD PTR _buf$[ebp]
$LL462@InputTextE:
	mov	dl, BYTE PTR [eax]
	cmp	dl, BYTE PTR [ecx]
	jne	SHORT $LN463@InputTextE
	test	dl, dl
	je	SHORT $LN464@InputTextE
	mov	dl, BYTE PTR [eax+1]
	cmp	dl, BYTE PTR [ecx+1]
	jne	SHORT $LN463@InputTextE
	add	eax, 2
	add	ecx, 2
	test	dl, dl
	jne	SHORT $LL462@InputTextE
$LN464@InputTextE:
	xor	eax, eax
	jmp	SHORT $LN465@InputTextE
$LN463@InputTextE:
	sbb	eax, eax
	or	eax, 1
$LN465@InputTextE:
	test	eax, eax
	je	$LN497@InputTextE

; 9091 :             {
; 9092 :                 ImStrncpy(buf, edit_state.TempTextBuffer.Data, buf_size);

	push	DWORD PTR _buf_size$[ebp]
	push	esi
	push	DWORD PTR _buf$[ebp]
	call	?ImStrncpy@@YAXPADPBDH@Z		; ImStrncpy
	add	esp, 12					; 0000000cH

; 9093 :                 value_changed = true;

	mov	BYTE PTR _value_changed$1$[ebp], 1

; 9094 :             }
; 9095 :         }
; 9096 :     }
; 9097 : 
; 9098 :     // Release active ID at the end of the function (so e.g. pressing Return still does a final application of the value)
; 9099 :     if (clear_active_id && g.ActiveId == id)

	jmp	$LN497@InputTextE
$LN217@InputTextE:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [edi+5356]
	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T27[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [edi+5360]
	addss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T27[ebp+4], xmm0
$LN510@InputTextE:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9113 :     const bool is_currently_scrolling = (edit_state.Id == id && is_multiline && g.ActiveId == draw_window->GetIDNoKeepAlive("#SCROLLY"));

	mov	esi, DWORD PTR _id$[ebp]
	lea	ecx, DWORD PTR $T27[ebp]
	mov	eax, DWORD PTR [ecx]
	xorps	xmm0, xmm0
	mov	DWORD PTR _render_pos$[ebp], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _render_pos$[ebp+4], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _text_size$$sroa$1442$1$[ebp], xmm0
	movss	DWORD PTR _text_size$$sroa$2013$1$[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9113 :     const bool is_currently_scrolling = (edit_state.Id == id && is_multiline && g.ActiveId == draw_window->GetIDNoKeepAlive("#SCROLLY"));

	cmp	DWORD PTR [ebx], esi
	jne	SHORT $LN219@InputTextE
	test	dl, dl
	je	SHORT $LN219@InputTextE
	mov	ecx, DWORD PTR _draw_window$1$[ebp]
	push	0
	push	OFFSET $SG121603
	call	?GetIDNoKeepAlive@ImGuiWindow@@QAEIPBD0@Z ; ImGuiWindow::GetIDNoKeepAlive
	cmp	DWORD PTR [edi+6264], eax
	jne	SHORT $LN219@InputTextE
	mov	al, 1
	jmp	SHORT $LN220@InputTextE
$LN219@InputTextE:
	xor	al, al
$LN220@InputTextE:

; 9114 :     if (g.ActiveId == id || is_currently_scrolling)

	cmp	DWORD PTR [edi+6264], esi
	je	$LN134@InputTextE
	test	al, al
	jne	$LN134@InputTextE

; 9250 :     }
; 9251 :     else
; 9252 :     {
; 9253 :         // Render text only
; 9254 :         const char* buf_end = NULL;
; 9255 :         if (is_multiline)

	mov	ebx, DWORD PTR tv2793[ebp]
	xor	ecx, ecx

; 9256 :             text_size = ImVec2(size.x, InputTextCalcTextLenAndLineCount(buf_display, &buf_end) * g.FontSize); // We don't need width

	mov	esi, DWORD PTR _buf$[ebp]
	mov	DWORD PTR _buf_end$20[ebp], ecx
	test	bl, bl
	je	SHORT $LN164@InputTextE
	lea	eax, DWORD PTR _buf_end$20[ebp]
	push	eax
	push	esi
	call	?InputTextCalcTextLenAndLineCount@@YAHPBDPAPBD@Z ; InputTextCalcTextLenAndLineCount
	movss	xmm1, DWORD PTR [edi+6172]
	add	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	ecx, DWORD PTR _buf_end$20[ebp]
	movd	xmm0, eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9256 :             text_size = ImVec2(size.x, InputTextCalcTextLenAndLineCount(buf_display, &buf_end) * g.FontSize); // We don't need width

	cvtdq2ps xmm0, xmm0
	mulss	xmm1, xmm0
	movss	xmm0, DWORD PTR _size$1$[ebp]
	movss	DWORD PTR _text_size$$sroa$1442$1$[ebp], xmm0
	movss	DWORD PTR _text_size$$sroa$2013$1$[ebp], xmm1
$LN164@InputTextE:

; 9257 :         draw_window->DrawList->AddText(g.Font, g.FontSize, render_pos, GetColorU32(ImGuiCol_Text), buf_display, buf_end, 0.0f, is_multiline ? NULL : &clip_rect);

	xor	edx, edx
	lea	eax, DWORD PTR _clip_rect$[ebp]
	test	bl, bl
	cmovne	eax, edx
	push	eax
	push	ecx
	mov	DWORD PTR [esp], edx
	push	ecx
	push	esi
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	edx
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	movss	xmm0, DWORD PTR [edi+6172]
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR _render_pos$[ebp]
	push	eax
	mov	eax, DWORD PTR _draw_window$1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR [edi+6168]
	mov	ecx, DWORD PTR [eax+624]
	call	?AddText@ImDrawList@@QAEXPBUImFont@@MABUImVec2@@IPBD2MPBUImVec4@@@Z ; ImDrawList::AddText
	jmp	$LN163@InputTextE
$LN134@InputTextE:

; 9115 :     {
; 9116 :         edit_state.CursorAnim += io.DeltaTime;

	movss	xmm0, DWORD PTR [edi+12]

; 9132 :             int searches_remaining = 1;
; 9133 :             int searches_result_line_number[2] = { -1, -999 };

	or	edx, -1
	mov	ecx, DWORD PTR [ebx+12]
	xorps	xmm1, xmm1
	addss	xmm0, DWORD PTR [ebx+3276]
	mov	eax, DWORD PTR [ebx+56]

; 9134 :             if (edit_state.StbState.select_start != edit_state.StbState.select_end)

	mov	esi, DWORD PTR [ebx+60]
	mov	DWORD PTR _text_begin$1$[ebp], ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 97   :     ImVec2() { x = y = 0.0f; }

	movss	DWORD PTR _rect_pos$9$sroa$1419$1$[ebp], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9130 :             searches_input_ptr[0] = text_begin + edit_state.StbState.cursor;

	lea	eax, DWORD PTR [ecx+eax*2]
	movss	DWORD PTR [ebx+3276], xmm0
	mov	DWORD PTR _searches_input_ptr$3$sroa$1437$1$[ebp], eax
	xorps	xmm0, xmm0

; 9134 :             if (edit_state.StbState.select_start != edit_state.StbState.select_end)

	mov	eax, DWORD PTR [ebx+64]
	mov	ecx, 1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 97   :     ImVec2() { x = y = 0.0f; }

	movss	DWORD PTR _select_start_offset$2$sroa$1431$1$[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9131 :             searches_input_ptr[1] = NULL;

	mov	DWORD PTR _searches_input_ptr$3$sroa$1436$1$[ebp], 0

; 9132 :             int searches_remaining = 1;
; 9133 :             int searches_result_line_number[2] = { -1, -999 };

	mov	DWORD PTR _searches_result_line_number$4$sroa$1268$2$[ebp], edx
	mov	DWORD PTR _searches_result_line_number$4$sroa$885$2$[ebp], -999 ; fffffc19H

; 9134 :             if (edit_state.StbState.select_start != edit_state.StbState.select_end)

	cmp	esi, eax
	je	SHORT $LN135@InputTextE

; 9135 :             {
; 9136 :                 searches_input_ptr[1] = text_begin + ImMin(edit_state.StbState.select_start, edit_state.StbState.select_end);

	mov	ecx, DWORD PTR _text_begin$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 125  : static inline int    ImMin(int lhs, int rhs)                                    { return lhs < rhs ? lhs : rhs; }

	cmovl	eax, esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9137 :                 searches_result_line_number[1] = -1;

	mov	DWORD PTR _searches_result_line_number$4$sroa$885$2$[ebp], edx
	lea	eax, DWORD PTR [ecx+eax*2]

; 9138 :                 searches_remaining++;

	mov	ecx, 2
	mov	DWORD PTR _searches_input_ptr$3$sroa$1436$1$[ebp], eax
$LN135@InputTextE:

; 9139 :             }
; 9140 : 
; 9141 :             // Iterate all lines to find our line numbers
; 9142 :             // In multi-line mode, we never exit the loop until all lines are counted, so add one extra to the searches_remaining counter.
; 9143 :             searches_remaining += is_multiline ? 1 : 0;
; 9144 :             int line_count = 0;
; 9145 :             for (const ImWchar* s = text_begin; *s != 0; s++)

	mov	edi, DWORD PTR _text_begin$1$[ebp]
	xor	eax, eax
	cmp	BYTE PTR tv2793[ebp], al
	setne	al
	xor	esi, esi
	add	ecx, eax
	mov	eax, edi
	movzx	edi, WORD PTR [edi]
	test	di, di
	mov	edi, DWORD PTR _g$1$[ebp]
	je	SHORT $LN435@InputTextE
	mov	edi, eax
	movzx	edx, WORD PTR [edi]
	mov	edi, DWORD PTR _searches_result_line_number$4$sroa$885$2$[ebp]
	npad	7
$LL10@InputTextE:

; 9146 :                 if (*s == '\n')

	cmp	dx, 10					; 0000000aH
	jne	SHORT $LN8@InputTextE

; 9147 :                 {
; 9148 :                     line_count++;

	inc	esi

; 9149 :                     if (searches_result_line_number[0] == -1 && s >= searches_input_ptr[0]) { searches_result_line_number[0] = line_count; if (--searches_remaining <= 0) break; }

	cmp	DWORD PTR _searches_result_line_number$4$sroa$1268$2$[ebp], -1
	jne	SHORT $LN138@InputTextE
	cmp	eax, DWORD PTR _searches_input_ptr$3$sroa$1437$1$[ebp]
	jb	SHORT $LN138@InputTextE
	dec	ecx
	mov	DWORD PTR _searches_result_line_number$4$sroa$1268$2$[ebp], esi
	test	ecx, ecx
	jle	SHORT $LN473@InputTextE
$LN138@InputTextE:

; 9150 :                     if (searches_result_line_number[1] == -1 && s >= searches_input_ptr[1]) { searches_result_line_number[1] = line_count; if (--searches_remaining <= 0) break; }

	cmp	edi, -1
	jne	SHORT $LN8@InputTextE
	cmp	eax, DWORD PTR _searches_input_ptr$3$sroa$1436$1$[ebp]
	jb	SHORT $LN8@InputTextE
	dec	ecx
	mov	edi, esi
	test	ecx, ecx
	jle	SHORT $LN473@InputTextE
$LN8@InputTextE:

; 9139 :             }
; 9140 : 
; 9141 :             // Iterate all lines to find our line numbers
; 9142 :             // In multi-line mode, we never exit the loop until all lines are counted, so add one extra to the searches_remaining counter.
; 9143 :             searches_remaining += is_multiline ? 1 : 0;
; 9144 :             int line_count = 0;
; 9145 :             for (const ImWchar* s = text_begin; *s != 0; s++)

	movzx	edx, WORD PTR [eax+2]
	add	eax, 2
	test	dx, dx
	jne	SHORT $LL10@InputTextE
$LN473@InputTextE:
	mov	edx, DWORD PTR _searches_result_line_number$4$sroa$1268$2$[ebp]
	mov	DWORD PTR _searches_result_line_number$4$sroa$885$2$[ebp], edi
	mov	edi, DWORD PTR _g$1$[ebp]
$LN435@InputTextE:

; 9151 :                 }
; 9152 :             line_count++;
; 9153 :             if (searches_result_line_number[0] == -1) searches_result_line_number[0] = line_count;
; 9154 :             if (searches_result_line_number[1] == -1) searches_result_line_number[1] = line_count;

	mov	eax, DWORD PTR _searches_result_line_number$4$sroa$885$2$[ebp]
	inc	esi
	cmp	edx, -1

; 9155 : 
; 9156 :             // Calculate 2d position by finding the beginning of the line and measuring distance
; 9157 :             cursor_offset.x = InputTextCalcTextSizeW(ImStrbolW(searches_input_ptr[0], text_begin), searches_input_ptr[0]).x;

	push	0
	cmove	edx, esi
	cmp	eax, -1
	push	0
	cmove	eax, esi
	mov	DWORD PTR _searches_result_line_number$4$sroa$1268$2$[ebp], edx
	push	0
	mov	DWORD PTR _searches_result_line_number$4$sroa$885$2$[ebp], eax
	mov	eax, DWORD PTR _searches_input_ptr$3$sroa$1437$1$[ebp]
	push	eax
	push	DWORD PTR _text_begin$1$[ebp]
	push	eax
	call	?ImStrbolW@@YAPBGPBG0@Z			; ImStrbolW
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR $T26[ebp]
	push	eax
	call	?InputTextCalcTextSizeW@@YA?AUImVec2@@PBG0PAPBGPAU1@_N@Z ; InputTextCalcTextSizeW
	movd	xmm3, DWORD PTR _searches_result_line_number$4$sroa$1268$2$[ebp]
	add	esp, 24					; 00000018H

; 9158 :             cursor_offset.y = searches_result_line_number[0] * g.FontSize;
; 9159 :             if (searches_result_line_number[1] >= 0)

	cmp	DWORD PTR _searches_result_line_number$4$sroa$885$2$[ebp], 0
	movss	xmm0, DWORD PTR [edi+6172]
	movss	xmm4, DWORD PTR [eax]
	cvtdq2ps xmm3, xmm3
	movss	DWORD PTR _cursor_offset$5$sroa$1433$1$[ebp], xmm4
	mulss	xmm3, xmm0
	movss	DWORD PTR _cursor_screen_pos$12$sroa$1944$1$[ebp], xmm3
	jl	SHORT $LN143@InputTextE

; 9160 :             {
; 9161 :                 select_start_offset.x = InputTextCalcTextSizeW(ImStrbolW(searches_input_ptr[1], text_begin), searches_input_ptr[1]).x;

	mov	eax, DWORD PTR _searches_input_ptr$3$sroa$1436$1$[ebp]
	push	0
	push	0
	push	0
	push	eax
	push	DWORD PTR _text_begin$1$[ebp]
	push	eax
	call	?ImStrbolW@@YAPBGPBG0@Z			; ImStrbolW
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR $T18[ebp]
	push	eax
	call	?InputTextCalcTextSizeW@@YA?AUImVec2@@PBG0PAPBGPAU1@_N@Z ; InputTextCalcTextSizeW
	movd	xmm1, DWORD PTR _searches_result_line_number$4$sroa$885$2$[ebp]
	add	esp, 24					; 00000018H
	movss	xmm3, DWORD PTR _cursor_screen_pos$12$sroa$1944$1$[ebp]
	movss	xmm4, DWORD PTR _cursor_offset$5$sroa$1433$1$[ebp]
	movss	xmm0, DWORD PTR [eax]

; 9162 :                 select_start_offset.y = searches_result_line_number[1] * g.FontSize;

	cvtdq2ps xmm1, xmm1
	movss	DWORD PTR _select_start_offset$2$sroa$1431$1$[ebp], xmm0
	movss	xmm0, DWORD PTR [edi+6172]
	mulss	xmm1, xmm0
	movss	DWORD PTR _rect_pos$9$sroa$1419$1$[ebp], xmm1
$LN143@InputTextE:

; 9163 :             }
; 9164 : 
; 9165 :             // Calculate text height
; 9166 :             if (is_multiline)

	mov	ecx, DWORD PTR tv2793[ebp]
	movss	xmm5, DWORD PTR _size$1$[ebp]
	test	cl, cl
	je	SHORT $LN144@InputTextE

; 9167 :                 text_size = ImVec2(size.x, line_count * g.FontSize);

	movd	xmm1, esi
	cvtdq2ps xmm1, xmm1
	movss	DWORD PTR _text_size$$sroa$1442$1$[ebp], xmm5
	mulss	xmm1, xmm0
	movss	DWORD PTR _text_size$$sroa$2013$1$[ebp], xmm1
$LN144@InputTextE:

; 9168 :         }
; 9169 : 
; 9170 :         // Scroll
; 9171 :         if (edit_state.CursorFollow)

	cmp	BYTE PTR [ebx+3280], 0
	je	$LN151@InputTextE

; 9172 :         {
; 9173 :             // Horizontal scroll in chunks of quarter width
; 9174 :             if (!(flags & ImGuiInputTextFlags_NoHorizontalScroll))

	test	DWORD PTR _flags$[ebp], 4096		; 00001000H
	jne	SHORT $LN146@InputTextE

; 9175 :             {
; 9176 :                 const float scroll_increment_x = size.x * 0.25f;
; 9177 :                 if (cursor_offset.x < edit_state.ScrollX)

	movss	xmm2, DWORD PTR [ebx+52]
	movaps	xmm1, xmm5
	comiss	xmm2, xmm4
	mulss	xmm1, DWORD PTR __real@3e800000

; 9178 :                     edit_state.ScrollX = (float)(int)ImMax(0.0f, cursor_offset.x - scroll_increment_x);

	movaps	xmm0, xmm4
	jbe	SHORT $LN148@InputTextE
	subss	xmm0, xmm1
	xorps	xmm2, xmm2
	maxss	xmm0, xmm2
	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [ebx+52], xmm0
	jmp	SHORT $LN147@InputTextE
$LN148@InputTextE:

; 9179 :                 else if (cursor_offset.x - size.x >= edit_state.ScrollX)

	subss	xmm0, xmm5
	comiss	xmm0, xmm2
	xorps	xmm2, xmm2
	jb	SHORT $LN147@InputTextE

; 9180 :                     edit_state.ScrollX = (float)(int)(cursor_offset.x - size.x + scroll_increment_x);

	addss	xmm1, xmm0
	cvttss2si eax, xmm1
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [ebx+52], xmm0

; 9181 :             }
; 9182 :             else

	jmp	SHORT $LN147@InputTextE
$LN146@InputTextE:

; 9183 :             {
; 9184 :                 edit_state.ScrollX = 0.0f;

	mov	DWORD PTR [ebx+52], 0
	xorps	xmm2, xmm2
$LN147@InputTextE:

; 9185 :             }
; 9186 : 
; 9187 :             // Vertical scroll
; 9188 :             if (is_multiline)

	test	cl, cl
	je	SHORT $LN151@InputTextE

; 9189 :             {
; 9190 :                 float scroll_y = draw_window->Scroll.y;

	mov	eax, DWORD PTR _draw_window$1$[ebp]

; 9191 :                 if (cursor_offset.y - g.FontSize < scroll_y)

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [edi+6172]
	movss	xmm1, DWORD PTR [eax+96]
	comiss	xmm1, xmm0
	jbe	SHORT $LN152@InputTextE
	maxss	xmm0, xmm2

; 9192 :                     scroll_y = ImMax(0.0f, cursor_offset.y - g.FontSize);

	jmp	SHORT $LN154@InputTextE
$LN152@InputTextE:

; 9193 :                 else if (cursor_offset.y - size.y >= scroll_y)
; 9194 :                     scroll_y = cursor_offset.y - size.y;

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR _size$[ebp+4]
	maxss	xmm0, xmm1
$LN154@InputTextE:

; 9195 :                 draw_window->DC.CursorPos.y += (draw_window->Scroll.y - scroll_y);   // To avoid a frame of lag

	subss	xmm1, xmm0

; 9196 :                 draw_window->Scroll.y = scroll_y;

	movss	DWORD PTR [eax+96], xmm0
	addss	xmm1, DWORD PTR [eax+196]
	movss	DWORD PTR [eax+196], xmm1

; 9197 :                 render_pos.y = draw_window->DC.CursorPos.y;

	movss	DWORD PTR _render_pos$[ebp+4], xmm1
$LN151@InputTextE:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR [ebx+52]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9204 :         if (edit_state.StbState.select_start != edit_state.StbState.select_end)

	mov	edx, DWORD PTR [ebx+60]
	mov	ecx, DWORD PTR [ebx+64]
	mov	BYTE PTR [ebx+3280], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _render_scroll$7$sroa$1428$1$[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9204 :         if (edit_state.StbState.select_start != edit_state.StbState.select_end)

	cmp	edx, ecx
	je	$LN475@InputTextE

; 9205 :         {
; 9206 :             const ImWchar* text_selected_begin = text_begin + ImMin(edit_state.StbState.select_start, edit_state.StbState.select_end);

	mov	esi, DWORD PTR _text_begin$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 125  : static inline int    ImMin(int lhs, int rhs)                                    { return lhs < rhs ? lhs : rhs; }

	mov	eax, ecx
	cmovl	eax, edx

; 126  : static inline int    ImMax(int lhs, int rhs)                                    { return lhs >= rhs ? lhs : rhs; }

	cmovge	ecx, edx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9209 :             float bg_offy_up = is_multiline ? 0.0f : -1.0f;    // FIXME: those offsets should be part of the style? they don't play so well with multi-line selection.

	cmp	BYTE PTR tv2793[ebp], 0
	lea	esi, DWORD PTR [esi+eax*2]
	mov	eax, DWORD PTR _text_begin$1$[ebp]
	lea	eax, DWORD PTR [eax+ecx*2]
	mov	DWORD PTR _text_selected_end$1$[ebp], eax
	je	SHORT $LN221@InputTextE
	xorps	xmm0, xmm0
	movss	DWORD PTR _bg_offy_up$1$[ebp], xmm0

; 9210 :             float bg_offy_dn = is_multiline ? 0.0f : 2.0f;

	jmp	SHORT $LN511@InputTextE
$LN221@InputTextE:
	movss	xmm0, DWORD PTR __real@40000000
$LN511@InputTextE:

; 9211 :             ImU32 bg_color = GetColorU32(ImGuiCol_TextSelectedBg);

	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	41					; 00000029H
	movss	DWORD PTR _bg_offy_dn$1$[ebp], xmm0
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm6, DWORD PTR _rect_pos$9$sroa$1419$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9211 :             ImU32 bg_color = GetColorU32(ImGuiCol_TextSelectedBg);

	add	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm5, DWORD PTR _render_pos$[ebp]
	addss	xmm5, DWORD PTR _select_start_offset$2$sroa$1431$1$[ebp]
	addss	xmm6, DWORD PTR _render_pos$[ebp+4]

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm1, DWORD PTR _render_scroll$7$sroa$1428$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9213 :             for (const ImWchar* p = text_selected_begin; p < text_selected_end; )

	mov	ecx, DWORD PTR _text_selected_end$1$[ebp]
	mov	DWORD PTR _bg_color$1$[ebp], eax
	mov	DWORD PTR _p$32[ebp], esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm5, xmm1

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	DWORD PTR _rect_pos$9$sroa$1419$1$[ebp], xmm6
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9213 :             for (const ImWchar* p = text_selected_begin; p < text_selected_end; )

	cmp	esi, ecx
	jae	$LN468@InputTextE
	movss	xmm3, DWORD PTR _clip_rect$[ebp+12]
	movss	xmm4, DWORD PTR _clip_rect$[ebp+4]
$LL11@InputTextE:

; 9214 :             {
; 9215 :                 if (rect_pos.y > clip_rect.w + g.FontSize)

	movaps	xmm0, xmm3
	addss	xmm0, DWORD PTR [edi+6172]
	comiss	xmm6, xmm0
	ja	$LN475@InputTextE

; 9216 :                     break;
; 9217 :                 if (rect_pos.y < clip_rect.y)

	comiss	xmm4, xmm6
	jbe	SHORT $LN157@InputTextE

; 9218 :                 {
; 9219 :                     while (p < text_selected_end)

	cmp	esi, ecx
	jae	$LN161@InputTextE
$LL14@InputTextE:

; 9220 :                         if (*p++ == '\n')

	movzx	eax, WORD PTR [esi]
	add	esi, 2
	mov	DWORD PTR _p$32[ebp], esi
	cmp	eax, 10					; 0000000aH
	je	$LN161@InputTextE

; 9218 :                 {
; 9219 :                     while (p < text_selected_end)

	cmp	esi, ecx
	jb	SHORT $LL14@InputTextE

; 9221 :                             break;
; 9222 :                 }
; 9223 :                 else

	jmp	$LN161@InputTextE
$LN157@InputTextE:

; 9224 :                 {
; 9225 :                     ImVec2 rect_size = InputTextCalcTextSizeW(p, text_selected_end, &p, NULL, true);

	push	1
	push	0
	lea	eax, DWORD PTR _p$32[ebp]
	push	eax
	push	ecx
	lea	eax, DWORD PTR _rect_size$39[ebp]
	push	esi
	push	eax
	call	?InputTextCalcTextSizeW@@YA?AUImVec2@@PBG0PAPBGPAU1@_N@Z ; InputTextCalcTextSizeW

; 9226 :                     if (rect_size.x <= 0.0f) rect_size.x = (float)(int)(g.Font->GetCharAdvance((unsigned short)' ') * 0.50f); // So we can see selected empty lines

	movss	xmm0, DWORD PTR _rect_size$39[ebp]
	xorps	xmm1, xmm1
	add	esp, 24					; 00000018H
	comiss	xmm1, xmm0
	jb	SHORT $LN160@InputTextE
	mov	eax, DWORD PTR [edi+6168]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1437 :     float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexXAdvance.Size) ? IndexXAdvance[(int)c] : FallbackXAdvance; }

	cmp	DWORD PTR [eax+28], 32			; 00000020H
	jle	SHORT $LN329@InputTextE
	mov	eax, DWORD PTR [eax+36]
	movss	xmm0, DWORD PTR [eax+128]
	jmp	SHORT $LN330@InputTextE
$LN329@InputTextE:
	movss	xmm0, DWORD PTR [eax+56]
$LN330@InputTextE:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9226 :                     if (rect_size.x <= 0.0f) rect_size.x = (float)(int)(g.Font->GetCharAdvance((unsigned short)' ') * 0.50f); // So we can see selected empty lines

	mulss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR _rect_size$39[ebp], xmm0
$LN160@InputTextE:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	movss	xmm7, DWORD PTR _clip_rect$[ebp]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movaps	xmm1, xmm5

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm7, xmm5

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm1, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T25[ebp], xmm5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T25[ebp]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movaps	xmm0, xmm6
	addss	xmm0, DWORD PTR _bg_offy_dn$1$[ebp]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _cursor_rect$19[ebp], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T17[ebp], xmm1
	movss	DWORD PTR $T17[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9227 :                     ImRect cursor_rect(rect_pos + ImVec2(0.0f, bg_offy_up - g.FontSize), rect_pos +ImVec2(rect_size.x, bg_offy_dn));

	movss	xmm0, DWORD PTR _bg_offy_up$1$[ebp]
	subss	xmm0, DWORD PTR [edi+6172]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm6

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	movss	xmm6, DWORD PTR _clip_rect$[ebp+8]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T25[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T25[ebp+4]
	mov	DWORD PTR _cursor_rect$19[ebp+4], eax
	mov	eax, DWORD PTR $T17[ebp]
	mov	DWORD PTR _cursor_rect$19[ebp+8], eax
	mov	eax, DWORD PTR $T17[ebp+4]
	mov	DWORD PTR _cursor_rect$19[ebp+12], eax

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	jbe	SHORT $LN359@InputTextE
	movaps	xmm5, xmm7
	jmp	SHORT $LN357@InputTextE
$LN359@InputTextE:
	comiss	xmm5, xmm6
	jbe	SHORT $LN357@InputTextE
	movaps	xmm5, xmm6
$LN357@InputTextE:
	movss	xmm4, DWORD PTR _clip_rect$[ebp+4]
	movss	xmm2, DWORD PTR _cursor_rect$19[ebp+4]
	comiss	xmm4, xmm2
	movss	xmm3, DWORD PTR _clip_rect$[ebp+12]
	movss	DWORD PTR _cursor_rect$19[ebp], xmm5
	jbe	SHORT $LN365@InputTextE
	movaps	xmm2, xmm4
	jmp	SHORT $LN512@InputTextE
$LN365@InputTextE:
	comiss	xmm2, xmm3
	jbe	SHORT $LN363@InputTextE
	movaps	xmm2, xmm3
$LN512@InputTextE:
	movss	DWORD PTR _cursor_rect$19[ebp+4], xmm2
$LN363@InputTextE:
	comiss	xmm7, xmm1
	jbe	SHORT $LN371@InputTextE
	movaps	xmm1, xmm7
	jmp	SHORT $LN369@InputTextE
$LN371@InputTextE:
	comiss	xmm1, xmm6
	jbe	SHORT $LN369@InputTextE
	movaps	xmm1, xmm6
$LN369@InputTextE:
	movss	xmm0, DWORD PTR _cursor_rect$19[ebp+12]
	comiss	xmm4, xmm0
	movss	DWORD PTR _cursor_rect$19[ebp+8], xmm1
	jbe	SHORT $LN377@InputTextE
	movaps	xmm0, xmm4
	jmp	SHORT $LN513@InputTextE
$LN377@InputTextE:
	comiss	xmm0, xmm3
	jbe	SHORT $LN375@InputTextE
	movaps	xmm0, xmm3
$LN513@InputTextE:
	movss	DWORD PTR _cursor_rect$19[ebp+12], xmm0
$LN375@InputTextE:

; 254  :     bool        Overlaps(const ImRect& r) const { return r.Min.y < Max.y  && r.Max.y > Min.y  && r.Min.x < Max.x && r.Max.x > Min.x; }

	comiss	xmm0, xmm4
	jbe	SHORT $LN467@InputTextE
	comiss	xmm3, xmm2
	jbe	SHORT $LN467@InputTextE
	comiss	xmm1, xmm7
	jbe	SHORT $LN467@InputTextE
	comiss	xmm6, xmm5
	jbe	SHORT $LN467@InputTextE
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9231 :                         draw_window->DrawList->AddRectFilled(cursor_rect.Min, cursor_rect.Max, bg_color);

	push	-1
	push	ecx
	mov	DWORD PTR [esp], 0
	lea	eax, DWORD PTR _cursor_rect$19[ebp+8]
	push	DWORD PTR _bg_color$1$[ebp]
	push	eax
	lea	eax, DWORD PTR _cursor_rect$19[ebp]
	push	eax
	mov	eax, DWORD PTR _draw_window$1$[ebp]
	mov	ecx, DWORD PTR [eax+624]
	call	?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	movss	xmm3, DWORD PTR _clip_rect$[ebp+12]
	movss	xmm4, DWORD PTR _clip_rect$[ebp+4]
$LN467@InputTextE:
	mov	ecx, DWORD PTR _text_selected_end$1$[ebp]
	movss	xmm6, DWORD PTR _rect_pos$9$sroa$1419$1$[ebp]
	mov	esi, DWORD PTR _p$32[ebp]
$LN161@InputTextE:

; 9232 :                 }
; 9233 :                 rect_pos.x = render_pos.x - render_scroll.x;

	movss	xmm5, DWORD PTR _render_pos$[ebp]

; 9234 :                 rect_pos.y += g.FontSize;

	addss	xmm6, DWORD PTR [edi+6172]
	subss	xmm5, DWORD PTR _render_scroll$7$sroa$1428$1$[ebp]
	movss	DWORD PTR _rect_pos$9$sroa$1419$1$[ebp], xmm6
	cmp	esi, ecx
	jb	$LL11@InputTextE
$LN475@InputTextE:
	movss	xmm1, DWORD PTR _render_scroll$7$sroa$1428$1$[ebp]
$LN468@InputTextE:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR _render_pos$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9238 :         draw_window->DrawList->AddText(g.Font, g.FontSize, render_pos - render_scroll, GetColorU32(ImGuiCol_Text), buf_display, buf_display + edit_state.CurLenA, 0.0f, is_multiline ? NULL : &clip_rect);

	lea	eax, DWORD PTR _clip_rect$[ebp]
	mov	esi, DWORD PTR _buf$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9238 :         draw_window->DrawList->AddText(g.Font, g.FontSize, render_pos - render_scroll, GetColorU32(ImGuiCol_Text), buf_display, buf_display + edit_state.CurLenA, 0.0f, is_multiline ? NULL : &clip_rect);

	xor	ecx, ecx
	cmp	BYTE PTR tv2793[ebp], cl
	cmovne	eax, ecx
	push	eax
	mov	eax, DWORD PTR [ebx+40]
	push	ecx
	mov	DWORD PTR [esp], ecx
	add	eax, esi
	push	eax
	push	esi
	push	ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T24[ebp], xmm0
	movss	xmm0, DWORD PTR _render_pos$[ebp+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9238 :         draw_window->DrawList->AddText(g.Font, g.FontSize, render_pos - render_scroll, GetColorU32(ImGuiCol_Text), buf_display, buf_display + edit_state.CurLenA, 0.0f, is_multiline ? NULL : &clip_rect);

	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T24[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9238 :         draw_window->DrawList->AddText(g.Font, g.FontSize, render_pos - render_scroll, GetColorU32(ImGuiCol_Text), buf_display, buf_display + edit_state.CurLenA, 0.0f, is_multiline ? NULL : &clip_rect);

	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	movss	xmm0, DWORD PTR [edi+6172]
	add	esp, 8
	mov	ebx, DWORD PTR _draw_window$1$[ebp]
	push	eax
	lea	eax, DWORD PTR $T24[ebp]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR [ebx+624]
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR [edi+6168]
	call	?AddText@ImDrawList@@QAEXPBUImFont@@MABUImVec2@@IPBD2MPBUImVec4@@@Z ; ImDrawList::AddText

; 9241 :         bool cursor_is_visible = (g.InputTextState.CursorAnim <= 0.0f) || fmodf(g.InputTextState.CursorAnim, 1.20f) <= 0.80f;

	movss	xmm0, DWORD PTR [edi+10408]
	xorps	xmm1, xmm1
	comiss	xmm1, xmm0
	movss	DWORD PTR tv2915[ebp], xmm0
	jae	SHORT $LN225@InputTextE
	fld	DWORD PTR tv2915[ebp]
	fld	DWORD PTR __real@3f99999a
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 677  :         return (float)fmod(_X, _Y);

	call	__CIfmod
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9241 :         bool cursor_is_visible = (g.InputTextState.CursorAnim <= 0.0f) || fmodf(g.InputTextState.CursorAnim, 1.20f) <= 0.80f;

	movss	xmm0, DWORD PTR __real@3f4ccccd
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 677  :         return (float)fmod(_X, _Y);

	fstp	DWORD PTR tv3317[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9241 :         bool cursor_is_visible = (g.InputTextState.CursorAnim <= 0.0f) || fmodf(g.InputTextState.CursorAnim, 1.20f) <= 0.80f;

	comiss	xmm0, DWORD PTR tv3317[ebp]
	jae	SHORT $LN225@InputTextE
	xor	al, al
	jmp	SHORT $LN226@InputTextE
$LN225@InputTextE:
	mov	al, 1
$LN226@InputTextE:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR _cursor_screen_pos$12$sroa$1944$1$[ebp]
	movss	xmm1, DWORD PTR _render_pos$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9243 :         ImRect cursor_screen_rect(cursor_screen_pos.x, cursor_screen_pos.y-g.FontSize+0.5f, cursor_screen_pos.x+1.0f, cursor_screen_pos.y-1.5f);

	movss	xmm5, DWORD PTR __real@3f800000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm1, DWORD PTR _cursor_offset$5$sroa$1433$1$[ebp]
	addss	xmm0, DWORD PTR _render_pos$[ebp+4]

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm1, DWORD PTR _render_scroll$7$sroa$1428$1$[ebp]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	DWORD PTR _cursor_screen_pos$12$sroa$1944$1$[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9243 :         ImRect cursor_screen_rect(cursor_screen_pos.x, cursor_screen_pos.y-g.FontSize+0.5f, cursor_screen_pos.x+1.0f, cursor_screen_pos.y-1.5f);

	movaps	xmm2, xmm0
	movaps	xmm3, xmm0
	subss	xmm2, DWORD PTR [edi+6172]
	subss	xmm3, DWORD PTR __real@3fc00000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	DWORD PTR _cursor_screen_pos$12$sroa$1412$1$[ebp], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9243 :         ImRect cursor_screen_rect(cursor_screen_pos.x, cursor_screen_pos.y-g.FontSize+0.5f, cursor_screen_pos.x+1.0f, cursor_screen_pos.y-1.5f);

	movaps	xmm4, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _cursor_screen_rect$14[ebp], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9243 :         ImRect cursor_screen_rect(cursor_screen_pos.x, cursor_screen_pos.y-g.FontSize+0.5f, cursor_screen_pos.x+1.0f, cursor_screen_pos.y-1.5f);

	addss	xmm4, xmm5
	addss	xmm2, DWORD PTR __real@3f000000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _cursor_screen_rect$14[ebp+12], xmm3
	movss	DWORD PTR _cursor_screen_rect$14[ebp+8], xmm4
	movss	DWORD PTR _cursor_screen_rect$14[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9244 :         if (cursor_is_visible && cursor_screen_rect.Overlaps(clip_rect))

	test	al, al
	je	$LN162@InputTextE
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 254  :     bool        Overlaps(const ImRect& r) const { return r.Min.y < Max.y  && r.Max.y > Min.y  && r.Min.x < Max.x && r.Max.x > Min.x; }

	comiss	xmm3, DWORD PTR _clip_rect$[ebp+4]
	jbe	SHORT $LN162@InputTextE
	movss	xmm0, DWORD PTR _clip_rect$[ebp+12]
	comiss	xmm0, xmm2
	jbe	SHORT $LN478@InputTextE
	comiss	xmm4, DWORD PTR _clip_rect$[ebp]
	jbe	SHORT $LN478@InputTextE
	movss	xmm0, DWORD PTR _clip_rect$[ebp+8]
	comiss	xmm0, xmm1
	jbe	SHORT $LN478@InputTextE
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9245 :             draw_window->DrawList->AddLine(cursor_screen_rect.Min, cursor_screen_rect.GetBL(), GetColorU32(ImGuiCol_Text));

	sub	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T23[ebp], xmm1
	movss	DWORD PTR $T23[ebp+4], xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9245 :             draw_window->DrawList->AddLine(cursor_screen_rect.Min, cursor_screen_rect.GetBL(), GetColorU32(ImGuiCol_Text));

	mov	DWORD PTR [esp+4], 1065353216		; 3f800000H
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	0
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	ecx, DWORD PTR [ebx+624]
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR $T23[ebp]
	push	eax
	lea	eax, DWORD PTR _cursor_screen_rect$14[ebp]
	push	eax
	call	?AddLine@ImDrawList@@QAEXABUImVec2@@0IM@Z ; ImDrawList::AddLine
	movss	xmm1, DWORD PTR _cursor_screen_pos$12$sroa$1412$1$[ebp]
	movss	xmm5, DWORD PTR __real@3f800000
$LN478@InputTextE:
	movss	xmm0, DWORD PTR _cursor_screen_pos$12$sroa$1944$1$[ebp]
$LN162@InputTextE:

; 9246 : 
; 9247 :         // Notify OS of text input position for advanced IME (-1 x offset so that Windows IME can cover our cursor. Bit of an extra nicety.)
; 9248 :         if (is_editable)

	cmp	BYTE PTR tv2795[ebp], 0
	je	SHORT $LN163@InputTextE

; 9249 :             g.OsImePosRequest = ImVec2(cursor_screen_pos.x - 1, cursor_screen_pos.y - g.FontSize);

	subss	xmm0, DWORD PTR [edi+6172]
	subss	xmm1, xmm5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T22[ebp+4], xmm0
	movss	DWORD PTR $T22[ebp], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9249 :             g.OsImePosRequest = ImVec2(cursor_screen_pos.x - 1, cursor_screen_pos.y - g.FontSize);

	mov	eax, DWORD PTR $T22[ebp]
	mov	DWORD PTR [edi+11584], eax
	mov	eax, DWORD PTR $T22[ebp+4]
	mov	DWORD PTR [edi+11588], eax
$LN163@InputTextE:

; 9258 :     }
; 9259 : 
; 9260 :     if (is_multiline)

	cmp	BYTE PTR tv2793[ebp], 0
	je	SHORT $LN165@InputTextE
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR _text_size$$sroa$1442$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9262 :         Dummy(text_size + ImVec2(0.0f, g.FontSize)); // Always add room to scroll an extra line

	lea	eax, DWORD PTR $T21[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T21[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR _text_size$$sroa$2013$1$[ebp]
	addss	xmm0, DWORD PTR [edi+6172]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9262 :         Dummy(text_size + ImVec2(0.0f, g.FontSize)); // Always add room to scroll an extra line

	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T21[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9262 :         Dummy(text_size + ImVec2(0.0f, g.FontSize)); // Always add room to scroll an extra line

	call	?Dummy@ImGui@@YAXABUImVec2@@@Z		; ImGui::Dummy
	add	esp, 4

; 9263 :         EndChildFrame();

	call	?EndChildFrame@ImGui@@YAXXZ		; ImGui::EndChildFrame

; 9264 :         EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup
$LN165@InputTextE:

; 9265 :     }
; 9266 : 
; 9267 :     if (is_password)

	mov	eax, DWORD PTR tv2797[ebp]
	test	al, al
	je	SHORT $LN166@InputTextE

; 9268 :         PopFont();

	call	?PopFont@ImGui@@YAXXZ			; ImGui::PopFont
	mov	eax, DWORD PTR tv2797[ebp]
$LN166@InputTextE:

; 9269 : 
; 9270 :     // Log as text
; 9271 :     if (g.LogEnabled && !is_password)

	cmp	BYTE PTR [edi+11600], 0
	je	SHORT $LN167@InputTextE
	test	al, al
	jne	SHORT $LN167@InputTextE

; 9272 :         LogRenderedText(render_pos, buf_display, NULL);

	push	0
	lea	eax, DWORD PTR _render_pos$[ebp]
	push	esi
	push	eax
	call	?LogRenderedText@@YAXABUImVec2@@PBD1@Z	; LogRenderedText
	add	esp, 12					; 0000000cH
$LN167@InputTextE:

; 9273 : 
; 9274 :     if (label_size.x > 0)

	movss	xmm0, DWORD PTR _label_size$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN168@InputTextE

; 9275 :         RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

	movss	xmm0, DWORD PTR [edi+5376]
	addss	xmm0, DWORD PTR _frame_bb$[ebp+8]
	push	1
	push	0
	push	DWORD PTR _label$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T16[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9275 :         RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

	movss	xmm0, DWORD PTR _frame_bb$[ebp+4]
	addss	xmm0, DWORD PTR [edi+5360]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T16[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9275 :         RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

	push	DWORD PTR $T16[ebp+4]
	push	DWORD PTR $T16[ebp]
	call	?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z	; ImGui::RenderText
	add	esp, 20					; 00000014H
$LN168@InputTextE:

; 9276 : 
; 9277 :     if ((flags & ImGuiInputTextFlags_EnterReturnsTrue) != 0)

	test	BYTE PTR _flags$[ebp], 32		; 00000020H
	movzx	eax, BYTE PTR _value_changed$1$[ebp]
	movzx	ecx, BYTE PTR _enter_pressed$1$[ebp]
	pop	esi
	pop	edi
	cmovne	eax, ecx
	pop	ebx

; 9278 :         return enter_pressed;
; 9279 :     else
; 9280 :         return value_changed;
; 9281 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InputTextEx@ImGui@@YA_NPBDPADHABUImVec2@@HP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ENDP ; ImGui::InputTextEx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_g$1$ = -4						; size = 4
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_components$ = 16					; size = 4
_v_speed$ = 20						; size = 4
_v_min$ = 24						; size = 4
_v_max$ = 28						; size = 4
_display_format$ = 32					; size = 4
?DragIntN@ImGui@@YA_NPBDPAHHMHH0@Z PROC			; ImGui::DragIntN

; 8058 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8060 :     if (window->SkipItems)

	mov	eax, DWORD PTR [ecx+6240]
	cmp	BYTE PTR [eax+137], 0
	je	SHORT $LN5@DragIntN

; 8061 :         return false;

	xor	al, al

; 8082 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@DragIntN:

; 8062 : 
; 8063 :     ImGuiContext& g = *GImGui;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _g$1$[ebp], eax

; 8064 :     bool value_changed = false;

	xor	bl, bl

; 8065 :     BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup

; 8066 :     PushID(label);

	push	DWORD PTR _label$[ebp]
	call	?PushID@ImGui@@YAXPBD@Z			; ImGui::PushID

; 8067 :     PushMultiItemsWidths(components);

	mov	edi, DWORD PTR _components$[ebp]
	mov	DWORD PTR [esp], 0
	push	edi
	call	?PushMultiItemsWidths@@YAXHM@Z		; PushMultiItemsWidths
	add	esp, 8

; 8068 :     for (int i = 0; i < components; i++)

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN3@DragIntN

; 8062 : 
; 8063 :     ImGuiContext& g = *GImGui;

	mov	edi, DWORD PTR _v$[ebp]
$LL4@DragIntN:

; 8069 :     {
; 8070 :         PushID(i);

	push	esi
	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID

; 8071 :         value_changed |= DragInt("##v", &v[i], v_speed, v_min, v_max, display_format);

	movss	xmm0, DWORD PTR _v_speed$[ebp]
	add	esp, 4
	push	DWORD PTR _display_format$[ebp]
	push	DWORD PTR _v_max$[ebp]
	push	DWORD PTR _v_min$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	edi
	push	OFFSET $SG120369
	call	?DragInt@ImGui@@YA_NPBDPAHMHH0@Z	; ImGui::DragInt
	or	bl, al

; 8072 :         SameLine(0, g.Style.ItemInnerSpacing.x);

	add	esp, 16					; 00000010H
	mov	eax, DWORD PTR _g$1$[ebp]
	movss	xmm0, DWORD PTR [eax+5376]
	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	add	esp, 8

; 8073 :         PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 8074 :         PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth
	inc	esi
	add	edi, 4
	cmp	esi, DWORD PTR _components$[ebp]
	jl	SHORT $LL4@DragIntN
$LN3@DragIntN:

; 8075 :     }
; 8076 :     PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 8077 : 
; 8078 :     TextUnformatted(label, FindRenderedTextEnd(label));

	mov	esi, DWORD PTR _label$[ebp]
	push	0
	push	esi
	call	?FindRenderedTextEnd@ImGui@@YAPBDPBD0@Z	; ImGui::FindRenderedTextEnd
	push	eax
	push	esi
	call	?TextUnformatted@ImGui@@YAXPBD0@Z	; ImGui::TextUnformatted
	add	esp, 16					; 00000010H

; 8079 :     EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup
	pop	edi
	pop	esi

; 8080 : 
; 8081 :     return value_changed;

	mov	al, bl
	pop	ebx

; 8082 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DragIntN@ImGui@@YA_NPBDPAHHMHH0@Z ENDP			; ImGui::DragIntN
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_g$1$ = -8						; size = 4
_value_changed$1$ = -1					; size = 1
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_components$ = 16					; size = 4
_v_speed$ = 20						; size = 4
_v_min$ = 24						; size = 4
_v_max$ = 28						; size = 4
_display_format$ = 32					; size = 4
_power$ = 36						; size = 4
?DragFloatN@ImGui@@YA_NPBDPAMHMMM0M@Z PROC		; ImGui::DragFloatN

; 7980 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7980 : {

	sub	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7982 :     if (window->SkipItems)

	mov	eax, DWORD PTR [ecx+6240]
	cmp	BYTE PTR [eax+137], 0
	je	SHORT $LN5@DragFloatN

; 7983 :         return false;

	xor	al, al

; 8004 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@DragFloatN:

; 7984 : 
; 7985 :     ImGuiContext& g = *GImGui;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _g$1$[ebp], eax

; 7986 :     bool value_changed = false;

	mov	BYTE PTR _value_changed$1$[ebp], 0

; 7987 :     BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup

; 7988 :     PushID(label);

	mov	ebx, DWORD PTR _label$[ebp]
	push	ebx
	call	?PushID@ImGui@@YAXPBD@Z			; ImGui::PushID

; 7989 :     PushMultiItemsWidths(components);

	mov	edi, DWORD PTR _components$[ebp]
	mov	DWORD PTR [esp], 0
	push	edi
	call	?PushMultiItemsWidths@@YAXHM@Z		; PushMultiItemsWidths
	add	esp, 8

; 7990 :     for (int i = 0; i < components; i++)

	xor	esi, esi
	test	edi, edi
	jle	$LN3@DragFloatN
	mov	bl, BYTE PTR _value_changed$1$[ebp]
	npad	3
$LL4@DragFloatN:

; 7991 :     {
; 7992 :         PushID(i);

	push	esi
	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID

; 7993 :         value_changed |= DragFloat("##v", &v[i], v_speed, v_min, v_max, display_format, power);

	movss	xmm0, DWORD PTR _power$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _display_format$[ebp]
	movss	xmm0, DWORD PTR _v_max$[ebp]
	sub	esp, 12					; 0000000cH
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _v_min$[ebp]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _v_speed$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _v$[ebp]
	push	OFFSET $SG120291
	call	?DragFloat@ImGui@@YA_NPBDPAMMMM0M@Z	; ImGui::DragFloat
	or	bl, al

; 7994 :         SameLine(0, g.Style.ItemInnerSpacing.x);

	add	esp, 20					; 00000014H
	mov	eax, DWORD PTR _g$1$[ebp]
	movss	xmm0, DWORD PTR [eax+5376]
	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	add	esp, 8

; 7995 :         PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 7996 :         PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth
	add	DWORD PTR _v$[ebp], 4
	inc	esi
	cmp	esi, edi
	jl	SHORT $LL4@DragFloatN
	mov	BYTE PTR _value_changed$1$[ebp], bl
	mov	ebx, DWORD PTR _label$[ebp]
$LN3@DragFloatN:

; 7997 :     }
; 7998 :     PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 7999 : 
; 8000 :     TextUnformatted(label, FindRenderedTextEnd(label));

	push	0
	push	ebx
	call	?FindRenderedTextEnd@ImGui@@YAPBDPBD0@Z	; ImGui::FindRenderedTextEnd
	push	eax
	push	ebx
	call	?TextUnformatted@ImGui@@YAXPBD0@Z	; ImGui::TextUnformatted
	add	esp, 16					; 00000010H

; 8001 :     EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup

; 8002 : 
; 8003 :     return value_changed;

	mov	al, BYTE PTR _value_changed$1$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 8004 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DragFloatN@ImGui@@YA_NPBDPAMHMMM0M@Z ENDP		; ImGui::DragFloatN
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_mouse_drag_delta$1 = -20				; size = 8
_v1_sign$1$ = -12					; size = 4
$T2 = -8						; size = 8
$T3 = -8						; size = 8
_adjust_delta$2$ = -4					; size = 4
_g$1$ = -4						; size = 4
_frame_bb$ = 8						; size = 4
_value_changed$2$ = 11					; size = 1
_v0_sign$1$ = 12					; size = 4
_v_cur$1$ = 12						; size = 4
tv400 = 12						; size = 4
_v_cur$4 = 12						; size = 4
_id$ = 12						; size = 4
_v$ = 16						; size = 4
_v_speed$ = 20						; size = 4
_v_min$ = 24						; size = 4
_v_max$ = 28						; size = 4
_decimal_precision$ = 32				; size = 4
_power$ = 36						; size = 4
?DragBehavior@ImGui@@YA_NABUImRect@@IPAMMMMHM@Z PROC	; ImGui::DragBehavior

; 7831 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 7832 :     ImGuiContext& g = *GImGui;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	esi
	push	edi

; 7833 :     const ImGuiStyle& style = g.Style;
; 7834 : 
; 7835 :     // Draw frame
; 7836 :     const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : g.HoveredId == id ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);

	mov	edi, DWORD PTR _id$[ebp]
	mov	DWORD PTR _g$1$[ebp], eax
	cmp	DWORD PTR [eax+6264], edi
	jne	SHORT $LN19@DragBehavi
	mov	ecx, 9
	jmp	SHORT $LN20@DragBehavi
$LN19@DragBehavi:
	xor	ecx, ecx
	cmp	DWORD PTR [eax+6252], edi
	sete	cl
	add	ecx, 7
$LN20@DragBehavi:
	movss	xmm1, DWORD PTR __real@3f800000
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	ecx
	movss	DWORD PTR _v1_sign$1$[ebp], xmm1
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32

; 7837 :     RenderNavHighlight(frame_bb, id);

	push	edi
	mov	edi, DWORD PTR _frame_bb$[ebp]
	mov	esi, eax
	push	edi
	call	?RenderNavHighlight@ImGui@@YAXABUImRect@@I@Z ; ImGui::RenderNavHighlight

; 7838 :     RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, style.FrameRounding);

	mov	eax, DWORD PTR _g$1$[ebp]
	add	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR [eax+5364]
	movss	DWORD PTR [esp], xmm0
	push	1
	push	esi
	push	DWORD PTR [edi+12]
	push	DWORD PTR [edi+8]
	push	DWORD PTR [edi+4]
	push	DWORD PTR [edi]
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame

; 7839 : 
; 7840 :     bool value_changed = false;
; 7841 : 
; 7842 :     // Process clicking on the drag
; 7843 :     if (g.ActiveId == id)

	mov	esi, DWORD PTR _g$1$[ebp]
	xor	cl, cl
	mov	eax, DWORD PTR _id$[ebp]
	add	esp, 28					; 0000001cH
	mov	BYTE PTR _value_changed$2$[ebp], cl
	cmp	DWORD PTR [esi+6264], eax
	jne	$LN46@DragBehavi

; 7844 :     {
; 7845 :         if (g.IO.MouseDown[0] || IsNavInputDown(ImGuiNavInput_PadActivate))

	cmp	BYTE PTR [esi+216], cl
	jne	SHORT $LN5@DragBehavi
	push	0
	call	?IsNavInputDown@@YA_NH@Z		; IsNavInputDown
	add	esp, 4
	test	al, al
	jne	SHORT $LN5@DragBehavi

; 7906 :             }
; 7907 :         }
; 7908 :         else
; 7909 :         {
; 7910 :             ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
$LN45@DragBehavi:

; 7911 :         }
; 7912 :     }
; 7913 : 
; 7914 :     return value_changed;

	mov	al, BYTE PTR _value_changed$2$[ebp]
	pop	edi
	pop	esi

; 7915 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@DragBehavi:

; 7846 :         {
; 7847 :             if (g.ActiveIdIsJustActivated)

	cmp	BYTE PTR [esi+6273], 0
	xorps	xmm2, xmm2
	je	SHORT $LN6@DragBehavi

; 7850 :                 g.DragCurrentValue = *v;

	mov	eax, DWORD PTR _v$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T3[ebp], 0
	mov	DWORD PTR $T3[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7850 :                 g.DragCurrentValue = *v;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+10516], eax

; 7851 :                 g.DragLastMouseDelta = ImVec2(0.f, 0.f);

	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR [esi+10520], eax
	mov	eax, DWORD PTR $T3[ebp+4]
	mov	DWORD PTR [esi+10524], eax
$LN6@DragBehavi:

; 7852 :             }
; 7853 : 
; 7854 :             if (v_speed == 0.0f && (v_max - v_min) != 0.0f && (v_max - v_min) < FLT_MAX)

	movss	xmm0, DWORD PTR _v_speed$[ebp]
	ucomiss	xmm0, xmm2
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@DragBehavi
	movss	xmm1, DWORD PTR _v_max$[ebp]
	subss	xmm1, DWORD PTR _v_min$[ebp]
	ucomiss	xmm1, xmm2
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN7@DragBehavi
	movss	xmm0, DWORD PTR __real@7f7fffff
	comiss	xmm0, xmm1
	jbe	SHORT $LN7@DragBehavi

; 7855 :                 v_speed = (v_max - v_min) * g.DragSpeedDefaultRatio;

	movss	xmm0, DWORD PTR [esi+10528]
	mulss	xmm0, xmm1
	movss	DWORD PTR _v_speed$[ebp], xmm0
$LN7@DragBehavi:

; 7856 :             if (g.ActiveIdSource == ImGuiInputSource_Nav)

	mov	edi, DWORD PTR [esi+6292]
	cmp	edi, 2
	jne	SHORT $LN30@DragBehavi

; 7857 :                 v_speed = ImMax(v_speed, GetMinimumStepAtDecimalPrecision(decimal_precision));

	push	DWORD PTR _decimal_precision$[ebp]
	call	?GetMinimumStepAtDecimalPrecision@@YAMH@Z ; GetMinimumStepAtDecimalPrecision
	fstp	DWORD PTR tv400[ebp]
	movss	xmm0, DWORD PTR tv400[ebp]
	add	esp, 4
	maxss	xmm0, DWORD PTR _v_speed$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 128  : static inline float  ImMax(float lhs, float rhs)                                { return lhs >= rhs ? lhs : rhs; }

	movss	DWORD PTR _v_speed$[ebp], xmm0
$LN30@DragBehavi:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7859 :             float v_cur = g.DragCurrentValue;

	movss	xmm0, DWORD PTR [esi+10516]

; 7860 :             const ImVec2 mouse_drag_delta = GetMouseDragDelta(0, 1.0f);

	lea	eax, DWORD PTR _mouse_drag_delta$1[ebp]
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	0
	push	eax
	movss	DWORD PTR _v_cur$1$[ebp], xmm0
	call	?GetMouseDragDelta@ImGui@@YA?AUImVec2@@HM@Z ; ImGui::GetMouseDragDelta
	add	esp, 12					; 0000000cH
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1

; 7861 :             float adjust_delta = 0.0f;
; 7862 :             if (g.ActiveIdSource == ImGuiInputSource_Mouse)

	cmp	edi, 1
	jne	SHORT $LN11@DragBehavi

; 7863 :             {
; 7864 :                 adjust_delta = mouse_drag_delta.x - g.DragLastMouseDelta.x;
; 7865 :                 if (g.IO.KeyShift && g.DragSpeedScaleFast >= 0.0f)

	cmp	BYTE PTR [esi+230], 0
	movss	xmm1, DWORD PTR _mouse_drag_delta$1[ebp]
	subss	xmm1, DWORD PTR [esi+10520]
	je	SHORT $LN10@DragBehavi
	movss	xmm0, DWORD PTR [esi+10536]
	comiss	xmm0, xmm2
	jb	SHORT $LN10@DragBehavi

; 7866 :                     adjust_delta *= g.DragSpeedScaleFast;

	mulss	xmm1, xmm0
$LN10@DragBehavi:

; 7867 :                 if (g.IO.KeyAlt && g.DragSpeedScaleSlow >= 0.0f)

	cmp	BYTE PTR [esi+231], 0
	je	SHORT $LN11@DragBehavi
	movss	xmm0, DWORD PTR [esi+10532]
	comiss	xmm0, xmm2
	jb	SHORT $LN11@DragBehavi

; 7868 :                     adjust_delta *= g.DragSpeedScaleSlow;

	mulss	xmm1, xmm0
$LN11@DragBehavi:

; 7869 :             }
; 7870 :             if (g.ActiveIdSource == ImGuiInputSource_Nav)

	cmp	edi, 2
	jne	SHORT $LN12@DragBehavi

; 7871 :             {
; 7872 :                 adjust_delta = GetNavInputAmount2d(0, ImGuiNavReadMode_RepeatFast, 1.0f/10.0f, 10.0f).x;

	sub	esp, 8
	lea	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR [esp+4], 1092616192		; 41200000H
	mov	DWORD PTR [esp], 1036831949		; 3dcccccdH
	push	5
	push	0
	push	eax
	call	?GetNavInputAmount2d@@YA?AUImVec2@@HW4ImGuiNavReadMode@@MM@Z ; GetNavInputAmount2d
	add	esp, 20					; 00000014H
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR [eax]
$LN12@DragBehavi:

; 7874 :             adjust_delta *= v_speed;

	mulss	xmm1, DWORD PTR _v_speed$[ebp]

; 7875 :             g.DragLastMouseDelta.x = mouse_drag_delta.x;

	movss	xmm0, DWORD PTR _mouse_drag_delta$1[ebp]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 658  :         return (float)fabs(_X);

	movss	xmm3, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7875 :             g.DragLastMouseDelta.x = mouse_drag_delta.x;

	movss	DWORD PTR [esi+10520], xmm0
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 658  :         return (float)fabs(_X);

	movaps	xmm0, xmm1
	andps	xmm0, xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7874 :             adjust_delta *= v_speed;

	movss	DWORD PTR _adjust_delta$2$[ebp], xmm1

; 7876 : 
; 7877 :             if (fabsf(adjust_delta) > 0.0f)

	comiss	xmm0, xmm2
	jbe	$LN47@DragBehavi

; 7879 :                 if (fabsf(power - 1.0f) > 0.001f)

	movss	xmm4, DWORD PTR _power$[ebp]
	movss	xmm5, DWORD PTR __real@3f800000
	movaps	xmm0, xmm4
	subss	xmm0, xmm5
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 658  :         return (float)fabs(_X);

	andps	xmm0, xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7879 :                 if (fabsf(power - 1.0f) > 0.001f)

	comiss	xmm0, DWORD PTR __real@3a83126f
	jbe	SHORT $LN14@DragBehavi

; 7880 :                 {
; 7881 :                     // Logarithmic curve on both side of 0.0
; 7882 :                     float v0_abs = v_cur >= 0.0f ? v_cur : -v_cur;

	movss	xmm0, DWORD PTR _v_cur$1$[ebp]

; 7883 :                     float v0_sign = v_cur >= 0.0f ? 1.0f : -1.0f;

	comiss	xmm0, xmm2
	movaps	xmm1, xmm0
	andps	xmm1, xmm3
	jb	SHORT $LN21@DragBehavi
	movss	DWORD PTR _v0_sign$1$[ebp], xmm5
	jmp	SHORT $LN22@DragBehavi
$LN21@DragBehavi:
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _v0_sign$1$[ebp], xmm0
$LN22@DragBehavi:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 731  :         return (float)pow(_X, _Y);

	movaps	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7884 :                     float v1 = powf(v0_abs, 1.0f / power) + (adjust_delta * v0_sign);

	movaps	xmm1, xmm5
	divss	xmm1, xmm4
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 731  :         return (float)pow(_X, _Y);

	call	___libm_sse2_powf
	movaps	xmm1, xmm0
	xorps	xmm2, xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7884 :                     float v1 = powf(v0_abs, 1.0f / power) + (adjust_delta * v0_sign);

	movss	xmm0, DWORD PTR _v0_sign$1$[ebp]
	mulss	xmm0, DWORD PTR _adjust_delta$2$[ebp]
	addss	xmm1, xmm0

; 7885 :                     float v1_abs = v1 >= 0.0f ? v1 : -v1;
; 7886 :                     float v1_sign = v1 >= 0.0f ? 1.0f : -1.0f;          // Crossed sign line

	comiss	xmm1, xmm2
	movaps	xmm3, xmm1
	andps	xmm3, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
	jae	SHORT $LN24@DragBehavi
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR _v1_sign$1$[ebp], xmm0
$LN24@DragBehavi:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 731  :         return (float)pow(_X, _Y);

	movss	xmm1, DWORD PTR _power$[ebp]
	movaps	xmm0, xmm3
	call	___libm_sse2_powf
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7887 :                     v_cur = powf(v1_abs, power) * v0_sign * v1_sign;    // Reapply sign

	mulss	xmm0, DWORD PTR _v0_sign$1$[ebp]
	mulss	xmm0, DWORD PTR _v1_sign$1$[ebp]

; 7888 :                 }
; 7889 :                 else

	jmp	SHORT $LN15@DragBehavi
$LN14@DragBehavi:

; 7890 :                 {
; 7891 :                     v_cur += adjust_delta;

	addss	xmm1, DWORD PTR _v_cur$1$[ebp]
	movaps	xmm0, xmm1
$LN15@DragBehavi:

; 7892 :                 }
; 7893 : 
; 7894 :                 // Clamp
; 7895 :                 if (v_min < v_max)

	movss	xmm1, DWORD PTR _v_min$[ebp]
	movss	xmm2, DWORD PTR _v_max$[ebp]
	comiss	xmm2, xmm1
	jbe	SHORT $LN41@DragBehavi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm1, xmm0
	jbe	SHORT $LN43@DragBehavi
	movaps	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7897 :                 g.DragCurrentValue = v_cur;

	movss	DWORD PTR [esi+10516], xmm0
	jmp	SHORT $LN13@DragBehavi
$LN43@DragBehavi:
	minss	xmm0, xmm2
$LN41@DragBehavi:
	movss	DWORD PTR [esi+10516], xmm0
	jmp	SHORT $LN13@DragBehavi
$LN47@DragBehavi:
	movss	xmm0, DWORD PTR _v_cur$1$[ebp]
$LN13@DragBehavi:

; 7898 :             }
; 7899 : 
; 7900 :             // Round to user desired precision, then apply
; 7901 :             v_cur = RoundScalar(v_cur, decimal_precision);

	push	DWORD PTR _decimal_precision$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?RoundScalar@ImGui@@YAMMH@Z		; ImGui::RoundScalar

; 7902 :             if (*v != v_cur)

	mov	ecx, DWORD PTR _v$[ebp]
	add	esp, 8
	fstp	DWORD PTR _v_cur$4[ebp]
	movss	xmm1, DWORD PTR _v_cur$4[ebp]
	movss	xmm0, DWORD PTR [ecx]
	ucomiss	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN45@DragBehavi

; 7903 :             {
; 7904 :                 *v = v_cur;

	pop	edi
	movss	DWORD PTR [ecx], xmm1

; 7905 :                 value_changed = true;

	mov	al, 1
	pop	esi

; 7915 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN46@DragBehavi:
	pop	edi

; 7911 :         }
; 7912 :     }
; 7913 : 
; 7914 :     return value_changed;

	mov	al, cl
	pop	esi

; 7915 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DragBehavior@ImGui@@YA_NABUImRect@@IPAMMMMHM@Z ENDP	; ImGui::DragBehavior
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_g$1$ = -4						; size = 4
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_components$ = 16					; size = 4
_v_min$ = 20						; size = 4
_v_max$ = 24						; size = 4
_display_format$ = 28					; size = 4
?SliderIntN@ImGui@@YA_NPBDPAHHHH0@Z PROC		; ImGui::SliderIntN

; 7789 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7791 :     if (window->SkipItems)

	mov	eax, DWORD PTR [ecx+6240]
	cmp	BYTE PTR [eax+137], 0
	je	SHORT $LN5@SliderIntN

; 7792 :         return false;

	xor	al, al

; 7813 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@SliderIntN:

; 7793 : 
; 7794 :     ImGuiContext& g = *GImGui;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _g$1$[ebp], eax

; 7795 :     bool value_changed = false;

	xor	bl, bl

; 7796 :     BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup

; 7797 :     PushID(label);

	push	DWORD PTR _label$[ebp]
	call	?PushID@ImGui@@YAXPBD@Z			; ImGui::PushID

; 7798 :     PushMultiItemsWidths(components);

	mov	edi, DWORD PTR _components$[ebp]
	mov	DWORD PTR [esp], 0
	push	edi
	call	?PushMultiItemsWidths@@YAXHM@Z		; PushMultiItemsWidths
	add	esp, 8

; 7799 :     for (int i = 0; i < components; i++)

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN3@SliderIntN

; 7793 : 
; 7794 :     ImGuiContext& g = *GImGui;

	mov	edi, DWORD PTR _v$[ebp]
$LL4@SliderIntN:

; 7800 :     {
; 7801 :         PushID(i);

	push	esi
	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID

; 7802 :         value_changed |= SliderInt("##v", &v[i], v_min, v_max, display_format);

	push	DWORD PTR _display_format$[ebp]
	push	DWORD PTR _v_max$[ebp]
	push	DWORD PTR _v_min$[ebp]
	push	edi
	push	OFFSET $SG120162
	call	?SliderInt@ImGui@@YA_NPBDPAHHH0@Z	; ImGui::SliderInt
	or	bl, al

; 7803 :         SameLine(0, g.Style.ItemInnerSpacing.x);

	add	esp, 16					; 00000010H
	mov	eax, DWORD PTR _g$1$[ebp]
	movss	xmm0, DWORD PTR [eax+5376]
	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	add	esp, 8

; 7804 :         PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 7805 :         PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth
	inc	esi
	add	edi, 4
	cmp	esi, DWORD PTR _components$[ebp]
	jl	SHORT $LL4@SliderIntN
$LN3@SliderIntN:

; 7806 :     }
; 7807 :     PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 7808 : 
; 7809 :     TextUnformatted(label, FindRenderedTextEnd(label));

	mov	esi, DWORD PTR _label$[ebp]
	push	0
	push	esi
	call	?FindRenderedTextEnd@ImGui@@YAPBDPBD0@Z	; ImGui::FindRenderedTextEnd
	push	eax
	push	esi
	call	?TextUnformatted@ImGui@@YAXPBD0@Z	; ImGui::TextUnformatted
	add	esp, 16					; 00000010H

; 7810 :     EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup
	pop	edi
	pop	esi

; 7811 : 
; 7812 :     return value_changed;

	mov	al, bl
	pop	ebx

; 7813 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SliderIntN@ImGui@@YA_NPBDPAHHHH0@Z ENDP		; ImGui::SliderIntN
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_g$1$ = -4						; size = 4
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_components$ = 16					; size = 4
_v_min$ = 20						; size = 4
_v_max$ = 24						; size = 4
_display_format$ = 28					; size = 4
_power$ = 32						; size = 4
?SliderFloatN@ImGui@@YA_NPBDPAMHMM0M@Z PROC		; ImGui::SliderFloatN

; 7747 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7749 :     if (window->SkipItems)

	mov	eax, DWORD PTR [ecx+6240]
	cmp	BYTE PTR [eax+137], 0
	je	SHORT $LN5@SliderFloa

; 7750 :         return false;

	xor	al, al

; 7771 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@SliderFloa:

; 7751 : 
; 7752 :     ImGuiContext& g = *GImGui;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _g$1$[ebp], eax

; 7753 :     bool value_changed = false;

	xor	bl, bl

; 7754 :     BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup

; 7755 :     PushID(label);

	push	DWORD PTR _label$[ebp]
	call	?PushID@ImGui@@YAXPBD@Z			; ImGui::PushID

; 7756 :     PushMultiItemsWidths(components);

	mov	edi, DWORD PTR _components$[ebp]
	mov	DWORD PTR [esp], 0
	push	edi
	call	?PushMultiItemsWidths@@YAXHM@Z		; PushMultiItemsWidths
	add	esp, 8

; 7757 :     for (int i = 0; i < components; i++)

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN3@SliderFloa
$LL4@SliderFloa:

; 7758 :     {
; 7759 :         PushID(i);

	push	esi
	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID

; 7760 :         value_changed |= SliderFloat("##v", &v[i], v_min, v_max, display_format, power);

	movss	xmm0, DWORD PTR _power$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _display_format$[ebp]
	movss	xmm0, DWORD PTR _v_max$[ebp]
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _v_min$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _v$[ebp]
	push	OFFSET $SG120121
	call	?SliderFloat@ImGui@@YA_NPBDPAMMM0M@Z	; ImGui::SliderFloat
	or	bl, al

; 7761 :         SameLine(0, g.Style.ItemInnerSpacing.x);

	add	esp, 16					; 00000010H
	mov	eax, DWORD PTR _g$1$[ebp]
	movss	xmm0, DWORD PTR [eax+5376]
	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	add	esp, 8

; 7762 :         PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 7763 :         PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth
	add	DWORD PTR _v$[ebp], 4
	inc	esi
	cmp	esi, edi
	jl	SHORT $LL4@SliderFloa
$LN3@SliderFloa:

; 7764 :     }
; 7765 :     PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 7766 : 
; 7767 :     TextUnformatted(label, FindRenderedTextEnd(label));

	mov	esi, DWORD PTR _label$[ebp]
	push	0
	push	esi
	call	?FindRenderedTextEnd@ImGui@@YAPBDPBD0@Z	; ImGui::FindRenderedTextEnd
	push	eax
	push	esi
	call	?TextUnformatted@ImGui@@YAXPBD0@Z	; ImGui::TextUnformatted
	add	esp, 16					; 00000010H

; 7768 :     EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup
	pop	edi
	pop	esi

; 7769 : 
; 7770 :     return value_changed;

	mov	al, bl
	pop	ebx

; 7771 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SliderFloatN@ImGui@@YA_NPBDPAMHMM0M@Z ENDP		; ImGui::SliderFloatN
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_grab_bb$ = -80						; size = 16
_window$1$ = -64					; size = 4
$T1 = -60						; size = 8
$T2 = -60						; size = 8
_grab_pos$1$ = -56					; size = 4
$T3 = -52						; size = 16
$T4 = -44						; size = 8
_grab_sz$1$ = -40					; size = 4
$T5 = -36						; size = 16
$T6 = -28						; size = 8
_slider_usable_pos_min$1$ = -24				; size = 4
_delta2$7 = -20						; size = 8
tv662 = -16						; size = 4
_clicked_t$8 = -16					; size = 4
_delta$2$ = -12						; size = 4
_slider_usable_sz$1$ = -12				; size = 4
_g$1$ = -12						; size = 4
_linear_zero_pos$1$ = -8				; size = 4
_value_changed$1$ = -1					; size = 1
tv666 = 8						; size = 4
tv665 = 8						; size = 4
_frame_bb$ = 8						; size = 4
_is_non_linear$1$ = 11					; size = 1
_id$ = 12						; size = 4
_v$ = 16						; size = 4
_v_min$ = 20						; size = 4
_grab_t$ = 24						; size = 4
_v_max$ = 24						; size = 4
_power$ = 28						; size = 4
_new_value$9 = 32					; size = 4
_decimal_precision$ = 32				; size = 4
_flags$ = 36						; size = 4
?SliderBehavior@ImGui@@YA_NABUImRect@@IPAMMMMHH@Z PROC	; ImGui::SliderBehavior

; 7465 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 7466 :     ImGuiContext& g = *GImGui;

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	esi
	push	edi

; 7471 :     const ImU32 frame_col = GetColorU32((g.ActiveId == id && g.ActiveIdSource == ImGuiInputSource_Nav) ? ImGuiCol_FrameBgActive : ImGuiCol_FrameBg);

	mov	edi, DWORD PTR _id$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7466 :     ImGuiContext& g = *GImGui;

	mov	DWORD PTR _g$1$[ebp], ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	BYTE PTR [eax+134], 1
	mov	eax, DWORD PTR [ecx+6240]
	mov	DWORD PTR _window$1$[ebp], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7471 :     const ImU32 frame_col = GetColorU32((g.ActiveId == id && g.ActiveIdSource == ImGuiInputSource_Nav) ? ImGuiCol_FrameBgActive : ImGuiCol_FrameBg);

	cmp	DWORD PTR [ecx+6264], edi
	jne	SHORT $LN32@SliderBeha
	cmp	DWORD PTR [ecx+6292], 2
	mov	eax, 9
	je	SHORT $LN33@SliderBeha
$LN32@SliderBeha:
	mov	eax, 7
$LN33@SliderBeha:
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	eax
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32

; 7472 :     RenderNavHighlight(frame_bb, id);

	push	edi
	mov	edi, DWORD PTR _frame_bb$[ebp]
	mov	esi, eax
	push	edi
	call	?RenderNavHighlight@ImGui@@YAXABUImRect@@I@Z ; ImGui::RenderNavHighlight

; 7473 :     RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, style.FrameRounding);

	mov	eax, DWORD PTR _g$1$[ebp]
	add	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR [eax+5364]
	movss	DWORD PTR [esp], xmm0
	push	1
	push	esi
	push	DWORD PTR [edi+12]
	push	DWORD PTR [edi+8]
	push	DWORD PTR [edi+4]
	push	DWORD PTR [edi]
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame

; 7474 : 
; 7475 :     const bool is_non_linear = (power < 1.0f-0.00001f) || (power > 1.0f+0.00001f);

	movss	xmm0, DWORD PTR __real@3f7fff58
	add	esp, 28					; 0000001cH
	movss	xmm7, DWORD PTR _power$[ebp]
	comiss	xmm0, xmm7
	ja	SHORT $LN34@SliderBeha
	comiss	xmm7, DWORD PTR __real@3f800054
	mov	BYTE PTR _is_non_linear$1$[ebp], 0
	jbe	SHORT $LN35@SliderBeha
$LN34@SliderBeha:
	mov	BYTE PTR _is_non_linear$1$[ebp], 1
$LN35@SliderBeha:

; 7476 :     const bool is_horizontal = (flags & ImGuiSliderFlags_Vertical) == 0;

	mov	al, BYTE PTR _flags$[ebp]
	not	al
	and	al, 1
	mov	BYTE PTR _flags$[ebp], al

; 7479 :     const float slider_sz = is_horizontal ? (frame_bb.GetWidth() - grab_padding * 2.0f) : (frame_bb.GetHeight() - grab_padding * 2.0f);

	je	SHORT $LN36@SliderBeha
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 246  :     float       GetWidth() const                { return Max.x-Min.x; }

	movss	xmm2, DWORD PTR [edi+8]
	subss	xmm2, DWORD PTR [edi]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7479 :     const float slider_sz = is_horizontal ? (frame_bb.GetWidth() - grab_padding * 2.0f) : (frame_bb.GetHeight() - grab_padding * 2.0f);

	jmp	SHORT $LN136@SliderBeha
$LN36@SliderBeha:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 247  :     float       GetHeight() const               { return Max.y-Min.y; }

	movss	xmm2, DWORD PTR [edi+12]
	subss	xmm2, DWORD PTR [edi+4]
$LN136@SliderBeha:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7481 :     if (decimal_precision > 0)

	cmp	DWORD PTR _decimal_precision$[ebp], 0
	subss	xmm2, DWORD PTR __real@40800000

; 7482 :         grab_sz = ImMin(style.GrabMinSize, slider_sz);
; 7483 :     else

	movss	xmm3, DWORD PTR _v_min$[ebp]
	movss	xmm4, DWORD PTR _v_max$[ebp]
	jle	SHORT $LN2@SliderBeha
	mov	esi, DWORD PTR _g$1$[ebp]
	movss	xmm1, DWORD PTR [esi+5408]
	jmp	SHORT $LN137@SliderBeha
$LN2@SliderBeha:

; 7484 :         grab_sz = ImMin(ImMax(1.0f * (slider_sz / ((v_min < v_max ? v_max - v_min : v_min - v_max) + 1.0f)), style.GrabMinSize), slider_sz);  // Integer sliders, if possible have the grab size represent 1 unit

	comiss	xmm4, xmm3
	jbe	SHORT $LN38@SliderBeha
	movaps	xmm0, xmm4
	subss	xmm0, xmm3
	jmp	SHORT $LN39@SliderBeha
$LN38@SliderBeha:
	movaps	xmm0, xmm3
	subss	xmm0, xmm4
$LN39@SliderBeha:
	addss	xmm0, DWORD PTR __real@3f800000
	movaps	xmm1, xmm2
	mov	esi, DWORD PTR _g$1$[ebp]
	divss	xmm1, xmm0
	maxss	xmm1, DWORD PTR [esi+5408]
$LN137@SliderBeha:

; 7485 :     const float slider_usable_sz = slider_sz - grab_sz;

	minss	xmm1, xmm2
	subss	xmm2, xmm1
	movss	DWORD PTR _slider_usable_sz$1$[ebp], xmm2

; 7486 :     const float slider_usable_pos_min = (is_horizontal ? frame_bb.Min.x : frame_bb.Min.y) + grab_padding + grab_sz*0.5f;

	test	al, al
	je	SHORT $LN40@SliderBeha
	movss	xmm5, DWORD PTR [edi]
	jmp	SHORT $LN41@SliderBeha
$LN40@SliderBeha:
	movss	xmm5, DWORD PTR [edi+4]
$LN41@SliderBeha:
	movss	xmm6, DWORD PTR __real@40000000
	mulss	xmm1, DWORD PTR __real@3f000000
	addss	xmm5, xmm6
	movss	DWORD PTR _grab_sz$1$[ebp], xmm1
	addss	xmm5, xmm1
	movss	DWORD PTR _slider_usable_pos_min$1$[ebp], xmm5

; 7487 :     const float slider_usable_pos_max = (is_horizontal ? frame_bb.Max.x : frame_bb.Max.y) - grab_padding - grab_sz*0.5f;

	test	al, al
	je	SHORT $LN42@SliderBeha
	movss	xmm0, DWORD PTR [edi+8]
	jmp	SHORT $LN43@SliderBeha
$LN42@SliderBeha:
	movss	xmm0, DWORD PTR [edi+12]
$LN43@SliderBeha:
	subss	xmm0, xmm6
	subss	xmm0, xmm1
	movss	DWORD PTR _grab_pos$1$[ebp], xmm0

; 7488 : 
; 7489 :     // For logarithmic sliders that cross over sign boundary we want the exponential increase to be symmetric around 0.0f
; 7490 :     float linear_zero_pos = 0.0f;   // 0.0->1.0f
; 7491 :     if (v_min * v_max < 0.0f)

	movaps	xmm0, xmm3
	mulss	xmm0, xmm4
	xorps	xmm4, xmm4
	comiss	xmm4, xmm0
	jbe	SHORT $LN4@SliderBeha

; 7494 :         const float linear_dist_min_to_0 = powf(fabsf(0.0f - v_min), 1.0f/power);

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 658  :         return (float)fabs(_X);

	movaps	xmm0, xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7494 :         const float linear_dist_min_to_0 = powf(fabsf(0.0f - v_min), 1.0f/power);

	divss	xmm1, xmm7
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 658  :         return (float)fabs(_X);

	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	andps	xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7494 :         const float linear_dist_min_to_0 = powf(fabsf(0.0f - v_min), 1.0f/power);

	movss	DWORD PTR tv662[ebp], xmm1
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 731  :         return (float)pow(_X, _Y);

	call	___libm_sse2_powf
	movss	xmm1, DWORD PTR tv662[ebp]
	movss	DWORD PTR _linear_zero_pos$1$[ebp], xmm0

; 658  :         return (float)fabs(_X);

	movss	xmm0, DWORD PTR _v_max$[ebp]
	andps	xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff

; 731  :         return (float)pow(_X, _Y);

	call	___libm_sse2_powf
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7496 :         linear_zero_pos = linear_dist_min_to_0 / (linear_dist_min_to_0+linear_dist_max_to_0);

	movss	xmm1, DWORD PTR _linear_zero_pos$1$[ebp]
	xorps	xmm4, xmm4
	addss	xmm0, xmm1

; 7497 :     }
; 7498 :     else

	movss	xmm2, DWORD PTR _slider_usable_sz$1$[ebp]
	movss	xmm5, DWORD PTR _slider_usable_pos_min$1$[ebp]
	mov	al, BYTE PTR _flags$[ebp]
	divss	xmm1, xmm0
	movss	DWORD PTR _linear_zero_pos$1$[ebp], xmm1
	jmp	SHORT $LN45@SliderBeha
$LN4@SliderBeha:

; 7499 :     {
; 7500 :         // Same sign
; 7501 :         linear_zero_pos = v_min < 0.0f ? 1.0f : 0.0f;

	comiss	xmm4, xmm3
	jbe	SHORT $LN44@SliderBeha
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _linear_zero_pos$1$[ebp], xmm0
	jmp	SHORT $LN45@SliderBeha
$LN44@SliderBeha:
	movss	DWORD PTR _linear_zero_pos$1$[ebp], xmm4
$LN45@SliderBeha:

; 7502 :     }
; 7503 : 
; 7504 :     // Process clicking on the slider
; 7505 :     bool value_changed = false;
; 7506 :     if (g.ActiveId == id)

	mov	ecx, DWORD PTR _id$[ebp]
	mov	BYTE PTR _value_changed$1$[ebp], 0
	cmp	DWORD PTR [esi+6264], ecx
	jne	$LN134@SliderBeha

; 7507 :     {
; 7508 :         bool set_new_value = false;
; 7509 :         float clicked_t = 0.0f;
; 7510 :         if (g.ActiveIdSource == ImGuiInputSource_Mouse && g.IO.MouseDown[0])

	mov	ecx, DWORD PTR [esi+6292]
	cmp	ecx, 1
	jne	SHORT $LN7@SliderBeha
	cmp	BYTE PTR [esi+216], 0
	je	SHORT $LN7@SliderBeha

; 7511 :         {
; 7512 :             const float mouse_abs_pos = is_horizontal ? g.IO.MousePos.x : g.IO.MousePos.y;

	test	al, al
	je	SHORT $LN46@SliderBeha
	movss	xmm1, DWORD PTR [esi+208]
	jmp	SHORT $LN47@SliderBeha
$LN46@SliderBeha:
	movss	xmm1, DWORD PTR [esi+212]
$LN47@SliderBeha:

; 7513 :             clicked_t = (slider_usable_sz > 0.0f) ? ImClamp((mouse_abs_pos - slider_usable_pos_min) / slider_usable_sz, 0.0f, 1.0f) : 0.0f;

	comiss	xmm2, xmm4
	jbe	SHORT $LN48@SliderBeha
	subss	xmm1, xmm5
	divss	xmm1, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm4, xmm1
	ja	SHORT $LN48@SliderBeha
	minss	xmm1, DWORD PTR __real@3f800000
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7513 :             clicked_t = (slider_usable_sz > 0.0f) ? ImClamp((mouse_abs_pos - slider_usable_pos_min) / slider_usable_sz, 0.0f, 1.0f) : 0.0f;

	jmp	SHORT $LN49@SliderBeha
$LN48@SliderBeha:
	xorps	xmm1, xmm1
$LN49@SliderBeha:

; 7516 :             set_new_value = true;

	mov	dl, BYTE PTR _is_non_linear$1$[ebp]
	test	al, al
	jne	$LN128@SliderBeha

; 7514 :             if (!is_horizontal)
; 7515 :                 clicked_t = 1.0f - clicked_t;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, xmm1
	movaps	xmm1, xmm0

; 7516 :             set_new_value = true;

	jmp	$LN128@SliderBeha
$LN7@SliderBeha:

; 7517 :         }
; 7518 :         else if (g.ActiveIdSource == ImGuiInputSource_Nav && IsNavInputDown(ImGuiNavInput_PadActivate))

	cmp	ecx, 2
	jne	$LN10@SliderBeha
	push	0
	call	?IsNavInputDown@@YA_NH@Z		; IsNavInputDown
	add	esp, 4
	test	al, al
	je	$LN10@SliderBeha

; 7519 :         {
; 7520 :             const ImVec2 delta2 = GetNavInputAmount2d(0, ImGuiNavReadMode_RepeatFast, 0.0f, 0.0f);

	sub	esp, 8
	lea	eax, DWORD PTR _delta2$7[ebp]
	mov	DWORD PTR [esp+4], 0
	mov	DWORD PTR [esp], 0
	push	5
	push	0
	push	eax
	call	?GetNavInputAmount2d@@YA?AUImVec2@@HW4ImGuiNavReadMode@@MM@Z ; GetNavInputAmount2d
	add	esp, 20					; 00000014H

; 7521 :             if (float delta = is_horizontal ? delta2.x : -delta2.y)

	cmp	BYTE PTR _flags$[ebp], 0
	je	SHORT $LN50@SliderBeha
	movss	xmm0, DWORD PTR _delta2$7[ebp]
	jmp	SHORT $LN138@SliderBeha
$LN50@SliderBeha:
	movss	xmm0, DWORD PTR _delta2$7[ebp+4]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
$LN138@SliderBeha:
	ucomiss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR _delta$2$[ebp], xmm0
	lahf
	test	ah, 68					; 00000044H

; 7522 :             {
; 7523 :                 clicked_t = SliderBehaviorCalcRatioFromValue(*v, v_min, v_max, power, linear_zero_pos);

	mov	eax, DWORD PTR _v$[ebp]
	jnp	$LN27@SliderBeha
	movss	xmm0, DWORD PTR _linear_zero_pos$1$[ebp]
	sub	esp, 20					; 00000014H
	movss	DWORD PTR [esp+16], xmm0
	movss	xmm0, DWORD PTR _power$[ebp]
	movss	DWORD PTR [esp+12], xmm0
	movss	xmm0, DWORD PTR _v_max$[ebp]
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _v_min$[ebp]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [esp], xmm0
	call	?SliderBehaviorCalcRatioFromValue@@YAMMMMMM@Z ; SliderBehaviorCalcRatioFromValue

; 7524 :                 if (decimal_precision == 0 && !is_non_linear)

	mov	dl, BYTE PTR _is_non_linear$1$[ebp]
	add	esp, 20					; 00000014H
	cmp	DWORD PTR _decimal_precision$[ebp], 0
	fstp	DWORD PTR _clicked_t$8[ebp]
	jne	SHORT $LN13@SliderBeha
	test	dl, dl
	jne	SHORT $LN13@SliderBeha

; 7526 :                     if (fabsf(v_max - v_min) <= 100.0f || IsNavInputDown(ImGuiNavInput_PadTweakSlow))

	movss	xmm2, DWORD PTR _v_max$[ebp]
	subss	xmm2, DWORD PTR _v_min$[ebp]
	movss	xmm0, DWORD PTR __real@42c80000
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 658  :         return (float)fabs(_X);

	movaps	xmm1, xmm2
	andps	xmm1, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7526 :                     if (fabsf(v_max - v_min) <= 100.0f || IsNavInputDown(ImGuiNavInput_PadTweakSlow))

	comiss	xmm0, xmm1
	jae	SHORT $LN17@SliderBeha
	push	14					; 0000000eH
	call	?IsNavInputDown@@YA_NH@Z		; IsNavInputDown
	add	esp, 4
	test	al, al
	jne	SHORT $LN17@SliderBeha

; 7528 :                     else
; 7529 :                         delta /= 100.0f;

	movss	xmm1, DWORD PTR _delta$2$[ebp]
	mulss	xmm1, DWORD PTR __real@3c23d70a
	jmp	SHORT $LN130@SliderBeha
$LN17@SliderBeha:
	xorps	xmm4, xmm4

; 7527 :                         delta = ((delta < 0.0f) ? -1.0f : +1.0f) / (v_max - v_min); // Gamepad/keyboard tweak speeds in integer steps

	comiss	xmm4, DWORD PTR _delta$2$[ebp]
	jbe	SHORT $LN52@SliderBeha
	movss	xmm1, DWORD PTR __real@bf800000
	divss	xmm1, xmm2

; 7530 :                 }
; 7531 :                 else

	jmp	SHORT $LN18@SliderBeha
$LN52@SliderBeha:

; 7527 :                         delta = ((delta < 0.0f) ? -1.0f : +1.0f) / (v_max - v_min); // Gamepad/keyboard tweak speeds in integer steps

	movss	xmm1, DWORD PTR __real@3f800000
	divss	xmm1, xmm2

; 7530 :                 }
; 7531 :                 else

	jmp	SHORT $LN18@SliderBeha
$LN13@SliderBeha:

; 7532 :                 {
; 7533 :                     delta /= 100.0f;    // Gamepad/keyboard tweak speeds in % of slider bounds

	movss	xmm1, DWORD PTR _delta$2$[ebp]
	mulss	xmm1, DWORD PTR __real@3c23d70a

; 7534 :                     if (IsNavInputDown(ImGuiNavInput_PadTweakSlow))

	push	14					; 0000000eH
	call	?IsNavInputDown@@YA_NH@Z		; IsNavInputDown
	add	esp, 4
	test	al, al
	je	SHORT $LN130@SliderBeha

; 7535 :                         delta /= 10.0f;

	mulss	xmm1, DWORD PTR __real@3dcccccd
$LN130@SliderBeha:
	xorps	xmm4, xmm4
$LN18@SliderBeha:

; 7536 :                 }
; 7537 :                 if (IsNavInputDown(ImGuiNavInput_PadTweakFast))

	push	15					; 0000000fH
	call	?IsNavInputDown@@YA_NH@Z		; IsNavInputDown
	add	esp, 4
	test	al, al
	je	SHORT $LN19@SliderBeha

; 7538 :                     delta *= 10.0f;

	mulss	xmm1, DWORD PTR __real@41200000
$LN19@SliderBeha:

; 7539 :                 clicked_t = ImSaturate(clicked_t + delta); // FIXME-NAVIGATION: todo: cancel adjustment if current value already past edge and we are moving in edge direction, to avoid clamping value to edge.

	addss	xmm1, DWORD PTR _clicked_t$8[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?ImSaturate@@YAMM@Z			; ImSaturate
	fstp	DWORD PTR _clicked_t$8[ebp]
	movss	xmm1, DWORD PTR _clicked_t$8[ebp]
	add	esp, 4
$LN128@SliderBeha:

; 7546 :         }
; 7547 : 
; 7548 :         if (set_new_value)
; 7549 :         {
; 7550 :             float new_value;
; 7551 :             if (is_non_linear)

	test	dl, dl
	je	$LN21@SliderBeha

; 7552 :             {
; 7553 :                 // Account for logarithmic scale on both sides of the zero
; 7554 :                 if (clicked_t < linear_zero_pos)

	movss	xmm2, DWORD PTR _linear_zero_pos$1$[ebp]
	comiss	xmm2, xmm1
	jbe	SHORT $LN23@SliderBeha

; 7555 :                 {
; 7556 :                     // Negative: rescale to the negative range before powering
; 7557 :                     float a = 1.0f - (clicked_t / linear_zero_pos);

	movss	xmm0, DWORD PTR _v_max$[ebp]
	divss	xmm1, xmm2
	minss	xmm0, xmm4
	movss	DWORD PTR tv665[ebp], xmm0
	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, xmm1
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 731  :         return (float)pow(_X, _Y);

	movss	xmm1, DWORD PTR _power$[ebp]
	call	___libm_sse2_powf
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 135  : static inline float  ImLerp(float a, float b, float t)                          { return a + (b - a) * t; }

	movss	xmm1, DWORD PTR _v_min$[ebp]
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 731  :         return (float)pow(_X, _Y);

	movaps	xmm3, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 135  : static inline float  ImLerp(float a, float b, float t)                          { return a + (b - a) * t; }

	subss	xmm1, DWORD PTR tv665[ebp]
	mulss	xmm3, xmm1
	addss	xmm3, DWORD PTR tv665[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7561 :                 else

	jmp	SHORT $LN22@SliderBeha
$LN23@SliderBeha:

; 7565 :                     if (fabsf(linear_zero_pos - 1.0f) > 1.e-6f)

	movaps	xmm0, xmm2
	subss	xmm0, DWORD PTR __real@3f800000
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 658  :         return (float)fabs(_X);

	andps	xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7565 :                     if (fabsf(linear_zero_pos - 1.0f) > 1.e-6f)

	comiss	xmm0, DWORD PTR __real@358637bd
	jbe	SHORT $LN25@SliderBeha

; 7566 :                         a = (clicked_t - linear_zero_pos) / (1.0f - linear_zero_pos);

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm1, xmm2
	subss	xmm0, xmm2
	divss	xmm1, xmm0
$LN25@SliderBeha:
	movss	xmm0, DWORD PTR _v_min$[ebp]
	maxss	xmm0, xmm4
	movss	DWORD PTR tv666[ebp], xmm0
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 731  :         return (float)pow(_X, _Y);

	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR _power$[ebp]
	call	___libm_sse2_powf
	movaps	xmm3, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 135  : static inline float  ImLerp(float a, float b, float t)                          { return a + (b - a) * t; }

	movss	xmm0, DWORD PTR _v_max$[ebp]
	subss	xmm0, DWORD PTR tv666[ebp]
	mulss	xmm3, xmm0
	addss	xmm3, DWORD PTR tv666[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7573 :             else

	jmp	SHORT $LN22@SliderBeha
$LN21@SliderBeha:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 135  : static inline float  ImLerp(float a, float b, float t)                          { return a + (b - a) * t; }

	movss	xmm3, DWORD PTR _v_max$[ebp]
	subss	xmm3, DWORD PTR _v_min$[ebp]
	mulss	xmm3, xmm1
	addss	xmm3, DWORD PTR _v_min$[ebp]
$LN22@SliderBeha:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7580 :             new_value = RoundScalar(new_value, decimal_precision);

	push	DWORD PTR _decimal_precision$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm3
	call	?RoundScalar@ImGui@@YAMMH@Z		; ImGui::RoundScalar

; 7581 :             if (*v != new_value)

	mov	eax, DWORD PTR _v$[ebp]
	add	esp, 8
	fstp	DWORD PTR _new_value$9[ebp]
	movss	xmm1, DWORD PTR _new_value$9[ebp]
	movss	xmm0, DWORD PTR [eax]
	ucomiss	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H

; 7582 :             {
; 7583 :                 *v = new_value;

	mov	eax, DWORD PTR _v$[ebp]
	jnp	SHORT $LN27@SliderBeha
	movss	DWORD PTR [eax], xmm1

; 7584 :                 value_changed = true;

	mov	BYTE PTR _value_changed$1$[ebp], 1
	jmp	SHORT $LN27@SliderBeha
$LN10@SliderBeha:

; 7540 :                 set_new_value = true;
; 7541 :             }
; 7542 :         }
; 7543 :         else
; 7544 :         {
; 7545 :             ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
$LN134@SliderBeha:
	mov	eax, DWORD PTR _v$[ebp]
$LN27@SliderBeha:

; 7585 :             }
; 7586 :         }
; 7587 :     }
; 7588 : 
; 7589 :     // Draw
; 7590 :     float grab_t = SliderBehaviorCalcRatioFromValue(*v, v_min, v_max, power, linear_zero_pos);

	movss	xmm0, DWORD PTR _linear_zero_pos$1$[ebp]
	sub	esp, 20					; 00000014H
	movss	DWORD PTR [esp+16], xmm0
	movss	xmm0, DWORD PTR _power$[ebp]
	movss	DWORD PTR [esp+12], xmm0
	movss	xmm0, DWORD PTR _v_max$[ebp]
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _v_min$[ebp]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [esp], xmm0
	call	?SliderBehaviorCalcRatioFromValue@@YAMMMMMM@Z ; SliderBehaviorCalcRatioFromValue

; 7591 :     if (!is_horizontal)

	mov	al, BYTE PTR _flags$[ebp]
	add	esp, 20					; 00000014H
	fstp	DWORD PTR _grab_t$[ebp]
	test	al, al
	jne	SHORT $LN129@SliderBeha

; 7592 :         grab_t = 1.0f - grab_t;

	movss	xmm0, DWORD PTR __real@3f800000
	subss	xmm0, DWORD PTR _grab_t$[ebp]
	jmp	SHORT $LN28@SliderBeha
$LN129@SliderBeha:
	movss	xmm0, DWORD PTR _grab_t$[ebp]
$LN28@SliderBeha:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 135  : static inline float  ImLerp(float a, float b, float t)                          { return a + (b - a) * t; }

	movss	xmm1, DWORD PTR _grab_pos$1$[ebp]
	subss	xmm1, DWORD PTR _slider_usable_pos_min$1$[ebp]
	mulss	xmm1, xmm0
	addss	xmm1, DWORD PTR _slider_usable_pos_min$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7595 :     if (is_horizontal)

	test	al, al
	je	SHORT $LN29@SliderBeha

; 7596 :         grab_bb = ImRect(ImVec2(grab_pos - grab_sz*0.5f, frame_bb.Min.y + grab_padding), ImVec2(grab_pos + grab_sz*0.5f, frame_bb.Max.y - grab_padding));

	movss	xmm2, DWORD PTR _grab_sz$1$[ebp]
	movaps	xmm0, xmm2
	addss	xmm0, xmm1
	subss	xmm1, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7596 :         grab_bb = ImRect(ImVec2(grab_pos - grab_sz*0.5f, frame_bb.Min.y + grab_padding), ImVec2(grab_pos + grab_sz*0.5f, frame_bb.Max.y - grab_padding));

	movss	xmm0, DWORD PTR [edi+12]
	subss	xmm0, DWORD PTR __real@40000000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T5[ebp], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7596 :         grab_bb = ImRect(ImVec2(grab_pos - grab_sz*0.5f, frame_bb.Min.y + grab_padding), ImVec2(grab_pos + grab_sz*0.5f, frame_bb.Max.y - grab_padding));

	movss	xmm0, DWORD PTR [edi+4]
	addss	xmm0, DWORD PTR __real@40000000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T2[ebp+4]
	mov	DWORD PTR $T5[ebp+4], eax
	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T5[ebp+8], eax
	mov	eax, DWORD PTR $T4[ebp+4]
	mov	DWORD PTR $T5[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7596 :         grab_bb = ImRect(ImVec2(grab_pos - grab_sz*0.5f, frame_bb.Min.y + grab_padding), ImVec2(grab_pos + grab_sz*0.5f, frame_bb.Max.y - grab_padding));

	movups	xmm0, XMMWORD PTR $T5[ebp]

; 7597 :     else

	jmp	SHORT $LN139@SliderBeha
$LN29@SliderBeha:

; 7598 :         grab_bb = ImRect(ImVec2(frame_bb.Min.x + grab_padding, grab_pos - grab_sz*0.5f), ImVec2(frame_bb.Max.x - grab_padding, grab_pos + grab_sz*0.5f));

	movss	xmm0, DWORD PTR [edi+8]
	subss	xmm0, DWORD PTR __real@40000000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T6[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7598 :         grab_bb = ImRect(ImVec2(frame_bb.Min.x + grab_padding, grab_pos - grab_sz*0.5f), ImVec2(frame_bb.Max.x - grab_padding, grab_pos + grab_sz*0.5f));

	movss	xmm0, DWORD PTR _grab_sz$1$[ebp]
	addss	xmm0, xmm1
	subss	xmm1, DWORD PTR _grab_sz$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T6[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7598 :         grab_bb = ImRect(ImVec2(frame_bb.Min.x + grab_padding, grab_pos - grab_sz*0.5f), ImVec2(frame_bb.Max.x - grab_padding, grab_pos + grab_sz*0.5f));

	movss	xmm0, DWORD PTR [edi]
	addss	xmm0, DWORD PTR __real@40000000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm1
	movss	DWORD PTR $T1[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	eax, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR $T3[ebp+4], eax
	mov	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR $T3[ebp+8], eax
	mov	eax, DWORD PTR $T6[ebp+4]
	mov	DWORD PTR $T3[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7598 :         grab_bb = ImRect(ImVec2(frame_bb.Min.x + grab_padding, grab_pos - grab_sz*0.5f), ImVec2(frame_bb.Max.x - grab_padding, grab_pos + grab_sz*0.5f));

	movups	xmm0, XMMWORD PTR $T3[ebp]
$LN139@SliderBeha:

; 7599 :     window->DrawList->AddRectFilled(grab_bb.Min, grab_bb.Max, GetColorU32(g.ActiveId == id ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab), style.GrabRounding);

	mov	ecx, DWORD PTR _id$[ebp]
	xor	eax, eax
	push	-1
	sub	esp, 8
	movups	XMMWORD PTR _grab_bb$[ebp], xmm0
	cmp	DWORD PTR [esi+6264], ecx
	movss	xmm0, DWORD PTR [esi+5412]
	sete	al
	movss	DWORD PTR [esp+4], xmm0
	add	eax, 20					; 00000014H
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	eax
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	ecx, DWORD PTR _window$1$[ebp]
	add	esp, 8
	mov	ecx, DWORD PTR [ecx+624]
	push	eax
	lea	eax, DWORD PTR _grab_bb$[ebp+8]
	push	eax
	lea	eax, DWORD PTR _grab_bb$[ebp]
	push	eax
	call	?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 7600 : 
; 7601 :     return value_changed;

	mov	al, BYTE PTR _value_changed$1$[ebp]
	pop	edi
	pop	esi

; 7602 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SliderBehavior@ImGui@@YA_NABUImRect@@IPAMMMMHH@Z ENDP	; ImGui::SliderBehavior
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_bb$ = -44						; size = 16
$T1 = -28						; size = 8
$T2 = -28						; size = 8
$T3 = -28						; size = 8
$T4 = -20						; size = 8
$T5 = -20						; size = 8
$T6 = -20						; size = 8
_center$ = -12						; size = 8
_pressed$1$ = -2					; size = 1
_held$ = -1						; size = 1
_id$ = 8						; size = 4
tv376 = 12						; size = 4
_pos$ = 12						; size = 4
_hovered$ = 15						; size = 1
_radius$ = 16						; size = 4
?CloseButton@ImGui@@YA_NIABUImVec2@@M@Z PROC		; ImGui::CloseButton

; 6673 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm3, DWORD PTR _radius$[ebp]
	push	esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6677 :     if (!ItemAdd(bb, &id)) // To allow navigation

	push	0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	mov	eax, DWORD PTR _pos$[ebp]

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	esi, DWORD PTR [ecx+6240]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm2, DWORD PTR [eax]
	movss	xmm1, DWORD PTR [eax+4]
	movaps	xmm0, xmm2
	addss	xmm0, xmm3

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm2, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movaps	xmm0, xmm1

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm1, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T6[ebp], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T6[ebp]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm3

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _bb$[ebp], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T6[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T6[ebp+4]
	mov	DWORD PTR _bb$[ebp+4], eax
	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR _bb$[ebp+8], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T3[ebp+4]
	mov	DWORD PTR _bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6677 :     if (!ItemAdd(bb, &id)) // To allow navigation

	lea	eax, DWORD PTR _id$[ebp]
	push	eax
	lea	eax, DWORD PTR _bb$[ebp]
	push	eax
	call	?ItemAdd@ImGui@@YA_NABUImRect@@PBIPBU2@@Z ; ImGui::ItemAdd
	add	esp, 12					; 0000000cH
	test	al, al
	jne	SHORT $LN2@CloseButto
	pop	esi

; 6696 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@CloseButto:

; 6678 :         return false;
; 6679 : 
; 6680 :     bool hovered, held;
; 6681 :     bool pressed = ButtonBehavior(bb, id, &hovered, &held);

	push	0
	lea	eax, DWORD PTR _held$[ebp]
	push	eax
	lea	eax, DWORD PTR _hovered$[ebp]
	push	eax
	push	DWORD PTR _id$[ebp]
	lea	eax, DWORD PTR _bb$[ebp]
	push	eax
	call	?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z ; ImGui::ButtonBehavior

; 6684 :     const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_CloseButtonActive : hovered ? ImGuiCol_CloseButtonHovered : ImGuiCol_CloseButton);

	mov	dl, BYTE PTR _hovered$[ebp]
	add	esp, 20					; 00000014H
	cmp	BYTE PTR _held$[ebp], 0
	mov	BYTE PTR _pressed$1$[ebp], al
	je	SHORT $LN5@CloseButto
	test	dl, dl
	je	SHORT $LN5@CloseButto
	mov	ecx, 36					; 00000024H
	jmp	SHORT $LN6@CloseButto
$LN5@CloseButto:
	xor	ecx, ecx
	test	dl, dl
	setne	cl
	add	ecx, 34					; 00000022H
$LN6@CloseButto:
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	ecx
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR _bb$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6684 :     const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_CloseButtonActive : hovered ? ImGuiCol_CloseButtonHovered : ImGuiCol_CloseButton);

	add	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	addss	xmm0, DWORD PTR _bb$[ebp+8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6686 :     window->DrawList->AddCircleFilled(center, ImMax(2.0f, radius), col, 12);

	push	12					; 0000000cH
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 244  :     ImVec2      GetCenter() const               { return ImVec2((Min.x+Max.x)*0.5f, (Min.y+Max.y)*0.5f); }

	mulss	xmm0, DWORD PTR __real@3f000000
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6686 :     window->DrawList->AddCircleFilled(center, ImMax(2.0f, radius), col, 12);

	lea	eax, DWORD PTR _center$[ebp]
	push	ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _center$[ebp], xmm0
	movss	xmm0, DWORD PTR _bb$[ebp+4]
	addss	xmm0, DWORD PTR _bb$[ebp+12]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 244  :     ImVec2      GetCenter() const               { return ImVec2((Min.x+Max.x)*0.5f, (Min.y+Max.y)*0.5f); }

	mulss	xmm0, DWORD PTR __real@3f000000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _center$[ebp+4], xmm0
	movss	xmm0, DWORD PTR _radius$[ebp]
	maxss	xmm0, DWORD PTR __real@40000000
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6686 :     window->DrawList->AddCircleFilled(center, ImMax(2.0f, radius), col, 12);

	mov	ecx, DWORD PTR [esi+624]
	movss	DWORD PTR [esp], xmm0
	push	eax
	call	?AddCircleFilled@ImDrawList@@QAEXABUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled

; 6687 : 
; 6688 :     const float cross_extent = (radius * 0.7071f) - 1.0f;
; 6689 :     if (hovered)

	cmp	BYTE PTR _hovered$[ebp], 0
	movss	xmm3, DWORD PTR _radius$[ebp]
	mulss	xmm3, DWORD PTR __real@3f350481
	subss	xmm3, DWORD PTR __real@3f800000
	movss	DWORD PTR _radius$[ebp], xmm3
	je	$LN3@CloseButto
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm2, DWORD PTR _center$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6691 :         window->DrawList->AddLine(center + ImVec2(+cross_extent,+cross_extent), center + ImVec2(-cross_extent,-cross_extent), GetColorU32(ImGuiCol_Text));

	movaps	xmm1, xmm3
	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	sub	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movaps	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6691 :         window->DrawList->AddLine(center + ImVec2(+cross_extent,+cross_extent), center + ImVec2(-cross_extent,-cross_extent), GetColorU32(ImGuiCol_Text));

	movss	DWORD PTR tv376[ebp], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm2
	addss	xmm2, xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6691 :         window->DrawList->AddLine(center + ImVec2(+cross_extent,+cross_extent), center + ImVec2(-cross_extent,-cross_extent), GetColorU32(ImGuiCol_Text));

	mov	DWORD PTR [esp+4], 1065353216		; 3f800000H
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movaps	xmm0, xmm1
	movss	xmm1, DWORD PTR _center$[ebp+4]
	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T5[ebp], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm1, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp+4], xmm0
	movss	DWORD PTR $T5[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6691 :         window->DrawList->AddLine(center + ImVec2(+cross_extent,+cross_extent), center + ImVec2(-cross_extent,-cross_extent), GetColorU32(ImGuiCol_Text));

	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	ecx, DWORD PTR [esi+624]
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	call	?AddLine@ImDrawList@@QAEXABUImVec2@@0IM@Z ; ImDrawList::AddLine
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm3, DWORD PTR tv376[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6692 :         window->DrawList->AddLine(center + ImVec2(+cross_extent,-cross_extent), center + ImVec2(-cross_extent,+cross_extent), GetColorU32(ImGuiCol_Text));

	sub	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm2, DWORD PTR _center$[ebp]
	movaps	xmm0, xmm3
	addss	xmm3, DWORD PTR _center$[ebp+4]
	addss	xmm0, xmm2
	addss	xmm2, DWORD PTR _radius$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6692 :         window->DrawList->AddLine(center + ImVec2(+cross_extent,-cross_extent), center + ImVec2(-cross_extent,+cross_extent), GetColorU32(ImGuiCol_Text));

	mov	DWORD PTR [esp+4], 1065353216		; 3f800000H
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR _center$[ebp+4]
	addss	xmm0, DWORD PTR _radius$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp], xmm2
	movss	DWORD PTR $T4[ebp+4], xmm3
	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6692 :         window->DrawList->AddLine(center + ImVec2(+cross_extent,-cross_extent), center + ImVec2(-cross_extent,+cross_extent), GetColorU32(ImGuiCol_Text));

	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	ecx, DWORD PTR [esi+624]
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	?AddLine@ImDrawList@@QAEXABUImVec2@@0IM@Z ; ImDrawList::AddLine
$LN3@CloseButto:

; 6693 :     }
; 6694 : 
; 6695 :     return pressed;

	mov	al, BYTE PTR _pressed$1$[ebp]
	pop	esi

; 6696 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CloseButton@ImGui@@YA_NIABUImVec2@@M@Z ENDP		; ImGui::CloseButton
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_bb$ = -52						; size = 16
$T1 = -36						; size = 8
_size$ = -36						; size = 8
_label_size$ = -28					; size = 8
$T2 = -20						; size = 8
$T3 = -20						; size = 8
_pos$2$ = -16						; size = 4
_id$ = -12						; size = 4
_pos$1$ = -8						; size = 4
_pressed$1$ = -3					; size = 1
_held$ = -2						; size = 1
_hovered$ = -1						; size = 1
_label$ = 8						; size = 4
_size_arg$ = 12						; size = 4
_flags$ = 16						; size = 4
?ButtonEx@ImGui@@YA_NPBDABUImVec2@@H@Z PROC		; ImGui::ButtonEx

; 6597 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6597 : {

	sub	esp, 52					; 00000034H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	push	esi
	mov	BYTE PTR [eax+134], 1
	mov	esi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6599 :     if (window->SkipItems)

	cmp	BYTE PTR [esi+137], 0
	je	SHORT $LN2@ButtonEx

; 6600 :         return false;

	xor	al, al
	pop	esi

; 6632 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@ButtonEx:
	push	ebx

; 6601 : 
; 6602 :     ImGuiContext& g = *GImGui;
; 6603 :     const ImGuiStyle& style = g.Style;
; 6604 :     const ImGuiID id = window->GetID(label);

	mov	ebx, DWORD PTR _label$[ebp]
	mov	ecx, esi
	push	edi
	mov	edi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	0
	push	ebx
	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID

; 6605 :     const ImVec2 label_size = CalcTextSize(label, NULL, true);

	push	ecx
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	push	1
	push	0
	mov	DWORD PTR _id$[ebp], eax
	lea	eax, DWORD PTR _label_size$[ebp]
	push	ebx
	push	eax
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
	movss	xmm0, DWORD PTR [esi+192]
	add	esp, 20					; 00000014H
	movss	xmm1, DWORD PTR [esi+196]

; 6606 : 
; 6607 :     ImVec2 pos = window->DC.CursorPos;
; 6608 :     if ((flags & ImGuiButtonFlags_AlignTextBaseLine) && style.FramePadding.y < window->DC.CurrentLineTextBaseOffset) // Try to vertically align buttons that are smaller/have no padding so that text baseline matches (bit hacky, since it shouldn't be a flag)

	mov	ebx, DWORD PTR _flags$[ebp]
	movss	DWORD PTR _pos$2$[ebp], xmm0
	movss	DWORD PTR _pos$1$[ebp], xmm1
	test	ebx, 256				; 00000100H
	je	SHORT $LN3@ButtonEx
	movss	xmm2, DWORD PTR [edi+5360]
	movss	xmm0, DWORD PTR [esi+228]
	comiss	xmm0, xmm2
	jbe	SHORT $LN3@ButtonEx

; 6609 :         pos.y += window->DC.CurrentLineTextBaseOffset - style.FramePadding.y;

	subss	xmm0, xmm2
	addss	xmm1, xmm0
	movss	DWORD PTR _pos$1$[ebp], xmm1
$LN3@ButtonEx:

; 6610 :     ImVec2 size = CalcItemSize(size_arg, label_size.x + style.FramePadding.x * 2.0f, label_size.y + style.FramePadding.y * 2.0f);

	movss	xmm0, DWORD PTR [edi+5360]
	sub	esp, 8
	movss	xmm1, DWORD PTR [edi+5356]
	addss	xmm0, xmm0
	mov	eax, DWORD PTR _size_arg$[ebp]
	addss	xmm1, xmm1
	addss	xmm0, DWORD PTR _label_size$[ebp+4]
	addss	xmm1, DWORD PTR _label_size$[ebp]
	movss	DWORD PTR [esp+4], xmm0
	movss	DWORD PTR [esp], xmm1
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	call	?CalcItemSize@ImGui@@YA?AUImVec2@@U2@MM@Z ; ImGui::CalcItemSize
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm2, DWORD PTR _pos$2$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6613 :     ItemSize(bb, style.FramePadding.y);

	add	esp, 16					; 00000010H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm1, DWORD PTR _pos$1$[ebp]
	movaps	xmm0, xmm2
	addss	xmm0, DWORD PTR _size$[ebp]
	movss	DWORD PTR _bb$[ebp], xmm2
	movss	DWORD PTR _bb$[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR _size$[ebp+4]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T3[ebp]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm1

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _bb$[ebp+8], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T3[ebp+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6613 :     ItemSize(bb, style.FramePadding.y);

	movss	xmm0, DWORD PTR [edi+5360]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6613 :     ItemSize(bb, style.FramePadding.y);

	lea	eax, DWORD PTR _bb$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	eax
	call	?ItemSize@ImGui@@YAXABUImRect@@M@Z	; ImGui::ItemSize

; 6614 :     if (!ItemAdd(bb, &id))

	push	0
	lea	eax, DWORD PTR _id$[ebp]
	push	eax
	lea	eax, DWORD PTR _bb$[ebp]
	push	eax
	call	?ItemAdd@ImGui@@YA_NABUImRect@@PBIPBU2@@Z ; ImGui::ItemAdd
	add	esp, 20					; 00000014H
	test	al, al
	jne	SHORT $LN4@ButtonEx
	pop	edi
	pop	ebx
	pop	esi

; 6632 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@ButtonEx:

; 6615 :         return false;
; 6616 : 
; 6617 :     if (window->DC.ItemFlags & ImGuiItemFlags_ButtonRepeat) flags |= ImGuiButtonFlags_Repeat;

	mov	eax, DWORD PTR [esi+312]
	mov	ecx, ebx
	or	ecx, 1
	and	al, 4

; 6618 :     bool hovered, held;
; 6619 :     bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);

	lea	eax, DWORD PTR _held$[ebp]
	cmove	ecx, ebx
	mov	ebx, DWORD PTR _id$[ebp]
	push	ecx
	push	eax
	lea	eax, DWORD PTR _hovered$[ebp]
	push	eax
	lea	eax, DWORD PTR _bb$[ebp]
	push	ebx
	push	eax
	call	?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z ; ImGui::ButtonBehavior

; 6620 : 
; 6621 :     // Render
; 6622 :     const ImU32 col = GetColorU32((hovered && held) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);

	mov	dl, BYTE PTR _hovered$[ebp]
	add	esp, 20					; 00000014H
	mov	BYTE PTR _pressed$1$[ebp], al
	test	dl, dl
	je	SHORT $LN7@ButtonEx
	cmp	BYTE PTR _held$[ebp], 0
	je	SHORT $LN7@ButtonEx
	mov	ecx, 24					; 00000018H
	jmp	SHORT $LN8@ButtonEx
$LN7@ButtonEx:
	xor	ecx, ecx
	test	dl, dl
	setne	cl
	add	ecx, 22					; 00000016H
$LN8@ButtonEx:
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	ecx
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	esi, eax

; 6623 :     RenderNavHighlight(bb, id);

	lea	eax, DWORD PTR _bb$[ebp]
	push	ebx
	push	eax
	call	?RenderNavHighlight@ImGui@@YAXABUImRect@@I@Z ; ImGui::RenderNavHighlight

; 6624 :     RenderFrame(bb.Min, bb.Max, col, true, style.FrameRounding);

	movss	xmm0, DWORD PTR [edi+5364]
	add	esp, 12					; 0000000cH
	movss	DWORD PTR [esp], xmm0
	push	1
	push	esi
	push	DWORD PTR _bb$[ebp+12]
	push	DWORD PTR _bb$[ebp+8]
	push	DWORD PTR _bb$[ebp+4]
	push	DWORD PTR _bb$[ebp]
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR _bb$[ebp+8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6625 :     RenderTextClipped(bb.Min + style.FramePadding, bb.Max - style.FramePadding, label, NULL, &label_size, style.ButtonTextAlign, &bb);

	lea	eax, DWORD PTR _bb$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm0, DWORD PTR [edi+5356]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6625 :     RenderTextClipped(bb.Min + style.FramePadding, bb.Max - style.FramePadding, label, NULL, &label_size, style.ButtonTextAlign, &bb);

	push	eax
	lea	eax, DWORD PTR [edi+5416]
	push	eax
	lea	eax, DWORD PTR _label_size$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR _bb$[ebp+12]
	subss	xmm0, DWORD PTR [edi+5360]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6625 :     RenderTextClipped(bb.Min + style.FramePadding, bb.Max - style.FramePadding, label, NULL, &label_size, style.ButtonTextAlign, &bb);

	push	eax
	push	0
	push	DWORD PTR _label$[ebp]
	lea	eax, DWORD PTR $T1[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [edi+5356]
	addss	xmm0, DWORD PTR _bb$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6625 :     RenderTextClipped(bb.Min + style.FramePadding, bb.Max - style.FramePadding, label, NULL, &label_size, style.ButtonTextAlign, &bb);

	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [edi+5360]
	addss	xmm0, DWORD PTR _bb$[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6625 :     RenderTextClipped(bb.Min + style.FramePadding, bb.Max - style.FramePadding, label, NULL, &label_size, style.ButtonTextAlign, &bb);

	call	?RenderTextClipped@ImGui@@YAXABUImVec2@@0PBD1PBU2@0PBUImRect@@@Z ; ImGui::RenderTextClipped

; 6626 : 
; 6627 :     // Automatically close popups
; 6628 :     //if (pressed && !(flags & ImGuiButtonFlags_DontClosePopups) && (window->Flags & ImGuiWindowFlags_Popup))
; 6629 :     //    CloseCurrentPopup();
; 6630 : 
; 6631 :     return pressed;

	mov	al, BYTE PTR _pressed$1$[ebp]
	add	esp, 56					; 00000038H
	pop	edi
	pop	ebx
	pop	esi

; 6632 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ButtonEx@ImGui@@YA_NPBDABUImVec2@@H@Z ENDP		; ImGui::ButtonEx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -20						; size = 8
_window$1$ = -12					; size = 4
tv473 = -8						; size = 4
_held$1$ = -1						; size = 1
_bb$ = 8						; size = 4
_id$ = 12						; size = 4
_out_hovered$ = 16					; size = 4
_out_held$ = 20						; size = 4
_flags$ = 24						; size = 4
_hovered$1$ = 27					; size = 1
?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z PROC	; ImGui::ButtonBehavior

; 6488 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 6492 :     if (flags & ImGuiButtonFlags_Disabled)

	mov	ecx, DWORD PTR _flags$[ebp]
	push	esi
	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [esi+6240]
	mov	BYTE PTR [eax+134], 1
	mov	eax, DWORD PTR [esi+6240]
	mov	DWORD PTR _window$1$[ebp], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6492 :     if (flags & ImGuiButtonFlags_Disabled)

	test	cl, cl
	jns	SHORT $LN2@ButtonBeha

; 6493 :     {
; 6494 :         if (out_hovered) *out_hovered = false;

	mov	eax, DWORD PTR _out_hovered$[ebp]
	test	eax, eax
	je	SHORT $LN3@ButtonBeha
	mov	BYTE PTR [eax], 0
$LN3@ButtonBeha:

; 6495 :         if (out_held) *out_held = false;

	mov	eax, DWORD PTR _out_held$[ebp]
	test	eax, eax
	je	SHORT $LN4@ButtonBeha
	mov	BYTE PTR [eax], 0
$LN4@ButtonBeha:

; 6496 :         if (g.ActiveId == id) ClearActiveID();

	mov	eax, DWORD PTR [esi+6264]
	cmp	eax, DWORD PTR _id$[ebp]
	jne	SHORT $LN5@ButtonBeha
	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
$LN5@ButtonBeha:

; 6497 :         return false;

	xor	al, al
	pop	esi

; 6592 : 
; 6593 :     return pressed;
; 6594 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@ButtonBeha:
	push	ebx

; 6498 :     }
; 6499 : 
; 6500 :     // Default behavior requires click+release on same spot
; 6501 :     if ((flags & (ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_PressedOnRelease | ImGuiButtonFlags_PressedOnDoubleClick)) == 0)

	mov	eax, ecx

; 6502 :         flags |= ImGuiButtonFlags_PressedOnClickRelease;
; 6503 : 
; 6504 :     bool pressed = false;

	mov	BYTE PTR tv473[ebp], 0
	mov	ebx, ecx
	or	ebx, 2
	and	al, 30					; 0000001eH
	push	edi

; 6505 :     bool hovered = IsHovered(bb, id, (flags & ImGuiButtonFlags_FlattenChilds) != 0);

	mov	edi, DWORD PTR _id$[ebp]
	cmovne	ebx, ecx
	mov	eax, ebx
	shr	eax, 5
	and	al, 1
	movzx	eax, al
	push	eax
	push	edi
	push	DWORD PTR _bb$[ebp]
	call	?IsHovered@ImGui@@YA_NABUImRect@@I_N@Z	; ImGui::IsHovered
	mov	dh, al
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _hovered$1$[ebp], dh

; 6506 :     if (hovered)

	test	dh, dh
	je	$LN20@ButtonBeha

; 6507 :     {
; 6508 :         SetHoveredID(id);

	push	edi
	call	?SetHoveredID@ImGui@@YAXI@Z		; ImGui::SetHoveredID
	add	esp, 4

; 6509 :         if (!(flags & ImGuiButtonFlags_NoKeyModifiers) || (!g.IO.KeyCtrl && !g.IO.KeyShift && !g.IO.KeyAlt))

	test	ebx, 512				; 00000200H
	je	SHORT $LN9@ButtonBeha
	cmp	BYTE PTR [esi+229], 0
	jne	$LN20@ButtonBeha
	cmp	BYTE PTR [esi+230], 0
	jne	$LN20@ButtonBeha
	cmp	BYTE PTR [esi+231], 0
	jne	$LN20@ButtonBeha
$LN9@ButtonBeha:

; 6510 :         {
; 6511 :             //                        | CLICKING        | HOLDING with ImGuiButtonFlags_Repeat
; 6512 :             // PressedOnClickRelease  |  <on release>*  |  <on repeat> <on repeat> .. (NOT on release)  <-- MOST COMMON! (*) only if both click/release were over bounds
; 6513 :             // PressedOnClick         |  <on click>     |  <on click> <on repeat> <on repeat> ..
; 6514 :             // PressedOnRelease       |  <on release>   |  <on repeat> <on repeat> .. (NOT on release)
; 6515 :             // PressedOnDoubleClick   |  <on dclick>    |  <on dclick> <on repeat> <on repeat> ..
; 6516 :             // FIXME-NAVIGATION: We don't honor those different behaviors.
; 6517 :             if ((flags & ImGuiButtonFlags_PressedOnClickRelease) && g.IO.MouseClicked[0])

	test	bl, 2
	je	SHORT $LN10@ButtonBeha
	cmp	BYTE PTR [esi+888], 0
	je	SHORT $LN10@ButtonBeha

; 6518 :             {
; 6519 :                 if (flags & ImGuiButtonFlags_NoNavOverride)
; 6520 :                     SetActiveIDNoNav(id, window);

	push	DWORD PTR _window$1$[ebp]
	push	edi
	test	ebx, 2048				; 00000800H
	je	SHORT $LN11@ButtonBeha
	call	?SetActiveIDNoNav@ImGui@@YAXIPAUImGuiWindow@@@Z ; ImGui::SetActiveIDNoNav

; 6521 :                 else

	jmp	SHORT $LN53@ButtonBeha
$LN11@ButtonBeha:

; 6522 :                     SetActiveID(id, window); // Hold on ID

	call	?SetActiveID@ImGui@@YAXIPAUImGuiWindow@@@Z ; ImGui::SetActiveID
$LN53@ButtonBeha:
	add	esp, 8

; 6523 :                 FocusWindow(window);

	push	DWORD PTR _window$1$[ebp]
	call	?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusWindow
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	mov	eax, DWORD PTR _bb$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6523 :                 FocusWindow(window);

	add	esp, 4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [esi+208]
	subss	xmm0, DWORD PTR [eax]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [esi+212]
	subss	xmm0, DWORD PTR [eax+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6524 :                 g.ActiveIdClickOffset = g.IO.MousePos - bb.Min;

	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR [esi+6280], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6524 :                 g.ActiveIdClickOffset = g.IO.MousePos - bb.Min;

	mov	eax, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR [esi+6284], eax
$LN10@ButtonBeha:

; 6525 :             }
; 6526 :             if (((flags & ImGuiButtonFlags_PressedOnClick) && g.IO.MouseClicked[0]) || ((flags & ImGuiButtonFlags_PressedOnDoubleClick) && g.IO.MouseDoubleClicked[0]))

	test	bl, 4
	je	SHORT $LN15@ButtonBeha
	cmp	BYTE PTR [esi+888], 0
	jne	SHORT $LN14@ButtonBeha
$LN15@ButtonBeha:
	test	bl, 16					; 00000010H
	je	SHORT $LN13@ButtonBeha
	cmp	BYTE PTR [esi+956], 0
	je	SHORT $LN13@ButtonBeha
$LN14@ButtonBeha:

; 6527 :             {
; 6528 :                 pressed = true;

	mov	BYTE PTR tv473[ebp], 1

; 6529 :                 ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID

; 6530 :                 FocusWindow(window);

	push	DWORD PTR _window$1$[ebp]
	call	?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusWindow
	add	esp, 4
$LN13@ButtonBeha:

; 6531 :             }
; 6532 :             if ((flags & ImGuiButtonFlags_PressedOnRelease) && g.IO.MouseReleased[0])

	test	bl, 8
	je	SHORT $LN16@ButtonBeha
	cmp	BYTE PTR [esi+961], 0
	je	SHORT $LN16@ButtonBeha

; 6533 :             {
; 6534 :                 if (!((flags & ImGuiButtonFlags_Repeat) && g.IO.MouseDownDurationPrev[0] >= g.IO.KeyRepeatDelay))  // Repeat mode trumps <on release>

	test	bl, 1
	je	SHORT $LN18@ButtonBeha
	movss	xmm0, DWORD PTR [esi+992]
	comiss	xmm0, DWORD PTR [esi+116]
	jae	SHORT $LN17@ButtonBeha
$LN18@ButtonBeha:

; 6535 :                     pressed = true;

	mov	BYTE PTR tv473[ebp], 1
$LN17@ButtonBeha:

; 6536 :                 ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
$LN16@ButtonBeha:

; 6537 :             }
; 6538 : 
; 6539 :             // 'Repeat' mode acts when held regardless of _PressedOn flags (see table above). 
; 6540 :             // Relies on repeat logic of IsMouseClicked() but we may as well do it ourselves if we end up exposing finer RepeatDelay/RepeatRate settings.
; 6541 :             if ((flags & ImGuiButtonFlags_Repeat) && g.ActiveId == id && g.IO.MouseDownDuration[0] > 0.0f && IsMouseClicked(0, true))

	test	bl, 1
	je	SHORT $LN19@ButtonBeha
	cmp	DWORD PTR [esi+6264], edi
	jne	SHORT $LN19@ButtonBeha
	movss	xmm0, DWORD PTR [esi+972]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN19@ButtonBeha
	push	1
	push	0
	call	?IsMouseClicked@ImGui@@YA_NH_N@Z	; ImGui::IsMouseClicked
	add	esp, 8
	test	al, al
	je	SHORT $LN19@ButtonBeha

; 6542 :                 pressed = true;

	mov	BYTE PTR tv473[ebp], 1

; 6543 :         }
; 6544 : 
; 6545 :         if (pressed)

	jmp	SHORT $LN44@ButtonBeha
$LN19@ButtonBeha:
	cmp	BYTE PTR tv473[ebp], 0
	je	SHORT $LN20@ButtonBeha
$LN44@ButtonBeha:

; 6546 :             g.NavDisableHighlight = true;

	mov	BYTE PTR [esi+6454], 1
$LN20@ButtonBeha:

; 6547 :     }
; 6548 : 
; 6549 :     // Gamepad/Keyboard navigation
; 6550 :     if (g.NavId == id && !g.NavDisableHighlight && (g.ActiveId == 0 || g.ActiveId == id))

	cmp	DWORD PTR [esi+6384], edi
	jne	SHORT $LN52@ButtonBeha
	cmp	BYTE PTR [esi+6454], 0
	jne	SHORT $LN52@ButtonBeha
	mov	eax, DWORD PTR [esi+6264]
	test	eax, eax
	je	SHORT $LN22@ButtonBeha
	cmp	eax, edi
	jne	SHORT $LN52@ButtonBeha
$LN22@ButtonBeha:

; 6551 :     {
; 6552 :         // We report navigated item as hovered but we don't set g.HoveredId to not interfere with mouse
; 6553 :         hovered = true;
; 6554 :         if (!g.NavWindowingTarget && IsNavInputDown(ImGuiNavInput_PadActivate))

	cmp	DWORD PTR [esi+6432], 0
	mov	al, 1
	mov	BYTE PTR _hovered$1$[ebp], al
	jne	SHORT $LN24@ButtonBeha
	push	0
	call	?IsNavInputDown@@YA_NH@Z		; IsNavInputDown
	add	esp, 4
	test	al, al
	je	SHORT $LN52@ButtonBeha

; 6555 :         {
; 6556 :             // Set active id so it can be queried by user via IsItemActive(), etc. but don't react to it ourselves
; 6557 :             g.NavActivateId = id;
; 6558 :             SetActiveID(id, window);

	push	DWORD PTR _window$1$[ebp]
	mov	DWORD PTR [esi+6388], edi
	push	edi
	call	?SetActiveID@ImGui@@YAXIPAUImGuiWindow@@@Z ; ImGui::SetActiveID

; 6559 :             g.ActiveIdAllowNavDirFlags = (1 << ImGuiNavDir_Left) | (1 << ImGuiNavDir_Right) | (1 << ImGuiNavDir_Up) | (1 << ImGuiNavDir_Down);
; 6560 :             if (IsNavInputPressed(ImGuiNavInput_PadActivate, (flags & ImGuiButtonFlags_Repeat) ? ImGuiNavReadMode_Repeat : ImGuiNavReadMode_Pressed))

	mov	eax, ebx
	mov	DWORD PTR [esi+6276], 15		; 0000000fH
	and	eax, 1
	add	eax, eax
	or	eax, 1
	push	eax
	push	0
	call	?IsNavInputPressed@@YA_NHW4ImGuiNavReadMode@@@Z ; IsNavInputPressed
	mov	ecx, DWORD PTR tv473[ebp]
	add	esp, 16					; 00000010H
	test	al, al
	movzx	ecx, cl
	mov	edx, 1
	cmovne	ecx, edx
	mov	al, dl
	mov	DWORD PTR tv473[ebp], ecx
	jmp	SHORT $LN24@ButtonBeha
$LN52@ButtonBeha:
	mov	al, BYTE PTR _hovered$1$[ebp]
$LN24@ButtonBeha:

; 6561 :                 pressed = true;
; 6562 :         }
; 6563 :     }
; 6564 : 
; 6565 :     bool held = false;

	mov	BYTE PTR _held$1$[ebp], 0

; 6566 :     if (g.ActiveId == id && g.ActiveIdSource == ImGuiInputSource_Mouse)

	cmp	DWORD PTR [esi+6264], edi
	jne	SHORT $LN33@ButtonBeha
	cmp	DWORD PTR [esi+6292], 1
	jne	SHORT $LN31@ButtonBeha

; 6567 :     {
; 6568 :         if (g.IO.MouseDown[0])

	cmp	BYTE PTR [esi+216], 0
	je	SHORT $LN26@ButtonBeha

; 6569 :         {
; 6570 :             held = true;

	mov	BYTE PTR _held$1$[ebp], 1

; 6571 :         }
; 6572 :         else

	jmp	SHORT $LN27@ButtonBeha
$LN26@ButtonBeha:

; 6573 :         {
; 6574 :             if (hovered && (flags & ImGuiButtonFlags_PressedOnClickRelease))

	test	al, al
	je	SHORT $LN29@ButtonBeha
	test	bl, 2
	je	SHORT $LN29@ButtonBeha

; 6575 :                 if (!((flags & ImGuiButtonFlags_Repeat) && g.IO.MouseDownDurationPrev[0] >= g.IO.KeyRepeatDelay))  // Repeat mode trumps <on release>

	test	bl, 1
	je	SHORT $LN30@ButtonBeha
	movss	xmm0, DWORD PTR [esi+992]
	comiss	xmm0, DWORD PTR [esi+116]
	jae	SHORT $LN29@ButtonBeha
$LN30@ButtonBeha:

; 6576 :                     pressed = true;

	mov	BYTE PTR tv473[ebp], 1
$LN29@ButtonBeha:

; 6577 :             ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
$LN27@ButtonBeha:

; 6578 :         }
; 6579 :         if (!(flags & ImGuiButtonFlags_NoNavOverride))

	test	ebx, 2048				; 00000800H
	jne	SHORT $LN31@ButtonBeha

; 6580 :             g.NavDisableHighlight = true;

	mov	BYTE PTR [esi+6454], 1
$LN31@ButtonBeha:

; 6581 :     }
; 6582 :     if (g.ActiveId == id && g.ActiveIdSource == ImGuiInputSource_Nav)

	cmp	DWORD PTR [esi+6264], edi
	jne	SHORT $LN33@ButtonBeha
	cmp	DWORD PTR [esi+6292], 2
	jne	SHORT $LN33@ButtonBeha

; 6583 :         if (!IsNavInputDown(ImGuiNavInput_PadActivate))

	push	0
	call	?IsNavInputDown@@YA_NH@Z		; IsNavInputDown
	add	esp, 4
	test	al, al
	jne	SHORT $LN33@ButtonBeha

; 6584 :             ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
$LN33@ButtonBeha:

; 6585 : 
; 6586 :     // AllowOverlap mode (rarely used) requires previous frame HoveredId to be null or to match. This allows using patterns where a later submitted widget overlaps a previous one.
; 6587 :     if (hovered && (flags & ImGuiButtonFlags_AllowOverlapMode) && (g.HoveredIdPreviousFrame != id && g.HoveredIdPreviousFrame != 0))

	mov	dh, BYTE PTR _hovered$1$[ebp]
	test	dh, dh
	je	SHORT $LN48@ButtonBeha
	test	ebx, 1024				; 00000400H
	je	SHORT $LN48@ButtonBeha
	mov	eax, DWORD PTR [esi+6260]
	cmp	eax, edi
	je	SHORT $LN48@ButtonBeha
	test	eax, eax
	je	SHORT $LN48@ButtonBeha

; 6588 :         hovered = pressed = held = false;

	xor	dl, dl
	xor	al, al
	xor	dh, dh
	jmp	SHORT $LN34@ButtonBeha
$LN48@ButtonBeha:
	mov	dl, BYTE PTR _held$1$[ebp]
	mov	eax, DWORD PTR tv473[ebp]
$LN34@ButtonBeha:

; 6589 : 
; 6590 :     if (out_hovered) *out_hovered = hovered;

	mov	ecx, DWORD PTR _out_hovered$[ebp]
	pop	edi
	pop	ebx
	test	ecx, ecx
	je	SHORT $LN35@ButtonBeha
	mov	BYTE PTR [ecx], dh
$LN35@ButtonBeha:

; 6591 :     if (out_held) *out_held = held;

	mov	ecx, DWORD PTR _out_held$[ebp]
	test	ecx, ecx
	je	SHORT $LN1@ButtonBeha
	mov	BYTE PTR [ecx], dl
$LN1@ButtonBeha:
	pop	esi

; 6592 : 
; 6593 :     return pressed;
; 6594 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z ENDP	; ImGui::ButtonBehavior
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_text$ = 8						; size = 4
_text_end$ = 12						; size = 4
?FindRenderedTextEnd@ImGui@@YAPBDPBD0@Z PROC		; ImGui::FindRenderedTextEnd

; 3558 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR _text_end$[ebp]
	or	edx, -1

; 3559 :     const char* text_display_end = text;

	mov	eax, DWORD PTR _text$[ebp]
	test	ecx, ecx
	cmovne	edx, ecx

; 3560 :     if (!text_end)
; 3561 :         text_end = (const char*)-1;
; 3562 : 
; 3563 :     while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))

	cmp	eax, edx
	jae	SHORT $LN3@FindRender
$LL2@FindRender:
	mov	cl, BYTE PTR [eax]
	test	cl, cl
	je	SHORT $LN3@FindRender
	cmp	cl, 35					; 00000023H
	jne	SHORT $LN5@FindRender
	cmp	BYTE PTR [eax+1], cl
	je	SHORT $LN3@FindRender
$LN5@FindRender:

; 3564 :         text_display_end++;

	inc	eax
	cmp	eax, edx
	jb	SHORT $LL2@FindRender
$LN3@FindRender:

; 3565 :     return text_display_end;
; 3566 : }

	pop	ebp
	ret	0
?FindRenderedTextEnd@ImGui@@YAPBDPBD0@Z ENDP		; ImGui::FindRenderedTextEnd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -28						; size = 8
$T2 = -28						; size = 8
$T3 = -20						; size = 8
$T4 = -20						; size = 8
$T5 = -12						; size = 4
$T6 = -8						; size = 4
$T7 = -4						; size = 4
_bb$ = 8						; size = 4
$T8 = 12						; size = 4
_id$ = 12						; size = 4
?RenderNavHighlight@ImGui@@YAXABUImRect@@I@Z PROC	; ImGui::RenderNavHighlight

; 2138 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2139 :     ImGuiContext& g = *GImGui;
; 2140 :     if (id != g.NavId || g.NavDisableHighlight)

	mov	eax, DWORD PTR _id$[ebp]
	sub	esp, 28					; 0000001cH
	push	edi
	mov	edi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	cmp	eax, DWORD PTR [edi+6384]
	jne	$LN3@RenderNavH
	cmp	BYTE PTR [edi+6454], 0
	jne	$LN3@RenderNavH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [edi+6240]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR __real@40800000
	push	esi

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	BYTE PTR [eax+134], 1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2146 :     ImRect display_rect(bb.Min - ImVec2(DISTANCE,DISTANCE), bb.Max + ImVec2(DISTANCE,DISTANCE));

	mov	eax, DWORD PTR _bb$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	esi, DWORD PTR [edi+6240]

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm4, DWORD PTR [eax]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm2, DWORD PTR [eax+8]

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm4, xmm0

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm1, DWORD PTR [eax+12]
	addss	xmm2, xmm0

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm3, DWORD PTR [eax+4]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm1, xmm0

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm3, xmm0

; 253  :     bool        Contains(const ImRect& r) const { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x < Max.x && r.Max.y < Max.y; }

	comiss	xmm4, DWORD PTR [esi+472]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	DWORD PTR $T6[ebp], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	DWORD PTR $T5[ebp], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	DWORD PTR $T8[ebp], xmm4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp], xmm4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	DWORD PTR $T7[ebp], xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp+4], xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 253  :     bool        Contains(const ImRect& r) const { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x < Max.x && r.Max.y < Max.y; }

	jb	SHORT $LN25@RenderNavH
	comiss	xmm3, DWORD PTR [esi+476]
	jb	SHORT $LN25@RenderNavH
	movss	xmm0, DWORD PTR [esi+480]
	comiss	xmm0, xmm2
	jbe	SHORT $LN25@RenderNavH
	movss	xmm0, DWORD PTR [esi+484]
	comiss	xmm0, xmm1
	ja	SHORT $LN4@RenderNavH
$LN25@RenderNavH:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2148 :         window->DrawList->PushClipRect(display_rect.Min, display_rect.Max);

	mov	ecx, DWORD PTR [esi+624]
	push	0
	push	DWORD PTR $T4[ebp+4]
	push	DWORD PTR $T4[ebp]
	push	DWORD PTR $T2[ebp+4]
	push	DWORD PTR $T2[ebp]
	call	?PushClipRect@ImDrawList@@QAEXUImVec2@@0_N@Z ; ImDrawList::PushClipRect
	movss	xmm2, DWORD PTR $T6[ebp]
	movss	xmm3, DWORD PTR $T7[ebp]
	movss	xmm4, DWORD PTR $T8[ebp]
$LN4@RenderNavH:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm1, DWORD PTR __real@3f800000
	movaps	xmm0, xmm2
	subss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2149 :     window->DrawList->AddRect(display_rect.Min + ImVec2(THICKNESS*0.5f,THICKNESS*0.5f), display_rect.Max - ImVec2(THICKNESS*0.5f,THICKNESS*0.5f), GetColorU32(ImGuiCol_NavHighlight), g.Style.FrameRounding, 0x0F, THICKNESS);

	push	ecx
	mov	DWORD PTR [esp], 1073741824		; 40000000H
	push	15					; 0000000fH
	sub	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR $T5[ebp]
	subss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movaps	xmm0, xmm4
	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movaps	xmm0, xmm3
	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2149 :     window->DrawList->AddRect(display_rect.Min + ImVec2(THICKNESS*0.5f,THICKNESS*0.5f), display_rect.Max - ImVec2(THICKNESS*0.5f,THICKNESS*0.5f), GetColorU32(ImGuiCol_NavHighlight), g.Style.FrameRounding, 0x0F, THICKNESS);

	movss	xmm0, DWORD PTR [edi+5364]
	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	43					; 0000002bH
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	ecx, DWORD PTR [esi+624]
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?AddRect@ImDrawList@@QAEXABUImVec2@@0IMHM@Z ; ImDrawList::AddRect
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 253  :     bool        Contains(const ImRect& r) const { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x < Max.x && r.Max.y < Max.y; }

	movss	xmm0, DWORD PTR $T8[ebp]
	comiss	xmm0, DWORD PTR [esi+472]
	jb	SHORT $LN41@RenderNavH
	movss	xmm0, DWORD PTR $T7[ebp]
	comiss	xmm0, DWORD PTR [esi+476]
	jb	SHORT $LN41@RenderNavH
	movss	xmm0, DWORD PTR [esi+480]
	comiss	xmm0, DWORD PTR $T6[ebp]
	jbe	SHORT $LN41@RenderNavH
	movss	xmm0, DWORD PTR [esi+484]
	comiss	xmm0, DWORD PTR $T5[ebp]
	ja	SHORT $LN45@RenderNavH
$LN41@RenderNavH:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2152 :         window->DrawList->PopClipRect();

	mov	ecx, DWORD PTR [esi+624]
	call	?PopClipRect@ImDrawList@@QAEXXZ		; ImDrawList::PopClipRect
$LN45@RenderNavH:
	pop	esi
$LN3@RenderNavH:
	pop	edi

; 2153 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RenderNavHighlight@ImGui@@YAXABUImRect@@I@Z ENDP	; ImGui::RenderNavHighlight
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_c$ = -24						; size = 8
_b$ = -16						; size = 8
_a$ = -8						; size = 8
_pos$ = 8						; size = 8
_col$ = 16						; size = 4
?RenderCheckMark@ImGui@@YAXUImVec2@@I@Z PROC		; ImGui::RenderCheckMark

; 3774 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 3775 :     ImGuiContext& g = *GImGui;

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 3779 :     float start_x = (float)(int)(g.FontSize * 0.307f + 0.5f);

	movss	xmm3, DWORD PTR __real@3f000000
	push	esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3779 :     float start_x = (float)(int)(g.FontSize * 0.307f + 0.5f);

	movss	xmm4, DWORD PTR [ecx+6172]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	esi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3779 :     float start_x = (float)(int)(g.FontSize * 0.307f + 0.5f);

	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR __real@3e9d2f1b

; 3784 :     b.y = pos.y - 1.0f + (float)(int)(g.Font->Ascent * (g.FontSize / g.Font->FontSize) + 0.5f) + (float)(int)(g.Font->DisplayOffset.y);

	mov	ecx, DWORD PTR [ecx+6168]
	movss	xmm1, DWORD PTR _pos$[ebp]
	addss	xmm1, xmm3
	addss	xmm0, xmm3
	cvttss2si eax, xmm0
	movaps	xmm0, xmm4
	divss	xmm4, DWORD PTR [ecx]
	movd	xmm2, eax
	mulss	xmm4, DWORD PTR [ecx+72]
	cvtdq2ps xmm2, xmm2
	addss	xmm4, xmm3
	subss	xmm0, xmm2
	addss	xmm1, xmm2
	mulss	xmm0, DWORD PTR __real@3eaaaaab
	movss	DWORD PTR _a$[ebp], xmm1
	cvttss2si eax, xmm0
	movaps	xmm0, xmm1
	movd	xmm5, eax
	cvtdq2ps xmm5, xmm5
	cvttss2si eax, xmm4
	addss	xmm0, xmm5
	movss	DWORD PTR _b$[ebp], xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, DWORD PTR __real@40400000
	addss	xmm0, xmm1
	movd	xmm1, eax
	cvttss2si eax, DWORD PTR [ecx+12]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1270 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	mov	ecx, DWORD PTR [esi+624]
	add	ecx, 76					; 0000004cH
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3783 :     c.x = a.x + rem_third * 3.0f;

	movss	DWORD PTR _c$[ebp], xmm0

; 3784 :     b.y = pos.y - 1.0f + (float)(int)(g.Font->Ascent * (g.FontSize / g.Font->FontSize) + 0.5f) + (float)(int)(g.Font->DisplayOffset.y);

	movss	xmm0, DWORD PTR _pos$[ebp+4]
	subss	xmm0, DWORD PTR __real@3f800000
	cvtdq2ps xmm1, xmm1
	addss	xmm1, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1270 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	lea	eax, DWORD PTR _a$[ebp]
	push	eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3784 :     b.y = pos.y - 1.0f + (float)(int)(g.Font->Ascent * (g.FontSize / g.Font->FontSize) + 0.5f) + (float)(int)(g.Font->DisplayOffset.y);

	addss	xmm1, xmm0

; 3785 :     a.y = b.y - rem_third;

	movaps	xmm0, xmm1
	movss	DWORD PTR _b$[ebp+4], xmm1
	subss	xmm0, xmm5

; 3786 :     c.y = b.y - rem_third * 2.0f;

	addss	xmm5, xmm5
	movss	DWORD PTR _a$[ebp+4], xmm0
	subss	xmm1, xmm5
	movss	DWORD PTR _c$[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1270 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	call	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back
	mov	ecx, DWORD PTR [esi+624]
	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	add	ecx, 76					; 0000004cH
	call	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back
	mov	ecx, DWORD PTR [esi+624]
	lea	eax, DWORD PTR _c$[ebp]
	push	eax
	add	ecx, 76					; 0000004cH
	call	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3791 :     window->DrawList->PathStroke(col, false);

	mov	ecx, DWORD PTR [esi+624]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1273 :     inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f)  { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness, true); PathClear(); }

	push	1
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	lea	esi, DWORD PTR [ecx+76]
	push	0
	push	DWORD PTR _col$[ebp]
	push	DWORD PTR [esi]
	push	DWORD PTR [ecx+84]
	call	?AddPolyline@ImDrawList@@QAEXPBUImVec2@@HI_NM1@Z ; ImDrawList::AddPolyline

; 1269 :     inline    void  PathClear()                                                 { _Path.resize(0); }

	push	0
	mov	ecx, esi
	call	?resize@?$ImVector@UImVec2@@@@QAEXH@Z	; ImVector<ImVec2>::resize
	pop	esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3792 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RenderCheckMark@ImGui@@YAXUImVec2@@I@Z ENDP		; ImGui::RenderCheckMark
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_pos$ = 8						; size = 8
?RenderBullet@ImGui@@YAXUImVec2@@@Z PROC		; ImGui::RenderBullet

; 3768 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3770 :     window->DrawList->AddCircleFilled(pos, GImGui->FontSize*0.20f, GetColorU32(ImGuiCol_Text), 8);

	push	8
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [esi+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3770 :     window->DrawList->AddCircleFilled(pos, GImGui->FontSize*0.20f, GetColorU32(ImGuiCol_Text), 8);

	push	0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	BYTE PTR [eax+134], 1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3770 :     window->DrawList->AddCircleFilled(pos, GImGui->FontSize*0.20f, GetColorU32(ImGuiCol_Text), 8);

	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	ecx
	mov	ecx, DWORD PTR [esi+6240]
	movss	xmm0, DWORD PTR [eax+6172]
	lea	eax, DWORD PTR _pos$[ebp]
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	mov	ecx, DWORD PTR [ecx+624]
	movss	DWORD PTR [esp], xmm0
	push	eax
	call	?AddCircleFilled@ImDrawList@@QAEXABUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
	pop	esi

; 3771 : }

	pop	ebp
	ret	0
?RenderBullet@ImGui@@YAXUImVec2@@@Z ENDP		; ImGui::RenderBullet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -32						; size = 8
$T2 = -32						; size = 8
$T3 = -32						; size = 8
$T4 = -32						; size = 8
$T5 = -32						; size = 8
$T6 = -32						; size = 8
_a$ = -24						; size = 8
_b$ = -16						; size = 8
_c$ = -8						; size = 8
_p_min$ = 8						; size = 8
_is_open$ = 16						; size = 1
_scale$ = 20						; size = 4
?RenderCollapseTriangle@ImGui@@YAXUImVec2@@_NM@Z PROC	; ImGui::RenderCollapseTriangle

; 3741 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 3742 :     ImGuiContext& g = *GImGui;

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	sub	esp, 32					; 00000020H

; 3748 : 
; 3749 :     ImVec2 a, b, c;
; 3750 :     if (is_open)

	cmp	BYTE PTR _is_open$[ebp], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	push	esi
	mov	BYTE PTR [eax+134], 1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3745 :     const float h = g.FontSize * 1.00f;

	movss	xmm3, DWORD PTR [ecx+6172]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	esi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3746 :     const float r = h * 0.40f * scale;

	movaps	xmm2, xmm3

; 3747 :     ImVec2 center = p_min + ImVec2(h*0.50f, h*0.50f*scale);

	mulss	xmm3, DWORD PTR __real@3f000000
	mulss	xmm2, DWORD PTR __real@3ecccccd
	movaps	xmm4, xmm3
	mulss	xmm4, DWORD PTR _scale$[ebp]
	mulss	xmm2, DWORD PTR _scale$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm3, DWORD PTR _p_min$[ebp]
	addss	xmm4, DWORD PTR _p_min$[ebp+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3752 :         center.y -= r*0.25f;

	movaps	xmm0, xmm2
	je	SHORT $LN2@RenderColl
	mulss	xmm0, DWORD PTR __real@3e800000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR __real@bf000000
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3752 :         center.y -= r*0.25f;

	subss	xmm4, xmm0
	xorps	xmm0, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm3
	addss	xmm1, xmm4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T6[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movaps	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3753 :         a = center + ImVec2(0,1)*r;

	mov	eax, DWORD PTR $T6[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3753 :         a = center + ImVec2(0,1)*r;

	mov	DWORD PTR _a$[ebp], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T6[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR __real@bf5db22d
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3753 :         a = center + ImVec2(0,1)*r;

	mov	eax, DWORD PTR $T6[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	mulss	xmm2, DWORD PTR __real@3f5db22d
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3753 :         a = center + ImVec2(0,1)*r;

	mov	DWORD PTR _a$[ebp+4], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T5[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm2, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T5[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3754 :         b = center + ImVec2(-0.866f,-0.5f)*r;

	mov	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR _b$[ebp], eax
	mov	eax, DWORD PTR $T5[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp], xmm2
	movss	DWORD PTR $T4[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3757 :     else

	jmp	SHORT $LN79@RenderColl
$LN2@RenderColl:
	xorps	xmm1, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm3
	addss	xmm1, xmm4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR __real@3f5db22d
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3759 :         a = center + ImVec2(1,0)*r;

	mov	eax, DWORD PTR $T3[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR __real@bf000000
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3759 :         a = center + ImVec2(1,0)*r;

	mov	DWORD PTR _a$[ebp], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	mulss	xmm2, DWORD PTR __real@bf5db22d

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3759 :         a = center + ImVec2(1,0)*r;

	mov	eax, DWORD PTR $T3[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm1, xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3759 :         a = center + ImVec2(1,0)*r;

	mov	DWORD PTR _a$[ebp+4], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm2, xmm4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp+4], xmm0
	movss	DWORD PTR $T2[ebp], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3760 :         b = center + ImVec2(-0.500f,0.866f)*r;

	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _b$[ebp], eax
	mov	eax, DWORD PTR $T2[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm1
	movss	DWORD PTR $T1[ebp+4], xmm2
$LN79@RenderColl:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3760 :         b = center + ImVec2(-0.500f,0.866f)*r;

	mov	DWORD PTR _b$[ebp+4], eax

; 3761 :         c = center + ImVec2(-0.500f,-0.866f)*r;

	mov	eax, DWORD PTR $T1[ebp]

; 3762 :     }
; 3763 : 
; 3764 :     window->DrawList->AddTriangleFilled(a, b, c, GetColorU32(ImGuiCol_Text));

	push	ecx
	mov	DWORD PTR _c$[ebp], eax
	mov	eax, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	0
	mov	DWORD PTR _c$[ebp+4], eax
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	ecx, DWORD PTR [esi+624]
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR _c$[ebp]
	push	eax
	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	eax, DWORD PTR _a$[ebp]
	push	eax
	call	?AddTriangleFilled@ImDrawList@@QAEXABUImVec2@@00I@Z ; ImDrawList::AddTriangleFilled
	pop	esi

; 3765 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RenderCollapseTriangle@ImGui@@YAXUImVec2@@_NM@Z ENDP	; ImGui::RenderCollapseTriangle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -16						; size = 8
$T2 = -8						; size = 8
_p_min$ = 8						; size = 8
_p_max$ = 16						; size = 8
_fill_col$ = 24						; size = 4
_border$ = 28						; size = 1
_rounding$ = 32						; size = 4
?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z PROC		; ImGui::RenderFrame

; 3728 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3728 : {

	sub	esp, 16					; 00000010H

; 3731 :     window->DrawList->AddRectFilled(p_min, p_max, fill_col, rounding);

	movss	xmm0, DWORD PTR _rounding$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	push	esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3731 :     window->DrawList->AddRectFilled(p_min, p_max, fill_col, rounding);

	push	-1
	push	ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	BYTE PTR [eax+134], 1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3731 :     window->DrawList->AddRectFilled(p_min, p_max, fill_col, rounding);

	lea	eax, DWORD PTR _p_max$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	esi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3731 :     window->DrawList->AddRectFilled(p_min, p_max, fill_col, rounding);

	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _fill_col$[ebp]
	mov	ecx, DWORD PTR [esi+624]
	push	eax
	lea	eax, DWORD PTR _p_min$[ebp]
	push	eax
	call	?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 3732 :     if (border && (window->Flags & ImGuiWindowFlags_ShowBorders))

	cmp	BYTE PTR _border$[ebp], 0
	je	$LN2@RenderFram
	test	BYTE PTR [esi+8], 128			; 00000080H
	je	$LN2@RenderFram
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm1, DWORD PTR __real@3f800000
	movss	xmm0, DWORD PTR _p_max$[ebp]
	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3734 :         window->DrawList->AddRect(p_min+ImVec2(1,1), p_max+ImVec2(1,1), GetColorU32(ImGuiCol_BorderShadow), rounding);

	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	-1
	sub	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR _p_max$[ebp+4]
	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR _p_min$[ebp]
	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR _p_min$[ebp+4]
	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3734 :         window->DrawList->AddRect(p_min+ImVec2(1,1), p_max+ImVec2(1,1), GetColorU32(ImGuiCol_BorderShadow), rounding);

	movss	xmm0, DWORD PTR _rounding$[ebp]
	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	6
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	ecx, DWORD PTR [esi+624]
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?AddRect@ImDrawList@@QAEXABUImVec2@@0IMHM@Z ; ImDrawList::AddRect

; 3735 :         window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border), rounding);

	movss	xmm0, DWORD PTR _rounding$[ebp]
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	-1
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	5
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	ecx, DWORD PTR [esi+624]
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR _p_max$[ebp]
	push	eax
	lea	eax, DWORD PTR _p_min$[ebp]
	push	eax
	call	?AddRect@ImDrawList@@QAEXABUImVec2@@0IMHM@Z ; ImDrawList::AddRect
$LN2@RenderFram:
	pop	esi

; 3736 :     }
; 3737 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z ENDP		; ImGui::RenderFrame
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_fine_clip_rect$1 = -36					; size = 16
_text_size$ = -28					; size = 8
_pos$ = -20						; size = 8
_window$1$ = -12					; size = 4
$T2 = -8						; size = 8
$T3 = -8						; size = 8
_clip_max$1$ = -4					; size = 4
_pos_min$ = 8						; size = 4
_pos_max$ = 12						; size = 4
_text$ = 16						; size = 4
_text_end$ = 20						; size = 4
_text_size_if_known$ = 24				; size = 4
_align$ = 28						; size = 4
_clip_rect$ = 32					; size = 4
?RenderTextClipped@ImGui@@YAXABUImVec2@@0PBD1PBU2@0PBUImRect@@@Z PROC ; ImGui::RenderTextClipped

; 3688 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi

; 3689 :     // Hide anything after a '##' string
; 3690 :     const char* text_display_end = FindRenderedTextEnd(text, text_end);

	mov	esi, DWORD PTR _text$[ebp]
	push	edi
	push	DWORD PTR _text_end$[ebp]
	push	esi
	call	?FindRenderedTextEnd@ImGui@@YAPBDPBD0@Z	; ImGui::FindRenderedTextEnd
	mov	edi, eax
	add	esp, 8

; 3691 :     const int text_len = (int)(text_display_end - text);

	mov	ecx, edi
	sub	ecx, esi

; 3692 :     if (text_len == 0)

	je	$LN8@RenderText

; 3699 :     ImVec2 pos = pos_min;

	mov	ecx, DWORD PTR _pos_min$[ebp]
	xorps	xmm6, xmm6
	push	ebx
	mov	ebx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ebx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	eax, DWORD PTR [ebx+6240]
	mov	DWORD PTR _window$1$[ebp], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3699 :     ImVec2 pos = pos_min;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _pos$[ebp], eax
	mov	eax, DWORD PTR [ecx+4]

; 3700 :     const ImVec2 text_size = text_size_if_known ? *text_size_if_known : CalcTextSize(text, text_display_end, false, 0.0f);

	mov	ecx, DWORD PTR _text_size_if_known$[ebp]
	mov	DWORD PTR _pos$[ebp+4], eax
	test	ecx, ecx
	je	SHORT $LN10@RenderText
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T3[ebp], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR $T3[ebp+4], eax
	lea	eax, DWORD PTR $T3[ebp]
	jmp	SHORT $LN11@RenderText
$LN10@RenderText:
	push	ecx
	mov	DWORD PTR [esp], 0
	lea	eax, DWORD PTR $T2[ebp]
	push	0
	push	edi
	push	esi
	push	eax
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
	add	esp, 20					; 00000014H
	xorps	xmm6, xmm6
$LN11@RenderText:
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _text_size$[ebp+4], eax
	mov	eax, DWORD PTR _clip_rect$[ebp]
	mov	edx, eax
	test	eax, eax
	mov	DWORD PTR _text_size$[ebp], ecx
	cmove	edx, DWORD PTR _pos_min$[ebp]

; 3701 : 
; 3702 :     const ImVec2* clip_min = clip_rect ? &clip_rect->Min : &pos_min;
; 3703 :     const ImVec2* clip_max = clip_rect ? &clip_rect->Max : &pos_max;

	lea	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN32@RenderText
	mov	ecx, DWORD PTR _pos_max$[ebp]
$LN32@RenderText:

; 3704 :     bool need_clipping = (pos.x + text_size.x >= clip_max->x) || (pos.y + text_size.y >= clip_max->y);

	movss	xmm5, DWORD PTR _text_size$[ebp]
	movss	xmm2, DWORD PTR _pos$[ebp]
	movaps	xmm0, xmm5
	movss	xmm7, DWORD PTR [ecx]
	addss	xmm0, xmm2
	movss	xmm1, DWORD PTR _pos$[ebp+4]
	movss	xmm4, DWORD PTR _text_size$[ebp+4]
	mov	DWORD PTR _clip_max$1$[ebp], ecx
	comiss	xmm0, xmm7
	jae	SHORT $LN16@RenderText
	movaps	xmm0, xmm4
	addss	xmm0, xmm1
	comiss	xmm0, DWORD PTR [ecx+4]
	jae	SHORT $LN16@RenderText
	xor	cl, cl
	jmp	SHORT $LN17@RenderText
$LN16@RenderText:
	mov	cl, 1
$LN17@RenderText:

; 3705 :     if (clip_rect) // If we had no explicit clipping rectangle then pos==clip_min

	test	eax, eax
	je	SHORT $LN3@RenderText

; 3706 :         need_clipping |= (pos.x < clip_min->x) || (pos.y < clip_min->y);

	movss	xmm0, DWORD PTR [edx]
	comiss	xmm0, xmm2
	ja	SHORT $LN18@RenderText
	movss	xmm0, DWORD PTR [edx+4]
	comiss	xmm0, xmm1
	ja	SHORT $LN18@RenderText
	xor	eax, eax
	jmp	SHORT $LN19@RenderText
$LN18@RenderText:
	mov	eax, 1
$LN19@RenderText:
	or	cl, al
$LN3@RenderText:

; 3709 :     if (align.x > 0.0f) pos.x = ImMax(pos.x, pos.x + (pos_max.x - pos.x - text_size.x) * align.x);

	mov	eax, DWORD PTR _align$[ebp]
	movss	xmm3, DWORD PTR [eax]
	comiss	xmm3, xmm6
	jbe	SHORT $LN25@RenderText
	mov	esi, DWORD PTR _pos_max$[ebp]
	movss	xmm0, DWORD PTR [esi]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 128  : static inline float  ImMax(float lhs, float rhs)                                { return lhs >= rhs ? lhs : rhs; }

	mov	esi, DWORD PTR _text$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3709 :     if (align.x > 0.0f) pos.x = ImMax(pos.x, pos.x + (pos_max.x - pos.x - text_size.x) * align.x);

	subss	xmm0, xmm2
	subss	xmm0, xmm5
	mulss	xmm0, xmm3
	addss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 128  : static inline float  ImMax(float lhs, float rhs)                                { return lhs >= rhs ? lhs : rhs; }

	comiss	xmm2, xmm0
	jae	SHORT $LN25@RenderText
	movss	DWORD PTR _pos$[ebp], xmm0
$LN25@RenderText:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3710 :     if (align.y > 0.0f) pos.y = ImMax(pos.y, pos.y + (pos_max.y - pos.y - text_size.y) * align.y);

	movss	xmm2, DWORD PTR [eax+4]
	comiss	xmm2, xmm6
	jbe	SHORT $LN29@RenderText
	mov	eax, DWORD PTR _pos_max$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	subss	xmm0, xmm1
	subss	xmm0, xmm4
	mulss	xmm0, xmm2
	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 128  : static inline float  ImMax(float lhs, float rhs)                                { return lhs >= rhs ? lhs : rhs; }

	comiss	xmm1, xmm0
	jae	SHORT $LN29@RenderText
	movss	DWORD PTR _pos$[ebp+4], xmm0
$LN29@RenderText:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3713 :     if (need_clipping)

	test	cl, cl
	je	SHORT $LN6@RenderText
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 109  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

	movss	xmm0, DWORD PTR [edx]
	mov	eax, DWORD PTR _clip_max$1$[ebp]
	movss	DWORD PTR _fine_clip_rect$1[ebp], xmm0
	movss	xmm0, DWORD PTR [edx+4]
	movss	DWORD PTR _fine_clip_rect$1[ebp+4], xmm0
	movss	xmm0, DWORD PTR [eax+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3716 :         window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, &fine_clip_rect);

	lea	eax, DWORD PTR _fine_clip_rect$1[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 109  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

	movss	DWORD PTR _fine_clip_rect$1[ebp+8], xmm7
	movss	DWORD PTR _fine_clip_rect$1[ebp+12], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3716 :         window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, &fine_clip_rect);

	push	eax

; 3717 :     }
; 3718 :     else

	jmp	SHORT $LN33@RenderText
$LN6@RenderText:

; 3719 :     {
; 3720 :         window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, NULL);

	push	0
$LN33@RenderText:
	push	ecx
	mov	DWORD PTR [esp], 0
	push	edi
	push	esi
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	0
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	movss	xmm0, DWORD PTR [ebx+6172]
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR _window$1$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR [ebx+6168]
	mov	ecx, DWORD PTR [ecx+624]
	call	?AddText@ImDrawList@@QAEXPBUImFont@@MABUImVec2@@IPBD2MPBUImVec4@@@Z ; ImDrawList::AddText

; 3721 :     }
; 3722 :     if (g.LogEnabled)

	cmp	BYTE PTR [ebx+11600], 0
	pop	ebx
	je	SHORT $LN8@RenderText

; 3723 :         LogRenderedText(pos, text, text_display_end);

	push	edi
	lea	eax, DWORD PTR _pos$[ebp]
	push	esi
	push	eax
	call	?LogRenderedText@@YAXABUImVec2@@PBD1@Z	; LogRenderedText
	add	esp, 12					; 0000000cH
$LN8@RenderText:
	pop	edi
	pop	esi

; 3724 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RenderTextClipped@ImGui@@YAXABUImVec2@@0PBD1PBU2@0PBUImRect@@@Z ENDP ; ImGui::RenderTextClipped
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_pos$ = 8						; size = 8
_text$ = 16						; size = 4
_text_end$ = 20						; size = 4
_wrap_width$ = 24					; size = 4
?RenderTextWrapped@ImGui@@YAXUImVec2@@PBD1M@Z PROC	; ImGui::RenderTextWrapped

; 3669 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx

; 3670 :     ImGuiContext& g = *GImGui;

	mov	ebx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	esi

; 3673 :     if (!text_end)

	mov	esi, DWORD PTR _text_end$[ebp]
	push	edi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ebx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3673 :     if (!text_end)

	mov	edi, DWORD PTR _text$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	BYTE PTR [eax+134], 1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3673 :     if (!text_end)

	test	esi, esi
	jne	SHORT $LN2@RenderText

; 3674 :         text_end = text + strlen(text); // FIXME-OPT

	mov	ecx, edi
	lea	edx, DWORD PTR [ecx+1]
	npad	6
$LL8@RenderText:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL8@RenderText
	sub	ecx, edx
	lea	esi, DWORD PTR [ecx+edi]
$LN2@RenderText:

; 3675 : 
; 3676 :     const int text_len = (int)(text_end - text);

	mov	eax, esi
	sub	eax, edi

; 3677 :     if (text_len > 0)

	test	eax, eax
	jle	SHORT $LN4@RenderText

; 3678 :     {
; 3679 :         window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_end, wrap_width);

	movss	xmm0, DWORD PTR _wrap_width$[ebp]
	push	0
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	esi
	push	edi
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	0
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	movss	xmm0, DWORD PTR [ebx+6172]
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR [ebx+6240]
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR [ebx+6168]
	mov	ecx, DWORD PTR [ecx+624]
	call	?AddText@ImDrawList@@QAEXPBUImFont@@MABUImVec2@@IPBD2MPBUImVec4@@@Z ; ImDrawList::AddText

; 3680 :         if (g.LogEnabled)

	cmp	BYTE PTR [ebx+11600], 0
	je	SHORT $LN4@RenderText

; 3681 :             LogRenderedText(pos, text, text_end);

	push	esi
	lea	eax, DWORD PTR _pos$[ebp]
	push	edi
	push	eax
	call	?LogRenderedText@@YAXABUImVec2@@PBD1@Z	; LogRenderedText
	add	esp, 12					; 0000000cH
$LN4@RenderText:
	pop	edi
	pop	esi
	pop	ebx

; 3682 :     }
; 3683 : }

	pop	ebp
	ret	0
?RenderTextWrapped@ImGui@@YAXUImVec2@@PBD1M@Z ENDP	; ImGui::RenderTextWrapped
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_pos$ = 8						; size = 8
_text$ = 16						; size = 4
_text_end$ = 20						; size = 4
_hide_text_after_hash$ = 24				; size = 1
?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z PROC		; ImGui::RenderText

; 3642 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 3648 :     if (hide_text_after_hash)

	cmp	BYTE PTR _hide_text_after_hash$[ebp], 0
	push	ebx
	mov	ebx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	esi

; 3649 :     {
; 3650 :         text_display_end = FindRenderedTextEnd(text, text_end);

	mov	esi, DWORD PTR _text$[ebp]
	push	edi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ebx+6240]
	mov	BYTE PTR [eax+134], 1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3648 :     if (hide_text_after_hash)

	je	SHORT $LN2@RenderText

; 3649 :     {
; 3650 :         text_display_end = FindRenderedTextEnd(text, text_end);

	push	DWORD PTR _text_end$[ebp]
	push	esi
	call	?FindRenderedTextEnd@ImGui@@YAPBDPBD0@Z	; ImGui::FindRenderedTextEnd
	add	esp, 8
	mov	edi, eax

; 3651 :     }
; 3652 :     else

	jmp	SHORT $LN4@RenderText
$LN2@RenderText:

; 3653 :     {
; 3654 :         if (!text_end)

	mov	edi, DWORD PTR _text_end$[ebp]
	test	edi, edi
	jne	SHORT $LN4@RenderText

; 3655 :             text_end = text + strlen(text); // FIXME-OPT

	mov	ecx, esi
	lea	edx, DWORD PTR [ecx+1]
$LL10@RenderText:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL10@RenderText
	sub	ecx, edx
	lea	edi, DWORD PTR [ecx+esi]
$LN4@RenderText:

; 3656 :         text_display_end = text_end;
; 3657 :     }
; 3658 : 
; 3659 :     const int text_len = (int)(text_display_end - text);

	mov	eax, edi
	sub	eax, esi

; 3660 :     if (text_len > 0)

	test	eax, eax
	jle	SHORT $LN6@RenderText

; 3661 :     {
; 3662 :         window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_display_end);

	push	0
	push	ecx
	mov	DWORD PTR [esp], 0
	push	edi
	push	esi
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	0
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	movss	xmm0, DWORD PTR [ebx+6172]
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR _pos$[ebp]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR [ebx+6240]
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR [ebx+6168]
	mov	ecx, DWORD PTR [ecx+624]
	call	?AddText@ImDrawList@@QAEXPBUImFont@@MABUImVec2@@IPBD2MPBUImVec4@@@Z ; ImDrawList::AddText

; 3663 :         if (g.LogEnabled)

	cmp	BYTE PTR [ebx+11600], 0
	je	SHORT $LN6@RenderText

; 3664 :             LogRenderedText(pos, text, text_display_end);

	push	edi
	lea	eax, DWORD PTR _pos$[ebp]
	push	esi
	push	eax
	call	?LogRenderedText@@YAXABUImVec2@@PBD1@Z	; LogRenderedText
	add	esp, 12					; 0000000cH
$LN6@RenderText:
	pop	edi
	pop	esi
	pop	ebx

; 3665 :     }
; 3666 : }

	pop	ebp
	ret	0
?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z ENDP		; ImGui::RenderText
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_t$ = 8							; size = 4
_t_prev$ = 12						; size = 4
_repeat_delay$ = 16					; size = 4
_repeat_rate$ = 20					; size = 4
?CalcTypematicPressedRepeatAmount@ImGui@@YAHMMMM@Z PROC	; ImGui::CalcTypematicPressedRepeatAmount

; 3937 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 3938 :     if (t == 0.0f)

	movss	xmm0, DWORD PTR _t$[ebp]
	xorps	xmm1, xmm1
	ucomiss	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@CalcTypema

; 3939 :         return 1;

	mov	eax, 1

; 3944 : }

	pop	ebp
	ret	0
$LN2@CalcTypema:

; 3940 :     if (t <= repeat_delay || repeat_rate <= 0.0f)

	movss	xmm2, DWORD PTR _repeat_delay$[ebp]
	comiss	xmm2, xmm0
	jae	SHORT $LN4@CalcTypema
	movss	xmm3, DWORD PTR _repeat_rate$[ebp]
	comiss	xmm1, xmm3
	jae	SHORT $LN4@CalcTypema

; 3942 :     const int count = (int)((t - repeat_delay) / repeat_rate) - (int)((t_prev - repeat_delay) / repeat_rate);

	movss	xmm1, DWORD PTR __real@3f800000
	subss	xmm0, xmm2
	divss	xmm1, xmm3
	mulss	xmm0, xmm1
	cvttss2si ecx, xmm0
	movss	xmm0, DWORD PTR _t_prev$[ebp]
	subss	xmm0, xmm2
	mulss	xmm0, xmm1
	cvttss2si eax, xmm0
	sub	ecx, eax

; 3943 :     return (count > 0) ? count : 0;

	xor	eax, eax
	test	ecx, ecx
	cmovg	eax, ecx

; 3944 : }

	pop	ebp
	ret	0
$LN4@CalcTypema:

; 3941 :         return 0;

	xor	eax, eax

; 3944 : }

	pop	ebp
	ret	0
?CalcTypematicPressedRepeatAmount@ImGui@@YAHMMMM@Z ENDP	; ImGui::CalcTypematicPressedRepeatAmount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_popup_ref$ = -60					; size = 32
$T1 = -28						; size = 8
$T2 = -28						; size = 8
_current_stack_size$1$ = -20				; size = 4
_mouse_pos$2$ = -16					; size = 4
_mouse_pos$1$ = -12					; size = 4
_window$1$ = -8						; size = 4
_id$1$ = -4						; size = 4
_str_id$ = 8						; size = 4
_reopen_existing$ = 12					; size = 1
?OpenPopupEx@ImGui@@YAXPBD_N@Z PROC			; ImGui::OpenPopupEx

; 4256 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	push	ebx

; 4257 :     ImGuiContext& g = *GImGui;

	mov	ebx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	esi
	push	edi

; 4258 :     ImGuiWindow* window = g.CurrentWindow;
; 4259 :     ImGuiID id = window->GetID(str_id);

	push	0
	mov	eax, DWORD PTR [ebx+6240]
	mov	ecx, eax
	push	DWORD PTR _str_id$[ebp]
	mov	DWORD PTR _window$1$[ebp], eax
	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID

; 4260 :     int current_stack_size = g.CurrentPopupStack.Size;
; 4261 :     ImVec2 mouse_pos = g.IO.MousePos;
; 4262 :     ImVec2 popup_pos = (!g.NavDisableHighlight && g.NavDisableMouseHover) ? NavCalcPreferredMousePos() : mouse_pos;

	cmp	BYTE PTR [ebx+6454], 0
	mov	ecx, DWORD PTR [ebx+6368]
	mov	DWORD PTR _id$1$[ebp], eax
	mov	eax, DWORD PTR [ebx+208]
	mov	DWORD PTR _mouse_pos$1$[ebp], eax
	mov	eax, DWORD PTR [ebx+212]
	mov	DWORD PTR _current_stack_size$1$[ebp], ecx
	mov	DWORD PTR _mouse_pos$2$[ebp], eax
	jne	SHORT $LN7@OpenPopupE
	cmp	BYTE PTR [ebx+6455], 0
	je	SHORT $LN7@OpenPopupE
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?NavCalcPreferredMousePos@@YA?AUImVec2@@XZ ; NavCalcPreferredMousePos
	add	esp, 4
	jmp	SHORT $LN8@OpenPopupE
$LN7@OpenPopupE:
	mov	eax, DWORD PTR [ebx+208]
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR [ebx+212]
	mov	DWORD PTR $T1[ebp+4], eax
	lea	eax, DWORD PTR $T1[ebp]
$LN8@OpenPopupE:
	mov	esi, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 380  :     ImGuiPopupRef(ImGuiID id, ImGuiWindow* parent_window, ImGuiID parent_menu_set, const ImVec2& popup_pos, const ImVec2& mouse_pos) { PopupId = id; Window = NULL; ParentWindow = parent_window; ParentMenuSet = parent_menu_set; PopupPosOnOpen = popup_pos; MousePosOnOpen = mouse_pos; }

	mov	eax, DWORD PTR _id$1$[ebp]
	mov	ecx, DWORD PTR _window$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4263 :     ImGuiPopupRef popup_ref = ImGuiPopupRef(id, window, window->GetID("##menus"), popup_pos, mouse_pos); // Tagged as new ref because constructor sets Window to NULL (we are passing the ParentWindow info here)

	push	0
	push	OFFSET $SG117642
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 380  :     ImGuiPopupRef(ImGuiID id, ImGuiWindow* parent_window, ImGuiID parent_menu_set, const ImVec2& popup_pos, const ImVec2& mouse_pos) { PopupId = id; Window = NULL; ParentWindow = parent_window; ParentMenuSet = parent_menu_set; PopupPosOnOpen = popup_pos; MousePosOnOpen = mouse_pos; }

	mov	DWORD PTR _popup_ref$[ebp], eax
	mov	DWORD PTR _popup_ref$[ebp+4], 0
	mov	DWORD PTR _popup_ref$[ebp+8], ecx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4263 :     ImGuiPopupRef popup_ref = ImGuiPopupRef(id, window, window->GetID("##menus"), popup_pos, mouse_pos); // Tagged as new ref because constructor sets Window to NULL (we are passing the ParentWindow info here)

	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 380  :     ImGuiPopupRef(ImGuiID id, ImGuiWindow* parent_window, ImGuiID parent_menu_set, const ImVec2& popup_pos, const ImVec2& mouse_pos) { PopupId = id; Window = NULL; ParentWindow = parent_window; ParentMenuSet = parent_menu_set; PopupPosOnOpen = popup_pos; MousePosOnOpen = mouse_pos; }

	mov	DWORD PTR _popup_ref$[ebp+12], eax
	mov	eax, DWORD PTR _mouse_pos$1$[ebp]
	mov	DWORD PTR _popup_ref$[ebp+16], esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4264 :     if (g.OpenPopupStack.Size < current_stack_size + 1)

	mov	esi, DWORD PTR _current_stack_size$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 380  :     ImGuiPopupRef(ImGuiID id, ImGuiWindow* parent_window, ImGuiID parent_menu_set, const ImVec2& popup_pos, const ImVec2& mouse_pos) { PopupId = id; Window = NULL; ParentWindow = parent_window; ParentMenuSet = parent_menu_set; PopupPosOnOpen = popup_pos; MousePosOnOpen = mouse_pos; }

	mov	DWORD PTR _popup_ref$[ebp+24], eax
	mov	eax, DWORD PTR _mouse_pos$2$[ebp]
	mov	DWORD PTR _popup_ref$[ebp+28], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4264 :     if (g.OpenPopupStack.Size < current_stack_size + 1)

	lea	eax, DWORD PTR [esi+1]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 380  :     ImGuiPopupRef(ImGuiID id, ImGuiWindow* parent_window, ImGuiID parent_menu_set, const ImVec2& popup_pos, const ImVec2& mouse_pos) { PopupId = id; Window = NULL; ParentWindow = parent_window; ParentMenuSet = parent_menu_set; PopupPosOnOpen = popup_pos; MousePosOnOpen = mouse_pos; }

	mov	DWORD PTR _popup_ref$[ebp+20], edi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4264 :     if (g.OpenPopupStack.Size < current_stack_size + 1)

	cmp	DWORD PTR [ebx+6356], eax
	jge	SHORT $LN2@OpenPopupE

; 4265 :         g.OpenPopupStack.push_back(popup_ref);

	lea	eax, DWORD PTR _popup_ref$[ebp]
	push	eax
	lea	ecx, DWORD PTR [ebx+6356]
	call	?push_back@?$ImVector@UImGuiPopupRef@@@@QAEXABUImGuiPopupRef@@@Z ; ImVector<ImGuiPopupRef>::push_back
	pop	edi
	pop	esi
	pop	ebx

; 4270 :     }
; 4271 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@OpenPopupE:

; 4266 :     else if (reopen_existing || g.OpenPopupStack[current_stack_size].PopupId != id)

	cmp	BYTE PTR _reopen_existing$[ebp], 0
	jne	SHORT $LN5@OpenPopupE
	mov	eax, DWORD PTR [ebx+6364]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	mov	ecx, esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4266 :     else if (reopen_existing || g.OpenPopupStack[current_stack_size].PopupId != id)

	mov	edi, DWORD PTR _id$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	shl	ecx, 5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4266 :     else if (reopen_existing || g.OpenPopupStack[current_stack_size].PopupId != id)

	cmp	DWORD PTR [ecx+eax], edi
	je	SHORT $LN4@OpenPopupE
	lea	eax, DWORD PTR [esi+1]
$LN5@OpenPopupE:

; 4267 :     {
; 4268 :         g.OpenPopupStack.resize(current_stack_size+1);

	push	eax
	lea	ecx, DWORD PTR [ebx+6356]
	call	?resize@?$ImVector@UImGuiPopupRef@@@@QAEXH@Z ; ImVector<ImGuiPopupRef>::resize
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	mov	eax, DWORD PTR [ebx+6364]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4269 :         g.OpenPopupStack[current_stack_size] = popup_ref;

	movups	xmm0, XMMWORD PTR _popup_ref$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	shl	esi, 5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4269 :         g.OpenPopupStack[current_stack_size] = popup_ref;

	movups	XMMWORD PTR [eax+esi], xmm0
	movups	xmm0, XMMWORD PTR _popup_ref$[ebp+16]
	movups	XMMWORD PTR [eax+esi+16], xmm0
$LN4@OpenPopupE:
	pop	edi
	pop	esi
	pop	ebx

; 4270 :     }
; 4271 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?OpenPopupEx@ImGui@@YAXPBD_N@Z ENDP			; ImGui::OpenPopupEx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?PopItemFlag@ImGui@@YAXXZ PROC				; ImGui::PopItemFlag
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	edx, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [edx+324]

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	cmp	DWORD PTR [edx+324], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5610 :     window->DC.ItemFlags = window->DC.ItemFlagsStack.empty() ? ImGuiItemFlags_Default_ : window->DC.ItemFlagsStack.back();

	jne	SHORT $LN3@PopItemFla
	mov	DWORD PTR [edx+312], 3

; 5611 : }

	ret	0
$LN3@PopItemFla:

; 5610 :     window->DC.ItemFlags = window->DC.ItemFlagsStack.empty() ? ImGuiItemFlags_Default_ : window->DC.ItemFlagsStack.back();

	mov	ecx, DWORD PTR [edx+324]
	mov	eax, DWORD PTR [edx+332]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	mov	DWORD PTR [edx+312], eax

; 5611 : }

	ret	0
?PopItemFlag@ImGui@@YAXXZ ENDP				; ImGui::PopItemFlag
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_option$ = 8						; size = 4
_enabled$ = 12						; size = 1
?PushItemFlag@ImGui@@YAXH_N@Z PROC			; ImGui::PushItemFlag

; 5597 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 5598 :     ImGuiWindow* window = GetCurrentWindow();
; 5599 :     if (enabled)

	cmp	BYTE PTR _enabled$[ebp], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	edx, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5600 :         window->DC.ItemFlags |= option;

	mov	eax, DWORD PTR _option$[ebp]
	lea	ecx, DWORD PTR [edx+312]
	je	SHORT $LN2@PushItemFl
	or	DWORD PTR [ecx], eax

; 5603 :     window->DC.ItemFlagsStack.push_back(window->DC.ItemFlags);

	push	ecx
	lea	ecx, DWORD PTR [edx+324]
	call	?push_back@?$ImVector@H@@QAEXABH@Z	; ImVector<int>::push_back

; 5604 : }

	pop	ebp
	ret	0
$LN2@PushItemFl:

; 5601 :     else
; 5602 :         window->DC.ItemFlags &= ~option;

	not	eax
	and	DWORD PTR [ecx], eax

; 5603 :     window->DC.ItemFlagsStack.push_back(window->DC.ItemFlags);

	push	ecx
	lea	ecx, DWORD PTR [edx+324]
	call	?push_back@?$ImVector@H@@QAEXABH@Z	; ImVector<int>::push_back

; 5604 : }

	pop	ebp
	ret	0
?PushItemFlag@ImGui@@YAXH_N@Z ENDP			; ImGui::PushItemFlag
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 8
_pos$ = 8						; size = 4
tv180 = 12						; size = 4
_wrap_pos_x$ = 12					; size = 4
?CalcWrapWidthForPos@ImGui@@YAMABUImVec2@@M@Z PROC	; ImGui::CalcWrapWidthForPos

; 2301 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2302 :     if (wrap_pos_x < 0.0f)

	movss	xmm1, DWORD PTR _wrap_pos_x$[ebp]
	xorps	xmm0, xmm0
	sub	esp, 8
	comiss	xmm0, xmm1
	jbe	SHORT $LN2@CalcWrapWi

; 2303 :         return 0.0f;

	fldz

; 2312 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@CalcWrapWi:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 792  :     inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2306 :     if (wrap_pos_x == 0.0f)

	ucomiss	xmm1, xmm0
	push	esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 792  :     inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }

	mov	esi, DWORD PTR [eax+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2306 :     if (wrap_pos_x == 0.0f)

	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@CalcWrapWi

; 2307 :         wrap_pos_x = GetContentRegionMax().x + window->Pos.x;

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?GetContentRegionMax@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetContentRegionMax
	movss	xmm1, DWORD PTR [esi+24]
	add	esp, 4
	addss	xmm1, DWORD PTR [eax]
	jmp	SHORT $LN5@CalcWrapWi
$LN3@CalcWrapWi:

; 2308 :     else if (wrap_pos_x > 0.0f)

	comiss	xmm1, xmm0
	jbe	SHORT $LN5@CalcWrapWi

; 2309 :         wrap_pos_x += window->Pos.x - window->Scroll.x; // wrap_pos_x is provided is window local space

	movss	xmm0, DWORD PTR [esi+24]
	subss	xmm0, DWORD PTR [esi+92]
	addss	xmm1, xmm0
$LN5@CalcWrapWi:

; 2310 : 
; 2311 :     return ImMax(wrap_pos_x - pos.x, 1.0f);

	mov	eax, DWORD PTR _pos$[ebp]
	pop	esi
	subss	xmm1, DWORD PTR [eax]
	maxss	xmm1, DWORD PTR __real@3f800000
	movss	DWORD PTR tv180[ebp], xmm1
	fld	DWORD PTR tv180[ebp]

; 2312 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CalcWrapWidthForPos@ImGui@@YAMABUImVec2@@M@Z ENDP	; ImGui::CalcWrapWidthForPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T2 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
_size$ = 12						; size = 8
_default_x$ = 20					; size = 4
_default_y$ = 24					; size = 4
?CalcItemSize@ImGui@@YA?AUImVec2@@U2@MM@Z PROC		; ImGui::CalcItemSize

; 2288 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2289 :     ImGuiContext& g = *GImGui;
; 2290 :     ImVec2 content_max;
; 2291 :     if (size.x < 0.0f || size.y < 0.0f)

	movss	xmm4, DWORD PTR _size$[ebp]
	sub	esp, 8
	xorps	xmm2, xmm2
	xorps	xmm1, xmm1
	comiss	xmm2, xmm4
	push	esi
	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	xorps	xmm0, xmm0
	ja	SHORT $LN3@CalcItemSi
	movss	xmm3, DWORD PTR _size$[ebp+4]
	comiss	xmm2, xmm3
	jbe	SHORT $LN2@CalcItemSi
$LN3@CalcItemSi:

; 2292 :         content_max = g.CurrentWindow->Pos + GetContentRegionMax();

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?GetContentRegionMax@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetContentRegionMax
	mov	ecx, DWORD PTR [esi+6240]
	add	esp, 4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm3, DWORD PTR _size$[ebp+4]
	xorps	xmm2, xmm2
	movss	xmm4, DWORD PTR _size$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [eax]
	movss	xmm1, DWORD PTR [ecx+28]
	addss	xmm0, DWORD PTR [ecx+24]
	addss	xmm1, DWORD PTR [eax+4]
$LN2@CalcItemSi:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2293 :     if (size.x <= 0.0f)

	comiss	xmm2, xmm4
	movss	xmm5, DWORD PTR __real@40800000
	jb	SHORT $LN8@CalcItemSi

; 2294 :         size.x = (size.x == 0.0f) ? default_x : ImMax(content_max.x - g.CurrentWindow->DC.CursorPos.x, 4.0f) + size.x;

	ucomiss	xmm4, xmm2
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@CalcItemSi
	movss	xmm0, DWORD PTR _default_x$[ebp]
	jmp	SHORT $LN25@CalcItemSi
$LN7@CalcItemSi:
	mov	eax, DWORD PTR [esi+6240]
	subss	xmm0, DWORD PTR [eax+192]
	maxss	xmm0, xmm5
	addss	xmm0, xmm4
$LN25@CalcItemSi:
	movss	DWORD PTR _size$[ebp], xmm0
$LN8@CalcItemSi:

; 2295 :     if (size.y <= 0.0f)

	comiss	xmm2, xmm3
	jb	SHORT $LN10@CalcItemSi

; 2296 :         size.y = (size.y == 0.0f) ? default_y : ImMax(content_max.y - g.CurrentWindow->DC.CursorPos.y, 4.0f) + size.y;

	ucomiss	xmm3, xmm2
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN9@CalcItemSi

; 2297 :     return size;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	movss	xmm0, DWORD PTR _default_y$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	movss	DWORD PTR _size$[ebp+4], xmm0
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _size$[ebp+4]
	mov	DWORD PTR [eax+4], ecx
	pop	esi

; 2298 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@CalcItemSi:

; 2296 :         size.y = (size.y == 0.0f) ? default_y : ImMax(content_max.y - g.CurrentWindow->DC.CursorPos.y, 4.0f) + size.y;

	mov	eax, DWORD PTR [esi+6240]
	subss	xmm1, DWORD PTR [eax+196]
	maxss	xmm1, xmm5
	addss	xmm1, xmm3
	movss	DWORD PTR _size$[ebp+4], xmm1
$LN10@CalcItemSi:

; 2297 :     return size;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	pop	esi
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _size$[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 2298 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CalcItemSize@ImGui@@YA?AUImVec2@@U2@MM@Z ENDP		; ImGui::CalcItemSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_window$ = 8						; size = 4
?FocusableItemUnregister@ImGui@@YAXPAUImGuiWindow@@@Z PROC ; ImGui::FocusableItemUnregister

; 2282 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2283 :     window->FocusIdxAllCounter--;

	mov	eax, DWORD PTR _window$[ebp]
	dec	DWORD PTR [eax+644]

; 2284 :     window->FocusIdxTabCounter--;

	dec	DWORD PTR [eax+648]

; 2285 : }

	pop	ebp
	ret	0
?FocusableItemUnregister@ImGui@@YAXPAUImGuiWindow@@@Z ENDP ; ImGui::FocusableItemUnregister
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_window$ = 8						; size = 4
_id$ = 12						; size = 4
_tab_stop$ = 16						; size = 1
?FocusableItemRegister@ImGui@@YA_NPAUImGuiWindow@@I_N@Z PROC ; ImGui::FocusableItemRegister

; 2257 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 2258 :     ImGuiContext& g = *GImGui;
; 2259 : 
; 2260 :     const bool allow_keyboard_focus = (window->DC.ItemFlags & ImGuiItemFlags_AllowKeyboardFocus) != 0;

	mov	esi, DWORD PTR _window$[ebp]
	push	edi
	mov	edi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	bl, BYTE PTR [esi+312]

; 2261 :     window->FocusIdxAllCounter++;

	inc	DWORD PTR [esi+644]
	and	bl, 1

; 2262 :     if (allow_keyboard_focus)

	je	SHORT $LN2@FocusableI

; 2263 :         window->FocusIdxTabCounter++;

	inc	DWORD PTR [esi+648]
$LN2@FocusableI:

; 2264 : 
; 2265 :     // Process keyboard input at this point: TAB/Shift-TAB to tab out of the currently focused item.
; 2266 :     // Note that we can always TAB out of a widget that doesn't allow tabbing in.
; 2267 :     if (tab_stop && (g.ActiveId == id) && window->FocusIdxAllRequestNext == INT_MAX && window->FocusIdxTabRequestNext == INT_MAX && !g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_Tab))

	cmp	BYTE PTR _tab_stop$[ebp], 0
	mov	ecx, DWORD PTR _id$[ebp]
	je	SHORT $LN3@FocusableI
	cmp	DWORD PTR [edi+6264], ecx
	jne	SHORT $LN3@FocusableI
	cmp	DWORD PTR [esi+660], 2147483647		; 7fffffffH
	jne	SHORT $LN3@FocusableI
	cmp	DWORD PTR [esi+664], 2147483647		; 7fffffffH
	jne	SHORT $LN3@FocusableI
	cmp	BYTE PTR [edi+229], 0
	jne	SHORT $LN3@FocusableI
	push	1
	push	0
	call	?IsKeyPressedMap@@YA_NH_N@Z		; IsKeyPressedMap
	add	esp, 8
	test	al, al
	je	SHORT $LN9@FocusableI

; 2268 :         window->FocusIdxTabRequestNext = window->FocusIdxTabCounter + (g.IO.KeyShift ? (allow_keyboard_focus ? -1 : 0) : +1); // Modulo on index will be applied at the end of frame once we've got the total counter of items.

	cmp	BYTE PTR [edi+230], 0
	je	SHORT $LN7@FocusableI
	movzx	ecx, bl
	neg	ecx
	sbb	ecx, ecx
	jmp	SHORT $LN8@FocusableI
$LN7@FocusableI:
	mov	ecx, 1
$LN8@FocusableI:
	mov	eax, DWORD PTR [esi+648]
	add	eax, ecx
	mov	DWORD PTR [esi+664], eax
$LN9@FocusableI:
	mov	ecx, DWORD PTR _id$[ebp]
$LN3@FocusableI:

; 2269 : 
; 2270 :     if (window->FocusIdxAllCounter == window->FocusIdxAllRequestCurrent)

	mov	eax, DWORD PTR [esi+644]
	cmp	eax, DWORD PTR [esi+652]
	je	SHORT $LN11@FocusableI

; 2271 :         return true;
; 2272 :     if (allow_keyboard_focus && window->FocusIdxTabCounter == window->FocusIdxTabRequestCurrent)

	test	bl, bl
	je	SHORT $LN5@FocusableI
	mov	eax, DWORD PTR [esi+648]
	cmp	eax, DWORD PTR [esi+656]
	jne	SHORT $LN5@FocusableI

; 2273 :     {
; 2274 :         g.NavTabbedId = id;

	mov	DWORD PTR [edi+6396], ecx
$LN11@FocusableI:
	pop	edi
	pop	esi

; 2275 :         return true;

	mov	al, 1
	pop	ebx

; 2279 : }

	pop	ebp
	ret	0
$LN5@FocusableI:
	pop	edi
	pop	esi

; 2276 :     }
; 2277 : 
; 2278 :     return false;

	xor	al, al
	pop	ebx

; 2279 : }

	pop	ebp
	ret	0
?FocusableItemRegister@ImGui@@YA_NPAUImGuiWindow@@I_N@Z ENDP ; ImGui::FocusableItemRegister
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_bb$ = 8						; size = 4
_id$ = 12						; size = 4
_flatten_childs$ = 16					; size = 1
?IsHovered@ImGui@@YA_NABUImRect@@I_N@Z PROC		; ImGui::IsHovered

; 2243 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2244 :     ImGuiContext& g = *GImGui;
; 2245 :     if (g.HoveredId == 0 || g.HoveredId == id || g.HoveredIdAllowOverlap)

	mov	edx, DWORD PTR _id$[ebp]
	push	esi
	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [esi+6252]
	test	eax, eax
	je	SHORT $LN3@IsHovered
	cmp	eax, edx
	je	SHORT $LN3@IsHovered
	cmp	BYTE PTR [esi+6256], 0
	je	SHORT $LN8@IsHovered
$LN3@IsHovered:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 792  :     inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }

	mov	ecx, DWORD PTR [esi+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2248 :         if (g.HoveredWindow == window || (flatten_childs && g.HoveredRootWindow == window->RootWindow))

	cmp	DWORD PTR [esi+6244], ecx
	je	SHORT $LN5@IsHovered
	cmp	BYTE PTR _flatten_childs$[ebp], 0
	je	SHORT $LN8@IsHovered
	mov	eax, DWORD PTR [esi+6248]
	cmp	eax, DWORD PTR [ecx+632]
	jne	SHORT $LN8@IsHovered
$LN5@IsHovered:

; 2249 :             if ((g.ActiveId == 0 || g.ActiveId == id || g.ActiveIdAllowOverlap) && IsMouseHoveringRect(bb.Min, bb.Max))

	mov	eax, DWORD PTR [esi+6264]
	test	eax, eax
	je	SHORT $LN7@IsHovered
	cmp	eax, edx
	je	SHORT $LN7@IsHovered
	cmp	BYTE PTR [esi+6274], 0
	je	SHORT $LN8@IsHovered
$LN7@IsHovered:
	mov	ecx, DWORD PTR _bb$[ebp]
	push	1
	lea	eax, DWORD PTR [ecx+8]
	push	eax
	push	ecx
	call	?IsMouseHoveringRect@ImGui@@YA_NABUImVec2@@0_N@Z ; ImGui::IsMouseHoveringRect
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN8@IsHovered

; 2250 :                 if (!g.NavDisableMouseHover && IsWindowContentHoverable(g.HoveredRootWindow))

	cmp	BYTE PTR [esi+6455], 0
	jne	SHORT $LN8@IsHovered
	push	DWORD PTR [esi+6248]
	call	?IsWindowContentHoverable@@YA_NPAUImGuiWindow@@@Z ; IsWindowContentHoverable
	add	esp, 4
	test	al, al
	je	SHORT $LN8@IsHovered

; 2251 :                     return true;

	mov	al, 1
	pop	esi

; 2254 : }

	pop	ebp
	ret	0
$LN8@IsHovered:

; 2252 :     }
; 2253 :     return false;

	xor	al, al
	pop	esi

; 2254 : }

	pop	ebp
	ret	0
?IsHovered@ImGui@@YA_NABUImRect@@I_N@Z ENDP		; ImGui::IsHovered
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_bb$ = 8						; size = 4
_id$ = 12						; size = 4
_clip_even_when_logged$ = 16				; size = 1
?IsClippedEx@ImGui@@YA_NABUImRect@@PBI_N@Z PROC		; ImGui::IsClippedEx

; 2231 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2232 :     ImGuiContext& g = *GImGui;

	mov	edx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 254  :     bool        Overlaps(const ImRect& r) const { return r.Min.y < Max.y  && r.Max.y > Min.y  && r.Min.x < Max.x && r.Max.x > Min.x; }

	mov	ecx, DWORD PTR _bb$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2234 :     if (!bb.Overlaps(window->ClipRect))

	mov	eax, DWORD PTR [edx+6240]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 254  :     bool        Overlaps(const ImRect& r) const { return r.Min.y < Max.y  && r.Max.y > Min.y  && r.Min.x < Max.x && r.Max.x > Min.x; }

	movss	xmm0, DWORD PTR [ecx+12]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2234 :     if (!bb.Overlaps(window->ClipRect))

	add	eax, 472				; 000001d8H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 254  :     bool        Overlaps(const ImRect& r) const { return r.Min.y < Max.y  && r.Max.y > Min.y  && r.Min.x < Max.x && r.Max.x > Min.x; }

	comiss	xmm0, DWORD PTR [eax+4]
	jbe	SHORT $LN12@IsClippedE
	movss	xmm0, DWORD PTR [eax+12]
	comiss	xmm0, DWORD PTR [ecx+4]
	jbe	SHORT $LN12@IsClippedE
	movss	xmm0, DWORD PTR [ecx+8]
	comiss	xmm0, DWORD PTR [eax]
	jbe	SHORT $LN12@IsClippedE
	movss	xmm0, DWORD PTR [eax+8]
	comiss	xmm0, DWORD PTR [ecx]
	ja	SHORT $LN5@IsClippedE
$LN12@IsClippedE:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2235 :         if (!id || *id != GImGui->ActiveId)

	mov	eax, DWORD PTR _id$[ebp]
	test	eax, eax
	je	SHORT $LN4@IsClippedE
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR [edx+6264]
	je	SHORT $LN5@IsClippedE
$LN4@IsClippedE:

; 2236 :             if (clip_even_when_logged || !g.LogEnabled)

	cmp	BYTE PTR _clip_even_when_logged$[ebp], 0
	jne	SHORT $LN6@IsClippedE
	cmp	BYTE PTR [edx+11600], 0
	je	SHORT $LN6@IsClippedE
$LN5@IsClippedE:

; 2238 :     return false;

	xor	al, al

; 2239 : }

	pop	ebp
	ret	0
$LN6@IsClippedE:

; 2237 :                 return true;

	mov	al, 1

; 2239 : }

	pop	ebp
	ret	0
?IsClippedEx@ImGui@@YA_NABUImRect@@PBI_N@Z ENDP		; ImGui::IsClippedEx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_nav_bb_rel$1 = -40					; size = 16
$T2 = -24						; size = 8
$T3 = -16						; size = 8
_nav_bb$1$ = -8						; size = 4
_is_clipped$1$ = -1					; size = 1
_bb$ = 8						; size = 4
_id$ = 12						; size = 4
_nav_bb_arg$ = 16					; size = 4
?ItemAdd@ImGui@@YA_NABUImRect@@PBIPBU2@@Z PROC		; ImGui::ItemAdd

; 2159 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	ebx

; 2160 :     ImGuiContext& g = *GImGui;
; 2161 :     ImGuiWindow* window = g.CurrentWindow;
; 2162 :     window->DC.LastItemId = id ? *id : 0;

	mov	ebx, DWORD PTR _id$[ebp]
	push	esi
	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	edi
	mov	edi, DWORD PTR [esi+6240]
	test	ebx, ebx
	je	SHORT $LN19@ItemAdd
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN20@ItemAdd
$LN19@ItemAdd:
	xor	eax, eax
$LN20@ItemAdd:
	mov	DWORD PTR [edi+248], eax

; 2163 :     window->DC.LastItemRect = bb;

	mov	eax, DWORD PTR _bb$[ebp]

; 2164 :     window->DC.LastItemHoveredAndUsable = window->DC.LastItemHoveredRect = false;
; 2165 :     const bool is_clipped = IsClippedEx(bb, id, false);

	push	0
	push	ebx
	push	eax
	movups	xmm0, XMMWORD PTR [eax]
	mov	WORD PTR [edi+268], 0
	movups	XMMWORD PTR [edi+252], xmm0
	call	?IsClippedEx@ImGui@@YA_NABUImRect@@PBI_N@Z ; ImGui::IsClippedEx
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _is_clipped$1$[ebp], al

; 2166 :     if (id != NULL) 

	test	ebx, ebx
	je	$LN10@ItemAdd

; 2167 :         window->DC.NavLayerActiveFlagsNext |= (1 << window->DC.NavLayerCurrent);

	mov	ecx, DWORD PTR [edi+280]
	mov	edx, DWORD PTR [edi+272]
	bts	ecx, edx
	mov	DWORD PTR [edi+280], ecx

; 2168 : 
; 2169 : 	// Navigation processing runs prior to clipping early-out
; 2170 :     //  (a) So that NavInitDefaultRequest can be honored, for newly opened windows to select a default widget
; 2171 :     //  (b) So that we can scroll up/down past clipped items. This adds a small O(N) cost to regular navigation requests unfortunately, but it is still limited to one window. 
; 2172 :     //      it may not scale very well for windows with ten of thousands of item, but at least the NavRequest is only performed on user interaction, aka maximum once a frame.
; 2173 :     //      We could early out with `if (is_clipped && !g.NavInitDefaultRequest) return false;` but when we wouldn't be able to reach unclipped widgets. This would work if user had explicit scrolling control (e.g. mapped on a stick)
; 2174 :     //      A more pragmatic solution for handling last lists is relying on the fact that they are likely evenly spread items (so that clipper can work) and we could nav at higher-level (apply index, etc.)
; 2175 :     //      So eventually we would like to provide the user will the primitives to be able to implement that sort of customized/efficient navigation handling whenever necessary.
; 2176 :     if (id != NULL && g.IO.NavUsable && g.NavWindow == window->RootNavWindow)

	cmp	BYTE PTR [esi+848], 0
	je	$LN10@ItemAdd
	mov	ecx, DWORD PTR [esi+6380]
	cmp	ecx, DWORD PTR [edi+640]
	jne	$LN10@ItemAdd

; 2178 :         const ImRect& nav_bb = nav_bb_arg ? *nav_bb_arg : bb;

	mov	eax, DWORD PTR _nav_bb_arg$[ebp]
	test	eax, eax
	mov	ebx, DWORD PTR _bb$[ebp]
	cmovne	ebx, eax

; 2180 :         if (g.NavInitDefaultRequest && g.NavLayer == window->DC.NavLayerCurrent)

	cmp	BYTE PTR [esi+6456], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	mov	eax, ebx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2178 :         const ImRect& nav_bb = nav_bb_arg ? *nav_bb_arg : bb;

	mov	DWORD PTR _nav_bb$1$[ebp], ebx

; 2180 :         if (g.NavInitDefaultRequest && g.NavLayer == window->DC.NavLayerCurrent)

	mov	ebx, DWORD PTR _id$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [eax+8]
	subss	xmm0, DWORD PTR [ecx+24]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [eax+12]
	subss	xmm0, DWORD PTR [ecx+28]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [eax]
	subss	xmm0, DWORD PTR [ecx+24]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [eax+4]
	subss	xmm0, DWORD PTR [ecx+28]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR _nav_bb_rel$1[ebp], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T3[ebp+4]
	mov	DWORD PTR _nav_bb_rel$1[ebp+4], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _nav_bb_rel$1[ebp+8], eax
	mov	eax, DWORD PTR $T2[ebp+4]
	mov	DWORD PTR _nav_bb_rel$1[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2180 :         if (g.NavInitDefaultRequest && g.NavLayer == window->DC.NavLayerCurrent)

	movups	xmm0, XMMWORD PTR _nav_bb_rel$1[ebp]
	je	SHORT $LN6@ItemAdd
	cmp	DWORD PTR [esi+6444], edx
	jne	SHORT $LN6@ItemAdd

; 2181 :         {
; 2182 :             // Even if 'ImGuiItemFlags_AllowNavDefaultFocus' is off (typically collapse/close button) we record the first ResultId so they can be used as fallback
; 2183 :             if (window->DC.ItemFlags & ImGuiItemFlags_AllowNavDefaultFocus)

	test	BYTE PTR [edi+312], 2
	je	SHORT $LN5@ItemAdd

; 2184 :                 g.NavInitDefaultRequest = g.NavInitDefaultResultExplicit = false; // Found a match, clear request

	mov	BYTE PTR [esi+6480], 0
	mov	BYTE PTR [esi+6456], 0
$LN5@ItemAdd:

; 2185 :             if (g.NavInitDefaultResultId == 0 || (window->DC.ItemFlags & ImGuiItemFlags_AllowNavDefaultFocus))

	cmp	DWORD PTR [esi+6460], 0
	je	SHORT $LN7@ItemAdd
	test	BYTE PTR [edi+312], 2
	je	SHORT $LN6@ItemAdd
$LN7@ItemAdd:

; 2186 :             {
; 2187 :                 g.NavInitDefaultResultId = *id;

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [esi+6460], eax

; 2188 :                 g.NavInitDefaultResultRectRel = nav_bb_rel;

	movups	XMMWORD PTR [esi+6464], xmm0
$LN6@ItemAdd:

; 2189 :             }
; 2190 :         }
; 2191 : 
; 2192 :         //const bool DEBUG_NAV = false; // [DEBUG] Enable to test scoring on all items.
; 2193 :         if ((g.NavMoveRequest /*|| DEBUG_NAV*/) && g.NavId != *id)

	cmp	BYTE PTR [esi+6481], 0
	je	SHORT $LN9@ItemAdd
	mov	eax, DWORD PTR [esi+6384]
	cmp	eax, DWORD PTR [ebx]
	je	SHORT $LN9@ItemAdd

; 2194 :         {
; 2195 :             //if (DEBUG_NAV && !g.NavMoveRequest) g.NavMoveDir = ImGuiNavDir_N;
; 2196 :             if (NavScoreItem(nav_bb)) //if (!DEBUG || g.NavMoveRequest)

	mov	ecx, DWORD PTR _nav_bb$1$[ebp]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	movups	xmm0, XMMWORD PTR [ecx]
	movups	XMMWORD PTR [eax], xmm0
	call	?NavScoreItem@@YA_NUImRect@@@Z		; NavScoreItem

; 2199 :                 g.NavMoveResultRectRel = nav_bb_rel;

	movups	xmm0, XMMWORD PTR _nav_bb_rel$1[ebp]
	add	esp, 16					; 00000010H
	test	al, al
	je	SHORT $LN9@ItemAdd

; 2197 :             {
; 2198 :                 g.NavMoveResultId = *id;

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [esi+6488], eax

; 2199 :                 g.NavMoveResultRectRel = nav_bb_rel;

	movups	XMMWORD PTR [esi+6504], xmm0
$LN9@ItemAdd:

; 2200 :             }
; 2201 :         }
; 2202 : 
; 2203 :         // Update window-relative bounding box of navigated item
; 2204 :         if (g.NavId == *id)

	mov	eax, DWORD PTR [esi+6384]
	cmp	eax, DWORD PTR [ebx]
	jne	SHORT $LN32@ItemAdd

; 2205 :         {
; 2206 :             g.NavRefRectRel = nav_bb_rel;

	movups	XMMWORD PTR [esi+6400], xmm0

; 2207 :             g.NavIdIsAlive = true;

	mov	BYTE PTR [esi+6452], 1

; 2208 :             g.NavIdTabCounter = window->FocusIdxTabCounter;

	mov	eax, DWORD PTR [edi+648]
	mov	DWORD PTR [esi+6448], eax
$LN32@ItemAdd:
	mov	al, BYTE PTR _is_clipped$1$[ebp]
$LN10@ItemAdd:

; 2209 :         }
; 2210 :     }
; 2211 : 
; 2212 :     if (is_clipped)

	test	al, al
	je	SHORT $LN11@ItemAdd

; 2213 :         return false;

	xor	al, al

; 2225 :     }
; 2226 : 
; 2227 :     return true;
; 2228 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN11@ItemAdd:

; 2214 : 
; 2215 :     // Setting LastItemHoveredAndUsable for IsItemHovered()
; 2216 :     if (IsMouseHoveringRect(bb.Min, bb.Max))

	mov	ecx, DWORD PTR _bb$[ebp]
	push	1
	lea	eax, DWORD PTR [ecx+8]
	push	eax
	push	ecx
	call	?IsMouseHoveringRect@ImGui@@YA_NABUImVec2@@0_N@Z ; ImGui::IsMouseHoveringRect
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN17@ItemAdd

; 2217 :     {
; 2218 :         // Matching the behavior of IsHovered() but allow if ActiveId==window->MoveID (we clicked on the window background)
; 2219 :         // So that clicking on items with no active id such as Text() still returns true with IsItemHovered()
; 2220 :         window->DC.LastItemHoveredRect = true;

	mov	BYTE PTR [edi+269], 1

; 2221 :         if (g.HoveredRootWindow == window->RootWindow)

	mov	eax, DWORD PTR [esi+6248]
	cmp	eax, DWORD PTR [edi+632]
	jne	SHORT $LN17@ItemAdd

; 2222 :             if (g.ActiveId == 0 || (id && g.ActiveId == *id) || g.ActiveIdAllowOverlap || (g.ActiveId == window->MoveId))

	mov	eax, DWORD PTR [esi+6264]
	test	eax, eax
	je	SHORT $LN15@ItemAdd
	test	ebx, ebx
	je	SHORT $LN16@ItemAdd
	cmp	eax, DWORD PTR [ebx]
	je	SHORT $LN15@ItemAdd
$LN16@ItemAdd:
	cmp	BYTE PTR [esi+6274], 0
	jne	SHORT $LN15@ItemAdd
	cmp	eax, DWORD PTR [edi+88]
	jne	SHORT $LN17@ItemAdd
$LN15@ItemAdd:

; 2223 :                 if (!g.NavDisableMouseHover && IsWindowContentHoverable(window))

	cmp	BYTE PTR [esi+6455], 0
	jne	SHORT $LN17@ItemAdd
	push	edi
	call	?IsWindowContentHoverable@@YA_NPAUImGuiWindow@@@Z ; IsWindowContentHoverable
	add	esp, 4
	test	al, al
	je	SHORT $LN17@ItemAdd

; 2224 :                     window->DC.LastItemHoveredAndUsable = true;

	mov	BYTE PTR [edi+268], 1
$LN17@ItemAdd:

; 2225 :     }
; 2226 : 
; 2227 :     return true;
; 2228 : }

	pop	edi
	pop	esi
	mov	al, 1
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ItemAdd@ImGui@@YA_NABUImRect@@PBIPBU2@@Z ENDP		; ImGui::ItemAdd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 8
_bb$ = 8						; size = 4
_text_offset_y$ = 12					; size = 4
?ItemSize@ImGui@@YAXABUImRect@@M@Z PROC			; ImGui::ItemSize

; 2006 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 245  :     ImVec2      GetSize() const                 { return ImVec2(Max.x-Min.x, Max.y-Min.y); }

	mov	eax, DWORD PTR _bb$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2007 :     ItemSize(bb.GetSize(), text_offset_y);

	push	ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 245  :     ImVec2      GetSize() const                 { return ImVec2(Max.x-Min.x, Max.y-Min.y); }

	movss	xmm0, DWORD PTR [eax+8]
	subss	xmm0, DWORD PTR [eax]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 245  :     ImVec2      GetSize() const                 { return ImVec2(Max.x-Min.x, Max.y-Min.y); }

	movss	xmm0, DWORD PTR [eax+12]
	subss	xmm0, DWORD PTR [eax+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2007 :     ItemSize(bb.GetSize(), text_offset_y);

	lea	eax, DWORD PTR $T1[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2007 :     ItemSize(bb.GetSize(), text_offset_y);

	movss	xmm0, DWORD PTR _text_offset_y$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	eax
	call	?ItemSize@ImGui@@YAXABUImVec2@@M@Z	; ImGui::ItemSize
	add	esp, 8

; 2008 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ItemSize@ImGui@@YAXABUImRect@@M@Z ENDP			; ImGui::ItemSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 8
$T2 = -8						; size = 8
_size$ = 8						; size = 4
_text_offset_y$ = 12					; size = 4
?ItemSize@ImGui@@YAXABUImVec2@@M@Z PROC			; ImGui::ItemSize

; 1984 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1984 : {

	sub	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	edx, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1986 :     if (window->SkipItems)

	cmp	BYTE PTR [edx+137], 0
	jne	$LN1@ItemSize

; 1993 :     window->DC.CursorPosPrevLine = ImVec2(window->DC.CursorPos.x + size.x, window->DC.CursorPos.y);

	mov	eax, DWORD PTR _size$[ebp]
	movss	xmm0, DWORD PTR [edx+192]
	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm1, DWORD PTR [edx+196]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1993 :     window->DC.CursorPosPrevLine = ImVec2(window->DC.CursorPos.x + size.x, window->DC.CursorPos.y);

	addss	xmm0, DWORD PTR [eax]
	movss	xmm2, DWORD PTR [eax+4]
	maxss	xmm2, DWORD PTR [edx+224]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp+4], xmm1
	movss	DWORD PTR $T2[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1994 :     window->DC.CursorPos = ImVec2((float)(int)(window->Pos.x + window->DC.IndentX + window->DC.ColumnsOffsetX), (float)(int)(window->DC.CursorPos.y + line_height + g.Style.ItemSpacing.y));

	movss	xmm0, DWORD PTR [edx+400]
	addss	xmm0, DWORD PTR [edx+24]
	mov	eax, DWORD PTR $T2[ebp]
	addss	xmm1, xmm2
	mov	DWORD PTR [edx+200], eax
	mov	eax, DWORD PTR $T2[ebp+4]
	mov	DWORD PTR [edx+204], eax
	addss	xmm0, DWORD PTR [edx+408]
	addss	xmm1, DWORD PTR [ecx+5372]

; 1997 : 
; 1998 :     //window->DrawList->AddCircle(window->DC.CursorMaxPos, 3.0f, IM_COL32(255,0,0,255), 4); // Debug
; 1999 : 
; 2000 :     window->DC.PrevLineHeight = line_height;

	movss	DWORD PTR [edx+232], xmm2

; 2001 :     window->DC.PrevLineTextBaseOffset = text_base_offset;
; 2002 :     window->DC.CurrentLineHeight = window->DC.CurrentLineTextBaseOffset = 0.0f;

	mov	DWORD PTR [edx+224], 0
	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	cvttss2si eax, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm0
	movd	xmm0, eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1994 :     window->DC.CursorPos = ImVec2((float)(int)(window->Pos.x + window->DC.IndentX + window->DC.ColumnsOffsetX), (float)(int)(window->DC.CursorPos.y + line_height + g.Style.ItemSpacing.y));

	mov	eax, DWORD PTR $T1[ebp]
	cvtdq2ps xmm0, xmm0
	mov	DWORD PTR [edx+192], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm0
	movss	xmm0, DWORD PTR [edx+216]
	maxss	xmm0, DWORD PTR [edx+200]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1994 :     window->DC.CursorPos = ImVec2((float)(int)(window->Pos.x + window->DC.IndentX + window->DC.ColumnsOffsetX), (float)(int)(window->DC.CursorPos.y + line_height + g.Style.ItemSpacing.y));

	mov	eax, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR [edx+196], eax

; 1995 :     window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPosPrevLine.x);

	movss	DWORD PTR [edx+216], xmm0
	movss	xmm0, DWORD PTR [edx+220]
	maxss	xmm0, DWORD PTR [edx+196]

; 1996 :     window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y);

	movss	DWORD PTR [edx+220], xmm0
	movss	xmm0, DWORD PTR _text_offset_y$[ebp]
	maxss	xmm0, DWORD PTR [edx+228]

; 2001 :     window->DC.PrevLineTextBaseOffset = text_base_offset;
; 2002 :     window->DC.CurrentLineHeight = window->DC.CurrentLineTextBaseOffset = 0.0f;

	mov	DWORD PTR [edx+228], 0
	movss	DWORD PTR [edx+236], xmm0
$LN1@ItemSize:

; 2003 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ItemSize@ImGui@@YAXABUImVec2@@M@Z ENDP			; ImGui::ItemSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_id$ = 8						; size = 4
?KeepAliveID@ImGui@@YAXI@Z PROC				; ImGui::KeepAliveID

; 1976 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1977 :     ImGuiContext& g = *GImGui;

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 1978 :     if (g.ActiveId == id)

	mov	eax, DWORD PTR [ecx+6264]
	cmp	eax, DWORD PTR _id$[ebp]
	jne	SHORT $LN2@KeepAliveI

; 1979 :         g.ActiveIdIsAlive = true;

	mov	BYTE PTR [ecx+6272], 1
$LN2@KeepAliveI:

; 1980 : }

	pop	ebp
	ret	0
?KeepAliveID@ImGui@@YAXI@Z ENDP				; ImGui::KeepAliveID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_id$ = 8						; size = 4
?SetHoveredID@ImGui@@YAXI@Z PROC			; ImGui::SetHoveredID

; 1969 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1970 :     ImGuiContext& g = *GImGui;

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 1971 :     g.HoveredId = id;

	mov	eax, DWORD PTR _id$[ebp]
	mov	DWORD PTR [ecx+6252], eax

; 1972 :     g.HoveredIdAllowOverlap = false;

	mov	BYTE PTR [ecx+6256], 0

; 1973 : }

	pop	ebp
	ret	0
?SetHoveredID@ImGui@@YAXI@Z ENDP			; ImGui::SetHoveredID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?ClearActiveID@ImGui@@YAXXZ PROC			; ImGui::ClearActiveID

; 1965 :     SetActiveID(0, NULL);

	push	0
	push	0
	call	?SetActiveID@ImGui@@YAXIPAUImGuiWindow@@@Z ; ImGui::SetActiveID
	add	esp, 8

; 1966 : }

	ret	0
?ClearActiveID@ImGui@@YAXXZ ENDP			; ImGui::ClearActiveID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_id$ = 8						; size = 4
_window$ = 12						; size = 4
?SetActiveIDNoNav@ImGui@@YAXIPAUImGuiWindow@@@Z PROC	; ImGui::SetActiveIDNoNav

; 1952 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1953 :     ImGuiContext& g = *GImGui;

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 1954 :     g.ActiveIdIsJustActivated = (g.ActiveId != id);

	mov	edx, DWORD PTR _id$[ebp]
	cmp	DWORD PTR [ecx+6264], edx

; 1955 :     g.ActiveId = id;

	mov	DWORD PTR [ecx+6264], edx
	setne	al

; 1956 :     g.ActiveIdAllowNavDirFlags = 0;

	mov	DWORD PTR [ecx+6276], 0

; 1957 :     g.ActiveIdAllowOverlap = false;
; 1958 :     g.ActiveIdIsAlive |= (id != 0);

	test	edx, edx
	mov	BYTE PTR [ecx+6273], al
	mov	BYTE PTR [ecx+6274], 0
	setne	al
	or	BYTE PTR [ecx+6272], al

; 1959 :     g.ActiveIdWindow = window;

	mov	eax, DWORD PTR _window$[ebp]
	mov	DWORD PTR [ecx+6288], eax

; 1960 :     g.ActiveIdSource = (g.NavActivateId == id || g.NavInputId == id) ? ImGuiInputSource_Nav : ImGuiInputSource_Mouse;

	cmp	DWORD PTR [ecx+6388], edx
	je	SHORT $LN3@SetActiveI
	cmp	DWORD PTR [ecx+6392], edx
	je	SHORT $LN3@SetActiveI
	mov	DWORD PTR [ecx+6292], 1

; 1961 : }

	pop	ebp
	ret	0
$LN3@SetActiveI:

; 1960 :     g.ActiveIdSource = (g.NavActivateId == id || g.NavInputId == id) ? ImGuiInputSource_Nav : ImGuiInputSource_Mouse;

	mov	DWORD PTR [ecx+6292], 2

; 1961 : }

	pop	ebp
	ret	0
?SetActiveIDNoNav@ImGui@@YAXIPAUImGuiWindow@@@Z ENDP	; ImGui::SetActiveIDNoNav
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_id$ = 8						; size = 4
_window$ = 12						; size = 4
?SetActiveID@ImGui@@YAXIPAUImGuiWindow@@@Z PROC		; ImGui::SetActiveID

; 1929 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1930 :     ImGuiContext& g = *GImGui;

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 1931 :     g.ActiveIdIsJustActivated = (g.ActiveId != id);

	mov	edx, DWORD PTR _id$[ebp]
	push	esi

; 1932 :     g.ActiveId = id;
; 1933 :     g.ActiveIdAllowNavDirFlags = 0;
; 1934 :     g.ActiveIdAllowOverlap = false;
; 1935 :     g.ActiveIdWindow = window;

	mov	esi, DWORD PTR _window$[ebp]
	cmp	DWORD PTR [ecx+6264], edx
	mov	DWORD PTR [ecx+6264], edx
	setne	al
	mov	DWORD PTR [ecx+6276], 0
	mov	BYTE PTR [ecx+6273], al
	mov	BYTE PTR [ecx+6274], 0
	mov	DWORD PTR [ecx+6288], esi

; 1936 :     if (id)

	test	edx, edx
	je	SHORT $LN6@SetActiveI

; 1937 :     {
; 1938 :         g.ActiveIdSource = (g.NavActivateId == id || g.NavInputId == id || g.NavTabbedId == id) ? ImGuiInputSource_Nav : ImGuiInputSource_Mouse;

	cmp	DWORD PTR [ecx+6388], edx
	je	SHORT $LN8@SetActiveI
	cmp	DWORD PTR [ecx+6392], edx
	je	SHORT $LN8@SetActiveI
	mov	eax, 1
	cmp	DWORD PTR [ecx+6396], edx
	jne	SHORT $LN9@SetActiveI
$LN8@SetActiveI:
	mov	eax, 2
$LN9@SetActiveI:
	mov	DWORD PTR [ecx+6292], eax

; 1939 :         if (g.ActiveIdSource == ImGuiInputSource_Nav)

	cmp	eax, 2
	jne	SHORT $LN3@SetActiveI

; 1940 :             g.NavDisableMouseHover = true;

	mov	BYTE PTR [ecx+6455], 1

; 1941 :         else

	jmp	SHORT $LN4@SetActiveI
$LN3@SetActiveI:

; 1942 :             g.NavDisableHighlight = true;

	mov	BYTE PTR [ecx+6454], 1
$LN4@SetActiveI:

; 1943 :         g.NavId = id;

	mov	DWORD PTR [ecx+6384], edx

; 1944 :         if (window)

	test	esi, esi
	je	SHORT $LN6@SetActiveI

; 1945 :             g.NavLayer = window->DC.NavLayerCurrent;

	mov	eax, DWORD PTR [esi+272]
	mov	DWORD PTR [ecx+6444], eax

; 1946 :         if (window && window->DC.NavLayerCurrent == 0) // (Assume that id correspond to the current NavLayer, which should be the case)

	cmp	DWORD PTR [esi+272], 0
	jne	SHORT $LN6@SetActiveI

; 1947 :             window->NavLastId = id;

	mov	DWORD PTR [esi+148], edx
$LN6@SetActiveI:
	pop	esi

; 1948 :     }
; 1949 : }

	pop	ebp
	ret	0
?SetActiveID@ImGui@@YAXIPAUImGuiWindow@@@Z ENDP		; ImGui::SetActiveID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T2 = -32						; size = 16
$T3 = -16						; size = 8
$T4 = -8						; size = 8
_new_data$1$ = -4					; size = 4
?EndFrame@ImGui@@YAXXZ PROC				; ImGui::EndFrame

; 3410 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi

; 3411 :     ImGuiContext& g = *GImGui;

	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 3412 :     IM_ASSERT(g.Initialized);                       // Forgot to call ImGui::NewFrame()
; 3413 :     IM_ASSERT(g.FrameCountEnded != g.FrameCount);   // ImGui::EndFrame() called multiple times, or forgot to call ImGui::NewFrame() again
; 3414 : 
; 3415 :     // Render tooltip
; 3416 :     if (g.Tooltip[0])

	cmp	BYTE PTR [esi+10548], 0
	push	edi
	lea	edi, DWORD PTR [esi+10548]
	je	SHORT $LN5@EndFrame

; 3417 :     {
; 3418 :         ImGui::BeginTooltip();

	call	?BeginTooltip@ImGui@@YAXXZ		; ImGui::BeginTooltip

; 3419 :         ImGui::TextUnformatted(g.Tooltip);

	push	0
	push	edi
	call	?TextUnformatted@ImGui@@YAXPBD0@Z	; ImGui::TextUnformatted
	add	esp, 8

; 3420 :         ImGui::EndTooltip();

	call	?EndTooltip@ImGui@@YAXXZ		; ImGui::EndTooltip
$LN5@EndFrame:

; 3424 :     if (g.IO.ImeSetInputScreenPosFn && ImLengthSqr(g.OsImePosRequest - g.OsImePosSet) > 0.0001f)

	mov	ecx, DWORD PTR [esi+200]
	test	ecx, ecx
	je	SHORT $LN6@EndFrame
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm1, DWORD PTR [esi+11584]
	movss	xmm0, DWORD PTR [esi+11588]
	subss	xmm1, DWORD PTR [esi+11592]
	subss	xmm0, DWORD PTR [esi+11596]

; 137  : static inline float  ImLengthSqr(const ImVec2& lhs)                             { return lhs.x*lhs.x + lhs.y*lhs.y; }

	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm1, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3424 :     if (g.IO.ImeSetInputScreenPosFn && ImLengthSqr(g.OsImePosRequest - g.OsImePosSet) > 0.0001f)

	comiss	xmm1, DWORD PTR __real@38d1b717
	jbe	SHORT $LN6@EndFrame

; 3425 :     {
; 3426 :         g.IO.ImeSetInputScreenPosFn((int)g.OsImePosRequest.x, (int)g.OsImePosRequest.y);

	cvttss2si eax, DWORD PTR [esi+11588]
	push	eax
	cvttss2si eax, DWORD PTR [esi+11584]
	push	eax
	call	ecx

; 3427 :         g.OsImePosSet = g.OsImePosRequest;

	mov	eax, DWORD PTR [esi+11584]
	add	esp, 8
	mov	DWORD PTR [esi+11592], eax
	mov	eax, DWORD PTR [esi+11588]
	mov	DWORD PTR [esi+11596], eax
$LN6@EndFrame:

; 3428 :     }
; 3429 : 
; 3430 :     // Hide implicit "Debug" window if it hasn't been used
; 3431 :     IM_ASSERT(g.CurrentWindowStack.Size == 1);    // Mismatched Begin()/End() calls
; 3432 :     if (g.CurrentWindow && !g.CurrentWindow->Accessed)

	mov	eax, DWORD PTR [esi+6240]
	test	eax, eax
	je	SHORT $LN7@EndFrame
	cmp	BYTE PTR [eax+134], 0
	jne	SHORT $LN7@EndFrame

; 3433 :         g.CurrentWindow->Active = false;

	mov	BYTE PTR [eax+132], 0
$LN7@EndFrame:

; 3434 :     ImGui::End();

	call	?End@ImGui@@YAXXZ			; ImGui::End

; 3435 : 
; 3436 :     // Click to focus window and start moving (after we're done with all our widgets)
; 3437 :     if (g.ActiveId == 0 && g.HoveredId == 0 && g.IO.MouseClicked[0])

	cmp	DWORD PTR [esi+6264], 0
	jne	$LN15@EndFrame
	cmp	DWORD PTR [esi+6252], 0
	jne	$LN15@EndFrame
	cmp	BYTE PTR [esi+888], 0
	je	$LN15@EndFrame

; 3438 :     {
; 3439 :         if (!(g.NavWindow && !g.NavWindow->WasActive && g.NavWindow->Active)) // Unless we just made a popup appear

	mov	eax, DWORD PTR [esi+6380]
	test	eax, eax
	je	SHORT $LN10@EndFrame
	cmp	BYTE PTR [eax+133], 0
	jne	SHORT $LN10@EndFrame
	cmp	BYTE PTR [eax+132], 0
	jne	$LN15@EndFrame
$LN10@EndFrame:

; 3440 :         {
; 3441 :             if (g.HoveredRootWindow != NULL)

	cmp	DWORD PTR [esi+6248], 0
	je	$LN11@EndFrame

; 3442 :             {
; 3443 :                 FocusWindow(g.HoveredWindow);

	push	DWORD PTR [esi+6244]
	call	?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusWindow

; 3444 :                 if (g.NavWindow != g.HoveredWindow)

	mov	ecx, DWORD PTR [esi+6244]
	add	esp, 4
	cmp	DWORD PTR [esi+6380], ecx
	je	SHORT $LN13@EndFrame
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [esi+208]
	subss	xmm0, DWORD PTR [ecx+24]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [esi+212]
	subss	xmm0, DWORD PTR [ecx+28]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [esi+208]
	subss	xmm0, DWORD PTR [ecx+24]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [esi+212]
	subss	xmm0, DWORD PTR [ecx+28]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T2[ebp], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3447 :                     g.NavDisableHighlight = true;

	mov	BYTE PTR [esi+6454], 1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T4[ebp+4]
	mov	DWORD PTR $T2[ebp+4], eax
	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T2[ebp+8], eax
	mov	eax, DWORD PTR $T3[ebp+4]
	mov	DWORD PTR $T2[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3446 :                     g.NavRefRectRel = ImRect(g.IO.MousePos - g.HoveredWindow->Pos, g.IO.MousePos - g.HoveredWindow->Pos); //ImRect(0,0,0,0);

	movups	xmm0, XMMWORD PTR $T2[ebp]
	movups	XMMWORD PTR [esi+6400], xmm0
$LN13@EndFrame:

; 3448 :                 }
; 3449 :                 if (!(g.HoveredWindow->Flags & ImGuiWindowFlags_NoMove))

	test	BYTE PTR [ecx+8], 4
	jne	SHORT $LN15@EndFrame

; 3450 :                 {
; 3451 :                     g.MovedWindow = g.HoveredWindow;
; 3452 :                     g.MovedWindowMoveId = g.HoveredRootWindow->MoveId;

	mov	eax, DWORD PTR [esi+6248]
	mov	DWORD PTR [esi+6296], ecx

; 3453 :                     SetActiveIDNoNav(g.MovedWindowMoveId, g.HoveredRootWindow);

	push	eax
	mov	ecx, DWORD PTR [eax+88]
	push	ecx
	mov	DWORD PTR [esi+6300], ecx
	call	?SetActiveIDNoNav@ImGui@@YAXIPAUImGuiWindow@@@Z ; ImGui::SetActiveIDNoNav
	add	esp, 8

; 3454 :                 }
; 3455 :             }

	jmp	SHORT $LN15@EndFrame
$LN11@EndFrame:

; 3456 :             else if (g.NavWindow != NULL && GetFrontMostModalRootWindow() == NULL)

	test	eax, eax
	je	SHORT $LN15@EndFrame
	call	?GetFrontMostModalRootWindow@@YAPAUImGuiWindow@@XZ ; GetFrontMostModalRootWindow
	test	eax, eax
	jne	SHORT $LN15@EndFrame

; 3457 :             {
; 3458 :                 // Clicking on void disable focus
; 3459 :                 FocusWindow(NULL);

	push	eax
	call	?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusWindow
	add	esp, 4
$LN15@EndFrame:

; 3460 :             }
; 3461 :         }
; 3462 :     }
; 3463 : 
; 3464 :     // Sort the window list so that all child windows are after their parent
; 3465 :     // We cannot do that on FocusWindow() because childs may not exist yet
; 3466 :     g.WindowsSortBuffer.resize(0);

	lea	ebx, DWORD PTR [esi+6216]
	push	0
	mov	ecx, ebx
	call	?resize@?$ImVector@PAUImGuiWindow@@@@QAEXH@Z ; ImVector<ImGuiWindow *>::resize

; 3467 :     g.WindowsSortBuffer.reserve(g.Windows.Size);

	mov	edi, DWORD PTR [esi+6204]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 931  :         if (new_capacity <= Capacity) return;

	cmp	edi, DWORD PTR [ebx+4]
	jle	SHORT $LN34@EndFrame

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*4]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [ebx+8]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN36@EndFrame

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [ebx]
	shl	ecx, 2
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN36@EndFrame:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [ebx+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [ebx+8], eax

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [ebx+4], edi
$LN34@EndFrame:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3468 :     for (int i = 0; i != g.Windows.Size; i++)

	xor	edi, edi
	cmp	DWORD PTR [esi+6204], edi
	je	SHORT $LN3@EndFrame
	npad	13
$LL4@EndFrame:

; 3469 :     {
; 3470 :         ImGuiWindow* window = g.Windows[i];

	mov	eax, DWORD PTR [esi+6212]
	mov	eax, DWORD PTR [eax+edi*4]

; 3471 :         if (window->Active && (window->Flags & ImGuiWindowFlags_ChildWindow))       // if a child is active its parent will add it

	cmp	BYTE PTR [eax+132], 0
	je	SHORT $LN16@EndFrame
	test	DWORD PTR [eax+8], 4194304		; 00400000H
	jne	SHORT $LN2@EndFrame
$LN16@EndFrame:

; 3472 :             continue;
; 3473 :         AddWindowToSortedBuffer(g.WindowsSortBuffer, window);

	push	eax
	push	ebx
	call	?AddWindowToSortedBuffer@@YAXAAV?$ImVector@PAUImGuiWindow@@@@PAUImGuiWindow@@@Z ; AddWindowToSortedBuffer
	add	esp, 8
$LN2@EndFrame:

; 3468 :     for (int i = 0; i != g.Windows.Size; i++)

	inc	edi
	cmp	edi, DWORD PTR [esi+6204]
	jne	SHORT $LL4@EndFrame
$LN3@EndFrame:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 924  :     inline void                 swap(ImVector<T>& rhs)          { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; value_type* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }

	mov	ecx, DWORD PTR [ebx]
	xorps	xmm0, xmm0
	mov	eax, DWORD PTR [esi+6204]
	mov	DWORD PTR [ebx], eax
	mov	eax, DWORD PTR [esi+6208]
	mov	DWORD PTR [esi+6204], ecx
	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx+4], eax
	mov	eax, DWORD PTR [esi+6212]
	mov	DWORD PTR [esi+6208], ecx
	mov	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR [ebx+8], eax
	mov	DWORD PTR [esi+6212], ecx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3480 :     g.IO.MouseWheel = 0.0f;

	mov	DWORD PTR [esi+224], 0

; 3481 :     memset(g.IO.InputCharacters, 0, sizeof(g.IO.InputCharacters));

	movups	XMMWORD PTR [esi+746], xmm0
	pop	edi
	movups	XMMWORD PTR [esi+762], xmm0
	mov	WORD PTR [esi+778], 0

; 3482 : 
; 3483 :     g.FrameCountEnded = g.FrameCount;

	mov	eax, DWORD PTR [esi+6192]
	mov	DWORD PTR [esi+6196], eax
	pop	esi
	pop	ebx

; 3484 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?EndFrame@ImGui@@YAXXZ ENDP				; ImGui::EndFrame
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 8
$T2 = -8						; size = 8
_window$ = 8						; size = 4
?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z PROC		; ImGui::FocusWindow

; 5480 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 5481 :     ImGuiContext& g = *GImGui;
; 5482 : 
; 5483 :     if (g.NavWindow != window)

	mov	esi, DWORD PTR _window$[ebp]
	push	edi
	mov	edi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	cmp	DWORD PTR [edi+6380], esi
	je	$LN5@FocusWindo

; 5484 :     {
; 5485 :         g.NavId = window ? window->NavLastId : 0; // Restore NavId

	test	esi, esi
	je	SHORT $LN15@FocusWindo
	mov	eax, DWORD PTR [esi+148]
	jmp	SHORT $LN16@FocusWindo
$LN15@FocusWindo:
	xor	eax, eax
$LN16@FocusWindo:
	mov	DWORD PTR [edi+6384], eax

; 5486 :         g.NavIdIsAlive = false;

	mov	BYTE PTR [edi+6452], 0

; 5487 :         g.NavLayer = 0;

	mov	DWORD PTR [edi+6444], 0

; 5488 :         if (window && g.NavDisableMouseHover)

	test	esi, esi
	je	SHORT $LN17@FocusWindo
	cmp	BYTE PTR [edi+6455], 0
	je	SHORT $LN6@FocusWindo

; 5489 :             g.NavMousePosDirty = true;

	mov	BYTE PTR [edi+6453], 1
$LN6@FocusWindo:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [esi+208]
	subss	xmm0, DWORD PTR [esi+24]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [esi+212]
	subss	xmm0, DWORD PTR [esi+28]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5490 :         g.NavRefRectRel.Min = g.NavRefRectRel.Max = window ? (window->DC.CursorStartPos - window->Pos) : ImVec2(0,0);

	jmp	SHORT $LN39@FocusWindo
$LN17@FocusWindo:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp], 0
	mov	DWORD PTR $T1[ebp+4], 0
$LN39@FocusWindo:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5490 :         g.NavRefRectRel.Min = g.NavRefRectRel.Max = window ? (window->DC.CursorStartPos - window->Pos) : ImVec2(0,0);

	lea	ecx, DWORD PTR $T1[ebp]

; 5491 :         g.NavWindow = window;

	mov	DWORD PTR [edi+6380], esi
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edi+6408], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edi+6412], eax
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edi+6400], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edi+6404], eax
$LN5@FocusWindo:

; 5492 :     }
; 5493 : 
; 5494 :     // Passing NULL allow to disable keyboard focus
; 5495 :     if (!window)

	test	esi, esi
	je	$LN12@FocusWindo

; 5496 :         return;
; 5497 : 
; 5498 :     // And move its root window to the top of the pile
; 5499 :     if (window->RootWindow)

	mov	eax, DWORD PTR [esi+632]
	test	eax, eax
	cmovne	esi, eax
	mov	DWORD PTR _window$[ebp], esi

; 5500 :         window = window->RootWindow;
; 5501 : 
; 5502 :     // Steal focus on active widgets
; 5503 :     if (window->Flags & ImGuiWindowFlags_Popup) // FIXME: This statement should be unnecessary. Need further testing before removing it..

	test	DWORD PTR [esi+8], 33554432		; 02000000H
	je	SHORT $LN10@FocusWindo

; 5504 :         if (g.ActiveId != 0 && g.ActiveIdWindow && g.ActiveIdWindow->RootWindow != window)

	cmp	DWORD PTR [edi+6264], 0
	je	SHORT $LN10@FocusWindo
	mov	eax, DWORD PTR [edi+6288]
	test	eax, eax
	je	SHORT $LN10@FocusWindo
	cmp	DWORD PTR [eax+632], esi
	je	SHORT $LN10@FocusWindo

; 5505 :             ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
$LN10@FocusWindo:

; 5506 : 
; 5507 :     // Bring to front
; 5508 :     if ((window->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus) || g.Windows.back() == window)

	test	DWORD PTR [esi+8], 8192			; 00002000H
	jne	SHORT $LN12@FocusWindo
	mov	ecx, DWORD PTR [edi+6204]
	mov	eax, DWORD PTR [edi+6212]
	push	ebx
	lea	ebx, DWORD PTR [edi+6204]
	cmp	DWORD PTR [eax+ecx*4-4], esi
	je	SHORT $LN38@FocusWindo

; 5509 :         return;
; 5510 :     for (int i = 0; i < g.Windows.Size; i++)

	mov	edx, DWORD PTR [ebx]
	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN3@FocusWindo
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	mov	edi, DWORD PTR [edi+6212]
	mov	eax, edi
$LL4@FocusWindo:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5511 :         if (g.Windows[i] == window)

	cmp	DWORD PTR [eax], esi
	je	SHORT $LN34@FocusWindo

; 5509 :         return;
; 5510 :     for (int i = 0; i < g.Windows.Size; i++)

	inc	ecx
	add	eax, 4
	cmp	ecx, edx
	jl	SHORT $LL4@FocusWindo

; 5516 :     g.Windows.push_back(window);

	lea	eax, DWORD PTR _window$[ebp]
	mov	ecx, ebx
	push	eax
	call	?push_back@?$ImVector@PAUImGuiWindow@@@@QAEXABQAUImGuiWindow@@@Z ; ImVector<ImGuiWindow *>::push_back
	pop	ebx
	pop	edi
	pop	esi

; 5517 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN34@FocusWindo:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 943  :     inline iterator             erase(const_iterator it)        { IM_ASSERT(it >= Data && it < Data+Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(value_type)); Size--; return Data + off; }

	mov	eax, DWORD PTR [ebx+8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5513 :             g.Windows.erase(g.Windows.begin() + i);

	shl	ecx, 2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 943  :     inline iterator             erase(const_iterator it)        { IM_ASSERT(it >= Data && it < Data+Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(value_type)); Size--; return Data + off; }

	sub	ecx, eax
	add	ecx, edi
	sar	ecx, 2
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [ebx]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax*4-4]
	push	eax
	lea	eax, DWORD PTR [edx+4]
	push	eax
	push	edx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	dec	DWORD PTR [ebx]
$LN3@FocusWindo:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5516 :     g.Windows.push_back(window);

	lea	eax, DWORD PTR _window$[ebp]
	mov	ecx, ebx
	push	eax
	call	?push_back@?$ImVector@PAUImGuiWindow@@@@QAEXABQAUImGuiWindow@@@Z ; ImVector<ImGuiWindow *>::push_back
$LN38@FocusWindo:
	pop	ebx
$LN12@FocusWindo:
	pop	edi
	pop	esi

; 5517 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z ENDP		; ImGui::FocusWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_name$ = 8						; size = 4
?FindWindowByName@ImGui@@YAPAUImGuiWindow@@PBD@Z PROC	; ImGui::FindWindowByName

; 4610 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx

; 4611 :     // FIXME-OPT: Store sorted hashes -> pointers so we can do a bissection in a contiguous block
; 4612 :     ImGuiContext& g = *GImGui;

	mov	ebx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	esi
	push	edi

; 4613 :     ImGuiID id = ImHash(name, 0);

	push	0
	push	0
	push	DWORD PTR _name$[ebp]
	call	?ImHash@@YAIPBXHI@Z			; ImHash
	mov	esi, DWORD PTR [ebx+6204]
	add	esp, 12					; 0000000cH

; 4614 :     for (int i = 0; i < g.Windows.Size; i++)

	xor	ecx, ecx
	mov	edi, eax
	test	esi, esi
	jle	SHORT $LN3@FindWindow
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	mov	ebx, DWORD PTR [ebx+6212]
	mov	edx, ebx
$LL4@FindWindow:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4615 :         if (g.Windows[i]->ID == id)

	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+4], edi
	je	SHORT $LN12@FindWindow

; 4614 :     for (int i = 0; i < g.Windows.Size; i++)

	inc	ecx
	add	edx, 4
	cmp	ecx, esi
	jl	SHORT $LL4@FindWindow
$LN3@FindWindow:
	pop	edi
	pop	esi

; 4617 :     return NULL;

	xor	eax, eax
	pop	ebx

; 4618 : }

	pop	ebp
	ret	0
$LN12@FindWindow:

; 4616 :             return g.Windows[i];

	mov	eax, DWORD PTR [ebx+ecx*4]
	pop	edi
	pop	esi
	pop	ebx

; 4618 : }

	pop	ebp
	ret	0
?FindWindowByName@ImGui@@YAPAUImGuiWindow@@PBD@Z ENDP	; ImGui::FindWindowByName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?GetParentWindow@ImGui@@YAPAUImGuiWindow@@XZ PROC	; ImGui::GetParentWindow

; 1923 :     ImGuiContext& g = *GImGui;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 1924 :     IM_ASSERT(g.CurrentWindowStack.Size >= 2);
; 1925 :     return g.CurrentWindowStack[(unsigned int)g.CurrentWindowStack.Size - 2];

	mov	ecx, DWORD PTR [eax+6228]
	mov	eax, DWORD PTR [eax+6236]
	mov	eax, DWORD PTR [eax+ecx*4-8]

; 1926 : }

	ret	0
?GetParentWindow@ImGui@@YAPAUImGuiWindow@@XZ ENDP	; ImGui::GetParentWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ
_TEXT	SEGMENT
?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ PROC	; ImGui::GetCurrentWindow, COMDAT

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	eax, DWORD PTR [ecx+6240]
	ret	0
?GetCurrentWindow@ImGui@@YAPAUImGuiWindow@@XZ ENDP	; ImGui::GetCurrentWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?GetCurrentWindowRead@ImGui@@YAPAUImGuiWindow@@XZ
_TEXT	SEGMENT
?GetCurrentWindowRead@ImGui@@YAPAUImGuiWindow@@XZ PROC	; ImGui::GetCurrentWindowRead, COMDAT

; 792  :     inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [eax+6240]
	ret	0
?GetCurrentWindowRead@ImGui@@YAPAUImGuiWindow@@XZ ENDP	; ImGui::GetCurrentWindowRead
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GImGuiWindow@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GImGuiWindow@@QAEPAXI@Z PROC				; ImGuiWindow::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1ImGuiWindow@@QAE@XZ			; ImGuiWindow::~ImGuiWindow
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	668					; 0000029cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_GImGuiWindow@@QAEPAXI@Z ENDP				; ImGuiWindow::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??4ImGuiWindow@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4ImGuiWindow@@QAEAAU0@ABU0@@Z PROC			; ImGuiWindow::operator=, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___that$[ebp]
	mov	eax, ecx
	push	edi
	mov	ecx, 167				; 000000a7H
	mov	edi, eax
	rep movsd
	pop	edi
	pop	esi
	pop	ebp
	ret	4
??4ImGuiWindow@@QAEAAU0@ABU0@@Z ENDP			; ImGuiWindow::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?MenuBarRect@ImGuiWindow@@QBE?AUImRect@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?MenuBarRect@ImGuiWindow@@QBE?AUImRect@@XZ PROC		; ImGuiWindow::MenuBarRect, COMDAT
; _this$ = ecx

; 778  :     ImRect      MenuBarRect() const                     { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }

	npad	2
	push	ebp
	mov	ebp, esp

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	mov	edx, DWORD PTR [ecx+8]
	xorps	xmm2, xmm2
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	test	dl, 1
	je	SHORT $LN5@MenuBarRec
	xorps	xmm1, xmm1
	jmp	SHORT $LN6@MenuBarRec
$LN5@MenuBarRec:
	movss	xmm0, DWORD PTR [eax+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm1, DWORD PTR [eax+6176]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm0, xmm0

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm1, DWORD PTR [ecx+620]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm1, xmm0
$LN6@MenuBarRec:

; 778  :     ImRect      MenuBarRect() const                     { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }

	movss	xmm3, DWORD PTR [ecx+28]
	addss	xmm3, xmm1

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	test	edx, 1024				; 00000400H
	je	SHORT $LN11@MenuBarRec
	movss	xmm0, DWORD PTR [eax+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm2, DWORD PTR [eax+6176]

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	addss	xmm0, xmm0

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm2, DWORD PTR [ecx+620]

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	addss	xmm2, xmm0
$LN11@MenuBarRec:

; 778  :     ImRect      MenuBarRect() const                     { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }

	movss	xmm0, DWORD PTR [ecx+24]
	addss	xmm2, xmm3
	movss	xmm1, DWORD PTR [ecx+40]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 778  :     ImRect      MenuBarRect() const                     { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }

	addss	xmm1, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax], xmm0
	movss	DWORD PTR [eax+4], xmm3
	movss	DWORD PTR [eax+8], xmm1
	movss	DWORD PTR [eax+12], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 778  :     ImRect      MenuBarRect() const                     { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }

	pop	ebp
	ret	4
?MenuBarRect@ImGuiWindow@@QBE?AUImRect@@XZ ENDP		; ImGuiWindow::MenuBarRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?MenuBarHeight@ImGuiWindow@@QBEMXZ
_TEXT	SEGMENT
tv74 = -4						; size = 4
?MenuBarHeight@ImGuiWindow@@QBEMXZ PROC			; ImGuiWindow::MenuBarHeight, COMDAT
; _this$ = ecx

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	test	DWORD PTR [ecx+8], 1024			; 00000400H
	je	SHORT $LN3@MenuBarHei
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	movss	xmm1, DWORD PTR [eax+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm0, DWORD PTR [eax+6176]

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	addss	xmm1, xmm1

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm0, DWORD PTR [ecx+620]

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	addss	xmm0, xmm1
	movss	DWORD PTR tv74[ebp], xmm0
	fld	DWORD PTR tv74[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@MenuBarHei:
	mov	DWORD PTR tv74[ebp], 0
	fld	DWORD PTR tv74[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?MenuBarHeight@ImGuiWindow@@QBEMXZ ENDP			; ImGuiWindow::MenuBarHeight
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?TitleBarRect@ImGuiWindow@@QBE?AUImRect@@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
?TitleBarRect@ImGuiWindow@@QBE?AUImRect@@XZ PROC	; ImGuiWindow::TitleBarRect, COMDAT
; _this$ = ecx

; 776  :     ImRect      TitleBarRect() const                    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, ecx
	sub	esp, 8

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	test	BYTE PTR [edx+8], 1
	je	SHORT $LN5@TitleBarRe
	xorps	xmm1, xmm1
	jmp	SHORT $LN6@TitleBarRe
$LN5@TitleBarRe:
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	movss	xmm0, DWORD PTR [eax+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm1, DWORD PTR [eax+6176]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm0, xmm0

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm1, DWORD PTR [edx+620]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm1, xmm0
$LN6@TitleBarRe:

; 776  :     ImRect      TitleBarRect() const                    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }

	movss	xmm0, DWORD PTR [edx+40]
	addss	xmm0, DWORD PTR [edx+24]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [edx+24]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 776  :     ImRect      TitleBarRect() const                    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }

	movss	xmm0, DWORD PTR [edx+28]
	addss	xmm0, xmm1

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+28]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax+8], ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	ecx, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR [eax+12], ecx

; 776  :     ImRect      TitleBarRect() const                    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }

	mov	esp, ebp
	pop	ebp
	ret	4
?TitleBarRect@ImGuiWindow@@QBE?AUImRect@@XZ ENDP	; ImGuiWindow::TitleBarRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?TitleBarHeight@ImGuiWindow@@QBEMXZ
_TEXT	SEGMENT
tv74 = -4						; size = 4
?TitleBarHeight@ImGuiWindow@@QBEMXZ PROC		; ImGuiWindow::TitleBarHeight, COMDAT
; _this$ = ecx

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	test	BYTE PTR [ecx+8], 1
	je	SHORT $LN3@TitleBarHe
	mov	DWORD PTR tv74[ebp], 0
	fld	DWORD PTR tv74[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@TitleBarHe:
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	movss	xmm1, DWORD PTR [eax+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm0, DWORD PTR [eax+6176]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm1, xmm1

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm0, DWORD PTR [ecx+620]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm0, xmm1
	movss	DWORD PTR tv74[ebp], xmm0
	fld	DWORD PTR tv74[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?TitleBarHeight@ImGuiWindow@@QBEMXZ ENDP		; ImGuiWindow::TitleBarHeight
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?CalcFontSize@ImGuiWindow@@QBEMXZ
_TEXT	SEGMENT
?CalcFontSize@ImGuiWindow@@QBEMXZ PROC			; ImGuiWindow::CalcFontSize, COMDAT
; _this$ = ecx

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	fld	DWORD PTR [eax+6176]
	fmul	DWORD PTR [ecx+620]
	ret	0
?CalcFontSize@ImGuiWindow@@QBEMXZ ENDP			; ImGuiWindow::CalcFontSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?Rect@ImGuiWindow@@QBE?AUImRect@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?Rect@ImGuiWindow@@QBE?AUImRect@@XZ PROC		; ImGuiWindow::Rect, COMDAT
; _this$ = ecx

; 773  :     ImRect      Rect() const                            { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }

	npad	2
	push	ebp
	mov	ebp, esp
	movss	xmm3, DWORD PTR [ecx+28]
	movss	xmm0, DWORD PTR [ecx+24]
	movss	xmm2, DWORD PTR [ecx+32]
	movss	xmm1, DWORD PTR [ecx+36]
	addss	xmm2, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 773  :     ImRect      Rect() const                            { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }

	addss	xmm1, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax], xmm0
	movss	DWORD PTR [eax+4], xmm3
	movss	DWORD PTR [eax+8], xmm2
	movss	DWORD PTR [eax+12], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 773  :     ImRect      Rect() const                            { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }

	pop	ebp
	ret	4
?Rect@ImGuiWindow@@QBE?AUImRect@@XZ ENDP		; ImGuiWindow::Rect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_child_window$ = 8					; size = 4
?GetChildID@ImGuiWindow@@QAEIPAU1@@Z PROC		; ImGuiWindow::GetChildID
; _this$ = ecx

; 1903 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	mov	eax, DWORD PTR [ecx+468]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1906 :     return ImHash(&child_window->ID, sizeof(child_window->ID), seed);

	push	DWORD PTR [eax]
	mov	eax, DWORD PTR _child_window$[ebp]
	add	eax, 4
	push	4
	push	eax
	call	?ImHash@@YAIPBXHI@Z			; ImHash
	add	esp, 12					; 0000000cH

; 1907 : }

	pop	ebp
	ret	4
?GetChildID@ImGuiWindow@@QAEIPAU1@@Z ENDP		; ImGuiWindow::GetChildID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_str$ = 8						; size = 4
_str_end$ = 12						; size = 4
?GetIDNoKeepAlive@ImGuiWindow@@QAEIPBD0@Z PROC		; ImGuiWindow::GetIDNoKeepAlive
; _this$ = ecx

; 1897 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1898 :     ImGuiID seed = IDStack.back();

	mov	edx, DWORD PTR [ecx+460]
	mov	eax, DWORD PTR [ecx+468]
	mov	ecx, DWORD PTR _str$[ebp]

; 1899 :     return ImHash(str, str_end ? (int)(str_end - str) : 0, seed);

	push	DWORD PTR [eax+edx*4-4]
	mov	edx, DWORD PTR _str_end$[ebp]
	mov	eax, edx
	sub	eax, ecx
	neg	edx
	sbb	edx, edx
	and	edx, eax
	push	edx
	push	ecx
	call	?ImHash@@YAIPBXHI@Z			; ImHash
	add	esp, 12					; 0000000cH

; 1900 : }

	pop	ebp
	ret	8
?GetIDNoKeepAlive@ImGuiWindow@@QAEIPBD0@Z ENDP		; ImGuiWindow::GetIDNoKeepAlive
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
?GetID@ImGuiWindow@@QAEIPBX@Z PROC			; ImGuiWindow::GetID
; _this$ = ecx

; 1889 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1890 :     ImGuiID seed = IDStack.back();

	mov	eax, DWORD PTR [ecx+468]
	mov	edx, DWORD PTR [ecx+460]
	push	esi

; 1891 :     ImGuiID id = ImHash(&ptr, sizeof(void*), seed);

	push	DWORD PTR [eax+edx*4-4]
	lea	eax, DWORD PTR _ptr$[ebp]
	push	4
	push	eax
	call	?ImHash@@YAIPBXHI@Z			; ImHash
	mov	esi, eax

; 1892 :     ImGui::KeepAliveID(id);

	push	esi
	call	?KeepAliveID@ImGui@@YAXI@Z		; ImGui::KeepAliveID
	add	esp, 16					; 00000010H

; 1893 :     return id;

	mov	eax, esi
	pop	esi

; 1894 : }

	pop	ebp
	ret	4
?GetID@ImGuiWindow@@QAEIPBX@Z ENDP			; ImGuiWindow::GetID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_str$ = 8						; size = 4
_str_end$ = 12						; size = 4
?GetID@ImGuiWindow@@QAEIPBD0@Z PROC			; ImGuiWindow::GetID
; _this$ = ecx

; 1881 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1882 :     ImGuiID seed = IDStack.back();

	mov	edx, DWORD PTR [ecx+460]
	mov	eax, DWORD PTR [ecx+468]
	mov	ecx, DWORD PTR _str$[ebp]
	push	esi

; 1883 :     ImGuiID id = ImHash(str, str_end ? (int)(str_end - str) : 0, seed);

	push	DWORD PTR [eax+edx*4-4]
	mov	edx, DWORD PTR _str_end$[ebp]
	mov	eax, edx
	sub	eax, ecx
	neg	edx
	sbb	edx, edx
	and	edx, eax
	push	edx
	push	ecx
	call	?ImHash@@YAIPBXHI@Z			; ImHash
	mov	esi, eax

; 1884 :     ImGui::KeepAliveID(id);

	push	esi
	call	?KeepAliveID@ImGui@@YAXI@Z		; ImGui::KeepAliveID
	add	esp, 16					; 00000010H

; 1885 :     return id;

	mov	eax, esi
	pop	esi

; 1886 : }

	pop	ebp
	ret	8
?GetID@ImGuiWindow@@QAEIPBD0@Z ENDP			; ImGuiWindow::GetID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1ImGuiWindow@@QAE@XZ PROC				; ImGuiWindow::~ImGuiWindow
; _this$ = ecx

; 1872 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1ImGuiWindow@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi+624]
	call	??1ImDrawList@@QAE@XZ			; ImDrawList::~ImDrawList

; 1873 :     DrawList->~ImDrawList();
; 1874 :     ImGui::MemFree(DrawList);

	push	DWORD PTR [esi+624]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 1875 :     DrawList = NULL;
; 1876 :     ImGui::MemFree(Name);

	push	DWORD PTR [esi]
	mov	DWORD PTR [esi+624], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 8

; 1877 :     Name = NULL;

	mov	DWORD PTR [esi], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	mov	eax, DWORD PTR [esi+616]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN11@ImGuiWindo
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN11@ImGuiWindo:
	mov	eax, DWORD PTR [esi+468]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	eax, eax
	je	SHORT $LN15@ImGuiWindo
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN15@ImGuiWindo:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1878 : }

	lea	ecx, DWORD PTR [esi+192]
	call	??1ImGuiDrawContext@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__ehhandler$??1ImGuiWindow@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1ImGuiWindow@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1ImGuiWindow@@QAE@XZ ENDP				; ImGuiWindow::~ImGuiWindow
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T2 = -28						; size = 8
$T3 = -28						; size = 8
$T4 = -28						; size = 8
$T5 = -28						; size = 8
$T6 = -28						; size = 8
$T7 = -28						; size = 8
$T8 = -28						; size = 8
$T9 = -28						; size = 8
$T10 = -24						; size = 4
$T11 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_name$ = 8						; size = 4
$T12 = 11						; size = 1
??0ImGuiWindow@@QAE@PBD@Z PROC				; ImGuiWindow::ImGuiWindow
; _this$ = ecx

; 1821 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0ImGuiWindow@@QAE@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 97   :     ImVec2() { x = y = 0.0f; }

	mov	DWORD PTR [esi+20], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1821 : {

	lea	ecx, DWORD PTR [esi+192]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 97   :     ImVec2() { x = y = 0.0f; }

	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+44], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+52], 0
	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+60], 0
	mov	DWORD PTR [esi+56], 0

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR [esi+64], 2139095039		; 7f7fffffH
	mov	DWORD PTR [esi+68], 2139095039		; 7f7fffffH
	mov	DWORD PTR [esi+72], -8388609		; ff7fffffH
	mov	DWORD PTR [esi+76], -8388609		; ff7fffffH

; 97   :     ImVec2() { x = y = 0.0f; }

	mov	DWORD PTR [esi+84], 0
	mov	DWORD PTR [esi+80], 0
	mov	DWORD PTR [esi+96], 0
	mov	DWORD PTR [esi+92], 0
	mov	DWORD PTR [esi+104], 0
	mov	DWORD PTR [esi+100], 0
	mov	DWORD PTR [esi+112], 0
	mov	DWORD PTR [esi+108], 0
	mov	DWORD PTR [esi+124], 0
	mov	DWORD PTR [esi+120], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1821 : {

	call	??0ImGuiDrawContext@@QAE@XZ		; ImGuiDrawContext::ImGuiDrawContext
	lea	ebx, DWORD PTR [esi+460]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ebx+4], 0
	mov	DWORD PTR [ebx], 0
	mov	DWORD PTR [ebx+8], 0

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR [esi+472], 2139095039		; 7f7fffffH
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1821 : {

	lea	ecx, DWORD PTR [esi+528]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR [esi+476], 2139095039		; 7f7fffffH
	mov	DWORD PTR [esi+480], -8388609		; ff7fffffH
	mov	DWORD PTR [esi+484], -8388609		; ff7fffffH
	mov	DWORD PTR [esi+488], 2139095039		; 7f7fffffH
	mov	DWORD PTR [esi+492], 2139095039		; 7f7fffffH
	mov	DWORD PTR [esi+496], -8388609		; ff7fffffH
	mov	DWORD PTR [esi+500], -8388609		; ff7fffffH
	mov	DWORD PTR [esi+504], 2139095039		; 7f7fffffH
	mov	DWORD PTR [esi+508], 2139095039		; 7f7fffffH
	mov	DWORD PTR [esi+512], -8388609		; ff7fffffH
	mov	DWORD PTR [esi+516], -8388609		; ff7fffffH
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1821 : {

	call	??0ImGuiSimpleColumns@@QAE@XZ		; ImGuiSimpleColumns::ImGuiSimpleColumns
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [esi+612], 0
	mov	DWORD PTR [esi+608], 0
	mov	DWORD PTR [esi+616], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1822 :     Name = ImStrdup(name);

	push	DWORD PTR _name$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	?ImStrdup@@YAPADPBD@Z			; ImStrdup

; 1823 :     ID = ImHash(name, 0);

	push	0
	push	0
	push	DWORD PTR _name$[ebp]
	mov	DWORD PTR [esi], eax
	add	esi, 4
	call	?ImHash@@YAIPBXHI@Z			; ImHash
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi], eax

; 1824 :     IDStack.push_back(ID);

	mov	ecx, ebx
	push	esi
	call	?push_back@?$ImVector@I@@QAEXABI@Z	; ImVector<unsigned int>::push_back

; 1825 :     Flags = 0;

	mov	ebx, DWORD PTR _this$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T9[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1827 :     PosFloat = Pos = ImVec2(0.0f, 0.0f);

	mov	ecx, DWORD PTR $T9[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T9[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1827 :     PosFloat = Pos = ImVec2(0.0f, 0.0f);

	mov	eax, DWORD PTR $T9[ebp+4]
	mov	DWORD PTR [ebx+8], 0
	mov	DWORD PTR [ebx+12], 0
	mov	DWORD PTR [ebx+24], ecx
	mov	DWORD PTR [ebx+28], eax
	mov	DWORD PTR [ebx+16], ecx
	mov	DWORD PTR [ebx+20], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T8[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1828 :     Size = SizeFull = ImVec2(0.0f, 0.0f);

	mov	ecx, DWORD PTR $T8[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T8[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1828 :     Size = SizeFull = ImVec2(0.0f, 0.0f);

	mov	eax, DWORD PTR $T8[ebp+4]
	mov	DWORD PTR [ebx+44], eax
	mov	DWORD PTR [ebx+36], eax
	mov	DWORD PTR [ebx+40], ecx
	mov	DWORD PTR [ebx+32], ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T7[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1829 :     SizeContents = SizeContentsExplicit = ImVec2(0.0f, 0.0f);

	mov	ecx, DWORD PTR $T7[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T7[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1829 :     SizeContents = SizeContentsExplicit = ImVec2(0.0f, 0.0f);

	mov	eax, DWORD PTR $T7[ebp+4]
	mov	DWORD PTR [ebx+60], eax
	mov	DWORD PTR [ebx+52], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T6[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1830 :     WindowPadding = ImVec2(0.0f, 0.0f);

	mov	eax, DWORD PTR $T6[ebp]

; 1831 :     MoveId = GetID("#MOVE");

	push	0
	mov	DWORD PTR [ebx+56], ecx
	mov	DWORD PTR [ebx+48], ecx
	mov	ecx, ebx
	mov	DWORD PTR [ebx+80], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T6[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1830 :     WindowPadding = ImVec2(0.0f, 0.0f);

	mov	eax, DWORD PTR $T6[ebp+4]

; 1831 :     MoveId = GetID("#MOVE");

	push	OFFSET $SG16890
	mov	DWORD PTR [ebx+84], eax
	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID
	mov	DWORD PTR [ebx+88], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T5[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1832 :     Scroll = ImVec2(0.0f, 0.0f);

	mov	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR [ebx+92], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T5[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1832 :     Scroll = ImVec2(0.0f, 0.0f);

	mov	eax, DWORD PTR $T5[ebp+4]
	mov	DWORD PTR [ebx+96], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T4[ebp], 2139095039		; 7f7fffffH
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1833 :     ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);

	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR [ebx+100], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T4[ebp+4], 2139095039	; 7f7fffffH
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1833 :     ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);

	mov	eax, DWORD PTR $T4[ebp+4]
	mov	DWORD PTR [ebx+104], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T3[ebp], 1056964608		; 3f000000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1834 :     ScrollTargetCenterRatio = ImVec2(0.5f, 0.5f);

	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR [ebx+108], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T3[ebp+4], 1056964608	; 3f000000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1834 :     ScrollTargetCenterRatio = ImVec2(0.5f, 0.5f);

	mov	eax, DWORD PTR $T3[ebp+4]
	mov	DWORD PTR [ebx+112], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T2[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1836 :     ScrollbarSizes = ImVec2(0.0f, 0.0f);

	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR [ebx+120], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T2[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1836 :     ScrollbarSizes = ImVec2(0.0f, 0.0f);

	mov	eax, DWORD PTR $T2[ebp+4]

; 1837 :     BorderSize = 0.0f;
; 1838 :     Active = WasActive = false;
; 1839 :     Accessed = false;
; 1840 :     Collapsed = false;
; 1841 :     CollapseToggleWanted = false;
; 1842 :     SkipItems = false;
; 1843 :     BeginCount = 0;
; 1844 :     PopupId = 0;
; 1845 :     NavLastId = 0;
; 1846 :     AutoFitFramesX = AutoFitFramesY = -1;
; 1847 :     AutoFitOnlyGrows = false;
; 1848 :     AutoFitChildAxises = 0x00;
; 1849 :     AutoPosLastDirection = -1;
; 1850 :     HiddenFrames = 0;
; 1851 :     SetWindowPosAllowFlags = SetWindowSizeAllowFlags = SetWindowCollapsedAllowFlags = ImGuiSetCond_Always | ImGuiSetCond_Once | ImGuiSetCond_FirstUseEver | ImGuiSetCond_Appearing;
; 1852 :     SetWindowPosCenterWanted = false;
; 1853 : 
; 1854 :     LastFrameActive = -1;
; 1855 :     ItemWidthDefault = 0.0f;
; 1856 :     FontWindowScale = 1.0f;
; 1857 : 
; 1858 :     DrawList = (ImDrawList*)ImGui::MemAlloc(sizeof(ImDrawList));

	push	108					; 0000006cH
	mov	WORD PTR [ebx+116], 0
	mov	DWORD PTR [ebx+124], eax
	mov	DWORD PTR [ebx+128], 0
	mov	DWORD PTR [ebx+132], 0
	mov	WORD PTR [ebx+136], 0
	mov	DWORD PTR [ebx+140], 0
	mov	DWORD PTR [ebx+144], 0
	mov	DWORD PTR [ebx+148], 0
	mov	DWORD PTR [ebx+156], -1
	mov	DWORD PTR [ebx+152], -1
	mov	BYTE PTR [ebx+160], 0
	mov	DWORD PTR [ebx+164], 0
	mov	DWORD PTR [ebx+168], -1
	mov	DWORD PTR [ebx+172], 0
	mov	DWORD PTR [ebx+184], 15			; 0000000fH
	mov	DWORD PTR [ebx+180], 15			; 0000000fH
	mov	DWORD PTR [ebx+176], 15			; 0000000fH
	mov	BYTE PTR [ebx+188], 0
	mov	DWORD PTR [ebx+520], -1
	mov	DWORD PTR [ebx+524], 0
	mov	DWORD PTR [ebx+620], 1065353216		; 3f800000H
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 1859 :     IM_PLACEMENT_NEW(DrawList) ImDrawList();

	lea	ecx, DWORD PTR $T12[ebp]
	mov	DWORD PTR [ebx+624], eax
	add	esp, 4
	mov	DWORD PTR $T11[ebp], ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 147  : inline void* operator new(size_t, ImPlacementNewDummy, void* ptr) { return ptr; }

	mov	DWORD PTR $T10[ebp], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1859 :     IM_PLACEMENT_NEW(DrawList) ImDrawList();

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	test	eax, eax
	je	SHORT $LN3@ImGuiWindo
	mov	ecx, eax
	call	??0ImDrawList@@QAE@XZ			; ImDrawList::ImDrawList
$LN3@ImGuiWindo:

; 1860 :     DrawList->_OwnerName = Name;

	mov	ecx, DWORD PTR [ebx+624]
	mov	eax, DWORD PTR [ebx]
	pop	esi
	mov	DWORD PTR [ecx+36], eax

; 1861 :     ParentWindow = NULL;
; 1862 :     RootWindow = NULL;
; 1863 :     RootNonPopupWindow = NULL;
; 1864 :     RootNavWindow = NULL;
; 1865 : 
; 1866 :     FocusIdxAllCounter = FocusIdxTabCounter = -1;
; 1867 :     FocusIdxAllRequestCurrent = FocusIdxTabRequestCurrent = INT_MAX;
; 1868 :     FocusIdxAllRequestNext = FocusIdxTabRequestNext = INT_MAX;
; 1869 : }

	mov	eax, ebx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR [ebx+628], 0
	mov	DWORD PTR [ebx+632], 0
	mov	DWORD PTR [ebx+636], 0
	mov	DWORD PTR [ebx+640], 0
	mov	DWORD PTR [ebx+648], -1
	mov	DWORD PTR [ebx+644], -1
	mov	DWORD PTR [ebx+656], 2147483647		; 7fffffffH
	mov	DWORD PTR [ebx+652], 2147483647		; 7fffffffH
	mov	DWORD PTR [ebx+664], 2147483647		; 7fffffffH
	mov	DWORD PTR [ebx+660], 2147483647		; 7fffffffH
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0ImGuiWindow@@QAE@PBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 192				; 000000c0H
	jmp	??1ImGuiDrawContext@@QAE@XZ
__unwindfunclet$??0ImGuiWindow@@QAE@PBD@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 460				; 000001ccH
	jmp	??1?$ImVector@I@@QAE@XZ			; ImVector<unsigned int>::~ImVector<unsigned int>
__unwindfunclet$??0ImGuiWindow@@QAE@PBD@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 608				; 00000260H
	jmp	??1ImGuiStorage@@QAE@XZ
__unwindfunclet$??0ImGuiWindow@@QAE@PBD@Z$3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+624]
	push	eax
	mov	eax, DWORD PTR $T11[ebp]
	movzx	eax, BYTE PTR [eax]
	push	eax
	mov	eax, DWORD PTR $T10[ebp]
	push	eax
	call	??3@YAXPAXUImPlacementNewDummy@@0@Z	; operator delete
	add	esp, 12					; 0000000cH
	ret	0
__ehhandler$??0ImGuiWindow@@QAE@PBD@Z:
	mov	eax, OFFSET __ehfuncinfo$??0ImGuiWindow@@QAE@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0ImGuiWindow@@QAE@PBD@Z ENDP				; ImGuiWindow::ImGuiWindow
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@I@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$ImVector@I@@QAEXXZ PROC			; ImVector<unsigned int>::pop_back, COMDAT
; _this$ = ecx

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [ecx]
	ret	0
?pop_back@?$ImVector@I@@QAEXXZ ENDP			; ImVector<unsigned int>::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@I@@QAEXABI@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?push_back@?$ImVector@I@@QAEXABI@Z PROC			; ImVector<unsigned int>::push_back, COMDAT
; _this$ = ecx

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jne	SHORT $LN8@push_back
	inc	edi

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, edi
	cmovg	edi, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	edi, ecx
	jle	SHORT $LN8@push_back

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN10@push_back

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@push_back:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN8@push_back:

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR _v$[ebp]
	pop	edi
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+edx*4], eax
	inc	DWORD PTR [esi]
	pop	esi
	pop	ebp
	ret	4
?push_back@?$ImVector@I@@QAEXABI@Z ENDP			; ImVector<unsigned int>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@I@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@I@@QAEXH@Z PROC			; ImVector<unsigned int>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@I@@QAEXH@Z ENDP			; ImVector<unsigned int>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@I@@QAEXH@Z
_TEXT	SEGMENT
_new_data$1$ = 8					; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@I@@QAEXH@Z PROC			; ImVector<unsigned int>::resize, COMDAT
; _this$ = ecx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR _new_size$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jle	SHORT $LN12@resize

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@resize
$LN6@resize:
	mov	eax, 8
$LN7@resize:
	push	ebx
	cmp	eax, edi
	mov	ebx, edi
	cmovg	ebx, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	ebx, ecx
	jle	SHORT $LN13@resize

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [ebx*4]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [esi+8]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN10@resize

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@resize:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], ebx
$LN13@resize:
	pop	ebx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
$LN12@resize:
	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?resize@?$ImVector@I@@QAEXH@Z ENDP			; ImVector<unsigned int>::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@I@@QAEHH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?_grow_capacity@?$ImVector@I@@QAEHH@Z PROC		; ImVector<unsigned int>::_grow_capacity, COMDAT
; _this$ = ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@grow_capac
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _new_size$[ebp]
	sar	ecx, 1
	add	ecx, esi
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
$LN3@grow_capac:
	mov	eax, DWORD PTR _new_size$[ebp]
	mov	ecx, 8
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
?_grow_capacity@?$ImVector@I@@QAEHH@Z ENDP		; ImVector<unsigned int>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?back@?$ImVector@I@@QAEAAIXZ
_TEXT	SEGMENT
?back@?$ImVector@I@@QAEAAIXZ PROC			; ImVector<unsigned int>::back, COMDAT
; _this$ = ecx

; 922  :     inline value_type&          back()                          { IM_ASSERT(Size > 0); return Data[Size-1]; }

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [eax+edx*4]
	add	eax, -4					; fffffffcH
	ret	0
?back@?$ImVector@I@@QAEAAIXZ ENDP			; ImVector<unsigned int>::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@I@@QAEAAIH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@I@@QAEAAIH@Z PROC				; ImVector<unsigned int>::operator[], COMDAT
; _this$ = ecx

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	pop	ebp
	ret	4
??A?$ImVector@I@@QAEAAIH@Z ENDP				; ImVector<unsigned int>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@I@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@I@@QAE@XZ PROC				; ImVector<unsigned int>::~ImVector<unsigned int>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@I@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@I@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@I@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@I@@QAE@XZ ENDP				; ImVector<unsigned int>::~ImVector<unsigned int>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@I@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@I@@QAE@XZ PROC				; ImVector<unsigned int>::ImVector<unsigned int>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@I@@QAE@XZ ENDP				; ImVector<unsigned int>::ImVector<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??4ImGuiDrawContext@@QAEAAU0@$$QAU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4ImGuiDrawContext@@QAEAAU0@$$QAU0@@Z PROC		; ImGuiDrawContext::operator=, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], eax
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+24], eax
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+28], eax
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+32], eax
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+36], eax
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx+40], eax
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [ecx+44], eax
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR [ecx+48], eax
	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR [ecx+52], eax
	mov	eax, DWORD PTR [edx+56]
	mov	DWORD PTR [ecx+56], eax
	movups	xmm0, XMMWORD PTR [edx+60]
	movups	XMMWORD PTR [ecx+60], xmm0
	movzx	eax, BYTE PTR [edx+76]
	mov	BYTE PTR [ecx+76], al
	movzx	eax, BYTE PTR [edx+77]
	mov	BYTE PTR [ecx+77], al
	movzx	eax, BYTE PTR [edx+78]
	mov	BYTE PTR [ecx+78], al
	mov	eax, DWORD PTR [edx+80]
	mov	DWORD PTR [ecx+80], eax
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR [ecx+84], eax
	mov	eax, DWORD PTR [edx+88]
	mov	DWORD PTR [ecx+88], eax
	movzx	eax, BYTE PTR [edx+92]
	mov	BYTE PTR [ecx+92], al
	mov	eax, DWORD PTR [edx+96]
	mov	DWORD PTR [ecx+96], eax
	movq	xmm0, QWORD PTR [edx+100]
	movq	QWORD PTR [ecx+100], xmm0
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR [ecx+108], eax
	mov	eax, DWORD PTR [edx+112]
	mov	DWORD PTR [ecx+112], eax
	mov	eax, DWORD PTR [edx+116]
	mov	DWORD PTR [ecx+116], eax
	mov	eax, DWORD PTR [edx+120]
	mov	DWORD PTR [ecx+120], eax
	mov	eax, DWORD PTR [edx+124]
	mov	DWORD PTR [ecx+124], eax
	mov	eax, DWORD PTR [edx+128]
	mov	DWORD PTR [ecx+128], eax
	movq	xmm0, QWORD PTR [edx+132]
	movq	QWORD PTR [ecx+132], xmm0
	mov	eax, DWORD PTR [edx+140]
	mov	DWORD PTR [ecx+140], eax
	movq	xmm0, QWORD PTR [edx+144]
	movq	QWORD PTR [ecx+144], xmm0
	mov	eax, DWORD PTR [edx+152]
	mov	DWORD PTR [ecx+152], eax
	movq	xmm0, QWORD PTR [edx+156]
	movq	QWORD PTR [ecx+156], xmm0
	mov	eax, DWORD PTR [edx+164]
	mov	DWORD PTR [ecx+164], eax
	movq	xmm0, QWORD PTR [edx+168]
	movq	QWORD PTR [ecx+168], xmm0
	mov	eax, DWORD PTR [edx+176]
	mov	DWORD PTR [ecx+176], eax
	mov	eax, DWORD PTR [edx+180]
	mov	DWORD PTR [ecx+180], eax
	mov	eax, DWORD PTR [edx+184]
	mov	DWORD PTR [ecx+184], eax
	mov	eax, DWORD PTR [edx+188]
	mov	DWORD PTR [ecx+188], eax
	mov	eax, DWORD PTR [edx+192]
	mov	DWORD PTR [ecx+192], eax
	mov	eax, DWORD PTR [edx+196]
	mov	DWORD PTR [ecx+196], eax
	mov	eax, DWORD PTR [edx+200]
	mov	DWORD PTR [ecx+200], eax
	mov	eax, DWORD PTR [edx+204]
	mov	DWORD PTR [ecx+204], eax
	mov	eax, DWORD PTR [edx+208]
	mov	DWORD PTR [ecx+208], eax
	mov	eax, DWORD PTR [edx+212]
	mov	DWORD PTR [ecx+212], eax
	mov	eax, DWORD PTR [edx+216]
	mov	DWORD PTR [ecx+216], eax
	mov	eax, DWORD PTR [edx+220]
	mov	DWORD PTR [ecx+220], eax
	mov	eax, DWORD PTR [edx+224]
	mov	DWORD PTR [ecx+224], eax
	mov	eax, DWORD PTR [edx+228]
	mov	DWORD PTR [ecx+228], eax
	mov	eax, DWORD PTR [edx+232]
	mov	DWORD PTR [ecx+232], eax
	mov	eax, DWORD PTR [edx+236]
	mov	DWORD PTR [ecx+236], eax
	mov	eax, DWORD PTR [edx+240]
	mov	DWORD PTR [ecx+240], eax
	mov	eax, DWORD PTR [edx+244]
	mov	DWORD PTR [ecx+244], eax
	movzx	eax, BYTE PTR [edx+248]
	mov	BYTE PTR [ecx+248], al
	mov	eax, DWORD PTR [edx+252]
	mov	DWORD PTR [ecx+252], eax
	movq	xmm0, QWORD PTR [edx+256]
	movq	QWORD PTR [ecx+256], xmm0
	mov	eax, DWORD PTR [edx+264]
	mov	DWORD PTR [ecx+264], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??4ImGuiDrawContext@@QAEAAU0@$$QAU0@@Z ENDP		; ImGuiDrawContext::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??4ImGuiDrawContext@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4ImGuiDrawContext@@QAEAAU0@ABU0@@Z PROC		; ImGuiDrawContext::operator=, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___that$[ebp]
	mov	eax, ecx
	push	edi
	mov	ecx, 67					; 00000043H
	mov	edi, eax
	rep movsd
	pop	edi
	pop	esi
	pop	ebp
	ret	4
??4ImGuiDrawContext@@QAEAAU0@ABU0@@Z ENDP		; ImGuiDrawContext::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1ImGuiDrawContext@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1ImGuiDrawContext@@QAE@XZ PROC			; ImGuiDrawContext::~ImGuiDrawContext, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1ImGuiDrawContext@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	mov	eax, DWORD PTR [esi+264]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN4@ImGuiDrawC
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN4@ImGuiDrawC:
	mov	eax, DWORD PTR [esi+176]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	eax, eax
	je	SHORT $LN8@ImGuiDrawC
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN8@ImGuiDrawC:
	mov	eax, DWORD PTR [esi+164]
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	test	eax, eax
	je	SHORT $LN12@ImGuiDrawC
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN12@ImGuiDrawC:
	mov	eax, DWORD PTR [esi+152]
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	test	eax, eax
	je	SHORT $LN16@ImGuiDrawC
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN16@ImGuiDrawC:
	mov	eax, DWORD PTR [esi+140]
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	test	eax, eax
	je	SHORT $LN20@ImGuiDrawC
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN20@ImGuiDrawC:
	mov	eax, DWORD PTR [esi+108]
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	test	eax, eax
	je	SHORT $LN24@ImGuiDrawC
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN24@ImGuiDrawC:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1ImGuiDrawContext@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1ImGuiDrawContext@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1ImGuiDrawContext@@QAE@XZ ENDP			; ImGuiDrawContext::~ImGuiDrawContext
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ??0ImGuiDrawContext@@QAE@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 8
_this$ = -4						; size = 4
??0ImGuiDrawContext@@QAE@XZ PROC			; ImGuiDrawContext::ImGuiDrawContext, COMDAT
; _this$ = ecx

; 662  :     ImGuiDrawContext()

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	edx, ecx
	xorps	xmm0, xmm0
	mov	DWORD PTR _this$[ebp], edx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 664  :         CursorPos = CursorPosPrevLine = CursorStartPos = CursorMaxPos = ImVec2(0.0f, 0.0f);

	mov	ecx, DWORD PTR $T1[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 97   :     ImVec2() { x = y = 0.0f; }

	mov	DWORD PTR [edx+4], 0
	mov	DWORD PTR [edx], 0
	mov	DWORD PTR [edx+12], 0
	mov	DWORD PTR [edx+8], 0
	mov	DWORD PTR [edx+20], 0
	mov	DWORD PTR [edx+16], 0
	mov	DWORD PTR [edx+28], 0
	mov	DWORD PTR [edx+24], 0

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR [edx+60], 2139095039		; 7f7fffffH
	mov	DWORD PTR [edx+64], 2139095039		; 7f7fffffH
	mov	DWORD PTR [edx+68], -8388609		; ff7fffffH
	mov	DWORD PTR [edx+72], -8388609		; ff7fffffH

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [edx+104], 0
	mov	DWORD PTR [edx+100], 0
	mov	DWORD PTR [edx+108], 0
	mov	DWORD PTR [edx+136], 0
	mov	DWORD PTR [edx+132], 0
	mov	DWORD PTR [edx+140], 0
	mov	DWORD PTR [edx+148], 0
	mov	DWORD PTR [edx+144], 0
	mov	DWORD PTR [edx+152], 0
	mov	DWORD PTR [edx+160], 0
	mov	DWORD PTR [edx+156], 0
	mov	DWORD PTR [edx+164], 0
	mov	DWORD PTR [edx+172], 0
	mov	DWORD PTR [edx+168], 0
	mov	DWORD PTR [edx+176], 0
	mov	DWORD PTR [edx+260], 0
	mov	DWORD PTR [edx+256], 0
	mov	DWORD PTR [edx+264], 0

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp+4], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 664  :         CursorPos = CursorPosPrevLine = CursorStartPos = CursorMaxPos = ImVec2(0.0f, 0.0f);

	mov	eax, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR [edx+28], eax
	mov	DWORD PTR [edx+20], eax
	mov	DWORD PTR [edx+12], eax
	mov	DWORD PTR [edx+4], eax

; 665  :         CurrentLineHeight = PrevLineHeight = 0.0f;
; 666  :         CurrentLineTextBaseOffset = PrevLineTextBaseOffset = 0.0f;
; 667  :         LogLinePosY = -1.0f;
; 668  :         TreeDepth = 0;
; 669  :         LastItemId = 0;
; 670  :         LastItemRect = ImRect(0.0f,0.0f,0.0f,0.0f);
; 671  :         LastItemHoveredAndUsable = LastItemHoveredRect = false;
; 672  :         NavHasScroll = false;
; 673  :         NavLayerActiveFlags = NavLayerActiveFlagsNext = 0x00;
; 674  :         NavLayerCurrent = 0;
; 675  :         MenuBarAppending = false;
; 676  :         MenuBarOffsetX = 0.0f;
; 677  :         StateStorage = NULL;
; 678  :         LayoutType = ImGuiLayoutType_Vertical;
; 679  :         ItemWidth = 0.0f;
; 680  :         ItemFlags = ImGuiItemFlags_Default_;
; 681  :         TextWrapPos = -1.0f;
; 682  :         ColorEditMode = ImGuiColorEditMode_RGB;
; 683  :         memset(StackSizesBackup, 0, sizeof(StackSizesBackup));
; 684  : 
; 685  :         IndentX = 0.0f;
; 686  :         GroupOffsetX = 0.0f;
; 687  :         ColumnsOffsetX = 0.0f;
; 688  :         ColumnsCurrent = 0;
; 689  :         ColumnsCount = 1;
; 690  :         ColumnsMinX = ColumnsMaxX = 0.0f;
; 691  :         ColumnsStartPosY = 0.0f;
; 692  :         ColumnsCellMinY = ColumnsCellMaxY = 0.0f;
; 693  :         ColumnsShowBorders = true;
; 694  :         ColumnsSetId = 0;
; 695  :     }

	mov	eax, edx
	mov	DWORD PTR [edx+24], ecx
	mov	DWORD PTR [edx+16], ecx
	mov	DWORD PTR [edx+8], ecx
	mov	DWORD PTR [edx], ecx
	mov	DWORD PTR [edx+40], 0
	mov	DWORD PTR [edx+32], 0
	mov	DWORD PTR [edx+44], 0
	mov	DWORD PTR [edx+36], 0
	mov	DWORD PTR [edx+48], -1082130432		; bf800000H
	mov	DWORD PTR [edx+52], 0
	mov	DWORD PTR [edx+56], 0
	movups	XMMWORD PTR [edx+60], xmm0
	mov	WORD PTR [edx+76], 0
	mov	BYTE PTR [edx+78], 0
	mov	DWORD PTR [edx+88], 0
	mov	DWORD PTR [edx+84], 0
	mov	DWORD PTR [edx+80], 0
	mov	BYTE PTR [edx+92], 0
	mov	DWORD PTR [edx+96], 0
	mov	DWORD PTR [edx+112], 0
	mov	DWORD PTR [edx+116], 0
	mov	DWORD PTR [edx+124], 0
	mov	DWORD PTR [edx+120], 3
	mov	DWORD PTR [edx+128], -1082130432	; bf800000H
	mov	DWORD PTR [edx+180], 0
	movups	XMMWORD PTR [edx+184], xmm0
	movq	QWORD PTR [edx+200], xmm0
	mov	DWORD PTR [edx+208], 0
	mov	DWORD PTR [edx+212], 0
	mov	DWORD PTR [edx+216], 0
	mov	DWORD PTR [edx+220], 0
	mov	DWORD PTR [edx+224], 1
	mov	DWORD PTR [edx+232], 0
	mov	DWORD PTR [edx+228], 0
	mov	DWORD PTR [edx+236], 0
	mov	DWORD PTR [edx+244], 0
	mov	DWORD PTR [edx+240], 0
	mov	BYTE PTR [edx+248], 1
	mov	DWORD PTR [edx+252], 0
	mov	esp, ebp
	pop	ebp
	ret	0
??0ImGuiDrawContext@@QAE@XZ ENDP			; ImGuiDrawContext::ImGuiDrawContext
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiColumnData@@@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UImGuiColumnData@@@@QAEXH@Z PROC	; ImVector<ImGuiColumnData>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@UImGuiColumnData@@@@QAEXH@Z ENDP	; ImVector<ImGuiColumnData>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImGuiColumnData@@@@QAEXH@Z
_TEXT	SEGMENT
_new_data$1$ = 8					; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@UImGuiColumnData@@@@QAEXH@Z PROC	; ImVector<ImGuiColumnData>::resize, COMDAT
; _this$ = ecx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR _new_size$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jle	SHORT $LN12@resize

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@resize
$LN6@resize:
	mov	eax, 8
$LN7@resize:
	push	ebx
	cmp	eax, edi
	mov	ebx, edi
	cmovg	ebx, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	ebx, ecx
	jle	SHORT $LN13@resize

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [ebx*4]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [esi+8]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN10@resize

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@resize:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], ebx
$LN13@resize:
	pop	ebx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
$LN12@resize:
	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?resize@?$ImVector@UImGuiColumnData@@@@QAEXH@Z ENDP	; ImVector<ImGuiColumnData>::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiColumnData@@@@QAEHH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?_grow_capacity@?$ImVector@UImGuiColumnData@@@@QAEHH@Z PROC ; ImVector<ImGuiColumnData>::_grow_capacity, COMDAT
; _this$ = ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@grow_capac
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _new_size$[ebp]
	sar	ecx, 1
	add	ecx, esi
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
$LN3@grow_capac:
	mov	eax, DWORD PTR _new_size$[ebp]
	mov	ecx, 8
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
?_grow_capacity@?$ImVector@UImGuiColumnData@@@@QAEHH@Z ENDP ; ImVector<ImGuiColumnData>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImGuiColumnData@@@@QAEAAUImGuiColumnData@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@UImGuiColumnData@@@@QAEAAUImGuiColumnData@@H@Z PROC ; ImVector<ImGuiColumnData>::operator[], COMDAT
; _this$ = ecx

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	pop	ebp
	ret	4
??A?$ImVector@UImGuiColumnData@@@@QAEAAUImGuiColumnData@@H@Z ENDP ; ImVector<ImGuiColumnData>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImGuiColumnData@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@UImGuiColumnData@@@@QAE@XZ PROC		; ImVector<ImGuiColumnData>::~ImVector<ImGuiColumnData>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@UImGuiColumnData@@@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@UImGuiColumnData@@@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@UImGuiColumnData@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@UImGuiColumnData@@@@QAE@XZ ENDP		; ImVector<ImGuiColumnData>::~ImVector<ImGuiColumnData>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImGuiColumnData@@@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@UImGuiColumnData@@@@QAE@XZ PROC		; ImVector<ImGuiColumnData>::ImVector<ImGuiColumnData>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@UImGuiColumnData@@@@QAE@XZ ENDP		; ImVector<ImGuiColumnData>::ImVector<ImGuiColumnData>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@UImGuiGroupData@@@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$ImVector@UImGuiGroupData@@@@QAEXXZ PROC	; ImVector<ImGuiGroupData>::pop_back, COMDAT
; _this$ = ecx

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [ecx]
	ret	0
?pop_back@?$ImVector@UImGuiGroupData@@@@QAEXXZ ENDP	; ImVector<ImGuiGroupData>::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiGroupData@@@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UImGuiGroupData@@@@QAEXH@Z PROC	; ImVector<ImGuiGroupData>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi+edi*4]
	shl	eax, 3
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	shl	ecx, 3
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@UImGuiGroupData@@@@QAEXH@Z ENDP	; ImVector<ImGuiGroupData>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImGuiGroupData@@@@QAEXH@Z
_TEXT	SEGMENT
_new_data$1$ = 8					; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@UImGuiGroupData@@@@QAEXH@Z PROC	; ImVector<ImGuiGroupData>::resize, COMDAT
; _this$ = ecx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR _new_size$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jle	SHORT $LN12@resize

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@resize
$LN6@resize:
	mov	eax, 8
$LN7@resize:
	push	ebx
	cmp	eax, edi
	mov	ebx, edi
	cmovg	ebx, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	ebx, ecx
	jle	SHORT $LN13@resize

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [ebx+ebx*4]
	shl	eax, 3
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [esi+8]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN10@resize

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	shl	ecx, 3
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@resize:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], ebx
$LN13@resize:
	pop	ebx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
$LN12@resize:
	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?resize@?$ImVector@UImGuiGroupData@@@@QAEXH@Z ENDP	; ImVector<ImGuiGroupData>::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiGroupData@@@@QAEHH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?_grow_capacity@?$ImVector@UImGuiGroupData@@@@QAEHH@Z PROC ; ImVector<ImGuiGroupData>::_grow_capacity, COMDAT
; _this$ = ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@grow_capac
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _new_size$[ebp]
	sar	ecx, 1
	add	ecx, esi
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
$LN3@grow_capac:
	mov	eax, DWORD PTR _new_size$[ebp]
	mov	ecx, 8
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
?_grow_capacity@?$ImVector@UImGuiGroupData@@@@QAEHH@Z ENDP ; ImVector<ImGuiGroupData>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImGuiGroupData@@@@QAEAAUImGuiGroupData@@XZ
_TEXT	SEGMENT
?back@?$ImVector@UImGuiGroupData@@@@QAEAAUImGuiGroupData@@XZ PROC ; ImVector<ImGuiGroupData>::back, COMDAT
; _this$ = ecx

; 922  :     inline value_type&          back()                          { IM_ASSERT(Size > 0); return Data[Size-1]; }

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [eax+edx*8]
	add	eax, -40				; ffffffd8H
	ret	0
?back@?$ImVector@UImGuiGroupData@@@@QAEAAUImGuiGroupData@@XZ ENDP ; ImVector<ImGuiGroupData>::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?empty@?$ImVector@UImGuiGroupData@@@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$ImVector@UImGuiGroupData@@@@QBE_NXZ PROC	; ImVector<ImGuiGroupData>::empty, COMDAT
; _this$ = ecx

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	cmp	DWORD PTR [ecx], 0
	sete	al
	ret	0
?empty@?$ImVector@UImGuiGroupData@@@@QBE_NXZ ENDP	; ImVector<ImGuiGroupData>::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImGuiGroupData@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@UImGuiGroupData@@@@QAE@XZ PROC		; ImVector<ImGuiGroupData>::~ImVector<ImGuiGroupData>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@UImGuiGroupData@@@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@UImGuiGroupData@@@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@UImGuiGroupData@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@UImGuiGroupData@@@@QAE@XZ ENDP		; ImVector<ImGuiGroupData>::~ImVector<ImGuiGroupData>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImGuiGroupData@@@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@UImGuiGroupData@@@@QAE@XZ PROC		; ImVector<ImGuiGroupData>::ImVector<ImGuiGroupData>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@UImGuiGroupData@@@@QAE@XZ ENDP		; ImVector<ImGuiGroupData>::ImVector<ImGuiGroupData>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@H@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$ImVector@H@@QAEXXZ PROC			; ImVector<int>::pop_back, COMDAT
; _this$ = ecx

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [ecx]
	ret	0
?pop_back@?$ImVector@H@@QAEXXZ ENDP			; ImVector<int>::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@H@@QAEXABH@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?push_back@?$ImVector@H@@QAEXABH@Z PROC			; ImVector<int>::push_back, COMDAT
; _this$ = ecx

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jne	SHORT $LN8@push_back
	inc	edi

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, edi
	cmovg	edi, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	edi, ecx
	jle	SHORT $LN8@push_back

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN10@push_back

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@push_back:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN8@push_back:

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR _v$[ebp]
	pop	edi
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+edx*4], eax
	inc	DWORD PTR [esi]
	pop	esi
	pop	ebp
	ret	4
?push_back@?$ImVector@H@@QAEXABH@Z ENDP			; ImVector<int>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@H@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@H@@QAEXH@Z PROC			; ImVector<int>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@H@@QAEXH@Z ENDP			; ImVector<int>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@H@@QAEXH@Z
_TEXT	SEGMENT
_new_data$1$ = 8					; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@H@@QAEXH@Z PROC			; ImVector<int>::resize, COMDAT
; _this$ = ecx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR _new_size$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jle	SHORT $LN12@resize

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@resize
$LN6@resize:
	mov	eax, 8
$LN7@resize:
	push	ebx
	cmp	eax, edi
	mov	ebx, edi
	cmovg	ebx, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	ebx, ecx
	jle	SHORT $LN13@resize

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [ebx*4]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [esi+8]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN10@resize

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@resize:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], ebx
$LN13@resize:
	pop	ebx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
$LN12@resize:
	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?resize@?$ImVector@H@@QAEXH@Z ENDP			; ImVector<int>::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@H@@QAEHH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?_grow_capacity@?$ImVector@H@@QAEHH@Z PROC		; ImVector<int>::_grow_capacity, COMDAT
; _this$ = ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@grow_capac
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _new_size$[ebp]
	sar	ecx, 1
	add	ecx, esi
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
$LN3@grow_capac:
	mov	eax, DWORD PTR _new_size$[ebp]
	mov	ecx, 8
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
?_grow_capacity@?$ImVector@H@@QAEHH@Z ENDP		; ImVector<int>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?back@?$ImVector@H@@QAEAAHXZ
_TEXT	SEGMENT
?back@?$ImVector@H@@QAEAAHXZ PROC			; ImVector<int>::back, COMDAT
; _this$ = ecx

; 922  :     inline value_type&          back()                          { IM_ASSERT(Size > 0); return Data[Size-1]; }

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [eax+edx*4]
	add	eax, -4					; fffffffcH
	ret	0
?back@?$ImVector@H@@QAEAAHXZ ENDP			; ImVector<int>::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?empty@?$ImVector@H@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$ImVector@H@@QBE_NXZ PROC			; ImVector<int>::empty, COMDAT
; _this$ = ecx

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	cmp	DWORD PTR [ecx], 0
	sete	al
	ret	0
?empty@?$ImVector@H@@QBE_NXZ ENDP			; ImVector<int>::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@H@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@H@@QAE@XZ PROC				; ImVector<int>::~ImVector<int>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@H@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@H@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@H@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@H@@QAE@XZ ENDP				; ImVector<int>::~ImVector<int>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@H@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@H@@QAE@XZ PROC				; ImVector<int>::ImVector<int>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@H@@QAE@XZ ENDP				; ImVector<int>::ImVector<int>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GImGuiContext@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GImGuiContext@@QAEPAXI@Z PROC			; ImGuiContext::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1ImGuiContext@@QAE@XZ
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	15192					; 00003b58H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_GImGuiContext@@QAEPAXI@Z ENDP			; ImGuiContext::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1ImGuiContext@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1ImGuiContext@@QAE@XZ PROC				; ImGuiContext::~ImGuiContext, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1ImGuiContext@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	mov	eax, DWORD PTR [esi+11580]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN4@ImGuiConte
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN4@ImGuiConte:
	mov	eax, DWORD PTR [esi+10512]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	eax, eax
	je	SHORT $LN11@ImGuiConte
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN11@ImGuiConte:
	lea	ecx, DWORD PTR [esi+10416]
	call	??1ImFont@@QAE@XZ			; ImFont::~ImFont
	mov	eax, DWORD PTR [esi+7168]
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	test	eax, eax
	je	SHORT $LN18@ImGuiConte
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN18@ImGuiConte:
	mov	eax, DWORD PTR [esi+7156]
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	test	eax, eax
	je	SHORT $LN22@ImGuiConte
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN22@ImGuiConte:
	mov	eax, DWORD PTR [esi+7144]
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	test	eax, eax
	je	SHORT $LN26@ImGuiConte
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN26@ImGuiConte:
	lea	ecx, DWORD PTR [esi+6656]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1ImDrawList@@QAE@XZ			; ImDrawList::~ImDrawList
	push	OFFSET ??1?$ImVector@PAUImDrawList@@@@QAE@XZ ; ImVector<ImDrawList *>::~ImVector<ImDrawList *>
	push	3
	push	12					; 0000000cH
	lea	eax, DWORD PTR [esi+6616]
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	mov	eax, DWORD PTR [esi+6376]
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	test	eax, eax
	je	SHORT $LN30@ImGuiConte
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN30@ImGuiConte:
	mov	eax, DWORD PTR [esi+6364]
	mov	DWORD PTR __$EHRec$[ebp+8], 6
	test	eax, eax
	je	SHORT $LN34@ImGuiConte
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN34@ImGuiConte:
	mov	eax, DWORD PTR [esi+6352]
	mov	DWORD PTR __$EHRec$[ebp+8], 7
	test	eax, eax
	je	SHORT $LN38@ImGuiConte
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN38@ImGuiConte:
	mov	eax, DWORD PTR [esi+6340]
	mov	DWORD PTR __$EHRec$[ebp+8], 8
	test	eax, eax
	je	SHORT $LN42@ImGuiConte
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN42@ImGuiConte:
	mov	eax, DWORD PTR [esi+6328]
	mov	DWORD PTR __$EHRec$[ebp+8], 9
	test	eax, eax
	je	SHORT $LN46@ImGuiConte
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN46@ImGuiConte:
	mov	eax, DWORD PTR [esi+6312]
	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH
	test	eax, eax
	je	SHORT $LN50@ImGuiConte
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN50@ImGuiConte:
	mov	eax, DWORD PTR [esi+6236]
	mov	DWORD PTR __$EHRec$[ebp+8], 11		; 0000000bH
	test	eax, eax
	je	SHORT $LN54@ImGuiConte
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN54@ImGuiConte:
	mov	eax, DWORD PTR [esi+6224]
	mov	DWORD PTR __$EHRec$[ebp+8], 12		; 0000000cH
	test	eax, eax
	je	SHORT $LN58@ImGuiConte
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN58@ImGuiConte:
	mov	eax, DWORD PTR [esi+6212]
	mov	DWORD PTR __$EHRec$[ebp+8], 13		; 0000000dH
	test	eax, eax
	je	SHORT $LN62@ImGuiConte
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN62@ImGuiConte:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1ImGuiContext@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1ImGuiContext@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1ImGuiContext@@QAE@XZ ENDP				; ImGuiContext::~ImGuiContext
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ??0ImGuiContext@@QAE@XZ
_TEXT	SEGMENT
$T2 = -20						; size = 8
$T3 = -20						; size = 8
$T4 = -20						; size = 8
$T5 = -20						; size = 8
$T6 = -20						; size = 8
$T7 = -20						; size = 8
$T8 = -20						; size = 8
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0ImGuiContext@@QAE@XZ PROC				; ImGuiContext::ImGuiContext, COMDAT
; _this$ = ecx

; 509  :     ImGuiContext()

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0ImGuiContext@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[ebp], esi

; 510  :     {

	lea	ecx, DWORD PTR [esi+4]
	call	??0ImGuiIO@@QAE@XZ			; ImGuiIO::ImGuiIO
	lea	ecx, DWORD PTR [esi+5320]
	call	??0ImGuiStyle@@QAE@XZ			; ImGuiStyle::ImGuiStyle
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 97   :     ImVec2() { x = y = 0.0f; }

	mov	DWORD PTR [esi+6184], 0
	mov	DWORD PTR [esi+6180], 0

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [esi+6208], 0
	mov	DWORD PTR [esi+6204], 0
	mov	DWORD PTR [esi+6212], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 510  :     {

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [esi+6220], 0
	mov	DWORD PTR [esi+6216], 0
	mov	DWORD PTR [esi+6224], 0
	mov	DWORD PTR [esi+6232], 0
	mov	DWORD PTR [esi+6228], 0
	mov	DWORD PTR [esi+6236], 0

; 97   :     ImVec2() { x = y = 0.0f; }

	mov	DWORD PTR [esi+6284], 0
	mov	DWORD PTR [esi+6280], 0

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [esi+6308], 0
	mov	DWORD PTR [esi+6304], 0
	mov	DWORD PTR [esi+6312], 0
	mov	DWORD PTR [esi+6324], 0
	mov	DWORD PTR [esi+6320], 0
	mov	DWORD PTR [esi+6328], 0
	mov	DWORD PTR [esi+6336], 0
	mov	DWORD PTR [esi+6332], 0
	mov	DWORD PTR [esi+6340], 0
	mov	DWORD PTR [esi+6348], 0
	mov	DWORD PTR [esi+6344], 0
	mov	DWORD PTR [esi+6352], 0
	mov	DWORD PTR [esi+6360], 0
	mov	DWORD PTR [esi+6356], 0
	mov	DWORD PTR [esi+6364], 0
	mov	DWORD PTR [esi+6372], 0
	mov	DWORD PTR [esi+6368], 0
	mov	DWORD PTR [esi+6376], 0

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR [esi+6400], 2139095039	; 7f7fffffH
	mov	DWORD PTR [esi+6404], 2139095039	; 7f7fffffH
	mov	DWORD PTR [esi+6408], -8388609		; ff7fffffH
	mov	DWORD PTR [esi+6412], -8388609		; ff7fffffH
	mov	DWORD PTR [esi+6416], 2139095039	; 7f7fffffH
	mov	DWORD PTR [esi+6420], 2139095039	; 7f7fffffH
	mov	DWORD PTR [esi+6424], -8388609		; ff7fffffH
	mov	DWORD PTR [esi+6428], -8388609		; ff7fffffH
	mov	DWORD PTR [esi+6464], 2139095039	; 7f7fffffH
	mov	DWORD PTR [esi+6468], 2139095039	; 7f7fffffH
	mov	DWORD PTR [esi+6472], -8388609		; ff7fffffH
	mov	DWORD PTR [esi+6476], -8388609		; ff7fffffH
	mov	DWORD PTR [esi+6504], 2139095039	; 7f7fffffH
	mov	DWORD PTR [esi+6508], 2139095039	; 7f7fffffH
	mov	DWORD PTR [esi+6512], -8388609		; ff7fffffH
	mov	DWORD PTR [esi+6516], -8388609		; ff7fffffH

; 97   :     ImVec2() { x = y = 0.0f; }

	mov	DWORD PTR [esi+6524], 0
	mov	DWORD PTR [esi+6520], 0
	mov	DWORD PTR [esi+6532], 0
	mov	DWORD PTR [esi+6528], 0
	mov	DWORD PTR [esi+6540], 0
	mov	DWORD PTR [esi+6536], 0

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR [esi+6564], 2139095039	; 7f7fffffH
	mov	DWORD PTR [esi+6568], 2139095039	; 7f7fffffH
	mov	DWORD PTR [esi+6572], -8388609		; ff7fffffH
	mov	DWORD PTR [esi+6576], -8388609		; ff7fffffH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 510  :     {

	mov	BYTE PTR __$EHRec$[ebp+8], 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1315 :     ImDrawData() { Valid = false; CmdLists = NULL; CmdListsCount = TotalVtxCount = TotalIdxCount = 0; }

	mov	BYTE PTR [esi+6596], 0
	mov	DWORD PTR [esi+6600], 0
	mov	DWORD PTR [esi+6612], 0
	mov	DWORD PTR [esi+6608], 0
	mov	DWORD PTR [esi+6604], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 510  :     {

	push	OFFSET ??1?$ImVector@PAUImDrawList@@@@QAE@XZ ; ImVector<ImDrawList *>::~ImVector<ImDrawList *>
	push	OFFSET ??0?$ImVector@PAUImDrawList@@@@QAE@XZ ; ImVector<ImDrawList *>::ImVector<ImDrawList *>
	push	3
	push	12					; 0000000cH
	lea	eax, DWORD PTR [esi+6616]
	push	eax
	call	??_L@YGXPAXIIP6EX0@Z1@Z
	lea	ecx, DWORD PTR [esi+6656]
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	call	??0ImDrawList@@QAE@XZ			; ImDrawList::ImDrawList
	lea	edi, DWORD PTR [esi+6768]
	mov	ecx, 7
	lea	eax, DWORD PTR [edi+16]
$LL79@ImGuiConte:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 97   :     ImVec2() { x = y = 0.0f; }

	mov	DWORD PTR [eax-8], 0
	lea	eax, DWORD PTR [eax+52]
	mov	DWORD PTR [eax-64], 0
	mov	DWORD PTR [eax-52], 0
	mov	DWORD PTR [eax-56], 0
	mov	DWORD PTR [eax-44], 0
	mov	DWORD PTR [eax-48], 0
	mov	DWORD PTR [eax-36], 0
	mov	DWORD PTR [eax-40], 0
	mov	DWORD PTR [eax-28], 0
	mov	DWORD PTR [eax-32], 0
	mov	DWORD PTR [eax-20], 0
	mov	DWORD PTR [eax-24], 0
	sub	ecx, 1
	jne	SHORT $LL79@ImGuiConte
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 510  :     {

	lea	eax, DWORD PTR [esi+7132]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+12], ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 341  :     ImGuiTextEditState()                            { memset(this, 0, sizeof(*this)); }

	push	3284					; 00000cd4H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+24], ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 341  :     ImGuiTextEditState()                            { memset(this, 0, sizeof(*this)); }

	push	ecx
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [eax+32], ecx
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR [eax+36], ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 341  :     ImGuiTextEditState()                            { memset(this, 0, sizeof(*this)); }

	call	_memset
	add	esp, 12					; 0000000cH

; 510  :     {

	lea	ecx, DWORD PTR [esi+10416]
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	call	??0ImFont@@QAE@XZ			; ImFont::ImFont
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [esi+10508], 0
	mov	DWORD PTR [esi+10504], 0
	mov	DWORD PTR [esi+10512], 0

; 97   :     ImVec2() { x = y = 0.0f; }

	mov	DWORD PTR [esi+10524], 0
	mov	DWORD PTR [esi+10520], 0
	mov	DWORD PTR [esi+10544], 0
	mov	DWORD PTR [esi+10540], 0

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [esi+11576], 0
	mov	DWORD PTR [esi+11572], 0
	mov	DWORD PTR [esi+11580], 0

; 97   :     ImVec2() { x = y = 0.0f; }

	mov	DWORD PTR [esi+11588], 0
	mov	DWORD PTR [esi+11584], 0
	mov	DWORD PTR [esi+11596], 0
	mov	DWORD PTR [esi+11592], 0
	movaps	xmm0, XMMWORD PTR __xmm@ff7fffffff7fffff7f7fffff7f7fffff

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T8[ebp], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 514  :         FontTexUvWhitePixel = ImVec2(0.0f, 0.0f);

	mov	eax, DWORD PTR $T8[ebp]
	mov	DWORD PTR [esi+6180], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T8[ebp+4], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 514  :         FontTexUvWhitePixel = ImVec2(0.0f, 0.0f);

	mov	eax, DWORD PTR $T8[ebp+4]
	mov	DWORD PTR [esi+6184], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T7[ebp], -1082130432		; bf800000H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 530  :         ActiveIdClickOffset = ImVec2(-1,-1);

	mov	eax, DWORD PTR $T7[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T7[ebp+4], -1082130432	; bf800000H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 530  :         ActiveIdClickOffset = ImVec2(-1,-1);

	mov	DWORD PTR [esi+6280], eax
	mov	eax, DWORD PTR $T7[ebp+4]
	mov	BYTE PTR [esi], 0
	mov	DWORD PTR [esi+6168], 0
	mov	DWORD PTR [esi+6176], 0
	mov	DWORD PTR [esi+6172], 0
	mov	DWORD PTR [esi+6188], 0
	mov	DWORD PTR [esi+6192], 0
	mov	DWORD PTR [esi+6200], -1
	mov	DWORD PTR [esi+6196], -1
	mov	DWORD PTR [esi+6240], 0
	mov	DWORD PTR [esi+6244], 0
	mov	DWORD PTR [esi+6248], 0
	mov	DWORD PTR [esi+6252], 0
	mov	BYTE PTR [esi+6256], 0
	mov	DWORD PTR [esi+6260], 0
	mov	DWORD PTR [esi+6264], 0
	mov	DWORD PTR [esi+6268], 0
	mov	WORD PTR [esi+6272], 0
	mov	BYTE PTR [esi+6274], 0
	mov	DWORD PTR [esi+6284], eax

; 531  :         ActiveIdWindow = NULL;

	mov	DWORD PTR [esi+6288], 0

; 532  :         ActiveIdSource = ImGuiInputSource_None;

	mov	DWORD PTR [esi+6292], 0

; 533  :         MovedWindow = NULL;

	mov	DWORD PTR [esi+6296], 0

; 534  :         MovedWindowMoveId = 0;

	mov	DWORD PTR [esi+6300], 0

; 535  :         SettingsDirtyTimer = 0.0f;

	mov	DWORD PTR [esi+6316], 0

; 536  : 
; 537  :         NavWindow = NULL;

	mov	DWORD PTR [esi+6380], 0

; 538  :         NavId = NavActivateId = NavInputId = NavTabbedId = 0;

	mov	DWORD PTR [esi+6396], 0
	mov	DWORD PTR [esi+6392], 0
	mov	DWORD PTR [esi+6388], 0
	mov	DWORD PTR [esi+6384], 0

; 539  :         NavRefRectRel = NavScoringRectScreen = ImRect();

	movups	XMMWORD PTR [esi+6416], xmm0

; 540  :         NavWindowingTarget = NULL;

	mov	DWORD PTR [esi+6432], 0
	movups	XMMWORD PTR [esi+6400], xmm0

; 541  :         NavWindowingDisplayAlpha = 0.0f;

	mov	DWORD PTR [esi+6436], 0

; 542  :         NavWindowingToggleLayer = false;

	mov	BYTE PTR [esi+6440], 0

; 543  :         NavIdTabCounter = INT_MAX;

	mov	DWORD PTR [esi+6448], 2147483647	; 7fffffffH

; 544  :         NavIdIsAlive = false;

	mov	DWORD PTR [esi+6452], 65536		; 00010000H
	movaps	xmm0, XMMWORD PTR __xmm@ff7fffffff7fffff7f7fffff7f7fffff
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T6[ebp], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 556  :         SetNextWindowPosVal = ImVec2(0.0f, 0.0f);

	mov	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR [esi+6520], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T6[ebp+4], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 556  :         SetNextWindowPosVal = ImVec2(0.0f, 0.0f);

	mov	eax, DWORD PTR $T6[ebp+4]
	mov	DWORD PTR [esi+6524], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T5[ebp], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 557  :         SetNextWindowSizeVal = ImVec2(0.0f, 0.0f);

	mov	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR [esi+6528], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T5[ebp+4], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 557  :         SetNextWindowSizeVal = ImVec2(0.0f, 0.0f);

	mov	eax, DWORD PTR $T5[ebp+4]
	mov	DWORD PTR [esi+6532], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T4[ebp], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 573  :         DragLastMouseDelta = ImVec2(0.0f, 0.0f);

	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR [esi+10520], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T4[ebp+4], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 573  :         DragLastMouseDelta = ImVec2(0.0f, 0.0f);

	mov	eax, DWORD PTR $T4[ebp+4]
	mov	DWORD PTR [esi+10524], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T3[ebp], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 577  :         ScrollbarClickDeltaToGrabCenter = ImVec2(0.0f, 0.0f);

	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR [esi+10540], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T3[ebp+4], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 577  :         ScrollbarClickDeltaToGrabCenter = ImVec2(0.0f, 0.0f);

	mov	eax, DWORD PTR $T3[ebp+4]

; 578  :         memset(Tooltip, 0, sizeof(Tooltip));

	push	1024					; 00000400H
	mov	DWORD PTR [esi+10544], eax
	lea	eax, DWORD PTR [esi+10548]
	push	0
	push	eax
	mov	BYTE PTR [esi+6456], 0
	mov	DWORD PTR [esi+6460], 0
	mov	WORD PTR [esi+6480], 0
	mov	DWORD PTR [esi+6484], -1
	mov	DWORD PTR [esi+6488], 0
	mov	DWORD PTR [esi+6500], 0
	mov	DWORD PTR [esi+6496], 0
	mov	DWORD PTR [esi+6492], 0
	mov	BYTE PTR [esi+6544], 0
	mov	DWORD PTR [esi+6548], 0
	mov	DWORD PTR [esi+6552], 0
	mov	DWORD PTR [esi+6556], 0
	mov	DWORD PTR [esi+6560], 0
	movups	XMMWORD PTR [esi+6564], xmm0
	mov	DWORD PTR [esi+6580], 0
	mov	DWORD PTR [esi+6584], 0
	mov	WORD PTR [esi+6588], 0
	mov	BYTE PTR [esi+6590], 0
	mov	DWORD PTR [esi+6592], 0
	mov	DWORD PTR [esi+10500], 0
	mov	DWORD PTR [esi+10516], 0
	mov	DWORD PTR [esi+10528], 1008981770	; 3c23d70aH
	mov	DWORD PTR [esi+10532], 1008981770	; 3c23d70aH
	mov	DWORD PTR [esi+10536], 1092616192	; 41200000H
	call	_memset

; 580  : 
; 581  :         ModalWindowDarkeningRatio = 0.0f;
; 582  :         OverlayDrawList._OwnerName = "##Overlay"; // Give it a name for debugging
; 583  :         MouseCursor = ImGuiMouseCursor_Arrow;
; 584  :         memset(MouseCursorData, 0, sizeof(MouseCursorData));

	push	364					; 0000016cH
	push	0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T2[ebp], -1082130432		; bf800000H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 579  :         OsImePosRequest = OsImePosSet = ImVec2(-1.0f, -1.0f);

	mov	ecx, DWORD PTR $T2[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T2[ebp+4], -1082130432	; bf800000H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 579  :         OsImePosRequest = OsImePosSet = ImVec2(-1.0f, -1.0f);

	mov	eax, DWORD PTR $T2[ebp+4]

; 580  : 
; 581  :         ModalWindowDarkeningRatio = 0.0f;
; 582  :         OverlayDrawList._OwnerName = "##Overlay"; // Give it a name for debugging
; 583  :         MouseCursor = ImGuiMouseCursor_Arrow;
; 584  :         memset(MouseCursorData, 0, sizeof(MouseCursorData));

	push	edi
	mov	DWORD PTR [esi+11592], ecx
	mov	DWORD PTR [esi+11596], eax
	mov	DWORD PTR [esi+11584], ecx
	mov	DWORD PTR [esi+11588], eax
	mov	DWORD PTR [esi+6652], 0
	mov	DWORD PTR [esi+6692], OFFSET ??_C@_09GBFFKCDJ@?$CD?$CDOverlay?$AA@
	mov	DWORD PTR [esi+6764], 0
	call	_memset

; 585  : 
; 586  :         LogEnabled = false;
; 587  :         LogFile = NULL;
; 588  :         LogClipboard = NULL;
; 589  :         LogStartDepth = 0;
; 590  :         LogAutoExpandMaxDepth = 2;
; 591  : 
; 592  :         memset(FramerateSecPerFrame, 0, sizeof(FramerateSecPerFrame));

	push	480					; 000001e0H
	lea	eax, DWORD PTR [esi+11620]
	mov	BYTE PTR [esi+11600], 0
	push	0
	push	eax
	mov	DWORD PTR [esi+11604], 0
	mov	DWORD PTR [esi+11608], 0
	mov	DWORD PTR [esi+11612], 0
	mov	DWORD PTR [esi+11616], 2
	call	_memset

; 593  :         FramerateSecPerFrameIdx = 0;

	mov	DWORD PTR [esi+12100], 0

; 594  :         FramerateSecPerFrameAccum = 0.0f;

	mov	DWORD PTR [esi+12104], 0

; 595  :         CaptureMouseNextFrame = CaptureKeyboardNextFrame = -1;
; 596  :         memset(TempBuffer, 0, sizeof(TempBuffer));

	push	3073					; 00000c01H
	lea	eax, DWORD PTR [esi+12116]
	mov	DWORD PTR [esi+12112], -1
	push	0
	push	eax
	mov	DWORD PTR [esi+12108], -1
	call	_memset

; 597  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	add	esp, 48					; 00000030H
	mov	eax, esi
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ImGuiContext@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 6204				; 0000183cH
	jmp	??1?$ImVector@PAUImGuiWindow@@@@QAE@XZ	; ImVector<ImGuiWindow *>::~ImVector<ImGuiWindow *>
__unwindfunclet$??0ImGuiContext@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 6216				; 00001848H
	jmp	??1?$ImVector@PAUImGuiWindow@@@@QAE@XZ	; ImVector<ImGuiWindow *>::~ImVector<ImGuiWindow *>
__unwindfunclet$??0ImGuiContext@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 6228				; 00001854H
	jmp	??1?$ImVector@PAUImGuiWindow@@@@QAE@XZ	; ImVector<ImGuiWindow *>::~ImVector<ImGuiWindow *>
__unwindfunclet$??0ImGuiContext@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 6304				; 000018a0H
	jmp	??1?$ImVector@UImGuiIniData@@@@QAE@XZ	; ImVector<ImGuiIniData>::~ImVector<ImGuiIniData>
__unwindfunclet$??0ImGuiContext@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 6320				; 000018b0H
	jmp	??1?$ImVector@UImGuiColMod@@@@QAE@XZ	; ImVector<ImGuiColMod>::~ImVector<ImGuiColMod>
__unwindfunclet$??0ImGuiContext@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 6332				; 000018bcH
	jmp	??1?$ImVector@UImGuiStyleMod@@@@QAE@XZ	; ImVector<ImGuiStyleMod>::~ImVector<ImGuiStyleMod>
__unwindfunclet$??0ImGuiContext@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 6344				; 000018c8H
	jmp	??1?$ImVector@PAUImFont@@@@QAE@XZ	; ImVector<ImFont *>::~ImVector<ImFont *>
__unwindfunclet$??0ImGuiContext@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 6356				; 000018d4H
	jmp	??1?$ImVector@UImGuiPopupRef@@@@QAE@XZ	; ImVector<ImGuiPopupRef>::~ImVector<ImGuiPopupRef>
__unwindfunclet$??0ImGuiContext@@QAE@XZ$8:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 6368				; 000018e0H
	jmp	??1?$ImVector@UImGuiPopupRef@@@@QAE@XZ	; ImVector<ImGuiPopupRef>::~ImVector<ImGuiPopupRef>
__unwindfunclet$??0ImGuiContext@@QAE@XZ$9:
	push	OFFSET ??1?$ImVector@PAUImDrawList@@@@QAE@XZ ; ImVector<ImDrawList *>::~ImVector<ImDrawList *>
	push	3
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 6616				; 000019d8H
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	ret	0
__unwindfunclet$??0ImGuiContext@@QAE@XZ$10:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 6656				; 00001a00H
	jmp	??1ImDrawList@@QAE@XZ			; ImDrawList::~ImDrawList
__unwindfunclet$??0ImGuiContext@@QAE@XZ$11:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 7132				; 00001bdcH
	jmp	??1ImGuiTextEditState@@QAE@XZ
__ehhandler$??0ImGuiContext@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0ImGuiContext@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0ImGuiContext@@QAE@XZ ENDP				; ImGuiContext::ImGuiContext
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@PAUImDrawList@@@@QAEXABQAUImDrawList@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?push_back@?$ImVector@PAUImDrawList@@@@QAEXABQAUImDrawList@@@Z PROC ; ImVector<ImDrawList *>::push_back, COMDAT
; _this$ = ecx

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jne	SHORT $LN8@push_back
	inc	edi

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, edi
	cmovg	edi, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	edi, ecx
	jle	SHORT $LN8@push_back

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN10@push_back

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@push_back:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN8@push_back:

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR _v$[ebp]
	pop	edi
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+edx*4], eax
	inc	DWORD PTR [esi]
	pop	esi
	pop	ebp
	ret	4
?push_back@?$ImVector@PAUImDrawList@@@@QAEXABQAUImDrawList@@@Z ENDP ; ImVector<ImDrawList *>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@PAUImDrawList@@@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@PAUImDrawList@@@@QAEXH@Z PROC	; ImVector<ImDrawList *>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@PAUImDrawList@@@@QAEXH@Z ENDP	; ImVector<ImDrawList *>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@PAUImDrawList@@@@QAEXH@Z
_TEXT	SEGMENT
_new_data$1$ = 8					; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@PAUImDrawList@@@@QAEXH@Z PROC	; ImVector<ImDrawList *>::resize, COMDAT
; _this$ = ecx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR _new_size$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jle	SHORT $LN12@resize

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@resize
$LN6@resize:
	mov	eax, 8
$LN7@resize:
	push	ebx
	cmp	eax, edi
	mov	ebx, edi
	cmovg	ebx, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	ebx, ecx
	jle	SHORT $LN13@resize

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [ebx*4]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [esi+8]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN10@resize

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@resize:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], ebx
$LN13@resize:
	pop	ebx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
$LN12@resize:
	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?resize@?$ImVector@PAUImDrawList@@@@QAEXH@Z ENDP	; ImVector<ImDrawList *>::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@PAUImDrawList@@@@QAEHH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?_grow_capacity@?$ImVector@PAUImDrawList@@@@QAEHH@Z PROC ; ImVector<ImDrawList *>::_grow_capacity, COMDAT
; _this$ = ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@grow_capac
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _new_size$[ebp]
	sar	ecx, 1
	add	ecx, esi
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
$LN3@grow_capac:
	mov	eax, DWORD PTR _new_size$[ebp]
	mov	ecx, 8
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
?_grow_capacity@?$ImVector@PAUImDrawList@@@@QAEHH@Z ENDP ; ImVector<ImDrawList *>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@PAUImDrawList@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$ImVector@PAUImDrawList@@@@QAEXXZ PROC		; ImVector<ImDrawList *>::clear, COMDAT
; _this$ = ecx

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	npad	2
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN2@clear
	push	eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+8], 0
$LN2@clear:
	pop	esi
	ret	0
?clear@?$ImVector@PAUImDrawList@@@@QAEXXZ ENDP		; ImVector<ImDrawList *>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@PAUImDrawList@@@@QAEAAPAUImDrawList@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@PAUImDrawList@@@@QAEAAPAUImDrawList@@H@Z PROC ; ImVector<ImDrawList *>::operator[], COMDAT
; _this$ = ecx

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	pop	ebp
	ret	4
??A?$ImVector@PAUImDrawList@@@@QAEAAPAUImDrawList@@H@Z ENDP ; ImVector<ImDrawList *>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?empty@?$ImVector@PAUImDrawList@@@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$ImVector@PAUImDrawList@@@@QBE_NXZ PROC		; ImVector<ImDrawList *>::empty, COMDAT
; _this$ = ecx

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	cmp	DWORD PTR [ecx], 0
	sete	al
	ret	0
?empty@?$ImVector@PAUImDrawList@@@@QBE_NXZ ENDP		; ImVector<ImDrawList *>::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@PAUImDrawList@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@PAUImDrawList@@@@QAE@XZ PROC		; ImVector<ImDrawList *>::~ImVector<ImDrawList *>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@PAUImDrawList@@@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@PAUImDrawList@@@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@PAUImDrawList@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@PAUImDrawList@@@@QAE@XZ ENDP		; ImVector<ImDrawList *>::~ImVector<ImDrawList *>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@PAUImDrawList@@@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@PAUImDrawList@@@@QAE@XZ PROC		; ImVector<ImDrawList *>::ImVector<ImDrawList *>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@PAUImDrawList@@@@QAE@XZ ENDP		; ImVector<ImDrawList *>::ImVector<ImDrawList *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@UImGuiPopupRef@@@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$ImVector@UImGuiPopupRef@@@@QAEXXZ PROC	; ImVector<ImGuiPopupRef>::pop_back, COMDAT
; _this$ = ecx

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [ecx]
	ret	0
?pop_back@?$ImVector@UImGuiPopupRef@@@@QAEXXZ ENDP	; ImVector<ImGuiPopupRef>::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImGuiPopupRef@@@@QAEXABUImGuiPopupRef@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?push_back@?$ImVector@UImGuiPopupRef@@@@QAEXABUImGuiPopupRef@@@Z PROC ; ImVector<ImGuiPopupRef>::push_back, COMDAT
; _this$ = ecx

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jne	SHORT $LN8@push_back
	inc	edi

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, edi
	cmovg	edi, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	edi, ecx
	jle	SHORT $LN8@push_back

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	mov	eax, edi
	shl	eax, 5
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN10@push_back

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 5
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@push_back:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN8@push_back:

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR _v$[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR [esi+8]
	pop	edi
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movups	xmm0, XMMWORD PTR [eax+16]
	movups	XMMWORD PTR [ecx+16], xmm0
	inc	DWORD PTR [esi]
	pop	esi
	pop	ebp
	ret	4
?push_back@?$ImVector@UImGuiPopupRef@@@@QAEXABUImGuiPopupRef@@@Z ENDP ; ImVector<ImGuiPopupRef>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiPopupRef@@@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UImGuiPopupRef@@@@QAEXH@Z PROC	; ImVector<ImGuiPopupRef>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	mov	eax, edi
	shl	eax, 5
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 5
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@UImGuiPopupRef@@@@QAEXH@Z ENDP	; ImVector<ImGuiPopupRef>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImGuiPopupRef@@@@QAEXH@Z
_TEXT	SEGMENT
_new_data$1$ = 8					; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@UImGuiPopupRef@@@@QAEXH@Z PROC	; ImVector<ImGuiPopupRef>::resize, COMDAT
; _this$ = ecx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR _new_size$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jle	SHORT $LN12@resize

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@resize
$LN6@resize:
	mov	eax, 8
$LN7@resize:
	push	ebx
	cmp	eax, edi
	mov	ebx, edi
	cmovg	ebx, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	ebx, ecx
	jle	SHORT $LN13@resize

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	mov	eax, ebx
	shl	eax, 5
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [esi+8]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN10@resize

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 5
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@resize:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], ebx
$LN13@resize:
	pop	ebx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
$LN12@resize:
	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?resize@?$ImVector@UImGuiPopupRef@@@@QAEXH@Z ENDP	; ImVector<ImGuiPopupRef>::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiPopupRef@@@@QAEHH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?_grow_capacity@?$ImVector@UImGuiPopupRef@@@@QAEHH@Z PROC ; ImVector<ImGuiPopupRef>::_grow_capacity, COMDAT
; _this$ = ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@grow_capac
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _new_size$[ebp]
	sar	ecx, 1
	add	ecx, esi
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
$LN3@grow_capac:
	mov	eax, DWORD PTR _new_size$[ebp]
	mov	ecx, 8
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
?_grow_capacity@?$ImVector@UImGuiPopupRef@@@@QAEHH@Z ENDP ; ImVector<ImGuiPopupRef>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImGuiPopupRef@@@@QAEAAUImGuiPopupRef@@XZ
_TEXT	SEGMENT
?back@?$ImVector@UImGuiPopupRef@@@@QAEAAUImGuiPopupRef@@XZ PROC ; ImVector<ImGuiPopupRef>::back, COMDAT
; _this$ = ecx

; 922  :     inline value_type&          back()                          { IM_ASSERT(Size > 0); return Data[Size-1]; }

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+8]
	shl	edx, 5
	add	eax, -32				; ffffffe0H
	add	eax, edx
	ret	0
?back@?$ImVector@UImGuiPopupRef@@@@QAEAAUImGuiPopupRef@@XZ ENDP ; ImVector<ImGuiPopupRef>::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImGuiPopupRef@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$ImVector@UImGuiPopupRef@@@@QAEXXZ PROC		; ImVector<ImGuiPopupRef>::clear, COMDAT
; _this$ = ecx

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	npad	2
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN2@clear
	push	eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+8], 0
$LN2@clear:
	pop	esi
	ret	0
?clear@?$ImVector@UImGuiPopupRef@@@@QAEXXZ ENDP		; ImVector<ImGuiPopupRef>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImGuiPopupRef@@@@QAEAAUImGuiPopupRef@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@UImGuiPopupRef@@@@QAEAAUImGuiPopupRef@@H@Z PROC ; ImVector<ImGuiPopupRef>::operator[], COMDAT
; _this$ = ecx

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR [ecx+8]
	pop	ebp
	ret	4
??A?$ImVector@UImGuiPopupRef@@@@QAEAAUImGuiPopupRef@@H@Z ENDP ; ImVector<ImGuiPopupRef>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?empty@?$ImVector@UImGuiPopupRef@@@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$ImVector@UImGuiPopupRef@@@@QBE_NXZ PROC	; ImVector<ImGuiPopupRef>::empty, COMDAT
; _this$ = ecx

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	cmp	DWORD PTR [ecx], 0
	sete	al
	ret	0
?empty@?$ImVector@UImGuiPopupRef@@@@QBE_NXZ ENDP	; ImVector<ImGuiPopupRef>::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImGuiPopupRef@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@UImGuiPopupRef@@@@QAE@XZ PROC		; ImVector<ImGuiPopupRef>::~ImVector<ImGuiPopupRef>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@UImGuiPopupRef@@@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@UImGuiPopupRef@@@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@UImGuiPopupRef@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@UImGuiPopupRef@@@@QAE@XZ ENDP		; ImVector<ImGuiPopupRef>::~ImVector<ImGuiPopupRef>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImGuiPopupRef@@@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@UImGuiPopupRef@@@@QAE@XZ PROC		; ImVector<ImGuiPopupRef>::ImVector<ImGuiPopupRef>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@UImGuiPopupRef@@@@QAE@XZ ENDP		; ImVector<ImGuiPopupRef>::ImVector<ImGuiPopupRef>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@UImGuiStyleMod@@@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$ImVector@UImGuiStyleMod@@@@QAEXXZ PROC	; ImVector<ImGuiStyleMod>::pop_back, COMDAT
; _this$ = ecx

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [ecx]
	ret	0
?pop_back@?$ImVector@UImGuiStyleMod@@@@QAEXXZ ENDP	; ImVector<ImGuiStyleMod>::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImGuiStyleMod@@@@QAEXABUImGuiStyleMod@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?push_back@?$ImVector@UImGuiStyleMod@@@@QAEXABUImGuiStyleMod@@@Z PROC ; ImVector<ImGuiStyleMod>::push_back, COMDAT
; _this$ = ecx

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jne	SHORT $LN8@push_back
	inc	edi

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, edi
	cmovg	edi, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	edi, ecx
	jle	SHORT $LN8@push_back

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi+edi*2]
	shl	eax, 2
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN10@push_back

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	shl	ecx, 2
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@push_back:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN8@push_back:

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	eax, DWORD PTR [esi]
	pop	edi
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _v$[ebp]
	movq	xmm0, QWORD PTR [eax]
	movq	QWORD PTR [ecx], xmm0
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	inc	DWORD PTR [esi]
	pop	esi
	pop	ebp
	ret	4
?push_back@?$ImVector@UImGuiStyleMod@@@@QAEXABUImGuiStyleMod@@@Z ENDP ; ImVector<ImGuiStyleMod>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiStyleMod@@@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UImGuiStyleMod@@@@QAEXH@Z PROC	; ImVector<ImGuiStyleMod>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi+edi*2]
	shl	eax, 2
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	shl	ecx, 2
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@UImGuiStyleMod@@@@QAEXH@Z ENDP	; ImVector<ImGuiStyleMod>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiStyleMod@@@@QAEHH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?_grow_capacity@?$ImVector@UImGuiStyleMod@@@@QAEHH@Z PROC ; ImVector<ImGuiStyleMod>::_grow_capacity, COMDAT
; _this$ = ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@grow_capac
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _new_size$[ebp]
	sar	ecx, 1
	add	ecx, esi
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
$LN3@grow_capac:
	mov	eax, DWORD PTR _new_size$[ebp]
	mov	ecx, 8
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
?_grow_capacity@?$ImVector@UImGuiStyleMod@@@@QAEHH@Z ENDP ; ImVector<ImGuiStyleMod>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImGuiStyleMod@@@@QAEAAUImGuiStyleMod@@XZ
_TEXT	SEGMENT
?back@?$ImVector@UImGuiStyleMod@@@@QAEAAUImGuiStyleMod@@XZ PROC ; ImVector<ImGuiStyleMod>::back, COMDAT
; _this$ = ecx

; 922  :     inline value_type&          back()                          { IM_ASSERT(Size > 0); return Data[Size-1]; }

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [eax+edx*4]
	add	eax, -12				; fffffff4H
	ret	0
?back@?$ImVector@UImGuiStyleMod@@@@QAEAAUImGuiStyleMod@@XZ ENDP ; ImVector<ImGuiStyleMod>::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImGuiStyleMod@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$ImVector@UImGuiStyleMod@@@@QAEXXZ PROC		; ImVector<ImGuiStyleMod>::clear, COMDAT
; _this$ = ecx

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	npad	2
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN2@clear
	push	eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+8], 0
$LN2@clear:
	pop	esi
	ret	0
?clear@?$ImVector@UImGuiStyleMod@@@@QAEXXZ ENDP		; ImVector<ImGuiStyleMod>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImGuiStyleMod@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@UImGuiStyleMod@@@@QAE@XZ PROC		; ImVector<ImGuiStyleMod>::~ImVector<ImGuiStyleMod>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@UImGuiStyleMod@@@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@UImGuiStyleMod@@@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@UImGuiStyleMod@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@UImGuiStyleMod@@@@QAE@XZ ENDP		; ImVector<ImGuiStyleMod>::~ImVector<ImGuiStyleMod>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImGuiStyleMod@@@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@UImGuiStyleMod@@@@QAE@XZ PROC		; ImVector<ImGuiStyleMod>::ImVector<ImGuiStyleMod>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@UImGuiStyleMod@@@@QAE@XZ ENDP		; ImVector<ImGuiStyleMod>::ImVector<ImGuiStyleMod>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@UImGuiColMod@@@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$ImVector@UImGuiColMod@@@@QAEXXZ PROC	; ImVector<ImGuiColMod>::pop_back, COMDAT
; _this$ = ecx

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [ecx]
	ret	0
?pop_back@?$ImVector@UImGuiColMod@@@@QAEXXZ ENDP	; ImVector<ImGuiColMod>::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImGuiColMod@@@@QAEXABUImGuiColMod@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?push_back@?$ImVector@UImGuiColMod@@@@QAEXABUImGuiColMod@@@Z PROC ; ImVector<ImGuiColMod>::push_back, COMDAT
; _this$ = ecx

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jne	SHORT $LN8@push_back
	inc	edi

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, edi
	cmovg	edi, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	edi, ecx
	jle	SHORT $LN8@push_back

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi+edi*4]
	shl	eax, 2
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN10@push_back

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	shl	ecx, 2
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@push_back:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN8@push_back:

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	eax, DWORD PTR [esi]
	pop	edi
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _v$[ebp]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	inc	DWORD PTR [esi]
	pop	esi
	pop	ebp
	ret	4
?push_back@?$ImVector@UImGuiColMod@@@@QAEXABUImGuiColMod@@@Z ENDP ; ImVector<ImGuiColMod>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiColMod@@@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UImGuiColMod@@@@QAEXH@Z PROC	; ImVector<ImGuiColMod>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi+edi*4]
	shl	eax, 2
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	shl	ecx, 2
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@UImGuiColMod@@@@QAEXH@Z ENDP	; ImVector<ImGuiColMod>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiColMod@@@@QAEHH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?_grow_capacity@?$ImVector@UImGuiColMod@@@@QAEHH@Z PROC	; ImVector<ImGuiColMod>::_grow_capacity, COMDAT
; _this$ = ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@grow_capac
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _new_size$[ebp]
	sar	ecx, 1
	add	ecx, esi
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
$LN3@grow_capac:
	mov	eax, DWORD PTR _new_size$[ebp]
	mov	ecx, 8
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
?_grow_capacity@?$ImVector@UImGuiColMod@@@@QAEHH@Z ENDP	; ImVector<ImGuiColMod>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImGuiColMod@@@@QAEAAUImGuiColMod@@XZ
_TEXT	SEGMENT
?back@?$ImVector@UImGuiColMod@@@@QAEAAUImGuiColMod@@XZ PROC ; ImVector<ImGuiColMod>::back, COMDAT
; _this$ = ecx

; 922  :     inline value_type&          back()                          { IM_ASSERT(Size > 0); return Data[Size-1]; }

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [eax+edx*4]
	add	eax, -20				; ffffffecH
	ret	0
?back@?$ImVector@UImGuiColMod@@@@QAEAAUImGuiColMod@@XZ ENDP ; ImVector<ImGuiColMod>::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImGuiColMod@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$ImVector@UImGuiColMod@@@@QAEXXZ PROC		; ImVector<ImGuiColMod>::clear, COMDAT
; _this$ = ecx

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	npad	2
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN2@clear
	push	eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+8], 0
$LN2@clear:
	pop	esi
	ret	0
?clear@?$ImVector@UImGuiColMod@@@@QAEXXZ ENDP		; ImVector<ImGuiColMod>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImGuiColMod@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@UImGuiColMod@@@@QAE@XZ PROC		; ImVector<ImGuiColMod>::~ImVector<ImGuiColMod>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@UImGuiColMod@@@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@UImGuiColMod@@@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@UImGuiColMod@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@UImGuiColMod@@@@QAE@XZ ENDP		; ImVector<ImGuiColMod>::~ImVector<ImGuiColMod>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImGuiColMod@@@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@UImGuiColMod@@@@QAE@XZ PROC		; ImVector<ImGuiColMod>::ImVector<ImGuiColMod>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@UImGuiColMod@@@@QAE@XZ ENDP		; ImVector<ImGuiColMod>::ImVector<ImGuiColMod>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImGuiIniData@@@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UImGuiIniData@@@@QAEXH@Z PROC	; ImVector<ImGuiIniData>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*8]
	sub	eax, edi
	shl	eax, 2
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	shl	edx, 2
	push	edx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@UImGuiIniData@@@@QAEXH@Z ENDP	; ImVector<ImGuiIniData>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImGuiIniData@@@@QAEXH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?resize@?$ImVector@UImGuiIniData@@@@QAEXH@Z PROC	; ImVector<ImGuiIniData>::resize, COMDAT
; _this$ = ecx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	esi, DWORD PTR _new_size$[ebp]
	push	edi
	mov	edi, ecx
	mov	ebx, DWORD PTR [edi+4]
	cmp	esi, ebx
	jle	SHORT $LN8@resize

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ebx, ebx
	je	SHORT $LN6@resize
	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	ecx, eax
	sar	ecx, 1
	add	ecx, ebx
	jmp	SHORT $LN7@resize
$LN6@resize:
	mov	ecx, 8
$LN7@resize:
	cmp	ecx, esi
	mov	eax, esi
	cmovg	eax, ecx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	ecx, edi
	push	eax
	call	?reserve@?$ImVector@UImGuiIniData@@@@QAEXH@Z ; ImVector<ImGuiIniData>::reserve
$LN8@resize:
	mov	DWORD PTR [edi], esi
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	4
?resize@?$ImVector@UImGuiIniData@@@@QAEXH@Z ENDP	; ImVector<ImGuiIniData>::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImGuiIniData@@@@QAEHH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?_grow_capacity@?$ImVector@UImGuiIniData@@@@QAEHH@Z PROC ; ImVector<ImGuiIniData>::_grow_capacity, COMDAT
; _this$ = ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@grow_capac
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _new_size$[ebp]
	sar	ecx, 1
	add	ecx, esi
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
$LN3@grow_capac:
	mov	eax, DWORD PTR _new_size$[ebp]
	mov	ecx, 8
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
?_grow_capacity@?$ImVector@UImGuiIniData@@@@QAEHH@Z ENDP ; ImVector<ImGuiIniData>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImGuiIniData@@@@QAEAAUImGuiIniData@@XZ
_TEXT	SEGMENT
?back@?$ImVector@UImGuiIniData@@@@QAEAAUImGuiIniData@@XZ PROC ; ImVector<ImGuiIniData>::back, COMDAT
; _this$ = ecx

; 922  :     inline value_type&          back()                          { IM_ASSERT(Size > 0); return Data[Size-1]; }

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [eax+edx*4]
	add	eax, -28				; ffffffe4H
	ret	0
?back@?$ImVector@UImGuiIniData@@@@QAEAAUImGuiIniData@@XZ ENDP ; ImVector<ImGuiIniData>::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UImGuiIniData@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$ImVector@UImGuiIniData@@@@QAEXXZ PROC		; ImVector<ImGuiIniData>::clear, COMDAT
; _this$ = ecx

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	npad	2
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN2@clear
	push	eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+8], 0
$LN2@clear:
	pop	esi
	ret	0
?clear@?$ImVector@UImGuiIniData@@@@QAEXXZ ENDP		; ImVector<ImGuiIniData>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImGuiIniData@@@@QAEAAUImGuiIniData@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@UImGuiIniData@@@@QAEAAUImGuiIniData@@H@Z PROC ; ImVector<ImGuiIniData>::operator[], COMDAT
; _this$ = ecx

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [eax+edx*4]
	pop	ebp
	ret	4
??A?$ImVector@UImGuiIniData@@@@QAEAAUImGuiIniData@@H@Z ENDP ; ImVector<ImGuiIniData>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImGuiIniData@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@UImGuiIniData@@@@QAE@XZ PROC		; ImVector<ImGuiIniData>::~ImVector<ImGuiIniData>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@UImGuiIniData@@@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@UImGuiIniData@@@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@UImGuiIniData@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@UImGuiIniData@@@@QAE@XZ ENDP		; ImVector<ImGuiIniData>::~ImVector<ImGuiIniData>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImGuiIniData@@@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@UImGuiIniData@@@@QAE@XZ PROC		; ImVector<ImGuiIniData>::ImVector<ImGuiIniData>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@UImGuiIniData@@@@QAE@XZ ENDP		; ImVector<ImGuiIniData>::ImVector<ImGuiIniData>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?insert@?$ImVector@PAUImGuiWindow@@@@QAEPAPAUImGuiWindow@@PBQAU2@ABQAU2@@Z
_TEXT	SEGMENT
_new_data$1$ = 8					; size = 4
_it$ = 8						; size = 4
_v$ = 12						; size = 4
?insert@?$ImVector@PAUImGuiWindow@@@@QAEPAPAUImGuiWindow@@PBQAU2@ABQAU2@@Z PROC ; ImVector<ImGuiWindow *>::insert, COMDAT
; _this$ = ecx

; 944  :     inline iterator             insert(const_iterator it, const value_type& v)  { IM_ASSERT(it >= Data && it <= Data+Size); const ptrdiff_t off = it - Data; if (Size == Capacity) reserve(Capacity ? Capacity * 2 : 4); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(value_type)); Data[off] = v; Size++; return Data + off; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR _it$[ebp]
	sub	edi, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [esi+4]
	sar	edi, 2
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN7@insert
	push	ebx
	lea	ebx, DWORD PTR [eax+eax]
	test	eax, eax
	jne	SHORT $LN6@insert
	mov	ebx, 4
$LN6@insert:

; 931  :         if (new_capacity <= Capacity) return;

	cmp	ebx, eax
	jle	SHORT $LN11@insert

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [ebx*4]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [esi+8]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN9@insert

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN9@insert:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], ebx
$LN11@insert:
	pop	ebx
$LN7@insert:

; 944  :     inline iterator             insert(const_iterator it, const value_type& v)  { IM_ASSERT(it >= Data && it <= Data+Size); const ptrdiff_t off = it - Data; if (Size == Capacity) reserve(Capacity ? Capacity * 2 : 4); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(value_type)); Data[off] = v; Size++; return Data + off; }

	mov	ecx, DWORD PTR [esi]
	cmp	edi, ecx
	jge	SHORT $LN3@insert
	mov	eax, DWORD PTR [esi+8]
	sub	ecx, edi
	shl	ecx, 2
	push	ecx
	lea	eax, DWORD PTR [eax+edi*4]
	push	eax
	add	eax, 4
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
$LN3@insert:
	mov	ecx, DWORD PTR [esi+8]
	lea	edx, DWORD PTR [edi*4]
	mov	eax, DWORD PTR _v$[ebp]
	pop	edi
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx+ecx], eax
	mov	eax, DWORD PTR [esi+8]
	inc	DWORD PTR [esi]
	add	eax, edx
	pop	esi
	pop	ebp
	ret	8
?insert@?$ImVector@PAUImGuiWindow@@@@QAEPAPAUImGuiWindow@@PBQAU2@ABQAU2@@Z ENDP ; ImVector<ImGuiWindow *>::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?erase@?$ImVector@PAUImGuiWindow@@@@QAEPAPAUImGuiWindow@@PBQAU2@@Z
_TEXT	SEGMENT
_it$ = 8						; size = 4
?erase@?$ImVector@PAUImGuiWindow@@@@QAEPAPAUImGuiWindow@@PBQAU2@@Z PROC ; ImVector<ImGuiWindow *>::erase, COMDAT
; _this$ = ecx

; 943  :     inline iterator             erase(const_iterator it)        { IM_ASSERT(it >= Data && it < Data+Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(value_type)); Size--; return Data + off; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _it$[ebp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	eax, DWORD PTR [edi+8]
	sub	edx, eax
	sar	edx, 2
	lea	esi, DWORD PTR [edx*4]
	lea	ecx, DWORD PTR [esi+eax]
	mov	eax, DWORD PTR [edi]
	sub	eax, edx
	lea	eax, DWORD PTR [eax*4-4]
	push	eax
	lea	eax, DWORD PTR [ecx+4]
	push	eax
	push	ecx
	call	DWORD PTR __imp__memmove
	dec	DWORD PTR [edi]
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR [edi+8]
	add	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?erase@?$ImVector@PAUImGuiWindow@@@@QAEPAPAUImGuiWindow@@PBQAU2@@Z ENDP ; ImVector<ImGuiWindow *>::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@PAUImGuiWindow@@@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$ImVector@PAUImGuiWindow@@@@QAEXXZ PROC	; ImVector<ImGuiWindow *>::pop_back, COMDAT
; _this$ = ecx

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [ecx]
	ret	0
?pop_back@?$ImVector@PAUImGuiWindow@@@@QAEXXZ ENDP	; ImVector<ImGuiWindow *>::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@PAUImGuiWindow@@@@QAEXABQAUImGuiWindow@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?push_back@?$ImVector@PAUImGuiWindow@@@@QAEXABQAUImGuiWindow@@@Z PROC ; ImVector<ImGuiWindow *>::push_back, COMDAT
; _this$ = ecx

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jne	SHORT $LN8@push_back
	inc	edi

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, edi
	cmovg	edi, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	edi, ecx
	jle	SHORT $LN8@push_back

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN10@push_back

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@push_back:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN8@push_back:

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR _v$[ebp]
	pop	edi
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+edx*4], eax
	inc	DWORD PTR [esi]
	pop	esi
	pop	ebp
	ret	4
?push_back@?$ImVector@PAUImGuiWindow@@@@QAEXABQAUImGuiWindow@@@Z ENDP ; ImVector<ImGuiWindow *>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@PAUImGuiWindow@@@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@PAUImGuiWindow@@@@QAEXH@Z PROC	; ImVector<ImGuiWindow *>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@PAUImGuiWindow@@@@QAEXH@Z ENDP	; ImVector<ImGuiWindow *>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@PAUImGuiWindow@@@@QAEXH@Z
_TEXT	SEGMENT
_new_data$1$ = 8					; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@PAUImGuiWindow@@@@QAEXH@Z PROC	; ImVector<ImGuiWindow *>::resize, COMDAT
; _this$ = ecx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR _new_size$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jle	SHORT $LN12@resize

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@resize
$LN6@resize:
	mov	eax, 8
$LN7@resize:
	push	ebx
	cmp	eax, edi
	mov	ebx, edi
	cmovg	ebx, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	ebx, ecx
	jle	SHORT $LN13@resize

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [ebx*4]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [esi+8]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN10@resize

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@resize:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], ebx
$LN13@resize:
	pop	ebx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
$LN12@resize:
	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?resize@?$ImVector@PAUImGuiWindow@@@@QAEXH@Z ENDP	; ImVector<ImGuiWindow *>::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@PAUImGuiWindow@@@@QAEHH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?_grow_capacity@?$ImVector@PAUImGuiWindow@@@@QAEHH@Z PROC ; ImVector<ImGuiWindow *>::_grow_capacity, COMDAT
; _this$ = ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@grow_capac
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _new_size$[ebp]
	sar	ecx, 1
	add	ecx, esi
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
$LN3@grow_capac:
	mov	eax, DWORD PTR _new_size$[ebp]
	mov	ecx, 8
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
?_grow_capacity@?$ImVector@PAUImGuiWindow@@@@QAEHH@Z ENDP ; ImVector<ImGuiWindow *>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?swap@?$ImVector@PAUImGuiWindow@@@@QAEXAAV1@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
?swap@?$ImVector@PAUImGuiWindow@@@@QAEXAAV1@@Z PROC	; ImVector<ImGuiWindow *>::swap, COMDAT
; _this$ = ecx

; 924  :     inline void                 swap(ImVector<T>& rhs)          { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; value_type* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _rhs$[ebp]
	push	edi
	mov	edi, ecx
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [edi], edx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [edi+4], edx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [edi+8], ecx
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?swap@?$ImVector@PAUImGuiWindow@@@@QAEXAAV1@@Z ENDP	; ImVector<ImGuiWindow *>::swap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?back@?$ImVector@PAUImGuiWindow@@@@QAEAAPAUImGuiWindow@@XZ
_TEXT	SEGMENT
?back@?$ImVector@PAUImGuiWindow@@@@QAEAAPAUImGuiWindow@@XZ PROC ; ImVector<ImGuiWindow *>::back, COMDAT
; _this$ = ecx

; 922  :     inline value_type&          back()                          { IM_ASSERT(Size > 0); return Data[Size-1]; }

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [eax+edx*4]
	add	eax, -4					; fffffffcH
	ret	0
?back@?$ImVector@PAUImGuiWindow@@@@QAEAAPAUImGuiWindow@@XZ ENDP ; ImVector<ImGuiWindow *>::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?begin@?$ImVector@PAUImGuiWindow@@@@QAEPAPAUImGuiWindow@@XZ
_TEXT	SEGMENT
?begin@?$ImVector@PAUImGuiWindow@@@@QAEPAPAUImGuiWindow@@XZ PROC ; ImVector<ImGuiWindow *>::begin, COMDAT
; _this$ = ecx

; 916  :     inline iterator             begin()                         { return Data; }

	mov	eax, DWORD PTR [ecx+8]
	ret	0
?begin@?$ImVector@PAUImGuiWindow@@@@QAEPAPAUImGuiWindow@@XZ ENDP ; ImVector<ImGuiWindow *>::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@PAUImGuiWindow@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$ImVector@PAUImGuiWindow@@@@QAEXXZ PROC		; ImVector<ImGuiWindow *>::clear, COMDAT
; _this$ = ecx

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	npad	2
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN2@clear
	push	eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+8], 0
$LN2@clear:
	pop	esi
	ret	0
?clear@?$ImVector@PAUImGuiWindow@@@@QAEXXZ ENDP		; ImVector<ImGuiWindow *>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@PAUImGuiWindow@@@@QAEAAPAUImGuiWindow@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@PAUImGuiWindow@@@@QAEAAPAUImGuiWindow@@H@Z PROC ; ImVector<ImGuiWindow *>::operator[], COMDAT
; _this$ = ecx

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	pop	ebp
	ret	4
??A?$ImVector@PAUImGuiWindow@@@@QAEAAPAUImGuiWindow@@H@Z ENDP ; ImVector<ImGuiWindow *>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?empty@?$ImVector@PAUImGuiWindow@@@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$ImVector@PAUImGuiWindow@@@@QBE_NXZ PROC	; ImVector<ImGuiWindow *>::empty, COMDAT
; _this$ = ecx

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	cmp	DWORD PTR [ecx], 0
	sete	al
	ret	0
?empty@?$ImVector@PAUImGuiWindow@@@@QBE_NXZ ENDP	; ImVector<ImGuiWindow *>::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@PAUImGuiWindow@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@PAUImGuiWindow@@@@QAE@XZ PROC		; ImVector<ImGuiWindow *>::~ImVector<ImGuiWindow *>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@PAUImGuiWindow@@@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@PAUImGuiWindow@@@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@PAUImGuiWindow@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@PAUImGuiWindow@@@@QAE@XZ ENDP		; ImVector<ImGuiWindow *>::~ImVector<ImGuiWindow *>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@PAUImGuiWindow@@@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@PAUImGuiWindow@@@@QAE@XZ PROC		; ImVector<ImGuiWindow *>::ImVector<ImGuiWindow *>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@PAUImGuiWindow@@@@QAE@XZ ENDP		; ImVector<ImGuiWindow *>::ImVector<ImGuiWindow *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ??0ImGuiPopupRef@@QAE@IPAUImGuiWindow@@IABUImVec2@@1@Z
_TEXT	SEGMENT
_id$ = 8						; size = 4
_parent_window$ = 12					; size = 4
_parent_menu_set$ = 16					; size = 4
_popup_pos$ = 20					; size = 4
_mouse_pos$ = 24					; size = 4
??0ImGuiPopupRef@@QAE@IPAUImGuiWindow@@IABUImVec2@@1@Z PROC ; ImGuiPopupRef::ImGuiPopupRef, COMDAT
; _this$ = ecx

; 380  :     ImGuiPopupRef(ImGuiID id, ImGuiWindow* parent_window, ImGuiID parent_menu_set, const ImVec2& popup_pos, const ImVec2& mouse_pos) { PopupId = id; Window = NULL; ParentWindow = parent_window; ParentMenuSet = parent_menu_set; PopupPosOnOpen = popup_pos; MousePosOnOpen = mouse_pos; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _id$[ebp]
	mov	edx, ecx
	mov	ecx, DWORD PTR _popup_pos$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 97   :     ImVec2() { x = y = 0.0f; }

	mov	DWORD PTR [edx+20], 0
	mov	DWORD PTR [edx+16], 0
	mov	DWORD PTR [edx+28], 0
	mov	DWORD PTR [edx+24], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 380  :     ImGuiPopupRef(ImGuiID id, ImGuiWindow* parent_window, ImGuiID parent_menu_set, const ImVec2& popup_pos, const ImVec2& mouse_pos) { PopupId = id; Window = NULL; ParentWindow = parent_window; ParentMenuSet = parent_menu_set; PopupPosOnOpen = popup_pos; MousePosOnOpen = mouse_pos; }

	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR _parent_window$[ebp]
	mov	DWORD PTR [edx+8], eax
	mov	eax, DWORD PTR _parent_menu_set$[ebp]
	mov	DWORD PTR [edx+12], eax
	mov	DWORD PTR [edx+4], 0
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx+16], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _mouse_pos$[ebp]
	mov	DWORD PTR [edx+20], eax
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx+24], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+28], eax
	mov	eax, edx
	pop	ebp
	ret	20					; 00000014H
??0ImGuiPopupRef@@QAE@IPAUImGuiWindow@@IABUImVec2@@1@Z ENDP ; ImGuiPopupRef::ImGuiPopupRef
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0ImGuiMouseCursorData@@QAE@XZ
_TEXT	SEGMENT
??0ImGuiMouseCursorData@@QAE@XZ PROC			; ImGuiMouseCursorData::ImGuiMouseCursorData, COMDAT
; _this$ = ecx

; 97   :     ImVec2() { x = y = 0.0f; }

	mov	DWORD PTR [ecx+8], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+40], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+44], 0
	ret	0
??0ImGuiMouseCursorData@@QAE@XZ ENDP			; ImGuiMouseCursorData::ImGuiMouseCursorData
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??4ImGuiTextEditState@@QAEAAU0@$$QAU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4ImGuiTextEditState@@QAEAAU0@$$QAU0@@Z PROC		; ImGuiTextEditState::operator=, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR ___that$[ebp]
	push	ebx
	mov	ebx, ecx
	mov	ecx, 805				; 00000325H
	push	esi
	mov	eax, DWORD PTR [edx]
	lea	esi, DWORD PTR [edx+56]
	push	edi
	mov	DWORD PTR [ebx], eax
	lea	edi, DWORD PTR [ebx+56]
	movq	xmm0, QWORD PTR [edx+4]
	movq	QWORD PTR [ebx+4], xmm0
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ebx+12], eax
	movq	xmm0, QWORD PTR [edx+16]
	movq	QWORD PTR [ebx+16], xmm0
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ebx+24], eax
	movq	xmm0, QWORD PTR [edx+28]
	movq	QWORD PTR [ebx+28], xmm0
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ebx+36], eax
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ebx+40], eax
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [ebx+44], eax
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR [ebx+48], eax
	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR [ebx+52], eax
	rep movsd
	mov	eax, DWORD PTR [edx+3276]
	mov	DWORD PTR [ebx+3276], eax
	movzx	eax, BYTE PTR [edx+3280]
	mov	BYTE PTR [ebx+3280], al
	movzx	eax, BYTE PTR [edx+3281]
	pop	edi
	mov	BYTE PTR [ebx+3281], al
	mov	eax, ebx
	pop	esi
	pop	ebx
	pop	ebp
	ret	4
??4ImGuiTextEditState@@QAEAAU0@$$QAU0@@Z ENDP		; ImGuiTextEditState::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??4ImGuiTextEditState@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4ImGuiTextEditState@@QAEAAU0@ABU0@@Z PROC		; ImGuiTextEditState::operator=, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___that$[ebp]
	mov	eax, ecx
	push	edi
	mov	ecx, 821				; 00000335H
	mov	edi, eax
	rep movsd
	pop	edi
	pop	esi
	pop	ebp
	ret	4
??4ImGuiTextEditState@@QAEAAU0@ABU0@@Z ENDP		; ImGuiTextEditState::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1ImGuiTextEditState@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1ImGuiTextEditState@@QAE@XZ PROC			; ImGuiTextEditState::~ImGuiTextEditState, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1ImGuiTextEditState@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN4@ImGuiTextE
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN4@ImGuiTextE:
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	eax, eax
	je	SHORT $LN8@ImGuiTextE
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN8@ImGuiTextE:
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	test	eax, eax
	je	SHORT $LN12@ImGuiTextE
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN12@ImGuiTextE:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1ImGuiTextEditState@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1ImGuiTextEditState@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1ImGuiTextEditState@@QAE@XZ ENDP			; ImGuiTextEditState::~ImGuiTextEditState
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_key$ = 8						; size = 4
?OnKeyPressed@ImGuiTextEditState@@QAEXH@Z PROC		; ImGuiTextEditState::OnKeyPressed
; _this$ = ecx

; 8595 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 8596 :     stb_textedit_key(this, &StbState, key);

	push	DWORD PTR _key$[ebp]
	mov	esi, ecx
	lea	eax, DWORD PTR [esi+56]
	push	eax
	push	esi
	call	?stb_textedit_key@ImGuiStb@@YAXPAUImGuiTextEditState@@PAUSTB_TexteditState@1@H@Z ; ImGuiStb::stb_textedit_key
	add	esp, 12					; 0000000cH

; 8597 :     CursorFollow = true;

	mov	BYTE PTR [esi+3280], 1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 342  :     void                CursorAnimReset()           { CursorAnim = -0.30f; }                                   // After a user-input the cursor stays on for a while without blinking

	mov	DWORD PTR [esi+3276], -1097229926	; be99999aH
	pop	esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8599 : }

	pop	ebp
	ret	4
?OnKeyPressed@ImGuiTextEditState@@QAEXH@Z ENDP		; ImGuiTextEditState::OnKeyPressed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?SelectAll@ImGuiTextEditState@@QAEXXZ
_TEXT	SEGMENT
?SelectAll@ImGuiTextEditState@@QAEXXZ PROC		; ImGuiTextEditState::SelectAll, COMDAT
; _this$ = ecx

; 346  :     void                SelectAll()                 { StbState.select_start = 0; StbState.select_end = CurLenW; StbState.cursor = StbState.select_end; StbState.has_preferred_x = false; }

	mov	eax, DWORD PTR [ecx+44]
	mov	DWORD PTR [ecx+60], 0
	mov	DWORD PTR [ecx+64], eax
	mov	DWORD PTR [ecx+56], eax
	mov	BYTE PTR [ecx+71], 0
	ret	0
?SelectAll@ImGuiTextEditState@@QAEXXZ ENDP		; ImGuiTextEditState::SelectAll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?ClearSelection@ImGuiTextEditState@@QAEXXZ
_TEXT	SEGMENT
?ClearSelection@ImGuiTextEditState@@QAEXXZ PROC		; ImGuiTextEditState::ClearSelection, COMDAT
; _this$ = ecx

; 345  :     void                ClearSelection()            { StbState.select_start = StbState.select_end = StbState.cursor; }

	mov	eax, DWORD PTR [ecx+56]
	mov	DWORD PTR [ecx+64], eax
	mov	DWORD PTR [ecx+60], eax
	ret	0
?ClearSelection@ImGuiTextEditState@@QAEXXZ ENDP		; ImGuiTextEditState::ClearSelection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?HasSelection@ImGuiTextEditState@@QBE_NXZ
_TEXT	SEGMENT
?HasSelection@ImGuiTextEditState@@QBE_NXZ PROC		; ImGuiTextEditState::HasSelection, COMDAT
; _this$ = ecx

; 344  :     bool                HasSelection() const        { return StbState.select_start != StbState.select_end; }

	mov	eax, DWORD PTR [ecx+60]
	cmp	eax, DWORD PTR [ecx+64]
	setne	al
	ret	0
?HasSelection@ImGuiTextEditState@@QBE_NXZ ENDP		; ImGuiTextEditState::HasSelection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?CursorClamp@ImGuiTextEditState@@QAEXXZ
_TEXT	SEGMENT
?CursorClamp@ImGuiTextEditState@@QAEXXZ PROC		; ImGuiTextEditState::CursorClamp, COMDAT
; _this$ = ecx

; 343  :     void                CursorClamp()               { StbState.cursor = ImMin(StbState.cursor, CurLenW); StbState.select_start = ImMin(StbState.select_start, CurLenW); StbState.select_end = ImMin(StbState.select_end, CurLenW); }

	npad	2
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+44]

; 125  : static inline int    ImMin(int lhs, int rhs)                                    { return lhs < rhs ? lhs : rhs; }

	mov	edx, esi
	cmp	DWORD PTR [edi+56], esi
	mov	ecx, esi
	cmovl	edx, DWORD PTR [edi+56]
	cmp	DWORD PTR [edi+60], esi

; 343  :     void                CursorClamp()               { StbState.cursor = ImMin(StbState.cursor, CurLenW); StbState.select_start = ImMin(StbState.select_start, CurLenW); StbState.select_end = ImMin(StbState.select_end, CurLenW); }

	mov	DWORD PTR [edi+56], edx

; 125  : static inline int    ImMin(int lhs, int rhs)                                    { return lhs < rhs ? lhs : rhs; }

	cmovl	ecx, DWORD PTR [edi+60]
	cmp	DWORD PTR [edi+64], esi

; 343  :     void                CursorClamp()               { StbState.cursor = ImMin(StbState.cursor, CurLenW); StbState.select_start = ImMin(StbState.select_start, CurLenW); StbState.select_end = ImMin(StbState.select_end, CurLenW); }

	mov	DWORD PTR [edi+60], ecx

; 125  : static inline int    ImMin(int lhs, int rhs)                                    { return lhs < rhs ? lhs : rhs; }

	cmovl	esi, DWORD PTR [edi+64]

; 343  :     void                CursorClamp()               { StbState.cursor = ImMin(StbState.cursor, CurLenW); StbState.select_start = ImMin(StbState.select_start, CurLenW); StbState.select_end = ImMin(StbState.select_end, CurLenW); }

	mov	DWORD PTR [edi+64], esi
	pop	edi
	pop	esi
	ret	0
?CursorClamp@ImGuiTextEditState@@QAEXXZ ENDP		; ImGuiTextEditState::CursorClamp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?CursorAnimReset@ImGuiTextEditState@@QAEXXZ
_TEXT	SEGMENT
?CursorAnimReset@ImGuiTextEditState@@QAEXXZ PROC	; ImGuiTextEditState::CursorAnimReset, COMDAT
; _this$ = ecx

; 342  :     void                CursorAnimReset()           { CursorAnim = -0.30f; }                                   // After a user-input the cursor stays on for a while without blinking

	mov	DWORD PTR [ecx+3276], -1097229926	; be99999aH
	ret	0
?CursorAnimReset@ImGuiTextEditState@@QAEXXZ ENDP	; ImGuiTextEditState::CursorAnimReset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ??0ImGuiTextEditState@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ImGuiTextEditState@@QAE@XZ PROC			; ImGuiTextEditState::ImGuiTextEditState, COMDAT
; _this$ = ecx

; 341  :     ImGuiTextEditState()                            { memset(this, 0, sizeof(*this)); }

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	3284					; 00000cd4H
	push	0
	push	esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+24], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 341  :     ImGuiTextEditState()                            { memset(this, 0, sizeof(*this)); }

	mov	DWORD PTR _this$[ebp], esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+36], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 341  :     ImGuiTextEditState()                            { memset(this, 0, sizeof(*this)); }

	call	_memset
	add	esp, 12					; 0000000cH
	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??0ImGuiTextEditState@@QAE@XZ ENDP			; ImGuiTextEditState::ImGuiTextEditState
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??4ImGuiSimpleColumns@@QAEAAU0@$$QAU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4ImGuiSimpleColumns@@QAEAAU0@$$QAU0@@Z PROC		; ImGuiSimpleColumns::operator=, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], eax
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+24], eax
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+28], eax
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+32], eax
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+36], eax
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx+40], eax
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [ecx+44], eax
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR [ecx+48], eax
	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR [ecx+52], eax
	mov	eax, DWORD PTR [edx+56]
	mov	DWORD PTR [ecx+56], eax
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR [ecx+60], eax
	mov	eax, DWORD PTR [edx+64]
	mov	DWORD PTR [ecx+64], eax
	mov	eax, DWORD PTR [edx+68]
	mov	DWORD PTR [ecx+68], eax
	mov	eax, DWORD PTR [edx+72]
	mov	DWORD PTR [ecx+72], eax
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR [ecx+76], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??4ImGuiSimpleColumns@@QAEAAU0@$$QAU0@@Z ENDP		; ImGuiSimpleColumns::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??4ImGuiSimpleColumns@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4ImGuiSimpleColumns@@QAEAAU0@ABU0@@Z PROC		; ImGuiSimpleColumns::operator=, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ___that$[ebp]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [ecx], xmm0
	movups	xmm0, XMMWORD PTR [eax+16]
	movups	XMMWORD PTR [ecx+16], xmm0
	movups	xmm0, XMMWORD PTR [eax+32]
	movups	XMMWORD PTR [ecx+32], xmm0
	movups	xmm0, XMMWORD PTR [eax+48]
	movups	XMMWORD PTR [ecx+48], xmm0
	movups	xmm0, XMMWORD PTR [eax+64]
	mov	eax, ecx
	movups	XMMWORD PTR [ecx+64], xmm0
	pop	ebp
	ret	4
??4ImGuiSimpleColumns@@QAEAAU0@ABU0@@Z ENDP		; ImGuiSimpleColumns::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
tv133 = 8						; size = 4
_avail_w$ = 8						; size = 4
?CalcExtraSpace@ImGuiSimpleColumns@@QAEMM@Z PROC	; ImGuiSimpleColumns::CalcExtraSpace
; _this$ = ecx

; 1729 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1730 :     return ImMax(0.0f, avail_w - Width);

	movss	xmm0, DWORD PTR _avail_w$[ebp]
	subss	xmm0, DWORD PTR [ecx+8]
	maxss	xmm0, DWORD PTR __real@00000000
	movss	DWORD PTR tv133[ebp], xmm0
	fld	DWORD PTR tv133[ebp]

; 1731 : }

	pop	ebp
	ret	4
?CalcExtraSpace@ImGuiSimpleColumns@@QAEMM@Z ENDP	; ImGuiSimpleColumns::CalcExtraSpace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
tv353 = 8						; size = 4
_w0$ = 8						; size = 4
_w1$ = 12						; size = 4
_w2$ = 16						; size = 4
?DeclColumns@ImGuiSimpleColumns@@QAEMMMM@Z PROC		; ImGuiSimpleColumns::DeclColumns
; _this$ = ecx

; 1718 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1719 :     NextWidth = 0.0f;

	mov	DWORD PTR [ecx+12], 0
	xorps	xmm2, xmm2
	movss	xmm0, DWORD PTR [ecx+52]
	maxss	xmm0, DWORD PTR _w1$[ebp]
	movss	xmm3, DWORD PTR [ecx+48]
	maxss	xmm3, DWORD PTR _w0$[ebp]

; 1720 :     NextWidths[0] = ImMax(NextWidths[0], w0);
; 1721 :     NextWidths[1] = ImMax(NextWidths[1], w1);

	movss	DWORD PTR [ecx+52], xmm0
	movss	xmm0, DWORD PTR _w2$[ebp]
	maxss	xmm0, DWORD PTR [ecx+56]
	movss	DWORD PTR [ecx+48], xmm3

; 1722 :     NextWidths[2] = ImMax(NextWidths[2], w2);

	movss	DWORD PTR [ecx+56], xmm0

; 1723 :     for (int i = 0; i < 3; i++)
; 1724 :         NextWidth += NextWidths[i] + ((i > 0 && NextWidths[i] > 0.0f) ? Spacing : 0.0f);

	addss	xmm3, DWORD PTR [ecx+12]
	movss	DWORD PTR [ecx+12], xmm3
	movss	xmm0, DWORD PTR [ecx+52]
	comiss	xmm0, xmm2
	jbe	SHORT $LN32@DeclColumn
	movss	xmm1, DWORD PTR [ecx+4]
	jmp	SHORT $LN33@DeclColumn
$LN32@DeclColumn:
	xorps	xmm1, xmm1
$LN33@DeclColumn:
	addss	xmm0, xmm1
	addss	xmm0, xmm3
	movss	DWORD PTR [ecx+12], xmm0
	movss	xmm1, DWORD PTR [ecx+56]
	comiss	xmm1, xmm2
	jbe	SHORT $LN35@DeclColumn
	movss	xmm2, DWORD PTR [ecx+4]
$LN35@DeclColumn:
	addss	xmm1, xmm2
	addss	xmm1, xmm0
	movss	DWORD PTR [ecx+12], xmm1
	movss	xmm0, DWORD PTR [ecx+8]
	maxss	xmm0, xmm1

; 1725 :     return ImMax(Width, NextWidth);

	movss	DWORD PTR tv353[ebp], xmm0
	fld	DWORD PTR tv353[ebp]

; 1726 : }

	pop	ebp
	ret	12					; 0000000cH
?DeclColumns@ImGuiSimpleColumns@@QAEMMMM@Z ENDP		; ImGuiSimpleColumns::DeclColumns
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_count$ = 8						; size = 4
_spacing$ = 12						; size = 4
_clear$ = 16						; size = 1
?Update@ImGuiSimpleColumns@@QAEXHM_N@Z PROC		; ImGuiSimpleColumns::Update
; _this$ = ecx

; 1701 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1702 :     IM_ASSERT(Count <= IM_ARRAYSIZE(Pos));
; 1703 :     Count = count;
; 1704 :     Width = NextWidth = 0.0f;
; 1705 :     Spacing = spacing;
; 1706 :     if (clear) memset(NextWidths, 0, sizeof(NextWidths));

	cmp	BYTE PTR _clear$[ebp], 0
	xorps	xmm1, xmm1
	movss	xmm0, DWORD PTR _spacing$[ebp]
	mov	eax, DWORD PTR _count$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+8], 0
	movss	DWORD PTR [ecx+4], xmm0
	je	SHORT $LN5@Update
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [ecx+48], xmm0
	movups	XMMWORD PTR [ecx+64], xmm0
$LN5@Update:

; 1707 :     for (int i = 0; i < Count; i++)

	push	esi
	xor	esi, esi
	test	eax, eax
	jle	SHORT $LN3@Update
	lea	edx, DWORD PTR [ecx+48]
$LL4@Update:

; 1708 :     {
; 1709 :         if (i > 0 && NextWidths[i] > 0.0f)

	test	esi, esi
	jle	SHORT $LN6@Update
	movss	xmm0, DWORD PTR [edx]
	comiss	xmm0, xmm1
	jbe	SHORT $LN6@Update

; 1710 :             Width += Spacing;

	movss	xmm0, DWORD PTR [ecx+8]
	addss	xmm0, DWORD PTR [ecx+4]
	movss	DWORD PTR [ecx+8], xmm0
$LN6@Update:

; 1711 :         Pos[i] = (float)(int)Width;

	cvttss2si eax, DWORD PTR [ecx+8]
	inc	esi
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [edx-32], xmm0

; 1712 :         Width += NextWidths[i];

	movss	xmm0, DWORD PTR [edx]
	addss	xmm0, DWORD PTR [ecx+8]
	movss	DWORD PTR [ecx+8], xmm0

; 1713 :         NextWidths[i] = 0.0f;

	mov	DWORD PTR [edx], 0
	add	edx, 4
	cmp	esi, DWORD PTR [ecx]
	jl	SHORT $LL4@Update
$LN3@Update:
	pop	esi

; 1714 :     }
; 1715 : }

	pop	ebp
	ret	12					; 0000000cH
?Update@ImGuiSimpleColumns@@QAEXHM_N@Z ENDP		; ImGuiSimpleColumns::Update
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
??0ImGuiSimpleColumns@@QAE@XZ PROC			; ImGuiSimpleColumns::ImGuiSimpleColumns
; _this$ = ecx

; 1693 : {

	npad	2
	push	esi
	mov	esi, ecx
	push	64					; 00000040H
	push	0
	lea	eax, DWORD PTR [esi+16]

; 1694 :     Count = 0;

	mov	DWORD PTR [esi], 0
	push	eax

; 1695 :     Spacing = Width = NextWidth = 0.0f;

	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+4], 0
	call	_memset
	add	esp, 12					; 0000000cH

; 1696 :     memset(Pos, 0, sizeof(Pos));
; 1697 :     memset(NextWidths, 0, sizeof(NextWidths));
; 1698 : }

	mov	eax, esi
	pop	esi
	ret	0
??0ImGuiSimpleColumns@@QAE@XZ ENDP			; ImGuiSimpleColumns::ImGuiSimpleColumns
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ??0ImGuiStyleMod@@QAE@HUImVec2@@@Z
_TEXT	SEGMENT
_idx$ = 8						; size = 4
_v$ = 12						; size = 8
??0ImGuiStyleMod@@QAE@HUImVec2@@@Z PROC			; ImGuiStyleMod::ImGuiStyleMod, COMDAT
; _this$ = ecx

; 288  :     ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v)  { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _idx$[ebp]
	movss	xmm0, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	movss	DWORD PTR [ecx+4], xmm0
	movss	xmm0, DWORD PTR _v$[ebp+4]
	movss	DWORD PTR [ecx+8], xmm0
	pop	ebp
	ret	12					; 0000000cH
??0ImGuiStyleMod@@QAE@HUImVec2@@@Z ENDP			; ImGuiStyleMod::ImGuiStyleMod
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ??0ImGuiStyleMod@@QAE@HM@Z
_TEXT	SEGMENT
_idx$ = 8						; size = 4
_v$ = 12						; size = 4
??0ImGuiStyleMod@@QAE@HM@Z PROC				; ImGuiStyleMod::ImGuiStyleMod, COMDAT
; _this$ = ecx

; 287  :     ImGuiStyleMod(ImGuiStyleVar idx, float v)   { VarIdx = idx; BackupFloat[0] = v; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _idx$[ebp]
	movss	xmm0, DWORD PTR _v$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	movss	DWORD PTR [ecx+4], xmm0
	pop	ebp
	ret	8
??0ImGuiStyleMod@@QAE@HM@Z ENDP				; ImGuiStyleMod::ImGuiStyleMod
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0ImGuiColMod@@QAE@XZ
_TEXT	SEGMENT
??0ImGuiColMod@@QAE@XZ PROC				; ImGuiColMod::ImGuiColMod, COMDAT
; _this$ = ecx

; 108  :     ImVec4() { x = y = z = w = 0.0f; }

	mov	DWORD PTR [ecx+16], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0ImGuiColMod@@QAE@XZ ENDP				; ImGuiColMod::ImGuiColMod
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??4ImRect@@QAEAAU0@$$QAU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4ImRect@@QAEAAU0@$$QAU0@@Z PROC			; ImRect::operator=, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??4ImRect@@QAEAAU0@$$QAU0@@Z ENDP			; ImRect::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??4ImRect@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4ImRect@@QAEAAU0@ABU0@@Z PROC				; ImRect::operator=, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ___that$[ebp]
	movups	xmm0, XMMWORD PTR [eax]
	mov	eax, ecx
	movups	XMMWORD PTR [ecx], xmm0
	pop	ebp
	ret	4
??4ImRect@@QAEAAU0@ABU0@@Z ENDP				; ImRect::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?GetClosestPoint@ImRect@@QBE?AUImVec2@@U2@_N@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_p$ = 12						; size = 8
_on_edge$ = 20						; size = 1
?GetClosestPoint@ImRect@@QBE?AUImVec2@@U2@_N@Z PROC	; ImRect::GetClosestPoint, COMDAT
; _this$ = ecx

; 263  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 264  :         if (!on_edge && Contains(p))

	cmp	BYTE PTR _on_edge$[ebp], 0
	movss	xmm2, DWORD PTR _p$[ebp+4]
	movss	xmm1, DWORD PTR _p$[ebp]
	jne	SHORT $LN2@GetClosest

; 252  :     bool        Contains(const ImVec2& p) const { return p.x >= Min.x     && p.y >= Min.y     && p.x < Max.x     && p.y < Max.y; }

	comiss	xmm1, DWORD PTR [ecx]
	jb	SHORT $LN2@GetClosest
	comiss	xmm2, DWORD PTR [ecx+4]
	jb	SHORT $LN2@GetClosest
	movss	xmm0, DWORD PTR [ecx+8]
	comiss	xmm0, xmm1
	jbe	SHORT $LN2@GetClosest
	movss	xmm0, DWORD PTR [ecx+12]
	comiss	xmm0, xmm2
	ja	SHORT $LN8@GetClosest
$LN2@GetClosest:

; 265  :             return p;
; 266  :         if (p.x > Max.x) p.x = Max.x;

	movss	xmm0, DWORD PTR [ecx+8]
	comiss	xmm1, xmm0
	ja	SHORT $LN15@GetClosest

; 267  :         else if (p.x < Min.x) p.x = Min.x;

	movss	xmm0, DWORD PTR [ecx]
	comiss	xmm0, xmm1
	jbe	SHORT $LN5@GetClosest
$LN15@GetClosest:
	movss	DWORD PTR _p$[ebp], xmm0
$LN5@GetClosest:

; 268  :         if (p.y > Max.y) p.y = Max.y;

	movss	xmm0, DWORD PTR [ecx+12]
	comiss	xmm2, xmm0
	ja	SHORT $LN16@GetClosest

; 269  :         else if (p.y < Min.y) p.y = Min.y;

	movss	xmm0, DWORD PTR [ecx+4]
	comiss	xmm0, xmm2
	jbe	SHORT $LN8@GetClosest
$LN16@GetClosest:
	movss	DWORD PTR _p$[ebp+4], xmm0
$LN8@GetClosest:

; 270  :         return p;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _p$[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 271  :     }

	pop	ebp
	ret	16					; 00000010H
?GetClosestPoint@ImRect@@QBE?AUImVec2@@U2@_N@Z ENDP	; ImRect::GetClosestPoint
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?Floor@ImRect@@QAEXXZ
_TEXT	SEGMENT
?Floor@ImRect@@QAEXXZ PROC				; ImRect::Floor, COMDAT
; _this$ = ecx

; 261  :     void        Floor()                         { Min.x = (float)(int)Min.x; Min.y = (float)(int)Min.y; Max.x = (float)(int)Max.x; Max.y = (float)(int)Max.y; }

	cvttss2si eax, DWORD PTR [ecx]
	movd	xmm0, eax
	cvttss2si eax, DWORD PTR [ecx+4]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [ecx], xmm0
	movd	xmm0, eax
	cvttss2si eax, DWORD PTR [ecx+8]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [ecx+4], xmm0
	movd	xmm0, eax
	cvttss2si eax, DWORD PTR [ecx+12]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [ecx+8], xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [ecx+12], xmm0
	ret	0
?Floor@ImRect@@QAEXXZ ENDP				; ImRect::Floor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?Clip@ImRect@@QBEXAAU1@@Z
_TEXT	SEGMENT
_r$ = 8							; size = 4
?Clip@ImRect@@QBEXAAU1@@Z PROC				; ImRect::Clip, COMDAT
; _this$ = ecx

; 260  :     void        Clip(ImRect& r) const           { r.Min.x = ImClamp(r.Min.x, Min.x, Max.x); r.Min.y = ImClamp(r.Min.y, Min.y, Max.y); r.Max.x = ImClamp(r.Max.x, Min.x, Max.x); r.Max.y = ImClamp(r.Max.y, Min.y, Max.y); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _r$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	movss	xmm1, DWORD PTR [eax]

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm0, xmm1
	ja	SHORT $LN8@Clip
	movss	xmm0, DWORD PTR [ecx+8]
	minss	xmm0, xmm1
$LN8@Clip:

; 260  :     void        Clip(ImRect& r) const           { r.Min.x = ImClamp(r.Min.x, Min.x, Max.x); r.Min.y = ImClamp(r.Min.y, Min.y, Max.y); r.Max.x = ImClamp(r.Max.x, Min.x, Max.x); r.Max.y = ImClamp(r.Max.y, Min.y, Max.y); }

	movss	xmm1, DWORD PTR [eax+4]
	movss	DWORD PTR [eax], xmm0
	movss	xmm0, DWORD PTR [ecx+4]

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm0, xmm1
	ja	SHORT $LN14@Clip
	movss	xmm0, DWORD PTR [ecx+12]
	minss	xmm0, xmm1
$LN14@Clip:

; 260  :     void        Clip(ImRect& r) const           { r.Min.x = ImClamp(r.Min.x, Min.x, Max.x); r.Min.y = ImClamp(r.Min.y, Min.y, Max.y); r.Max.x = ImClamp(r.Max.x, Min.x, Max.x); r.Max.y = ImClamp(r.Max.y, Min.y, Max.y); }

	movss	xmm1, DWORD PTR [eax+8]
	movss	DWORD PTR [eax+4], xmm0
	movss	xmm0, DWORD PTR [ecx]

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm0, xmm1
	ja	SHORT $LN20@Clip
	movss	xmm0, DWORD PTR [ecx+8]
	minss	xmm0, xmm1
$LN20@Clip:

; 260  :     void        Clip(ImRect& r) const           { r.Min.x = ImClamp(r.Min.x, Min.x, Max.x); r.Min.y = ImClamp(r.Min.y, Min.y, Max.y); r.Max.x = ImClamp(r.Max.x, Min.x, Max.x); r.Max.y = ImClamp(r.Max.y, Min.y, Max.y); }

	movss	xmm1, DWORD PTR [eax+12]
	movss	DWORD PTR [eax+8], xmm0
	movss	xmm0, DWORD PTR [ecx+4]

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm0, xmm1
	ja	SHORT $LN27@Clip
	movss	xmm0, DWORD PTR [ecx+12]
	minss	xmm0, xmm1
$LN27@Clip:

; 260  :     void        Clip(ImRect& r) const           { r.Min.x = ImClamp(r.Min.x, Min.x, Max.x); r.Min.y = ImClamp(r.Min.y, Min.y, Max.y); r.Max.x = ImClamp(r.Max.x, Min.x, Max.x); r.Max.y = ImClamp(r.Max.y, Min.y, Max.y); }

	movss	DWORD PTR [eax+12], xmm0
	pop	ebp
	ret	4
?Clip@ImRect@@QBEXAAU1@@Z ENDP				; ImRect::Clip
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?Translate@ImRect@@QAEXABUImVec2@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?Translate@ImRect@@QAEXABUImVec2@@@Z PROC		; ImRect::Translate, COMDAT
; _this$ = ecx

; 259  :     void        Translate(const ImVec2& v)      { Min.x += v.x; Min.y += v.y; Max.x += v.x; Max.y += v.y; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR [ecx+4]
	addss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [ecx+4], xmm0
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR [ecx+8]
	movss	DWORD PTR [ecx+8], xmm0
	movss	xmm0, DWORD PTR [eax+4]
	addss	xmm0, DWORD PTR [ecx+12]
	movss	DWORD PTR [ecx+12], xmm0
	pop	ebp
	ret	4
?Translate@ImRect@@QAEXABUImVec2@@@Z ENDP		; ImRect::Translate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?Expand@ImRect@@QAEXABUImVec2@@@Z
_TEXT	SEGMENT
_amount$ = 8						; size = 4
?Expand@ImRect@@QAEXABUImVec2@@@Z PROC			; ImRect::Expand, COMDAT
; _this$ = ecx

; 258  :     void        Expand(const ImVec2& amount)    { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _amount$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	subss	xmm0, DWORD PTR [eax]
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR [ecx+4]
	subss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [ecx+4], xmm0
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR [ecx+8]
	movss	DWORD PTR [ecx+8], xmm0
	movss	xmm0, DWORD PTR [eax+4]
	addss	xmm0, DWORD PTR [ecx+12]
	movss	DWORD PTR [ecx+12], xmm0
	pop	ebp
	ret	4
?Expand@ImRect@@QAEXABUImVec2@@@Z ENDP			; ImRect::Expand
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?Expand@ImRect@@QAEXM@Z
_TEXT	SEGMENT
_amount$ = 8						; size = 4
?Expand@ImRect@@QAEXM@Z PROC				; ImRect::Expand, COMDAT
; _this$ = ecx

; 257  :     void        Expand(const float amount)      { Min.x -= amount;   Min.y -= amount;   Max.x += amount;   Max.y += amount; }

	npad	2
	push	ebp
	mov	ebp, esp
	movss	xmm1, DWORD PTR _amount$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	subss	xmm0, xmm1
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR [ecx+4]
	subss	xmm0, xmm1
	movss	DWORD PTR [ecx+4], xmm0
	movss	xmm0, DWORD PTR [ecx+8]
	addss	xmm0, xmm1
	movss	DWORD PTR [ecx+8], xmm0
	movss	xmm0, DWORD PTR [ecx+12]
	addss	xmm0, xmm1
	movss	DWORD PTR [ecx+12], xmm0
	pop	ebp
	ret	4
?Expand@ImRect@@QAEXM@Z ENDP				; ImRect::Expand
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?Add@ImRect@@QAEXABU1@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
?Add@ImRect@@QAEXABU1@@Z PROC				; ImRect::Add, COMDAT
; _this$ = ecx

; 256  :     void        Add(const ImRect& rhs)          { if (Min.x > rhs.Min.x) Min.x = rhs.Min.x; if (Min.y > rhs.Min.y) Min.y = rhs.Min.y; if (Max.x < rhs.Max.x) Max.x = rhs.Max.x; if (Max.y < rhs.Max.y) Max.y = rhs.Max.y; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _rhs$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	movss	xmm1, DWORD PTR [eax]
	comiss	xmm0, xmm1
	jbe	SHORT $LN2@Add
	movss	DWORD PTR [ecx], xmm1
$LN2@Add:
	movss	xmm1, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [ecx+4]
	comiss	xmm0, xmm1
	jbe	SHORT $LN3@Add
	movss	DWORD PTR [ecx+4], xmm1
$LN3@Add:
	movss	xmm0, DWORD PTR [eax+8]
	comiss	xmm0, DWORD PTR [ecx+8]
	jbe	SHORT $LN4@Add
	movss	DWORD PTR [ecx+8], xmm0
$LN4@Add:
	movss	xmm0, DWORD PTR [eax+12]
	comiss	xmm0, DWORD PTR [ecx+12]
	jbe	SHORT $LN5@Add
	movss	DWORD PTR [ecx+12], xmm0
$LN5@Add:
	pop	ebp
	ret	4
?Add@ImRect@@QAEXABU1@@Z ENDP				; ImRect::Add
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?Add@ImRect@@QAEXABUImVec2@@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
?Add@ImRect@@QAEXABUImVec2@@@Z PROC			; ImRect::Add, COMDAT
; _this$ = ecx

; 255  :     void        Add(const ImVec2& rhs)          { if (Min.x > rhs.x)     Min.x = rhs.x;     if (Min.y > rhs.y) Min.y = rhs.y;         if (Max.x < rhs.x) Max.x = rhs.x;         if (Max.y < rhs.y) Max.y = rhs.y; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _rhs$[ebp]
	movss	xmm0, DWORD PTR [ecx]
	movss	xmm1, DWORD PTR [eax]
	comiss	xmm0, xmm1
	jbe	SHORT $LN2@Add
	movss	DWORD PTR [ecx], xmm1
$LN2@Add:
	movss	xmm1, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [ecx+4]
	comiss	xmm0, xmm1
	jbe	SHORT $LN3@Add
	movss	DWORD PTR [ecx+4], xmm1
$LN3@Add:
	movss	xmm0, DWORD PTR [eax]
	comiss	xmm0, DWORD PTR [ecx+8]
	jbe	SHORT $LN4@Add
	movss	DWORD PTR [ecx+8], xmm0
$LN4@Add:
	movss	xmm0, DWORD PTR [eax+4]
	comiss	xmm0, DWORD PTR [ecx+12]
	jbe	SHORT $LN5@Add
	movss	DWORD PTR [ecx+12], xmm0
$LN5@Add:
	pop	ebp
	ret	4
?Add@ImRect@@QAEXABUImVec2@@@Z ENDP			; ImRect::Add
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?Overlaps@ImRect@@QBE_NABU1@@Z
_TEXT	SEGMENT
_r$ = 8							; size = 4
?Overlaps@ImRect@@QBE_NABU1@@Z PROC			; ImRect::Overlaps, COMDAT
; _this$ = ecx

; 254  :     bool        Overlaps(const ImRect& r) const { return r.Min.y < Max.y  && r.Max.y > Min.y  && r.Min.x < Max.x && r.Max.x > Min.x; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _r$[ebp]
	movss	xmm0, DWORD PTR [ecx+12]
	comiss	xmm0, DWORD PTR [eax+4]
	jbe	SHORT $LN3@Overlaps
	movss	xmm0, DWORD PTR [eax+12]
	comiss	xmm0, DWORD PTR [ecx+4]
	jbe	SHORT $LN3@Overlaps
	movss	xmm0, DWORD PTR [ecx+8]
	comiss	xmm0, DWORD PTR [eax]
	jbe	SHORT $LN3@Overlaps
	movss	xmm0, DWORD PTR [eax+8]
	comiss	xmm0, DWORD PTR [ecx]
	jbe	SHORT $LN3@Overlaps
	mov	al, 1
	pop	ebp
	ret	4
$LN3@Overlaps:
	xor	al, al
	pop	ebp
	ret	4
?Overlaps@ImRect@@QBE_NABU1@@Z ENDP			; ImRect::Overlaps
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?Contains@ImRect@@QBE_NABU1@@Z
_TEXT	SEGMENT
_r$ = 8							; size = 4
?Contains@ImRect@@QBE_NABU1@@Z PROC			; ImRect::Contains, COMDAT
; _this$ = ecx

; 253  :     bool        Contains(const ImRect& r) const { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x < Max.x && r.Max.y < Max.y; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _r$[ebp]
	movss	xmm0, DWORD PTR [eax]
	comiss	xmm0, DWORD PTR [ecx]
	jb	SHORT $LN3@Contains
	movss	xmm0, DWORD PTR [eax+4]
	comiss	xmm0, DWORD PTR [ecx+4]
	jb	SHORT $LN3@Contains
	movss	xmm0, DWORD PTR [ecx+8]
	comiss	xmm0, DWORD PTR [eax+8]
	jbe	SHORT $LN3@Contains
	movss	xmm0, DWORD PTR [ecx+12]
	comiss	xmm0, DWORD PTR [eax+12]
	jbe	SHORT $LN3@Contains
	mov	al, 1
	pop	ebp
	ret	4
$LN3@Contains:
	xor	al, al
	pop	ebp
	ret	4
?Contains@ImRect@@QBE_NABU1@@Z ENDP			; ImRect::Contains
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?Contains@ImRect@@QBE_NABUImVec2@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?Contains@ImRect@@QBE_NABUImVec2@@@Z PROC		; ImRect::Contains, COMDAT
; _this$ = ecx

; 252  :     bool        Contains(const ImVec2& p) const { return p.x >= Min.x     && p.y >= Min.y     && p.x < Max.x     && p.y < Max.y; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _p$[ebp]
	movss	xmm2, DWORD PTR [eax]
	comiss	xmm2, DWORD PTR [ecx]
	jb	SHORT $LN3@Contains
	movss	xmm1, DWORD PTR [eax+4]
	comiss	xmm1, DWORD PTR [ecx+4]
	jb	SHORT $LN3@Contains
	movss	xmm0, DWORD PTR [ecx+8]
	comiss	xmm0, xmm2
	jbe	SHORT $LN3@Contains
	movss	xmm0, DWORD PTR [ecx+12]
	comiss	xmm0, xmm1
	jbe	SHORT $LN3@Contains
	mov	al, 1
	pop	ebp
	ret	4
$LN3@Contains:
	xor	al, al
	pop	ebp
	ret	4
?Contains@ImRect@@QBE_NABUImVec2@@@Z ENDP		; ImRect::Contains
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?GetBR@ImRect@@QBE?AUImVec2@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetBR@ImRect@@QBE?AUImVec2@@XZ PROC			; ImRect::GetBR, COMDAT
; _this$ = ecx

; 251  :     ImVec2      GetBR() const                   { return Max; }                   // Bottom-right

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	pop	ebp
	ret	4
?GetBR@ImRect@@QBE?AUImVec2@@XZ ENDP			; ImRect::GetBR
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?GetBL@ImRect@@QBE?AUImVec2@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetBL@ImRect@@QBE?AUImVec2@@XZ PROC			; ImRect::GetBL, COMDAT
; _this$ = ecx

; 250  :     ImVec2      GetBL() const                   { return ImVec2(Min.x, Max.y); }  // Bottom-left

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 250  :     ImVec2      GetBL() const                   { return ImVec2(Min.x, Max.y); }  // Bottom-left

	pop	ebp
	ret	4
?GetBL@ImRect@@QBE?AUImVec2@@XZ ENDP			; ImRect::GetBL
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?GetTR@ImRect@@QBE?AUImVec2@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetTR@ImRect@@QBE?AUImVec2@@XZ PROC			; ImRect::GetTR, COMDAT
; _this$ = ecx

; 249  :     ImVec2      GetTR() const                   { return ImVec2(Max.x, Min.y); }  // Top-right

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 249  :     ImVec2      GetTR() const                   { return ImVec2(Max.x, Min.y); }  // Top-right

	pop	ebp
	ret	4
?GetTR@ImRect@@QBE?AUImVec2@@XZ ENDP			; ImRect::GetTR
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?GetTL@ImRect@@QBE?AUImVec2@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetTL@ImRect@@QBE?AUImVec2@@XZ PROC			; ImRect::GetTL, COMDAT
; _this$ = ecx

; 248  :     ImVec2      GetTL() const                   { return Min; }                   // Top-left

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	pop	ebp
	ret	4
?GetTL@ImRect@@QBE?AUImVec2@@XZ ENDP			; ImRect::GetTL
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?GetHeight@ImRect@@QBEMXZ
_TEXT	SEGMENT
?GetHeight@ImRect@@QBEMXZ PROC				; ImRect::GetHeight, COMDAT
; _this$ = ecx

; 247  :     float       GetHeight() const               { return Max.y-Min.y; }

	fld	DWORD PTR [ecx+12]
	fsub	DWORD PTR [ecx+4]
	ret	0
?GetHeight@ImRect@@QBEMXZ ENDP				; ImRect::GetHeight
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?GetWidth@ImRect@@QBEMXZ
_TEXT	SEGMENT
?GetWidth@ImRect@@QBEMXZ PROC				; ImRect::GetWidth, COMDAT
; _this$ = ecx

; 246  :     float       GetWidth() const                { return Max.x-Min.x; }

	fld	DWORD PTR [ecx+8]
	fsub	DWORD PTR [ecx]
	ret	0
?GetWidth@ImRect@@QBEMXZ ENDP				; ImRect::GetWidth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?GetSize@ImRect@@QBE?AUImVec2@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetSize@ImRect@@QBE?AUImVec2@@XZ PROC			; ImRect::GetSize, COMDAT
; _this$ = ecx

; 245  :     ImVec2      GetSize() const                 { return ImVec2(Max.x-Min.x, Max.y-Min.y); }

	npad	2
	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR [ecx+8]
	subss	xmm0, DWORD PTR [ecx]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	movss	DWORD PTR [eax], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 245  :     ImVec2      GetSize() const                 { return ImVec2(Max.x-Min.x, Max.y-Min.y); }

	movss	xmm0, DWORD PTR [ecx+12]
	subss	xmm0, DWORD PTR [ecx+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 245  :     ImVec2      GetSize() const                 { return ImVec2(Max.x-Min.x, Max.y-Min.y); }

	pop	ebp
	ret	4
?GetSize@ImRect@@QBE?AUImVec2@@XZ ENDP			; ImRect::GetSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ?GetCenter@ImRect@@QBE?AUImVec2@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetCenter@ImRect@@QBE?AUImVec2@@XZ PROC		; ImRect::GetCenter, COMDAT
; _this$ = ecx

; 244  :     ImVec2      GetCenter() const               { return ImVec2((Min.x+Max.x)*0.5f, (Min.y+Max.y)*0.5f); }

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR [ecx+8]
	addss	xmm0, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 244  :     ImVec2      GetCenter() const               { return ImVec2((Min.x+Max.x)*0.5f, (Min.y+Max.y)*0.5f); }

	mulss	xmm0, DWORD PTR __real@3f000000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax], xmm0
	movss	xmm0, DWORD PTR [ecx+12]
	addss	xmm0, DWORD PTR [ecx+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 244  :     ImVec2      GetCenter() const               { return ImVec2((Min.x+Max.x)*0.5f, (Min.y+Max.y)*0.5f); }

	mulss	xmm0, DWORD PTR __real@3f000000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 244  :     ImVec2      GetCenter() const               { return ImVec2((Min.x+Max.x)*0.5f, (Min.y+Max.y)*0.5f); }

	pop	ebp
	ret	4
?GetCenter@ImRect@@QBE?AUImVec2@@XZ ENDP		; ImRect::GetCenter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ??0ImRect@@QAE@MMMM@Z
_TEXT	SEGMENT
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_x2$ = 16						; size = 4
_y2$ = 20						; size = 4
??0ImRect@@QAE@MMMM@Z PROC				; ImRect::ImRect, COMDAT
; _this$ = ecx

; 242  :     ImRect(float x1, float y1, float x2, float y2)  : Min(x1, y1), Max(x2, y2)                      {}

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR _x1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 242  :     ImRect(float x1, float y1, float x2, float y2)  : Min(x1, y1), Max(x2, y2)                      {}

	mov	eax, ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR _y1$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	movss	xmm0, DWORD PTR _x2$[ebp]
	movss	DWORD PTR [ecx+8], xmm0
	movss	xmm0, DWORD PTR _y2$[ebp]
	movss	DWORD PTR [ecx+12], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 242  :     ImRect(float x1, float y1, float x2, float y2)  : Min(x1, y1), Max(x2, y2)                      {}

	pop	ebp
	ret	16					; 00000010H
??0ImRect@@QAE@MMMM@Z ENDP				; ImRect::ImRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ??0ImRect@@QAE@ABUImVec4@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
??0ImRect@@QAE@ABUImVec4@@@Z PROC			; ImRect::ImRect, COMDAT
; _this$ = ecx

; 241  :     ImRect(const ImVec4& v)                         : Min(v.x, v.y), Max(v.z, v.w)                  {}

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _v$[ebp]
	movss	xmm0, DWORD PTR [edx+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	movss	DWORD PTR [ecx+4], xmm0
	mov	eax, DWORD PTR [edx+8]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 241  :     ImRect(const ImVec4& v)                         : Min(v.x, v.y), Max(v.z, v.w)                  {}

	movss	xmm0, DWORD PTR [edx+12]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR [ecx+8], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 241  :     ImRect(const ImVec4& v)                         : Min(v.x, v.y), Max(v.z, v.w)                  {}

	mov	eax, ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [ecx+12], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 241  :     ImRect(const ImVec4& v)                         : Min(v.x, v.y), Max(v.z, v.w)                  {}

	pop	ebp
	ret	4
??0ImRect@@QAE@ABUImVec4@@@Z ENDP			; ImRect::ImRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ??0ImRect@@QAE@ABUImVec2@@0@Z
_TEXT	SEGMENT
_min$ = 8						; size = 4
_max$ = 12						; size = 4
??0ImRect@@QAE@ABUImVec2@@0@Z PROC			; ImRect::ImRect, COMDAT
; _this$ = ecx

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _min$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _max$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, ecx
	pop	ebp
	ret	8
??0ImRect@@QAE@ABUImVec2@@0@Z ENDP			; ImRect::ImRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ??0ImRect@@QAE@XZ
_TEXT	SEGMENT
??0ImRect@@QAE@XZ PROC					; ImRect::ImRect, COMDAT
; _this$ = ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR [ecx], 2139095039		; 7f7fffffH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 239  :     ImRect()                                        : Min(FLT_MAX,FLT_MAX), Max(-FLT_MAX,-FLT_MAX)  {}

	mov	eax, ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR [ecx+4], 2139095039		; 7f7fffffH
	mov	DWORD PTR [ecx+8], -8388609		; ff7fffffH
	mov	DWORD PTR [ecx+12], -8388609		; ff7fffffH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 239  :     ImRect()                                        : Min(FLT_MAX,FLT_MAX), Max(-FLT_MAX,-FLT_MAX)  {}

	ret	0
??0ImRect@@QAE@XZ ENDP					; ImRect::ImRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ??3@YAXPAXUImPlacementNewDummy@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 4
??3@YAXPAXUImPlacementNewDummy@@0@Z PROC		; operator delete, COMDAT

; 148  : inline void operator delete(void*, ImPlacementNewDummy, void*) {}

	ret	0
??3@YAXPAXUImPlacementNewDummy@@0@Z ENDP		; operator delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
;	COMDAT ??2@YAPAXIUImPlacementNewDummy@@PAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 1
_ptr$ = 16						; size = 4
??2@YAPAXIUImPlacementNewDummy@@PAX@Z PROC		; operator new, COMDAT

; 147  : inline void* operator new(size_t, ImPlacementNewDummy, void* ptr) { return ptr; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _ptr$[ebp]
	pop	ebp
	ret	0
??2@YAPAXIUImPlacementNewDummy@@PAX@Z ENDP		; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 8
?ImFloor@@YA?AUImVec2@@U1@@Z PROC			; ImFloor

; 141  : static inline ImVec2 ImFloor(ImVec2 v)                                          { return ImVec2((float)(int)v.x, (float)(int)v.y); }

	npad	2
	push	ebp
	mov	ebp, esp
	cvttss2si eax, DWORD PTR _v$[ebp]
	cvttss2si ecx, DWORD PTR _v$[ebp+4]
	movd	xmm0, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 141  : static inline ImVec2 ImFloor(ImVec2 v)                                          { return ImVec2((float)(int)v.x, (float)(int)v.y); }

	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax], xmm0
	movd	xmm0, ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 141  : static inline ImVec2 ImFloor(ImVec2 v)                                          { return ImVec2((float)(int)v.x, (float)(int)v.y); }

	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 141  : static inline ImVec2 ImFloor(ImVec2 v)                                          { return ImVec2((float)(int)v.x, (float)(int)v.y); }

	pop	ebp
	ret	0
?ImFloor@@YA?AUImVec2@@U1@@Z ENDP			; ImFloor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
tv67 = 8						; size = 4
_f$ = 8							; size = 4
?ImFloor@@YAMM@Z PROC					; ImFloor

; 140  : static inline float  ImFloor(float f)                                           { return (float)(int)f; }

	npad	2
	push	ebp
	mov	ebp, esp
	cvttss2si eax, DWORD PTR _f$[ebp]
	mov	DWORD PTR tv67[ebp], eax
	fild	DWORD PTR tv67[ebp]
	pop	ebp
	ret	0
?ImFloor@@YAMM@Z ENDP					; ImFloor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
tv65 = 8						; size = 4
_lhs$ = 8						; size = 4
?ImLengthSqr@@YAMABUImVec2@@@Z PROC			; ImLengthSqr

; 137  : static inline float  ImLengthSqr(const ImVec2& lhs)                             { return lhs.x*lhs.x + lhs.y*lhs.y; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _lhs$[ebp]
	movss	xmm1, DWORD PTR [eax+4]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, xmm0
	mulss	xmm1, xmm1
	addss	xmm0, xmm1
	movss	DWORD PTR tv65[ebp], xmm0
	fld	DWORD PTR tv65[ebp]
	pop	ebp
	ret	0
?ImLengthSqr@@YAMABUImVec2@@@Z ENDP			; ImLengthSqr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_a$ = 12						; size = 4
_b$ = 16						; size = 4
_t$ = 20						; size = 4
?ImLerp@@YA?AUImVec2@@ABU1@00@Z PROC			; ImLerp

; 136  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 136  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }

	mov	esi, DWORD PTR _a$[ebp]
	movss	xmm0, DWORD PTR [edx]
	subss	xmm0, DWORD PTR [esi]
	mulss	xmm0, DWORD PTR [ecx]
	addss	xmm0, DWORD PTR [esi]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 136  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }

	movss	xmm0, DWORD PTR [edx+4]
	subss	xmm0, DWORD PTR [esi+4]
	mulss	xmm0, DWORD PTR [ecx+4]
	addss	xmm0, DWORD PTR [esi+4]
	pop	esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 136  : static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }

	pop	ebp
	ret	0
?ImLerp@@YA?AUImVec2@@ABU1@00@Z ENDP			; ImLerp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
_a$ = 8							; size = 4
tv128 = 12						; size = 4
_b$ = 12						; size = 4
_t$ = 16						; size = 4
?ImLerp@@YAMMMM@Z PROC					; ImLerp

; 135  : static inline float  ImLerp(float a, float b, float t)                          { return a + (b - a) * t; }

	npad	2
	push	ebp
	mov	ebp, esp
	movss	xmm1, DWORD PTR _b$[ebp]
	subss	xmm1, DWORD PTR _a$[ebp]
	mulss	xmm1, DWORD PTR _t$[ebp]
	addss	xmm1, DWORD PTR _a$[ebp]
	movss	DWORD PTR tv128[ebp], xmm1
	fld	DWORD PTR tv128[ebp]
	pop	ebp
	ret	0
?ImLerp@@YAMMMM@Z ENDP					; ImLerp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
tv67 = 8						; size = 4
_f$ = 8							; size = 4
?ImSaturate@@YAMM@Z PROC				; ImSaturate

; 134  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	npad	2
	push	ebp
	mov	ebp, esp
	movss	xmm1, DWORD PTR _f$[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, xmm1
	jbe	SHORT $LN5@ImSaturate
	mov	DWORD PTR tv67[ebp], 0
	fld	DWORD PTR tv67[ebp]
	pop	ebp
	ret	0
$LN5@ImSaturate:
	minss	xmm1, DWORD PTR __real@3f800000
	movss	DWORD PTR tv67[ebp], xmm1
	fld	DWORD PTR tv67[ebp]
	pop	ebp
	ret	0
?ImSaturate@@YAMM@Z ENDP				; ImSaturate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_f$ = 12						; size = 4
_mn$ = 16						; size = 4
_mx$ = 20						; size = 8
?ImClamp@@YA?AUImVec2@@ABU1@0U1@@Z PROC			; ImClamp

; 133  : static inline ImVec2 ImClamp(const ImVec2& f, const ImVec2& mn, ImVec2 mx)      { return ImVec2(ImClamp(f.x,mn.x,mx.x), ImClamp(f.y,mn.y,mx.y)); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _f$[ebp]
	mov	ecx, DWORD PTR _mn$[ebp]
	movss	xmm0, DWORD PTR [eax+4]
	movss	xmm1, DWORD PTR [ecx+4]

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm1, xmm0
	ja	SHORT $LN8@ImClamp
	movaps	xmm1, xmm0
	minss	xmm1, DWORD PTR _mx$[ebp+4]
$LN8@ImClamp:

; 133  : static inline ImVec2 ImClamp(const ImVec2& f, const ImVec2& mn, ImVec2 mx)      { return ImVec2(ImClamp(f.x,mn.x,mx.x), ImClamp(f.y,mn.y,mx.y)); }

	movss	xmm2, DWORD PTR [eax]
	movss	xmm0, DWORD PTR [ecx]

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm0, xmm2
	ja	SHORT $LN14@ImClamp
	movaps	xmm0, xmm2
	minss	xmm0, DWORD PTR _mx$[ebp]
$LN14@ImClamp:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	movss	DWORD PTR [eax], xmm0
	movss	DWORD PTR [eax+4], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 133  : static inline ImVec2 ImClamp(const ImVec2& f, const ImVec2& mn, ImVec2 mx)      { return ImVec2(ImClamp(f.x,mn.x,mx.x), ImClamp(f.y,mn.y,mx.y)); }

	pop	ebp
	ret	0
?ImClamp@@YA?AUImVec2@@ABU1@0U1@@Z ENDP			; ImClamp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
_v$ = 8							; size = 4
tv67 = 12						; size = 4
_mn$ = 12						; size = 4
_mx$ = 16						; size = 4
?ImClamp@@YAMMMM@Z PROC					; ImClamp

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	npad	2
	push	ebp
	mov	ebp, esp
	movss	xmm1, DWORD PTR _mn$[ebp]
	movss	xmm0, DWORD PTR _v$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN5@ImClamp
	movss	DWORD PTR tv67[ebp], xmm1
	fld	DWORD PTR tv67[ebp]
	pop	ebp
	ret	0
$LN5@ImClamp:
	minss	xmm0, DWORD PTR _mx$[ebp]
	movss	DWORD PTR tv67[ebp], xmm0
	fld	DWORD PTR tv67[ebp]
	pop	ebp
	ret	0
?ImClamp@@YAMMMM@Z ENDP					; ImClamp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
_v$ = 8							; size = 4
_mn$ = 12						; size = 4
_mx$ = 16						; size = 4
?ImClamp@@YAHHHH@Z PROC					; ImClamp

; 131  : static inline int    ImClamp(int v, int mn, int mx)                             { return (v < mn) ? mn : (v > mx) ? mx : v; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR _mn$[ebp]
	cmp	eax, ecx
	jge	SHORT $LN3@ImClamp
	mov	eax, ecx
	pop	ebp
	ret	0
$LN3@ImClamp:
	cmp	eax, DWORD PTR _mx$[ebp]
	cmovg	eax, DWORD PTR _mx$[ebp]
	pop	ebp
	ret	0
?ImClamp@@YAHHHH@Z ENDP					; ImClamp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_lhs$ = 12						; size = 4
_rhs$ = 16						; size = 4
?ImMax@@YA?AUImVec2@@ABU1@0@Z PROC			; ImMax

; 130  : static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(ImMax(lhs.x,rhs.x), ImMax(lhs.y,rhs.y)); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _lhs$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	movss	xmm0, DWORD PTR [edx]
	maxss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [eax], xmm0
	movss	xmm0, DWORD PTR [edx+4]
	maxss	xmm0, DWORD PTR [ecx+4]
	movss	DWORD PTR [eax+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 130  : static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(ImMax(lhs.x,rhs.x), ImMax(lhs.y,rhs.y)); }

	pop	ebp
	ret	0
?ImMax@@YA?AUImVec2@@ABU1@0@Z ENDP			; ImMax
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_lhs$ = 12						; size = 4
_rhs$ = 16						; size = 4
?ImMin@@YA?AUImVec2@@ABU1@0@Z PROC			; ImMin

; 129  : static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(ImMin(lhs.x,rhs.x), ImMin(lhs.y,rhs.y)); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _lhs$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	movss	xmm0, DWORD PTR [edx]
	minss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [eax], xmm0
	movss	xmm0, DWORD PTR [edx+4]
	minss	xmm0, DWORD PTR [ecx+4]
	movss	DWORD PTR [eax+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 129  : static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(ImMin(lhs.x,rhs.x), ImMin(lhs.y,rhs.y)); }

	pop	ebp
	ret	0
?ImMin@@YA?AUImVec2@@ABU1@0@Z ENDP			; ImMin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
tv65 = 8						; size = 4
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
?ImMax@@YAMMM@Z PROC					; ImMax

; 128  : static inline float  ImMax(float lhs, float rhs)                                { return lhs >= rhs ? lhs : rhs; }

	npad	2
	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR _lhs$[ebp]
	maxss	xmm0, DWORD PTR _rhs$[ebp]
	movss	DWORD PTR tv65[ebp], xmm0
	fld	DWORD PTR tv65[ebp]
	pop	ebp
	ret	0
?ImMax@@YAMMM@Z ENDP					; ImMax
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
tv65 = 8						; size = 4
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
?ImMin@@YAMMM@Z PROC					; ImMin

; 127  : static inline float  ImMin(float lhs, float rhs)                                { return lhs < rhs ? lhs : rhs; }

	npad	2
	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR _lhs$[ebp]
	minss	xmm0, DWORD PTR _rhs$[ebp]
	movss	DWORD PTR tv65[ebp], xmm0
	fld	DWORD PTR tv65[ebp]
	pop	ebp
	ret	0
?ImMin@@YAMMM@Z ENDP					; ImMin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
?ImMax@@YAHHH@Z PROC					; ImMax

; 126  : static inline int    ImMax(int lhs, int rhs)                                    { return lhs >= rhs ? lhs : rhs; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _rhs$[ebp]
	cmp	DWORD PTR _lhs$[ebp], eax
	cmovge	eax, DWORD PTR _lhs$[ebp]
	pop	ebp
	ret	0
?ImMax@@YAHHH@Z ENDP					; ImMax
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
?ImMin@@YAHHH@Z PROC					; ImMin

; 125  : static inline int    ImMin(int lhs, int rhs)                                    { return lhs < rhs ? lhs : rhs; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _rhs$[ebp]
	cmp	DWORD PTR _lhs$[ebp], eax
	cmovl	eax, DWORD PTR _lhs$[ebp]
	pop	ebp
	ret	0
?ImMin@@YAHHH@Z ENDP					; ImMin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
??X@YAAAUImVec2@@AAU0@M@Z PROC				; operator*=

; 120  : static inline ImVec2& operator*=(ImVec2& lhs, const float rhs)                  { lhs.x *= rhs; lhs.y *= rhs; return lhs; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _lhs$[ebp]
	movss	xmm0, DWORD PTR [eax]
	mulss	xmm0, DWORD PTR _rhs$[ebp]
	movss	DWORD PTR [eax], xmm0
	movss	xmm0, DWORD PTR [eax+4]
	mulss	xmm0, DWORD PTR _rhs$[ebp]
	movss	DWORD PTR [eax+4], xmm0
	pop	ebp
	ret	0
??X@YAAAUImVec2@@AAU0@M@Z ENDP				; operator*=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
_lhs$ = 8						; size = 4
_rhs$ = 12						; size = 4
??Y@YAAAUImVec2@@AAU0@ABU0@@Z PROC			; operator+=

; 118  : static inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _lhs$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [eax], xmm0
	movss	xmm0, DWORD PTR [ecx+4]
	addss	xmm0, DWORD PTR [eax+4]
	movss	DWORD PTR [eax+4], xmm0
	pop	ebp
	ret	0
??Y@YAAAUImVec2@@AAU0@ABU0@@Z ENDP			; operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_lhs$ = 12						; size = 4
_rhs$ = 16						; size = 4
??K@YA?AUImVec2@@ABU0@0@Z PROC				; operator/

; 117  : static inline ImVec2 operator/(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x/rhs.x, lhs.y/rhs.y); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _lhs$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 117  : static inline ImVec2 operator/(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x/rhs.x, lhs.y/rhs.y); }

	movss	xmm0, DWORD PTR [edx]
	divss	xmm0, DWORD PTR [ecx]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 117  : static inline ImVec2 operator/(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x/rhs.x, lhs.y/rhs.y); }

	movss	xmm0, DWORD PTR [edx+4]
	divss	xmm0, DWORD PTR [ecx+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 117  : static inline ImVec2 operator/(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x/rhs.x, lhs.y/rhs.y); }

	pop	ebp
	ret	0
??K@YA?AUImVec2@@ABU0@0@Z ENDP				; operator/
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_lhs$ = 12						; size = 4
_rhs$ = 16						; size = 4
??D@YA?AUImVec2@@ABU0@0@Z PROC				; operator*

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _lhs$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movss	xmm0, DWORD PTR [edx]
	mulss	xmm0, DWORD PTR [ecx]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	movss	xmm0, DWORD PTR [edx+4]
	mulss	xmm0, DWORD PTR [ecx+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	pop	ebp
	ret	0
??D@YA?AUImVec2@@ABU0@0@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_lhs$ = 12						; size = 4
_rhs$ = 16						; size = 4
??G@YA?AUImVec2@@ABU0@0@Z PROC				; operator-

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _lhs$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [edx]
	subss	xmm0, DWORD PTR [ecx]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [edx+4]
	subss	xmm0, DWORD PTR [ecx+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	pop	ebp
	ret	0
??G@YA?AUImVec2@@ABU0@0@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_lhs$ = 12						; size = 4
_rhs$ = 16						; size = 4
??H@YA?AUImVec2@@ABU0@0@Z PROC				; operator+

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _lhs$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [edx]
	addss	xmm0, DWORD PTR [ecx]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [edx+4]
	addss	xmm0, DWORD PTR [ecx+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	pop	ebp
	ret	0
??H@YA?AUImVec2@@ABU0@0@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_lhs$ = 12						; size = 4
_rhs$ = 16						; size = 4
??D@YA?AUImVec2@@ABU0@M@Z PROC				; operator*

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR _lhs$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	movss	xmm0, DWORD PTR [ecx]
	mulss	xmm0, DWORD PTR _rhs$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	movss	xmm0, DWORD PTR [ecx+4]
	mulss	xmm0, DWORD PTR _rhs$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	pop	ebp
	ret	0
??D@YA?AUImVec2@@ABU0@M@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_buf_size$ = 12						; size = 4
_fmt$ = 16						; size = 4
_args$ = 20						; size = 4
?ImFormatStringV@@YAHPADHPBD0@Z PROC			; ImFormatStringV

; 1039 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 1040 :     IM_ASSERT(buf_size > 0);
; 1041 :     int w = vsnprintf(buf, buf_size, fmt, args);

	mov	esi, DWORD PTR _buf_size$[ebp]
	push	edi
	push	DWORD PTR _args$[ebp]
	mov	edi, DWORD PTR _buf$[ebp]
	push	DWORD PTR _fmt$[ebp]
	push	esi
	push	edi
	call	_vsnprintf
	add	esp, 16					; 00000010H

; 1042 :     if (w == -1 || w >= buf_size)

	cmp	eax, -1
	je	SHORT $LN3@ImFormatSt
	cmp	eax, esi
	jl	SHORT $LN6@ImFormatSt
$LN3@ImFormatSt:

; 1043 :         w = buf_size - 1;

	lea	eax, DWORD PTR [esi-1]
$LN6@ImFormatSt:

; 1044 :     buf[w] = 0;

	mov	BYTE PTR [eax+edi], 0
	pop	edi
	pop	esi

; 1045 :     return w;
; 1046 : }

	pop	ebp
	ret	0
?ImFormatStringV@@YAHPADHPBD0@Z ENDP			; ImFormatStringV
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_buf_size$ = 12						; size = 4
_fmt$ = 16						; size = 4
?ImFormatString@@YAHPADHPBDZZ PROC			; ImFormatString

; 1026 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 1027 :     IM_ASSERT(buf_size > 0);
; 1028 :     va_list args;
; 1029 :     va_start(args, fmt);
; 1030 :     int w = vsnprintf(buf, buf_size, fmt, args);

	mov	esi, DWORD PTR _buf_size$[ebp]
	lea	eax, DWORD PTR _fmt$[ebp+4]
	push	edi
	mov	edi, DWORD PTR _buf$[ebp]
	push	eax
	push	DWORD PTR _fmt$[ebp]
	push	esi
	push	edi
	call	_vsnprintf
	add	esp, 16					; 00000010H

; 1031 :     va_end(args);
; 1032 :     if (w == -1 || w >= buf_size)

	cmp	eax, -1
	je	SHORT $LN3@ImFormatSt
	cmp	eax, esi
	jl	SHORT $LN6@ImFormatSt
$LN3@ImFormatSt:

; 1033 :         w = buf_size - 1;

	lea	eax, DWORD PTR [esi-1]
$LN6@ImFormatSt:

; 1034 :     buf[w] = 0;

	mov	BYTE PTR [eax+edi], 0
	pop	edi
	pop	esi

; 1035 :     return w;
; 1036 : }

	pop	ebp
	ret	0
?ImFormatString@@YAHPADHPBDZZ ENDP			; ImFormatString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
tv222 = -4						; size = 4
_haystack$ = 8						; size = 4
_haystack_end$ = 12					; size = 4
_needle$ = 16						; size = 4
_needle_end$ = 20					; size = 4
_un0$1$ = 23						; size = 1
?ImStristr@@YAPBDPBD000@Z PROC				; ImStristr

; 1001 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx

; 1002 :     if (!needle_end)

	mov	ebx, DWORD PTR _needle_end$[ebp]
	push	esi
	push	edi
	test	ebx, ebx
	jne	SHORT $LN7@ImStristr

; 1003 :         needle_end = needle + strlen(needle);

	mov	ebx, DWORD PTR _needle$[ebp]
	mov	ecx, ebx
	lea	edx, DWORD PTR [ecx+1]
$LL25@ImStristr:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL25@ImStristr
	sub	ecx, edx
	add	ebx, ecx
$LN7@ImStristr:

; 1004 : 
; 1005 :     const char un0 = (char)toupper(*needle);

	mov	eax, DWORD PTR _needle$[ebp]
	mov	esi, DWORD PTR __imp__toupper
	movsx	eax, BYTE PTR [eax]
	push	eax
	call	esi
	mov	edi, DWORD PTR _haystack$[ebp]
	add	esp, 4
	mov	BYTE PTR _un0$1$[ebp], al
$LN28@ImStristr:
	mov	eax, DWORD PTR _haystack_end$[ebp]

; 1006 :     while ((!haystack_end && *haystack) || (haystack_end && haystack < haystack_end))

	test	eax, eax
	jne	SHORT $LN23@ImStristr
	cmp	BYTE PTR [edi], al
	jne	SHORT $LN8@ImStristr
$LN3@ImStristr:
	pop	edi
	pop	esi

; 1019 :     return NULL;

	xor	eax, eax
	pop	ebx

; 1020 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@ImStristr:

; 1006 :     while ((!haystack_end && *haystack) || (haystack_end && haystack < haystack_end))

	cmp	edi, eax
	jae	SHORT $LN3@ImStristr
$LN8@ImStristr:

; 1007 :     {
; 1008 :         if (toupper(*haystack) == un0)

	movsx	eax, BYTE PTR [edi]
	push	eax
	call	esi
	movsx	ecx, BYTE PTR _un0$1$[ebp]
	add	esp, 4
	cmp	eax, ecx
	jne	SHORT $LN12@ImStristr

; 1009 :         {
; 1010 :             const char* b = needle + 1;

	mov	esi, DWORD PTR _needle$[ebp]
	inc	esi

; 1011 :             for (const char* a = haystack + 1; b < needle_end; a++, b++)

	cmp	esi, ebx
	jae	SHORT $LN27@ImStristr
	mov	eax, edi
	sub	eax, esi
	inc	eax
	mov	DWORD PTR tv222[ebp], eax
$LL6@ImStristr:

; 1012 :                 if (toupper(*a) != toupper(*b))

	movsx	eax, BYTE PTR [eax+esi]
	push	eax
	call	DWORD PTR __imp__toupper
	movsx	ecx, BYTE PTR [esi]
	mov	edi, eax
	push	ecx
	call	DWORD PTR __imp__toupper
	add	esp, 8
	cmp	edi, eax
	jne	SHORT $LN26@ImStristr

; 1011 :             for (const char* a = haystack + 1; b < needle_end; a++, b++)

	mov	eax, DWORD PTR tv222[ebp]
	inc	esi
	cmp	esi, ebx
	jb	SHORT $LL6@ImStristr
$LN26@ImStristr:
	mov	edi, DWORD PTR _haystack$[ebp]

; 1013 :                     break;
; 1014 :             if (b == needle_end)

	cmp	esi, ebx
$LN27@ImStristr:
	je	SHORT $LN17@ImStristr
	mov	esi, DWORD PTR __imp__toupper
$LN12@ImStristr:

; 1016 :         }
; 1017 :         haystack++;

	inc	edi
	mov	DWORD PTR _haystack$[ebp], edi

; 1018 :     }

	jmp	SHORT $LN28@ImStristr
$LN17@ImStristr:

; 1015 :                 return haystack;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 1020 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ImStristr@@YAPBDPBD000@Z ENDP				; ImStristr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_buf_mid_line$ = 8					; size = 4
_buf_begin$ = 12					; size = 4
?ImStrbolW@@YAPBGPBG0@Z PROC				; ImStrbolW

; 994  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 995  :     while (buf_mid_line > buf_begin && buf_mid_line[-1] != '\n')

	mov	eax, DWORD PTR _buf_mid_line$[ebp]
	mov	edx, DWORD PTR _buf_begin$[ebp]
	cmp	eax, edx
	jbe	SHORT $LN3@ImStrbolW
	npad	1
$LL2@ImStrbolW:
	cmp	WORD PTR [eax-2], 10			; 0000000aH
	je	SHORT $LN3@ImStrbolW

; 996  :         buf_mid_line--;

	add	eax, -2					; fffffffeH
	cmp	eax, edx
	ja	SHORT $LL2@ImStrbolW
$LN3@ImStrbolW:

; 997  :     return buf_mid_line;
; 998  : }

	pop	ebp
	ret	0
?ImStrbolW@@YAPBGPBG0@Z ENDP				; ImStrbolW
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_str$ = 8						; size = 4
?ImStrlenW@@YAHPBG@Z PROC				; ImStrlenW

; 987  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 988  :     int n = 0;
; 989  :     while (*str++) n++;

	mov	ecx, DWORD PTR _str$[ebp]
	xor	eax, eax
	cmp	WORD PTR [ecx], ax
	je	SHORT $LN6@ImStrlenW
	npad	1
$LL2@ImStrlenW:
	lea	ecx, DWORD PTR [ecx+2]
	inc	eax
	cmp	WORD PTR [ecx], 0
	jne	SHORT $LL2@ImStrlenW
$LN6@ImStrlenW:

; 990  :     return n;
; 991  : }

	pop	ebp
	ret	0
?ImStrlenW@@YAHPBG@Z ENDP				; ImStrlenW
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_str$ = 8						; size = 4
?ImStrdup@@YAPADPBD@Z PROC				; ImStrdup

; 980  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 981  :     size_t len = strlen(str) + 1;

	mov	eax, DWORD PTR _str$[ebp]
	lea	edx, DWORD PTR [eax+1]
	npad	5
$LL3@ImStrdup:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL3@ImStrdup
	sub	eax, edx
	push	esi
	lea	esi, DWORD PTR [eax+1]

; 982  :     void* buff = ImGui::MemAlloc(len);

	push	esi
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 983  :     return (char*)memcpy(buff, (const void*)str, len);

	push	esi
	push	DWORD PTR _str$[ebp]
	push	eax
	call	_memcpy
	add	esp, 16					; 00000010H
	pop	esi

; 984  : }

	pop	ebp
	ret	0
?ImStrdup@@YAPADPBD@Z ENDP				; ImStrdup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_str1$ = 8						; size = 4
_str2$ = 12						; size = 4
_count$ = 16						; size = 4
?ImStrnicmp@@YAHPBD0H@Z PROC				; ImStrnicmp

; 966  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	edi

; 967  :     int d = 0;
; 968  :     while (count > 0 && (d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; count--; }

	mov	edi, DWORD PTR _count$[ebp]
	test	edi, edi
	jle	SHORT $LN9@ImStrnicmp
	mov	eax, DWORD PTR _str2$[ebp]
	push	esi
	mov	esi, DWORD PTR _str1$[ebp]
	sub	eax, esi
	mov	DWORD PTR _str2$[ebp], eax
	push	ebx
	npad	6
$LL2@ImStrnicmp:
	movsx	eax, BYTE PTR [eax+esi]
	push	eax
	call	DWORD PTR __imp__toupper
	mov	ebx, eax
	movsx	eax, BYTE PTR [esi]
	push	eax
	call	DWORD PTR __imp__toupper
	add	esp, 8
	sub	ebx, eax
	jne	SHORT $LN10@ImStrnicmp
	cmp	BYTE PTR [esi], bl
	je	SHORT $LN10@ImStrnicmp
	mov	eax, DWORD PTR _str2$[ebp]
	dec	edi
	inc	esi
	test	edi, edi
	jg	SHORT $LL2@ImStrnicmp
$LN10@ImStrnicmp:

; 969  :     return d;

	mov	eax, ebx
	pop	ebx
	pop	esi
	pop	edi

; 970  : }

	pop	ebp
	ret	0
$LN9@ImStrnicmp:

; 969  :     return d;

	xor	eax, eax
	pop	edi

; 970  : }

	pop	ebp
	ret	0
?ImStrnicmp@@YAHPBD0H@Z ENDP				; ImStrnicmp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_str1$ = 8						; size = 4
_str2$ = 12						; size = 4
?ImStricmp@@YAHPBD0@Z PROC				; ImStricmp

; 959  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx

; 960  :     int d;
; 961  :     while ((d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; }

	mov	ebx, DWORD PTR __imp__toupper
	push	esi
	mov	esi, DWORD PTR _str1$[ebp]
	push	edi
	movsx	eax, BYTE PTR [esi]
	push	eax
	call	ebx
	mov	edi, eax
	mov	eax, DWORD PTR _str2$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	ebx
	mov	ebx, eax
	add	esp, 8
	sub	ebx, edi
	jne	SHORT $LN9@ImStricmp
	mov	eax, DWORD PTR _str2$[ebp]
	mov	edi, DWORD PTR __imp__toupper
	sub	eax, esi
	mov	DWORD PTR _str2$[ebp], eax
	npad	7
$LL2@ImStricmp:
	cmp	BYTE PTR [esi], 0
	je	SHORT $LN9@ImStricmp
	movsx	eax, BYTE PTR [eax+esi+1]
	inc	esi
	push	eax
	call	edi
	movsx	ecx, BYTE PTR [esi]
	mov	ebx, eax
	push	ecx
	call	edi
	add	esp, 8
	sub	ebx, eax
	mov	eax, DWORD PTR _str2$[ebp]
	je	SHORT $LL2@ImStricmp
$LN9@ImStricmp:
	pop	edi
	pop	esi

; 962  :     return d;

	mov	eax, ebx
	pop	ebx

; 963  : }

	pop	ebp
	ret	0
?ImStricmp@@YAHPBD0@Z ENDP				; ImStricmp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
_TEXT	SEGMENT
_c$ = 8							; size = 4
?ImCharIsSpace@@YA_NH@Z PROC				; ImCharIsSpace

; 96   : static inline bool      ImCharIsSpace(int c)            { return c == ' ' || c == '\t' || c == 0x3000; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _c$[ebp]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN3@ImCharIsSp
	cmp	eax, 9
	je	SHORT $LN3@ImCharIsSp
	cmp	eax, 12288				; 00003000H
	je	SHORT $LN3@ImCharIsSp
	xor	al, al
	pop	ebp
	ret	0
$LN3@ImCharIsSp:
	mov	al, 1
	pop	ebp
	ret	0
?ImCharIsSpace@@YA_NH@Z ENDP				; ImCharIsSpace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_p$ = 8							; size = 4
_a$ = 12						; size = 4
_b$ = 16						; size = 4
_c$ = 20						; size = 4
?ImIsPointInTriangle@@YA_NABUImVec2@@000@Z PROC		; ImIsPointInTriangle

; 951  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 952  :     bool b1 = ((p.x - b.x) * (a.y - b.y) - (p.y - b.y) * (a.x - b.x)) < 0.0f;
; 953  :     bool b2 = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0f;

	mov	eax, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	movss	xmm5, DWORD PTR [eax]
	movss	xmm4, DWORD PTR [edx+4]
	movaps	xmm2, xmm5
	movss	xmm7, DWORD PTR [ecx+4]
	movaps	xmm0, xmm4
	movss	xmm6, DWORD PTR [ecx]
	subss	xmm0, xmm7
	movss	xmm3, DWORD PTR [edx]
	subss	xmm2, xmm6
	mov	ecx, DWORD PTR _a$[ebp]
	movaps	xmm1, xmm3
	subss	xmm1, xmm6
	mulss	xmm2, xmm0
	movss	xmm0, DWORD PTR [eax+4]
	subss	xmm0, xmm7
	mulss	xmm1, xmm0
	xorps	xmm0, xmm0
	subss	xmm2, xmm1
	movss	xmm1, DWORD PTR [ecx]
	subss	xmm1, xmm3
	comiss	xmm0, xmm2
	movss	xmm0, DWORD PTR [ecx+4]
	movaps	xmm2, xmm5
	subss	xmm0, xmm4
	subss	xmm2, xmm3
	seta	dl
	movss	xmm3, DWORD PTR [eax+4]
	mulss	xmm2, xmm0
	movaps	xmm0, xmm3
	subss	xmm0, xmm4
	xorps	xmm4, xmm4
	mulss	xmm1, xmm0
	subss	xmm2, xmm1
	comiss	xmm4, xmm2
	seta	al

; 955  :     return ((b1 == b2) && (b2 == b3));

	cmp	al, dl
	jne	SHORT $LN3@ImIsPointI

; 954  :     bool b3 = ((p.x - a.x) * (c.y - a.y) - (p.y - a.y) * (c.x - a.x)) < 0.0f;

	subss	xmm5, DWORD PTR [ecx]
	subss	xmm7, DWORD PTR [ecx+4]
	subss	xmm6, DWORD PTR [ecx]
	subss	xmm3, DWORD PTR [ecx+4]
	mulss	xmm5, xmm7
	mulss	xmm6, xmm3
	subss	xmm5, xmm6
	comiss	xmm4, xmm5
	seta	al

; 955  :     return ((b1 == b2) && (b2 == b3));

	cmp	dl, al
	jne	SHORT $LN3@ImIsPointI
	mov	al, 1

; 956  : }

	pop	ebp
	ret	0
$LN3@ImIsPointI:

; 955  :     return ((b1 == b2) && (b2 == b3));

	xor	al, al

; 956  : }

	pop	ebp
	ret	0
?ImIsPointInTriangle@@YA_NABUImVec2@@000@Z ENDP		; ImIsPointInTriangle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_buf$ = -28						; size = 12
_filename_wsize$1$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
_filename$ = 8						; size = 4
_mode$ = 12						; size = 4
?ImFileOpen@@YAPAU_iobuf@@PBD0@Z PROC			; ImFileOpen

; 1354 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ImFileOpen@@YAPAU_iobuf@@PBD0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi

; 1355 : #if defined(_WIN32) && !defined(__CYGWIN__)
; 1356 :     // We need a fopen() wrapper because MSVC/Windows fopen doesn't handle UTF-8 filenames. Converting both strings from UTF-8 to wchar format (using a single allocation, because we can)
; 1357 :     const int filename_wsize = ImTextCountCharsFromUtf8(filename, NULL) + 1;

	mov	esi, DWORD PTR _filename$[ebp]
	push	edi
	push	0
	push	esi
	call	?ImTextCountCharsFromUtf8@@YAHPBD0@Z	; ImTextCountCharsFromUtf8

; 1358 :     const int mode_wsize = ImTextCountCharsFromUtf8(mode, NULL) + 1;

	mov	ebx, DWORD PTR _mode$[ebp]
	inc	eax
	push	0
	push	ebx
	mov	DWORD PTR _filename_wsize$1$[ebp], eax
	call	?ImTextCountCharsFromUtf8@@YAHPBD0@Z	; ImTextCountCharsFromUtf8
	add	esp, 16					; 00000010H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR _buf$[ebp+4], 0
	mov	DWORD PTR _buf$[ebp], 0
	mov	DWORD PTR _buf$[ebp+8], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1358 :     const int mode_wsize = ImTextCountCharsFromUtf8(mode, NULL) + 1;

	lea	edi, DWORD PTR [eax+1]

; 1359 :     ImVector<ImWchar> buf;
; 1360 :     buf.resize(filename_wsize + mode_wsize);

	mov	ecx, DWORD PTR _filename_wsize$1$[ebp]
	add	ecx, edi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	ecx
	lea	ecx, DWORD PTR _buf$[ebp]
	call	?resize@?$ImVector@G@@QAEXH@Z		; ImVector<unsigned short>::resize

; 1361 :     ImTextStrFromUtf8(&buf[0], filename_wsize, filename, NULL);

	push	0
	push	0
	push	esi
	mov	esi, DWORD PTR _filename_wsize$1$[ebp]
	push	esi
	push	DWORD PTR _buf$[ebp+8]
	call	?ImTextStrFromUtf8@@YAHPAGHPBD1PAPBD@Z	; ImTextStrFromUtf8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	mov	eax, DWORD PTR _buf$[ebp+8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1362 :     ImTextStrFromUtf8(&buf[filename_wsize], mode_wsize, mode, NULL);

	push	0
	push	0
	push	ebx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	lea	esi, DWORD PTR [eax+esi*2]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1362 :     ImTextStrFromUtf8(&buf[filename_wsize], mode_wsize, mode, NULL);

	push	edi
	push	esi
	call	?ImTextStrFromUtf8@@YAHPAGHPBD1PAPBD@Z	; ImTextStrFromUtf8

; 1363 :     return _wfopen((wchar_t*)&buf[0], (wchar_t*)&buf[filename_wsize]);

	mov	ebx, DWORD PTR _buf$[ebp+8]
	push	esi
	push	ebx
	call	DWORD PTR __imp___wfopen
	add	esp, 48					; 00000030H
	mov	esi, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	ebx, ebx
	je	SHORT $LN18@ImFileOpen
	push	ebx
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN18@ImFileOpen:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1367 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ImFileOpen@@YAPAU_iobuf@@PBD0@Z$0:
	lea	ecx, DWORD PTR _buf$[ebp]
	jmp	??1?$ImVector@G@@QAE@XZ			; ImVector<unsigned short>::~ImVector<unsigned short>
__ehhandler$?ImFileOpen@@YAPAU_iobuf@@PBD0@Z:
	mov	eax, OFFSET __ehfuncinfo$?ImFileOpen@@YAPAU_iobuf@@PBD0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ImFileOpen@@YAPAU_iobuf@@PBD0@Z ENDP			; ImFileOpen
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_file_open_mode$ = 12					; size = 4
_file_data$1$ = 16					; size = 4
_out_file_size$ = 16					; size = 4
_padding_bytes$ = 20					; size = 4
?ImFileLoadToMemory@@YAPAXPBD0PAHH@Z PROC		; ImFileLoadToMemory

; 1372 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 1373 :     IM_ASSERT(filename && file_open_mode);
; 1374 :     if (out_file_size)

	mov	edi, DWORD PTR _out_file_size$[ebp]
	test	edi, edi
	je	SHORT $LN2@ImFileLoad

; 1375 :         *out_file_size = 0;

	mov	DWORD PTR [edi], 0
$LN2@ImFileLoad:

; 1376 : 
; 1377 :     FILE* f;
; 1378 :     if ((f = ImFileOpen(filename, file_open_mode)) == NULL)

	push	DWORD PTR _file_open_mode$[ebp]
	push	DWORD PTR _filename$[ebp]
	call	?ImFileOpen@@YAPAU_iobuf@@PBD0@Z	; ImFileOpen
	mov	esi, eax
	add	esp, 8
	test	esi, esi
	jne	SHORT $LN3@ImFileLoad
	pop	edi
	pop	esi

; 1409 : }

	pop	ebp
	ret	0
$LN3@ImFileLoad:
	push	ebx

; 1379 :         return NULL;
; 1380 : 
; 1381 :     long file_size_signed;
; 1382 :     if (fseek(f, 0, SEEK_END) || (file_size_signed = ftell(f)) == -1 || fseek(f, 0, SEEK_SET))

	push	2
	push	0
	push	esi
	call	DWORD PTR __imp__fseek
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN5@ImFileLoad
	push	esi
	call	DWORD PTR __imp__ftell
	mov	ebx, eax
	add	esp, 4
	cmp	ebx, -1
	je	$LN5@ImFileLoad
	push	0
	push	0
	push	esi
	call	DWORD PTR __imp__fseek
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@ImFileLoad

; 1386 :     }
; 1387 : 
; 1388 :     int file_size = (int)file_size_signed;
; 1389 :     void* file_data = ImGui::MemAlloc(file_size + padding_bytes);

	mov	eax, DWORD PTR _padding_bytes$[ebp]
	add	eax, ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	add	esp, 4
	mov	DWORD PTR _file_data$1$[ebp], eax

; 1390 :     if (file_data == NULL)
; 1391 :     {
; 1392 :         fclose(f);

	push	esi
	test	eax, eax
	je	SHORT $LN12@ImFileLoad

; 1393 :         return NULL;
; 1394 :     }
; 1395 :     if (fread(file_data, 1, (size_t)file_size, f) != (size_t)file_size)

	push	ebx
	push	1
	push	eax
	call	DWORD PTR __imp__fread
	add	esp, 16					; 00000010H
	cmp	eax, ebx
	je	SHORT $LN7@ImFileLoad

; 1396 :     {
; 1397 :         fclose(f);

	push	esi
	call	DWORD PTR __imp__fclose

; 1398 :         ImGui::MemFree(file_data);

	mov	eax, DWORD PTR _file_data$1$[ebp]
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 8
	xor	eax, eax
	pop	ebx
	pop	edi
	pop	esi

; 1409 : }

	pop	ebp
	ret	0
$LN7@ImFileLoad:

; 1399 :         return NULL;
; 1400 :     }
; 1401 :     if (padding_bytes > 0)

	mov	eax, DWORD PTR _padding_bytes$[ebp]
	test	eax, eax
	jle	SHORT $LN8@ImFileLoad

; 1402 :         memset((void *)(((char*)file_data) + file_size), 0, padding_bytes);

	push	eax
	mov	eax, DWORD PTR _file_data$1$[ebp]
	add	eax, ebx
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN8@ImFileLoad:

; 1403 : 
; 1404 :     fclose(f);

	push	esi
	call	DWORD PTR __imp__fclose
	add	esp, 4

; 1405 :     if (out_file_size)

	test	edi, edi
	je	SHORT $LN9@ImFileLoad

; 1406 :         *out_file_size = file_size;

	mov	DWORD PTR [edi], ebx
$LN9@ImFileLoad:

; 1407 : 
; 1408 :     return file_data;

	mov	eax, DWORD PTR _file_data$1$[ebp]
	pop	ebx
	pop	edi
	pop	esi

; 1409 : }

	pop	ebp
	ret	0
$LN5@ImFileLoad:

; 1383 :     {
; 1384 :         fclose(f);

	push	esi
$LN12@ImFileLoad:
	call	DWORD PTR __imp__fclose
	add	esp, 4

; 1385 :         return NULL;

	xor	eax, eax
	pop	ebx
	pop	edi
	pop	esi

; 1409 : }

	pop	ebp
	ret	0
?ImFileLoadToMemory@@YAPAXPBD0PAHH@Z ENDP		; ImFileLoadToMemory
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_data$ = 8						; size = 4
_data_size$ = 12					; size = 4
_seed$ = 16						; size = 4
?ImHash@@YAIPBXHI@Z PROC				; ImHash

; 1051 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1052 :     static ImU32 crc32_lut[256] = { };
; 1053 :     if (!crc32_lut[1])

	cmp	DWORD PTR ?crc32_lut@?1??ImHash@@YAIPBXHI@Z@4PAIA+4, 0
	jne	$LN3@ImHash

; 1054 :     {
; 1055 :         const ImU32 polynomial = 0xEDB88320;
; 1056 :         for (ImU32 i = 0; i < 256; i++)

	xor	edx, edx
$LL4@ImHash:

; 1057 :         {
; 1058 :             ImU32 crc = i;
; 1059 :             for (ImU32 j = 0; j < 8; j++)
; 1060 :                 crc = (crc >> 1) ^ (ImU32(-int(crc & 1)) & polynomial);

	mov	ecx, edx
	mov	eax, edx
	and	ecx, 1
	shr	eax, 1
	neg	ecx
	and	ecx, -306674912				; edb88320H
	xor	ecx, eax
	mov	eax, ecx
	shr	ecx, 1
	and	eax, 1
	neg	eax
	and	eax, -306674912				; edb88320H
	xor	eax, ecx
	mov	ecx, eax
	shr	eax, 1
	and	ecx, 1
	neg	ecx
	and	ecx, -306674912				; edb88320H
	xor	ecx, eax
	mov	eax, ecx
	shr	ecx, 1
	and	eax, 1
	neg	eax
	and	eax, -306674912				; edb88320H
	xor	eax, ecx
	mov	ecx, eax
	shr	eax, 1
	and	ecx, 1
	neg	ecx
	and	ecx, -306674912				; edb88320H
	xor	ecx, eax
	mov	eax, ecx
	shr	ecx, 1
	and	eax, 1
	neg	eax
	and	eax, -306674912				; edb88320H
	xor	eax, ecx
	mov	ecx, eax
	shr	eax, 1
	and	ecx, 1
	neg	ecx
	and	ecx, -306674912				; edb88320H
	xor	ecx, eax
	mov	eax, ecx
	shr	ecx, 1
	and	eax, 1
	neg	eax
	and	eax, -306674912				; edb88320H
	xor	eax, ecx

; 1061 :             crc32_lut[i] = crc;

	mov	DWORD PTR ?crc32_lut@?1??ImHash@@YAIPBXHI@Z@4PAIA[edx*4], eax
	inc	edx
	cmp	edx, 256				; 00000100H
	jb	$LL4@ImHash
$LN3@ImHash:
	push	ebx

; 1062 :         }
; 1063 :     }
; 1064 : 
; 1065 :     seed = ~seed;

	mov	ebx, DWORD PTR _seed$[ebp]
	push	esi

; 1066 :     ImU32 crc = seed;
; 1067 :     const unsigned char* current = (const unsigned char*)data;

	mov	esi, DWORD PTR _data$[ebp]
	not	ebx
	push	edi

; 1068 : 
; 1069 :     if (data_size > 0)

	mov	edi, DWORD PTR _data_size$[ebp]
	mov	eax, ebx
	test	edi, edi
	jle	SHORT $LN20@ImHash
$LL8@ImHash:

; 1070 :     {
; 1071 :         // Known size
; 1072 :         while (data_size--)
; 1073 :             crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ *current++];

	movzx	ecx, BYTE PTR [esi]
	lea	esi, DWORD PTR [esi+1]
	movzx	edx, al
	xor	edx, ecx
	shr	eax, 8
	xor	eax, DWORD PTR ?crc32_lut@?1??ImHash@@YAIPBXHI@Z@4PAIA[edx*4]
	sub	edi, 1
	jne	SHORT $LL8@ImHash

; 1087 :         }
; 1088 :     }
; 1089 :     return ~crc;

	pop	edi
	pop	esi
	not	eax
	pop	ebx

; 1090 : }

	pop	ebp
	ret	0
$LN20@ImHash:

; 1074 :     }
; 1075 :     else
; 1076 :     {
; 1077 :         // Zero-terminated string
; 1078 :         while (unsigned char c = *current++)

	mov	cl, BYTE PTR [esi]
	inc	esi
	test	cl, cl
	je	SHORT $LN11@ImHash
	npad	6
$LL10@ImHash:

; 1079 :         {
; 1080 :             // We support a syntax of "label###id" where only "###id" is included in the hash, and only "label" gets displayed.
; 1081 :             // Because this syntax is rarely used we are optimizing for the common case.
; 1082 :             // - If we reach ### in the string we discard the hash so far and reset to the seed.
; 1083 :             // - We don't do 'current += 2; continue;' after handling ### to keep the code smaller.
; 1084 :             if (c == '#' && current[0] == '#' && current[1] == '#')

	cmp	cl, 35					; 00000023H
	jne	SHORT $LN15@ImHash
	cmp	BYTE PTR [esi], cl
	jne	SHORT $LN15@ImHash
	cmp	BYTE PTR [esi+1], cl
	cmove	eax, ebx
$LN15@ImHash:

; 1085 :                 crc = seed;
; 1086 :             crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];

	movzx	edx, al
	movzx	ecx, cl
	xor	edx, ecx
	shr	eax, 8
	mov	cl, BYTE PTR [esi]
	inc	esi
	xor	eax, DWORD PTR ?crc32_lut@?1??ImHash@@YAIPBXHI@Z@4PAIA[edx*4]
	test	cl, cl
	jne	SHORT $LL10@ImHash
$LN11@ImHash:
	pop	edi
	pop	esi

; 1087 :         }
; 1088 :     }
; 1089 :     return ~crc;

	not	eax
	pop	ebx

; 1090 : }

	pop	ebp
	ret	0
?ImHash@@YAIPBXHI@Z ENDP				; ImHash
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_in_text$ = 8						; size = 4
_in_text_end$ = 12					; size = 4
?ImTextCountUtf8BytesFromStr@@YAHPBG0@Z PROC		; ImTextCountUtf8BytesFromStr

; 1255 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1256 :     int bytes_count = 0;

	mov	edx, DWORD PTR _in_text$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _in_text_end$[ebp]
	xor	esi, esi
	mov	ebx, 1023				; 000003ffH
$LL2@ImTextCoun:

; 1257 :     while ((!in_text_end || in_text < in_text_end) && *in_text)

	test	edi, edi
	je	SHORT $LN4@ImTextCoun
	cmp	edx, edi
	jae	SHORT $LN18@ImTextCoun
$LN4@ImTextCoun:
	movzx	eax, WORD PTR [edx]
	test	ax, ax
	je	SHORT $LN18@ImTextCoun

; 1258 :     {
; 1259 :         unsigned int c = (unsigned int)(*in_text++);

	mov	ecx, eax
	add	edx, 2

; 1260 :         if (c < 0x80)

	cmp	ecx, 128				; 00000080H
	jae	SHORT $LN5@ImTextCoun

; 1261 :             bytes_count++;

	mov	eax, 1
	add	esi, eax

; 1262 :         else
; 1263 :             bytes_count += ImTextCountUtf8BytesFromChar(c);
; 1264 :     }

	jmp	SHORT $LL2@ImTextCoun
$LN5@ImTextCoun:

; 1232 :     if (c < 0x800) return 2;

	cmp	ecx, 2048				; 00000800H
	jae	SHORT $LN10@ImTextCoun
	mov	eax, 2
	add	esi, eax

; 1262 :         else
; 1263 :             bytes_count += ImTextCountUtf8BytesFromChar(c);
; 1264 :     }

	jmp	SHORT $LL2@ImTextCoun
$LN10@ImTextCoun:

; 1233 :     if (c >= 0xdc00 && c < 0xe000) return 0;

	lea	eax, DWORD PTR [ecx-56320]
	cmp	eax, 1023				; 000003ffH
	ja	SHORT $LN11@ImTextCoun
	xor	eax, eax
	add	esi, eax

; 1262 :         else
; 1263 :             bytes_count += ImTextCountUtf8BytesFromChar(c);
; 1264 :     }

	jmp	SHORT $LL2@ImTextCoun
$LN11@ImTextCoun:

; 1234 :     if (c >= 0xd800 && c < 0xdc00) return 4;

	lea	eax, DWORD PTR [ecx-55296]
	cmp	ebx, eax
	sbb	eax, eax
	add	eax, 4
	add	esi, eax

; 1262 :         else
; 1263 :             bytes_count += ImTextCountUtf8BytesFromChar(c);
; 1264 :     }

	jmp	SHORT $LL2@ImTextCoun
$LN18@ImTextCoun:
	pop	edi

; 1265 :     return bytes_count;

	mov	eax, esi
	pop	esi
	pop	ebx

; 1266 : }

	pop	ebp
	ret	0
?ImTextCountUtf8BytesFromStr@@YAHPBG0@Z ENDP		; ImTextCountUtf8BytesFromStr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_in_text$ = 8						; size = 4
_c$1 = 12						; size = 4
_in_text_end$ = 12					; size = 4
?ImTextCountCharsFromUtf8@@YAHPBD0@Z PROC		; ImTextCountCharsFromUtf8

; 1177 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx

; 1178 :     int char_count = 0;

	mov	ebx, DWORD PTR _in_text_end$[ebp]
	push	esi
	mov	esi, DWORD PTR _in_text$[ebp]
	push	edi
	xor	edi, edi
$LL2@ImTextCoun:

; 1179 :     while ((!in_text_end || in_text < in_text_end) && *in_text)

	test	ebx, ebx
	je	SHORT $LN4@ImTextCoun
	cmp	esi, ebx
	jae	SHORT $LN14@ImTextCoun
$LN4@ImTextCoun:
	cmp	BYTE PTR [esi], 0
	je	SHORT $LN14@ImTextCoun

; 1180 :     {
; 1181 :         unsigned int c;
; 1182 :         in_text += ImTextCharFromUtf8(&c, in_text, in_text_end);

	push	ebx
	lea	eax, DWORD PTR _c$1[ebp]
	push	esi
	push	eax
	call	?ImTextCharFromUtf8@@YAHPAIPBD1@Z	; ImTextCharFromUtf8
	add	esi, eax
	add	esp, 12					; 0000000cH

; 1183 :         if (c == 0)

	mov	eax, DWORD PTR _c$1[ebp]
	test	eax, eax
	je	SHORT $LN14@ImTextCoun

; 1184 :             break;
; 1185 :         if (c < 0x10000)

	cmp	eax, 65536				; 00010000H
	jae	SHORT $LL2@ImTextCoun

; 1186 :             char_count++;

	inc	edi

; 1187 :     }

	jmp	SHORT $LL2@ImTextCoun
$LN14@ImTextCoun:

; 1188 :     return char_count;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 1189 : }

	pop	ebp
	ret	0
?ImTextCountCharsFromUtf8@@YAHPBD0@Z ENDP		; ImTextCountCharsFromUtf8
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
tv188 = -4						; size = 4
_buf$ = 8						; size = 4
_c$1 = 12						; size = 4
_buf_size$ = 12						; size = 4
_in_text$ = 16						; size = 4
_in_text_end$ = 20					; size = 4
_in_text_remaining$ = 24				; size = 4
?ImTextStrFromUtf8@@YAHPAGHPBD1PAPBD@Z PROC		; ImTextStrFromUtf8

; 1158 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 1159 :     ImWchar* buf_out = buf;

	mov	ecx, DWORD PTR _buf$[ebp]
	mov	eax, DWORD PTR _buf_size$[ebp]
	dec	eax
	push	esi
	push	edi

; 1160 :     ImWchar* buf_end = buf + buf_size;
; 1161 :     while (buf_out < buf_end-1 && (!in_text_end || in_text < in_text_end) && *in_text)

	mov	edi, DWORD PTR _in_text$[ebp]
	mov	esi, ecx
	lea	eax, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR tv188[ebp], eax
	cmp	ecx, eax
	jae	SHORT $LN10@ImTextStrF
	push	ebx
	mov	ebx, DWORD PTR _in_text_end$[ebp]
$LL2@ImTextStrF:
	test	ebx, ebx
	je	SHORT $LN4@ImTextStrF
	cmp	edi, ebx
	jae	SHORT $LN16@ImTextStrF
$LN4@ImTextStrF:
	cmp	BYTE PTR [edi], 0
	je	SHORT $LN16@ImTextStrF

; 1162 :     {
; 1163 :         unsigned int c;
; 1164 :         in_text += ImTextCharFromUtf8(&c, in_text, in_text_end);

	push	ebx
	lea	eax, DWORD PTR _c$1[ebp]
	push	edi
	push	eax
	call	?ImTextCharFromUtf8@@YAHPAIPBD1@Z	; ImTextCharFromUtf8
	add	edi, eax
	add	esp, 12					; 0000000cH

; 1165 :         if (c == 0)

	mov	eax, DWORD PTR _c$1[ebp]
	test	eax, eax
	je	SHORT $LN16@ImTextStrF

; 1166 :             break;
; 1167 :         if (c < 0x10000)    // FIXME: Losing characters that don't fit in 2 bytes

	cmp	eax, 65536				; 00010000H
	jae	SHORT $LN6@ImTextStrF

; 1168 :             *buf_out++ = (ImWchar)c;

	mov	WORD PTR [esi], ax
	add	esi, 2
$LN6@ImTextStrF:

; 1160 :     ImWchar* buf_end = buf + buf_size;
; 1161 :     while (buf_out < buf_end-1 && (!in_text_end || in_text < in_text_end) && *in_text)

	cmp	esi, DWORD PTR tv188[ebp]
	jb	SHORT $LL2@ImTextStrF
$LN16@ImTextStrF:
	mov	ecx, DWORD PTR _buf$[ebp]
	pop	ebx
$LN10@ImTextStrF:

; 1169 :     }
; 1170 :     *buf_out = 0;

	xor	eax, eax
	mov	WORD PTR [esi], ax

; 1171 :     if (in_text_remaining)

	mov	eax, DWORD PTR _in_text_remaining$[ebp]
	test	eax, eax
	je	SHORT $LN7@ImTextStrF

; 1172 :         *in_text_remaining = in_text;

	mov	DWORD PTR [eax], edi
$LN7@ImTextStrF:

; 1173 :     return (int)(buf_out - buf);

	sub	esi, ecx
	sar	esi, 1
	pop	edi
	mov	eax, esi
	pop	esi

; 1174 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ImTextStrFromUtf8@@YAHPAGHPBD1PAPBD@Z ENDP		; ImTextStrFromUtf8
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_out_char$ = 8						; size = 4
_in_text$ = 12						; size = 4
_in_text_end$ = 16					; size = 4
?ImTextCharFromUtf8@@YAHPAIPBD1@Z PROC			; ImTextCharFromUtf8

; 1100 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1101 :     unsigned int c = (unsigned int)-1;
; 1102 :     const unsigned char* str = (const unsigned char*)in_text;
; 1103 :     if (!(*str & 0x80))

	mov	ecx, DWORD PTR _in_text$[ebp]
	mov	dl, BYTE PTR [ecx]
	test	dl, dl
	js	SHORT $LN2@ImTextChar

; 1104 :     {
; 1105 :         c = (unsigned int)(*str++);
; 1106 :         *out_char = c;

	mov	eax, DWORD PTR _out_char$[ebp]
	movzx	ecx, dl
	mov	DWORD PTR [eax], ecx

; 1107 :         return 1;

	mov	eax, 1

; 1155 : }

	pop	ebp
	ret	0
$LN2@ImTextChar:

; 1108 :     }
; 1109 :     if ((*str & 0xe0) == 0xc0)

	mov	al, dl
	and	al, 224					; 000000e0H
	push	esi
	cmp	al, 192					; 000000c0H
	jne	SHORT $LN3@ImTextChar

; 1110 :     {
; 1111 :         *out_char = 0xFFFD; // will be invalid but not end of string

	mov	esi, DWORD PTR _out_char$[ebp]

; 1112 :         if (in_text_end && in_text_end - (const char*)str < 2) return 1;

	mov	eax, DWORD PTR _in_text_end$[ebp]
	mov	DWORD PTR [esi], 65533			; 0000fffdH
	test	eax, eax
	je	SHORT $LN4@ImTextChar
	sub	eax, ecx
	cmp	eax, 2
	jge	SHORT $LN4@ImTextChar
	mov	eax, 1
	pop	esi

; 1155 : }

	pop	ebp
	ret	0
$LN4@ImTextChar:

; 1113 :         if (*str < 0xc2) return 2;

	mov	al, BYTE PTR [ecx]
	cmp	al, 194					; 000000c2H
	jb	SHORT $LN30@ImTextChar

; 1114 :         c = (unsigned int)((*str++ & 0x1f) << 6);
; 1115 :         if ((*str & 0xc0) != 0x80) return 2;

	mov	cl, BYTE PTR [ecx+1]
	movzx	edx, al
	mov	al, cl
	and	edx, 31					; 0000001fH
	and	al, 192					; 000000c0H
	shl	edx, 6
	cmp	al, 128					; 00000080H
	jne	SHORT $LN30@ImTextChar

; 1116 :         c += (*str++ & 0x3f);
; 1117 :         *out_char = c;

	movzx	eax, cl
	and	eax, 63					; 0000003fH
	add	eax, edx
	mov	DWORD PTR [esi], eax
$LN30@ImTextChar:

; 1118 :         return 2;

	mov	eax, 2
	pop	esi

; 1155 : }

	pop	ebp
	ret	0
$LN3@ImTextChar:

; 1119 :     }
; 1120 :     if ((*str & 0xf0) == 0xe0)

	mov	al, dl
	and	al, 240					; 000000f0H
	push	ebx
	cmp	al, 224					; 000000e0H
	jne	SHORT $LN7@ImTextChar

; 1121 :     {
; 1122 :         *out_char = 0xFFFD; // will be invalid but not end of string

	mov	esi, DWORD PTR _out_char$[ebp]

; 1123 :         if (in_text_end && in_text_end - (const char*)str < 3) return 1;

	mov	eax, DWORD PTR _in_text_end$[ebp]
	mov	DWORD PTR [esi], 65533			; 0000fffdH
	test	eax, eax
	je	SHORT $LN8@ImTextChar
	sub	eax, ecx
	cmp	eax, 3
	jl	SHORT $LN28@ImTextChar
$LN8@ImTextChar:

; 1124 :         if (*str == 0xe0 && (str[1] < 0xa0 || str[1] > 0xbf)) return 3;

	mov	al, BYTE PTR [ecx]
	cmp	al, 224					; 000000e0H
	jne	SHORT $LN9@ImTextChar
	mov	dl, BYTE PTR [ecx+1]
	cmp	dl, 160					; 000000a0H
	jb	SHORT $LN29@ImTextChar
	cmp	dl, 191					; 000000bfH
	ja	SHORT $LN29@ImTextChar
$LN9@ImTextChar:

; 1125 :         if (*str == 0xed && str[1] > 0x9f) return 3; // str[1] < 0x80 is checked below

	cmp	al, 237					; 000000edH
	jne	SHORT $LN11@ImTextChar
	cmp	BYTE PTR [ecx+1], 159			; 0000009fH
	ja	SHORT $LN29@ImTextChar
$LN11@ImTextChar:

; 1126 :         c = (unsigned int)((*str++ & 0x0f) << 12);
; 1127 :         if ((*str & 0xc0) != 0x80) return 3;

	mov	bl, BYTE PTR [ecx+1]
	movzx	edx, al
	mov	al, bl
	and	edx, 15					; 0000000fH
	and	al, 192					; 000000c0H
	shl	edx, 12					; 0000000cH
	cmp	al, 128					; 00000080H
	jne	SHORT $LN29@ImTextChar

; 1128 :         c += (unsigned int)((*str++ & 0x3f) << 6);

	add	ecx, 2
	movzx	eax, bl
	and	eax, 63					; 0000003fH
	shl	eax, 6
	add	edx, eax

; 1129 :         if ((*str & 0xc0) != 0x80) return 3;

	mov	cl, BYTE PTR [ecx]
	mov	al, cl
	and	al, 192					; 000000c0H
	cmp	al, 128					; 00000080H
	jne	SHORT $LN29@ImTextChar

; 1130 :         c += (*str++ & 0x3f);
; 1131 :         *out_char = c;

	movzx	eax, cl
	and	eax, 63					; 0000003fH
	add	eax, edx
	mov	DWORD PTR [esi], eax
$LN29@ImTextChar:

; 1132 :         return 3;

	pop	ebx
	mov	eax, 3
	pop	esi

; 1155 : }

	pop	ebp
	ret	0
$LN7@ImTextChar:

; 1133 :     }
; 1134 :     if ((*str & 0xf8) == 0xf0)

	and	dl, 248					; 000000f8H
	cmp	dl, 240					; 000000f0H
	jne	$LN14@ImTextChar

; 1135 :     {
; 1136 :         *out_char = 0xFFFD; // will be invalid but not end of string

	mov	esi, DWORD PTR _out_char$[ebp]

; 1137 :         if (in_text_end && in_text_end - (const char*)str < 4) return 1;

	mov	eax, DWORD PTR _in_text_end$[ebp]
	mov	DWORD PTR [esi], 65533			; 0000fffdH
	test	eax, eax
	je	SHORT $LN15@ImTextChar
	sub	eax, ecx
	cmp	eax, 4
	jge	SHORT $LN15@ImTextChar
$LN28@ImTextChar:
	pop	ebx
	mov	eax, 1
	pop	esi

; 1155 : }

	pop	ebp
	ret	0
$LN15@ImTextChar:

; 1138 :         if (*str > 0xf4) return 4;

	mov	al, BYTE PTR [ecx]
	cmp	al, 244					; 000000f4H
	ja	SHORT $LN27@ImTextChar

; 1139 :         if (*str == 0xf0 && (str[1] < 0x90 || str[1] > 0xbf)) return 4;

	cmp	al, 240					; 000000f0H
	jne	SHORT $LN17@ImTextChar
	mov	dl, BYTE PTR [ecx+1]
	cmp	dl, 144					; 00000090H
	jb	SHORT $LN27@ImTextChar
	cmp	dl, 191					; 000000bfH
	ja	SHORT $LN27@ImTextChar
$LN17@ImTextChar:

; 1140 :         if (*str == 0xf4 && str[1] > 0x8f) return 4; // str[1] < 0x80 is checked below

	cmp	al, 244					; 000000f4H
	jne	SHORT $LN19@ImTextChar
	cmp	BYTE PTR [ecx+1], 143			; 0000008fH
	ja	SHORT $LN27@ImTextChar
$LN19@ImTextChar:

; 1141 :         c = (unsigned int)((*str++ & 0x07) << 18);
; 1142 :         if ((*str & 0xc0) != 0x80) return 4;

	mov	bl, BYTE PTR [ecx+1]
	movzx	edx, al
	mov	al, bl
	and	edx, 7
	and	al, 192					; 000000c0H
	shl	edx, 18					; 00000012H
	cmp	al, 128					; 00000080H
	jne	SHORT $LN27@ImTextChar

; 1143 :         c += (unsigned int)((*str++ & 0x3f) << 12);

	movzx	eax, bl

; 1144 :         if ((*str & 0xc0) != 0x80) return 4;

	mov	bl, BYTE PTR [ecx+2]
	and	eax, 63					; 0000003fH
	shl	eax, 12					; 0000000cH
	add	edx, eax
	mov	al, bl
	and	al, 192					; 000000c0H
	cmp	al, 128					; 00000080H
	jne	SHORT $LN27@ImTextChar

; 1145 :         c += (unsigned int)((*str++ & 0x3f) << 6);

	add	ecx, 3
	movzx	eax, bl
	and	eax, 63					; 0000003fH
	shl	eax, 6
	add	edx, eax

; 1146 :         if ((*str & 0xc0) != 0x80) return 4;

	mov	cl, BYTE PTR [ecx]
	mov	al, cl
	and	al, 192					; 000000c0H
	cmp	al, 128					; 00000080H
	je	SHORT $LN22@ImTextChar
$LN27@ImTextChar:
	pop	ebx
	mov	eax, 4
	pop	esi

; 1155 : }

	pop	ebp
	ret	0
$LN22@ImTextChar:

; 1147 :         c += (*str++ & 0x3f);

	movzx	eax, cl
	and	eax, 63					; 0000003fH
	add	edx, eax

; 1148 :         // utf-8 encodings of values used in surrogate pairs are invalid
; 1149 :         if ((c & 0xFFFFF800) == 0xD800) return 4;

	mov	eax, edx
	and	eax, -2048				; fffff800H
	cmp	eax, 55296				; 0000d800H
	mov	eax, 4
	je	SHORT $LN26@ImTextChar

; 1150 :         *out_char = c;

	pop	ebx
	mov	DWORD PTR [esi], edx
	pop	esi

; 1155 : }

	pop	ebp
	ret	0
$LN14@ImTextChar:

; 1151 :         return 4;
; 1152 :     }
; 1153 :     *out_char = 0;

	mov	eax, DWORD PTR _out_char$[ebp]
	mov	DWORD PTR [eax], 0

; 1154 :     return 0;

	xor	eax, eax
$LN26@ImTextChar:
	pop	ebx
	pop	esi

; 1155 : }

	pop	ebp
	ret	0
?ImTextCharFromUtf8@@YAHPAIPBD1@Z ENDP			; ImTextCharFromUtf8
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_buf_end$1$ = -4					; size = 4
_buf$ = 8						; size = 4
tv335 = 12						; size = 4
_buf_size$ = 12						; size = 4
_in_text$ = 16						; size = 4
_in_text_end$ = 20					; size = 4
?ImTextStrToUtf8@@YAHPADHPBG1@Z PROC			; ImTextStrToUtf8

; 1239 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx

; 1240 :     char* buf_out = buf;

	mov	ebx, DWORD PTR _buf$[ebp]
	mov	edx, ebx
	push	esi

; 1241 :     const char* buf_end = buf + buf_size;

	mov	esi, DWORD PTR _buf_size$[ebp]
	add	esi, ebx
	mov	DWORD PTR _buf_end$1$[ebp], esi

; 1242 :     while (buf_out < buf_end-1 && (!in_text_end || in_text < in_text_end) && *in_text)

	lea	ecx, DWORD PTR [esi-1]
	mov	DWORD PTR tv335[ebp], ecx
	cmp	ebx, ecx
	jae	$LN3@ImTextStrT
	mov	ebx, DWORD PTR _in_text_end$[ebp]
	push	edi
	mov	edi, DWORD PTR _in_text$[ebp]
	npad	6
$LL2@ImTextStrT:
	test	ebx, ebx
	je	SHORT $LN4@ImTextStrT
	cmp	edi, ebx
	jae	$LN20@ImTextStrT
$LN4@ImTextStrT:
	movzx	eax, WORD PTR [edi]
	test	ax, ax
	je	$LN20@ImTextStrT

; 1243 :     {
; 1244 :         unsigned int c = (unsigned int)(*in_text++);

	add	edi, 2

; 1245 :         if (c < 0x80)

	cmp	eax, 128				; 00000080H
	jae	SHORT $LN5@ImTextStrT

; 1246 :             *buf_out++ = (char)c;

	mov	BYTE PTR [edx], al
	mov	eax, 1

; 1247 :         else

	jmp	$LN6@ImTextStrT
$LN5@ImTextStrT:

; 1248 :             buf_out += ImTextCharToUtf8(buf_out, (int)(buf_end-buf_out-1), c);

	sub	esi, edx
	dec	esi

; 1199 :     if (c < 0x800)

	cmp	eax, 2048				; 00000800H
	jae	SHORT $LN10@ImTextStrT

; 1200 :     {
; 1201 :         if (buf_size < 2) return 0;

	cmp	esi, 2
	jge	SHORT $LN11@ImTextStrT
	xor	eax, eax
	jmp	$LN8@ImTextStrT
$LN11@ImTextStrT:

; 1202 :         buf[0] = (char)(0xc0 + (c >> 6));

	mov	ecx, eax

; 1203 :         buf[1] = (char)(0x80 + (c & 0x3f));

	and	al, 63					; 0000003fH
	shr	ecx, 6
	sub	cl, 64					; 00000040H
	add	al, -128				; ffffff80H
	mov	BYTE PTR [edx+1], al

; 1204 :         return 2;

	mov	eax, 2
	mov	BYTE PTR [edx], cl
	jmp	$LN21@ImTextStrT
$LN10@ImTextStrT:

; 1205 :     }
; 1206 :     if (c >= 0xdc00 && c < 0xe000)

	lea	ecx, DWORD PTR [eax-56320]
	cmp	ecx, 1023				; 000003ffH
	ja	SHORT $LN12@ImTextStrT

; 1207 :     {
; 1208 :         return 0;

	xor	eax, eax
	jmp	SHORT $LN21@ImTextStrT
$LN12@ImTextStrT:

; 1209 :     }
; 1210 :     if (c >= 0xd800 && c < 0xdc00)

	lea	ecx, DWORD PTR [eax-55296]
	cmp	ecx, 1023				; 000003ffH
	ja	SHORT $LN13@ImTextStrT

; 1211 :     {
; 1212 :         if (buf_size < 4) return 0;

	cmp	esi, 4
	jge	SHORT $LN14@ImTextStrT
	xor	eax, eax
	jmp	SHORT $LN21@ImTextStrT
$LN14@ImTextStrT:

; 1213 :         buf[0] = (char)(0xf0 + (c >> 18));

	mov	ecx, eax
	shr	ecx, 18					; 00000012H
	sub	cl, 16					; 00000010H
	mov	BYTE PTR [edx], cl

; 1214 :         buf[1] = (char)(0x80 + ((c >> 12) & 0x3f));

	mov	ecx, eax
	shr	ecx, 12					; 0000000cH
	and	cl, 63					; 0000003fH
	add	cl, -128				; ffffff80H
	mov	BYTE PTR [edx+1], cl

; 1215 :         buf[2] = (char)(0x80 + ((c >> 6) & 0x3f));

	mov	ecx, eax
	shr	ecx, 6

; 1216 :         buf[3] = (char)(0x80 + ((c ) & 0x3f));

	and	al, 63					; 0000003fH
	and	cl, 63					; 0000003fH
	add	cl, -128				; ffffff80H
	add	al, -128				; ffffff80H
	mov	BYTE PTR [edx+3], al

; 1217 :         return 4;

	mov	eax, 4
	mov	BYTE PTR [edx+2], cl
	jmp	SHORT $LN21@ImTextStrT
$LN13@ImTextStrT:

; 1218 :     }
; 1219 :     //else if (c < 0x10000)
; 1220 :     {
; 1221 :         if (buf_size < 3) return 0;

	cmp	esi, 3
	jge	SHORT $LN15@ImTextStrT
	xor	eax, eax
	jmp	SHORT $LN21@ImTextStrT
$LN15@ImTextStrT:

; 1222 :         buf[0] = (char)(0xe0 + (c >> 12));

	mov	ecx, eax
	shr	ecx, 12					; 0000000cH
	sub	cl, 32					; 00000020H
	mov	BYTE PTR [edx], cl

; 1223 :         buf[1] = (char)(0x80 + ((c>> 6) & 0x3f));

	mov	ecx, eax
	shr	ecx, 6

; 1224 :         buf[2] = (char)(0x80 + ((c ) & 0x3f));

	and	al, 63					; 0000003fH
	and	cl, 63					; 0000003fH
	add	cl, -128				; ffffff80H
	add	al, -128				; ffffff80H
	mov	BYTE PTR [edx+2], al

; 1225 :         return 3;

	mov	eax, 3
	mov	BYTE PTR [edx+1], cl
$LN21@ImTextStrT:
	mov	ecx, DWORD PTR tv335[ebp]
$LN8@ImTextStrT:
	mov	esi, DWORD PTR _buf_end$1$[ebp]
$LN6@ImTextStrT:
	add	edx, eax

; 1242 :     while (buf_out < buf_end-1 && (!in_text_end || in_text < in_text_end) && *in_text)

	cmp	edx, ecx
	jb	$LL2@ImTextStrT
$LN20@ImTextStrT:
	mov	ebx, DWORD PTR _buf$[ebp]
	pop	edi
$LN3@ImTextStrT:

; 1249 :     }
; 1250 :     *buf_out = 0;

	mov	BYTE PTR [edx], 0

; 1251 :     return (int)(buf_out - buf);

	sub	edx, ebx
	pop	esi
	mov	eax, edx
	pop	ebx

; 1252 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ImTextStrToUtf8@@YAHPADHPBG1@Z ENDP			; ImTextStrToUtf8
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv65 = 8						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 745  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR __X$[ebp]

; 746  :         return (float)sqrt(_X);

	sqrtss	xmm0, xmm0
	movss	DWORD PTR tv65[ebp], xmm0
	fld	DWORD PTR tv65[ebp]

; 747  :     }

	pop	ebp
	ret	0
_sqrtf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
;	COMDAT _powf
_TEXT	SEGMENT
tv67 = 8						; size = 4
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
_powf	PROC						; COMDAT

; 730  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 731  :         return (float)pow(_X, _Y);

	movss	xmm0, DWORD PTR __X$[ebp]
	movss	xmm1, DWORD PTR __Y$[ebp]
	call	___libm_sse2_powf
	movss	DWORD PTR tv67[ebp], xmm0
	fld	DWORD PTR tv67[ebp]

; 732  :     }

	pop	ebp
	ret	0
_powf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
;	COMDAT _fmodf
_TEXT	SEGMENT
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
_fmodf	PROC						; COMDAT

; 676  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	fld	DWORD PTR __X$[ebp]
	fld	DWORD PTR __Y$[ebp]

; 678  :     }

	pop	ebp

; 677  :         return (float)fmod(_X, _Y);

	jmp	__CIfmod
_fmodf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv68 = 8						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 657  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 658  :         return (float)fabs(_X);

	movss	xmm0, DWORD PTR __X$[ebp]
	andps	xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
	movss	DWORD PTR tv68[ebp], xmm0
	fld	DWORD PTR tv68[ebp]

; 659  :     }

	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
_TEXT	SEGMENT
?SK_ImGui_Active@@YA_NXZ PROC				; SK_ImGui_Active

; 1466 : static inline bool SK_ImGui_Active (void) { return SK_ImGui_Visible || SK_ReShade_Visible; };

	cmp	BYTE PTR ?SK_ImGui_Visible@@3_NA, 0	; SK_ImGui_Visible
	jne	SHORT $LN3@SK_ImGui_A
	cmp	BYTE PTR ?SK_ReShade_Visible@@3_NA, 0	; SK_ReShade_Visible
	jne	SHORT $LN3@SK_ImGui_A
	xor	al, al
	ret	0
$LN3@SK_ImGui_A:
	mov	al, 1
	ret	0
?SK_ImGui_Active@@YA_NXZ ENDP				; SK_ImGui_Active
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?GetCharAdvance@ImFont@@QBEMG@Z
_TEXT	SEGMENT
tv74 = 8						; size = 4
_c$ = 8							; size = 2
?GetCharAdvance@ImFont@@QBEMG@Z PROC			; ImFont::GetCharAdvance, COMDAT
; _this$ = ecx

; 1437 :     float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexXAdvance.Size) ? IndexXAdvance[(int)c] : FallbackXAdvance; }

	npad	2
	push	ebp
	mov	ebp, esp
	movzx	edx, WORD PTR _c$[ebp]
	cmp	edx, DWORD PTR [ecx+28]
	jge	SHORT $LN3@GetCharAdv
	mov	eax, DWORD PTR [ecx+36]
	movss	xmm0, DWORD PTR [eax+edx*4]
	movss	DWORD PTR tv74[ebp], xmm0
	fld	DWORD PTR tv74[ebp]
	pop	ebp
	ret	4
$LN3@GetCharAdv:
	movss	xmm0, DWORD PTR [ecx+56]
	movss	DWORD PTR tv74[ebp], xmm0
	fld	DWORD PTR tv74[ebp]
	pop	ebp
	ret	4
?GetCharAdvance@ImFont@@QBEMG@Z ENDP			; ImFont::GetCharAdvance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@M@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$ImVector@M@@QAEXXZ PROC			; ImVector<float>::pop_back, COMDAT
; _this$ = ecx

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [ecx]
	ret	0
?pop_back@?$ImVector@M@@QAEXXZ ENDP			; ImVector<float>::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@M@@QAEXABM@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?push_back@?$ImVector@M@@QAEXABM@Z PROC			; ImVector<float>::push_back, COMDAT
; _this$ = ecx

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jne	SHORT $LN8@push_back
	inc	edi

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, edi
	cmovg	edi, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	edi, ecx
	jle	SHORT $LN8@push_back

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN10@push_back

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@push_back:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN8@push_back:

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR _v$[ebp]
	pop	edi
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+edx*4], eax
	inc	DWORD PTR [esi]
	pop	esi
	pop	ebp
	ret	4
?push_back@?$ImVector@M@@QAEXABM@Z ENDP			; ImVector<float>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@M@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@M@@QAEXH@Z PROC			; ImVector<float>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@M@@QAEXH@Z ENDP			; ImVector<float>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@M@@QAEXH@Z
_TEXT	SEGMENT
_new_data$1$ = 8					; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@M@@QAEXH@Z PROC			; ImVector<float>::resize, COMDAT
; _this$ = ecx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR _new_size$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jle	SHORT $LN12@resize

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@resize
$LN6@resize:
	mov	eax, 8
$LN7@resize:
	push	ebx
	cmp	eax, edi
	mov	ebx, edi
	cmovg	ebx, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	ebx, ecx
	jle	SHORT $LN13@resize

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [ebx*4]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [esi+8]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN10@resize

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@resize:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], ebx
$LN13@resize:
	pop	ebx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
$LN12@resize:
	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?resize@?$ImVector@M@@QAEXH@Z ENDP			; ImVector<float>::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@M@@QAEHH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?_grow_capacity@?$ImVector@M@@QAEHH@Z PROC		; ImVector<float>::_grow_capacity, COMDAT
; _this$ = ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@grow_capac
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _new_size$[ebp]
	sar	ecx, 1
	add	ecx, esi
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
$LN3@grow_capac:
	mov	eax, DWORD PTR _new_size$[ebp]
	mov	ecx, 8
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
?_grow_capacity@?$ImVector@M@@QAEHH@Z ENDP		; ImVector<float>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?back@?$ImVector@M@@QAEAAMXZ
_TEXT	SEGMENT
?back@?$ImVector@M@@QAEAAMXZ PROC			; ImVector<float>::back, COMDAT
; _this$ = ecx

; 922  :     inline value_type&          back()                          { IM_ASSERT(Size > 0); return Data[Size-1]; }

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [eax+edx*4]
	add	eax, -4					; fffffffcH
	ret	0
?back@?$ImVector@M@@QAEAAMXZ ENDP			; ImVector<float>::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@M@@QBEABMH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@M@@QBEABMH@Z PROC				; ImVector<float>::operator[], COMDAT
; _this$ = ecx

; 913  :     inline const value_type&    operator[](int i) const         { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	pop	ebp
	ret	4
??A?$ImVector@M@@QBEABMH@Z ENDP				; ImVector<float>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?empty@?$ImVector@M@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$ImVector@M@@QBE_NXZ PROC			; ImVector<float>::empty, COMDAT
; _this$ = ecx

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	cmp	DWORD PTR [ecx], 0
	sete	al
	ret	0
?empty@?$ImVector@M@@QBE_NXZ ENDP			; ImVector<float>::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@M@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@M@@QAE@XZ PROC				; ImVector<float>::~ImVector<float>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@M@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@M@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@M@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@M@@QAE@XZ ENDP				; ImVector<float>::~ImVector<float>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@M@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@M@@QAE@XZ PROC				; ImVector<float>::ImVector<float>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@M@@QAE@XZ ENDP				; ImVector<float>::ImVector<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@PAUImFont@@@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$ImVector@PAUImFont@@@@QAEXXZ PROC		; ImVector<ImFont *>::pop_back, COMDAT
; _this$ = ecx

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [ecx]
	ret	0
?pop_back@?$ImVector@PAUImFont@@@@QAEXXZ ENDP		; ImVector<ImFont *>::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@PAUImFont@@@@QAEXABQAUImFont@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?push_back@?$ImVector@PAUImFont@@@@QAEXABQAUImFont@@@Z PROC ; ImVector<ImFont *>::push_back, COMDAT
; _this$ = ecx

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jne	SHORT $LN8@push_back
	inc	edi

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, edi
	cmovg	edi, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	edi, ecx
	jle	SHORT $LN8@push_back

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN10@push_back

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@push_back:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN8@push_back:

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	edx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR _v$[ebp]
	pop	edi
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+edx*4], eax
	inc	DWORD PTR [esi]
	pop	esi
	pop	ebp
	ret	4
?push_back@?$ImVector@PAUImFont@@@@QAEXABQAUImFont@@@Z ENDP ; ImVector<ImFont *>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@PAUImFont@@@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@PAUImFont@@@@QAEXH@Z PROC		; ImVector<ImFont *>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*4]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 2
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@PAUImFont@@@@QAEXH@Z ENDP		; ImVector<ImFont *>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@PAUImFont@@@@QAEHH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?_grow_capacity@?$ImVector@PAUImFont@@@@QAEHH@Z PROC	; ImVector<ImFont *>::_grow_capacity, COMDAT
; _this$ = ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@grow_capac
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _new_size$[ebp]
	sar	ecx, 1
	add	ecx, esi
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
$LN3@grow_capac:
	mov	eax, DWORD PTR _new_size$[ebp]
	mov	ecx, 8
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
?_grow_capacity@?$ImVector@PAUImFont@@@@QAEHH@Z ENDP	; ImVector<ImFont *>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?back@?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@XZ
_TEXT	SEGMENT
?back@?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@XZ PROC	; ImVector<ImFont *>::back, COMDAT
; _this$ = ecx

; 922  :     inline value_type&          back()                          { IM_ASSERT(Size > 0); return Data[Size-1]; }

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [eax+edx*4]
	add	eax, -4					; fffffffcH
	ret	0
?back@?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@XZ ENDP	; ImVector<ImFont *>::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@PAUImFont@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$ImVector@PAUImFont@@@@QAEXXZ PROC		; ImVector<ImFont *>::clear, COMDAT
; _this$ = ecx

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	npad	2
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN2@clear
	push	eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+8], 0
$LN2@clear:
	pop	esi
	ret	0
?clear@?$ImVector@PAUImFont@@@@QAEXXZ ENDP		; ImVector<ImFont *>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@H@Z PROC	; ImVector<ImFont *>::operator[], COMDAT
; _this$ = ecx

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	pop	ebp
	ret	4
??A?$ImVector@PAUImFont@@@@QAEAAPAUImFont@@H@Z ENDP	; ImVector<ImFont *>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?empty@?$ImVector@PAUImFont@@@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$ImVector@PAUImFont@@@@QBE_NXZ PROC		; ImVector<ImFont *>::empty, COMDAT
; _this$ = ecx

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	cmp	DWORD PTR [ecx], 0
	sete	al
	ret	0
?empty@?$ImVector@PAUImFont@@@@QBE_NXZ ENDP		; ImVector<ImFont *>::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@PAUImFont@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@PAUImFont@@@@QAE@XZ PROC			; ImVector<ImFont *>::~ImVector<ImFont *>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@PAUImFont@@@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@PAUImFont@@@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@PAUImFont@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@PAUImFont@@@@QAE@XZ ENDP			; ImVector<ImFont *>::~ImVector<ImFont *>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@PAUImFont@@@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@PAUImFont@@@@QAE@XZ PROC			; ImVector<ImFont *>::ImVector<ImFont *>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@PAUImFont@@@@QAE@XZ ENDP			; ImVector<ImFont *>::ImVector<ImFont *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0ImDrawData@@QAE@XZ
_TEXT	SEGMENT
??0ImDrawData@@QAE@XZ PROC				; ImDrawData::ImDrawData, COMDAT
; _this$ = ecx

; 1315 :     ImDrawData() { Valid = false; CmdLists = NULL; CmdListsCount = TotalVtxCount = TotalIdxCount = 0; }

	mov	BYTE PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0ImDrawData@@QAE@XZ ENDP				; ImDrawData::ImDrawData
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GImDrawList@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GImDrawList@@QAEPAXI@Z PROC				; ImDrawList::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1ImDrawList@@QAE@XZ			; ImDrawList::~ImDrawList
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	108					; 0000006cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_GImDrawList@@QAEPAXI@Z ENDP				; ImDrawList::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?PathStroke@ImDrawList@@QAEXI_NM@Z
_TEXT	SEGMENT
_col$ = 8						; size = 4
_closed$ = 12						; size = 1
_thickness$ = 16					; size = 4
?PathStroke@ImDrawList@@QAEXI_NM@Z PROC			; ImDrawList::PathStroke, COMDAT
; _this$ = ecx

; 1273 :     inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f)  { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness, true); PathClear(); }

	npad	2
	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR _thickness$[ebp]
	push	esi
	push	1
	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	esi, DWORD PTR [ecx+76]
	push	DWORD PTR _closed$[ebp]
	push	DWORD PTR _col$[ebp]
	push	DWORD PTR [esi]
	push	DWORD PTR [ecx+84]
	call	?AddPolyline@ImDrawList@@QAEXPBUImVec2@@HI_NM1@Z ; ImDrawList::AddPolyline

; 1269 :     inline    void  PathClear()                                                 { _Path.resize(0); }

	push	0
	mov	ecx, esi
	call	?resize@?$ImVector@UImVec2@@@@QAEXH@Z	; ImVector<ImVec2>::resize
	pop	esi

; 1273 :     inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f)  { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness, true); PathClear(); }

	pop	ebp
	ret	12					; 0000000cH
?PathStroke@ImDrawList@@QAEXI_NM@Z ENDP			; ImDrawList::PathStroke
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?PathFill@ImDrawList@@QAEXI@Z
_TEXT	SEGMENT
_col$ = 8						; size = 4
?PathFill@ImDrawList@@QAEXI@Z PROC			; ImDrawList::PathFill, COMDAT
; _this$ = ecx

; 1272 :     inline    void  PathFill(ImU32 col)                                         { AddConvexPolyFilled(_Path.Data, _Path.Size, col, true); PathClear(); }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	1
	push	DWORD PTR _col$[ebp]
	lea	esi, DWORD PTR [ecx+76]
	push	DWORD PTR [esi]
	push	DWORD PTR [ecx+84]
	call	?AddConvexPolyFilled@ImDrawList@@QAEXPBUImVec2@@HI_N@Z ; ImDrawList::AddConvexPolyFilled

; 1269 :     inline    void  PathClear()                                                 { _Path.resize(0); }

	push	0
	mov	ecx, esi
	call	?resize@?$ImVector@UImVec2@@@@QAEXH@Z	; ImVector<ImVec2>::resize
	pop	esi

; 1272 :     inline    void  PathFill(ImU32 col)                                         { AddConvexPolyFilled(_Path.Data, _Path.Size, col, true); PathClear(); }

	pop	ebp
	ret	4
?PathFill@ImDrawList@@QAEXI@Z ENDP			; ImDrawList::PathFill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z
_TEXT	SEGMENT
_pos$ = 8						; size = 4
?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z PROC		; ImDrawList::PathLineTo, COMDAT
; _this$ = ecx

; 1270 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	npad	2
	push	ebp
	mov	ebp, esp
	add	ecx, 76					; 0000004cH
	pop	ebp
	jmp	?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ; ImVector<ImVec2>::push_back
?PathLineTo@ImDrawList@@QAEXABUImVec2@@@Z ENDP		; ImDrawList::PathLineTo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?PathClear@ImDrawList@@QAEXXZ
_TEXT	SEGMENT
?PathClear@ImDrawList@@QAEXXZ PROC			; ImDrawList::PathClear, COMDAT
; _this$ = ecx

; 1269 :     inline    void  PathClear()                                                 { _Path.resize(0); }

	push	0
	add	ecx, 76					; 0000004cH
	call	?resize@?$ImVector@UImVec2@@@@QAEXH@Z	; ImVector<ImVec2>::resize
	ret	0
?PathClear@ImDrawList@@QAEXXZ ENDP			; ImDrawList::PathClear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1ImDrawList@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1ImDrawList@@QAE@XZ PROC				; ImDrawList::~ImDrawList, COMDAT
; _this$ = ecx

; 1243 :     ~ImDrawList() { ClearFreeMemory(); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1ImDrawList@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx
	call	?ClearFreeMemory@ImDrawList@@QAEXXZ	; ImDrawList::ClearFreeMemory

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	mov	eax, DWORD PTR [esi+104]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN4@ImDrawList
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN4@ImDrawList:
	mov	eax, DWORD PTR [esi+84]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	eax, eax
	je	SHORT $LN8@ImDrawList
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN8@ImDrawList:
	mov	eax, DWORD PTR [esi+72]
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	test	eax, eax
	je	SHORT $LN12@ImDrawList
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN12@ImDrawList:
	mov	eax, DWORD PTR [esi+60]
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	test	eax, eax
	je	SHORT $LN16@ImDrawList
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN16@ImDrawList:
	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	test	eax, eax
	je	SHORT $LN20@ImDrawList
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN20@ImDrawList:
	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	test	eax, eax
	je	SHORT $LN24@ImDrawList
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN24@ImDrawList:
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR __$EHRec$[ebp+8], 6
	test	eax, eax
	je	SHORT $LN28@ImDrawList
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN28@ImDrawList:

; 1243 :     ~ImDrawList() { ClearFreeMemory(); }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1ImDrawList@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1ImDrawList@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1ImDrawList@@QAE@XZ ENDP				; ImDrawList::~ImDrawList
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0ImDrawList@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0ImDrawList@@QAE@XZ PROC				; ImDrawList::ImDrawList, COMDAT
; _this$ = ecx

; 1242 :     ImDrawList()  { _OwnerName = NULL; Clear(); }

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0ImDrawList@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+8], 0

; 1242 :     ImDrawList()  { _OwnerName = NULL; Clear(); }

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+56], 0
	mov	DWORD PTR [esi+52], 0
	mov	DWORD PTR [esi+60], 0
	mov	DWORD PTR [esi+68], 0
	mov	DWORD PTR [esi+64], 0
	mov	DWORD PTR [esi+72], 0
	mov	DWORD PTR [esi+80], 0
	mov	DWORD PTR [esi+76], 0
	mov	DWORD PTR [esi+84], 0
	mov	DWORD PTR [esi+100], 0
	mov	DWORD PTR [esi+96], 0
	mov	DWORD PTR [esi+104], 0

; 1242 :     ImDrawList()  { _OwnerName = NULL; Clear(); }

	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	DWORD PTR [esi+36], 0
	call	?Clear@ImDrawList@@QAEXXZ		; ImDrawList::Clear
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ImDrawList@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$ImVector@UImDrawCmd@@@@QAE@XZ	; ImVector<ImDrawCmd>::~ImVector<ImDrawCmd>
__unwindfunclet$??0ImDrawList@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$ImVector@G@@QAE@XZ			; ImVector<unsigned short>::~ImVector<unsigned short>
__unwindfunclet$??0ImDrawList@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1?$ImVector@UImDrawVert@@@@QAE@XZ	; ImVector<ImDrawVert>::~ImVector<ImDrawVert>
__unwindfunclet$??0ImDrawList@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	jmp	??1?$ImVector@UImVec4@@@@QAE@XZ		; ImVector<ImVec4>::~ImVector<ImVec4>
__unwindfunclet$??0ImDrawList@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1?$ImVector@PAX@@QAE@XZ		; ImVector<void *>::~ImVector<void *>
__unwindfunclet$??0ImDrawList@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	jmp	??1?$ImVector@UImVec2@@@@QAE@XZ		; ImVector<ImVec2>::~ImVector<ImVec2>
__unwindfunclet$??0ImDrawList@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	jmp	??1?$ImVector@UImDrawChannel@@@@QAE@XZ	; ImVector<ImDrawChannel>::~ImVector<ImDrawChannel>
__ehhandler$??0ImDrawList@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0ImDrawList@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0ImDrawList@@QAE@XZ ENDP				; ImDrawList::ImDrawList
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImDrawChannel@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@UImDrawChannel@@@@QAE@XZ PROC		; ImVector<ImDrawChannel>::~ImVector<ImDrawChannel>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@UImDrawChannel@@@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@UImDrawChannel@@@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@UImDrawChannel@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@UImDrawChannel@@@@QAE@XZ ENDP		; ImVector<ImDrawChannel>::~ImVector<ImDrawChannel>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImDrawChannel@@@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@UImDrawChannel@@@@QAE@XZ PROC		; ImVector<ImDrawChannel>::ImVector<ImDrawChannel>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@UImDrawChannel@@@@QAE@XZ ENDP		; ImVector<ImDrawChannel>::ImVector<ImDrawChannel>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z PROC	; ImVector<ImVec2>::push_back, COMDAT
; _this$ = ecx

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi]
	mov	ecx, DWORD PTR [edi+4]
	cmp	esi, ecx
	jne	SHORT $LN8@push_back
	inc	esi

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, esi
	cmovg	esi, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	esi, ecx
	jle	SHORT $LN8@push_back

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [esi*8]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN10@push_back

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [edi]
	shl	ecx, 3
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@push_back:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [edi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [edi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [edi+4], esi
	pop	ebx
$LN8@push_back:

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	esi, DWORD PTR [edi+8]
	mov	edx, DWORD PTR [edi]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi+edx*8], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+edx*8+4], eax
	inc	DWORD PTR [edi]
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?push_back@?$ImVector@UImVec2@@@@QAEXABUImVec2@@@Z ENDP	; ImVector<ImVec2>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UImVec2@@@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UImVec2@@@@QAEXH@Z PROC		; ImVector<ImVec2>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*8]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 3
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@UImVec2@@@@QAEXH@Z ENDP		; ImVector<ImVec2>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UImVec2@@@@QAEXH@Z
_TEXT	SEGMENT
_new_data$1$ = 8					; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@UImVec2@@@@QAEXH@Z PROC		; ImVector<ImVec2>::resize, COMDAT
; _this$ = ecx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR _new_size$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jle	SHORT $LN12@resize

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@resize
$LN6@resize:
	mov	eax, 8
$LN7@resize:
	push	ebx
	cmp	eax, edi
	mov	ebx, edi
	cmovg	ebx, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	ebx, ecx
	jle	SHORT $LN13@resize

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [ebx*8]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [esi+8]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN10@resize

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 3
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@resize:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], ebx
$LN13@resize:
	pop	ebx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
$LN12@resize:
	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?resize@?$ImVector@UImVec2@@@@QAEXH@Z ENDP		; ImVector<ImVec2>::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UImVec2@@@@QAEHH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?_grow_capacity@?$ImVector@UImVec2@@@@QAEHH@Z PROC	; ImVector<ImVec2>::_grow_capacity, COMDAT
; _this$ = ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@grow_capac
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _new_size$[ebp]
	sar	ecx, 1
	add	ecx, esi
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
$LN3@grow_capac:
	mov	eax, DWORD PTR _new_size$[ebp]
	mov	ecx, 8
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
?_grow_capacity@?$ImVector@UImVec2@@@@QAEHH@Z ENDP	; ImVector<ImVec2>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImVec2@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@UImVec2@@@@QAE@XZ PROC			; ImVector<ImVec2>::~ImVector<ImVec2>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@UImVec2@@@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@UImVec2@@@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@UImVec2@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@UImVec2@@@@QAE@XZ ENDP			; ImVector<ImVec2>::~ImVector<ImVec2>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImVec2@@@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@UImVec2@@@@QAE@XZ PROC			; ImVector<ImVec2>::ImVector<ImVec2>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@UImVec2@@@@QAE@XZ ENDP			; ImVector<ImVec2>::ImVector<ImVec2>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@PAX@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@PAX@@QAE@XZ PROC				; ImVector<void *>::~ImVector<void *>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@PAX@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@PAX@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@PAX@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@PAX@@QAE@XZ ENDP				; ImVector<void *>::~ImVector<void *>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@PAX@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@PAX@@QAE@XZ PROC				; ImVector<void *>::ImVector<void *>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@PAX@@QAE@XZ ENDP				; ImVector<void *>::ImVector<void *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImVec4@@@@QAEAAUImVec4@@XZ
_TEXT	SEGMENT
?back@?$ImVector@UImVec4@@@@QAEAAUImVec4@@XZ PROC	; ImVector<ImVec4>::back, COMDAT
; _this$ = ecx

; 922  :     inline value_type&          back()                          { IM_ASSERT(Size > 0); return Data[Size-1]; }

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+8]
	shl	edx, 4
	add	eax, -16				; fffffff0H
	add	eax, edx
	ret	0
?back@?$ImVector@UImVec4@@@@QAEAAUImVec4@@XZ ENDP	; ImVector<ImVec4>::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImVec4@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@UImVec4@@@@QAE@XZ PROC			; ImVector<ImVec4>::~ImVector<ImVec4>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@UImVec4@@@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@UImVec4@@@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@UImVec4@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@UImVec4@@@@QAE@XZ ENDP			; ImVector<ImVec4>::~ImVector<ImVec4>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImVec4@@@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@UImVec4@@@@QAE@XZ PROC			; ImVector<ImVec4>::ImVector<ImVec4>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@UImVec4@@@@QAE@XZ ENDP			; ImVector<ImVec4>::ImVector<ImVec4>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImDrawVert@@@@QAEAAUImDrawVert@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@UImDrawVert@@@@QAEAAUImDrawVert@@H@Z PROC	; ImVector<ImDrawVert>::operator[], COMDAT
; _this$ = ecx

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _i$[ebp]
	lea	edx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [eax+edx*4]
	pop	ebp
	ret	4
??A?$ImVector@UImDrawVert@@@@QAEAAUImDrawVert@@H@Z ENDP	; ImVector<ImDrawVert>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?empty@?$ImVector@UImDrawVert@@@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$ImVector@UImDrawVert@@@@QBE_NXZ PROC		; ImVector<ImDrawVert>::empty, COMDAT
; _this$ = ecx

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	cmp	DWORD PTR [ecx], 0
	sete	al
	ret	0
?empty@?$ImVector@UImDrawVert@@@@QBE_NXZ ENDP		; ImVector<ImDrawVert>::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImDrawVert@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@UImDrawVert@@@@QAE@XZ PROC		; ImVector<ImDrawVert>::~ImVector<ImDrawVert>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@UImDrawVert@@@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@UImDrawVert@@@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@UImDrawVert@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@UImDrawVert@@@@QAE@XZ ENDP		; ImVector<ImDrawVert>::~ImVector<ImDrawVert>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImDrawVert@@@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@UImDrawVert@@@@QAE@XZ PROC		; ImVector<ImDrawVert>::ImVector<ImDrawVert>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@UImDrawVert@@@@QAE@XZ ENDP		; ImVector<ImDrawVert>::ImVector<ImDrawVert>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@G@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@G@@QAEXH@Z PROC			; ImVector<unsigned short>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi+edi]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	add	ecx, ecx
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@G@@QAEXH@Z ENDP			; ImVector<unsigned short>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@G@@QAEXH@Z
_TEXT	SEGMENT
_new_data$1$ = 8					; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@G@@QAEXH@Z PROC			; ImVector<unsigned short>::resize, COMDAT
; _this$ = ecx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR _new_size$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jle	SHORT $LN12@resize

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@resize
$LN6@resize:
	mov	eax, 8
$LN7@resize:
	push	ebx
	cmp	eax, edi
	mov	ebx, edi
	cmovg	ebx, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	ebx, ecx
	jle	SHORT $LN13@resize

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [ebx+ebx]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [esi+8]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN10@resize

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	add	ecx, ecx
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@resize:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], ebx
$LN13@resize:
	pop	ebx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
$LN12@resize:
	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?resize@?$ImVector@G@@QAEXH@Z ENDP			; ImVector<unsigned short>::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@G@@QAEHH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?_grow_capacity@?$ImVector@G@@QAEHH@Z PROC		; ImVector<unsigned short>::_grow_capacity, COMDAT
; _this$ = ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@grow_capac
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _new_size$[ebp]
	sar	ecx, 1
	add	ecx, esi
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
$LN3@grow_capac:
	mov	eax, DWORD PTR _new_size$[ebp]
	mov	ecx, 8
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
?_grow_capacity@?$ImVector@G@@QAEHH@Z ENDP		; ImVector<unsigned short>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@G@@QAEXXZ
_TEXT	SEGMENT
?clear@?$ImVector@G@@QAEXXZ PROC			; ImVector<unsigned short>::clear, COMDAT
; _this$ = ecx

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	npad	2
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN2@clear
	push	eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+8], 0
$LN2@clear:
	pop	esi
	ret	0
?clear@?$ImVector@G@@QAEXXZ ENDP			; ImVector<unsigned short>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@G@@QBEABGH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@G@@QBEABGH@Z PROC				; ImVector<unsigned short>::operator[], COMDAT
; _this$ = ecx

; 913  :     inline const value_type&    operator[](int i) const         { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+eax*2]
	pop	ebp
	ret	4
??A?$ImVector@G@@QBEABGH@Z ENDP				; ImVector<unsigned short>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@G@@QAEAAGH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@G@@QAEAAGH@Z PROC				; ImVector<unsigned short>::operator[], COMDAT
; _this$ = ecx

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+eax*2]
	pop	ebp
	ret	4
??A?$ImVector@G@@QAEAAGH@Z ENDP				; ImVector<unsigned short>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@G@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@G@@QAE@XZ PROC				; ImVector<unsigned short>::~ImVector<unsigned short>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@G@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@G@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@G@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@G@@QAE@XZ ENDP				; ImVector<unsigned short>::~ImVector<unsigned short>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@G@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@G@@QAE@XZ PROC				; ImVector<unsigned short>::ImVector<unsigned short>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@G@@QAE@XZ ENDP				; ImVector<unsigned short>::ImVector<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?pop_back@?$ImVector@UImDrawCmd@@@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$ImVector@UImDrawCmd@@@@QAEXXZ PROC		; ImVector<ImDrawCmd>::pop_back, COMDAT
; _this$ = ecx

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [ecx]
	ret	0
?pop_back@?$ImVector@UImDrawCmd@@@@QAEXXZ ENDP		; ImVector<ImDrawCmd>::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?back@?$ImVector@UImDrawCmd@@@@QAEAAUImDrawCmd@@XZ
_TEXT	SEGMENT
?back@?$ImVector@UImDrawCmd@@@@QAEAAUImDrawCmd@@XZ PROC	; ImVector<ImDrawCmd>::back, COMDAT
; _this$ = ecx

; 922  :     inline value_type&          back()                          { IM_ASSERT(Size > 0); return Data[Size-1]; }

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+8]
	shl	edx, 5
	add	eax, -32				; ffffffe0H
	add	eax, edx
	ret	0
?back@?$ImVector@UImDrawCmd@@@@QAEAAUImDrawCmd@@XZ ENDP	; ImVector<ImDrawCmd>::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?end@?$ImVector@UImDrawCmd@@@@QAEPAUImDrawCmd@@XZ
_TEXT	SEGMENT
?end@?$ImVector@UImDrawCmd@@@@QAEPAUImDrawCmd@@XZ PROC	; ImVector<ImDrawCmd>::end, COMDAT
; _this$ = ecx

; 918  :     inline iterator             end()                           { return Data + Size; }

	mov	eax, DWORD PTR [ecx]
	shl	eax, 5
	add	eax, DWORD PTR [ecx+8]
	ret	0
?end@?$ImVector@UImDrawCmd@@@@QAEPAUImDrawCmd@@XZ ENDP	; ImVector<ImDrawCmd>::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?begin@?$ImVector@UImDrawCmd@@@@QAEPAUImDrawCmd@@XZ
_TEXT	SEGMENT
?begin@?$ImVector@UImDrawCmd@@@@QAEPAUImDrawCmd@@XZ PROC ; ImVector<ImDrawCmd>::begin, COMDAT
; _this$ = ecx

; 916  :     inline iterator             begin()                         { return Data; }

	mov	eax, DWORD PTR [ecx+8]
	ret	0
?begin@?$ImVector@UImDrawCmd@@@@QAEPAUImDrawCmd@@XZ ENDP ; ImVector<ImDrawCmd>::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?empty@?$ImVector@UImDrawCmd@@@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$ImVector@UImDrawCmd@@@@QBE_NXZ PROC		; ImVector<ImDrawCmd>::empty, COMDAT
; _this$ = ecx

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	cmp	DWORD PTR [ecx], 0
	sete	al
	ret	0
?empty@?$ImVector@UImDrawCmd@@@@QBE_NXZ ENDP		; ImVector<ImDrawCmd>::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@UImDrawCmd@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@UImDrawCmd@@@@QAE@XZ PROC			; ImVector<ImDrawCmd>::~ImVector<ImDrawCmd>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@UImDrawCmd@@@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@UImDrawCmd@@@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@UImDrawCmd@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@UImDrawCmd@@@@QAE@XZ ENDP			; ImVector<ImDrawCmd>::~ImVector<ImDrawCmd>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@UImDrawCmd@@@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@UImDrawCmd@@@@QAE@XZ PROC			; ImVector<ImDrawCmd>::ImVector<ImDrawCmd>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@UImDrawCmd@@@@QAE@XZ ENDP			; ImVector<ImDrawCmd>::ImVector<ImDrawCmd>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?End@ImGuiListClipper@@QAEXXZ PROC			; ImGuiListClipper::End
; _this$ = ecx

; 1769 : {

	npad	2
	push	esi
	mov	esi, ecx

; 1770 :     if (ItemsCount < 0)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	js	SHORT $LN1@End

; 1771 :         return;
; 1772 :     // In theory here we should assert that ImGui::GetCursorPosY() == StartPosY + DisplayEnd * ItemsHeight, but it feels saner to just seek at the end and not assert/crash the user.
; 1773 :     if (ItemsCount < INT_MAX)

	cmp	eax, 2147483647				; 7fffffffH
	jge	SHORT $LN3@End

; 1774 :         SetCursorPosYAndSetupDummyPrevLine(StartPosY + ItemsCount * ItemsHeight, ItemsHeight); // advance cursor

	movss	xmm1, DWORD PTR [esi+4]
	sub	esp, 8
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [esp+4], xmm1
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [esi]
	movss	DWORD PTR [esp], xmm0
	call	?SetCursorPosYAndSetupDummyPrevLine@@YAXMM@Z ; SetCursorPosYAndSetupDummyPrevLine
	add	esp, 8
$LN3@End:

; 1775 :     ItemsCount = -1;

	mov	DWORD PTR [esi+8], -1

; 1776 :     StepNo = 3;

	mov	DWORD PTR [esi+12], 3
$LN1@End:
	pop	esi

; 1777 : }

	ret	0
?End@ImGuiListClipper@@QAEXXZ ENDP			; ImGuiListClipper::End
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_count$ = 8						; size = 4
_items_height$ = 12					; size = 4
?Begin@ImGuiListClipper@@QAEXHM@Z PROC			; ImGuiListClipper::Begin
; _this$ = ecx

; 1753 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	esi, ecx

; 1754 :     StartPosY = ImGui::GetCursorPosY();

	call	?GetCursorPosY@ImGui@@YAMXZ		; ImGui::GetCursorPosY

; 1755 :     ItemsHeight = items_height;

	movss	xmm0, DWORD PTR _items_height$[ebp]

; 1756 :     ItemsCount = count;
; 1757 :     StepNo = 0;
; 1758 :     DisplayEnd = DisplayStart = -1;

	lea	edi, DWORD PTR [esi+16]

; 1759 :     if (ItemsHeight > 0.0f)

	comiss	xmm0, DWORD PTR __real@00000000
	mov	eax, DWORD PTR _count$[ebp]
	lea	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [edi], -1
	mov	DWORD PTR [ecx], -1
	fstp	DWORD PTR [esi]
	movss	DWORD PTR [esi+4], xmm0
	jbe	SHORT $LN2@Begin

; 1760 :     {
; 1761 :         ImGui::CalcListClipping(ItemsCount, ItemsHeight, &DisplayStart, &DisplayEnd); // calculate how many to clip/display

	push	ecx
	push	edi
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	eax
	call	?CalcListClipping@ImGui@@YAXHMPAH0@Z	; ImGui::CalcListClipping

; 1762 :         if (DisplayStart > 0)

	mov	eax, DWORD PTR [edi]
	add	esp, 16					; 00000010H
	test	eax, eax
	jle	SHORT $LN3@Begin

; 1763 :             SetCursorPosYAndSetupDummyPrevLine(StartPosY + DisplayStart * ItemsHeight, ItemsHeight); // advance cursor

	movss	xmm1, DWORD PTR [esi+4]
	sub	esp, 8
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [esp+4], xmm1
	mulss	xmm0, xmm1
	addss	xmm0, DWORD PTR [esi]
	movss	DWORD PTR [esp], xmm0
	call	?SetCursorPosYAndSetupDummyPrevLine@@YAXMM@Z ; SetCursorPosYAndSetupDummyPrevLine
	add	esp, 8
$LN3@Begin:

; 1764 :         StepNo = 2;

	mov	DWORD PTR [esi+12], 2
$LN2@Begin:
	pop	edi
	pop	esi

; 1765 :     }
; 1766 : }

	pop	ebp
	ret	8
?Begin@ImGuiListClipper@@QAEXHM@Z ENDP			; ImGuiListClipper::Begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?Step@ImGuiListClipper@@QAE_NXZ PROC			; ImGuiListClipper::Step
; _this$ = ecx

; 1780 : {

	npad	2
	push	esi
	mov	esi, ecx
	push	edi

; 1781 :     if (ItemsCount == 0 || ImGui::GetCurrentWindowRead()->SkipItems)

	mov	edi, DWORD PTR [esi+8]
	test	edi, edi
	je	SHORT $LN3@Step
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [eax+6240]
	cmp	BYTE PTR [eax+137], 0
	jne	SHORT $LN3@Step

; 1785 :     }
; 1786 :     if (StepNo == 0) // Step 0: the clipper let you process the first element, regardless of it being visible or not, so we can measure the element height.

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	jne	SHORT $LN4@Step

; 1787 :     {
; 1788 :         DisplayStart = 0;

	mov	DWORD PTR [esi+16], eax

; 1789 :         DisplayEnd = 1;

	mov	DWORD PTR [esi+20], 1

; 1790 :         StartPosY = ImGui::GetCursorPosY();

	call	?GetCursorPosY@ImGui@@YAMXZ		; ImGui::GetCursorPosY
	pop	edi
	fstp	DWORD PTR [esi]

; 1791 :         StepNo = 1;

	mov	DWORD PTR [esi+12], 1

; 1792 :         return true;

	mov	al, 1
	pop	esi

; 1813 :     return false;
; 1814 : }

	ret	0
$LN4@Step:

; 1793 :     }
; 1794 :     if (StepNo == 1) // Step 1: the clipper infer height from first element, calculate the actual range of elements to display, and position the cursor before the first element.

	cmp	eax, 1
	jne	SHORT $LN5@Step

; 1795 :     {
; 1796 :         if (ItemsCount == 1) { ItemsCount = -1; return false; }

	cmp	edi, eax
	je	SHORT $LN3@Step

; 1797 :         float items_height = ImGui::GetCursorPosY() - StartPosY;

	call	?GetCursorPosY@ImGui@@YAMXZ		; ImGui::GetCursorPosY
	fsub	DWORD PTR [esi]

; 1798 :         IM_ASSERT(items_height > 0.0f);   // If this triggers, it means Item 0 hasn't moved the cursor vertically
; 1799 :         Begin(ItemsCount-1, items_height);

	push	ecx
	lea	eax, DWORD PTR [edi-1]
	mov	ecx, esi
	fstp	DWORD PTR [esp]
	push	eax
	call	?Begin@ImGuiListClipper@@QAEXHM@Z	; ImGuiListClipper::Begin

; 1800 :         DisplayStart++;

	inc	DWORD PTR [esi+16]

; 1801 :         DisplayEnd++;

	inc	DWORD PTR [esi+20]
$LN12@Step:

; 1802 :         StepNo = 3;

	pop	edi
	mov	DWORD PTR [esi+12], 3

; 1803 :         return true;

	mov	al, 1
	pop	esi

; 1813 :     return false;
; 1814 : }

	ret	0
$LN5@Step:

; 1804 :     }
; 1805 :     if (StepNo == 2) // Step 2: dummy step only required if an explicit items_height was passed to constructor or Begin() and user still call Step(). Does nothing and switch to Step 3.

	cmp	eax, 2
	je	SHORT $LN12@Step

; 1806 :     {
; 1807 :         IM_ASSERT(DisplayStart >= 0 && DisplayEnd >= 0);
; 1808 :         StepNo = 3;
; 1809 :         return true;
; 1810 :     }
; 1811 :     if (StepNo == 3) // Step 3: the clipper validate that we have reached the expected Y position (corresponding to element DisplayEnd), advance the cursor to the end of the list and then returns 'false' to end the loop.

	cmp	eax, 3
	jne	SHORT $LN8@Step

; 1812 :         End();

	call	?End@ImGuiListClipper@@QAEXXZ		; ImGuiListClipper::End
	pop	edi
	xor	al, al
	pop	esi

; 1813 :     return false;
; 1814 : }

	ret	0
$LN3@Step:

; 1782 :     {
; 1783 :         ItemsCount = -1; 

	mov	DWORD PTR [esi+8], -1
$LN8@Step:
	pop	edi

; 1784 :         return false; 

	xor	al, al
	pop	esi

; 1813 :     return false;
; 1814 : }

	ret	0
?Step@ImGuiListClipper@@QAE_NXZ ENDP			; ImGuiListClipper::Step
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1ImGuiListClipper@@QAE@XZ
_TEXT	SEGMENT
??1ImGuiListClipper@@QAE@XZ PROC			; ImGuiListClipper::~ImGuiListClipper, COMDAT
; _this$ = ecx

; 1159 :     ~ImGuiListClipper()                                                 { IM_ASSERT(ItemsCount == -1); }      // Assert if user forgot to call End() or Step() until false.

	ret	0
??1ImGuiListClipper@@QAE@XZ ENDP			; ImGuiListClipper::~ImGuiListClipper
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0ImGuiListClipper@@QAE@HM@Z
_TEXT	SEGMENT
_items_count$ = 8					; size = 4
_items_height$ = 12					; size = 4
??0ImGuiListClipper@@QAE@HM@Z PROC			; ImGuiListClipper::ImGuiListClipper, COMDAT
; _this$ = ecx

; 1158 :     ImGuiListClipper(int items_count = -1, float items_height = -1.0f)  { Begin(items_count, items_height); } // NB: Begin() initialize every fields (as we allow user to call Begin/End multiple times on a same instance if they want).

	npad	2
	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR _items_height$[ebp]
	push	esi
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	esi, ecx
	push	DWORD PTR _items_count$[ebp]
	call	?Begin@ImGuiListClipper@@QAEXHM@Z	; ImGuiListClipper::Begin
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	8
??0ImGuiListClipper@@QAE@HM@Z ENDP			; ImGuiListClipper::ImGuiListClipper
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?HSV@ImColor@@SA?AU1@MMMM@Z
_TEXT	SEGMENT
_b$ = -12						; size = 4
_g$ = -8						; size = 4
_r$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_h$ = 12						; size = 4
_s$ = 16						; size = 4
_v$ = 20						; size = 4
_a$ = 24						; size = 4
?HSV@ImColor@@SA?AU1@MMMM@Z PROC			; ImColor::HSV, COMDAT

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR _v$[ebp]
	lea	eax, DWORD PTR _b$[ebp]
	push	eax
	lea	eax, DWORD PTR _g$[ebp]
	push	eax
	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _s$[ebp]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _h$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?ColorConvertHSVtoRGB@ImGui@@YAXMMMAAM00@Z ; ImGui::ColorConvertHSVtoRGB

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	add	esp, 24					; 00000018H

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	movss	xmm0, DWORD PTR _r$[ebp]
	movss	DWORD PTR [eax], xmm0
	movss	xmm0, DWORD PTR _g$[ebp]
	movss	DWORD PTR [eax+4], xmm0
	movss	xmm0, DWORD PTR _b$[ebp]
	movss	DWORD PTR [eax+8], xmm0
	movss	xmm0, DWORD PTR _a$[ebp]
	movss	DWORD PTR [eax+12], xmm0

; 1133 :     static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }

	mov	esp, ebp
	pop	ebp
	ret	0
?HSV@ImColor@@SA?AU1@MMMM@Z ENDP			; ImColor::HSV
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??BImColor@@QBE?AUImVec4@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??BImColor@@QBE?AUImVec4@@XZ PROC			; ImColor::operator ImVec4, COMDAT
; _this$ = ecx

; 1129 :     inline operator ImVec4() const                                  { return Value; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	movups	xmm0, XMMWORD PTR [ecx]
	movups	XMMWORD PTR [eax], xmm0
	pop	ebp
	ret	4
??BImColor@@QBE?AUImVec4@@XZ ENDP			; ImColor::operator ImVec4
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??BImColor@@QBEIXZ
_TEXT	SEGMENT
??BImColor@@QBEIXZ PROC					; ImColor::operator unsigned int, COMDAT
; _this$ = ecx

; 1128 :     inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }

	npad	2
	push	ecx
	call	?ColorConvertFloat4ToU32@ImGui@@YAIABUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	add	esp, 4
	ret	0
??BImColor@@QBEIXZ ENDP					; ImColor::operator unsigned int
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0ImColor@@QAE@MMMM@Z
_TEXT	SEGMENT
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
_a$ = 20						; size = 4
??0ImColor@@QAE@MMMM@Z PROC				; ImColor::ImColor, COMDAT
; _this$ = ecx

; 1126 :     ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }

	npad	2
	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR _r$[ebp]
	mov	eax, ecx
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR _g$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	movss	xmm0, DWORD PTR _b$[ebp]
	movss	DWORD PTR [ecx+8], xmm0
	movss	xmm0, DWORD PTR _a$[ebp]
	movss	DWORD PTR [ecx+12], xmm0
	pop	ebp
	ret	16					; 00000010H
??0ImColor@@QAE@MMMM@Z ENDP				; ImColor::ImColor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0ImColor@@QAE@HHHH@Z
_TEXT	SEGMENT
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
_a$ = 20						; size = 4
??0ImColor@@QAE@HHHH@Z PROC				; ImColor::ImColor, COMDAT
; _this$ = ecx

; 1124 :     ImColor(int r, int g, int b, int a = 255)                       { float sc = 1.0f/255.0f; Value.x = (float)r * sc; Value.y = (float)g * sc; Value.z = (float)b * sc; Value.w = (float)a * sc; }

	npad	2
	push	ebp
	mov	ebp, esp
	movd	xmm0, DWORD PTR _r$[ebp]
	mov	eax, ecx
	movss	xmm1, DWORD PTR __real@3b808081
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	movss	DWORD PTR [ecx], xmm0
	movd	xmm0, DWORD PTR _g$[ebp]
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	movss	DWORD PTR [ecx+4], xmm0
	movd	xmm0, DWORD PTR _b$[ebp]
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	movss	DWORD PTR [ecx+8], xmm0
	movd	xmm0, DWORD PTR _a$[ebp]
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	movss	DWORD PTR [ecx+12], xmm0
	pop	ebp
	ret	16					; 00000010H
??0ImColor@@QAE@HHHH@Z ENDP				; ImColor::ImColor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0ImGuiSizeConstraintCallbackData@@QAE@XZ
_TEXT	SEGMENT
??0ImGuiSizeConstraintCallbackData@@QAE@XZ PROC		; ImGuiSizeConstraintCallbackData::ImGuiSizeConstraintCallbackData, COMDAT
; _this$ = ecx

; 97   :     ImVec2() { x = y = 0.0f; }

	mov	DWORD PTR [ecx+8], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+20], 0
	ret	0
??0ImGuiSizeConstraintCallbackData@@QAE@XZ ENDP		; ImGuiSizeConstraintCallbackData::ImGuiSizeConstraintCallbackData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_pos$ = 8						; size = 4
_new_text$ = 12						; size = 4
_new_text_end$ = 16					; size = 4
?InsertChars@ImGuiTextEditCallbackData@@QAEXHPBD0@Z PROC ; ImGuiTextEditCallbackData::InsertChars
; _this$ = ecx

; 8623 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 8624 :     const int new_text_len = new_text_end ? (int)(new_text_end - new_text) : (int)strlen(new_text);

	mov	esi, DWORD PTR _new_text_end$[ebp]
	push	edi
	mov	edi, ecx
	test	esi, esi
	je	SHORT $LN6@InsertChar
	sub	esi, DWORD PTR _new_text$[ebp]
	jmp	SHORT $LN7@InsertChar
$LN6@InsertChar:
	mov	esi, DWORD PTR _new_text$[ebp]
	lea	ecx, DWORD PTR [esi+1]
	npad	5
$LL8@InsertChar:
	mov	al, BYTE PTR [esi]
	inc	esi
	test	al, al
	jne	SHORT $LL8@InsertChar
	sub	esi, ecx
$LN7@InsertChar:

; 8625 :     if (new_text_len + BufTextLen + 1 >= BufSize)

	mov	edx, DWORD PTR [edi+24]
	lea	eax, DWORD PTR [edx+1]
	add	eax, esi
	cmp	eax, DWORD PTR [edi+28]
	jge	SHORT $LN1@InsertChar

; 8626 :         return;
; 8627 : 
; 8628 :     if (BufTextLen != pos)

	push	ebx
	mov	ebx, DWORD PTR _pos$[ebp]
	cmp	edx, ebx
	je	SHORT $LN3@InsertChar

; 8629 :         memmove(Buf + pos + new_text_len, Buf + pos, (size_t)(BufTextLen - pos));

	mov	ecx, DWORD PTR [edi+20]
	sub	edx, ebx
	push	edx
	lea	eax, DWORD PTR [ecx+ebx]
	push	eax
	lea	eax, DWORD PTR [ecx+esi]
	add	eax, ebx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
$LN3@InsertChar:

; 8630 :     memcpy(Buf + pos, new_text, (size_t)new_text_len * sizeof(char));

	mov	eax, DWORD PTR [edi+20]
	push	esi
	push	DWORD PTR _new_text$[ebp]
	add	eax, ebx
	push	eax
	call	_memcpy

; 8631 :     Buf[BufTextLen + new_text_len] = '\0';

	mov	eax, DWORD PTR [edi+24]
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR [edi+20]
	mov	BYTE PTR [eax+esi], 0

; 8632 : 
; 8633 :     if (CursorPos >= pos)

	mov	eax, DWORD PTR [edi+36]
	cmp	eax, ebx
	pop	ebx
	jl	SHORT $LN4@InsertChar

; 8634 :         CursorPos += new_text_len;

	add	eax, esi
	mov	DWORD PTR [edi+36], eax
$LN4@InsertChar:

; 8635 :     SelectionStart = SelectionEnd = CursorPos;

	mov	eax, DWORD PTR [edi+36]

; 8636 :     BufDirty = true;
; 8637 :     BufTextLen += new_text_len;

	add	DWORD PTR [edi+24], esi
	mov	DWORD PTR [edi+44], eax
	mov	DWORD PTR [edi+40], eax
	mov	BYTE PTR [edi+32], 1
$LN1@InsertChar:
	pop	edi
	pop	esi

; 8638 : }

	pop	ebp
	ret	12					; 0000000cH
?InsertChars@ImGuiTextEditCallbackData@@QAEXHPBD0@Z ENDP ; ImGuiTextEditCallbackData::InsertChars
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_pos$ = 8						; size = 4
_bytes_count$ = 12					; size = 4
?DeleteChars@ImGuiTextEditCallbackData@@QAEXHH@Z PROC	; ImGuiTextEditCallbackData::DeleteChars
; _this$ = ecx

; 8605 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 8606 :     IM_ASSERT(pos + bytes_count <= BufTextLen);
; 8607 :     char* dst = Buf + pos;

	mov	edx, DWORD PTR [ecx+20]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _pos$[ebp]
	add	edx, esi
	push	edi

; 8608 :     const char* src = Buf + pos + bytes_count;

	mov	edi, DWORD PTR _bytes_count$[ebp]

; 8609 :     while (char c = *src++)

	mov	bl, BYTE PTR [edx+edi]
	lea	eax, DWORD PTR [edx+edi]
	inc	eax
	test	bl, bl
	je	SHORT $LN3@DeleteChar
	npad	2
$LL2@DeleteChar:

; 8610 :         *dst++ = c;

	mov	BYTE PTR [edx], bl
	lea	eax, DWORD PTR [eax+1]
	mov	bl, BYTE PTR [eax-1]
	inc	edx
	test	bl, bl
	jne	SHORT $LL2@DeleteChar
$LN3@DeleteChar:

; 8611 :     *dst = '\0';

	mov	BYTE PTR [edx], 0

; 8612 : 
; 8613 :     if (CursorPos + bytes_count >= pos)

	mov	edx, DWORD PTR [ecx+36]
	lea	eax, DWORD PTR [edx+edi]
	cmp	eax, esi
	jl	SHORT $LN4@DeleteChar

; 8614 :         CursorPos -= bytes_count;

	sub	edx, edi
	mov	DWORD PTR [ecx+36], edx
	jmp	SHORT $LN6@DeleteChar
$LN4@DeleteChar:

; 8615 :     else if (CursorPos >= pos)

	cmp	edx, esi
	jl	SHORT $LN6@DeleteChar

; 8616 :         CursorPos = pos;

	mov	DWORD PTR [ecx+36], esi
$LN6@DeleteChar:

; 8617 :     SelectionStart = SelectionEnd = CursorPos;
; 8618 :     BufDirty = true;
; 8619 :     BufTextLen -= bytes_count;

	sub	DWORD PTR [ecx+24], edi
	mov	eax, DWORD PTR [ecx+36]
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx+44], eax
	mov	DWORD PTR [ecx+40], eax
	mov	BYTE PTR [ecx+32], 1
	pop	ebx

; 8620 : }

	pop	ebp
	ret	8
?DeleteChars@ImGuiTextEditCallbackData@@QAEXHH@Z ENDP	; ImGuiTextEditCallbackData::DeleteChars
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1ImGuiStorage@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1ImGuiStorage@@QAE@XZ PROC				; ImGuiStorage::~ImGuiStorage, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1ImGuiStorage@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN4@ImGuiStora
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN4@ImGuiStora:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1ImGuiStorage@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1ImGuiStorage@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1ImGuiStorage@@QAE@XZ ENDP				; ImGuiStorage::~ImGuiStorage
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0ImGuiStorage@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ImGuiStorage@@QAE@XZ PROC				; ImGuiStorage::ImGuiStorage, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	mov	esp, ebp
	pop	ebp
	ret	0
??0ImGuiStorage@@QAE@XZ ENDP				; ImGuiStorage::ImGuiStorage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_v$ = 8							; size = 4
?SetAllInt@ImGuiStorage@@QAEXH@Z PROC			; ImGuiStorage::SetAllInt
; _this$ = ecx

; 1543 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	edx, ecx

; 1544 :     for (int i = 0; i < Data.Size; i++)

	xor	eax, eax
	cmp	DWORD PTR [edx], eax
	jle	SHORT $LN3@SetAllInt
	push	esi
	mov	esi, DWORD PTR _v$[ebp]
$LL4@SetAllInt:

; 1545 :         Data[i].val_i = v;

	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+eax*8+4], esi
	inc	eax
	cmp	eax, DWORD PTR [edx]
	jl	SHORT $LL4@SetAllInt
	pop	esi
$LN3@SetAllInt:

; 1546 : }

	pop	ebp
	ret	4
?SetAllInt@ImGuiStorage@@QAEXH@Z ENDP			; ImGuiStorage::SetAllInt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 8
_key$ = 8						; size = 4
_default_val$ = 12					; size = 4
?GetVoidPtrRef@ImGuiStorage@@QAEPAPAXIPAX@Z PROC	; ImGuiStorage::GetVoidPtrRef
; _this$ = ecx

; 1496 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi

; 1497 :     ImVector<Pair>::iterator it = LowerBound(Data, key);

	push	DWORD PTR _key$[ebp]
	mov	ebx, ecx
	push	ebx
	call	?LowerBound@@YAPAUPair@ImGuiStorage@@AAV?$ImVector@UPair@ImGuiStorage@@@@I@Z ; LowerBound
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 918  :     inline iterator             end()                           { return Data + Size; }

	mov	esi, DWORD PTR [ebx]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1497 :     ImVector<Pair>::iterator it = LowerBound(Data, key);

	mov	edi, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 918  :     inline iterator             end()                           { return Data + Size; }

	mov	edx, DWORD PTR [ebx+8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1497 :     ImVector<Pair>::iterator it = LowerBound(Data, key);

	add	esp, 8

; 1498 :     if (it == Data.end() || it->key != key)

	mov	eax, DWORD PTR _key$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 918  :     inline iterator             end()                           { return Data + Size; }

	lea	ecx, DWORD PTR [edx+esi*8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1498 :     if (it == Data.end() || it->key != key)

	cmp	edi, ecx
	je	SHORT $LN3@GetVoidPtr
	cmp	DWORD PTR [edi], eax
	jne	SHORT $LN3@GetVoidPtr

; 1500 :     return &it->val_p;

	lea	eax, DWORD PTR [edi+4]
	pop	edi
	pop	esi
	pop	ebx

; 1501 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN3@GetVoidPtr:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1028 :         Pair(ImGuiID _key, void* _val_p) { key = _key; val_p = _val_p; }

	mov	DWORD PTR $T1[ebp], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1499 :         it = Data.insert(it, Pair(key, default_val));

	mov	ecx, ebx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1028 :         Pair(ImGuiID _key, void* _val_p) { key = _key; val_p = _val_p; }

	mov	eax, DWORD PTR _default_val$[ebp]
	mov	DWORD PTR $T1[ebp+4], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1499 :         it = Data.insert(it, Pair(key, default_val));

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	push	edi
	call	?insert@?$ImVector@UPair@ImGuiStorage@@@@QAEPAUPair@ImGuiStorage@@PBU23@ABU23@@Z ; ImVector<ImGuiStorage::Pair>::insert
	pop	edi
	pop	esi

; 1500 :     return &it->val_p;

	add	eax, 4
	pop	ebx

; 1501 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetVoidPtrRef@ImGuiStorage@@QAEPAPAXIPAX@Z ENDP	; ImGuiStorage::GetVoidPtrRef
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 8
_key$ = 8						; size = 4
_default_val$ = 12					; size = 4
?GetFloatRef@ImGuiStorage@@QAEPAMIM@Z PROC		; ImGuiStorage::GetFloatRef
; _this$ = ecx

; 1488 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx

; 1489 :     ImVector<Pair>::iterator it = LowerBound(Data, key);

	mov	ebx, DWORD PTR _key$[ebp]
	push	esi
	push	edi
	mov	edi, ecx
	push	ebx
	push	edi
	call	?LowerBound@@YAPAUPair@ImGuiStorage@@AAV?$ImVector@UPair@ImGuiStorage@@@@I@Z ; LowerBound
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 918  :     inline iterator             end()                           { return Data + Size; }

	mov	esi, DWORD PTR [edi]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1489 :     ImVector<Pair>::iterator it = LowerBound(Data, key);

	add	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 918  :     inline iterator             end()                           { return Data + Size; }

	mov	edx, DWORD PTR [edi+8]
	lea	ecx, DWORD PTR [edx+esi*8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1490 :     if (it == Data.end() || it->key != key)

	cmp	eax, ecx
	je	SHORT $LN3@GetFloatRe
	cmp	DWORD PTR [eax], ebx
	je	SHORT $LN10@GetFloatRe
$LN3@GetFloatRe:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1027 :         Pair(ImGuiID _key, float _val_f) { key = _key; val_f = _val_f; }

	movss	xmm0, DWORD PTR _default_val$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1491 :         it = Data.insert(it, Pair(key, default_val));

	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	push	eax
	mov	ecx, edi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1027 :         Pair(ImGuiID _key, float _val_f) { key = _key; val_f = _val_f; }

	mov	DWORD PTR $T1[ebp], ebx
	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1491 :         it = Data.insert(it, Pair(key, default_val));

	call	?insert@?$ImVector@UPair@ImGuiStorage@@@@QAEPAUPair@ImGuiStorage@@PBU23@ABU23@@Z ; ImVector<ImGuiStorage::Pair>::insert
$LN10@GetFloatRe:

; 1492 :     return &it->val_f;

	pop	edi
	pop	esi
	add	eax, 4
	pop	ebx

; 1493 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetFloatRef@ImGuiStorage@@QAEPAMIM@Z ENDP		; ImGuiStorage::GetFloatRef
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_key$ = 8						; size = 4
_default_val$ = 12					; size = 1
?GetBoolRef@ImGuiStorage@@QAEPA_NI_N@Z PROC		; ImGuiStorage::GetBoolRef
; _this$ = ecx

; 1483 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1484 :     return (bool*)GetIntRef(key, default_val ? 1 : 0);

	movzx	eax, BYTE PTR _default_val$[ebp]
	mov	DWORD PTR _default_val$[ebp], eax

; 1485 : }

	pop	ebp

; 1484 :     return (bool*)GetIntRef(key, default_val ? 1 : 0);

	jmp	?GetIntRef@ImGuiStorage@@QAEPAHIH@Z	; ImGuiStorage::GetIntRef
?GetBoolRef@ImGuiStorage@@QAEPA_NI_N@Z ENDP		; ImGuiStorage::GetBoolRef
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 8
_key$ = 8						; size = 4
_default_val$ = 12					; size = 4
?GetIntRef@ImGuiStorage@@QAEPAHIH@Z PROC		; ImGuiStorage::GetIntRef
; _this$ = ecx

; 1475 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi

; 1476 :     ImVector<Pair>::iterator it = LowerBound(Data, key);

	push	DWORD PTR _key$[ebp]
	mov	ebx, ecx
	push	ebx
	call	?LowerBound@@YAPAUPair@ImGuiStorage@@AAV?$ImVector@UPair@ImGuiStorage@@@@I@Z ; LowerBound
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 918  :     inline iterator             end()                           { return Data + Size; }

	mov	esi, DWORD PTR [ebx]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1476 :     ImVector<Pair>::iterator it = LowerBound(Data, key);

	mov	edi, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 918  :     inline iterator             end()                           { return Data + Size; }

	mov	edx, DWORD PTR [ebx+8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1476 :     ImVector<Pair>::iterator it = LowerBound(Data, key);

	add	esp, 8

; 1477 :     if (it == Data.end() || it->key != key)

	mov	eax, DWORD PTR _key$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 918  :     inline iterator             end()                           { return Data + Size; }

	lea	ecx, DWORD PTR [edx+esi*8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1477 :     if (it == Data.end() || it->key != key)

	cmp	edi, ecx
	je	SHORT $LN3@GetIntRef
	cmp	DWORD PTR [edi], eax
	jne	SHORT $LN3@GetIntRef

; 1479 :     return &it->val_i;

	lea	eax, DWORD PTR [edi+4]
	pop	edi
	pop	esi
	pop	ebx

; 1480 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN3@GetIntRef:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1026 :         Pair(ImGuiID _key, int _val_i) { key = _key; val_i = _val_i; }

	mov	DWORD PTR $T1[ebp], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1478 :         it = Data.insert(it, Pair(key, default_val));

	mov	ecx, ebx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1026 :         Pair(ImGuiID _key, int _val_i) { key = _key; val_i = _val_i; }

	mov	eax, DWORD PTR _default_val$[ebp]
	mov	DWORD PTR $T1[ebp+4], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1478 :         it = Data.insert(it, Pair(key, default_val));

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	push	edi
	call	?insert@?$ImVector@UPair@ImGuiStorage@@@@QAEPAUPair@ImGuiStorage@@PBU23@ABU23@@Z ; ImVector<ImGuiStorage::Pair>::insert
	pop	edi
	pop	esi

; 1479 :     return &it->val_i;

	add	eax, 4
	pop	ebx

; 1480 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetIntRef@ImGuiStorage@@QAEPAHIH@Z ENDP		; ImGuiStorage::GetIntRef
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$1$ = -4						; size = 4
_key$ = 8						; size = 4
_val$ = 12						; size = 4
?SetVoidPtr@ImGuiStorage@@QAEXIPAX@Z PROC		; ImGuiStorage::SetVoidPtr
; _this$ = ecx

; 1532 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx

; 1533 :     ImVector<Pair>::iterator it = LowerBound(Data, key);

	mov	ebx, DWORD PTR _key$[ebp]
	push	esi
	push	edi
	mov	esi, ecx
	push	ebx
	push	esi
	mov	DWORD PTR _this$1$[ebp], esi
	call	?LowerBound@@YAPAUPair@ImGuiStorage@@AAV?$ImVector@UPair@ImGuiStorage@@@@I@Z ; LowerBound
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 918  :     inline iterator             end()                           { return Data + Size; }

	mov	edx, DWORD PTR _this$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1533 :     ImVector<Pair>::iterator it = LowerBound(Data, key);

	mov	edi, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 918  :     inline iterator             end()                           { return Data + Size; }

	mov	esi, DWORD PTR [esi]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1533 :     ImVector<Pair>::iterator it = LowerBound(Data, key);

	add	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 918  :     inline iterator             end()                           { return Data + Size; }

	mov	edx, DWORD PTR [edx+8]
	lea	ecx, DWORD PTR [edx+esi*8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1534 :     if (it == Data.end() || it->key != key)

	cmp	edi, ecx
	je	SHORT $LN3@SetVoidPtr
	cmp	DWORD PTR [edi], ebx
	jne	SHORT $LN3@SetVoidPtr

; 1537 :         return;
; 1538 :     }
; 1539 :     it->val_p = val;

	mov	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR [edi+4], eax
	pop	edi
	pop	esi
	pop	ebx

; 1540 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN3@SetVoidPtr:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1028 :         Pair(ImGuiID _key, void* _val_p) { key = _key; val_p = _val_p; }

	mov	eax, DWORD PTR _val$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1536 :         Data.insert(it, Pair(key, val));

	mov	ecx, DWORD PTR _this$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1028 :         Pair(ImGuiID _key, void* _val_p) { key = _key; val_p = _val_p; }

	mov	DWORD PTR $T1[ebp+4], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1536 :         Data.insert(it, Pair(key, val));

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	push	edi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1028 :         Pair(ImGuiID _key, void* _val_p) { key = _key; val_p = _val_p; }

	mov	DWORD PTR $T1[ebp], ebx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1536 :         Data.insert(it, Pair(key, val));

	call	?insert@?$ImVector@UPair@ImGuiStorage@@@@QAEPAUPair@ImGuiStorage@@PBU23@ABU23@@Z ; ImVector<ImGuiStorage::Pair>::insert
	pop	edi
	pop	esi
	pop	ebx

; 1540 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetVoidPtr@ImGuiStorage@@QAEXIPAX@Z ENDP		; ImGuiStorage::SetVoidPtr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_key$ = 8						; size = 4
?GetVoidPtr@ImGuiStorage@@QBEPAXI@Z PROC		; ImGuiStorage::GetVoidPtr
; _this$ = ecx

; 1466 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 1467 :     ImVector<Pair>::iterator it = LowerBound(const_cast<ImVector<ImGuiStorage::Pair>&>(Data), key);

	mov	edi, DWORD PTR _key$[ebp]
	mov	esi, ecx
	push	edi
	push	esi
	call	?LowerBound@@YAPAUPair@ImGuiStorage@@AAV?$ImVector@UPair@ImGuiStorage@@@@I@Z ; LowerBound
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 919  :     inline const_iterator       end() const                     { return Data + Size; }

	mov	edx, DWORD PTR [esi]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1467 :     ImVector<Pair>::iterator it = LowerBound(const_cast<ImVector<ImGuiStorage::Pair>&>(Data), key);

	add	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 919  :     inline const_iterator       end() const                     { return Data + Size; }

	mov	ecx, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [ecx+edx*8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1468 :     if (it == Data.end() || it->key != key)

	cmp	eax, ecx
	je	SHORT $LN3@GetVoidPtr
	cmp	DWORD PTR [eax], edi
	jne	SHORT $LN3@GetVoidPtr

; 1470 :     return it->val_p;

	mov	eax, DWORD PTR [eax+4]
	pop	edi
	pop	esi

; 1471 : }

	pop	ebp
	ret	4
$LN3@GetVoidPtr:
	pop	edi

; 1469 :         return NULL;

	xor	eax, eax
	pop	esi

; 1471 : }

	pop	ebp
	ret	4
?GetVoidPtr@ImGuiStorage@@QBEPAXI@Z ENDP		; ImGuiStorage::GetVoidPtr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 8
_key$ = 8						; size = 4
_val$ = 12						; size = 4
?SetFloat@ImGuiStorage@@QAEXIM@Z PROC			; ImGuiStorage::SetFloat
; _this$ = ecx

; 1521 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi

; 1522 :     ImVector<Pair>::iterator it = LowerBound(Data, key);

	mov	edi, DWORD PTR _key$[ebp]
	mov	ebx, ecx
	push	edi
	push	ebx
	call	?LowerBound@@YAPAUPair@ImGuiStorage@@AAV?$ImVector@UPair@ImGuiStorage@@@@I@Z ; LowerBound
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 918  :     inline iterator             end()                           { return Data + Size; }

	mov	esi, DWORD PTR [ebx]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1522 :     ImVector<Pair>::iterator it = LowerBound(Data, key);

	add	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 918  :     inline iterator             end()                           { return Data + Size; }

	mov	edx, DWORD PTR [ebx+8]
	lea	ecx, DWORD PTR [edx+esi*8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1523 :     if (it == Data.end() || it->key != key)

	cmp	eax, ecx
	je	SHORT $LN3@SetFloat
	cmp	DWORD PTR [eax], edi
	jne	SHORT $LN3@SetFloat

; 1526 :         return;
; 1527 :     }
; 1528 :     it->val_f = val;

	movss	xmm0, DWORD PTR _val$[ebp]
	pop	edi
	pop	esi
	movss	DWORD PTR [eax+4], xmm0
	pop	ebx

; 1529 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN3@SetFloat:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1027 :         Pair(ImGuiID _key, float _val_f) { key = _key; val_f = _val_f; }

	movss	xmm0, DWORD PTR _val$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1525 :         Data.insert(it, Pair(key, val));

	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	push	eax
	mov	ecx, ebx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1027 :         Pair(ImGuiID _key, float _val_f) { key = _key; val_f = _val_f; }

	mov	DWORD PTR $T1[ebp], edi
	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1525 :         Data.insert(it, Pair(key, val));

	call	?insert@?$ImVector@UPair@ImGuiStorage@@@@QAEPAUPair@ImGuiStorage@@PBU23@ABU23@@Z ; ImVector<ImGuiStorage::Pair>::insert
	pop	edi
	pop	esi
	pop	ebx

; 1529 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetFloat@ImGuiStorage@@QAEXIM@Z ENDP			; ImGuiStorage::SetFloat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_key$ = 8						; size = 4
_default_val$ = 12					; size = 4
?GetFloat@ImGuiStorage@@QBEMIM@Z PROC			; ImGuiStorage::GetFloat
; _this$ = ecx

; 1458 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 1459 :     ImVector<Pair>::iterator it = LowerBound(const_cast<ImVector<ImGuiStorage::Pair>&>(Data), key);

	mov	edi, DWORD PTR _key$[ebp]
	mov	esi, ecx
	push	edi
	push	esi
	call	?LowerBound@@YAPAUPair@ImGuiStorage@@AAV?$ImVector@UPair@ImGuiStorage@@@@I@Z ; LowerBound
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 919  :     inline const_iterator       end() const                     { return Data + Size; }

	mov	edx, DWORD PTR [esi]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1459 :     ImVector<Pair>::iterator it = LowerBound(const_cast<ImVector<ImGuiStorage::Pair>&>(Data), key);

	add	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 919  :     inline const_iterator       end() const                     { return Data + Size; }

	mov	ecx, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [ecx+edx*8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1460 :     if (it == Data.end() || it->key != key)

	cmp	eax, ecx
	je	SHORT $LN3@GetFloat
	cmp	DWORD PTR [eax], edi
	jne	SHORT $LN3@GetFloat

; 1462 :     return it->val_f;

	fld	DWORD PTR [eax+4]
	pop	edi
	pop	esi

; 1463 : }

	pop	ebp
	ret	8
$LN3@GetFloat:

; 1461 :         return default_val;

	fld	DWORD PTR _default_val$[ebp]
	pop	edi
	pop	esi

; 1463 : }

	pop	ebp
	ret	8
?GetFloat@ImGuiStorage@@QBEMIM@Z ENDP			; ImGuiStorage::GetFloat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_key$ = 8						; size = 4
_val$ = 12						; size = 1
?SetBool@ImGuiStorage@@QAEXI_N@Z PROC			; ImGuiStorage::SetBool
; _this$ = ecx

; 1516 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1517 :     SetInt(key, val ? 1 : 0);

	movzx	eax, BYTE PTR _val$[ebp]
	mov	DWORD PTR _val$[ebp], eax

; 1518 : }

	pop	ebp

; 1517 :     SetInt(key, val ? 1 : 0);

	jmp	?SetInt@ImGuiStorage@@QAEXIH@Z		; ImGuiStorage::SetInt
?SetBool@ImGuiStorage@@QAEXI_N@Z ENDP			; ImGuiStorage::SetBool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_key$ = 8						; size = 4
_default_val$ = 12					; size = 1
?GetBool@ImGuiStorage@@QBE_NI_N@Z PROC			; ImGuiStorage::GetBool
; _this$ = ecx

; 1453 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1454 :     return GetInt(key, default_val ? 1 : 0) != 0;

	movzx	eax, BYTE PTR _default_val$[ebp]
	push	eax
	push	DWORD PTR _key$[ebp]
	call	?GetInt@ImGuiStorage@@QBEHIH@Z		; ImGuiStorage::GetInt
	test	eax, eax
	setne	al

; 1455 : }

	pop	ebp
	ret	8
?GetBool@ImGuiStorage@@QBE_NI_N@Z ENDP			; ImGuiStorage::GetBool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$1$ = -4						; size = 4
_key$ = 8						; size = 4
_val$ = 12						; size = 4
?SetInt@ImGuiStorage@@QAEXIH@Z PROC			; ImGuiStorage::SetInt
; _this$ = ecx

; 1505 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx

; 1506 :     ImVector<Pair>::iterator it = LowerBound(Data, key);

	mov	ebx, DWORD PTR _key$[ebp]
	push	esi
	push	edi
	mov	esi, ecx
	push	ebx
	push	esi
	mov	DWORD PTR _this$1$[ebp], esi
	call	?LowerBound@@YAPAUPair@ImGuiStorage@@AAV?$ImVector@UPair@ImGuiStorage@@@@I@Z ; LowerBound
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 918  :     inline iterator             end()                           { return Data + Size; }

	mov	edx, DWORD PTR _this$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1506 :     ImVector<Pair>::iterator it = LowerBound(Data, key);

	mov	edi, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 918  :     inline iterator             end()                           { return Data + Size; }

	mov	esi, DWORD PTR [esi]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1506 :     ImVector<Pair>::iterator it = LowerBound(Data, key);

	add	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 918  :     inline iterator             end()                           { return Data + Size; }

	mov	edx, DWORD PTR [edx+8]
	lea	ecx, DWORD PTR [edx+esi*8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1507 :     if (it == Data.end() || it->key != key)

	cmp	edi, ecx
	je	SHORT $LN3@SetInt
	cmp	DWORD PTR [edi], ebx
	jne	SHORT $LN3@SetInt

; 1510 :         return;
; 1511 :     }
; 1512 :     it->val_i = val;

	mov	eax, DWORD PTR _val$[ebp]
	mov	DWORD PTR [edi+4], eax
	pop	edi
	pop	esi
	pop	ebx

; 1513 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN3@SetInt:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1026 :         Pair(ImGuiID _key, int _val_i) { key = _key; val_i = _val_i; }

	mov	eax, DWORD PTR _val$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1509 :         Data.insert(it, Pair(key, val));

	mov	ecx, DWORD PTR _this$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1026 :         Pair(ImGuiID _key, int _val_i) { key = _key; val_i = _val_i; }

	mov	DWORD PTR $T1[ebp+4], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1509 :         Data.insert(it, Pair(key, val));

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	push	edi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1026 :         Pair(ImGuiID _key, int _val_i) { key = _key; val_i = _val_i; }

	mov	DWORD PTR $T1[ebp], ebx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1509 :         Data.insert(it, Pair(key, val));

	call	?insert@?$ImVector@UPair@ImGuiStorage@@@@QAEPAUPair@ImGuiStorage@@PBU23@ABU23@@Z ; ImVector<ImGuiStorage::Pair>::insert
	pop	edi
	pop	esi
	pop	ebx

; 1513 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SetInt@ImGuiStorage@@QAEXIH@Z ENDP			; ImGuiStorage::SetInt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_key$ = 8						; size = 4
_default_val$ = 12					; size = 4
?GetInt@ImGuiStorage@@QBEHIH@Z PROC			; ImGuiStorage::GetInt
; _this$ = ecx

; 1445 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 1446 :     ImVector<Pair>::iterator it = LowerBound(const_cast<ImVector<ImGuiStorage::Pair>&>(Data), key);

	mov	edi, DWORD PTR _key$[ebp]
	mov	esi, ecx
	push	edi
	push	esi
	call	?LowerBound@@YAPAUPair@ImGuiStorage@@AAV?$ImVector@UPair@ImGuiStorage@@@@I@Z ; LowerBound
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 919  :     inline const_iterator       end() const                     { return Data + Size; }

	mov	edx, DWORD PTR [esi]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1446 :     ImVector<Pair>::iterator it = LowerBound(const_cast<ImVector<ImGuiStorage::Pair>&>(Data), key);

	add	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 919  :     inline const_iterator       end() const                     { return Data + Size; }

	mov	ecx, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [ecx+edx*8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1447 :     if (it == Data.end() || it->key != key)

	cmp	eax, ecx
	je	SHORT $LN3@GetInt
	cmp	DWORD PTR [eax], edi
	jne	SHORT $LN3@GetInt

; 1449 :     return it->val_i;

	mov	eax, DWORD PTR [eax+4]
	pop	edi
	pop	esi

; 1450 : }

	pop	ebp
	ret	8
$LN3@GetInt:

; 1448 :         return default_val;

	mov	eax, DWORD PTR _default_val$[ebp]
	pop	edi
	pop	esi

; 1450 : }

	pop	ebp
	ret	8
?GetInt@ImGuiStorage@@QBEHIH@Z ENDP			; ImGuiStorage::GetInt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?Clear@ImGuiStorage@@QAEXXZ PROC			; ImGuiStorage::Clear
; _this$ = ecx

; 1417 : {

	npad	2
	push	esi
	mov	esi, ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN4@Clear
	push	eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+8], 0
$LN4@Clear:
	pop	esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1419 : }

	ret	0
?Clear@ImGuiStorage@@QAEXXZ ENDP			; ImGuiStorage::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?insert@?$ImVector@UPair@ImGuiStorage@@@@QAEPAUPair@ImGuiStorage@@PBU23@ABU23@@Z
_TEXT	SEGMENT
_new_data$1$ = 8					; size = 4
_it$ = 8						; size = 4
_v$ = 12						; size = 4
?insert@?$ImVector@UPair@ImGuiStorage@@@@QAEPAUPair@ImGuiStorage@@PBU23@ABU23@@Z PROC ; ImVector<ImGuiStorage::Pair>::insert, COMDAT
; _this$ = ecx

; 944  :     inline iterator             insert(const_iterator it, const value_type& v)  { IM_ASSERT(it >= Data && it <= Data+Size); const ptrdiff_t off = it - Data; if (Size == Capacity) reserve(Capacity ? Capacity * 2 : 4); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(value_type)); Data[off] = v; Size++; return Data + off; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR _it$[ebp]
	push	edi
	mov	edi, ecx
	sub	esi, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [edi+4]
	sar	esi, 3
	cmp	DWORD PTR [edi], eax
	jne	SHORT $LN7@insert
	push	ebx
	lea	ebx, DWORD PTR [eax+eax]
	test	eax, eax
	jne	SHORT $LN6@insert
	mov	ebx, 4
$LN6@insert:

; 931  :         if (new_capacity <= Capacity) return;

	cmp	ebx, eax
	jle	SHORT $LN11@insert

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [ebx*8]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [edi+8]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN9@insert

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [edi]
	shl	ecx, 3
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN9@insert:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [edi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [edi+8], eax

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [edi+4], ebx
$LN11@insert:
	pop	ebx
$LN7@insert:

; 944  :     inline iterator             insert(const_iterator it, const value_type& v)  { IM_ASSERT(it >= Data && it <= Data+Size); const ptrdiff_t off = it - Data; if (Size == Capacity) reserve(Capacity ? Capacity * 2 : 4); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(value_type)); Data[off] = v; Size++; return Data + off; }

	mov	ecx, DWORD PTR [edi]
	cmp	esi, ecx
	jge	SHORT $LN3@insert
	mov	eax, DWORD PTR [edi+8]
	sub	ecx, esi
	shl	ecx, 3
	push	ecx
	lea	eax, DWORD PTR [eax+esi*8]
	push	eax
	add	eax, 8
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
$LN3@insert:
	mov	edx, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR _v$[ebp]
	shl	esi, 3
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi+edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+edx+4], eax
	inc	DWORD PTR [edi]
	mov	eax, DWORD PTR [edi+8]
	pop	edi
	add	eax, esi
	pop	esi
	pop	ebp
	ret	8
?insert@?$ImVector@UPair@ImGuiStorage@@@@QAEPAUPair@ImGuiStorage@@PBU23@ABU23@@Z ENDP ; ImVector<ImGuiStorage::Pair>::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UPair@ImGuiStorage@@@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UPair@ImGuiStorage@@@@QAEXH@Z PROC	; ImVector<ImGuiStorage::Pair>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*8]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 3
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@UPair@ImGuiStorage@@@@QAEXH@Z ENDP	; ImVector<ImGuiStorage::Pair>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?end@?$ImVector@UPair@ImGuiStorage@@@@QBEPBUPair@ImGuiStorage@@XZ
_TEXT	SEGMENT
?end@?$ImVector@UPair@ImGuiStorage@@@@QBEPBUPair@ImGuiStorage@@XZ PROC ; ImVector<ImGuiStorage::Pair>::end, COMDAT
; _this$ = ecx

; 919  :     inline const_iterator       end() const                     { return Data + Size; }

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [eax+edx*8]
	ret	0
?end@?$ImVector@UPair@ImGuiStorage@@@@QBEPBUPair@ImGuiStorage@@XZ ENDP ; ImVector<ImGuiStorage::Pair>::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?end@?$ImVector@UPair@ImGuiStorage@@@@QAEPAUPair@ImGuiStorage@@XZ
_TEXT	SEGMENT
?end@?$ImVector@UPair@ImGuiStorage@@@@QAEPAUPair@ImGuiStorage@@XZ PROC ; ImVector<ImGuiStorage::Pair>::end, COMDAT
; _this$ = ecx

; 918  :     inline iterator             end()                           { return Data + Size; }

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [eax+edx*8]
	ret	0
?end@?$ImVector@UPair@ImGuiStorage@@@@QAEPAUPair@ImGuiStorage@@XZ ENDP ; ImVector<ImGuiStorage::Pair>::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?begin@?$ImVector@UPair@ImGuiStorage@@@@QAEPAUPair@ImGuiStorage@@XZ
_TEXT	SEGMENT
?begin@?$ImVector@UPair@ImGuiStorage@@@@QAEPAUPair@ImGuiStorage@@XZ PROC ; ImVector<ImGuiStorage::Pair>::begin, COMDAT
; _this$ = ecx

; 916  :     inline iterator             begin()                         { return Data; }

	mov	eax, DWORD PTR [ecx+8]
	ret	0
?begin@?$ImVector@UPair@ImGuiStorage@@@@QAEPAUPair@ImGuiStorage@@XZ ENDP ; ImVector<ImGuiStorage::Pair>::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@UPair@ImGuiStorage@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$ImVector@UPair@ImGuiStorage@@@@QAEXXZ PROC	; ImVector<ImGuiStorage::Pair>::clear, COMDAT
; _this$ = ecx

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	npad	2
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN2@clear
	push	eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+8], 0
$LN2@clear:
	pop	esi
	ret	0
?clear@?$ImVector@UPair@ImGuiStorage@@@@QAEXXZ ENDP	; ImVector<ImGuiStorage::Pair>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@UPair@ImGuiStorage@@@@QAEAAUPair@ImGuiStorage@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@UPair@ImGuiStorage@@@@QAEAAUPair@ImGuiStorage@@H@Z PROC ; ImVector<ImGuiStorage::Pair>::operator[], COMDAT
; _this$ = ecx

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+eax*8]
	pop	ebp
	ret	4
??A?$ImVector@UPair@ImGuiStorage@@@@QAEAAUPair@ImGuiStorage@@H@Z ENDP ; ImVector<ImGuiStorage::Pair>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@UPair@ImGuiStorage@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@UPair@ImGuiStorage@@@@QAE@XZ PROC		; ImVector<ImGuiStorage::Pair>::~ImVector<ImGuiStorage::Pair>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@UPair@ImGuiStorage@@@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@UPair@ImGuiStorage@@@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@UPair@ImGuiStorage@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@UPair@ImGuiStorage@@@@QAE@XZ ENDP		; ImVector<ImGuiStorage::Pair>::~ImVector<ImGuiStorage::Pair>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@UPair@ImGuiStorage@@@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@UPair@ImGuiStorage@@@@QAE@XZ PROC		; ImVector<ImGuiStorage::Pair>::ImVector<ImGuiStorage::Pair>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@UPair@ImGuiStorage@@@@QAE@XZ ENDP		; ImVector<ImGuiStorage::Pair>::ImVector<ImGuiStorage::Pair>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0Pair@ImGuiStorage@@QAE@IPAX@Z
_TEXT	SEGMENT
__key$ = 8						; size = 4
__val_p$ = 12						; size = 4
??0Pair@ImGuiStorage@@QAE@IPAX@Z PROC			; ImGuiStorage::Pair::Pair, COMDAT
; _this$ = ecx

; 1028 :         Pair(ImGuiID _key, void* _val_p) { key = _key; val_p = _val_p; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __key$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __val_p$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, ecx
	pop	ebp
	ret	8
??0Pair@ImGuiStorage@@QAE@IPAX@Z ENDP			; ImGuiStorage::Pair::Pair
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0Pair@ImGuiStorage@@QAE@IM@Z
_TEXT	SEGMENT
__key$ = 8						; size = 4
__val_f$ = 12						; size = 4
??0Pair@ImGuiStorage@@QAE@IM@Z PROC			; ImGuiStorage::Pair::Pair, COMDAT
; _this$ = ecx

; 1027 :         Pair(ImGuiID _key, float _val_f) { key = _key; val_f = _val_f; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __key$[ebp]
	movss	xmm0, DWORD PTR __val_f$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	movss	DWORD PTR [ecx+4], xmm0
	pop	ebp
	ret	8
??0Pair@ImGuiStorage@@QAE@IM@Z ENDP			; ImGuiStorage::Pair::Pair
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0Pair@ImGuiStorage@@QAE@IH@Z
_TEXT	SEGMENT
__key$ = 8						; size = 4
__val_i$ = 12						; size = 4
??0Pair@ImGuiStorage@@QAE@IH@Z PROC			; ImGuiStorage::Pair::Pair, COMDAT
; _this$ = ecx

; 1026 :         Pair(ImGuiID _key, int _val_i) { key = _key; val_i = _val_i; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __key$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __val_i$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, ecx
	pop	ebp
	ret	8
??0Pair@ImGuiStorage@@QAE@IH@Z ENDP			; ImGuiStorage::Pair::Pair
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??_GImGuiTextBuffer@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_GImGuiTextBuffer@@QAEPAXI@Z PROC			; ImGuiTextBuffer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??_GImGuiTextBuffer@@QAEPAXI@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN8@scalar
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN8@scalar:
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN11@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN11@scalar:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_GImGuiTextBuffer@@QAEPAXI@Z:
	mov	eax, OFFSET __ehfuncinfo$??_GImGuiTextBuffer@@QAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_GImGuiTextBuffer@@QAEPAXI@Z ENDP			; ImGuiTextBuffer::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1ImGuiTextBuffer@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1ImGuiTextBuffer@@QAE@XZ PROC				; ImGuiTextBuffer::~ImGuiTextBuffer, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1ImGuiTextBuffer@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN4@ImGuiTextB
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN4@ImGuiTextB:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1ImGuiTextBuffer@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1ImGuiTextBuffer@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1ImGuiTextBuffer@@QAE@XZ ENDP				; ImGuiTextBuffer::~ImGuiTextBuffer
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_write_off$1$ = -12					; size = 4
_needed_sz$1$ = -8					; size = 4
_new_data$1$ = -4					; size = 4
_fmt$ = 8						; size = 4
_args$ = 12						; size = 4
?appendv@ImGuiTextBuffer@@QAEXPBDPAD@Z PROC		; ImGuiTextBuffer::appendv
; _this$ = ecx

; 1660 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	push	edi

; 1661 :     va_list args_copy;
; 1662 :     va_copy(args_copy, args);
; 1663 : 
; 1664 :     int len = vsnprintf(NULL, 0, fmt, args);         // FIXME-OPT: could do a first pass write attempt, likely successful on first pass.

	push	DWORD PTR _args$[ebp]
	mov	esi, ecx
	push	DWORD PTR _fmt$[ebp]
	push	0
	push	0
	call	_vsnprintf
	mov	edi, eax
	add	esp, 16					; 00000010H

; 1665 :     if (len <= 0)

	test	edi, edi
	jle	SHORT $LN1@appendv

; 1666 :         return;
; 1667 : 
; 1668 :     const int write_off = Buf.Size;

	mov	eax, DWORD PTR [esi]

; 1669 :     const int needed_sz = write_off + len;
; 1670 :     if (write_off + len >= Buf.Capacity)

	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR _write_off$1$[ebp], eax
	add	eax, edi
	mov	DWORD PTR _needed_sz$1$[ebp], eax
	cmp	eax, ecx
	jl	SHORT $LN5@appendv

; 1671 :     {
; 1672 :         int double_capacity = Buf.Capacity * 2;

	push	ebx
	lea	ebx, DWORD PTR [ecx+ecx]

; 1673 :         Buf.reserve(needed_sz > double_capacity ? needed_sz : double_capacity);

	cmp	eax, ebx
	cmovg	ebx, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 931  :         if (new_capacity <= Capacity) return;

	cmp	ebx, ecx
	jle	SHORT $LN11@appendv

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	push	ebx
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	ecx, DWORD PTR [esi+8]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	ecx, ecx
	je	SHORT $LN7@appendv

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	push	DWORD PTR [esi]
	push	ecx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN7@appendv:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR _needed_sz$1$[ebp]

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], ebx
$LN11@appendv:
	pop	ebx
$LN5@appendv:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1676 :     Buf.resize(needed_sz);

	push	eax
	mov	ecx, esi
	call	?resize@?$ImVector@D@@QAEXH@Z		; ImVector<char>::resize

; 1677 :     ImFormatStringV(&Buf[write_off] - 1, len+1, fmt, args_copy);

	push	DWORD PTR _args$[ebp]
	mov	ecx, DWORD PTR _write_off$1$[ebp]
	lea	eax, DWORD PTR [edi+1]
	push	DWORD PTR _fmt$[ebp]
	dec	ecx
	push	eax
	mov	eax, DWORD PTR [esi+8]
	add	eax, ecx
	push	eax
	call	?ImFormatStringV@@YAHPADHPBD0@Z		; ImFormatStringV
	add	esp, 16					; 00000010H
$LN1@appendv:
	pop	edi
	pop	esi

; 1678 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?appendv@ImGuiTextBuffer@@QAEXPBDPAD@Z ENDP		; ImGuiTextBuffer::appendv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_this$ = 8						; size = 4
_fmt$ = 12						; size = 4
?append@ImGuiTextBuffer@@QAAXPBDZZ PROC			; ImGuiTextBuffer::append

; 1681 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1682 :     va_list args;
; 1683 :     va_start(args, fmt);
; 1684 :     appendv(fmt, args);

	mov	ecx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR _fmt$[ebp+4]
	push	eax
	push	DWORD PTR _fmt$[ebp]
	call	?appendv@ImGuiTextBuffer@@QAEXPBDPAD@Z	; ImGuiTextBuffer::appendv

; 1685 :     va_end(args);
; 1686 : }

	pop	ebp
	ret	0
?append@ImGuiTextBuffer@@QAAXPBDZZ ENDP			; ImGuiTextBuffer::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?clear@ImGuiTextBuffer@@QAEXXZ
_TEXT	SEGMENT
$T1 = -1						; size = 1
?clear@ImGuiTextBuffer@@QAEXXZ PROC			; ImGuiTextBuffer::clear, COMDAT
; _this$ = ecx

; 1006 :     void                clear() { Buf.clear(); Buf.push_back(0); }

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN4@clear
	push	eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+8], 0
$LN4@clear:

; 1006 :     void                clear() { Buf.clear(); Buf.push_back(0); }

	lea	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR $T1[ebp], 0
	push	eax
	mov	ecx, esi
	call	?push_back@?$ImVector@D@@QAEXABD@Z	; ImVector<char>::push_back
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?clear@ImGuiTextBuffer@@QAEXXZ ENDP			; ImGuiTextBuffer::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?size@ImGuiTextBuffer@@QBEHXZ
_TEXT	SEGMENT
?size@ImGuiTextBuffer@@QBEHXZ PROC			; ImGuiTextBuffer::size, COMDAT
; _this$ = ecx

; 1004 :     int                 size() const { return Buf.Size - 1; }

	mov	eax, DWORD PTR [ecx]
	dec	eax
	ret	0
?size@ImGuiTextBuffer@@QBEHXZ ENDP			; ImGuiTextBuffer::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?begin@ImGuiTextBuffer@@QBEPBDXZ
_TEXT	SEGMENT
?begin@ImGuiTextBuffer@@QBEPBDXZ PROC			; ImGuiTextBuffer::begin, COMDAT
; _this$ = ecx

; 1002 :     const char*         begin() const { return &Buf.front(); }

	mov	eax, DWORD PTR [ecx+8]
	ret	0
?begin@ImGuiTextBuffer@@QBEPBDXZ ENDP			; ImGuiTextBuffer::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0ImGuiTextBuffer@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -13						; size = 1
__$EHRec$ = -12						; size = 12
??0ImGuiTextBuffer@@QAE@XZ PROC				; ImGuiTextBuffer::ImGuiTextBuffer, COMDAT
; _this$ = ecx

; 1000 :     ImGuiTextBuffer()   { Buf.push_back(0); }

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0ImGuiTextBuffer@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+8], 0

; 1000 :     ImGuiTextBuffer()   { Buf.push_back(0); }

	lea	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	mov	BYTE PTR $T2[ebp], 0
	call	?push_back@?$ImVector@D@@QAEXABD@Z	; ImVector<char>::push_back
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ImGuiTextBuffer@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$ImVector@D@@QAE@XZ			; ImVector<char>::~ImVector<char>
__ehhandler$??0ImGuiTextBuffer@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0ImGuiTextBuffer@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0ImGuiTextBuffer@@QAE@XZ ENDP				; ImGuiTextBuffer::ImGuiTextBuffer
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@D@@QAEXABD@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?push_back@?$ImVector@D@@QAEXABD@Z PROC			; ImVector<char>::push_back, COMDAT
; _this$ = ecx

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jne	SHORT $LN8@push_back
	inc	edi

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, edi
	cmovg	edi, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	edi, ecx
	jle	SHORT $LN8@push_back
	push	ebx

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	push	edi
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN10@push_back

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	push	DWORD PTR [esi]
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@push_back:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN8@push_back:

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [esi+8]
	pop	edi
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [edx+ecx], al
	inc	DWORD PTR [esi]
	pop	esi
	pop	ebp
	ret	4
?push_back@?$ImVector@D@@QAEXABD@Z ENDP			; ImVector<char>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@D@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@D@@QAEXH@Z PROC			; ImVector<char>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	push	ebx
	push	edi
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	push	DWORD PTR [esi]
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@D@@QAEXH@Z ENDP			; ImVector<char>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@D@@QAEXH@Z
_TEXT	SEGMENT
_new_data$1$ = 8					; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@D@@QAEXH@Z PROC			; ImVector<char>::resize, COMDAT
; _this$ = ecx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR _new_size$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jle	SHORT $LN12@resize

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@resize
$LN6@resize:
	mov	eax, 8
$LN7@resize:
	push	ebx
	cmp	eax, edi
	mov	ebx, edi
	cmovg	ebx, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	ebx, ecx
	jle	SHORT $LN13@resize

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	push	ebx
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	ecx, DWORD PTR [esi+8]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	ecx, ecx
	je	SHORT $LN10@resize

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	push	DWORD PTR [esi]
	push	ecx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@resize:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], ebx
$LN13@resize:
	pop	ebx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
$LN12@resize:
	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?resize@?$ImVector@D@@QAEXH@Z ENDP			; ImVector<char>::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@D@@QAEHH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?_grow_capacity@?$ImVector@D@@QAEHH@Z PROC		; ImVector<char>::_grow_capacity, COMDAT
; _this$ = ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@grow_capac
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _new_size$[ebp]
	sar	ecx, 1
	add	ecx, esi
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
$LN3@grow_capac:
	mov	eax, DWORD PTR _new_size$[ebp]
	mov	ecx, 8
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
?_grow_capacity@?$ImVector@D@@QAEHH@Z ENDP		; ImVector<char>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?front@?$ImVector@D@@QBEABDXZ
_TEXT	SEGMENT
?front@?$ImVector@D@@QBEABDXZ PROC			; ImVector<char>::front, COMDAT
; _this$ = ecx

; 921  :     inline const value_type&    front() const                   { IM_ASSERT(Size > 0); return Data[0]; }

	mov	eax, DWORD PTR [ecx+8]
	ret	0
?front@?$ImVector@D@@QBEABDXZ ENDP			; ImVector<char>::front
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?begin@?$ImVector@D@@QAEPADXZ
_TEXT	SEGMENT
?begin@?$ImVector@D@@QAEPADXZ PROC			; ImVector<char>::begin, COMDAT
; _this$ = ecx

; 916  :     inline iterator             begin()                         { return Data; }

	mov	eax, DWORD PTR [ecx+8]
	ret	0
?begin@?$ImVector@D@@QAEPADXZ ENDP			; ImVector<char>::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@D@@QAEXXZ
_TEXT	SEGMENT
?clear@?$ImVector@D@@QAEXXZ PROC			; ImVector<char>::clear, COMDAT
; _this$ = ecx

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	npad	2
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN2@clear
	push	eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+8], 0
$LN2@clear:
	pop	esi
	ret	0
?clear@?$ImVector@D@@QAEXXZ ENDP			; ImVector<char>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@D@@QAEAADH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@D@@QAEAADH@Z PROC				; ImVector<char>::operator[], COMDAT
; _this$ = ecx

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR [ecx+8]
	add	eax, DWORD PTR _i$[ebp]
	pop	ebp
	ret	4
??A?$ImVector@D@@QAEAADH@Z ENDP				; ImVector<char>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@D@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@D@@QAE@XZ PROC				; ImVector<char>::~ImVector<char>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@D@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@D@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@D@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@D@@QAE@XZ ENDP				; ImVector<char>::~ImVector<char>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@D@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@D@@QAE@XZ PROC				; ImVector<char>::ImVector<char>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@D@@QAE@XZ ENDP				; ImVector<char>::ImVector<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_input_range$ = -8					; size = 8
?Build@ImGuiTextFilter@@QAEXXZ PROC			; ImGuiTextFilter::Build
; _this$ = ecx

; 1598 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 1599 :     Filters.resize(0);

	push	0
	lea	esi, DWORD PTR [edi+256]
	mov	ecx, esi
	call	?resize@?$ImVector@UTextRange@ImGuiTextFilter@@@@QAEXH@Z ; ImVector<ImGuiTextFilter::TextRange>::resize

; 1600 :     TextRange input_range(InputBuf, InputBuf+strlen(InputBuf));

	mov	edx, edi
	lea	ecx, DWORD PTR [edx+1]
$LL50@Build:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL50@Build
	sub	edx, ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 972  :         TextRange(const char* _b, const char* _e) { b = _b; e = _e; }

	mov	DWORD PTR _input_range$[ebp], edi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1601 :     input_range.split(',', Filters);

	push	esi
	push	44					; 0000002cH
	lea	ecx, DWORD PTR _input_range$[ebp]
	lea	eax, DWORD PTR [edx+edi]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 972  :         TextRange(const char* _b, const char* _e) { b = _b; e = _e; }

	mov	DWORD PTR _input_range$[ebp+4], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1601 :     input_range.split(',', Filters);

	call	?split@TextRange@ImGuiTextFilter@@QAEXDAAV?$ImVector@UTextRange@ImGuiTextFilter@@@@@Z ; ImGuiTextFilter::TextRange::split

; 1604 :     for (int i = 0; i != Filters.Size; i++)

	xor	ebx, ebx
	mov	DWORD PTR [edi+268], 0
	cmp	DWORD PTR [esi], ebx
	je	SHORT $LN3@Build
	npad	2
$LL4@Build:
	mov	eax, DWORD PTR [edi+264]
	lea	ecx, DWORD PTR [ebx*8]
	add	eax, ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 978  :         void trim_blanks() { while (b < e && is_blank(*b)) b++; while (e > b && is_blank(*(e-1))) e--; }

	mov	esi, DWORD PTR [eax+4]
	cmp	DWORD PTR [eax], esi
	jae	SHORT $LN51@Build
$LL13@Build:
	mov	edx, DWORD PTR [eax]
	mov	cl, BYTE PTR [edx]

; 977  :         static bool is_blank(char c) { return c == ' ' || c == '\t'; }

	cmp	cl, 32					; 00000020H
	je	SHORT $LN20@Build
	cmp	cl, 9
	jne	SHORT $LN51@Build
$LN20@Build:

; 978  :         void trim_blanks() { while (b < e && is_blank(*b)) b++; while (e > b && is_blank(*(e-1))) e--; }

	lea	ecx, DWORD PTR [edx+1]
	mov	DWORD PTR [eax], ecx
	cmp	ecx, esi
	jb	SHORT $LL13@Build
$LN51@Build:
	mov	edx, DWORD PTR [eax]
	cmp	esi, edx
	jbe	SHORT $LN52@Build
$LL15@Build:
	mov	ecx, DWORD PTR [eax+4]
	mov	cl, BYTE PTR [ecx-1]

; 977  :         static bool is_blank(char c) { return c == ' ' || c == '\t'; }

	cmp	cl, 32					; 00000020H
	je	SHORT $LN24@Build
	cmp	cl, 9
	jne	SHORT $LN52@Build
$LN24@Build:

; 978  :         void trim_blanks() { while (b < e && is_blank(*b)) b++; while (e > b && is_blank(*(e-1))) e--; }

	dec	DWORD PTR [eax+4]
	cmp	DWORD PTR [eax+4], edx
	ja	SHORT $LL15@Build
$LN52@Build:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1604 :     for (int i = 0; i != Filters.Size; i++)

	mov	eax, DWORD PTR [edi+264]
	lea	ecx, DWORD PTR [eax+ebx*8]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 975  :         bool empty() const { return b == e; }

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [ecx+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1607 :         if (Filters[i].empty())

	je	SHORT $LN2@Build

; 1608 :             continue;
; 1609 :         if (Filters[i].front() != '-')

	cmp	BYTE PTR [eax], 45			; 0000002dH
	je	SHORT $LN2@Build

; 1610 :             CountGrep += 1;

	inc	DWORD PTR [edi+268]
$LN2@Build:

; 1604 :     for (int i = 0; i != Filters.Size; i++)

	inc	ebx
	cmp	ebx, DWORD PTR [edi+256]
	jne	SHORT $LL4@Build
$LN3@Build:
	pop	edi
	pop	esi
	pop	ebx

; 1611 :     }
; 1612 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Build@ImGuiTextFilter@@QAEXXZ ENDP			; ImGuiTextFilter::Build
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_text$ = 8						; size = 4
_text_end$ = 12						; size = 4
?PassFilter@ImGuiTextFilter@@QBE_NPBD0@Z PROC		; ImGuiTextFilter::PassFilter
; _this$ = ecx

; 1615 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	edi
	mov	edi, ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	cmp	DWORD PTR [edi+256], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1616 :     if (Filters.empty())

	jne	SHORT $LN5@PassFilter

; 1617 :         return true;

	mov	al, 1
	pop	edi

; 1643 :         return true;
; 1644 : 
; 1645 :     return false;
; 1646 : }

	pop	ebp
	ret	8
$LN5@PassFilter:
	mov	eax, DWORD PTR _text$[ebp]
	test	eax, eax

; 1618 : 
; 1619 :     if (text == NULL)
; 1620 :         text = "";
; 1621 : 
; 1622 :     for (int i = 0; i != Filters.Size; i++)

	mov	edx, DWORD PTR _text_end$[ebp]
	push	ebx
	mov	ebx, OFFSET $SG16770
	push	esi
	cmovne	ebx, eax
	xor	esi, esi
	npad	4
$LL4@PassFilter:
	mov	eax, DWORD PTR [edi+264]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 975  :         bool empty() const { return b == e; }

	mov	ecx, DWORD PTR [eax+esi*8]
	mov	eax, DWORD PTR [eax+esi*8+4]
	cmp	ecx, eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1625 :         if (f.empty())

	je	SHORT $LN2@PassFilter

; 1626 :             continue;
; 1627 :         if (f.front() == '-')

	cmp	BYTE PTR [ecx], 45			; 0000002dH

; 1628 :         {
; 1629 :             // Subtract
; 1630 :             if (ImStristr(text, text_end, f.begin()+1, f.end()) != NULL)

	push	eax
	jne	SHORT $LN8@PassFilter
	lea	eax, DWORD PTR [ecx+1]
	push	eax
	push	edx
	push	ebx
	call	?ImStristr@@YAPBDPBD000@Z		; ImStristr
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN39@PassFilter

; 1631 :                 return false;

	pop	esi
	pop	ebx
	xor	al, al
	pop	edi

; 1643 :         return true;
; 1644 : 
; 1645 :     return false;
; 1646 : }

	pop	ebp
	ret	8
$LN8@PassFilter:

; 1632 :         }
; 1633 :         else
; 1634 :         {
; 1635 :             // Grep
; 1636 :             if (ImStristr(text, text_end, f.begin(), f.end()) != NULL)

	push	ecx
	push	edx
	push	ebx
	call	?ImStristr@@YAPBDPBD000@Z		; ImStristr
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN32@PassFilter
$LN39@PassFilter:
	mov	edx, DWORD PTR _text_end$[ebp]
$LN2@PassFilter:

; 1618 : 
; 1619 :     if (text == NULL)
; 1620 :         text = "";
; 1621 : 
; 1622 :     for (int i = 0; i != Filters.Size; i++)

	inc	esi
	cmp	esi, DWORD PTR [edi+256]
	jne	SHORT $LL4@PassFilter

; 1638 :         }
; 1639 :     }
; 1640 : 
; 1641 :     // Implicit * grep
; 1642 :     if (CountGrep == 0)

	cmp	DWORD PTR [edi+268], 0
	pop	esi
	pop	ebx
	sete	al
	pop	edi

; 1643 :         return true;
; 1644 : 
; 1645 :     return false;
; 1646 : }

	pop	ebp
	ret	8
$LN32@PassFilter:
	pop	esi
	pop	ebx

; 1637 :                 return true;

	mov	al, 1
	pop	edi

; 1643 :         return true;
; 1644 : 
; 1645 :     return false;
; 1646 : }

	pop	ebp
	ret	8
?PassFilter@ImGuiTextFilter@@QBE_NPBD0@Z ENDP		; ImGuiTextFilter::PassFilter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_width$ = 12						; size = 4
?Draw@ImGuiTextFilter@@QAE_NPBDM@Z PROC			; ImGuiTextFilter::Draw
; _this$ = ecx

; 1568 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1569 :     if (width != 0.0f)

	movss	xmm0, DWORD PTR _width$[ebp]
	xorps	xmm1, xmm1
	ucomiss	xmm0, xmm1
	push	ebx
	push	esi
	mov	esi, ecx
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@Draw

; 1570 :         ImGui::PushItemWidth(width);

	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth
	add	esp, 4
$LN2@Draw:

; 1571 :     bool value_changed = ImGui::InputText(label, InputBuf, IM_ARRAYSIZE(InputBuf));

	push	0
	push	0
	push	0
	push	256					; 00000100H
	push	esi
	push	DWORD PTR _label$[ebp]
	call	?InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ; ImGui::InputText

; 1572 :     if (width != 0.0f)

	movss	xmm0, DWORD PTR _width$[ebp]
	add	esp, 24					; 00000018H
	xorps	xmm1, xmm1
	mov	bl, al
	ucomiss	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@Draw

; 1573 :         ImGui::PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth
$LN3@Draw:

; 1574 :     if (value_changed)

	test	bl, bl
	je	SHORT $LN6@Draw

; 1575 :         Build();

	mov	ecx, esi
	call	?Build@ImGuiTextFilter@@QAEXXZ		; ImGuiTextFilter::Build
$LN6@Draw:

; 1576 :     return value_changed;

	pop	esi
	mov	al, bl
	pop	ebx

; 1577 : }

	pop	ebp
	ret	8
?Draw@ImGuiTextFilter@@QAE_NPBDM@Z ENDP			; ImGuiTextFilter::Draw
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_default_filter$ = 8					; size = 4
??0ImGuiTextFilter@@QAE@PBD@Z PROC			; ImGuiTextFilter::ImGuiTextFilter
; _this$ = ecx

; 1554 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0ImGuiTextFilter@@QAE@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [esi+260], 0
	mov	DWORD PTR [esi+256], 0
	mov	DWORD PTR [esi+264], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1555 :     if (default_filter)

	mov	eax, DWORD PTR _default_filter$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN2@ImGuiTextF

; 1556 :     {
; 1557 :         ImStrncpy(InputBuf, default_filter, IM_ARRAYSIZE(InputBuf));

	push	256					; 00000100H
	push	eax
	push	esi
	call	?ImStrncpy@@YAXPADPBDH@Z		; ImStrncpy
	add	esp, 12					; 0000000cH

; 1558 :         Build();

	mov	ecx, esi
	call	?Build@ImGuiTextFilter@@QAEXXZ		; ImGuiTextFilter::Build

; 1559 :     }
; 1560 :     else
; 1561 :     {
; 1562 :         InputBuf[0] = 0;
; 1563 :         CountGrep = 0;
; 1564 :     }
; 1565 : }

	mov	eax, esi
	pop	esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@ImGuiTextF:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	mov	BYTE PTR [esi], 0
	mov	DWORD PTR [esi+268], 0
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0ImGuiTextFilter@@QAE@PBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 256				; 00000100H
	jmp	??1?$ImVector@UTextRange@ImGuiTextFilter@@@@QAE@XZ ; ImVector<ImGuiTextFilter::TextRange>::~ImVector<ImGuiTextFilter::TextRange>
__ehhandler$??0ImGuiTextFilter@@QAE@PBD@Z:
	mov	eax, OFFSET __ehfuncinfo$??0ImGuiTextFilter@@QAE@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0ImGuiTextFilter@@QAE@PBD@Z ENDP			; ImGuiTextFilter::ImGuiTextFilter
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?push_back@?$ImVector@UTextRange@ImGuiTextFilter@@@@QAEXABUTextRange@ImGuiTextFilter@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?push_back@?$ImVector@UTextRange@ImGuiTextFilter@@@@QAEXABUTextRange@ImGuiTextFilter@@@Z PROC ; ImVector<ImGuiTextFilter::TextRange>::push_back, COMDAT
; _this$ = ecx

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi]
	mov	ecx, DWORD PTR [edi+4]
	cmp	esi, ecx
	jne	SHORT $LN8@push_back
	inc	esi

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@push_back
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@push_back
$LN6@push_back:
	mov	eax, 8
$LN7@push_back:
	cmp	eax, esi
	cmovg	esi, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	esi, ecx
	jle	SHORT $LN8@push_back

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [esi*8]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN10@push_back

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [edi]
	shl	ecx, 3
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@push_back:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [edi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [edi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [edi+4], esi
	pop	ebx
$LN8@push_back:

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	esi, DWORD PTR [edi+8]
	mov	edx, DWORD PTR [edi]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi+edx*8], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+edx*8+4], eax
	inc	DWORD PTR [edi]
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?push_back@?$ImVector@UTextRange@ImGuiTextFilter@@@@QAEXABUTextRange@ImGuiTextFilter@@@Z ENDP ; ImVector<ImGuiTextFilter::TextRange>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@UTextRange@ImGuiTextFilter@@@@QAEXH@Z
_TEXT	SEGMENT
_new_capacity$ = 8					; size = 4
?reserve@?$ImVector@UTextRange@ImGuiTextFilter@@@@QAEXH@Z PROC ; ImVector<ImGuiTextFilter::TextRange>::reserve, COMDAT
; _this$ = ecx

; 930  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 931  :         if (new_capacity <= Capacity) return;

	mov	edi, DWORD PTR _new_capacity$[ebp]
	cmp	edi, DWORD PTR [esi+4]
	jle	SHORT $LN1@reserve

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*8]
	push	ebx
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	ebx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN3@reserve

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 3
	push	ecx
	push	eax
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@reserve:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4

; 936  :         Data = new_data;

	mov	DWORD PTR [esi+8], ebx

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], edi
	pop	ebx
$LN1@reserve:
	pop	edi
	pop	esi

; 938  :     }

	pop	ebp
	ret	4
?reserve@?$ImVector@UTextRange@ImGuiTextFilter@@@@QAEXH@Z ENDP ; ImVector<ImGuiTextFilter::TextRange>::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@UTextRange@ImGuiTextFilter@@@@QAEXH@Z
_TEXT	SEGMENT
_new_data$1$ = 8					; size = 4
_new_size$ = 8						; size = 4
?resize@?$ImVector@UTextRange@ImGuiTextFilter@@@@QAEXH@Z PROC ; ImVector<ImGuiTextFilter::TextRange>::resize, COMDAT
; _this$ = ecx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR _new_size$[ebp]
	mov	ecx, DWORD PTR [esi+4]
	cmp	edi, ecx
	jle	SHORT $LN12@resize

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN6@resize
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN7@resize
$LN6@resize:
	mov	eax, 8
$LN7@resize:
	push	ebx
	cmp	eax, edi
	mov	ebx, edi
	cmovg	ebx, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	ebx, ecx
	jle	SHORT $LN13@resize

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [ebx*8]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [esi+8]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN10@resize

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi]
	shl	ecx, 3
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN10@resize:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+8], eax

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+4], ebx
$LN13@resize:
	pop	ebx

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
$LN12@resize:
	mov	DWORD PTR [esi], edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
?resize@?$ImVector@UTextRange@ImGuiTextFilter@@@@QAEXH@Z ENDP ; ImVector<ImGuiTextFilter::TextRange>::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@UTextRange@ImGuiTextFilter@@@@QAEHH@Z
_TEXT	SEGMENT
_new_size$ = 8						; size = 4
?_grow_capacity@?$ImVector@UTextRange@ImGuiTextFilter@@@@QAEHH@Z PROC ; ImVector<ImGuiTextFilter::TextRange>::_grow_capacity, COMDAT
; _this$ = ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	test	esi, esi
	je	SHORT $LN3@grow_capac
	mov	eax, esi
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _new_size$[ebp]
	sar	ecx, 1
	add	ecx, esi
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
$LN3@grow_capac:
	mov	eax, DWORD PTR _new_size$[ebp]
	mov	ecx, 8
	cmp	ecx, eax
	pop	esi
	cmovg	eax, ecx
	pop	ebp
	ret	4
?_grow_capacity@?$ImVector@UTextRange@ImGuiTextFilter@@@@QAEHH@Z ENDP ; ImVector<ImGuiTextFilter::TextRange>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@UTextRange@ImGuiTextFilter@@@@QBEABUTextRange@ImGuiTextFilter@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@UTextRange@ImGuiTextFilter@@@@QBEABUTextRange@ImGuiTextFilter@@H@Z PROC ; ImVector<ImGuiTextFilter::TextRange>::operator[], COMDAT
; _this$ = ecx

; 913  :     inline const value_type&    operator[](int i) const         { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+eax*8]
	pop	ebp
	ret	4
??A?$ImVector@UTextRange@ImGuiTextFilter@@@@QBEABUTextRange@ImGuiTextFilter@@H@Z ENDP ; ImVector<ImGuiTextFilter::TextRange>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@UTextRange@ImGuiTextFilter@@@@QAEAAUTextRange@ImGuiTextFilter@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@UTextRange@ImGuiTextFilter@@@@QAEAAUTextRange@ImGuiTextFilter@@H@Z PROC ; ImVector<ImGuiTextFilter::TextRange>::operator[], COMDAT
; _this$ = ecx

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+eax*8]
	pop	ebp
	ret	4
??A?$ImVector@UTextRange@ImGuiTextFilter@@@@QAEAAUTextRange@ImGuiTextFilter@@H@Z ENDP ; ImVector<ImGuiTextFilter::TextRange>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?empty@?$ImVector@UTextRange@ImGuiTextFilter@@@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$ImVector@UTextRange@ImGuiTextFilter@@@@QBE_NXZ PROC ; ImVector<ImGuiTextFilter::TextRange>::empty, COMDAT
; _this$ = ecx

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	cmp	DWORD PTR [ecx], 0
	sete	al
	ret	0
?empty@?$ImVector@UTextRange@ImGuiTextFilter@@@@QBE_NXZ ENDP ; ImVector<ImGuiTextFilter::TextRange>::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??1?$ImVector@UTextRange@ImGuiTextFilter@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$ImVector@UTextRange@ImGuiTextFilter@@@@QAE@XZ PROC	; ImVector<ImGuiTextFilter::TextRange>::~ImVector<ImGuiTextFilter::TextRange>, COMDAT
; _this$ = ecx

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$ImVector@UTextRange@ImGuiTextFilter@@@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@ImVector
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN2@ImVector:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$ImVector@UTextRange@ImGuiTextFilter@@@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$ImVector@UTextRange@ImGuiTextFilter@@@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$ImVector@UTextRange@ImGuiTextFilter@@@@QAE@XZ ENDP	; ImVector<ImGuiTextFilter::TextRange>::~ImVector<ImGuiTextFilter::TextRange>
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0?$ImVector@UTextRange@ImGuiTextFilter@@@@QAE@XZ
_TEXT	SEGMENT
??0?$ImVector@UTextRange@ImGuiTextFilter@@@@QAE@XZ PROC	; ImVector<ImGuiTextFilter::TextRange>::ImVector<ImGuiTextFilter::TextRange>, COMDAT
; _this$ = ecx

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$ImVector@UTextRange@ImGuiTextFilter@@@@QAE@XZ ENDP	; ImVector<ImGuiTextFilter::TextRange>::ImVector<ImGuiTextFilter::TextRange>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 8
$T2 = -8						; size = 8
_separator$ = 8						; size = 1
_out$ = 12						; size = 4
?split@TextRange@ImGuiTextFilter@@QAEXDAAV?$ImVector@UTextRange@ImGuiTextFilter@@@@@Z PROC ; ImGuiTextFilter::TextRange::split
; _this$ = ecx

; 1580 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	push	edi
	mov	edi, ecx

; 1581 :     out.resize(0);

	mov	ecx, DWORD PTR _out$[ebp]
	push	0
	call	?resize@?$ImVector@UTextRange@ImGuiTextFilter@@@@QAEXH@Z ; ImVector<ImGuiTextFilter::TextRange>::resize

; 1582 :     const char* wb = b;

	mov	eax, DWORD PTR [edi]

; 1583 :     const char* we = wb;

	mov	esi, eax

; 1584 :     while (we < e)

	cmp	eax, DWORD PTR [edi+4]
	jae	SHORT $LN5@split
	push	ebx
	mov	bl, BYTE PTR _separator$[ebp]
$LL2@split:

; 1585 :     {
; 1586 :         if (*we == separator)

	cmp	BYTE PTR [esi], bl
	jne	SHORT $LN4@split

; 1588 :             out.push_back(TextRange(wb, we));

	mov	ecx, DWORD PTR _out$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 972  :         TextRange(const char* _b, const char* _e) { b = _b; e = _e; }

	mov	DWORD PTR $T2[ebp], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1588 :             out.push_back(TextRange(wb, we));

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 972  :         TextRange(const char* _b, const char* _e) { b = _b; e = _e; }

	mov	DWORD PTR $T2[ebp+4], esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1588 :             out.push_back(TextRange(wb, we));

	call	?push_back@?$ImVector@UTextRange@ImGuiTextFilter@@@@QAEXABUTextRange@ImGuiTextFilter@@@Z ; ImVector<ImGuiTextFilter::TextRange>::push_back

; 1589 :             wb = we + 1;

	lea	eax, DWORD PTR [esi+1]
$LN4@split:

; 1590 :         }
; 1591 :         we++;

	inc	esi
	cmp	esi, DWORD PTR [edi+4]
	jb	SHORT $LL2@split

; 1592 :     }
; 1593 :     if (wb != we)

	pop	ebx
	cmp	eax, esi
	je	SHORT $LN5@split

; 1594 :         out.push_back(TextRange(wb, we));

	mov	ecx, DWORD PTR _out$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 972  :         TextRange(const char* _b, const char* _e) { b = _b; e = _e; }

	mov	DWORD PTR $T1[ebp], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1594 :         out.push_back(TextRange(wb, we));

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 972  :         TextRange(const char* _b, const char* _e) { b = _b; e = _e; }

	mov	DWORD PTR $T1[ebp+4], esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1594 :         out.push_back(TextRange(wb, we));

	call	?push_back@?$ImVector@UTextRange@ImGuiTextFilter@@@@QAEXABUTextRange@ImGuiTextFilter@@@Z ; ImVector<ImGuiTextFilter::TextRange>::push_back
$LN5@split:
	pop	edi
	pop	esi

; 1595 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?split@TextRange@ImGuiTextFilter@@QAEXDAAV?$ImVector@UTextRange@ImGuiTextFilter@@@@@Z ENDP ; ImGuiTextFilter::TextRange::split
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?trim_blanks@TextRange@ImGuiTextFilter@@QAEXXZ
_TEXT	SEGMENT
?trim_blanks@TextRange@ImGuiTextFilter@@QAEXXZ PROC	; ImGuiTextFilter::TextRange::trim_blanks, COMDAT
; _this$ = ecx

; 978  :         void trim_blanks() { while (b < e && is_blank(*b)) b++; while (e > b && is_blank(*(e-1))) e--; }

	npad	2
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	cmp	DWORD PTR [ecx], esi
	jae	SHORT $LN27@trim_blank
	npad	6
$LL2@trim_blank:
	mov	edx, DWORD PTR [ecx]
	mov	al, BYTE PTR [edx]

; 977  :         static bool is_blank(char c) { return c == ' ' || c == '\t'; }

	cmp	al, 32					; 00000020H
	je	SHORT $LN9@trim_blank
	cmp	al, 9
	jne	SHORT $LN27@trim_blank
$LN9@trim_blank:

; 978  :         void trim_blanks() { while (b < e && is_blank(*b)) b++; while (e > b && is_blank(*(e-1))) e--; }

	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
	cmp	eax, esi
	jb	SHORT $LL2@trim_blank
$LN27@trim_blank:
	mov	edx, DWORD PTR [ecx]
	cmp	esi, edx
	pop	esi
	jbe	SHORT $LN28@trim_blank
	npad	4
$LL4@trim_blank:
	mov	eax, DWORD PTR [ecx+4]
	mov	al, BYTE PTR [eax-1]

; 977  :         static bool is_blank(char c) { return c == ' ' || c == '\t'; }

	cmp	al, 32					; 00000020H
	je	SHORT $LN13@trim_blank
	cmp	al, 9
	jne	SHORT $LN28@trim_blank
$LN13@trim_blank:

; 978  :         void trim_blanks() { while (b < e && is_blank(*b)) b++; while (e > b && is_blank(*(e-1))) e--; }

	dec	DWORD PTR [ecx+4]
	cmp	DWORD PTR [ecx+4], edx
	ja	SHORT $LL4@trim_blank
$LN28@trim_blank:
	ret	0
?trim_blanks@TextRange@ImGuiTextFilter@@QAEXXZ ENDP	; ImGuiTextFilter::TextRange::trim_blanks
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?is_blank@TextRange@ImGuiTextFilter@@SA_ND@Z
_TEXT	SEGMENT
_c$ = 8							; size = 1
?is_blank@TextRange@ImGuiTextFilter@@SA_ND@Z PROC	; ImGuiTextFilter::TextRange::is_blank, COMDAT

; 977  :         static bool is_blank(char c) { return c == ' ' || c == '\t'; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	al, BYTE PTR _c$[ebp]
	cmp	al, 32					; 00000020H
	je	SHORT $LN3@is_blank
	cmp	al, 9
	je	SHORT $LN3@is_blank
	xor	al, al
	pop	ebp
	ret	0
$LN3@is_blank:
	mov	al, 1
	pop	ebp
	ret	0
?is_blank@TextRange@ImGuiTextFilter@@SA_ND@Z ENDP	; ImGuiTextFilter::TextRange::is_blank
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?front@TextRange@ImGuiTextFilter@@QBEDXZ
_TEXT	SEGMENT
?front@TextRange@ImGuiTextFilter@@QBEDXZ PROC		; ImGuiTextFilter::TextRange::front, COMDAT
; _this$ = ecx

; 976  :         char front() const { return *b; }

	mov	eax, DWORD PTR [ecx]
	mov	al, BYTE PTR [eax]
	ret	0
?front@TextRange@ImGuiTextFilter@@QBEDXZ ENDP		; ImGuiTextFilter::TextRange::front
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?empty@TextRange@ImGuiTextFilter@@QBE_NXZ
_TEXT	SEGMENT
?empty@TextRange@ImGuiTextFilter@@QBE_NXZ PROC		; ImGuiTextFilter::TextRange::empty, COMDAT
; _this$ = ecx

; 975  :         bool empty() const { return b == e; }

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [ecx+4]
	sete	al
	ret	0
?empty@TextRange@ImGuiTextFilter@@QBE_NXZ ENDP		; ImGuiTextFilter::TextRange::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?end@TextRange@ImGuiTextFilter@@QBEPBDXZ
_TEXT	SEGMENT
?end@TextRange@ImGuiTextFilter@@QBEPBDXZ PROC		; ImGuiTextFilter::TextRange::end, COMDAT
; _this$ = ecx

; 974  :         const char* end() const { return e; }

	mov	eax, DWORD PTR [ecx+4]
	ret	0
?end@TextRange@ImGuiTextFilter@@QBEPBDXZ ENDP		; ImGuiTextFilter::TextRange::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ?begin@TextRange@ImGuiTextFilter@@QBEPBDXZ
_TEXT	SEGMENT
?begin@TextRange@ImGuiTextFilter@@QBEPBDXZ PROC		; ImGuiTextFilter::TextRange::begin, COMDAT
; _this$ = ecx

; 973  :         const char* begin() const { return b; }

	mov	eax, DWORD PTR [ecx]
	ret	0
?begin@TextRange@ImGuiTextFilter@@QBEPBDXZ ENDP		; ImGuiTextFilter::TextRange::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0TextRange@ImGuiTextFilter@@QAE@PBD0@Z
_TEXT	SEGMENT
__b$ = 8						; size = 4
__e$ = 12						; size = 4
??0TextRange@ImGuiTextFilter@@QAE@PBD0@Z PROC		; ImGuiTextFilter::TextRange::TextRange, COMDAT
; _this$ = ecx

; 972  :         TextRange(const char* _b, const char* _e) { b = _b; e = _e; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __b$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __e$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, ecx
	pop	ebp
	ret	8
??0TextRange@ImGuiTextFilter@@QAE@PBD0@Z ENDP		; ImGuiTextFilter::TextRange::TextRange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 8
$T2 = -8						; size = 8
$T3 = -8						; size = 8
$T4 = -8						; size = 8
$T5 = -8						; size = 8
??0ImGuiIO@@QAE@XZ PROC					; ImGuiIO::ImGuiIO
; _this$ = ecx

; 863  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	esi, ecx

; 865  :     memset(this, 0, sizeof(*this));

	push	5316					; 000014c4H
	push	0
	push	esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 97   :     ImVec2() { x = y = 0.0f; }

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+148], 0
	mov	DWORD PTR [esi+144], 0
	mov	DWORD PTR [esi+156], 0
	mov	DWORD PTR [esi+152], 0
	mov	DWORD PTR [esi+164], 0
	mov	DWORD PTR [esi+160], 0
	mov	DWORD PTR [esi+208], 0
	mov	DWORD PTR [esi+204], 0
	mov	DWORD PTR [esi+872], 0
	mov	DWORD PTR [esi+868], 0
	mov	DWORD PTR [esi+880], 0
	mov	DWORD PTR [esi+876], 0
	mov	DWORD PTR [esi+896], 0
	mov	DWORD PTR [esi+892], 0
	mov	DWORD PTR [esi+904], 0
	mov	DWORD PTR [esi+900], 0
	mov	DWORD PTR [esi+912], 0
	mov	DWORD PTR [esi+908], 0
	mov	DWORD PTR [esi+920], 0
	mov	DWORD PTR [esi+916], 0
	mov	DWORD PTR [esi+928], 0
	mov	DWORD PTR [esi+924], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 865  :     memset(this, 0, sizeof(*this));

	call	_memset

; 876  :         KeyMap[i] = -1;

	movaps	xmm0, XMMWORD PTR __xmm@ffffffffffffffffffffffffffffffff
	add	esp, 12					; 0000000cH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T5[ebp], -1082130432		; bf800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 868  :     DisplaySize = ImVec2(-1.0f, -1.0f);

	mov	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR [esi], eax

; 869  :     DeltaTime = 1.0f/60.0f;

	mov	DWORD PTR [esi+8], 1015580809		; 3c888889H

; 870  :     IniSavingRate = 5.0f;

	mov	DWORD PTR [esi+12], 1084227584		; 40a00000H

; 871  :     IniFilename = "imgui.ini";

	mov	DWORD PTR [esi+16], OFFSET $SG16217

; 872  :     LogFilename = "imgui_log.txt";

	mov	DWORD PTR [esi+20], OFFSET $SG16218

; 873  :     MouseDoubleClickTime = 0.30f;

	mov	DWORD PTR [esi+24], 1050253722		; 3e99999aH

; 874  :     MouseDoubleClickMaxDist = 6.0f;

	mov	DWORD PTR [esi+28], 1086324736		; 40c00000H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T5[ebp+4], -1082130432	; bf800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 868  :     DisplaySize = ImVec2(-1.0f, -1.0f);

	mov	eax, DWORD PTR $T5[ebp+4]
	mov	DWORD PTR [esi+4], eax

; 876  :         KeyMap[i] = -1;

	movups	XMMWORD PTR [esi+36], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T4[ebp], 1065353216		; 3f800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 886  :     DisplayFramebufferScale = ImVec2(1.0f, 1.0f);

	mov	eax, DWORD PTR $T4[ebp]
	movups	XMMWORD PTR [esi+52], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T4[ebp+4], 1065353216	; 3f800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 876  :         KeyMap[i] = -1;

	movups	XMMWORD PTR [esi+68], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T3[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 887  :     DisplayVisibleMin = DisplayVisibleMax = ImVec2(0.0f, 0.0f);

	mov	ecx, DWORD PTR $T3[ebp]
	movups	XMMWORD PTR [esi+84], xmm0
	movq	QWORD PTR [esi+100], xmm0
	mov	DWORD PTR [esi+108], -1
	mov	DWORD PTR [esi+144], eax
	mov	eax, DWORD PTR $T4[ebp+4]
	mov	DWORD PTR [esi+148], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T3[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 887  :     DisplayVisibleMin = DisplayVisibleMax = ImVec2(0.0f, 0.0f);

	mov	eax, DWORD PTR $T3[ebp+4]
	mov	DWORD PTR [esi+164], eax
	mov	DWORD PTR [esi+156], eax

; 888  : 
; 889  :     // User functions
; 890  :     RenderDrawListsFn = NULL;
; 891  :     MemAllocFn = malloc;

	mov	eax, DWORD PTR __imp__malloc
	mov	DWORD PTR [esi+188], eax

; 892  :     MemFreeFn = free;

	mov	eax, DWORD PTR __imp__free
	mov	DWORD PTR [esi+112], 1048576000		; 3e800000H
	mov	DWORD PTR [esi+116], 1028443341		; 3d4ccccdH
	mov	BYTE PTR [esi+120], 0
	mov	DWORD PTR [esi+124], 0
	mov	DWORD PTR [esi+128], OFFSET ?GImDefaultFontAtlas@@3UImFontAtlas@@A
	mov	DWORD PTR [esi+132], 1065353216		; 3f800000H
	mov	DWORD PTR [esi+140], 0
	mov	BYTE PTR [esi+136], 0
	mov	DWORD PTR [esi+160], ecx
	mov	DWORD PTR [esi+152], ecx
	mov	DWORD PTR [esi+172], 0
	mov	DWORD PTR [esi+192], eax

; 893  :     GetClipboardTextFn = GetClipboardTextFn_DefaultImpl;   // Platform dependent default implementations

	mov	DWORD PTR [esi+176], OFFSET ?GetClipboardTextFn_DefaultImpl@@YAPBDPAX@Z ; GetClipboardTextFn_DefaultImpl

; 894  :     SetClipboardTextFn = SetClipboardTextFn_DefaultImpl;

	mov	DWORD PTR [esi+180], OFFSET ?SetClipboardTextFn_DefaultImpl@@YAXPAXPBD@Z ; SetClipboardTextFn_DefaultImpl

; 895  :     ClipboardUserData = NULL;

	mov	DWORD PTR [esi+184], 0

; 896  :     ImeSetInputScreenPosFn = ImeSetInputScreenPosFn_DefaultImpl;

	mov	DWORD PTR [esi+196], OFFSET ?ImeSetInputScreenPosFn_DefaultImpl@@YAXHH@Z ; ImeSetInputScreenPosFn_DefaultImpl

; 897  :     ImeWindowHandle = NULL;

	mov	DWORD PTR [esi+200], 0
	mov	ecx, 512				; 00000200H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T2[ebp], -1082130432		; bf800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 900  :     MousePos = ImVec2(-1,-1);

	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR [esi+204], eax

; 902  :     MouseDragThreshold = 6.0f;

	mov	DWORD PTR [esi+32], 1086324736		; 40c00000H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T2[ebp+4], -1082130432	; bf800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 900  :     MousePos = ImVec2(-1,-1);

	mov	eax, DWORD PTR $T2[ebp+4]
	mov	DWORD PTR [esi+208], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp], -1082130432		; bf800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 901  :     MousePosPrev = ImVec2(-1,-1);

	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR [esi+876], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp+4], -1082130432	; bf800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 901  :     MousePosPrev = ImVec2(-1,-1);

	mov	eax, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR [esi+880], eax
	lea	eax, DWORD PTR [esi+1028]

; 903  :     for (int i = 0; i < IM_ARRAYSIZE(MouseDownDuration); i++) MouseDownDuration[i] = MouseDownDurationPrev[i] = -1.0f;

	mov	DWORD PTR [esi+988], -1082130432	; bf800000H
	mov	DWORD PTR [esi+968], -1082130432	; bf800000H
	mov	DWORD PTR [esi+992], -1082130432	; bf800000H
	mov	DWORD PTR [esi+972], -1082130432	; bf800000H
	mov	DWORD PTR [esi+996], -1082130432	; bf800000H
	mov	DWORD PTR [esi+976], -1082130432	; bf800000H
	mov	DWORD PTR [esi+1000], -1082130432	; bf800000H
	mov	DWORD PTR [esi+980], -1082130432	; bf800000H
	mov	DWORD PTR [esi+1004], -1082130432	; bf800000H
	mov	DWORD PTR [esi+984], -1082130432	; bf800000H
	npad	4
$LL10@ImGuiIO:

; 904  :     for (int i = 0; i < IM_ARRAYSIZE(KeysDownDuration); i++) KeysDownDuration[i]  = KeysDownDurationPrev[i] = -1.0f;

	mov	DWORD PTR [eax+2048], -1082130432	; bf800000H
	lea	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax-4], -1082130432		; bf800000H
	sub	ecx, 1
	jne	SHORT $LL10@ImGuiIO

; 905  :     for (int i = 0; i < IM_ARRAYSIZE(NavInputsDownDuration); i++) NavInputsDownDuration[i] = NavInputsDownDurationPrev[i] = -1.0f;

	lea	eax, DWORD PTR [esi+5124]
	mov	ecx, 16					; 00000010H
$LL13@ImGuiIO:
	mov	DWORD PTR [eax+64], -1082130432		; bf800000H
	lea	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax-4], -1082130432		; bf800000H
	sub	ecx, 1
	jne	SHORT $LL13@ImGuiIO

; 906  : 
; 907  :     // Set OS X style defaults based on __APPLE__ compile time flag
; 908  : #ifdef __APPLE__
; 909  :     OSXBehaviors = true;
; 910  : #endif
; 911  : }

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??0ImGuiIO@@QAE@XZ ENDP					; ImGuiIO::ImGuiIO
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_wchars$ = -36						; size = 34
_utf8_chars$ = 8					; size = 4
?AddInputCharactersUTF8@ImGuiIO@@QAEXPBD@Z PROC		; ImGuiIO::AddInputCharactersUTF8
; _this$ = ecx

; 927  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 928  :     // We can't pass more wchars than ImGuiIO::InputCharacters[] can hold so don't convert more
; 929  :     const int wchars_buf_len = sizeof(ImGuiIO::InputCharacters) / sizeof(ImWchar);
; 930  :     ImWchar wchars[wchars_buf_len];
; 931  :     ImTextStrFromUtf8(wchars, wchars_buf_len, utf8_chars, NULL);

	lea	eax, DWORD PTR _wchars$[ebp]
	push	esi
	push	edi
	push	0
	push	0
	push	DWORD PTR _utf8_chars$[ebp]
	mov	edi, ecx
	push	17					; 00000011H
	push	eax
	call	?ImTextStrFromUtf8@@YAHPAGHPBD1PAPBD@Z	; ImTextStrFromUtf8
	add	esp, 20					; 00000014H

; 932  :     for (int i = 0; i < wchars_buf_len && wchars[i] != 0; i++)

	xor	esi, esi
$LL4@AddInputCh:
	movzx	eax, WORD PTR _wchars$[ebp+esi*2]
	test	ax, ax
	je	SHORT $LN3@AddInputCh

; 933  :         AddInputCharacter(wchars[i]);

	push	eax
	mov	ecx, edi
	call	?AddInputCharacter@ImGuiIO@@QAEXG@Z	; ImGuiIO::AddInputCharacter
	inc	esi
	cmp	esi, 17					; 00000011H
	jl	SHORT $LL4@AddInputCh
$LN3@AddInputCh:
	pop	edi
	pop	esi

; 934  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?AddInputCharactersUTF8@ImGuiIO@@QAEXPBD@Z ENDP		; ImGuiIO::AddInputCharactersUTF8
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_c$ = 8							; size = 2
?AddInputCharacter@ImGuiIO@@QAEXG@Z PROC		; ImGuiIO::AddInputCharacter
; _this$ = ecx

; 917  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 918  :     const int n = ImStrlenW(InputCharacters);

	lea	eax, DWORD PTR [esi+742]
	push	eax
	call	?ImStrlenW@@YAHPBG@Z			; ImStrlenW
	add	esp, 4

; 919  :     if (n + 1 < IM_ARRAYSIZE(InputCharacters))

	lea	edx, DWORD PTR [eax+1]
	cmp	edx, 17					; 00000011H
	jge	SHORT $LN2@AddInputCh

; 920  :     {
; 921  :         InputCharacters[n] = c;

	mov	cx, WORD PTR _c$[ebp]
	mov	WORD PTR [esi+eax*2+742], cx

; 922  :         InputCharacters[n+1] = '\0';

	xor	ecx, ecx
	mov	WORD PTR [esi+eax*2+744], cx
$LN2@AddInputCh:
	pop	esi

; 923  :     }
; 924  : }

	pop	ebp
	ret	4
?AddInputCharacter@ImGuiIO@@QAEXG@Z ENDP		; ImGuiIO::AddInputCharacter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 8
$T2 = -8						; size = 8
$T3 = -8						; size = 8
$T4 = -8						; size = 8
$T5 = -8						; size = 8
$T6 = -8						; size = 8
$T7 = -8						; size = 8
$T8 = -8						; size = 8
$T9 = -8						; size = 8
$T10 = -8						; size = 8
??0ImGuiStyle@@QAE@XZ PROC				; ImGuiStyle::ImGuiStyle
; _this$ = ecx

; 790  : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 97   :     ImVec2() { x = y = 0.0f; }

	mov	DWORD PTR [ecx+8], 0

; 109  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }
; 110  : #ifdef IM_VEC4_CLASS_EXTRA          // Define constructor and implicit cast operators in imconfig.h to convert back<>forth from your math types and ImVec4.
; 111  :     IM_VEC4_CLASS_EXTRA
; 112  : #endif
; 113  : };
; 114  : 
; 115  : // ImGui end-user API
; 116  : // In a namespace so that user can add extra functions in a separate file (e.g. Value() helpers for your vector or common types)
; 117  : namespace ImGui
; 118  : {
; 119  :     // Main
; 120  :     IMGUI_API ImGuiIO&      GetIO();
; 121  :     IMGUI_API ImGuiStyle&   GetStyle();
; 122  :     IMGUI_API ImDrawData*   GetDrawData();                              // same value as passed to your io.RenderDrawListsFn() function. valid after Render() and until the next call to NewFrame()
; 123  :     IMGUI_API void          NewFrame();                                 // start a new ImGui frame, you can submit any command from this point until NewFrame()/Render().
; 124  :     IMGUI_API void          Render();                                   // ends the ImGui frame, finalize rendering data, then call your io.RenderDrawListsFn() function if set.
; 125  :     IMGUI_API void          Shutdown();
; 126  :     IMGUI_API void          ShowUserGuide();                            // help block
; 127  :     IMGUI_API void          ShowStyleEditor(ImGuiStyle* ref = NULL);    // style editor block. you can pass in a reference ImGuiStyle structure to compare to, revert to and save to (else it uses the default style)
; 128  :     IMGUI_API void          ShowTestWindow(bool* p_open = NULL);        // test window demonstrating ImGui features
; 129  :     IMGUI_API void          ShowMetricsWindow(bool* p_open = NULL);     // metrics window for debugging ImGui (browse draw commands, individual vertices, window list, etc.)
; 130  : 
; 131  :     // Window
; 132  :     IMGUI_API bool          Begin(const char* name, bool* p_open = NULL, ImGuiWindowFlags flags = 0);                                                   // push window to the stack and start appending to it. see .cpp for details. return false when window is collapsed, so you can early out in your code. 'bool* p_open' creates a widget on the upper-right to close the window (which sets your bool to false).
; 133  :     IMGUI_API bool          Begin(const char* name, bool* p_open, const ImVec2& size_on_first_use, float bg_alpha = -1.0f, ImGuiWindowFlags flags = 0); // OBSOLETE. this is the older/longer API. the extra parameters aren't very relevant. call SetNextWindowSize() instead if you want to set a window size. For regular windows, 'size_on_first_use' only applies to the first time EVER the window is created and probably not what you want! might obsolete this API eventually.
; 134  :     IMGUI_API void          End();                                                                                                                      // finish appending to current window, pop it off the window stack.
; 135  :     IMGUI_API bool          BeginChild(const char* str_id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags extra_flags = 0);    // begin a scrolling region. size==0.0f: use remaining window size, size<0.0f: use remaining window size minus abs(size). size>0.0f: fixed size. each axis can use a different mode, e.g. ImVec2(0,400).
; 136  :     IMGUI_API bool          BeginChild(ImGuiID id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags extra_flags = 0);            // "
; 137  :     IMGUI_API void          EndChild();
; 138  :     IMGUI_API ImVec2        GetContentRegionMax();                                              // current content boundaries (typically window boundaries including scrolling, or current column boundaries), in windows coordinates
; 139  :     IMGUI_API ImVec2        GetContentRegionAvail();                                            // == GetContentRegionMax() - GetCursorPos()
; 140  :     IMGUI_API float         GetContentRegionAvailWidth();                                       //
; 141  :     IMGUI_API ImVec2        GetWindowContentRegionMin();                                        // content boundaries min (roughly (0,0)-Scroll), in window coordinates
; 142  :     IMGUI_API ImVec2        GetWindowContentRegionMax();                                        // content boundaries max (roughly (0,0)+Size-Scroll) where Size can be override with SetNextWindowContentSize(), in window coordinates
; 143  :     IMGUI_API float         GetWindowContentRegionWidth();                                      //
; 144  :     IMGUI_API ImDrawList*   GetWindowDrawList();                                                // get rendering command-list if you want to append your own draw primitives
; 145  :     IMGUI_API ImVec2        GetWindowPos();                                                     // get current window position in screen space (useful if you want to do your own drawing via the DrawList api)
; 146  :     IMGUI_API ImVec2        GetWindowSize();                                                    // get current window size
; 147  :     IMGUI_API float         GetWindowWidth();
; 148  :     IMGUI_API float         GetWindowHeight();
; 149  :     IMGUI_API bool          IsWindowCollapsed();
; 150  :     IMGUI_API void          SetWindowFontScale(float scale);                                    // per-window font scale. Adjust IO.FontGlobalScale if you want to scale all windows
; 151  : 
; 152  :     IMGUI_API void          SetNextWindowPos(const ImVec2& pos, ImGuiSetCond cond = 0);         // set next window position. call before Begin()
; 153  :     IMGUI_API void          SetNextWindowPosCenter(ImGuiSetCond cond = 0);                      // set next window position to be centered on screen. call before Begin()
; 154  :     IMGUI_API void          SetNextWindowSize(const ImVec2& size, ImGuiSetCond cond = 0);       // set next window size. set axis to 0.0f to force an auto-fit on this axis. call before Begin()
; 155  :     IMGUI_API void          SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeConstraintCallback custom_callback = NULL, void* custom_callback_data = NULL); // set next window size limits. use -1,-1 on either X/Y axis to preserve the current size. Use callback to apply non-trivial programmatic constraints.
; 156  :     IMGUI_API void          SetNextWindowContentSize(const ImVec2& size);                       // set next window content size (enforce the range of scrollbars). set axis to 0.0f to leave it automatic. call before Begin()
; 157  :     IMGUI_API void          SetNextWindowContentWidth(float width);                             // set next window content width (enforce the range of horizontal scrollbar). call before Begin()
; 158  :     IMGUI_API void          SetNextWindowCollapsed(bool collapsed, ImGuiSetCond cond = 0);      // set next window collapsed state. call before Begin()
; 159  :     IMGUI_API void          SetNextWindowFocus();                                               // set next window to be focused / front-most. call before Begin()
; 160  :     IMGUI_API void          SetWindowPos(const ImVec2& pos, ImGuiSetCond cond = 0);             // (not recommended) set current window position - call within Begin()/End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.
; 161  :     IMGUI_API void          SetWindowSize(const ImVec2& size, ImGuiSetCond cond = 0);           // (not recommended) set current window size - call within Begin()/End(). set to ImVec2(0,0) to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.    
; 162  :     IMGUI_API void          SetWindowCollapsed(bool collapsed, ImGuiSetCond cond = 0);          // (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().
; 163  :     IMGUI_API void          SetWindowFocus();                                                   // (not recommended) set current window to be focused / front-most. prefer using SetNextWindowFocus().
; 164  :     IMGUI_API void          SetWindowPos(const char* name, const ImVec2& pos, ImGuiSetCond cond = 0);      // set named window position.
; 165  :     IMGUI_API void          SetWindowSize(const char* name, const ImVec2& size, ImGuiSetCond cond = 0);    // set named window size. set axis to 0.0f to force an auto-fit on this axis.
; 166  :     IMGUI_API void          SetWindowCollapsed(const char* name, bool collapsed, ImGuiSetCond cond = 0);   // set named window collapsed state
; 167  :     IMGUI_API void          SetWindowFocus(const char* name);                                              // set named window to be focused / front-most. use NULL to remove focus.
; 168  : 
; 169  :     IMGUI_API float         GetScrollX();                                                       // get scrolling amount [0..GetScrollMaxX()]
; 170  :     IMGUI_API float         GetScrollY();                                                       // get scrolling amount [0..GetScrollMaxY()]
; 171  :     IMGUI_API float         GetScrollMaxX();                                                    // get maximum scrolling amount ~~ ContentSize.X - WindowSize.X
; 172  :     IMGUI_API float         GetScrollMaxY();                                                    // get maximum scrolling amount ~~ ContentSize.Y - WindowSize.Y
; 173  :     IMGUI_API void          SetScrollX(float scroll_x);                                         // set scrolling amount [0..GetScrollMaxX()]
; 174  :     IMGUI_API void          SetScrollY(float scroll_y);                                         // set scrolling amount [0..GetScrollMaxY()]
; 175  :     IMGUI_API void          SetScrollHere(float center_y_ratio = 0.5f);                         // adjust scrolling amount to make current cursor position visible. center_y_ratio=0.0: top, 0.5: center, 1.0: bottom.
; 176  :     IMGUI_API void          SetScrollFromPosY(float pos_y, float center_y_ratio = 0.5f);        // adjust scrolling amount to make given position valid. use GetCursorPos() or GetCursorStartPos()+offset to get valid positions.
; 177  :     IMGUI_API void          SetKeyboardFocusHere(int offset = 0);  // FIXME-NAVIGATION          // focus keyboard on the next widget. Use positive 'offset' to access sub components of a multiple component widget. Use negative 'offset' to access previous widgets.
; 178  :     IMGUI_API void          SetStateStorage(ImGuiStorage* tree);                                // replace tree state storage with our own (if you want to manipulate it yourself, typically clear subsection of it)
; 179  :     IMGUI_API ImGuiStorage* GetStateStorage();
; 180  : 
; 181  :     // Parameters stacks (shared)
; 182  :     IMGUI_API void          PushFont(ImFont* font);                                             // use NULL as a shortcut to push default font
; 183  :     IMGUI_API void          PopFont();
; 184  :     IMGUI_API void          PushStyleColor(ImGuiCol idx, const ImVec4& col);
; 185  :     IMGUI_API void          PopStyleColor(int count = 1);
; 186  :     IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, float val);
; 187  :     IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, const ImVec2& val);
; 188  :     IMGUI_API void          PopStyleVar(int count = 1);
; 189  :     IMGUI_API ImFont*       GetFont();                                                          // get current font
; 190  :     IMGUI_API float         GetFontSize();                                                      // get current font size (= height in pixels) of current font with current scale applied
; 191  :     IMGUI_API ImVec2        GetFontTexUvWhitePixel();                                           // get UV coordinate for a while pixel, useful to draw custom shapes via the ImDrawList API
; 192  :     IMGUI_API ImU32         GetColorU32(ImGuiCol idx, float alpha_mul = 1.0f);                  // retrieve given style color with style alpha applied and optional extra alpha multiplier
; 193  :     IMGUI_API ImU32         GetColorU32(const ImVec4& col);                                     // retrieve given color with style alpha applied
; 194  : 
; 195  :     // Parameters stacks (current window)
; 196  :     IMGUI_API void          PushItemWidth(float item_width);                                    // width of items for the common item+label case, pixels. 0.0f = default to ~2/3 of windows width, >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -1.0f always align width to the right side)
; 197  :     IMGUI_API void          PopItemWidth();
; 198  :     IMGUI_API float         CalcItemWidth();                                                    // width of item given pushed settings and current cursor position
; 199  :     IMGUI_API void          PushTextWrapPos(float wrap_pos_x = 0.0f);                           // word-wrapping for Text*() commands. < 0.0f: no wrapping; 0.0f: wrap to end of window (or column); > 0.0f: wrap at 'wrap_pos_x' position in window local space
; 200  :     IMGUI_API void          PopTextWrapPos();
; 201  :     IMGUI_API void          PushAllowKeyboardFocus(bool v);                                     // allow focusing using TAB/Shift-TAB, enabled by default but you can disable it for certain widgets
; 202  :     IMGUI_API void          PopAllowKeyboardFocus();
; 203  :     IMGUI_API void          PushButtonRepeat(bool repeat);                                      // in 'repeat' mode, Button*() functions return repeated true in a typematic manner (uses io.KeyRepeatDelay/io.KeyRepeatRate for now). Note that you can call IsItemActive() after any Button() to tell if the button is held in the current frame.
; 204  :     IMGUI_API void          PopButtonRepeat();
; 205  : 
; 206  :     // Cursor / Layout
; 207  :     IMGUI_API void          Separator();                                                        // horizontal line
; 208  :     IMGUI_API void          SameLine(float pos_x = 0.0f, float spacing_w = -1.0f);              // call between widgets or groups to layout them horizontally
; 209  :     IMGUI_API void          NewLine();                                                          // undo a SameLine()
; 210  :     IMGUI_API void          Spacing();                                                          // add vertical spacing
; 211  :     IMGUI_API void          Dummy(const ImVec2& size);                                          // add a dummy item of given size
; 212  :     IMGUI_API void          Indent(float indent_w = 0.0f);                                      // move content position toward the right, by style.IndentSpacing or indent_w if >0
; 213  :     IMGUI_API void          Unindent(float indent_w = 0.0f);                                    // move content position back to the left, by style.IndentSpacing or indent_w if >0
; 214  :     IMGUI_API void          BeginGroup();                                                       // lock horizontal starting position + capture group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)
; 215  :     IMGUI_API void          EndGroup();
; 216  :     IMGUI_API ImVec2        GetCursorPos();                                                     // cursor position is relative to window position
; 217  :     IMGUI_API float         GetCursorPosX();                                                    // "
; 218  :     IMGUI_API float         GetCursorPosY();                                                    // "
; 219  :     IMGUI_API void          SetCursorPos(const ImVec2& local_pos);                              // "
; 220  :     IMGUI_API void          SetCursorPosX(float x);                                             // "
; 221  :     IMGUI_API void          SetCursorPosY(float y);                                             // "
; 222  :     IMGUI_API ImVec2        GetCursorStartPos();                                                // initial cursor position
; 223  :     IMGUI_API ImVec2        GetCursorScreenPos();                                               // cursor position in absolute screen coordinates [0..io.DisplaySize] (useful to work with ImDrawList API)
; 224  :     IMGUI_API void          SetCursorScreenPos(const ImVec2& pos);                              // cursor position in absolute screen coordinates [0..io.DisplaySize]
; 225  :     IMGUI_API void          AlignFirstTextHeightToWidgets();                                    // call once if the first item on the line is a Text() item and you want to vertically lower it to match subsequent (bigger) widgets
; 226  :     IMGUI_API float         GetTextLineHeight();                                                // height of font == GetWindowFontSize()
; 227  :     IMGUI_API float         GetTextLineHeightWithSpacing();                                     // distance (in pixels) between 2 consecutive lines of text == GetWindowFontSize() + GetStyle().ItemSpacing.y
; 228  :     IMGUI_API float         GetItemsLineHeightWithSpacing();                                    // distance (in pixels) between 2 consecutive lines of standard height widgets == GetWindowFontSize() + GetStyle().FramePadding.y*2 + GetStyle().ItemSpacing.y
; 229  : 
; 230  :     // Columns
; 231  :     // You can also use SameLine(pos_x) for simplified columning. The columns API is still work-in-progress and rather lacking.
; 232  :     IMGUI_API void          Columns(int count = 1, const char* id = NULL, bool border = true);  // setup number of columns. use an identifier to distinguish multiple column sets. close with Columns(1).
; 233  :     IMGUI_API void          NextColumn();                                                       // next column
; 234  :     IMGUI_API int           GetColumnIndex();                                                   // get current column index
; 235  :     IMGUI_API float         GetColumnOffset(int column_index = -1);                             // get position of column line (in pixels, from the left side of the contents region). pass -1 to use current column, otherwise 0..GetcolumnsCount() inclusive. column 0 is usually 0.0f and not resizable unless you call this
; 236  :     IMGUI_API void          SetColumnOffset(int column_index, float offset_x);                  // set position of column line (in pixels, from the left side of the contents region). pass -1 to use current column
; 237  :     IMGUI_API float         GetColumnWidth(int column_index = -1);                              // column width (== GetColumnOffset(GetColumnIndex()+1) - GetColumnOffset(GetColumnOffset())
; 238  :     IMGUI_API int           GetColumnsCount();                                                  // number of columns (what was passed to Columns())
; 239  : 
; 240  :     // ID scopes
; 241  :     // If you are creating widgets in a loop you most likely want to push a unique identifier so ImGui can differentiate them.
; 242  :     // You can also use the "##foobar" syntax within widget label to distinguish them from each others. Read "A primer on the use of labels/IDs" in the FAQ for more details.
; 243  :     IMGUI_API void          PushID(const char* str_id);                                         // push identifier into the ID stack. IDs are hash of the *entire* stack!
; 244  :     IMGUI_API void          PushID(const char* str_id_begin, const char* str_id_end);
; 245  :     IMGUI_API void          PushID(const void* ptr_id);
; 246  :     IMGUI_API void          PushID(int int_id);
; 247  :     IMGUI_API void          PopID();
; 248  :     IMGUI_API ImGuiID       GetID(const char* str_id);                                          // calculate unique ID (hash of whole ID stack + given parameter). useful if you want to query into ImGuiStorage yourself. otherwise rarely needed
; 249  :     IMGUI_API ImGuiID       GetID(const char* str_id_begin, const char* str_id_end);
; 250  :     IMGUI_API ImGuiID       GetID(const void* ptr_id);
; 251  : 
; 252  :     // Widgets
; 253  :     IMGUI_API void          Text(const char* fmt, ...) IM_PRINTFARGS(1);
; 254  :     IMGUI_API void          TextV(const char* fmt, va_list args);
; 255  :     IMGUI_API void          TextColored(const ImVec4& col, const char* fmt, ...) IM_PRINTFARGS(2);  // shortcut for PushStyleColor(ImGuiCol_Text, col); Text(fmt, ...); PopStyleColor();
; 256  :     IMGUI_API void          TextColoredV(const ImVec4& col, const char* fmt, va_list args);
; 257  :     IMGUI_API void          TextDisabled(const char* fmt, ...) IM_PRINTFARGS(1);                    // shortcut for PushStyleColor(ImGuiCol_Text, style.Colors[ImGuiCol_TextDisabled]); Text(fmt, ...); PopStyleColor();
; 258  :     IMGUI_API void          TextDisabledV(const char* fmt, va_list args);
; 259  :     IMGUI_API void          TextWrapped(const char* fmt, ...) IM_PRINTFARGS(1);                     // shortcut for PushTextWrapPos(0.0f); Text(fmt, ...); PopTextWrapPos();. Note that this won't work on an auto-resizing window if there's no other widgets to extend the window width, yoy may need to set a size using SetNextWindowSize().
; 260  :     IMGUI_API void          TextWrappedV(const char* fmt, va_list args);
; 261  :     IMGUI_API void          TextUnformatted(const char* text, const char* text_end = NULL);         // doesn't require null terminated string if 'text_end' is specified. no copy done to any bounded stack buffer, recommended for long chunks of text
; 262  :     IMGUI_API void          LabelText(const char* label, const char* fmt, ...) IM_PRINTFARGS(2);    // display text+label aligned the same way as value+label widgets
; 263  :     IMGUI_API void          LabelTextV(const char* label, const char* fmt, va_list args);
; 264  :     IMGUI_API void          Bullet();                                                               // draw a small circle and keep the cursor on the same line. advance cursor x position by GetTreeNodeToLabelSpacing(), same distance that TreeNode() uses
; 265  :     IMGUI_API void          BulletText(const char* fmt, ...) IM_PRINTFARGS(1);                      // shortcut for Bullet()+Text()
; 266  :     IMGUI_API void          BulletTextV(const char* fmt, va_list args);
; 267  :     IMGUI_API bool          Button(const char* label, const ImVec2& size = ImVec2(0,0));            // button
; 268  :     IMGUI_API bool          SmallButton(const char* label);                                         // button with FramePadding=(0,0)
; 269  :     IMGUI_API bool          InvisibleButton(const char* str_id, const ImVec2& size);
; 270  :     IMGUI_API void          Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0), const ImVec2& uv1 = ImVec2(1,1), const ImVec4& tint_col = ImVec4(1,1,1,1), const ImVec4& border_col = ImVec4(0,0,0,0));
; 271  :     IMGUI_API bool          ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0),  const ImVec2& uv1 = ImVec2(1,1), int frame_padding = -1, const ImVec4& bg_col = ImVec4(0,0,0,0), const ImVec4& tint_col = ImVec4(1,1,1,1));    // <0 frame_padding uses default frame padding settings. 0 for no padding
; 272  :     IMGUI_API bool          Checkbox(const char* label, bool* v);
; 273  :     IMGUI_API bool          CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value);
; 274  :     IMGUI_API bool          RadioButton(const char* label, bool active);
; 275  :     IMGUI_API bool          RadioButton(const char* label, int* v, int v_button);
; 276  :     IMGUI_API bool          Combo(const char* label, int* current_item, const char* const* items, int items_count, int height_in_items = -1);
; 277  :     IMGUI_API bool          Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int height_in_items = -1);      // separate items with \0, end item-list with \0\0
; 278  :     IMGUI_API bool          Combo(const char* label, int* current_item, bool (*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int height_in_items = -1);
; 279  :     IMGUI_API bool          ColorButton(const ImVec4& col, bool small_height = false, bool outline_border = true);
; 280  :     IMGUI_API bool          ColorEdit3(const char* label, float col[3]);                            // Hint: 'float col[3]' function argument is same as 'float* col'. You can pass address of first element out of a contiguous set, e.g. &myvector.x
; 281  :     IMGUI_API bool          ColorEdit4(const char* label, float col[4], bool show_alpha = true);    // "
; 282  :     IMGUI_API void          ColorEditMode(ImGuiColorEditMode mode);                                 // FIXME-OBSOLETE: This is inconsistent with most of the API and will be obsoleted/replaced.
; 283  :     IMGUI_API void          PlotLines(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0), int stride = sizeof(float));
; 284  :     IMGUI_API void          PlotLines(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0));
; 285  : 
; 286  :     //XXX: Special K Add
; 287  :     IMGUI_API void          PlotLinesC(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0), int stride = sizeof(float), float saturation = 0.0f, float value = 0.0f, float avg = 0.0f, bool inverse = false);
; 288  :     IMGUI_API void          PlotHistogram(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0), int stride = sizeof(float));
; 289  :     IMGUI_API void          PlotHistogram(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0));
; 290  :     IMGUI_API void          ProgressBar(float fraction, const ImVec2& size_arg = ImVec2(-1,0), const char* overlay = NULL);
; 291  : 
; 292  :     // Widgets: Drags (tip: ctrl+click on a drag box to input with keyboard. manually input values aren't clamped, can go off-bounds)
; 293  :     // For all the Float2/Float3/Float4/Int2/Int3/Int4 versions of every functions, remember than a 'float v[3]' function argument is the same as 'float* v'. You can pass address of your first element out of a contiguous set, e.g. &myvector.x
; 294  :     // Speed are per-pixel of mouse movement (v_speed=0.2f: mouse needs to move by 5 pixels to increase value by 1). For gamepad/keyboard navigation, minimum speed is Max(v_speed, minimum_step_at_given_precision).
; 295  :     IMGUI_API bool          DragFloat(const char* label, float* v, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", float power = 1.0f);     // If v_min >= v_max we have no bound
; 296  :     IMGUI_API bool          DragFloat2(const char* label, float v[2], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", float power = 1.0f);
; 297  :     IMGUI_API bool          DragFloat3(const char* label, float v[3], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", float power = 1.0f);
; 298  :     IMGUI_API bool          DragFloat4(const char* label, float v[4], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", float power = 1.0f);
; 299  :     IMGUI_API bool          DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", const char* display_format_max = NULL, float power = 1.0f);
; 300  :     IMGUI_API bool          DragInt(const char* label, int* v, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f");                                       // If v_min >= v_max we have no bound
; 301  :     IMGUI_API bool          DragInt2(const char* label, int v[2], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f");
; 302  :     IMGUI_API bool          DragInt3(const char* label, int v[3], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f");
; 303  :     IMGUI_API bool          DragInt4(const char* label, int v[4], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f");
; 304  :     IMGUI_API bool          DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f", const char* display_format_max = NULL);
; 305  : 
; 306  :     // Widgets: Input with Keyboard
; 307  :     IMGUI_API bool          InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiTextEditCallback callback = NULL, void* user_data = NULL);
; 308  :     IMGUI_API bool          InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size = ImVec2(0,0), ImGuiInputTextFlags flags = 0, ImGuiTextEditCallback callback = NULL, void* user_data = NULL);
; 309  :     IMGUI_API bool          InputFloat(const char* label, float* v, float step = 0.0f, float step_fast = 0.0f, int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0);
; 310  :     IMGUI_API bool          InputFloat2(const char* label, float v[2], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0);
; 311  :     IMGUI_API bool          InputFloat3(const char* label, float v[3], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0);
; 312  :     IMGUI_API bool          InputFloat4(const char* label, float v[4], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0);
; 313  :     IMGUI_API bool          InputInt(const char* label, int* v, int step = 1, int step_fast = 100, ImGuiInputTextFlags extra_flags = 0);
; 314  :     IMGUI_API bool          InputInt2(const char* label, int v[2], ImGuiInputTextFlags extra_flags = 0);
; 315  :     IMGUI_API bool          InputInt3(const char* label, int v[3], ImGuiInputTextFlags extra_flags = 0);
; 316  :     IMGUI_API bool          InputInt4(const char* label, int v[4], ImGuiInputTextFlags extra_flags = 0);
; 317  : 
; 318  :     // Widgets: Sliders (tip: ctrl+click on a slider to input with keyboard. manually input values aren't clamped, can go off-bounds)
; 319  :     IMGUI_API bool          SliderFloat(const char* label, float* v, float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);     // adjust display_format to decorate the value with a prefix or a suffix. Use power!=1.0 for logarithmic sliders
; 320  :     IMGUI_API bool          SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);
; 321  :     IMGUI_API bool          SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);
; 322  :     IMGUI_API bool          SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);
; 323  :     IMGUI_API bool          SliderAngle(const char* label, float* v_rad, float v_degrees_min = -360.0f, float v_degrees_max = +360.0f);
; 324  :     IMGUI_API bool          SliderInt(const char* label, int* v, int v_min, int v_max, const char* display_format = "%.0f");
; 325  :     IMGUI_API bool          SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* display_format = "%.0f");
; 326  :     IMGUI_API bool          SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* display_format = "%.0f");
; 327  :     IMGUI_API bool          SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* display_format = "%.0f");
; 328  :     IMGUI_API bool          VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);
; 329  :     IMGUI_API bool          VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* display_format = "%.0f");
; 330  : 
; 331  :     // Widgets: Trees
; 332  :     IMGUI_API bool          TreeNode(const char* label);                                            // if returning 'true' the node is open and the tree id is pushed into the id stack. user is responsible for calling TreePop().
; 333  :     IMGUI_API bool          TreeNode(const char* str_id, const char* fmt, ...) IM_PRINTFARGS(2);    // read the FAQ about why and how to use ID. to align arbitrary text at the same level as a TreeNode() you can use Bullet().
; 334  :     IMGUI_API bool          TreeNode(const void* ptr_id, const char* fmt, ...) IM_PRINTFARGS(2);    // "
; 335  :     IMGUI_API bool          TreeNodeV(const char* str_id, const char* fmt, va_list args);           // "
; 336  :     IMGUI_API bool          TreeNodeV(const void* ptr_id, const char* fmt, va_list args);           // "
; 337  :     IMGUI_API bool          TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags = 0);
; 338  :     IMGUI_API bool          TreeNodeEx(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...) IM_PRINTFARGS(3);
; 339  :     IMGUI_API bool          TreeNodeEx(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...) IM_PRINTFARGS(3);
; 340  :     IMGUI_API bool          TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args);
; 341  :     IMGUI_API bool          TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args);
; 342  :     IMGUI_API void          TreePush(const char* str_id = NULL);                                    // ~ Indent()+PushId(). Already called by TreeNode() when returning true, but you can call Push/Pop yourself for layout purpose
; 343  :     IMGUI_API void          TreePush(const void* ptr_id = NULL);                                    // "
; 344  :     IMGUI_API void          TreePop();                                                              // ~ Unindent()+PopId()
; 345  :     IMGUI_API void          TreeAdvanceToLabelPos();                                                // advance cursor x position by GetTreeNodeToLabelSpacing()
; 346  :     IMGUI_API float         GetTreeNodeToLabelSpacing();                                            // horizontal distance preceding label when using TreeNode*() or Bullet() == (g.FontSize + style.FramePadding.x*2) for a regular unframed TreeNode
; 347  :     IMGUI_API void          SetNextTreeNodeOpen(bool is_open, ImGuiSetCond cond = 0);               // set next TreeNode/CollapsingHeader open state.
; 348  :     IMGUI_API bool          CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags = 0);      // if returning 'true' the header is open. doesn't indent nor push on ID stack. user doesn't have to call TreePop().
; 349  :     IMGUI_API bool          CollapsingHeader(const char* label, bool* p_open, ImGuiTreeNodeFlags flags = 0); // when 'p_open' isn't NULL, display an additional small close button on upper right of the header
; 350  : 
; 351  :     // Widgets: Selectable / Lists
; 352  :     IMGUI_API bool          Selectable(const char* label, bool selected = false, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0));  // size.x==0.0: use remaining width, size.x>0.0: specify width. size.y==0.0: use label height, size.y>0.0: specify height
; 353  :     IMGUI_API bool          Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0));
; 354  :     IMGUI_API bool          ListBox(const char* label, int* current_item, const char* const* items, int items_count, int height_in_items = -1);
; 355  :     IMGUI_API bool          ListBox(const char* label, int* current_item, bool (*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int height_in_items = -1);
; 356  :     IMGUI_API bool          ListBoxHeader(const char* label, const ImVec2& size = ImVec2(0,0)); // use if you want to reimplement ListBox() will custom data or interactions. make sure to call ListBoxFooter() afterwards.
; 357  :     IMGUI_API bool          ListBoxHeader(const char* label, int items_count, int height_in_items = -1); // "
; 358  :     IMGUI_API void          ListBoxFooter();                                                    // terminate the scrolling region
; 359  : 
; 360  :     // Widgets: Value() Helpers. Output single value in "name: value" format (tip: freely declare more in your code to handle your types. you can add functions to the ImGui namespace)
; 361  :     IMGUI_API void          Value(const char* prefix, bool b);
; 362  :     IMGUI_API void          Value(const char* prefix, int v);
; 363  :     IMGUI_API void          Value(const char* prefix, unsigned int v);
; 364  :     IMGUI_API void          Value(const char* prefix, float v, const char* float_format = NULL);
; 365  :     IMGUI_API void          ValueColor(const char* prefix, const ImVec4& v);
; 366  :     IMGUI_API void          ValueColor(const char* prefix, ImU32 v);
; 367  : 
; 368  :     // Tooltips
; 369  :     IMGUI_API void          SetTooltip(const char* fmt, ...) IM_PRINTFARGS(1);                  // set tooltip under mouse-cursor, typically use with ImGui::IsHovered(). last call wins
; 370  :     IMGUI_API void          SetTooltipV(const char* fmt, va_list args);
; 371  :     IMGUI_API void          BeginTooltip();                                                     // use to create full-featured tooltip windows that aren't just text
; 372  :     IMGUI_API void          EndTooltip();
; 373  : 
; 374  :     // Menus
; 375  :     IMGUI_API bool          BeginMainMenuBar();                                                 // create and append to a full screen menu-bar. only call EndMainMenuBar() if this returns true!
; 376  :     IMGUI_API void          EndMainMenuBar();
; 377  :     IMGUI_API bool          BeginMenuBar();                                                     // append to menu-bar of current window (requires ImGuiWindowFlags_MenuBar flag set). only call EndMenuBar() if this returns true!
; 378  :     IMGUI_API void          EndMenuBar();
; 379  :     IMGUI_API bool          BeginMenu(const char* label, bool enabled = true);                  // create a sub-menu entry. only call EndMenu() if this returns true!
; 380  :     IMGUI_API void          EndMenu();
; 381  :     IMGUI_API bool          MenuItem(const char* label, const char* shortcut = NULL, bool selected = false, bool enabled = true);  // return true when activated. shortcuts are displayed for convenience but not processed by ImGui at the moment
; 382  :     IMGUI_API bool          MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled = true);              // return true when activated + toggle (*p_selected) if p_selected != NULL
; 383  : 
; 384  :     // Popups
; 385  :     IMGUI_API void          OpenPopup(const char* str_id);                                      // mark popup as open. popups are closed when user click outside, or activate a pressable item, or CloseCurrentPopup() is called within a BeginPopup()/EndPopup() block. popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level).
; 386  :     IMGUI_API bool          BeginPopup(const char* str_id);                                     // return true if the popup is open, and you can start outputting to it. only call EndPopup() if BeginPopup() returned true!
; 387  :     IMGUI_API bool          BeginPopupModal(const char* name, bool* p_open = NULL, ImGuiWindowFlags extra_flags = 0);               // modal dialog (block interactions behind the modal window, can't close the modal window by clicking outside)
; 388  :     IMGUI_API bool          BeginPopupContextItem(const char* str_id, int mouse_button = 1);                                        // helper to open and begin popup when clicked on last item. read comments in .cpp!
; 389  :     IMGUI_API bool          BeginPopupContextWindow(bool also_over_items = true, const char* str_id = NULL, int mouse_button = 1);  // helper to open and begin popup when clicked on current window.
; 390  :     IMGUI_API bool          BeginPopupContextVoid(const char* str_id = NULL, int mouse_button = 1);                                 // helper to open and begin popup when clicked in void (no window).
; 391  :     IMGUI_API void          EndPopup();
; 392  :     IMGUI_API void          CloseCurrentPopup();                                                // close the popup we have begin-ed into. clicking on a MenuItem or Selectable automatically close the current popup.
; 393  : 
; 394  :     // Logging: all text output from interface is redirected to tty/file/clipboard. By default, tree nodes are automatically opened during logging.
; 395  :     IMGUI_API void          LogToTTY(int max_depth = -1);                                       // start logging to tty
; 396  :     IMGUI_API void          LogToFile(int max_depth = -1, const char* filename = NULL);         // start logging to file
; 397  :     IMGUI_API void          LogToClipboard(int max_depth = -1);                                 // start logging to OS clipboard
; 398  :     IMGUI_API void          LogFinish();                                                        // stop logging (close file, etc.)
; 399  :     IMGUI_API void          LogButtons();                                                       // helper to display buttons for logging to tty/file/clipboard
; 400  :     IMGUI_API void          LogText(const char* fmt, ...) IM_PRINTFARGS(1);                     // pass text data straight to log (without being displayed)
; 401  : 
; 402  :     // Clipping
; 403  :     IMGUI_API void          PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect);
; 404  :     IMGUI_API void          PopClipRect();
; 405  : 
; 406  :     // Utilities
; 407  :     IMGUI_API bool          IsItemHovered();                                                    // is the last item hovered by mouse (and usable)? or we are currently using Nav and the item is focused.
; 408  :     IMGUI_API bool          IsItemHoveredRect();                                                // is the last item hovered by mouse? even if another item is active or window is blocked by popup while we are hovering this
; 409  :     IMGUI_API bool          IsItemActive();                                                     // is the last item active? (e.g. button being held, text field being edited- items that don't interact will always return false)
; 410  :     IMGUI_API bool          IsItemFocused();                                                    // is the last item focused for keyboard/gamepad navigation?
; 411  :     IMGUI_API bool          IsItemClicked(int mouse_button = 0);                                // is the last item clicked? (e.g. button/node just clicked on)
; 412  :     IMGUI_API bool          IsItemVisible();                                                    // is the last item visible? (aka not out of sight due to clipping/scrolling.)
; 413  :     IMGUI_API bool          IsAnyItemHovered();
; 414  :     IMGUI_API bool          IsAnyItemActive();
; 415  :     IMGUI_API bool          IsAnyItemFocused();
; 416  :     IMGUI_API ImVec2        GetItemRectMin();                                                   // get bounding rect of last item in screen space
; 417  :     IMGUI_API ImVec2        GetItemRectMax();                                                   // "
; 418  :     IMGUI_API ImVec2        GetItemRectSize();                                                  // "
; 419  :     IMGUI_API void          SetItemAllowOverlap();                                              // allow last item to be overlapped by a subsequent item. sometimes useful with invisible buttons, selectables, etc. to catch unused area.
; 420  :     IMGUI_API void          SetItemDefaultFocus();                                              // make last item the default focused item of a window
; 421  :     IMGUI_API bool          IsWindowFocused();                                                  // is current window focused
; 422  :     IMGUI_API bool          IsWindowHovered();                                                  // is current window hovered and hoverable (not blocked by a popup) (differentiate child windows from each others)
; 423  :     IMGUI_API bool          IsWindowHoveredRect();                                              // is current window hovered, disregarding of any consideration of being blocked by a popup. (unlike IsWindowHovered() this will return true even if the window is blocked because of a popup)
; 424  :     IMGUI_API bool          IsRootWindowFocused();                                              // is current root window focused (root = top-most parent of a child, otherwise self)
; 425  :     IMGUI_API bool          IsRootWindowOrAnyChildFocused();                                    // is current root window or any of its child (including current window) focused
; 426  :     IMGUI_API bool          IsRootWindowOrAnyChildHovered();                                    // is current root window or any of its child (including current window) hovered and hoverable (not blocked by a popup)
; 427  :     IMGUI_API bool          IsAnyWindowFocused();
; 428  :     IMGUI_API bool          IsAnyWindowHovered();                                               // is mouse hovering any visible window
; 429  :     IMGUI_API bool          IsAnyWindowHoveredAtPos(const ImVec2& pos);                         // is given position hovering any active imgui window
; 430  :     IMGUI_API bool          IsRectVisible(const ImVec2& size);                                  // test if rectangle (of given size, starting from cursor position) is visible / not clipped.
; 431  :     IMGUI_API bool          IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max);      // test if rectangle (in screen space) is visible / not clipped. to perform coarse clipping on user's side.
; 432  :     IMGUI_API float         GetTime();
; 433  :     IMGUI_API int           GetFrameCount();
; 434  :     IMGUI_API const char*   GetStyleColName(ImGuiCol idx);
; 435  :     IMGUI_API ImVec2        CalcItemRectClosestPoint(const ImVec2& pos, bool on_edge = false, float outward = +0.0f);   // utility to find the closest point the last item bounding rectangle edge. useful to visually link items
; 436  :     IMGUI_API ImVec2        CalcTextSize(const char* text, const char* text_end = NULL, bool hide_text_after_double_hash = false, float wrap_width = -1.0f);
; 437  :     IMGUI_API void          CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end);    // calculate coarse clipping for large list of evenly sized items. Prefer using the ImGuiListClipper higher-level helper if you can.
; 438  : 
; 439  :     IMGUI_API bool          BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags extra_flags = 0);	// helper to create a child window / scrolling region that looks like a normal widget frame
; 440  :     IMGUI_API void          EndChildFrame();
; 441  : 
; 442  :     IMGUI_API ImVec4        ColorConvertU32ToFloat4(ImU32 in);
; 443  :     IMGUI_API ImU32         ColorConvertFloat4ToU32(const ImVec4& in);
; 444  :     IMGUI_API void          ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v);
; 445  :     IMGUI_API void          ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b);
; 446  : 
; 447  :     // Inputs
; 448  :     IMGUI_API int           GetKeyIndex(ImGuiKey key);                                          // map ImGuiKey_* values into user's key index. == io.KeyMap[key]
; 449  :     IMGUI_API bool          IsKeyDown(int key_index);                                           // key_index into the keys_down[] array, imgui doesn't know the semantic of each entry, uses your own indices!
; 450  :     IMGUI_API bool          IsKeyPressed(int key_index, bool repeat = true);                    // uses user's key indices as stored in the keys_down[] array. if repeat=true. uses io.KeyRepeatDelay / KeyRepeatRate
; 451  :     IMGUI_API bool          IsKeyReleased(int key_index);                                       // "
; 452  :     IMGUI_API int           GetKeyPressedAmount(int key_index, float repeat_delay, float rate); // uses provided repeat rate/delay. return a count, most often 0 or 1 but might be >1 if RepeatRate is small enough that DeltaTime > RepeatRate
; 453  :     IMGUI_API bool          IsMouseDown(int button);                                            // is mouse button held
; 454  :     IMGUI_API bool          IsMouseClicked(int button, bool repeat = false);                    // did mouse button clicked (went from !Down to Down)
; 455  :     IMGUI_API bool          IsMouseDoubleClicked(int button);                                   // did mouse button double-clicked. a double-click returns false in IsMouseClicked(). uses io.MouseDoubleClickTime.
; 456  :     IMGUI_API bool          IsMouseReleased(int button);                                        // did mouse button released (went from Down to !Down)
; 457  :     IMGUI_API bool          IsMouseDragging(int button = 0, float lock_threshold = -1.0f);      // is mouse dragging. if lock_threshold < -1.0f uses io.MouseDraggingThreshold
; 458  :     IMGUI_API bool          IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip = true);  // is mouse hovering given bounding rect (in screen space). clipped by current clipping settings. disregarding of consideration of focus/window ordering/blocked by a popup.
; 459  :     IMGUI_API ImVec2        GetMousePos();                                                      // shortcut to ImGui::GetIO().MousePos provided by user, to be consistent with other calls
; 460  :     IMGUI_API ImVec2        GetMousePosOnOpeningCurrentPopup();                                 // retrieve backup of mouse positioning at the time of opening popup we have BeginPopup() into
; 461  :     IMGUI_API ImVec2        GetMouseDragDelta(int button = 0, float lock_threshold = -1.0f);    // dragging amount since clicking. if lock_threshold < -1.0f uses io.MouseDraggingThreshold
; 462  :     IMGUI_API void          ResetMouseDragDelta(int button = 0);                                //
; 463  :     IMGUI_API ImGuiMouseCursor GetMouseCursor();                                                // get desired cursor type, reset in ImGui::NewFrame(), this updated during the frame. valid before Render(). If you use software rendering by setting io.MouseDrawCursor ImGui will render those for you
; 464  :     IMGUI_API void          SetMouseCursor(ImGuiMouseCursor type);                              // set desired cursor type
; 465  :     IMGUI_API void          CaptureKeyboardFromApp(bool capture = true);                        // manually override io.WantCaptureKeyboard flag next frame (said flag is entirely left for your application handle). e.g. force capture keyboard when your widget is being hovered.
; 466  :     IMGUI_API void          CaptureMouseFromApp(bool capture = true);                           // manually override io.WantCaptureMouse flag next frame (said flag is entirely left for your application handle).
; 467  :     IMGUI_API bool          IsNavDragging(int stick_no = 1, float lock_threshold = -1.0f);
; 468  : 
; 469  :     // Helpers functions to access functions pointers in ImGui::GetIO()
; 470  :     IMGUI_API void*         MemAlloc(size_t sz);
; 471  :     IMGUI_API void          MemFree(void* ptr);
; 472  :     IMGUI_API const char*   GetClipboardText();
; 473  :     IMGUI_API void          SetClipboardText(const char* text);
; 474  : 
; 475  :     // Internal context access - if you want to use multiple context, share context between modules (e.g. DLL). There is a default context created and active by default.
; 476  :     // All contexts share a same ImFontAtlas by default. If you want different font atlas, you can new() them and overwrite the GetIO().Fonts variable of an ImGui context.
; 477  :     IMGUI_API const char*   GetVersion();
; 478  :     IMGUI_API ImGuiContext* CreateContext(void* (*malloc_fn)(size_t) = NULL, void (*free_fn)(void*) = NULL);
; 479  :     IMGUI_API void          DestroyContext(ImGuiContext* ctx);
; 480  :     IMGUI_API ImGuiContext* GetCurrentContext();
; 481  :     IMGUI_API void          SetCurrentContext(ImGuiContext* ctx);
; 482  : 
; 483  :     // Obsolete (will be removed)
; 484  : #ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
; 485  :     static inline bool      IsPosHoveringAnyWindow(const ImVec2& pos) { return IsAnyWindowHoveredAtPos(pos); } // OBSOLETE 1.50+
; 486  :     static inline bool      IsMouseHoveringAnyWindow() { return IsAnyWindowHovered(); }        // OBSOLETE 1.50+
; 487  :     static inline bool      IsMouseHoveringWindow() { return IsWindowHoveredRect(); }          // OBSOLETE 1.50+
; 488  :     static inline bool      CollapsingHeader(const char* label, const char* str_id, bool framed = true, bool default_open = false) { (void)str_id; (void)framed; ImGuiTreeNodeFlags default_open_flags = 1<<5; return CollapsingHeader(label, (default_open ? default_open_flags : 0)); } // OBSOLETE 1.49+
; 489  :     static inline ImFont*   GetWindowFont() { return GetFont(); }                              // OBSOLETE 1.48+
; 490  :     static inline float     GetWindowFontSize() { return GetFontSize(); }                      // OBSOLETE 1.48+
; 491  :     static inline void      SetScrollPosHere() { SetScrollHere(); }                            // OBSOLETE 1.42+
; 492  :     static inline bool      GetWindowCollapsed() { return ImGui::IsWindowCollapsed(); }        // OBSOLETE 1.39+
; 493  :     static inline bool      IsRectClipped(const ImVec2& size) { return !IsRectVisible(size); } // OBSOLETE 1.39+
; 494  : #endif
; 495  : 
; 496  : } // namespace ImGui
; 497  : 
; 498  : // Flags for ImGui::Begin()
; 499  : enum ImGuiWindowFlags_
; 500  : {
; 501  :     // Default: 0
; 502  :     ImGuiWindowFlags_NoTitleBar             = 1 << 0,   // Disable title-bar
; 503  :     ImGuiWindowFlags_NoResize               = 1 << 1,   // Disable user resizing with the lower-right grip
; 504  :     ImGuiWindowFlags_NoMove                 = 1 << 2,   // Disable user moving the window
; 505  :     ImGuiWindowFlags_NoScrollbar            = 1 << 3,   // Disable scrollbars (window can still scroll with mouse or programatically)
; 506  :     ImGuiWindowFlags_NoScrollWithMouse      = 1 << 4,   // Disable user vertically scrolling with mouse wheel
; 507  :     ImGuiWindowFlags_NoCollapse             = 1 << 5,   // Disable user collapsing window by double-clicking on it
; 508  :     ImGuiWindowFlags_AlwaysAutoResize       = 1 << 6,   // Resize every window to its content every frame
; 509  :     ImGuiWindowFlags_ShowBorders            = 1 << 7,   // Show borders around windows and items
; 510  :     ImGuiWindowFlags_NoSavedSettings        = 1 << 8,   // Never load/save settings in .ini file
; 511  :     ImGuiWindowFlags_NoInputs               = 1 << 9,   // Disable catching mouse or keyboard inputs
; 512  :     ImGuiWindowFlags_MenuBar                = 1 << 10,  // Has a menu-bar
; 513  :     ImGuiWindowFlags_HorizontalScrollbar    = 1 << 11,  // Allow horizontal scrollbar to appear (off by default). You may use SetNextWindowContentSize(ImVec2(width,0.0f)); prior to calling Begin() to specify width. Read code in imgui_demo in the "Horizontal Scrolling" section.
; 514  :     ImGuiWindowFlags_NoFocusOnAppearing     = 1 << 12,  // Disable taking focus when transitioning from hidden to visible state
; 515  :     ImGuiWindowFlags_NoBringToFrontOnFocus  = 1 << 13,  // Disable bringing window to front when taking focus (e.g. clicking on it or programatically giving it focus)
; 516  :     ImGuiWindowFlags_AlwaysVerticalScrollbar= 1 << 14,  // Always show vertical scrollbar (even if ContentSize.y < Size.y)
; 517  :     ImGuiWindowFlags_AlwaysHorizontalScrollbar=1<< 15,  // Always show horizontal scrollbar (even if ContentSize.x < Size.x)
; 518  :     ImGuiWindowFlags_AlwaysUseWindowPadding = 1 << 16,  // Ensure child windows without border uses style.WindowPadding (ignored by default for non-bordered child windows, because more convenient)
; 519  :     ImGuiWindowFlags_NoNavFocus             = 1 << 17,  // No focusing of this window with gamepad/keyboard navigation
; 520  :     ImGuiWindowFlags_NoNavInputs            = 1 << 18,  // No gamepad/keyboard navigation within the window
; 521  :     ImGuiWindowFlags_NavFlattened           = 1 << 19,  // Allow gamepad/keyboard navigation to cross over parent border to this child (only use on child that have no scrolling!)
; 522  :     // [Internal]
; 523  :     ImGuiWindowFlags_ChildWindow            = 1 << 22,  // Don't use! For internal use by BeginChild()
; 524  :     ImGuiWindowFlags_ComboBox               = 1 << 23,  // Don't use! For internal use by ComboBox()
; 525  :     ImGuiWindowFlags_Tooltip                = 1 << 24,  // Don't use! For internal use by BeginTooltip()
; 526  :     ImGuiWindowFlags_Popup                  = 1 << 25,  // Don't use! For internal use by BeginPopup()
; 527  :     ImGuiWindowFlags_Modal                  = 1 << 26,  // Don't use! For internal use by BeginPopupModal()
; 528  :     ImGuiWindowFlags_ChildMenu              = 1 << 27   // Don't use! For internal use by BeginMenu()
; 529  : };
; 530  : 
; 531  : // Flags for ImGui::InputText()
; 532  : enum ImGuiInputTextFlags_
; 533  : {
; 534  :     // Default: 0
; 535  :     ImGuiInputTextFlags_CharsDecimal        = 1 << 0,   // Allow 0123456789.+-*/
; 536  :     ImGuiInputTextFlags_CharsHexadecimal    = 1 << 1,   // Allow 0123456789ABCDEFabcdef
; 537  :     ImGuiInputTextFlags_CharsUppercase      = 1 << 2,   // Turn a..z into A..Z
; 538  :     ImGuiInputTextFlags_CharsNoBlank        = 1 << 3,   // Filter out spaces, tabs
; 539  :     ImGuiInputTextFlags_AutoSelectAll       = 1 << 4,   // Select entire text when first taking mouse focus
; 540  :     ImGuiInputTextFlags_EnterReturnsTrue    = 1 << 5,   // Return 'true' when Enter is pressed (as opposed to when the value was modified)
; 541  :     ImGuiInputTextFlags_CallbackCompletion  = 1 << 6,   // Call user function on pressing TAB (for completion handling)
; 542  :     ImGuiInputTextFlags_CallbackHistory     = 1 << 7,   // Call user function on pressing Up/Down arrows (for history handling)
; 543  :     ImGuiInputTextFlags_CallbackAlways      = 1 << 8,   // Call user function every time. User code may query cursor position, modify text buffer.
; 544  :     ImGuiInputTextFlags_CallbackCharFilter  = 1 << 9,   // Call user function to filter character. Modify data->EventChar to replace/filter input, or return 1 to discard character.
; 545  :     ImGuiInputTextFlags_AllowTabInput       = 1 << 10,  // Pressing TAB input a '\t' character into the text field
; 546  :     ImGuiInputTextFlags_CtrlEnterForNewLine = 1 << 11,  // In multi-line mode, unfocus with Enter, add new line with Ctrl+Enter (default is opposite: unfocus with Ctrl+Enter, add line with Enter).
; 547  :     ImGuiInputTextFlags_NoHorizontalScroll  = 1 << 12,  // Disable following the cursor horizontally
; 548  :     ImGuiInputTextFlags_AlwaysInsertMode    = 1 << 13,  // Insert mode
; 549  :     ImGuiInputTextFlags_ReadOnly            = 1 << 14,  // Read-only mode
; 550  :     ImGuiInputTextFlags_Password            = 1 << 15,  // Password mode, display all characters as '*'
; 551  :     // [Internal]
; 552  :     ImGuiInputTextFlags_Multiline           = 1 << 20   // For internal use by InputTextMultiline()
; 553  : };
; 554  : 
; 555  : // Flags for ImGui::TreeNodeEx(), ImGui::CollapsingHeader*()
; 556  : enum ImGuiTreeNodeFlags_
; 557  : {
; 558  :     ImGuiTreeNodeFlags_Selected             = 1 << 0,   // Draw as selected
; 559  :     ImGuiTreeNodeFlags_Framed               = 1 << 1,   // Full colored frame (e.g. for CollapsingHeader)
; 560  :     ImGuiTreeNodeFlags_AllowOverlapMode     = 1 << 2,   // Hit testing to allow subsequent widgets to overlap this one
; 561  :     ImGuiTreeNodeFlags_NoTreePushOnOpen     = 1 << 3,   // Don't do a TreePush() when open (e.g. for CollapsingHeader) = no extra indent nor pushing on ID stack
; 562  :     ImGuiTreeNodeFlags_NoAutoOpenOnLog      = 1 << 4,   // Don't automatically and temporarily open node when Logging is active (by default logging will automatically open tree nodes)
; 563  :     ImGuiTreeNodeFlags_DefaultOpen          = 1 << 5,   // Default node to be open
; 564  :     ImGuiTreeNodeFlags_OpenOnDoubleClick    = 1 << 6,   // Need double-click to open node
; 565  :     ImGuiTreeNodeFlags_OpenOnArrow          = 1 << 7,   // Only open when clicking on the arrow part. If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set, single-click arrow or double-click all box to open.
; 566  :     ImGuiTreeNodeFlags_Leaf                 = 1 << 8,   // No collapsing, no arrow (use as a convenience for leaf nodes). 
; 567  :     ImGuiTreeNodeFlags_Bullet               = 1 << 9,   // Display a bullet instead of arrow
; 568  :     //ImGuITreeNodeFlags_SpanAllAvailWidth  = 1 << 10,  // FIXME: TODO: Extend hit box horizontally even if not framed
; 569  :     //ImGuiTreeNodeFlags_NoScrollOnOpen     = 1 << 11,  // FIXME: TODO: Disable automatic scroll on TreePop() if node got just open and contents is not visible
; 570  :     ImGuiTreeNodeFlags_CollapsingHeader     = ImGuiTreeNodeFlags_Framed | ImGuiTreeNodeFlags_NoAutoOpenOnLog
; 571  : };
; 572  : 
; 573  : // Flags for ImGui::Selectable()
; 574  : enum ImGuiSelectableFlags_
; 575  : {
; 576  :     // Default: 0
; 577  :     ImGuiSelectableFlags_DontClosePopups    = 1 << 0,   // Clicking this don't close parent popup window
; 578  :     ImGuiSelectableFlags_SpanAllColumns     = 1 << 1,   // Selectable frame can span all columns (text will still fit in current column)
; 579  :     ImGuiSelectableFlags_AllowDoubleClick   = 1 << 2    // Generate press events on double clicks too
; 580  : };
; 581  : 
; 582  : // User fill ImGuiIO.KeyMap[] array with indices into the ImGuiIO.KeysDown[512] array
; 583  : enum ImGuiKey_
; 584  : {
; 585  :     ImGuiKey_Tab,       // for tabbing through fields
; 586  :     ImGuiKey_UpArrow,   // for text edit
; 587  :     ImGuiKey_DownArrow, // for text edit
; 588  :     ImGuiKey_LeftArrow, // for text edit
; 589  :     ImGuiKey_RightArrow,// for text edit
; 590  :     ImGuiKey_PageUp,
; 591  :     ImGuiKey_PageDown,
; 592  :     ImGuiKey_Home,      // for text edit
; 593  :     ImGuiKey_End,       // for text edit
; 594  :     ImGuiKey_Delete,    // for text edit
; 595  :     ImGuiKey_Backspace, // for text edit
; 596  :     ImGuiKey_Enter,     // for text edit
; 597  :     ImGuiKey_Escape,    // for text edit
; 598  :     ImGuiKey_A,         // for text edit CTRL+A: select all
; 599  :     ImGuiKey_C,         // for text edit CTRL+C: copy
; 600  :     ImGuiKey_V,         // for text edit CTRL+V: paste
; 601  :     ImGuiKey_X,         // for text edit CTRL+X: cut
; 602  :     ImGuiKey_Y,         // for text edit CTRL+Y: redo
; 603  :     ImGuiKey_Z,         // for text edit CTRL+Z: undo
; 604  :     ImGuiKey_COUNT
; 605  : };
; 606  : 
; 607  : // [BETA] Gamepad/Keyboard directional navigation
; 608  : // Fill ImGuiIO.NavInputs[] float array every frame to feed gamepad/keyboard navigation inputs.
; 609  : // 0.0f= not held. 1.0f= fully held. Pass intermediate 0.0f..1.0f values for analog triggers/sticks.
; 610  : // ImGui uses a simple >0.0f for activation testing, and won't attempt to test for a dead-zone.
; 611  : // Your code passing analog gamepad values is likely to want to transform your raw inputs, using a dead-zone and maybe a power curve.
; 612  : enum ImGuiNavInput_
; 613  : {
; 614  :     ImGuiNavInput_PadActivate,      // press button, tweak value                    // e.g. Circle button
; 615  :     ImGuiNavInput_PadCancel,        // close menu/popup/child, lose selection       // e.g. Cross button
; 616  :     ImGuiNavInput_PadInput,         // text input                                   // e.g. Triangle button
; 617  :     ImGuiNavInput_PadMenu,          // access menu, focus, move, resize             // e.g. Square button
; 618  :     ImGuiNavInput_PadUp,            // move up, resize window (with PadMenu held)   // e.g. D-pad up/down/left/right, analog
; 619  :     ImGuiNavInput_PadDown,          // move down
; 620  :     ImGuiNavInput_PadLeft,          // move left
; 621  :     ImGuiNavInput_PadRight,         // move right
; 622  :     ImGuiNavInput_PadScrollUp,      // scroll up, move window (with PadMenu held)   // e.g. right stick up/down/left/right, analog
; 623  :     ImGuiNavInput_PadScrollDown,    // "
; 624  :     ImGuiNavInput_PadScrollLeft,    //
; 625  :     ImGuiNavInput_PadScrollRight,   //
; 626  :     ImGuiNavInput_PadFocusPrev,     // next window (with PadMenu held)              // e.g. L-trigger
; 627  :     ImGuiNavInput_PadFocusNext,     // prev window (with PadMenu held)              // e.g. R-trigger
; 628  :     ImGuiNavInput_PadTweakSlow,     // slower tweaks                                // e.g. L-trigger, analog
; 629  :     ImGuiNavInput_PadTweakFast,     // faster tweaks                                // e.g. R-trigger, analog
; 630  :     ImGuiNavInput_COUNT,
; 631  : };
; 632  : 
; 633  : // Enumeration for PushStyleColor() / PopStyleColor()
; 634  : enum ImGuiCol_
; 635  : {
; 636  :     ImGuiCol_Text,
; 637  :     ImGuiCol_TextDisabled,
; 638  :     ImGuiCol_WindowBg,              // Background of normal windows
; 639  :     ImGuiCol_ChildWindowBg,         // Background of child windows
; 640  :     ImGuiCol_PopupBg,               // Background of popups, menus, tooltips windows
; 641  :     ImGuiCol_Border,
; 642  :     ImGuiCol_BorderShadow,
; 643  :     ImGuiCol_FrameBg,               // Background of checkbox, radio button, plot, slider, text input
; 644  :     ImGuiCol_FrameBgHovered,
; 645  :     ImGuiCol_FrameBgActive,
; 646  :     ImGuiCol_TitleBg,
; 647  :     ImGuiCol_TitleBgCollapsed,
; 648  :     ImGuiCol_TitleBgActive,
; 649  :     ImGuiCol_MenuBarBg,
; 650  :     ImGuiCol_ScrollbarBg,
; 651  :     ImGuiCol_ScrollbarGrab,
; 652  :     ImGuiCol_ScrollbarGrabHovered,
; 653  :     ImGuiCol_ScrollbarGrabActive,
; 654  :     ImGuiCol_ComboBg,
; 655  :     ImGuiCol_CheckMark,
; 656  :     ImGuiCol_SliderGrab,
; 657  :     ImGuiCol_SliderGrabActive,
; 658  :     ImGuiCol_Button,
; 659  :     ImGuiCol_ButtonHovered,
; 660  :     ImGuiCol_ButtonActive,
; 661  :     ImGuiCol_Header,
; 662  :     ImGuiCol_HeaderHovered,
; 663  :     ImGuiCol_HeaderActive,
; 664  :     ImGuiCol_Column,
; 665  :     ImGuiCol_ColumnHovered,
; 666  :     ImGuiCol_ColumnActive,
; 667  :     ImGuiCol_ResizeGrip,
; 668  :     ImGuiCol_ResizeGripHovered,
; 669  :     ImGuiCol_ResizeGripActive,
; 670  :     ImGuiCol_CloseButton,
; 671  :     ImGuiCol_CloseButtonHovered,
; 672  :     ImGuiCol_CloseButtonActive,
; 673  :     ImGuiCol_PlotLines,
; 674  :     ImGuiCol_PlotLinesHovered,
; 675  :     ImGuiCol_PlotHistogram,
; 676  :     ImGuiCol_PlotHistogramHovered,
; 677  :     ImGuiCol_TextSelectedBg,
; 678  :     ImGuiCol_ModalWindowDarkening,  // darken entire screen when a modal window is active
; 679  :     ImGuiCol_NavHighlight,          // gamepad/keyboard: current highlighted item 
; 680  :     ImGuiCol_NavWindowingHighlight, // gamepad/keyboard: when holding NavMenu to focus/move/resize windows
; 681  :     ImGuiCol_COUNT
; 682  : };
; 683  : 
; 684  : // Enumeration for PushStyleVar() / PopStyleVar()
; 685  : // NB: the enum only refers to fields of ImGuiStyle() which makes sense to be pushed/poped in UI code. Feel free to add others.
; 686  : enum ImGuiStyleVar_
; 687  : {
; 688  :     ImGuiStyleVar_Alpha,               // float
; 689  :     ImGuiStyleVar_WindowPadding,       // ImVec2
; 690  :     ImGuiStyleVar_WindowRounding,      // float
; 691  :     ImGuiStyleVar_WindowMinSize,       // ImVec2
; 692  :     ImGuiStyleVar_ChildWindowRounding, // float
; 693  :     ImGuiStyleVar_FramePadding,        // ImVec2
; 694  :     ImGuiStyleVar_FrameRounding,       // float
; 695  :     ImGuiStyleVar_ItemSpacing,         // ImVec2
; 696  :     ImGuiStyleVar_ItemInnerSpacing,    // ImVec2
; 697  :     ImGuiStyleVar_IndentSpacing,       // float
; 698  :     ImGuiStyleVar_GrabMinSize,         // float
; 699  :     ImGuiStyleVar_ButtonTextAlign,     // flags ImGuiAlign_*
; 700  :     ImGuiStyleVar_Count_
; 701  : };
; 702  : 
; 703  : // Enumeration for ColorEditMode()
; 704  : // FIXME-OBSOLETE: Will be replaced by future color/picker api
; 705  : enum ImGuiColorEditMode_
; 706  : {
; 707  :     ImGuiColorEditMode_UserSelect = -2,
; 708  :     ImGuiColorEditMode_UserSelectShowButton = -1,
; 709  :     ImGuiColorEditMode_RGB = 0,
; 710  :     ImGuiColorEditMode_HSV = 1,
; 711  :     ImGuiColorEditMode_HEX = 2
; 712  : };
; 713  : 
; 714  : // Enumeration for GetMouseCursor()
; 715  : enum ImGuiMouseCursor_
; 716  : {
; 717  :     ImGuiMouseCursor_None = -1,
; 718  :     ImGuiMouseCursor_Arrow = 0,
; 719  :     ImGuiMouseCursor_TextInput,         // When hovering over InputText, etc.
; 720  :     ImGuiMouseCursor_Move,              // Unused
; 721  :     ImGuiMouseCursor_ResizeNS,          // Unused
; 722  :     ImGuiMouseCursor_ResizeEW,          // When hovering over a column
; 723  :     ImGuiMouseCursor_ResizeNESW,        // Unused
; 724  :     ImGuiMouseCursor_ResizeNWSE,        // When hovering over the bottom-right corner of a window
; 725  :     ImGuiMouseCursor_Count_
; 726  : };
; 727  : 
; 728  : // Condition flags for ImGui::SetWindow***(), SetNextWindow***(), SetNextTreeNode***() functions
; 729  : // All those functions treat 0 as a shortcut to ImGuiSetCond_Always
; 730  : enum ImGuiSetCond_
; 731  : {
; 732  :     ImGuiSetCond_Always        = 1 << 0, // Set the variable
; 733  :     ImGuiSetCond_Once          = 1 << 1, // Set the variable once per runtime session (only the first call with succeed)
; 734  :     ImGuiSetCond_FirstUseEver  = 1 << 2, // Set the variable if the window has no saved data (if doesn't exist in the .ini file)
; 735  :     ImGuiSetCond_Appearing     = 1 << 3  // Set the variable if the window is appearing after being hidden/inactive (or the first time)
; 736  : };
; 737  : 
; 738  : struct ImGuiStyle
; 739  : {
; 740  :     float       Alpha;                      // Global alpha applies to everything in ImGui
; 741  :     ImVec2      WindowPadding;              // Padding within a window
; 742  :     ImVec2      WindowMinSize;              // Minimum window size
; 743  :     float       WindowRounding;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows
; 744  :     ImVec2      WindowTitleAlign;           // Alignment for title bar text. Defaults to (0.0f,0.5f) for left-aligned,vertically centered.
; 745  :     float       ChildWindowRounding;        // Radius of child window corners rounding. Set to 0.0f to have rectangular windows
; 746  :     ImVec2      FramePadding;               // Padding within a framed rectangle (used by most widgets)
; 747  :     float       FrameRounding;              // Radius of frame corners rounding. Set to 0.0f to have rectangular frame (used by most widgets).
; 748  :     ImVec2      ItemSpacing;                // Horizontal and vertical spacing between widgets/lines
; 749  :     ImVec2      ItemInnerSpacing;           // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)
; 750  :     ImVec2      TouchExtraPadding;          // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!
; 751  :     float       IndentSpacing;              // Horizontal indentation when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).
; 752  :     float       ColumnsMinSpacing;          // Minimum horizontal spacing between two columns
; 753  :     float       ScrollbarSize;              // Width of the vertical scrollbar, Height of the horizontal scrollbar
; 754  :     float       ScrollbarRounding;          // Radius of grab corners for scrollbar
; 755  :     float       GrabMinSize;                // Minimum width/height of a grab box for slider/scrollbar.
; 756  :     float       GrabRounding;               // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
; 757  :     ImVec2      ButtonTextAlign;            // Alignment of button text when button is larger than text. Defaults to (0.5f,0.5f) for horizontally+vertically centered.
; 758  :     ImVec2      DisplayWindowPadding;       // Window positions are clamped to be visible within the display area by at least this amount. Only covers regular windows.
; 759  :     ImVec2      DisplaySafeAreaPadding;     // If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups/tooltips as well regular windows.
; 760  :     bool        AntiAliasedLines;           // Enable anti-aliasing on lines/borders. Disable if you are really tight on CPU/GPU.
; 761  :     bool        AntiAliasedShapes;          // Enable anti-aliasing on filled shapes (rounded rectangles, circles, etc.)
; 762  :     float       CurveTessellationTol;       // Tessellation tolerance. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.

	lea	eax, DWORD PTR [ecx+128]

; 97   :     ImVec2() { x = y = 0.0f; }

	mov	DWORD PTR [ecx+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 790  : {

	sub	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 97   :     ImVec2() { x = y = 0.0f; }

	mov	DWORD PTR [ecx+16], 0
	mov	edx, 45					; 0000002dH
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+40], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+52], 0
	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+60], 0
	mov	DWORD PTR [ecx+56], 0
	mov	DWORD PTR [ecx+68], 0
	mov	DWORD PTR [ecx+64], 0
	mov	DWORD PTR [ecx+100], 0
	mov	DWORD PTR [ecx+96], 0
	mov	DWORD PTR [ecx+108], 0
	mov	DWORD PTR [ecx+104], 0
	push	esi
	mov	DWORD PTR [ecx+116], 0
	mov	DWORD PTR [ecx+112], 0
$LL24@ImGuiStyle:

; 108  :     ImVec4() { x = y = z = w = 0.0f; }

	mov	DWORD PTR [eax+12], 0
	lea	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [eax-8], 0
	mov	DWORD PTR [eax-12], 0
	mov	DWORD PTR [eax-16], 0
	sub	edx, 1
	jne	SHORT $LL24@ImGuiStyle

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T10[ebp], 1090519040		; 41000000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 792  :     WindowPadding           = ImVec2(8,8);      // Padding within a window

	mov	eax, DWORD PTR $T10[ebp]
	mov	DWORD PTR [ecx+4], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T10[ebp+4], 1090519040	; 41000000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 792  :     WindowPadding           = ImVec2(8,8);      // Padding within a window

	mov	eax, DWORD PTR $T10[ebp+4]
	mov	DWORD PTR [ecx+8], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T9[ebp], 1107296256		; 42000000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 793  :     WindowMinSize           = ImVec2(32,32);    // Minimum window size

	mov	eax, DWORD PTR $T9[ebp]
	mov	DWORD PTR [ecx+12], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T9[ebp+4], 1107296256	; 42000000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 793  :     WindowMinSize           = ImVec2(32,32);    // Minimum window size

	mov	eax, DWORD PTR $T9[ebp+4]
	mov	DWORD PTR [ecx+16], eax

; 795  :     WindowTitleAlign        = ImVec2(0.0f,0.5f);// Alignment for title bar text

	mov	eax, edx
	mov	DWORD PTR [ecx+24], eax
	movaps	xmm0, XMMWORD PTR __xmm@3f8000003f6666663f6666663f666666
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T8[ebp+4], 1056964608	; 3f000000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 795  :     WindowTitleAlign        = ImVec2(0.0f,0.5f);// Alignment for title bar text

	mov	eax, DWORD PTR $T8[ebp+4]
	mov	DWORD PTR [ecx+28], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T8[ebp], edx
	mov	DWORD PTR $T7[ebp], 1082130432		; 40800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 797  :     FramePadding            = ImVec2(4,3);      // Padding within a framed rectangle (used by most widgets)

	mov	eax, DWORD PTR $T7[ebp]
	mov	DWORD PTR [ecx+36], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T7[ebp+4], 1077936128	; 40400000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 797  :     FramePadding            = ImVec2(4,3);      // Padding within a framed rectangle (used by most widgets)

	mov	eax, DWORD PTR $T7[ebp+4]
	mov	DWORD PTR [ecx+40], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T6[ebp], 1090519040		; 41000000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 799  :     ItemSpacing             = ImVec2(8,4);      // Horizontal and vertical spacing between widgets/lines

	mov	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR [ecx+48], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T6[ebp+4], 1082130432	; 40800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 799  :     ItemSpacing             = ImVec2(8,4);      // Horizontal and vertical spacing between widgets/lines

	mov	eax, DWORD PTR $T6[ebp+4]
	mov	DWORD PTR [ecx+52], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T5[ebp], 1082130432		; 40800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 800  :     ItemInnerSpacing        = ImVec2(4,4);      // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)

	mov	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR [ecx+56], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T5[ebp+4], 1082130432	; 40800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 800  :     ItemInnerSpacing        = ImVec2(4,4);      // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)

	mov	eax, DWORD PTR $T5[ebp+4]
	mov	DWORD PTR [ecx+60], eax

; 801  :     TouchExtraPadding       = ImVec2(0,0);      // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!

	mov	eax, edx
	mov	DWORD PTR [ecx+64], eax
	mov	DWORD PTR [ecx+68], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T4[ebp], edx
	mov	DWORD PTR $T3[ebp], 1056964608		; 3f000000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 808  :     ButtonTextAlign         = ImVec2(0.5f,0.5f);// Alignment of button text when button is larger than text.

	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR [ecx+96], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T4[ebp+4], edx
	mov	DWORD PTR $T3[ebp+4], 1056964608	; 3f000000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 808  :     ButtonTextAlign         = ImVec2(0.5f,0.5f);// Alignment of button text when button is larger than text.

	mov	eax, DWORD PTR $T3[ebp+4]
	mov	DWORD PTR [ecx+100], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T2[ebp], 1102053376		; 41b00000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 809  :     DisplayWindowPadding    = ImVec2(22,22);    // Window positions are clamped to be visible within the display area by at least this amount. Only covers regular windows.

	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR [ecx+104], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T2[ebp+4], 1102053376	; 41b00000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 809  :     DisplayWindowPadding    = ImVec2(22,22);    // Window positions are clamped to be visible within the display area by at least this amount. Only covers regular windows.

	mov	eax, DWORD PTR $T2[ebp+4]
	mov	DWORD PTR [ecx+108], eax
	mov	DWORD PTR [ecx], 1065353216		; 3f800000H
	mov	DWORD PTR [ecx+20], 1091567616		; 41100000H
	mov	DWORD PTR [ecx+32], edx
	mov	DWORD PTR [ecx+44], edx
	mov	DWORD PTR [ecx+72], 1101529088		; 41a80000H
	mov	DWORD PTR [ecx+76], 1086324736		; 40c00000H
	mov	DWORD PTR [ecx+80], 1098907648		; 41800000H
	mov	DWORD PTR [ecx+84], 1091567616		; 41100000H
	mov	DWORD PTR [ecx+88], 1092616192		; 41200000H
	mov	DWORD PTR [ecx+92], edx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp], 1082130432		; 40800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 810  :     DisplaySafeAreaPadding  = ImVec2(4,4);      // If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups/tooltips as well regular windows.

	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR [ecx+112], eax

; 811  :     AntiAliasedLines        = true;             // Enable anti-aliasing on lines/borders. Disable if you are really short on CPU/GPU.

	mov	WORD PTR [ecx+120], 257			; 00000101H

; 812  :     AntiAliasedShapes       = true;             // Enable anti-aliasing on filled shapes (rounded rectangles, circles, etc.)
; 813  :     CurveTessellationTol    = 1.25f;            // Tessellation tolerance. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.

	mov	DWORD PTR [ecx+124], 1067450368		; 3fa00000H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp+4], 1082130432	; 40800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 810  :     DisplaySafeAreaPadding  = ImVec2(4,4);      // If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups/tooltips as well regular windows.

	mov	eax, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR [ecx+116], eax

; 814  : 
; 815  :     Colors[ImGuiCol_Text]                   = ImVec4(0.90f, 0.90f, 0.90f, 1.00f);

	movups	XMMWORD PTR [ecx+128], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3f8000003f19999a3f19999a3f19999a

; 816  :     Colors[ImGuiCol_TextDisabled]           = ImVec4(0.60f, 0.60f, 0.60f, 1.00f);

	movups	XMMWORD PTR [ecx+144], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3f333333000000000000000000000000

; 817  :     Colors[ImGuiCol_WindowBg]               = ImVec4(0.00f, 0.00f, 0.00f, 0.70f);

	movups	XMMWORD PTR [ecx+160], xmm0
	xorps	xmm0, xmm0

; 818  :     Colors[ImGuiCol_ChildWindowBg]          = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);

	movups	XMMWORD PTR [ecx+176], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3f6666663dcccccd3d4ccccd3d4ccccd

; 819  :     Colors[ImGuiCol_PopupBg]                = ImVec4(0.05f, 0.05f, 0.10f, 0.90f);

	movups	XMMWORD PTR [ecx+192], xmm0

; 820  :     Colors[ImGuiCol_Border]                 = ImVec4(0.70f, 0.70f, 0.70f, 0.65f);
; 821  :     Colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
; 822  :     Colors[ImGuiCol_FrameBg]                = ImVec4(0.80f, 0.80f, 0.80f, 0.30f);   // Background of checkbox, radio button, plot, slider, text input
; 823  :     Colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.90f, 0.80f, 0.80f, 0.40f);
; 824  :     Colors[ImGuiCol_FrameBgActive]          = ImVec4(0.90f, 0.65f, 0.65f, 0.45f);
; 825  :     Colors[ImGuiCol_TitleBg]                = ImVec4(0.24f, 0.24f, 0.50f, 0.83f);
; 826  :     Colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(0.40f, 0.40f, 0.80f, 0.20f);
; 827  :     Colors[ImGuiCol_TitleBgActive]          = ImVec4(0.33f, 0.33f, 0.65f, 0.87f);
; 828  :     Colors[ImGuiCol_MenuBarBg]              = ImVec4(0.40f, 0.40f, 0.55f, 0.80f);
; 829  :     Colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.20f, 0.25f, 0.30f, 0.60f);
; 830  :     Colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.40f, 0.40f, 0.80f, 0.30f);
; 831  :     Colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.40f, 0.40f, 0.80f, 0.40f);
; 832  :     Colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.80f, 0.50f, 0.50f, 0.40f);
; 833  :     Colors[ImGuiCol_ComboBg]                = ImVec4(0.20f, 0.20f, 0.20f, 0.99f);
; 834  :     Colors[ImGuiCol_CheckMark]              = ImVec4(0.90f, 0.90f, 0.90f, 0.50f);
; 835  :     Colors[ImGuiCol_SliderGrab]             = ImVec4(1.00f, 1.00f, 1.00f, 0.30f);
; 836  :     Colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.80f, 0.50f, 0.50f, 1.00f);
; 837  :     Colors[ImGuiCol_Button]                 = ImVec4(0.67f, 0.40f, 0.40f, 0.60f);
; 838  :     Colors[ImGuiCol_ButtonHovered]          = ImVec4(0.67f, 0.40f, 0.40f, 1.00f);
; 839  :     Colors[ImGuiCol_ButtonActive]           = ImVec4(0.80f, 0.50f, 0.50f, 1.00f);
; 840  :     Colors[ImGuiCol_Header]                 = ImVec4(0.40f, 0.40f, 0.90f, 0.45f);
; 841  :     Colors[ImGuiCol_HeaderHovered]          = ImVec4(0.45f, 0.45f, 0.90f, 0.80f);
; 842  :     Colors[ImGuiCol_HeaderActive]           = ImVec4(0.53f, 0.53f, 0.87f, 0.80f);
; 843  :     Colors[ImGuiCol_Column]                 = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);
; 844  :     Colors[ImGuiCol_ColumnHovered]          = ImVec4(0.70f, 0.60f, 0.60f, 1.00f);
; 845  :     Colors[ImGuiCol_ColumnActive]           = ImVec4(0.90f, 0.70f, 0.70f, 1.00f);
; 846  :     Colors[ImGuiCol_ResizeGrip]             = ImVec4(1.00f, 1.00f, 1.00f, 0.30f);
; 847  :     Colors[ImGuiCol_ResizeGripHovered]      = ImVec4(1.00f, 1.00f, 1.00f, 0.60f);
; 848  :     Colors[ImGuiCol_ResizeGripActive]       = ImVec4(1.00f, 1.00f, 1.00f, 0.90f);
; 849  :     Colors[ImGuiCol_CloseButton]            = ImVec4(0.50f, 0.50f, 0.90f, 0.50f);
; 850  :     Colors[ImGuiCol_CloseButtonHovered]     = ImVec4(0.70f, 0.70f, 0.90f, 0.60f);
; 851  :     Colors[ImGuiCol_CloseButtonActive]      = ImVec4(0.70f, 0.70f, 0.70f, 1.00f);
; 852  :     Colors[ImGuiCol_PlotLines]              = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
; 853  :     Colors[ImGuiCol_PlotLinesHovered]       = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
; 854  :     Colors[ImGuiCol_PlotHistogram]          = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
; 855  :     Colors[ImGuiCol_PlotHistogramHovered]   = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);
; 856  :     Colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.00f, 0.00f, 1.00f, 0.35f);
; 857  :     Colors[ImGuiCol_ModalWindowDarkening]   = ImVec4(0.20f, 0.20f, 0.20f, 0.35f);
; 858  :     Colors[ImGuiCol_NavHighlight]           = Colors[ImGuiCol_HeaderHovered];
; 859  :     Colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(1.00f, 1.00f, 1.00f, 0.12f);
; 860  : }

	movaps	xmm0, XMMWORD PTR __xmm@3f2666663f3333333f3333333f333333
	mov	eax, ecx
	movups	XMMWORD PTR [ecx+208], xmm0
	pop	esi
	xorps	xmm0, xmm0
	movaps	xmm1, XMMWORD PTR __xmm@3f4ccccd3f6666663ee666663ee66666
	movups	XMMWORD PTR [ecx+224], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3e99999a3f4ccccd3f4ccccd3f4ccccd
	movups	XMMWORD PTR [ecx+240], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3ecccccd3f4ccccd3f4ccccd3f666666
	movups	XMMWORD PTR [ecx+256], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3ee666663f2666663f2666663f666666
	movups	XMMWORD PTR [ecx+272], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3f547ae13f0000003e75c28f3e75c28f
	movups	XMMWORD PTR [ecx+288], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3e4ccccd3f4ccccd3ecccccd3ecccccd
	movups	XMMWORD PTR [ecx+304], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3f5eb8523f2666663ea8f5c33ea8f5c3
	movups	XMMWORD PTR [ecx+320], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3f4ccccd3f0ccccd3ecccccd3ecccccd
	movups	XMMWORD PTR [ecx+336], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3f19999a3e99999a3e8000003e4ccccd
	movups	XMMWORD PTR [ecx+352], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3e99999a3f4ccccd3ecccccd3ecccccd
	movups	XMMWORD PTR [ecx+368], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3ecccccd3f4ccccd3ecccccd3ecccccd
	movups	XMMWORD PTR [ecx+384], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3ecccccd3f0000003f0000003f4ccccd
	movups	XMMWORD PTR [ecx+400], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3f7d70a43e4ccccd3e4ccccd3e4ccccd
	movups	XMMWORD PTR [ecx+416], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3f0000003f6666663f6666663f666666
	movups	XMMWORD PTR [ecx+432], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3e99999a3f8000003f8000003f800000
	movups	XMMWORD PTR [ecx+448], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3f8000003f0000003f0000003f4ccccd
	movups	XMMWORD PTR [ecx+464], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3f19999a3ecccccd3ecccccd3f2b851f
	movups	XMMWORD PTR [ecx+480], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3f8000003ecccccd3ecccccd3f2b851f
	movups	XMMWORD PTR [ecx+496], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3f8000003f0000003f0000003f4ccccd
	movups	XMMWORD PTR [ecx+512], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3ee666663f6666663ecccccd3ecccccd
	movups	XMMWORD PTR [ecx+528], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3f4ccccd3f5eb8523f07ae143f07ae14
	movups	XMMWORD PTR [ecx+560], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3f8000003f0000003f0000003f000000
	movups	XMMWORD PTR [ecx+576], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3f8000003f19999a3f19999a3f333333
	movups	XMMWORD PTR [ecx+592], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3f8000003f3333333f3333333f666666
	movups	XMMWORD PTR [ecx+608], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3e99999a3f8000003f8000003f800000
	movups	XMMWORD PTR [ecx+624], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3f19999a3f8000003f8000003f800000
	movups	XMMWORD PTR [ecx+640], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3f6666663f8000003f8000003f800000
	movups	XMMWORD PTR [ecx+656], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3f0000003f6666663f0000003f000000
	movups	XMMWORD PTR [ecx+672], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3f19999a3f6666663f3333333f333333
	movups	XMMWORD PTR [ecx+688], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3f8000003f3333333f3333333f333333
	movups	XMMWORD PTR [ecx+704], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3f8000003f8000003f8000003f800000
	movups	XMMWORD PTR [ecx+720], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3f800000000000003f3333333f666666
	movups	XMMWORD PTR [ecx+736], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3f800000000000003f3333333f666666
	movups	XMMWORD PTR [ecx+752], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3f800000000000003f19999a3f800000
	movups	XMMWORD PTR [ecx+768], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3eb333333f8000000000000000000000
	movups	XMMWORD PTR [ecx+784], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3eb333333e4ccccd3e4ccccd3e4ccccd
	movups	XMMWORD PTR [ecx+800], xmm0
	movaps	xmm0, XMMWORD PTR __xmm@3df5c28f3f8000003f8000003f800000
	movups	XMMWORD PTR [ecx+544], xmm1
	movups	XMMWORD PTR [ecx+816], xmm1
	movups	XMMWORD PTR [ecx+832], xmm0
	mov	esp, ebp
	pop	ebp
	ret	0
??0ImGuiStyle@@QAE@XZ ENDP				; ImGuiStyle::ImGuiStyle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
?SetCurrentContext@ImGui@@YAXPAUImGuiContext@@@Z PROC	; ImGui::SetCurrentContext

; 2352 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2353 : #ifdef IMGUI_SET_CURRENT_CONTEXT_FUNC
; 2354 :     IMGUI_SET_CURRENT_CONTEXT_FUNC(ctx); // For custom thread-based hackery you may want to have control over this.
; 2355 : #else
; 2356 :     GImGui = ctx;

	mov	eax, DWORD PTR _ctx$[ebp]
	mov	DWORD PTR ?GImGui@@3PAUImGuiContext@@A, eax ; GImGui

; 2357 : #endif
; 2358 : }

	pop	ebp
	ret	0
?SetCurrentContext@ImGui@@YAXPAUImGuiContext@@@Z ENDP	; ImGui::SetCurrentContext
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?GetCurrentContext@ImGui@@YAPAUImGuiContext@@XZ PROC	; ImGui::GetCurrentContext

; 2348 :     return GImGui;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 2349 : }

	ret	0
?GetCurrentContext@ImGui@@YAPAUImGuiContext@@XZ ENDP	; ImGui::GetCurrentContext
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_ctx$ = 8						; size = 4
?DestroyContext@ImGui@@YAXPAUImGuiContext@@@Z PROC	; ImGui::DestroyContext

; 2371 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 2372 :     void (*free_fn)(void*) = ctx->IO.MemFreeFn;

	mov	edi, DWORD PTR _ctx$[ebp]
	mov	ecx, edi
	mov	esi, DWORD PTR [edi+196]
	call	??1ImGuiContext@@QAE@XZ

; 2373 :     ctx->~ImGuiContext();
; 2374 :     free_fn(ctx);

	push	edi
	call	esi
	add	esp, 4

; 2375 :     if (GImGui == ctx)

	cmp	DWORD PTR ?GImGui@@3PAUImGuiContext@@A, edi ; GImGui
	pop	edi
	pop	esi
	jne	SHORT $LN2@DestroyCon

; 2376 :         SetCurrentContext(NULL);

	mov	DWORD PTR _ctx$[ebp], 0

; 2377 : }

	pop	ebp

; 2376 :         SetCurrentContext(NULL);

	jmp	?SetCurrentContext@ImGui@@YAXPAUImGuiContext@@@Z ; ImGui::SetCurrentContext
$LN2@DestroyCon:

; 2377 : }

	pop	ebp
	ret	0
?DestroyContext@ImGui@@YAXPAUImGuiContext@@@Z ENDP	; ImGui::DestroyContext
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T2 = -24						; size = 4
$T3 = -20						; size = 4
_ctx$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_malloc_fn$ = 8						; size = 4
$T4 = 11						; size = 1
_free_fn$ = 12						; size = 4
?CreateContext@ImGui@@YAPAUImGuiContext@@P6APAXI@ZP6AXPAX@Z@Z PROC ; ImGui::CreateContext

; 2361 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CreateContext@ImGui@@YAPAUImGuiContext@@P6APAXI@ZP6AXPAX@Z@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	esi
	push	edi

; 2362 :     if (!malloc_fn) malloc_fn = malloc;

	mov	edi, DWORD PTR _malloc_fn$[ebp]
	test	edi, edi

; 2363 :     ImGuiContext* ctx = (ImGuiContext*)malloc_fn(sizeof(ImGuiContext));

	push	15192					; 00003b58H
	cmove	edi, DWORD PTR __imp__malloc
	call	edi
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR _ctx$[ebp], esi

; 2364 :     IM_PLACEMENT_NEW(ctx) ImGuiContext();

	lea	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR $T2[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	esi, esi
	je	SHORT $LN4@CreateCont
	mov	ecx, esi
	call	??0ImGuiContext@@QAE@XZ			; ImGuiContext::ImGuiContext
$LN4@CreateCont:

; 2365 :     ctx->IO.MemAllocFn = malloc_fn;
; 2366 :     ctx->IO.MemFreeFn = free_fn ? free_fn : free;

	mov	eax, DWORD PTR _free_fn$[ebp]
	test	eax, eax
	mov	ecx, DWORD PTR __imp__free
	cmovne	ecx, eax
	mov	DWORD PTR [esi+192], edi
	mov	DWORD PTR [esi+196], ecx

; 2367 :     return ctx;

	mov	eax, esi

; 2368 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?CreateContext@ImGui@@YAPAUImGuiContext@@P6APAXI@ZP6AXPAX@Z@Z$0:
	mov	eax, DWORD PTR _ctx$[ebp]
	push	eax
	mov	eax, DWORD PTR $T3[ebp]
	movzx	eax, BYTE PTR [eax]
	push	eax
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXUImPlacementNewDummy@@0@Z	; operator delete
	add	esp, 12					; 0000000cH
	ret	0
__ehhandler$?CreateContext@ImGui@@YAPAUImGuiContext@@P6APAXI@ZP6AXPAX@Z@Z:
	mov	eax, OFFSET __ehfuncinfo$?CreateContext@ImGui@@YAPAUImGuiContext@@P6APAXI@ZP6AXPAX@Z@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CreateContext@ImGui@@YAPAUImGuiContext@@P6APAXI@ZP6AXPAX@Z@Z ENDP ; ImGui::CreateContext
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?GetVersion@ImGui@@YAPBDXZ PROC				; ImGui::GetVersion

; 2341 :     return IMGUI_VERSION;

	mov	eax, OFFSET $SG17169

; 2342 : }

	ret	0
?GetVersion@ImGui@@YAPBDXZ ENDP				; ImGui::GetVersion
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_text$ = 8						; size = 4
?SetClipboardText@ImGui@@YAXPBD@Z PROC			; ImGui::SetClipboardText

; 2334 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2335 :     if (GImGui->IO.SetClipboardTextFn)

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	ecx, DWORD PTR [eax+184]
	test	ecx, ecx
	je	SHORT $LN2@SetClipboa

; 2336 :         GImGui->IO.SetClipboardTextFn(GImGui->IO.ClipboardUserData, text);

	push	DWORD PTR _text$[ebp]
	push	DWORD PTR [eax+188]
	call	ecx
	add	esp, 8
$LN2@SetClipboa:

; 2337 : }

	pop	ebp
	ret	0
?SetClipboardText@ImGui@@YAXPBD@Z ENDP			; ImGui::SetClipboardText
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?GetClipboardText@ImGui@@YAPBDXZ PROC			; ImGui::GetClipboardText

; 2330 :     return GImGui->IO.GetClipboardTextFn ? GImGui->IO.GetClipboardTextFn(GImGui->IO.ClipboardUserData) : "";

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	ecx, DWORD PTR [eax+180]
	test	ecx, ecx
	je	SHORT $LN3@GetClipboa
	push	DWORD PTR [eax+188]
	call	ecx
	add	esp, 4

; 2331 : }

	ret	0
$LN3@GetClipboa:

; 2330 :     return GImGui->IO.GetClipboardTextFn ? GImGui->IO.GetClipboardTextFn(GImGui->IO.ClipboardUserData) : "";

	mov	eax, OFFSET $SG17162

; 2331 : }

	ret	0
?GetClipboardText@ImGui@@YAPBDXZ ENDP			; ImGui::GetClipboardText
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
?MemFree@ImGui@@YAXPAX@Z PROC				; ImGui::MemFree

; 2323 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2324 :     if (ptr) GImGui->IO.MetricsAllocs--;

	mov	ecx, DWORD PTR _ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@MemFree
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	dec	DWORD PTR [eax+856]
$LN2@MemFree:

; 2325 :     return GImGui->IO.MemFreeFn(ptr);

	mov	DWORD PTR _ptr$[ebp], ecx
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [eax+196]

; 2326 : }

	pop	ebp

; 2325 :     return GImGui->IO.MemFreeFn(ptr);

	jmp	eax
?MemFree@ImGui@@YAXPAX@Z ENDP				; ImGui::MemFree
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_sz$ = 8						; size = 4
?MemAlloc@ImGui@@YAPAXI@Z PROC				; ImGui::MemAlloc

; 2317 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2318 :     GImGui->IO.MetricsAllocs++;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	inc	DWORD PTR [eax+856]

; 2319 :     return GImGui->IO.MemAllocFn(sz);

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [eax+192]

; 2320 : }

	pop	ebp

; 2319 :     return GImGui->IO.MemAllocFn(sz);

	jmp	eax
?MemAlloc@ImGui@@YAPAXI@Z ENDP				; ImGui::MemAlloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_delta$1$sroa$86$ = -8					; size = 4
tv168 = -4						; size = 4
tv160 = -4						; size = 4
_delta$1$sroa$81$ = -4					; size = 4
_stick_no$ = 8						; size = 4
_lock_threshold$ = 12					; size = 4
?IsNavDragging@ImGui@@YA_NHM@Z PROC			; ImGui::IsNavDragging

; 4027 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 4028 :     IM_ASSERT(ImGuiNavInput_PadScrollUp == ImGuiNavInput_PadUp + 4);
; 4029 :     IM_ASSERT(stick_no >= 0 && stick_no < 2);
; 4030 : 
; 4031 :     ImGuiContext& g = *GImGui;
; 4032 : 
; 4033 :     if (g.NavWindowingTarget != nullptr)

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	sub	esp, 8
	cmp	DWORD PTR [eax+6432], 0
	je	SHORT $LN4@IsNavDragg

; 4034 :     {
; 4035 :       ImVec2 delta;
; 4036 :       delta.x = GetNavInputAmount(ImGuiNavInput_PadRight + stick_no*4, ImGuiNavReadMode_Down) - GetNavInputAmount(ImGuiNavInput_PadLeft + stick_no*4, ImGuiNavReadMode_Down); 

	push	esi
	mov	esi, DWORD PTR _stick_no$[ebp]
	push	0
	lea	eax, DWORD PTR [esi*4+7]
	push	eax
	call	?GetNavInputAmount@@YAMHW4ImGuiNavReadMode@@@Z ; GetNavInputAmount
	lea	eax, DWORD PTR [esi*4+6]
	push	0
	fstp	DWORD PTR tv160[ebp]
	push	eax
	call	?GetNavInputAmount@@YAMHW4ImGuiNavReadMode@@@Z ; GetNavInputAmount
	fsubr	DWORD PTR tv160[ebp]

; 4037 :       delta.y = GetNavInputAmount(ImGuiNavInput_PadDown  + stick_no*4, ImGuiNavReadMode_Down) - GetNavInputAmount(ImGuiNavInput_PadUp   + stick_no*4, ImGuiNavReadMode_Down); 

	lea	eax, DWORD PTR [esi*4+5]
	push	0
	push	eax
	fstp	DWORD PTR _delta$1$sroa$86$[ebp]
	call	?GetNavInputAmount@@YAMHW4ImGuiNavReadMode@@@Z ; GetNavInputAmount
	lea	eax, DWORD PTR [esi*4+4]
	push	0
	fstp	DWORD PTR tv168[ebp]
	push	eax
	call	?GetNavInputAmount@@YAMHW4ImGuiNavReadMode@@@Z ; GetNavInputAmount

; 4038 : 
; 4039 :       if (lock_threshold < 0.0f)
; 4040 :         lock_threshold = g.IO.MouseDragThreshold;
; 4041 :       if (delta.x != 0.0 || delta.y != 0.0)// >= lock_threshold * lock_threshold)

	movss	xmm0, DWORD PTR _delta$1$sroa$86$[ebp]
	add	esp, 32					; 00000020H
	fsubr	DWORD PTR tv168[ebp]
	pop	esi
	xorps	xmm1, xmm1
	ucomiss	xmm0, xmm1
	fstp	DWORD PTR _delta$1$sroa$81$[ebp]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN5@IsNavDragg
	movss	xmm0, DWORD PTR _delta$1$sroa$81$[ebp]
	ucomiss	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN4@IsNavDragg
$LN5@IsNavDragg:

; 4042 :         return true;

	mov	al, 1

; 4046 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@IsNavDragg:

; 4043 :     }
; 4044 : 
; 4045 :     return false;

	xor	al, al

; 4046 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsNavDragging@ImGui@@YA_NHM@Z ENDP			; ImGui::IsNavDragging
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_capture$ = 8						; size = 1
?CaptureMouseFromApp@ImGui@@YAX_N@Z PROC		; ImGui::CaptureMouseFromApp

; 4098 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 4099 :     GImGui->CaptureMouseNextFrame = capture ? 1 : 0;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	movzx	ecx, BYTE PTR _capture$[ebp]
	mov	DWORD PTR [eax+12108], ecx

; 4100 : }

	pop	ebp
	ret	0
?CaptureMouseFromApp@ImGui@@YAX_N@Z ENDP		; ImGui::CaptureMouseFromApp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_capture$ = 8						; size = 1
?CaptureKeyboardFromApp@ImGui@@YAX_N@Z PROC		; ImGui::CaptureKeyboardFromApp

; 4093 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 4094 :     GImGui->CaptureKeyboardNextFrame = capture ? 1 : 0;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	movzx	ecx, BYTE PTR _capture$[ebp]
	mov	DWORD PTR [eax+12112], ecx

; 4095 : }

	pop	ebp
	ret	0
?CaptureKeyboardFromApp@ImGui@@YAX_N@Z ENDP		; ImGui::CaptureKeyboardFromApp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_cursor_type$ = 8					; size = 4
?SetMouseCursor@ImGui@@YAXH@Z PROC			; ImGui::SetMouseCursor

; 4088 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 4089 :     GImGui->MouseCursor = cursor_type;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	ecx, DWORD PTR _cursor_type$[ebp]
	mov	DWORD PTR [eax+6764], ecx

; 4090 : }

	pop	ebp
	ret	0
?SetMouseCursor@ImGui@@YAXH@Z ENDP			; ImGui::SetMouseCursor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?GetMouseCursor@ImGui@@YAHXZ PROC			; ImGui::GetMouseCursor

; 4084 :     return GImGui->MouseCursor;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [eax+6764]

; 4085 : }

	ret	0
?GetMouseCursor@ImGui@@YAHXZ ENDP			; ImGui::GetMouseCursor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_button$ = 8						; size = 4
?ResetMouseDragDelta@ImGui@@YAXH@Z PROC			; ImGui::ResetMouseDragDelta

; 4075 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 4076 :     ImGuiContext& g = *GImGui;

	mov	edx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 4077 :     IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
; 4078 :     // NB: We don't need to reset g.IO.MouseDragMaxDistanceSqr
; 4079 :     g.IO.MouseClickedPos[button] = g.IO.MousePos;

	mov	ecx, DWORD PTR _button$[ebp]
	mov	eax, DWORD PTR [edx+208]
	mov	DWORD PTR [edx+ecx*8+896], eax
	mov	eax, DWORD PTR [edx+212]
	mov	DWORD PTR [edx+ecx*8+900], eax

; 4080 : }

	pop	ebp
	ret	0
?ResetMouseDragDelta@ImGui@@YAXH@Z ENDP			; ImGui::ResetMouseDragDelta
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_button$ = 12						; size = 4
_lock_threshold$ = 16					; size = 4
?GetMouseDragDelta@ImGui@@YA?AUImVec2@@HM@Z PROC	; ImGui::GetMouseDragDelta

; 4063 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 4064 :     ImGuiContext& g = *GImGui;
; 4065 :     IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
; 4066 :     if (lock_threshold < 0.0f)

	movss	xmm1, DWORD PTR _lock_threshold$[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, xmm1
	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	jbe	SHORT $LN2@GetMouseDr

; 4067 :         lock_threshold = g.IO.MouseDragThreshold;

	movss	xmm1, DWORD PTR [ecx+36]
$LN2@GetMouseDr:

; 4068 :     if (g.IO.MouseDown[button])

	mov	edx, DWORD PTR _button$[ebp]
	cmp	BYTE PTR [ecx+edx+216], 0
	je	SHORT $LN4@GetMouseDr

; 4069 :         if (g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold)

	movss	xmm0, DWORD PTR [ecx+edx*4+1012]
	mulss	xmm1, xmm1
	comiss	xmm0, xmm1
	jb	SHORT $LN4@GetMouseDr
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [ecx+208]
	subss	xmm0, DWORD PTR [ecx+edx*8+896]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	movss	DWORD PTR [eax], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [ecx+212]
	subss	xmm0, DWORD PTR [ecx+edx*8+900]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4072 : }

	pop	ebp
	ret	0
$LN4@GetMouseDr:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4072 : }

	pop	ebp
	ret	0
?GetMouseDragDelta@ImGui@@YA?AUImVec2@@HM@Z ENDP	; ImGui::GetMouseDragDelta
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetMousePosOnOpeningCurrentPopup@ImGui@@YA?AUImVec2@@XZ PROC ; ImGui::GetMousePosOnOpeningCurrentPopup

; 4055 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 4056 :     ImGuiContext& g = *GImGui;

	mov	edx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 4057 :     if (g.CurrentPopupStack.Size > 0)
; 4058 :         return g.OpenPopupStack[g.CurrentPopupStack.Size-1].MousePosOnOpen;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	esi
	mov	esi, DWORD PTR [edx+6368]
	test	esi, esi
	jle	SHORT $LN2@GetMousePo
	mov	edx, DWORD PTR [edx+6364]
	shl	esi, 5
	mov	ecx, DWORD PTR [edx+esi-8]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+esi-4]

; 4059 :     return g.IO.MousePos;

	mov	DWORD PTR [eax+4], ecx
	pop	esi

; 4060 : }

	pop	ebp
	ret	0
$LN2@GetMousePo:

; 4059 :     return g.IO.MousePos;

	mov	ecx, DWORD PTR [edx+208]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+212]
	mov	DWORD PTR [eax+4], ecx
	pop	esi

; 4060 : }

	pop	ebp
	ret	0
?GetMousePosOnOpeningCurrentPopup@ImGui@@YA?AUImVec2@@XZ ENDP ; ImGui::GetMousePosOnOpeningCurrentPopup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetMousePos@ImGui@@YA?AUImVec2@@XZ PROC		; ImGui::GetMousePos

; 4049 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 4050 :     return GImGui->IO.MousePos;

	mov	edx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [edx+208]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+212]
	mov	DWORD PTR [eax+4], ecx

; 4051 : }

	pop	ebp
	ret	0
?GetMousePos@ImGui@@YA?AUImVec2@@XZ ENDP		; ImGui::GetMousePos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_rect_clipped$ = -16					; size = 16
_r_min$ = 8						; size = 4
_r_max$ = 12						; size = 4
_clip$ = 16						; size = 1
?IsMouseHoveringRect@ImGui@@YA_NABUImVec2@@0_N@Z PROC	; ImGui::IsMouseHoveringRect

; 3883 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 3889 :     if (clip)

	cmp	BYTE PTR _clip$[ebp], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	ecx, DWORD PTR _r_min$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3884 :     ImGuiContext& g = *GImGui;

	mov	edx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _rect_clipped$[ebp], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _r_max$[ebp]
	mov	DWORD PTR _rect_clipped$[ebp+4], eax
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _rect_clipped$[ebp+8], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _rect_clipped$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3889 :     if (clip)

	je	SHORT $LN48@IsMouseHov

; 3890 :         window->ClipRect.Clip(rect_clipped);

	mov	eax, DWORD PTR [edx+6240]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	movss	xmm0, DWORD PTR _rect_clipped$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3890 :         window->ClipRect.Clip(rect_clipped);

	add	eax, 472				; 000001d8H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 260  :     void        Clip(ImRect& r) const           { r.Min.x = ImClamp(r.Min.x, Min.x, Max.x); r.Min.y = ImClamp(r.Min.y, Min.y, Max.y); r.Max.x = ImClamp(r.Max.x, Min.x, Max.x); r.Max.y = ImClamp(r.Max.y, Min.y, Max.y); }

	movss	xmm1, DWORD PTR [eax]

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm1, xmm0
	jbe	SHORT $LN14@IsMouseHov
	movaps	xmm3, xmm1
	jmp	SHORT $LN15@IsMouseHov
$LN14@IsMouseHov:
	movss	xmm3, DWORD PTR [eax+8]
	minss	xmm3, xmm0
$LN15@IsMouseHov:

; 260  :     void        Clip(ImRect& r) const           { r.Min.x = ImClamp(r.Min.x, Min.x, Max.x); r.Min.y = ImClamp(r.Min.y, Min.y, Max.y); r.Max.x = ImClamp(r.Max.x, Min.x, Max.x); r.Max.y = ImClamp(r.Max.y, Min.y, Max.y); }

	movss	xmm0, DWORD PTR [eax+4]

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	movss	xmm4, DWORD PTR _rect_clipped$[ebp+4]
	comiss	xmm0, xmm4
	jbe	SHORT $LN20@IsMouseHov
	movaps	xmm2, xmm0
	jmp	SHORT $LN21@IsMouseHov
$LN20@IsMouseHov:
	movss	xmm2, DWORD PTR [eax+12]
	minss	xmm2, xmm4
$LN21@IsMouseHov:
	movss	xmm4, DWORD PTR _rect_clipped$[ebp+8]
	comiss	xmm1, xmm4
	ja	SHORT $LN27@IsMouseHov
	movss	xmm1, DWORD PTR [eax+8]
	minss	xmm1, xmm4
$LN27@IsMouseHov:
	movss	xmm4, DWORD PTR _rect_clipped$[ebp+12]
	comiss	xmm0, xmm4
	ja	SHORT $LN33@IsMouseHov
	movss	xmm0, DWORD PTR [eax+12]
	minss	xmm0, xmm4
	jmp	SHORT $LN33@IsMouseHov
$LN48@IsMouseHov:
	movss	xmm0, DWORD PTR _rect_clipped$[ebp+12]
	movss	xmm1, DWORD PTR _rect_clipped$[ebp+8]
	movss	xmm2, DWORD PTR _rect_clipped$[ebp+4]
	movss	xmm3, DWORD PTR _rect_clipped$[ebp]
$LN33@IsMouseHov:

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm3, DWORD PTR [edx+5384]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm4, DWORD PTR [edx+5384]

; 252  :     bool        Contains(const ImVec2& p) const { return p.x >= Min.x     && p.y >= Min.y     && p.x < Max.x     && p.y < Max.y; }

	movss	xmm5, DWORD PTR [edx+208]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm4, xmm1
	movss	xmm1, DWORD PTR [edx+5388]

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm2, DWORD PTR [edx+5388]

; 252  :     bool        Contains(const ImVec2& p) const { return p.x >= Min.x     && p.y >= Min.y     && p.x < Max.x     && p.y < Max.y; }

	comiss	xmm5, xmm3

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm1, xmm0

; 252  :     bool        Contains(const ImVec2& p) const { return p.x >= Min.x     && p.y >= Min.y     && p.x < Max.x     && p.y < Max.y; }

	jb	SHORT $LN46@IsMouseHov
	movss	xmm0, DWORD PTR [edx+212]
	comiss	xmm0, xmm2
	jb	SHORT $LN46@IsMouseHov
	comiss	xmm4, xmm5
	jbe	SHORT $LN46@IsMouseHov
	comiss	xmm1, xmm0
	jbe	SHORT $LN46@IsMouseHov
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3894 :     return rect_for_touch.Contains(g.IO.MousePos);

	mov	al, 1

; 3895 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN46@IsMouseHov:

; 3894 :     return rect_for_touch.Contains(g.IO.MousePos);

	xor	al, al

; 3895 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsMouseHoveringRect@ImGui@@YA_NABUImVec2@@0_N@Z ENDP	; ImGui::IsMouseHoveringRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_button$ = 8						; size = 4
_lock_threshold$ = 12					; size = 4
?IsMouseDragging@ImGui@@YA_NHM@Z PROC			; ImGui::IsMouseDragging

; 4014 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 4015 :     ImGuiContext& g = *GImGui;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 4016 :     IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
; 4017 :     if (!g.IO.MouseDown[button])

	mov	ecx, DWORD PTR _button$[ebp]
	cmp	BYTE PTR [eax+ecx+216], 0
	jne	SHORT $LN2@IsMouseDra

; 4018 :         return false;

	xor	al, al

; 4022 : }

	pop	ebp
	ret	0
$LN2@IsMouseDra:

; 4019 :     if (lock_threshold < 0.0f)

	movss	xmm1, DWORD PTR _lock_threshold$[ebp]
	xorps	xmm0, xmm0
	comiss	xmm0, xmm1
	jbe	SHORT $LN3@IsMouseDra

; 4020 :         lock_threshold = g.IO.MouseDragThreshold;

	movss	xmm1, DWORD PTR [eax+36]
$LN3@IsMouseDra:

; 4021 :     return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold;

	movss	xmm0, DWORD PTR [eax+ecx*4+1012]
	xor	eax, eax
	mulss	xmm1, xmm1
	comiss	xmm0, xmm1
	setae	al

; 4022 : }

	pop	ebp
	ret	0
?IsMouseDragging@ImGui@@YA_NHM@Z ENDP			; ImGui::IsMouseDragging
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_button$ = 8						; size = 4
?IsMouseReleased@ImGui@@YA_NH@Z PROC			; ImGui::IsMouseReleased

; 4000 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 4001 :     ImGuiContext& g = *GImGui;
; 4002 :     IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
; 4003 :     return g.IO.MouseReleased[button];

	mov	ecx, DWORD PTR _button$[ebp]
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	al, BYTE PTR [eax+ecx+961]

; 4004 : }

	pop	ebp
	ret	0
?IsMouseReleased@ImGui@@YA_NH@Z ENDP			; ImGui::IsMouseReleased
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_button$ = 8						; size = 4
?IsMouseDoubleClicked@ImGui@@YA_NH@Z PROC		; ImGui::IsMouseDoubleClicked

; 4007 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 4008 :     ImGuiContext& g = *GImGui;
; 4009 :     IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
; 4010 :     return g.IO.MouseDoubleClicked[button];

	mov	ecx, DWORD PTR _button$[ebp]
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	al, BYTE PTR [eax+ecx+956]

; 4011 : }

	pop	ebp
	ret	0
?IsMouseDoubleClicked@ImGui@@YA_NH@Z ENDP		; ImGui::IsMouseDoubleClicked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
tv175 = -12						; size = 4
tv179 = -8						; size = 4
tv170 = -8						; size = 4
_rate$2$ = -4						; size = 4
tv138 = 8						; size = 4
_rate$1 = 8						; size = 4
_button$ = 8						; size = 4
_repeat$ = 12						; size = 1
?IsMouseClicked@ImGui@@YA_NH_N@Z PROC			; ImGui::IsMouseClicked

; 3982 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 3983 :     ImGuiContext& g = *GImGui;
; 3984 :     IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
; 3985 :     const float t = g.IO.MouseDownDuration[button];

	mov	eax, DWORD PTR _button$[ebp]
	sub	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	movss	xmm1, DWORD PTR [ecx+eax*4+972]

; 3986 :     if (t == 0.0f)

	ucomiss	xmm1, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@IsMouseCli
$LN10@IsMouseCli:

; 3987 :         return true;

	mov	al, 1

; 3997 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@IsMouseCli:

; 3988 : 
; 3989 :     if (repeat && t > g.IO.KeyRepeatDelay)

	cmp	BYTE PTR _repeat$[ebp], 0
	je	SHORT $LN4@IsMouseCli
	movss	xmm2, DWORD PTR [ecx+116]
	comiss	xmm1, xmm2
	jbe	SHORT $LN4@IsMouseCli

; 3990 :     {
; 3991 :         float delay = g.IO.KeyRepeatDelay, rate = g.IO.KeyRepeatRate;

	movss	xmm0, DWORD PTR [ecx+120]

; 3992 :         if ((fmodf(t - delay, rate) > rate*0.5f) != (fmodf(t - delay - g.IO.DeltaTime, rate) > rate*0.5f))

	subss	xmm1, xmm2
	movss	DWORD PTR _rate$1[ebp], xmm0
	mulss	xmm0, DWORD PTR __real@3f000000
	push	ebx
	movss	DWORD PTR tv175[ebp], xmm1
	subss	xmm1, DWORD PTR [ecx+12]
	movss	DWORD PTR _rate$2$[ebp], xmm0
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 677  :         return (float)fmod(_X, _Y);

	movss	DWORD PTR tv179[ebp], xmm1
	fld	DWORD PTR tv179[ebp]
	fld	DWORD PTR _rate$1[ebp]
	call	__CIfmod
	fstp	DWORD PTR tv170[ebp]
	movss	xmm0, DWORD PTR tv170[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3992 :         if ((fmodf(t - delay, rate) > rate*0.5f) != (fmodf(t - delay - g.IO.DeltaTime, rate) > rate*0.5f))

	xor	ebx, ebx
	comiss	xmm0, DWORD PTR _rate$2$[ebp]
	fld	DWORD PTR tv175[ebp]
	fld	DWORD PTR _rate$1[ebp]
	seta	bl
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 677  :         return (float)fmod(_X, _Y);

	call	__CIfmod
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3992 :         if ((fmodf(t - delay, rate) > rate*0.5f) != (fmodf(t - delay - g.IO.DeltaTime, rate) > rate*0.5f))

	fstp	DWORD PTR tv138[ebp]
	movss	xmm0, DWORD PTR tv138[ebp]
	xor	eax, eax
	comiss	xmm0, DWORD PTR _rate$2$[ebp]
	seta	al
	cmp	eax, ebx
	pop	ebx
	jne	SHORT $LN10@IsMouseCli
$LN4@IsMouseCli:

; 3993 :             return true;
; 3994 :     }
; 3995 : 
; 3996 :     return false;

	xor	al, al

; 3997 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsMouseClicked@ImGui@@YA_NH_N@Z ENDP			; ImGui::IsMouseClicked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_button$ = 8						; size = 4
?IsMouseDown@ImGui@@YA_NH@Z PROC			; ImGui::IsMouseDown

; 3975 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 3976 :     ImGuiContext& g = *GImGui;
; 3977 :     IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
; 3978 :     return g.IO.MouseDown[button];

	mov	ecx, DWORD PTR _button$[ebp]
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	al, BYTE PTR [eax+ecx+216]

; 3979 : }

	pop	ebp
	ret	0
?IsMouseDown@ImGui@@YA_NH@Z ENDP			; ImGui::IsMouseDown
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_key_index$ = 8						; size = 4
_repeat_delay$ = 12					; size = 4
_repeat_rate$ = 16					; size = 4
?GetKeyPressedAmount@ImGui@@YAHHMM@Z PROC		; ImGui::GetKeyPressedAmount

; 3947 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 3948 :     ImGuiContext& g = *GImGui;
; 3949 :     if (key_index < 0) return false;

	mov	eax, DWORD PTR _key_index$[ebp]
	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	test	eax, eax
	jns	SHORT $LN2@GetKeyPres
	xor	eax, eax

; 3953 : }

	pop	ebp
	ret	0
$LN2@GetKeyPres:

; 3950 :     IM_ASSERT(key_index >= 0 && key_index < IM_ARRAYSIZE(g.IO.KeysDown));
; 3951 :     const float t = g.IO.KeysDownDuration[key_index];
; 3952 :     return CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, repeat_delay, repeat_rate);

	movss	xmm0, DWORD PTR _repeat_rate$[ebp]
	sub	esp, 16					; 00000010H
	movss	xmm1, DWORD PTR [ecx+eax*4+1032]
	movss	DWORD PTR [esp+12], xmm0
	movss	xmm0, DWORD PTR _repeat_delay$[ebp]
	movss	DWORD PTR [esp+8], xmm0
	movaps	xmm0, xmm1
	subss	xmm0, DWORD PTR [ecx+12]
	movss	DWORD PTR [esp+4], xmm0
	movss	DWORD PTR [esp], xmm1
	call	?CalcTypematicPressedRepeatAmount@ImGui@@YAHMMMM@Z ; ImGui::CalcTypematicPressedRepeatAmount
	add	esp, 16					; 00000010H

; 3953 : }

	pop	ebp
	ret	0
?GetKeyPressedAmount@ImGui@@YAHHMM@Z ENDP		; ImGui::GetKeyPressedAmount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_key_index$ = 8						; size = 4
?IsKeyReleased@ImGui@@YA_NH@Z PROC			; ImGui::IsKeyReleased

; 3965 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 3966 :     ImGuiContext& g = *GImGui;
; 3967 :     if (key_index < 0) return false;

	mov	eax, DWORD PTR _key_index$[ebp]
	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	test	eax, eax
	js	SHORT $LN3@IsKeyRelea

; 3968 :     IM_ASSERT(key_index >= 0 && key_index < IM_ARRAYSIZE(g.IO.KeysDown));
; 3969 :     if (g.IO.KeysDownDurationPrev[key_index] >= 0.0f && !g.IO.KeysDown[key_index])

	movss	xmm0, DWORD PTR [ecx+eax*4+3080]
	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN3@IsKeyRelea
	cmp	BYTE PTR [ecx+eax+233], 0
	jne	SHORT $LN3@IsKeyRelea

; 3970 :         return true;

	mov	al, 1

; 3972 : }

	pop	ebp
	ret	0
$LN3@IsKeyRelea:

; 3971 :     return false;

	xor	al, al

; 3972 : }

	pop	ebp
	ret	0
?IsKeyReleased@ImGui@@YA_NH@Z ENDP			; ImGui::IsKeyReleased
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_key_index$ = 8						; size = 4
_repeat$ = 12						; size = 1
?IsKeyPressed@ImGui@@YA_NH_N@Z PROC			; ImGui::IsKeyPressed

; 3956 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 3957 :     ImGuiContext& g = *GImGui;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 3958 :     if (repeat)
; 3959 :         return GetKeyPressedAmount(key_index, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0;

	sub	esp, 8
	cmp	BYTE PTR _repeat$[ebp], 0
	je	SHORT $LN2@IsKeyPress
	movss	xmm0, DWORD PTR [eax+120]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR [eax+116]
	movss	DWORD PTR [esp], xmm0

; 3960 :     else
; 3961 :         return GetKeyPressedAmount(key_index, 0.0f, 0.0f) > 0;

	push	DWORD PTR _key_index$[ebp]
	call	?GetKeyPressedAmount@ImGui@@YAHHMM@Z	; ImGui::GetKeyPressedAmount
	add	esp, 12					; 0000000cH
	test	eax, eax
	setg	al

; 3962 : }

	pop	ebp
	ret	0
$LN2@IsKeyPress:

; 3960 :     else
; 3961 :         return GetKeyPressedAmount(key_index, 0.0f, 0.0f) > 0;

	mov	DWORD PTR [esp+4], 0
	mov	DWORD PTR [esp], 0
	push	DWORD PTR _key_index$[ebp]
	call	?GetKeyPressedAmount@ImGui@@YAHHMM@Z	; ImGui::GetKeyPressedAmount
	add	esp, 12					; 0000000cH
	test	eax, eax
	setg	al

; 3962 : }

	pop	ebp
	ret	0
?IsKeyPressed@ImGui@@YA_NH_N@Z ENDP			; ImGui::IsKeyPressed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_key_index$ = 8						; size = 4
?IsKeyDown@ImGui@@YA_NH@Z PROC				; ImGui::IsKeyDown

; 3930 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 3931 :     if (key_index < 0) return false;

	mov	ecx, DWORD PTR _key_index$[ebp]
	test	ecx, ecx
	jns	SHORT $LN2@IsKeyDown
	xor	al, al

; 3934 : }

	pop	ebp
	ret	0
$LN2@IsKeyDown:

; 3932 :     IM_ASSERT(key_index >= 0 && key_index < IM_ARRAYSIZE(GImGui->IO.KeysDown));
; 3933 :     return GImGui->IO.KeysDown[key_index];

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	al, BYTE PTR [eax+ecx+233]

; 3934 : }

	pop	ebp
	ret	0
?IsKeyDown@ImGui@@YA_NH@Z ENDP				; ImGui::IsKeyDown
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_key$ = 8						; size = 4
?GetKeyIndex@ImGui@@YAHH@Z PROC				; ImGui::GetKeyIndex

; 3924 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 3925 :     IM_ASSERT(key >= 0 && key < ImGuiKey_COUNT);
; 3926 :     return GImGui->IO.KeyMap[key];

	mov	ecx, DWORD PTR _key$[ebp]
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [eax+ecx*4+40]

; 3927 : }

	pop	ebp
	ret	0
?GetKeyIndex@ImGui@@YAHH@Z ENDP				; ImGui::GetKeyIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
tv166 = -4						; size = 4
_h$ = 8							; size = 4
_s$ = 12						; size = 4
_v$ = 16						; size = 4
_out_r$ = 20						; size = 4
_out_g$ = 24						; size = 4
_out_b$ = 28						; size = 4
?ColorConvertHSVtoRGB@ImGui@@YAXMMMAAM00@Z PROC		; ImGui::ColorConvertHSVtoRGB

; 1327 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 1328 :     if (s == 0.0f)

	movss	xmm0, DWORD PTR _s$[ebp]
	ucomiss	xmm0, DWORD PTR __real@00000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN4@ColorConve

; 1329 :     {
; 1330 :         // gray
; 1331 :         out_r = out_g = out_b = v;

	mov	eax, DWORD PTR _out_b$[ebp]
	movss	xmm0, DWORD PTR _v$[ebp]
	movss	DWORD PTR [eax], xmm0
	mov	eax, DWORD PTR _out_g$[ebp]
	movss	DWORD PTR [eax], xmm0
	mov	eax, DWORD PTR _out_r$[ebp]
	movss	DWORD PTR [eax], xmm0

; 1350 :     }
; 1351 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@ColorConve:
	fld	DWORD PTR _h$[ebp]
	fld1
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 677  :         return (float)fmod(_X, _Y);

	call	__CIfmod
	fstp	DWORD PTR tv166[ebp]
	movss	xmm1, DWORD PTR tv166[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1335 :     h = fmodf(h, 1.0f) / (60.0f/360.0f);

	mulss	xmm1, DWORD PTR __real@40c00000

; 1336 :     int   i = (int)h;
; 1337 :     float f = h - (float)i;
; 1338 :     float p = v * (1.0f - s);

	movss	xmm6, DWORD PTR _s$[ebp]
	movss	xmm4, DWORD PTR __real@3f800000
	cvttss2si eax, xmm1
	movss	xmm3, DWORD PTR _v$[ebp]

; 1339 :     float q = v * (1.0f - s * f);

	movaps	xmm5, xmm4
	movaps	xmm2, xmm4
	subss	xmm2, xmm6
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm2, xmm3
	subss	xmm1, xmm0
	movaps	xmm0, xmm1
	mulss	xmm0, xmm6
	subss	xmm5, xmm0

; 1340 :     float t = v * (1.0f - s * (1.0f - f));

	movaps	xmm0, xmm4
	subss	xmm0, xmm1
	mulss	xmm5, xmm3
	mulss	xmm0, xmm6
	subss	xmm4, xmm0
	mulss	xmm4, xmm3

; 1341 : 
; 1342 :     switch (i)

	cmp	eax, 4
	ja	$LN10@ColorConve
	jmp	DWORD PTR $LN15@ColorConve[eax*4]
$LN5@ColorConve:

; 1343 :     {
; 1344 :     case 0: out_r = v; out_g = t; out_b = p; break;

	mov	eax, DWORD PTR _out_r$[ebp]
	movss	DWORD PTR [eax], xmm3
	mov	eax, DWORD PTR _out_g$[ebp]
	movss	DWORD PTR [eax], xmm4
	mov	eax, DWORD PTR _out_b$[ebp]
	movss	DWORD PTR [eax], xmm2

; 1350 :     }
; 1351 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@ColorConve:

; 1345 :     case 1: out_r = q; out_g = v; out_b = p; break;

	mov	eax, DWORD PTR _out_r$[ebp]
	movss	DWORD PTR [eax], xmm5
	mov	eax, DWORD PTR _out_g$[ebp]
	movss	DWORD PTR [eax], xmm3
	mov	eax, DWORD PTR _out_b$[ebp]
	movss	DWORD PTR [eax], xmm2

; 1350 :     }
; 1351 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@ColorConve:

; 1346 :     case 2: out_r = p; out_g = v; out_b = t; break;

	mov	eax, DWORD PTR _out_r$[ebp]
	movss	DWORD PTR [eax], xmm2
	mov	eax, DWORD PTR _out_g$[ebp]
	movss	DWORD PTR [eax], xmm3
	mov	eax, DWORD PTR _out_b$[ebp]
	movss	DWORD PTR [eax], xmm4

; 1350 :     }
; 1351 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@ColorConve:

; 1347 :     case 3: out_r = p; out_g = q; out_b = v; break;

	mov	eax, DWORD PTR _out_r$[ebp]
	movss	DWORD PTR [eax], xmm2
	mov	eax, DWORD PTR _out_g$[ebp]
	movss	DWORD PTR [eax], xmm5
	mov	eax, DWORD PTR _out_b$[ebp]
	movss	DWORD PTR [eax], xmm3

; 1350 :     }
; 1351 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@ColorConve:

; 1348 :     case 4: out_r = t; out_g = p; out_b = v; break;

	mov	eax, DWORD PTR _out_r$[ebp]
	movss	DWORD PTR [eax], xmm4
	mov	eax, DWORD PTR _out_g$[ebp]
	movss	DWORD PTR [eax], xmm2
	mov	eax, DWORD PTR _out_b$[ebp]
	movss	DWORD PTR [eax], xmm3

; 1350 :     }
; 1351 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@ColorConve:

; 1349 :     case 5: default: out_r = v; out_g = p; out_b = q; break;

	mov	eax, DWORD PTR _out_r$[ebp]
	movss	DWORD PTR [eax], xmm3
	mov	eax, DWORD PTR _out_g$[ebp]
	movss	DWORD PTR [eax], xmm2
	mov	eax, DWORD PTR _out_b$[ebp]
	movss	DWORD PTR [eax], xmm5

; 1350 :     }
; 1351 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN15@ColorConve:
	DD	$LN5@ColorConve
	DD	$LN6@ColorConve
	DD	$LN7@ColorConve
	DD	$LN8@ColorConve
	DD	$LN9@ColorConve
?ColorConvertHSVtoRGB@ImGui@@YAXMMMAAM00@Z ENDP		; ImGui::ColorConvertHSVtoRGB
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
_out_h$ = 20						; size = 4
_out_s$ = 24						; size = 4
_out_v$ = 28						; size = 4
?ColorConvertRGBtoHSV@ImGui@@YAXMMMAAM00@Z PROC		; ImGui::ColorConvertRGBtoHSV

; 1305 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1306 :     float K = 0.f;
; 1307 :     if (g < b)

	movss	xmm1, DWORD PTR _b$[ebp]
	xorps	xmm5, xmm5
	movss	xmm3, DWORD PTR _g$[ebp]
	comiss	xmm1, xmm3
	jbe	SHORT $LN2@ColorConve

; 1308 :     {
; 1309 :         const float tmp = g; g = b; b = tmp;
; 1310 :         K = -1.f;

	movss	xmm5, DWORD PTR __real@bf800000
	movaps	xmm0, xmm3
	movaps	xmm3, xmm1
	movaps	xmm1, xmm0
$LN2@ColorConve:

; 1311 :     }
; 1312 :     if (r < g)

	movss	xmm4, DWORD PTR _r$[ebp]
	comiss	xmm3, xmm4
	jbe	SHORT $LN3@ColorConve

; 1313 :     {
; 1314 :         const float tmp = r; r = g; g = tmp;

	movaps	xmm0, xmm4
	movaps	xmm4, xmm3
	movaps	xmm3, xmm0

; 1315 :         K = -2.f / 6.f - K;

	movss	xmm0, DWORD PTR __real@beaaaaab
	subss	xmm0, xmm5
	movaps	xmm5, xmm0
$LN3@ColorConve:

; 1319 :     out_h = fabsf(K + (g - b) / (6.f * chroma + 1e-20f));

	movaps	xmm0, xmm3
	mov	eax, DWORD PTR _out_h$[ebp]
	minss	xmm0, xmm1
	movaps	xmm2, xmm4
	subss	xmm3, xmm1
	subss	xmm2, xmm0
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR __real@40c00000
	addss	xmm0, DWORD PTR __real@1e3ce508
	divss	xmm3, xmm0

; 1320 :     out_s = chroma / (r + 1e-20f);

	movaps	xmm0, xmm4
	addss	xmm0, DWORD PTR __real@1e3ce508
	addss	xmm3, xmm5
	divss	xmm2, xmm0
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 658  :         return (float)fabs(_X);

	andps	xmm3, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1319 :     out_h = fabsf(K + (g - b) / (6.f * chroma + 1e-20f));

	movss	DWORD PTR [eax], xmm3

; 1320 :     out_s = chroma / (r + 1e-20f);

	mov	eax, DWORD PTR _out_s$[ebp]
	movss	DWORD PTR [eax], xmm2

; 1321 :     out_v = r;

	mov	eax, DWORD PTR _out_v$[ebp]
	movss	DWORD PTR [eax], xmm4

; 1322 : }

	pop	ebp
	ret	0
?ColorConvertRGBtoHSV@ImGui@@YAXMMMAAM00@Z ENDP		; ImGui::ColorConvertRGBtoHSV
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_in$ = 8						; size = 4
?ColorConvertFloat4ToU32@ImGui@@YAIABUImVec4@@@Z PROC	; ImGui::ColorConvertFloat4ToU32

; 1279 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1281 :     out  = ((ImU32)IM_F32_TO_INT8_SAT(in.x)) << IM_COL32_R_SHIFT;

	mov	ecx, DWORD PTR _in$[ebp]
	xorps	xmm0, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 134  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	movss	xmm2, DWORD PTR __real@3f800000
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1281 :     out  = ((ImU32)IM_F32_TO_INT8_SAT(in.x)) << IM_COL32_R_SHIFT;

	movss	xmm1, DWORD PTR [ecx]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 134  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm0, xmm1
	jbe	SHORT $LN7@ColorConve
	xorps	xmm1, xmm1
	jmp	SHORT $LN8@ColorConve
$LN7@ColorConve:
	minss	xmm1, xmm2
$LN8@ColorConve:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1281 :     out  = ((ImU32)IM_F32_TO_INT8_SAT(in.x)) << IM_COL32_R_SHIFT;

	movss	xmm3, DWORD PTR __real@437f0000
	movss	xmm4, DWORD PTR __real@3f000000
	mulss	xmm1, xmm3
	addss	xmm1, xmm4
	cvttss2si edx, xmm1

; 1282 :     out |= ((ImU32)IM_F32_TO_INT8_SAT(in.y)) << IM_COL32_G_SHIFT;

	movss	xmm1, DWORD PTR [ecx+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 134  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm0, xmm1
	jbe	SHORT $LN13@ColorConve
	xorps	xmm1, xmm1
	jmp	SHORT $LN14@ColorConve
$LN13@ColorConve:
	minss	xmm1, xmm2
$LN14@ColorConve:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1282 :     out |= ((ImU32)IM_F32_TO_INT8_SAT(in.y)) << IM_COL32_G_SHIFT;

	mulss	xmm1, xmm3
	addss	xmm1, xmm4
	cvttss2si eax, xmm1

; 1283 :     out |= ((ImU32)IM_F32_TO_INT8_SAT(in.z)) << IM_COL32_B_SHIFT;

	movss	xmm1, DWORD PTR [ecx+8]
	shl	eax, 8
	or	edx, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 134  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm0, xmm1
	jbe	SHORT $LN19@ColorConve
	xorps	xmm1, xmm1
	jmp	SHORT $LN20@ColorConve
$LN19@ColorConve:
	minss	xmm1, xmm2
$LN20@ColorConve:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1283 :     out |= ((ImU32)IM_F32_TO_INT8_SAT(in.z)) << IM_COL32_B_SHIFT;

	mulss	xmm1, xmm3
	addss	xmm1, xmm4
	cvttss2si eax, xmm1

; 1284 :     out |= ((ImU32)IM_F32_TO_INT8_SAT(in.w)) << IM_COL32_A_SHIFT;

	movss	xmm1, DWORD PTR [ecx+12]
	shl	eax, 16					; 00000010H
	or	edx, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 134  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm0, xmm1
	ja	SHORT $LN26@ColorConve
	minss	xmm1, xmm2
	movaps	xmm0, xmm1
$LN26@ColorConve:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1284 :     out |= ((ImU32)IM_F32_TO_INT8_SAT(in.w)) << IM_COL32_A_SHIFT;

	mulss	xmm0, xmm3
	addss	xmm0, xmm4
	cvttss2si eax, xmm0
	shl	eax, 24					; 00000018H
	or	eax, edx

; 1285 :     return out;
; 1286 : }

	pop	ebp
	ret	0
?ColorConvertFloat4ToU32@ImGui@@YAIABUImVec4@@@Z ENDP	; ImGui::ColorConvertFloat4ToU32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_in$ = 12						; size = 4
?ColorConvertU32ToFloat4@ImGui@@YA?AUImVec4@@I@Z PROC	; ImGui::ColorConvertU32ToFloat4

; 1269 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 1271 :     return ImVec4(

	mov	edx, DWORD PTR _in$[ebp]
	movss	xmm1, DWORD PTR __real@3b808081
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 109  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1271 :     return ImVec4(

	movzx	eax, dl
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 109  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

	mov	eax, edx
	shr	eax, 8
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1271 :     return ImVec4(

	movzx	eax, al
	cvtpd2ps xmm0, xmm0
	mulss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 109  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

	movss	DWORD PTR [ecx], xmm0
	movd	xmm0, eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1271 :     return ImVec4(

	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 109  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

	mov	eax, edx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1271 :     return ImVec4(

	shr	edx, 24					; 00000018H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 109  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

	shr	eax, 16					; 00000010H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1271 :     return ImVec4(

	movzx	eax, al
	cvtpd2ps xmm0, xmm0
	mulss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 109  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

	movss	DWORD PTR [ecx+4], xmm0
	movd	xmm0, eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1271 :     return ImVec4(

	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	eax, ecx
	cvtpd2ps xmm0, xmm0
	mulss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 109  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

	movss	DWORD PTR [ecx+8], xmm0
	movd	xmm0, edx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1271 :     return ImVec4(

	cvtdq2pd xmm0, xmm0
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	cvtpd2ps xmm0, xmm0
	mulss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 109  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

	movss	DWORD PTR [ecx+12], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 1276 : }

	pop	ebp
	ret	0
?ColorConvertU32ToFloat4@ImGui@@YA?AUImVec4@@I@Z ENDP	; ImGui::ColorConvertU32ToFloat4
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?EndChildFrame@ImGui@@YAXXZ PROC			; ImGui::EndChildFrame

; 4561 :     ImGui::EndChild();

	call	?EndChild@ImGui@@YAXXZ			; ImGui::EndChild

; 4562 :     ImGui::PopStyleVar(2);

	push	2
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar

; 4563 :     ImGui::PopStyleColor();

	push	1
	call	?PopStyleColor@ImGui@@YAXH@Z		; ImGui::PopStyleColor
	add	esp, 8

; 4564 : }

	ret	0
?EndChildFrame@ImGui@@YAXXZ ENDP			; ImGui::EndChildFrame
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_id$ = 8						; size = 4
_size$ = 12						; size = 4
_extra_flags$ = 16					; size = 4
?BeginChildFrame@ImGui@@YA_NIABUImVec2@@H@Z PROC	; ImGui::BeginChildFrame

; 4550 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 4551 :     ImGuiContext& g = *GImGui;

	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 4552 :     const ImGuiStyle& style = g.Style;
; 4553 :     ImGui::PushStyleColor(ImGuiCol_ChildWindowBg, style.Colors[ImGuiCol_FrameBg]);

	lea	eax, DWORD PTR [esi+5560]
	push	eax
	push	3
	call	?PushStyleColor@ImGui@@YAXHABUImVec4@@@Z ; ImGui::PushStyleColor

; 4554 :     ImGui::PushStyleVar(ImGuiStyleVar_ChildWindowRounding, style.FrameRounding);

	movss	xmm0, DWORD PTR [esi+5364]
	add	esp, 4
	movss	DWORD PTR [esp], xmm0
	push	4
	call	?PushStyleVar@ImGui@@YAXHM@Z		; ImGui::PushStyleVar

; 4555 :     ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, style.FramePadding);

	lea	eax, DWORD PTR [esi+5356]
	push	eax
	push	1
	call	?PushStyleVar@ImGui@@YAXHABUImVec2@@@Z	; ImGui::PushStyleVar

; 4556 :     return ImGui::BeginChild(id, size, (g.CurrentWindow->Flags & ImGuiWindowFlags_ShowBorders) ? true : false, ImGuiWindowFlags_NoMove | ImGuiWindowFlags_AlwaysUseWindowPadding | extra_flags);

	mov	eax, DWORD PTR _extra_flags$[ebp]
	or	eax, 65540				; 00010004H
	push	eax
	mov	eax, DWORD PTR [esi+6240]
	mov	eax, DWORD PTR [eax+8]
	shr	eax, 7
	and	al, 1
	movzx	eax, al
	push	eax
	push	DWORD PTR _size$[ebp]
	push	DWORD PTR _id$[ebp]
	call	?BeginChild@ImGui@@YA_NIABUImVec2@@_NH@Z ; ImGui::BeginChild
	add	esp, 32					; 00000020H
	pop	esi

; 4557 : }

	pop	ebp
	ret	0
?BeginChildFrame@ImGui@@YA_NIABUImVec2@@H@Z ENDP	; ImGui::BeginChildFrame
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_pos$ = -8						; size = 8
_items_count$ = 8					; size = 4
_items_height$ = 12					; size = 4
_out_items_display_start$ = 16				; size = 4
_out_items_display_end$ = 20				; size = 4
?CalcListClipping@ImGui@@YAXHMPAH0@Z PROC		; ImGui::CalcListClipping

; 3826 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 3827 :     ImGuiContext& g = *GImGui;

	mov	edx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	sub	esp, 8

; 3829 :     if (g.LogEnabled)

	cmp	BYTE PTR [edx+11600], 0
	push	esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 792  :     inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }

	mov	esi, DWORD PTR [edx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3829 :     if (g.LogEnabled)

	je	SHORT $LN2@CalcListCl

; 3830 :     {
; 3831 :         // If logging is active, do not perform any clipping
; 3832 :         *out_items_display_start = 0;

	mov	eax, DWORD PTR _out_items_display_start$[ebp]

; 3833 :         *out_items_display_end = items_count;

	mov	ecx, DWORD PTR _out_items_display_end$[ebp]
	pop	esi
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _items_count$[ebp]
	mov	DWORD PTR [ecx], eax

; 3854 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@CalcListCl:

; 3834 :         return;
; 3835 :     }
; 3836 :     if (window->SkipItems)

	cmp	BYTE PTR [esi+137], 0
	je	SHORT $LN3@CalcListCl

; 3837 :     {
; 3838 :         *out_items_display_start = *out_items_display_end = 0;

	mov	eax, DWORD PTR _out_items_display_end$[ebp]
	pop	esi
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _out_items_display_start$[ebp]
	mov	DWORD PTR [eax], 0

; 3854 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@CalcListCl:

; 3839 :         return;
; 3840 :     }
; 3841 : 
; 3842 :     const ImVec2 pos = window->DC.CursorPos;
; 3843 :     int start = (int)((window->ClipRect.Min.y - pos.y) / items_height);

	movss	xmm2, DWORD PTR __real@3f800000
	divss	xmm2, DWORD PTR _items_height$[ebp]
	mov	eax, DWORD PTR [esi+196]
	mov	DWORD PTR _pos$[ebp+4], eax

; 3844 :     int end = (int)((window->ClipRect.Max.y - pos.y) / items_height);
; 3845 :     if (g.NavMoveRequest && g.NavMoveDir == ImGuiNavDir_Up) // When performing a navigation request, ensure we have one item extra in the direction we are moving to

	mov	al, BYTE PTR [edx+6481]
	movss	xmm0, DWORD PTR [esi+476]
	subss	xmm0, DWORD PTR _pos$[ebp+4]
	mulss	xmm0, xmm2
	cvttss2si ecx, xmm0
	movss	xmm0, DWORD PTR [esi+484]
	subss	xmm0, DWORD PTR _pos$[ebp+4]
	mulss	xmm0, xmm2
	cvttss2si esi, xmm0
	test	al, al
	je	SHORT $LN5@CalcListCl
	cmp	DWORD PTR [edx+6484], 2
	jne	SHORT $LN4@CalcListCl

; 3846 :         start--;

	dec	ecx
$LN4@CalcListCl:

; 3847 :     if (g.NavMoveRequest && g.NavMoveDir == ImGuiNavDir_Down)

	test	al, al
	je	SHORT $LN5@CalcListCl
	cmp	DWORD PTR [edx+6484], 3
	jne	SHORT $LN5@CalcListCl

; 3848 :         end++;

	inc	esi
$LN5@CalcListCl:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 131  : static inline int    ImClamp(int v, int mn, int mx)                             { return (v < mn) ? mn : (v > mx) ? mx : v; }

	mov	eax, DWORD PTR _items_count$[ebp]
	test	ecx, ecx
	jns	SHORT $LN11@CalcListCl
	xor	ecx, ecx
	jmp	SHORT $LN12@CalcListCl
$LN11@CalcListCl:
	cmp	ecx, eax
	cmovg	ecx, eax
$LN12@CalcListCl:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3851 :     end = ImClamp(end + 1, start, items_count);

	lea	edx, DWORD PTR [esi+1]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 131  : static inline int    ImClamp(int v, int mn, int mx)                             { return (v < mn) ? mn : (v > mx) ? mx : v; }

	cmp	edx, ecx
	jge	SHORT $LN15@CalcListCl
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3852 :     *out_items_display_start = start;

	mov	eax, DWORD PTR _out_items_display_start$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 131  : static inline int    ImClamp(int v, int mn, int mx)                             { return (v < mn) ? mn : (v > mx) ? mx : v; }

	mov	edx, ecx
	pop	esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3852 :     *out_items_display_start = start;

	mov	DWORD PTR [eax], ecx

; 3853 :     *out_items_display_end = end;

	mov	eax, DWORD PTR _out_items_display_end$[ebp]
	mov	DWORD PTR [eax], edx

; 3854 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@CalcListCl:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 131  : static inline int    ImClamp(int v, int mn, int mx)                             { return (v < mn) ? mn : (v > mx) ? mx : v; }

	cmp	edx, eax
	pop	esi
	cmovg	edx, eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3852 :     *out_items_display_start = start;

	mov	eax, DWORD PTR _out_items_display_start$[ebp]
	mov	DWORD PTR [eax], ecx

; 3853 :     *out_items_display_end = end;

	mov	eax, DWORD PTR _out_items_display_end$[ebp]
	mov	DWORD PTR [eax], edx

; 3854 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CalcListClipping@ImGui@@YAXHMPAH0@Z ENDP		; ImGui::CalcListClipping
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_text_size$ = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
_text$ = 12						; size = 4
_text_end$ = 16						; size = 4
_font_size$1$ = 20					; size = 4
_hide_text_after_double_hash$ = 20			; size = 1
_wrap_width$ = 24					; size = 4
?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z PROC	; ImGui::CalcTextSize

; 3797 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3798 :     ImGuiContext& g = *GImGui;
; 3799 : 
; 3800 :     const char* text_display_end;
; 3801 :     if (hide_text_after_double_hash)

	cmp	BYTE PTR _hide_text_after_double_hash$[ebp], 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR _text$[ebp]
	push	edi
	mov	edi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	je	SHORT $LN2@CalcTextSi

; 3802 :         text_display_end = FindRenderedTextEnd(text, text_end);      // Hide anything after a '##' string

	push	DWORD PTR _text_end$[ebp]
	push	esi
	call	?FindRenderedTextEnd@ImGui@@YAPBDPBD0@Z	; ImGui::FindRenderedTextEnd
	add	esp, 8

; 3803 :     else

	jmp	SHORT $LN3@CalcTextSi
$LN2@CalcTextSi:

; 3804 :         text_display_end = text_end;

	mov	eax, DWORD PTR _text_end$[ebp]
$LN3@CalcTextSi:

; 3805 : 
; 3806 :     ImFont* font = g.Font;
; 3807 :     const float font_size = g.FontSize;

	movss	xmm1, DWORD PTR [edi+6172]
	mov	ebx, DWORD PTR [edi+6168]
	movss	DWORD PTR _font_size$1$[ebp], xmm1

; 3808 :     if (text == text_display_end)

	cmp	esi, eax
	jne	SHORT $LN4@CalcTextSi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR [eax], 0
	movss	DWORD PTR [eax+4], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3820 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@CalcTextSi:

; 3809 :         return ImVec2(0.0f, font_size);
; 3810 :     ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	movss	xmm0, DWORD PTR _wrap_width$[ebp]
	mov	ecx, ebx
	push	0
	push	eax
	push	esi
	sub	esp, 12					; 0000000cH
	lea	eax, DWORD PTR _text_size$[ebp]
	movss	DWORD PTR [esp+8], xmm0
	mov	DWORD PTR [esp+4], 2139095039		; 7f7fffffH
	movss	DWORD PTR [esp], xmm1
	push	eax
	call	?CalcTextSizeA@ImFont@@QBE?AUImVec2@@MMMPBD0PAPBD@Z ; ImFont::CalcTextSizeA

; 3814 :     const float character_spacing_x = 1.0f * font_scale;
; 3815 :     if (text_size.x > 0.0f)

	movss	xmm0, DWORD PTR _text_size$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN5@CalcTextSi

; 3811 : 
; 3812 :     // Cancel out character spacing for the last character of a line (it is baked into glyph->XAdvance field)
; 3813 :     const float font_scale = font_size / font->FontSize;

	movss	xmm1, DWORD PTR _font_size$1$[ebp]
	divss	xmm1, DWORD PTR [ebx]

; 3816 :         text_size.x -= character_spacing_x;

	subss	xmm0, xmm1
$LN5@CalcTextSi:

; 3817 :     text_size.x = (float)(int)(text_size.x + 0.95f);

	addss	xmm0, DWORD PTR __real@3f733333
	pop	edi
	pop	esi
	pop	ebx
	cvttss2si eax, xmm0
	movd	xmm0, eax

; 3818 : 
; 3819 :     return text_size;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR _text_size$[ebp], xmm0
	mov	ecx, DWORD PTR _text_size$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _text_size$[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 3820 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ENDP	; ImGui::CalcTextSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_rect$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_pos$ = 12						; size = 4
_on_edge$ = 16						; size = 1
_outward$ = 20						; size = 4
?CalcItemRectClosestPoint@ImGui@@YA?AUImVec2@@ABU2@_NM@Z PROC ; ImGui::CalcItemRectClosestPoint

; 4203 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 264  :         if (!on_edge && Contains(p))

	cmp	BYTE PTR _on_edge$[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4205 :     ImRect rect = window->DC.LastItemRect;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 257  :     void        Expand(const float amount)      { Min.x -= amount;   Min.y -= amount;   Max.x += amount;   Max.y += amount; }

	movss	xmm0, DWORD PTR _outward$[ebp]
	mov	edx, DWORD PTR _pos$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4205 :     ImRect rect = window->DC.LastItemRect;

	mov	eax, DWORD PTR [eax+6240]
	movss	xmm1, DWORD PTR [edx]
	movups	xmm2, XMMWORD PTR [eax+252]
	movups	XMMWORD PTR _rect$[ebp], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 257  :     void        Expand(const float amount)      { Min.x -= amount;   Min.y -= amount;   Max.x += amount;   Max.y += amount; }

	movss	xmm3, DWORD PTR _rect$[ebp+4]
	subss	xmm2, xmm0
	movss	xmm5, DWORD PTR _rect$[ebp+8]
	subss	xmm3, xmm0
	movss	xmm4, DWORD PTR _rect$[ebp+12]
	addss	xmm5, xmm0
	addss	xmm4, xmm0
	movss	xmm0, DWORD PTR [edx+4]

; 264  :         if (!on_edge && Contains(p))

	jne	SHORT $LN8@CalcItemRe

; 252  :     bool        Contains(const ImVec2& p) const { return p.x >= Min.x     && p.y >= Min.y     && p.x < Max.x     && p.y < Max.y; }

	comiss	xmm1, xmm2
	jb	SHORT $LN8@CalcItemRe
	comiss	xmm0, xmm3
	jb	SHORT $LN8@CalcItemRe
	comiss	xmm5, xmm1
	jbe	SHORT $LN8@CalcItemRe
	comiss	xmm4, xmm0
	jbe	SHORT $LN8@CalcItemRe

; 265  :             return p;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4208 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@CalcItemRe:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 266  :         if (p.x > Max.x) p.x = Max.x;

	comiss	xmm1, xmm5
	jbe	SHORT $LN9@CalcItemRe
	movaps	xmm1, xmm5
	jmp	SHORT $LN11@CalcItemRe
$LN9@CalcItemRe:

; 267  :         else if (p.x < Min.x) p.x = Min.x;

	comiss	xmm2, xmm1
	jbe	SHORT $LN11@CalcItemRe
	movaps	xmm1, xmm2
$LN11@CalcItemRe:

; 268  :         if (p.y > Max.y) p.y = Max.y;

	comiss	xmm0, xmm4
	jbe	SHORT $LN12@CalcItemRe
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	movaps	xmm0, xmm4
	movss	DWORD PTR [eax], xmm1
	movss	DWORD PTR [eax+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4208 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@CalcItemRe:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 269  :         else if (p.y < Min.y) p.y = Min.y;

	comiss	xmm3, xmm0
	jbe	SHORT $LN14@CalcItemRe
	movaps	xmm0, xmm3
$LN14@CalcItemRe:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	movss	DWORD PTR [eax], xmm1
	movss	DWORD PTR [eax+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4208 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CalcItemRectClosestPoint@ImGui@@YA?AUImVec2@@ABU2@_NM@Z ENDP ; ImGui::CalcItemRectClosestPoint
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_idx$ = 8						; size = 4
?GetStyleColName@ImGui@@YAPBDH@Z PROC			; ImGui::GetStyleColName

; 5740 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 5741 :     // Create switch-case from enum with regexp: ImGuiCol_{.*}, --> case ImGuiCol_\1: return "\1";
; 5742 :     switch (idx)

	mov	eax, DWORD PTR _idx$[ebp]
	cmp	eax, 44					; 0000002cH
	ja	$LN2@GetStyleCo
	jmp	DWORD PTR $LN51@GetStyleCo[eax*4]
$LN4@GetStyleCo:

; 5743 :     {
; 5744 :     case ImGuiCol_Text: return "Text";

	mov	eax, OFFSET $SG118597

; 5792 : }

	pop	ebp
	ret	0
$LN5@GetStyleCo:

; 5745 :     case ImGuiCol_TextDisabled: return "TextDisabled";

	mov	eax, OFFSET $SG118599

; 5792 : }

	pop	ebp
	ret	0
$LN6@GetStyleCo:

; 5746 :     case ImGuiCol_WindowBg: return "WindowBg";

	mov	eax, OFFSET $SG118601

; 5792 : }

	pop	ebp
	ret	0
$LN7@GetStyleCo:

; 5747 :     case ImGuiCol_ChildWindowBg: return "ChildWindowBg";

	mov	eax, OFFSET $SG118603

; 5792 : }

	pop	ebp
	ret	0
$LN8@GetStyleCo:

; 5748 :     case ImGuiCol_PopupBg: return "PopupBg";

	mov	eax, OFFSET $SG118605

; 5792 : }

	pop	ebp
	ret	0
$LN9@GetStyleCo:

; 5749 :     case ImGuiCol_Border: return "Border";

	mov	eax, OFFSET $SG118607

; 5792 : }

	pop	ebp
	ret	0
$LN10@GetStyleCo:

; 5750 :     case ImGuiCol_BorderShadow: return "BorderShadow";

	mov	eax, OFFSET $SG118609

; 5792 : }

	pop	ebp
	ret	0
$LN11@GetStyleCo:

; 5751 :     case ImGuiCol_FrameBg: return "FrameBg";

	mov	eax, OFFSET $SG118611

; 5792 : }

	pop	ebp
	ret	0
$LN12@GetStyleCo:

; 5752 :     case ImGuiCol_FrameBgHovered: return "FrameBgHovered";

	mov	eax, OFFSET $SG118613

; 5792 : }

	pop	ebp
	ret	0
$LN13@GetStyleCo:

; 5753 :     case ImGuiCol_FrameBgActive: return "FrameBgActive";

	mov	eax, OFFSET $SG118615

; 5792 : }

	pop	ebp
	ret	0
$LN14@GetStyleCo:

; 5754 :     case ImGuiCol_TitleBg: return "TitleBg";

	mov	eax, OFFSET $SG118617

; 5792 : }

	pop	ebp
	ret	0
$LN15@GetStyleCo:

; 5755 :     case ImGuiCol_TitleBgCollapsed: return "TitleBgCollapsed";

	mov	eax, OFFSET $SG118619

; 5792 : }

	pop	ebp
	ret	0
$LN16@GetStyleCo:

; 5756 :     case ImGuiCol_TitleBgActive: return "TitleBgActive";

	mov	eax, OFFSET $SG118621

; 5792 : }

	pop	ebp
	ret	0
$LN17@GetStyleCo:

; 5757 :     case ImGuiCol_MenuBarBg: return "MenuBarBg";

	mov	eax, OFFSET $SG118623

; 5792 : }

	pop	ebp
	ret	0
$LN18@GetStyleCo:

; 5758 :     case ImGuiCol_ScrollbarBg: return "ScrollbarBg";

	mov	eax, OFFSET $SG118625

; 5792 : }

	pop	ebp
	ret	0
$LN19@GetStyleCo:

; 5759 :     case ImGuiCol_ScrollbarGrab: return "ScrollbarGrab";

	mov	eax, OFFSET $SG118627

; 5792 : }

	pop	ebp
	ret	0
$LN20@GetStyleCo:

; 5760 :     case ImGuiCol_ScrollbarGrabHovered: return "ScrollbarGrabHovered";

	mov	eax, OFFSET $SG118629

; 5792 : }

	pop	ebp
	ret	0
$LN21@GetStyleCo:

; 5761 :     case ImGuiCol_ScrollbarGrabActive: return "ScrollbarGrabActive";

	mov	eax, OFFSET $SG118631

; 5792 : }

	pop	ebp
	ret	0
$LN22@GetStyleCo:

; 5762 :     case ImGuiCol_ComboBg: return "ComboBg";

	mov	eax, OFFSET $SG118633

; 5792 : }

	pop	ebp
	ret	0
$LN23@GetStyleCo:

; 5763 :     case ImGuiCol_CheckMark: return "CheckMark";

	mov	eax, OFFSET $SG118635

; 5792 : }

	pop	ebp
	ret	0
$LN24@GetStyleCo:

; 5764 :     case ImGuiCol_SliderGrab: return "SliderGrab";

	mov	eax, OFFSET $SG118637

; 5792 : }

	pop	ebp
	ret	0
$LN25@GetStyleCo:

; 5765 :     case ImGuiCol_SliderGrabActive: return "SliderGrabActive";

	mov	eax, OFFSET $SG118639

; 5792 : }

	pop	ebp
	ret	0
$LN26@GetStyleCo:

; 5766 :     case ImGuiCol_Button: return "Button";

	mov	eax, OFFSET $SG118641

; 5792 : }

	pop	ebp
	ret	0
$LN27@GetStyleCo:

; 5767 :     case ImGuiCol_ButtonHovered: return "ButtonHovered";

	mov	eax, OFFSET $SG118643

; 5792 : }

	pop	ebp
	ret	0
$LN28@GetStyleCo:

; 5768 :     case ImGuiCol_ButtonActive: return "ButtonActive";

	mov	eax, OFFSET $SG118645

; 5792 : }

	pop	ebp
	ret	0
$LN29@GetStyleCo:

; 5769 :     case ImGuiCol_Header: return "Header";

	mov	eax, OFFSET $SG118647

; 5792 : }

	pop	ebp
	ret	0
$LN30@GetStyleCo:

; 5770 :     case ImGuiCol_HeaderHovered: return "HeaderHovered";

	mov	eax, OFFSET $SG118649

; 5792 : }

	pop	ebp
	ret	0
$LN31@GetStyleCo:

; 5771 :     case ImGuiCol_HeaderActive: return "HeaderActive";

	mov	eax, OFFSET $SG118651

; 5792 : }

	pop	ebp
	ret	0
$LN32@GetStyleCo:

; 5772 :     case ImGuiCol_Column: return "Column";

	mov	eax, OFFSET $SG118653

; 5792 : }

	pop	ebp
	ret	0
$LN33@GetStyleCo:

; 5773 :     case ImGuiCol_ColumnHovered: return "ColumnHovered";

	mov	eax, OFFSET $SG118655

; 5792 : }

	pop	ebp
	ret	0
$LN34@GetStyleCo:

; 5774 :     case ImGuiCol_ColumnActive: return "ColumnActive";

	mov	eax, OFFSET $SG118657

; 5792 : }

	pop	ebp
	ret	0
$LN35@GetStyleCo:

; 5775 :     case ImGuiCol_ResizeGrip: return "ResizeGrip";

	mov	eax, OFFSET $SG118659

; 5792 : }

	pop	ebp
	ret	0
$LN36@GetStyleCo:

; 5776 :     case ImGuiCol_ResizeGripHovered: return "ResizeGripHovered";

	mov	eax, OFFSET $SG118661

; 5792 : }

	pop	ebp
	ret	0
$LN37@GetStyleCo:

; 5777 :     case ImGuiCol_ResizeGripActive: return "ResizeGripActive";

	mov	eax, OFFSET $SG118663

; 5792 : }

	pop	ebp
	ret	0
$LN38@GetStyleCo:

; 5778 :     case ImGuiCol_CloseButton: return "CloseButton";

	mov	eax, OFFSET $SG118665

; 5792 : }

	pop	ebp
	ret	0
$LN39@GetStyleCo:

; 5779 :     case ImGuiCol_CloseButtonHovered: return "CloseButtonHovered";

	mov	eax, OFFSET $SG118667

; 5792 : }

	pop	ebp
	ret	0
$LN40@GetStyleCo:

; 5780 :     case ImGuiCol_CloseButtonActive: return "CloseButtonActive";

	mov	eax, OFFSET $SG118669

; 5792 : }

	pop	ebp
	ret	0
$LN41@GetStyleCo:

; 5781 :     case ImGuiCol_PlotLines: return "PlotLines";

	mov	eax, OFFSET $SG118671

; 5792 : }

	pop	ebp
	ret	0
$LN42@GetStyleCo:

; 5782 :     case ImGuiCol_PlotLinesHovered: return "PlotLinesHovered";

	mov	eax, OFFSET $SG118673

; 5792 : }

	pop	ebp
	ret	0
$LN43@GetStyleCo:

; 5783 :     case ImGuiCol_PlotHistogram: return "PlotHistogram";

	mov	eax, OFFSET $SG118675

; 5792 : }

	pop	ebp
	ret	0
$LN44@GetStyleCo:

; 5784 :     case ImGuiCol_PlotHistogramHovered: return "PlotHistogramHovered";

	mov	eax, OFFSET $SG118677

; 5792 : }

	pop	ebp
	ret	0
$LN45@GetStyleCo:

; 5785 :     case ImGuiCol_TextSelectedBg: return "TextSelectedBg";

	mov	eax, OFFSET $SG118679

; 5792 : }

	pop	ebp
	ret	0
$LN46@GetStyleCo:

; 5786 :     case ImGuiCol_ModalWindowDarkening: return "ModalWindowDarkening";

	mov	eax, OFFSET $SG118681

; 5792 : }

	pop	ebp
	ret	0
$LN47@GetStyleCo:

; 5787 :     case ImGuiCol_NavHighlight: return "NavHighlight";

	mov	eax, OFFSET $SG118683

; 5792 : }

	pop	ebp
	ret	0
$LN48@GetStyleCo:

; 5788 :     case ImGuiCol_NavWindowingHighlight: return "NavWindowingHighlight"; 

	mov	eax, OFFSET $SG118685

; 5792 : }

	pop	ebp
	ret	0
$LN2@GetStyleCo:

; 5789 :     }
; 5790 :     IM_ASSERT(0);
; 5791 :     return "Unknown";

	mov	eax, OFFSET $SG118686

; 5792 : }

	pop	ebp
	ret	0
	npad	2
$LN51@GetStyleCo:
	DD	$LN4@GetStyleCo
	DD	$LN5@GetStyleCo
	DD	$LN6@GetStyleCo
	DD	$LN7@GetStyleCo
	DD	$LN8@GetStyleCo
	DD	$LN9@GetStyleCo
	DD	$LN10@GetStyleCo
	DD	$LN11@GetStyleCo
	DD	$LN12@GetStyleCo
	DD	$LN13@GetStyleCo
	DD	$LN14@GetStyleCo
	DD	$LN15@GetStyleCo
	DD	$LN16@GetStyleCo
	DD	$LN17@GetStyleCo
	DD	$LN18@GetStyleCo
	DD	$LN19@GetStyleCo
	DD	$LN20@GetStyleCo
	DD	$LN21@GetStyleCo
	DD	$LN22@GetStyleCo
	DD	$LN23@GetStyleCo
	DD	$LN24@GetStyleCo
	DD	$LN25@GetStyleCo
	DD	$LN26@GetStyleCo
	DD	$LN27@GetStyleCo
	DD	$LN28@GetStyleCo
	DD	$LN29@GetStyleCo
	DD	$LN30@GetStyleCo
	DD	$LN31@GetStyleCo
	DD	$LN32@GetStyleCo
	DD	$LN33@GetStyleCo
	DD	$LN34@GetStyleCo
	DD	$LN35@GetStyleCo
	DD	$LN36@GetStyleCo
	DD	$LN37@GetStyleCo
	DD	$LN38@GetStyleCo
	DD	$LN39@GetStyleCo
	DD	$LN40@GetStyleCo
	DD	$LN41@GetStyleCo
	DD	$LN42@GetStyleCo
	DD	$LN43@GetStyleCo
	DD	$LN44@GetStyleCo
	DD	$LN45@GetStyleCo
	DD	$LN46@GetStyleCo
	DD	$LN47@GetStyleCo
	DD	$LN48@GetStyleCo
?GetStyleColName@ImGui@@YAPBDH@Z ENDP			; ImGui::GetStyleColName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?GetFrameCount@ImGui@@YAHXZ PROC			; ImGui::GetFrameCount

; 2402 :     return GImGui->FrameCount;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [eax+6192]

; 2403 : }

	ret	0
?GetFrameCount@ImGui@@YAHXZ ENDP			; ImGui::GetFrameCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?GetTime@ImGui@@YAMXZ PROC				; ImGui::GetTime

; 2397 :     return GImGui->Time;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	fld	DWORD PTR [eax+6188]

; 2398 : }

	ret	0
?GetTime@ImGui@@YAMXZ ENDP				; ImGui::GetTime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -16						; size = 16
_rect_min$ = 8						; size = 4
_rect_max$ = 12						; size = 4
?IsRectVisible@ImGui@@YA_NABUImVec2@@0@Z PROC		; ImGui::IsRectVisible

; 10296: {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	ecx, DWORD PTR _rect_min$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _rect_max$[ebp]
	mov	DWORD PTR $T1[ebp+4], eax
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T1[ebp+8], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR $T1[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10298:     return window->ClipRect.Overlaps(ImRect(rect_min, rect_max));

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [eax+6240]
	add	eax, 472				; 000001d8H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 254  :     bool        Overlaps(const ImRect& r) const { return r.Min.y < Max.y  && r.Max.y > Min.y  && r.Min.x < Max.x && r.Max.x > Min.x; }

	movss	xmm0, DWORD PTR [eax+12]
	comiss	xmm0, DWORD PTR $T1[ebp+4]
	jbe	SHORT $LN9@IsRectVisi
	movss	xmm0, DWORD PTR $T1[ebp+12]
	comiss	xmm0, DWORD PTR [eax+4]
	jbe	SHORT $LN9@IsRectVisi
	movss	xmm0, DWORD PTR [eax+8]
	comiss	xmm0, DWORD PTR $T1[ebp]
	jbe	SHORT $LN9@IsRectVisi
	movss	xmm0, DWORD PTR $T1[ebp+8]
	comiss	xmm0, DWORD PTR [eax]
	jbe	SHORT $LN9@IsRectVisi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10298:     return window->ClipRect.Overlaps(ImRect(rect_min, rect_max));

	mov	al, 1

; 10299: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@IsRectVisi:

; 10298:     return window->ClipRect.Overlaps(ImRect(rect_min, rect_max));

	xor	al, al

; 10299: }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsRectVisible@ImGui@@YA_NABUImVec2@@0@Z ENDP		; ImGui::IsRectVisible
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T2 = -16						; size = 16
_size$ = 8						; size = 4
?IsRectVisible@ImGui@@YA_NABUImVec2@@@Z PROC		; ImGui::IsRectVisible

; 10290: {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 792  :     inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	ecx, DWORD PTR [eax+6240]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	mov	eax, DWORD PTR _size$[ebp]
	movss	xmm1, DWORD PTR [ecx+192]
	movss	xmm2, DWORD PTR [ecx+196]
	addss	xmm1, DWORD PTR [eax]
	addss	xmm2, DWORD PTR [eax+4]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [ecx+192]

; 254  :     bool        Overlaps(const ImRect& r) const { return r.Min.y < Max.y  && r.Max.y > Min.y  && r.Min.x < Max.x && r.Max.x > Min.x; }

	movss	xmm0, DWORD PTR [ecx+484]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR [ecx+196]
	mov	DWORD PTR $T2[ebp+4], eax

; 254  :     bool        Overlaps(const ImRect& r) const { return r.Min.y < Max.y  && r.Max.y > Min.y  && r.Min.x < Max.x && r.Max.x > Min.x; }

	comiss	xmm0, DWORD PTR $T2[ebp+4]
	jbe	SHORT $LN13@IsRectVisi
	comiss	xmm2, DWORD PTR [ecx+476]
	jbe	SHORT $LN13@IsRectVisi
	movss	xmm0, DWORD PTR [ecx+480]
	comiss	xmm0, DWORD PTR $T2[ebp]
	jbe	SHORT $LN13@IsRectVisi
	comiss	xmm1, DWORD PTR [ecx+472]
	jbe	SHORT $LN13@IsRectVisi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10292:     return window->ClipRect.Overlaps(ImRect(window->DC.CursorPos, window->DC.CursorPos + size));

	mov	al, 1

; 10293: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN13@IsRectVisi:

; 10292:     return window->ClipRect.Overlaps(ImRect(window->DC.CursorPos, window->DC.CursorPos + size));

	xor	al, al

; 10293: }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsRectVisible@ImGui@@YA_NABUImVec2@@@Z ENDP		; ImGui::IsRectVisible
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_pos$ = 8						; size = 4
?IsAnyWindowHoveredAtPos@ImGui@@YA_NABUImVec2@@@Z PROC	; ImGui::IsAnyWindowHoveredAtPos

; 3913 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 3914 :     return FindHoveredWindow(pos, false) != NULL;

	mov	eax, DWORD PTR _pos$[ebp]
	push	0
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	?FindHoveredWindow@@YAPAUImGuiWindow@@UImVec2@@_N@Z ; FindHoveredWindow
	add	esp, 12					; 0000000cH
	test	eax, eax
	setne	al

; 3915 : }

	pop	ebp
	ret	0
?IsAnyWindowHoveredAtPos@ImGui@@YA_NABUImVec2@@@Z ENDP	; ImGui::IsAnyWindowHoveredAtPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?IsAnyWindowHovered@ImGui@@YA_NXZ PROC			; ImGui::IsAnyWindowHovered

; 3903 : {

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	cmp	DWORD PTR [eax+6244], 0
	setne	al

; 3904 :     return GImGui->HoveredWindow != NULL;
; 3905 : }

	ret	0
?IsAnyWindowHovered@ImGui@@YA_NXZ ENDP			; ImGui::IsAnyWindowHovered
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?IsAnyWindowFocused@ImGui@@YA_NXZ PROC			; ImGui::IsAnyWindowFocused

; 3908 : {

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	cmp	DWORD PTR [eax+6380], 0
	setne	al

; 3909 :     return GImGui->NavWindow != NULL;
; 3910 : }

	ret	0
?IsAnyWindowFocused@ImGui@@YA_NXZ ENDP			; ImGui::IsAnyWindowFocused
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?IsRootWindowOrAnyChildHovered@ImGui@@YA_NXZ PROC	; ImGui::IsRootWindowOrAnyChildHovered

; 5820 :     ImGuiContext& g = *GImGui;

	mov	edx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 5821 :     return g.HoveredRootWindow && (g.HoveredRootWindow == g.CurrentWindow->RootWindow) && IsWindowContentHoverable(g.HoveredRootWindow);

	mov	ecx, DWORD PTR [edx+6248]
	test	ecx, ecx
	je	SHORT $LN3@IsRootWind
	mov	eax, DWORD PTR [edx+6240]
	cmp	ecx, DWORD PTR [eax+632]
	jne	SHORT $LN3@IsRootWind

; 6479 :     if (g.NavWindow)

	mov	eax, DWORD PTR [edx+6380]
	test	eax, eax
	je	SHORT $LN8@IsRootWind

; 6480 :         if (ImGuiWindow* focused_root_window = g.NavWindow->RootWindow)

	mov	eax, DWORD PTR [eax+632]
	test	eax, eax
	je	SHORT $LN8@IsRootWind

; 6481 :             if ((focused_root_window->Flags & ImGuiWindowFlags_Popup) != 0 && focused_root_window->WasActive && focused_root_window != window->RootWindow)

	test	DWORD PTR [eax+8], 33554432		; 02000000H
	je	SHORT $LN8@IsRootWind
	cmp	BYTE PTR [eax+133], 0
	je	SHORT $LN8@IsRootWind
	cmp	eax, DWORD PTR [ecx+632]
	jne	SHORT $LN3@IsRootWind
$LN8@IsRootWind:

; 5821 :     return g.HoveredRootWindow && (g.HoveredRootWindow == g.CurrentWindow->RootWindow) && IsWindowContentHoverable(g.HoveredRootWindow);

	mov	al, 1

; 5822 : }

	ret	0
$LN3@IsRootWind:

; 5821 :     return g.HoveredRootWindow && (g.HoveredRootWindow == g.CurrentWindow->RootWindow) && IsWindowContentHoverable(g.HoveredRootWindow);

	xor	al, al

; 5822 : }

	ret	0
?IsRootWindowOrAnyChildHovered@ImGui@@YA_NXZ ENDP	; ImGui::IsRootWindowOrAnyChildHovered
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?IsRootWindowOrAnyChildFocused@ImGui@@YA_NXZ PROC	; ImGui::IsRootWindowOrAnyChildFocused

; 5814 :     ImGuiContext& g = *GImGui;

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 5815 :     return g.NavWindow && g.NavWindow->RootWindow == g.CurrentWindow->RootWindow;

	mov	eax, DWORD PTR [ecx+6380]
	test	eax, eax
	je	SHORT $LN3@IsRootWind
	mov	ecx, DWORD PTR [ecx+6240]
	mov	eax, DWORD PTR [eax+632]
	cmp	eax, DWORD PTR [ecx+632]
	jne	SHORT $LN3@IsRootWind
	mov	al, 1

; 5816 : }

	ret	0
$LN3@IsRootWind:

; 5815 :     return g.NavWindow && g.NavWindow->RootWindow == g.CurrentWindow->RootWindow;

	xor	al, al

; 5816 : }

	ret	0
?IsRootWindowOrAnyChildFocused@ImGui@@YA_NXZ ENDP	; ImGui::IsRootWindowOrAnyChildFocused
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?IsRootWindowFocused@ImGui@@YA_NXZ PROC			; ImGui::IsRootWindowFocused

; 5808 :     ImGuiContext& g = *GImGui;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	ecx, DWORD PTR [eax+6240]
	mov	eax, DWORD PTR [eax+6380]
	cmp	eax, DWORD PTR [ecx+632]
	sete	al

; 5809 :     return g.NavWindow == g.CurrentWindow->RootWindow;
; 5810 : }

	ret	0
?IsRootWindowFocused@ImGui@@YA_NXZ ENDP			; ImGui::IsRootWindowFocused
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?IsWindowHoveredRect@ImGui@@YA_NXZ PROC			; ImGui::IsWindowHoveredRect

; 3898 : {

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [ecx+6244]
	cmp	eax, DWORD PTR [ecx+6240]
	sete	al

; 3899 :     return GImGui->HoveredWindow == GImGui->CurrentWindow;
; 3900 : }

	ret	0
?IsWindowHoveredRect@ImGui@@YA_NXZ ENDP			; ImGui::IsWindowHoveredRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?IsWindowHovered@ImGui@@YA_NXZ PROC			; ImGui::IsWindowHovered

; 5796 :     ImGuiContext& g = *GImGui;

	mov	edx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 5797 :     return g.HoveredWindow == g.CurrentWindow && IsWindowContentHoverable(g.HoveredRootWindow);

	mov	eax, DWORD PTR [edx+6244]
	cmp	eax, DWORD PTR [edx+6240]
	jne	SHORT $LN3@IsWindowHo

; 6479 :     if (g.NavWindow)

	mov	ecx, DWORD PTR [edx+6380]
	test	ecx, ecx
	je	SHORT $LN8@IsWindowHo

; 6480 :         if (ImGuiWindow* focused_root_window = g.NavWindow->RootWindow)

	mov	ecx, DWORD PTR [ecx+632]
	test	ecx, ecx
	je	SHORT $LN8@IsWindowHo

; 6481 :             if ((focused_root_window->Flags & ImGuiWindowFlags_Popup) != 0 && focused_root_window->WasActive && focused_root_window != window->RootWindow)

	test	DWORD PTR [ecx+8], 33554432		; 02000000H
	je	SHORT $LN8@IsWindowHo
	cmp	BYTE PTR [ecx+133], 0
	je	SHORT $LN8@IsWindowHo
	mov	eax, DWORD PTR [edx+6248]
	cmp	ecx, DWORD PTR [eax+632]
	jne	SHORT $LN3@IsWindowHo
$LN8@IsWindowHo:

; 5797 :     return g.HoveredWindow == g.CurrentWindow && IsWindowContentHoverable(g.HoveredRootWindow);

	mov	al, 1

; 5798 : }

	ret	0
$LN3@IsWindowHo:

; 5797 :     return g.HoveredWindow == g.CurrentWindow && IsWindowContentHoverable(g.HoveredRootWindow);

	xor	al, al

; 5798 : }

	ret	0
?IsWindowHovered@ImGui@@YA_NXZ ENDP			; ImGui::IsWindowHovered
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?IsWindowFocused@ImGui@@YA_NXZ PROC			; ImGui::IsWindowFocused

; 5802 :     ImGuiContext& g = *GImGui;

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [ecx+6380]
	cmp	eax, DWORD PTR [ecx+6240]
	sete	al

; 5803 :     return g.NavWindow == g.CurrentWindow;
; 5804 : }

	ret	0
?IsWindowFocused@ImGui@@YA_NXZ ENDP			; ImGui::IsWindowFocused
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -32						; size = 16
$T2 = -16						; size = 8
$T3 = -8						; size = 8
?SetItemDefaultFocus@ImGui@@YAXXZ PROC			; ImGui::SetItemDefaultFocus

; 4171 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 4172 :     ImGuiContext& g = *GImGui;

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	sub	esp, 32					; 00000020H

; 4173 :     if (g.NavWindow == g.CurrentWindow->RootNavWindow && (g.NavInitDefaultRequest || g.NavInitDefaultResultId != 0))

	mov	eax, DWORD PTR [ecx+6240]
	mov	edx, DWORD PTR [ecx+6380]
	cmp	edx, DWORD PTR [eax+640]
	jne	$LN4@SetItemDef
	cmp	BYTE PTR [ecx+6456], 0
	jne	SHORT $LN3@SetItemDef
	cmp	DWORD PTR [ecx+6460], 0
	je	$LN4@SetItemDef
$LN3@SetItemDef:

; 4174 :     {
; 4175 :         g.NavInitDefaultRequest = false;

	mov	BYTE PTR [ecx+6456], 0

; 4176 :         g.NavInitDefaultResultExplicit = true;

	mov	BYTE PTR [ecx+6480], 1

; 4177 :         g.NavInitDefaultResultId = g.NavWindow->DC.LastItemId;

	mov	eax, DWORD PTR [edx+248]
	mov	DWORD PTR [ecx+6460], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [edx+260]
	subss	xmm0, DWORD PTR [edx+24]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [edx+264]
	subss	xmm0, DWORD PTR [edx+28]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [edx+252]
	subss	xmm0, DWORD PTR [edx+24]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [edx+256]
	subss	xmm0, DWORD PTR [edx+28]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR $T1[ebp], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T3[ebp+4]
	mov	DWORD PTR $T1[ebp+4], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR $T1[ebp+8], eax
	mov	eax, DWORD PTR $T2[ebp+4]
	mov	DWORD PTR $T1[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4178 :         g.NavInitDefaultResultRectRel = ImRect(g.NavWindow->DC.LastItemRect.Min - g.NavWindow->Pos, g.NavWindow->DC.LastItemRect.Max - g.NavWindow->Pos);

	movups	xmm0, XMMWORD PTR $T1[ebp]
	movups	XMMWORD PTR [ecx+6464], xmm0

; 4179 :         if (!IsItemVisible())

	call	?IsItemVisible@ImGui@@YA_NXZ		; ImGui::IsItemVisible
	test	al, al
	jne	SHORT $LN4@SetItemDef

; 4180 :             SetScrollHere();

	push	ecx
	mov	DWORD PTR [esp], 1056964608		; 3f000000H
	call	?SetScrollHere@ImGui@@YAXM@Z		; ImGui::SetScrollHere
	add	esp, 4
$LN4@SetItemDef:

; 4181 :     }
; 4182 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetItemDefaultFocus@ImGui@@YAXXZ ENDP			; ImGui::SetItemDefaultFocus
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?SetItemAllowOverlap@ImGui@@YAXXZ PROC			; ImGui::SetItemAllowOverlap

; 4163 :     ImGuiContext& g = *GImGui;

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 4164 :     if (g.HoveredId == g.CurrentWindow->DC.LastItemId)

	mov	edx, DWORD PTR [ecx+6240]
	mov	eax, DWORD PTR [ecx+6252]
	cmp	eax, DWORD PTR [edx+248]
	jne	SHORT $LN2@SetItemAll

; 4165 :         g.HoveredIdAllowOverlap = true;

	mov	BYTE PTR [ecx+6256], 1
$LN2@SetItemAll:

; 4166 :     if (g.ActiveId == g.CurrentWindow->DC.LastItemId)

	mov	eax, DWORD PTR [ecx+6264]
	cmp	eax, DWORD PTR [edx+248]
	jne	SHORT $LN3@SetItemAll

; 4167 :         g.ActiveIdAllowOverlap = true;

	mov	BYTE PTR [ecx+6274], 1
$LN3@SetItemAll:

; 4168 : }

	ret	0
?SetItemAllowOverlap@ImGui@@YAXXZ ENDP			; ImGui::SetItemAllowOverlap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetItemRectSize@ImGui@@YA?AUImVec2@@XZ PROC		; ImGui::GetItemRectSize

; 4197 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 4198 :     ImGuiWindow* window = GetCurrentWindowRead();
; 4199 :     return window->DC.LastItemRect.GetSize();

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	ecx, DWORD PTR [eax+6240]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 245  :     ImVec2      GetSize() const                 { return ImVec2(Max.x-Min.x, Max.y-Min.y); }

	movss	xmm0, DWORD PTR [ecx+260]
	subss	xmm0, DWORD PTR [ecx+252]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 245  :     ImVec2      GetSize() const                 { return ImVec2(Max.x-Min.x, Max.y-Min.y); }

	movss	xmm0, DWORD PTR [ecx+264]
	subss	xmm0, DWORD PTR [ecx+256]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4200 : }

	pop	ebp
	ret	0
?GetItemRectSize@ImGui@@YA?AUImVec2@@XZ ENDP		; ImGui::GetItemRectSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetItemRectMax@ImGui@@YA?AUImVec2@@XZ PROC		; ImGui::GetItemRectMax

; 4191 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 4192 :     ImGuiWindow* window = GetCurrentWindowRead();
; 4193 :     return window->DC.LastItemRect.Max;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	edx, DWORD PTR [eax+6240]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [edx+260]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+264]
	mov	DWORD PTR [eax+4], ecx

; 4194 : }

	pop	ebp
	ret	0
?GetItemRectMax@ImGui@@YA?AUImVec2@@XZ ENDP		; ImGui::GetItemRectMax
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetItemRectMin@ImGui@@YA?AUImVec2@@XZ PROC		; ImGui::GetItemRectMin

; 4185 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 4186 :     ImGuiWindow* window = GetCurrentWindowRead();
; 4187 :     return window->DC.LastItemRect.Min;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	edx, DWORD PTR [eax+6240]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [edx+252]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+256]
	mov	DWORD PTR [eax+4], ecx

; 4188 : }

	pop	ebp
	ret	0
?GetItemRectMin@ImGui@@YA?AUImVec2@@XZ ENDP		; ImGui::GetItemRectMin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?IsAnyItemFocused@ImGui@@YA_NXZ PROC			; ImGui::IsAnyItemFocused

; 4151 :     return GImGui->NavId != 0 && !GImGui->NavDisableHighlight;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	cmp	DWORD PTR [eax+6384], 0
	je	SHORT $LN3@IsAnyItemF
	cmp	BYTE PTR [eax+6454], 0
	jne	SHORT $LN3@IsAnyItemF
	mov	al, 1

; 4152 : }

	ret	0
$LN3@IsAnyItemF:

; 4151 :     return GImGui->NavId != 0 && !GImGui->NavDisableHighlight;

	xor	al, al

; 4152 : }

	ret	0
?IsAnyItemFocused@ImGui@@YA_NXZ ENDP			; ImGui::IsAnyItemFocused
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?IsAnyItemActive@ImGui@@YA_NXZ PROC			; ImGui::IsAnyItemActive

; 4145 : {

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	cmp	DWORD PTR [eax+6264], 0
	setne	al

; 4146 :     return GImGui->ActiveId != 0;
; 4147 : }

	ret	0
?IsAnyItemActive@ImGui@@YA_NXZ ENDP			; ImGui::IsAnyItemActive
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?IsAnyItemHovered@ImGui@@YA_NXZ PROC			; ImGui::IsAnyItemHovered

; 4141 :     return GImGui->HoveredId != 0 || GImGui->HoveredIdPreviousFrame != 0;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	cmp	DWORD PTR [eax+6252], 0
	jne	SHORT $LN3@IsAnyItemH
	cmp	DWORD PTR [eax+6260], 0
	jne	SHORT $LN3@IsAnyItemH
	xor	al, al

; 4142 : }

	ret	0
$LN3@IsAnyItemH:

; 4141 :     return GImGui->HoveredId != 0 || GImGui->HoveredIdPreviousFrame != 0;

	mov	al, 1

; 4142 : }

	ret	0
?IsAnyItemHovered@ImGui@@YA_NXZ ENDP			; ImGui::IsAnyItemHovered
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?IsItemVisible@ImGui@@YA_NXZ PROC			; ImGui::IsItemVisible
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 792  :     inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [eax+6240]

; 254  :     bool        Overlaps(const ImRect& r) const { return r.Min.y < Max.y  && r.Max.y > Min.y  && r.Min.x < Max.x && r.Max.x > Min.x; }

	movss	xmm0, DWORD PTR [eax+484]
	comiss	xmm0, DWORD PTR [eax+256]
	jbe	SHORT $LN7@IsItemVisi
	movss	xmm0, DWORD PTR [eax+264]
	comiss	xmm0, DWORD PTR [eax+476]
	jbe	SHORT $LN7@IsItemVisi
	movss	xmm0, DWORD PTR [eax+480]
	comiss	xmm0, DWORD PTR [eax+252]
	jbe	SHORT $LN7@IsItemVisi
	movss	xmm0, DWORD PTR [eax+260]
	comiss	xmm0, DWORD PTR [eax+472]
	jbe	SHORT $LN7@IsItemVisi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4157 :     return window->ClipRect.Overlaps(window->DC.LastItemRect);

	mov	al, 1

; 4158 : }

	ret	0
$LN7@IsItemVisi:

; 4157 :     return window->ClipRect.Overlaps(window->DC.LastItemRect);

	xor	al, al

; 4158 : }

	ret	0
?IsItemVisible@ImGui@@YA_NXZ ENDP			; ImGui::IsItemVisible
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_mouse_button$ = 8					; size = 4
?IsItemClicked@ImGui@@YA_NH@Z PROC			; ImGui::IsItemClicked

; 4135 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 4136 :     return IsMouseClicked(mouse_button) && IsItemHovered();

	push	0
	push	DWORD PTR _mouse_button$[ebp]
	call	?IsMouseClicked@ImGui@@YA_NH_N@Z	; ImGui::IsMouseClicked
	add	esp, 8
	test	al, al
	je	SHORT $LN3@IsItemClic
	call	?IsItemHovered@ImGui@@YA_NXZ		; ImGui::IsItemHovered
	test	al, al
	je	SHORT $LN3@IsItemClic
	mov	al, 1

; 4137 : }

	pop	ebp
	ret	0
$LN3@IsItemClic:

; 4136 :     return IsMouseClicked(mouse_button) && IsItemHovered();

	xor	al, al

; 4137 : }

	pop	ebp
	ret	0
?IsItemClicked@ImGui@@YA_NH@Z ENDP			; ImGui::IsItemClicked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?IsItemFocused@ImGui@@YA_NXZ PROC			; ImGui::IsItemFocused

; 4130 :     ImGuiContext& g = *GImGui;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 4131 :     return g.NavId && !g.NavDisableHighlight && g.NavId == g.CurrentWindow->DC.LastItemId;

	mov	ecx, DWORD PTR [eax+6384]
	test	ecx, ecx
	je	SHORT $LN3@IsItemFocu
	cmp	BYTE PTR [eax+6454], 0
	jne	SHORT $LN3@IsItemFocu
	mov	eax, DWORD PTR [eax+6240]
	cmp	ecx, DWORD PTR [eax+248]
	jne	SHORT $LN3@IsItemFocu
	mov	al, 1

; 4132 : }

	ret	0
$LN3@IsItemFocu:

; 4131 :     return g.NavId && !g.NavDisableHighlight && g.NavId == g.CurrentWindow->DC.LastItemId;

	xor	al, al

; 4132 : }

	ret	0
?IsItemFocused@ImGui@@YA_NXZ ENDP			; ImGui::IsItemFocused
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?IsItemActive@ImGui@@YA_NXZ PROC			; ImGui::IsItemActive

; 4119 :     ImGuiContext& g = *GImGui;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 4120 :     if (g.ActiveId)

	mov	ecx, DWORD PTR [eax+6264]
	test	ecx, ecx
	je	SHORT $LN2@IsItemActi
	mov	eax, DWORD PTR [eax+6240]
	cmp	ecx, DWORD PTR [eax+248]
	sete	al

; 4126 : }

	ret	0
$LN2@IsItemActi:

; 4121 :     {
; 4122 :         ImGuiWindow* window = GetCurrentWindowRead();
; 4123 :         return g.ActiveId == window->DC.LastItemId;
; 4124 :     }
; 4125 :     return false;

	xor	al, al

; 4126 : }

	ret	0
?IsItemActive@ImGui@@YA_NXZ ENDP			; ImGui::IsItemActive
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?IsItemHoveredRect@ImGui@@YA_NXZ PROC			; ImGui::IsItemHoveredRect

; 4113 :     ImGuiWindow* window = GetCurrentWindowRead();
; 4114 :     return window->DC.LastItemHoveredRect;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [eax+6240]
	mov	al, BYTE PTR [eax+269]

; 4115 : }

	ret	0
?IsItemHoveredRect@ImGui@@YA_NXZ ENDP			; ImGui::IsItemHoveredRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?IsItemHovered@ImGui@@YA_NXZ PROC			; ImGui::IsItemHovered

; 4104 :     ImGuiWindow* window = GetCurrentWindowRead();
; 4105 :     ImGuiContext& g = *GImGui;
; 4106 :     if (g.NavDisableMouseHover)

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	cmp	BYTE PTR [eax+6455], 0
	jne	?IsItemFocused@ImGui@@YA_NXZ		; ImGui::IsItemFocused

; 4107 :         return IsItemFocused();
; 4108 :     return window->DC.LastItemHoveredAndUsable;

	mov	eax, DWORD PTR [eax+6240]
	mov	al, BYTE PTR [eax+268]

; 4109 : }

	ret	0
?IsItemHovered@ImGui@@YA_NXZ ENDP			; ImGui::IsItemHovered
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -16						; size = 16
?PopClipRect@ImGui@@YAXXZ PROC				; ImGui::PopClipRect

; 3402 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	esi
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	esi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3404 :     window->DrawList->PopClipRect();

	mov	ecx, DWORD PTR [esi+624]
	call	?PopClipRect@ImDrawList@@QAEXXZ		; ImDrawList::PopClipRect

; 3405 :     window->ClipRect = window->DrawList->_ClipRectStack.back();

	mov	eax, DWORD PTR [esi+624]
	mov	ecx, DWORD PTR [eax+52]
	mov	eax, DWORD PTR [eax+60]
	add	ecx, ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movups	xmm0, XMMWORD PTR [eax+ecx*8-16]
	movups	XMMWORD PTR $T1[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3405 :     window->ClipRect = window->DrawList->_ClipRectStack.back();

	movups	xmm0, XMMWORD PTR $T1[ebp]
	movups	XMMWORD PTR [esi+472], xmm0
	pop	esi

; 3406 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PopClipRect@ImGui@@YAXXZ ENDP				; ImGui::PopClipRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -16						; size = 16
_clip_rect_min$ = 8					; size = 4
_clip_rect_max$ = 12					; size = 4
_intersect_with_current_clip_rect$ = 16			; size = 1
?PushClipRect@ImGui@@YAXABUImVec2@@0_N@Z PROC		; ImGui::PushClipRect

; 3395 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3397 :     window->DrawList->PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);

	push	DWORD PTR _intersect_with_current_clip_rect$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3397 :     window->DrawList->PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);

	mov	eax, DWORD PTR _clip_rect_max$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	esi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3397 :     window->DrawList->PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);

	push	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [esi+624]
	push	DWORD PTR [eax]
	mov	eax, DWORD PTR _clip_rect_min$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	?PushClipRect@ImDrawList@@QAEXUImVec2@@0_N@Z ; ImDrawList::PushClipRect

; 3398 :     window->ClipRect = window->DrawList->_ClipRectStack.back();

	mov	eax, DWORD PTR [esi+624]
	mov	ecx, DWORD PTR [eax+52]
	mov	eax, DWORD PTR [eax+60]
	add	ecx, ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movups	xmm0, XMMWORD PTR [eax+ecx*8-16]
	movups	XMMWORD PTR $T1[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3398 :     window->ClipRect = window->DrawList->_ClipRectStack.back();

	movups	xmm0, XMMWORD PTR $T1[ebp]
	movups	XMMWORD PTR [esi+472], xmm0
	pop	esi

; 3399 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PushClipRect@ImGui@@YAXABUImVec2@@0_N@Z ENDP		; ImGui::PushClipRect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_fmt$ = 8						; size = 4
?LogText@ImGui@@YAXPBDZZ PROC				; ImGui::LogText

; 3570 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 3571 :     ImGuiContext& g = *GImGui;

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 3572 :     if (!g.LogEnabled)

	cmp	BYTE PTR [ecx+11600], 0
	je	SHORT $LN4@LogText

; 3573 :         return;
; 3574 : 
; 3575 :     va_list args;
; 3576 :     va_start(args, fmt);
; 3577 :     if (g.LogFile)

	mov	eax, DWORD PTR [ecx+11604]
	test	eax, eax
	je	SHORT $LN3@LogText

; 3578 :     {
; 3579 :         vfprintf(g.LogFile, fmt, args);

	lea	ecx, DWORD PTR _fmt$[ebp+4]
	push	ecx
	push	DWORD PTR _fmt$[ebp]
	push	eax
	call	_vfprintf
	add	esp, 12					; 0000000cH

; 3584 :     }
; 3585 :     va_end(args);
; 3586 : }

	pop	ebp
	ret	0
$LN3@LogText:

; 3580 :     }
; 3581 :     else
; 3582 :     {
; 3583 :         g.LogClipboard->appendv(fmt, args);

	mov	ecx, DWORD PTR [ecx+11608]
	lea	eax, DWORD PTR _fmt$[ebp+4]
	push	eax
	push	DWORD PTR _fmt$[ebp]
	call	?appendv@ImGuiTextBuffer@@QAEXPBDPAD@Z	; ImGuiTextBuffer::appendv
$LN4@LogText:

; 3584 :     }
; 3585 :     va_end(args);
; 3586 : }

	pop	ebp
	ret	0
?LogText@ImGui@@YAXPBDZZ ENDP				; ImGui::LogText
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 8
$T2 = -12						; size = 8
$T3 = -12						; size = 8
_log_to_file$1$ = -1					; size = 1
?LogButtons@ImGui@@YAXXZ PROC				; ImGui::LogButtons

; 6844 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi

; 6845 :     ImGuiContext& g = *GImGui;

	mov	edi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 6846 : 
; 6847 :     PushID("LogButtons");

	push	OFFSET $SG119397
	call	?PushID@ImGui@@YAXPBD@Z			; ImGui::PushID

; 6848 :     const bool log_to_tty = Button("Log To TTY"); SameLine();

	lea	eax, DWORD PTR $T3[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T3[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6848 :     const bool log_to_tty = Button("Log To TTY"); SameLine();

	push	eax
	push	OFFSET $SG119398
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T3[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6848 :     const bool log_to_tty = Button("Log To TTY"); SameLine();

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 4
	mov	bl, al
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 6849 :     const bool log_to_file = Button("Log To File"); SameLine();

	lea	eax, DWORD PTR $T2[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T2[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6849 :     const bool log_to_file = Button("Log To File"); SameLine();

	push	eax
	push	OFFSET $SG119399
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T2[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6849 :     const bool log_to_file = Button("Log To File"); SameLine();

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 8
	mov	BYTE PTR _log_to_file$1$[ebp], al
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 6850 :     const bool log_to_clipboard = Button("Log To Clipboard"); SameLine();

	lea	eax, DWORD PTR $T1[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6850 :     const bool log_to_clipboard = Button("Log To Clipboard"); SameLine();

	push	eax
	push	OFFSET $SG119400
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6850 :     const bool log_to_clipboard = Button("Log To Clipboard"); SameLine();

	call	?Button@ImGui@@YA_NPBDABUImVec2@@@Z	; ImGui::Button
	add	esp, 8
	mov	bh, al
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 6851 :     PushItemWidth(80.0f);

	add	esp, 4
	mov	DWORD PTR [esp], 1117782016		; 42a00000H
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth

; 6852 :     PushAllowKeyboardFocus(false);

	push	0
	call	?PushAllowKeyboardFocus@ImGui@@YAX_N@Z	; ImGui::PushAllowKeyboardFocus

; 6853 :     SliderInt("Depth", &g.LogAutoExpandMaxDepth, 0, 9, NULL);

	push	0
	push	9
	push	0
	lea	esi, DWORD PTR [edi+11616]
	push	esi
	push	OFFSET $SG119401
	call	?SliderInt@ImGui@@YA_NPBDPAHHH0@Z	; ImGui::SliderInt
	add	esp, 28					; 0000001cH

; 6854 :     PopAllowKeyboardFocus();

	call	?PopAllowKeyboardFocus@ImGui@@YAXXZ	; ImGui::PopAllowKeyboardFocus

; 6855 :     PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 6856 :     PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 6857 : 
; 6858 :     // Start logging at the end of the function so that the buttons don't appear in the log
; 6859 :     if (log_to_tty)

	test	bl, bl
	je	SHORT $LN2@LogButtons

; 6860 :         LogToTTY(g.LogAutoExpandMaxDepth);

	push	DWORD PTR [esi]
	call	?LogToTTY@ImGui@@YAXH@Z			; ImGui::LogToTTY
	add	esp, 4
$LN2@LogButtons:

; 6861 :     if (log_to_file)

	cmp	BYTE PTR _log_to_file$1$[ebp], 0
	je	SHORT $LN3@LogButtons

; 6862 :         LogToFile(g.LogAutoExpandMaxDepth, g.IO.LogFilename);

	push	DWORD PTR [edi+24]
	push	DWORD PTR [esi]
	call	?LogToFile@ImGui@@YAXHPBD@Z		; ImGui::LogToFile
	add	esp, 8
$LN3@LogButtons:

; 6863 :     if (log_to_clipboard)

	test	bh, bh
	je	SHORT $LN4@LogButtons

; 6864 :         LogToClipboard(g.LogAutoExpandMaxDepth);

	push	DWORD PTR [esi]
	call	?LogToClipboard@ImGui@@YAXH@Z		; ImGui::LogToClipboard
	add	esp, 4
$LN4@LogButtons:
	pop	edi
	pop	esi
	pop	ebx

; 6865 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LogButtons@ImGui@@YAXXZ ENDP				; ImGui::LogButtons
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -1						; size = 1
?LogFinish@ImGui@@YAXXZ PROC				; ImGui::LogFinish

; 6820 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 6821 :     ImGuiContext& g = *GImGui;

	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 6822 :     if (!g.LogEnabled)

	cmp	BYTE PTR [esi+11600], 0
	je	$LN6@LogFinish

; 6823 :         return;
; 6824 : 
; 6825 :     LogText(IM_NEWLINE);

	push	OFFSET $SG119383
	call	?LogText@ImGui@@YAXPBDZZ		; ImGui::LogText
	add	esp, 4

; 6826 :     g.LogEnabled = false;

	mov	BYTE PTR [esi+11600], 0

; 6827 :     if (g.LogFile != NULL)

	cmp	DWORD PTR [esi+11604], 0
	je	SHORT $LN3@LogFinish

; 6828 :     {
; 6829 :         if (g.LogFile == stdout)

	push	edi
	mov	edi, DWORD PTR [esi+11604]
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4

; 6830 :             fflush(g.LogFile);

	push	edi
	cmp	edi, eax
	jne	SHORT $LN4@LogFinish
	call	DWORD PTR __imp__fflush

; 6831 :         else

	jmp	SHORT $LN19@LogFinish
$LN4@LogFinish:

; 6832 :             fclose(g.LogFile);

	call	DWORD PTR __imp__fclose
$LN19@LogFinish:
	add	esp, 4

; 6833 :         g.LogFile = NULL;

	mov	DWORD PTR [esi+11604], 0
	pop	edi
$LN3@LogFinish:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1004 :     int                 size() const { return Buf.Size - 1; }

	mov	ecx, DWORD PTR [esi+11608]
	mov	eax, DWORD PTR [ecx]
	dec	eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6835 :     if (g.LogClipboard->size() > 1)

	cmp	eax, 1
	jle	SHORT $LN6@LogFinish

; 6836 :     {
; 6837 :         SetClipboardText(g.LogClipboard->begin());

	push	DWORD PTR [ecx+8]
	call	?SetClipboardText@ImGui@@YAXPBD@Z	; ImGui::SetClipboardText

; 6838 :         g.LogClipboard->clear();

	mov	esi, DWORD PTR [esi+11608]
	add	esp, 4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN17@LogFinish
	push	eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+8], 0
$LN17@LogFinish:

; 1006 :     void                clear() { Buf.clear(); Buf.push_back(0); }

	lea	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR $T1[ebp], 0
	push	eax
	mov	ecx, esi
	call	?push_back@?$ImVector@D@@QAEXABD@Z	; ImVector<char>::push_back
$LN6@LogFinish:
	pop	esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6840 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LogFinish@ImGui@@YAXXZ ENDP				; ImGui::LogFinish
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_max_depth$ = 8						; size = 4
?LogToClipboard@ImGui@@YAXH@Z PROC			; ImGui::LogToClipboard

; 6806 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 6807 :     ImGuiContext& g = *GImGui;

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 6808 :     if (g.LogEnabled)

	cmp	BYTE PTR [ecx+11600], 0
	jne	SHORT $LN3@LogToClipb
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 792  :     inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6812 :     g.LogEnabled = true;

	mov	BYTE PTR [ecx+11600], 1

; 6813 :     g.LogFile = NULL;

	mov	DWORD PTR [ecx+11604], 0

; 6814 :     g.LogStartDepth = window->DC.TreeDepth;

	mov	eax, DWORD PTR [eax+244]
	mov	DWORD PTR [ecx+11612], eax

; 6815 :     if (max_depth >= 0)

	mov	eax, DWORD PTR _max_depth$[ebp]
	test	eax, eax
	js	SHORT $LN3@LogToClipb

; 6816 :         g.LogAutoExpandMaxDepth = max_depth;

	mov	DWORD PTR [ecx+11616], eax
$LN3@LogToClipb:

; 6817 : }

	pop	ebp
	ret	0
?LogToClipboard@ImGui@@YAXH@Z ENDP			; ImGui::LogToClipboard
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_max_depth$ = 8						; size = 4
_filename$ = 12						; size = 4
?LogToFile@ImGui@@YAXHPBD@Z PROC			; ImGui::LogToFile

; 6779 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 6780 :     ImGuiContext& g = *GImGui;

	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 6781 :     if (g.LogEnabled)

	cmp	BYTE PTR [esi+11600], 0
	jne	SHORT $LN6@LogToFile

; 6785 :     if (!filename)

	mov	eax, DWORD PTR _filename$[ebp]
	push	edi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 792  :     inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }

	mov	edi, DWORD PTR [esi+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6785 :     if (!filename)

	test	eax, eax
	jne	SHORT $LN4@LogToFile

; 6786 :     {
; 6787 :         filename = g.IO.LogFilename;

	mov	eax, DWORD PTR [esi+24]

; 6788 :         if (!filename)

	test	eax, eax
	je	SHORT $LN10@LogToFile
$LN4@LogToFile:

; 6789 :             return;
; 6790 :     }
; 6791 : 
; 6792 :     g.LogFile = ImFileOpen(filename, "ab");

	push	OFFSET $SG119369
	push	eax
	call	?ImFileOpen@@YAPAU_iobuf@@PBD0@Z	; ImFileOpen
	add	esp, 8
	mov	DWORD PTR [esi+11604], eax

; 6793 :     if (!g.LogFile)

	test	eax, eax
	je	SHORT $LN10@LogToFile

; 6794 :     {
; 6795 :         IM_ASSERT(g.LogFile != NULL); // Consider this an error
; 6796 :         return;
; 6797 :     }
; 6798 :     g.LogEnabled = true;

	mov	BYTE PTR [esi+11600], 1

; 6799 :     g.LogStartDepth = window->DC.TreeDepth;

	mov	eax, DWORD PTR [edi+244]
	mov	DWORD PTR [esi+11612], eax

; 6800 :     if (max_depth >= 0)

	mov	eax, DWORD PTR _max_depth$[ebp]
	test	eax, eax
	js	SHORT $LN10@LogToFile

; 6801 :         g.LogAutoExpandMaxDepth = max_depth;

	mov	DWORD PTR [esi+11616], eax
$LN10@LogToFile:
	pop	edi
$LN6@LogToFile:
	pop	esi

; 6802 : }

	pop	ebp
	ret	0
?LogToFile@ImGui@@YAXHPBD@Z ENDP			; ImGui::LogToFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_max_depth$ = 8						; size = 4
?LogToTTY@ImGui@@YAXH@Z PROC				; ImGui::LogToTTY

; 6764 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	edi

; 6765 :     ImGuiContext& g = *GImGui;

	mov	edi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 6766 :     if (g.LogEnabled)

	cmp	BYTE PTR [edi+11600], 0
	jne	SHORT $LN3@LogToTTY
	push	esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 792  :     inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }

	mov	esi, DWORD PTR [edi+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6771 :     g.LogFile = stdout;

	push	1
	mov	BYTE PTR [edi+11600], 1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	mov	DWORD PTR [edi+11604], eax

; 6772 :     g.LogStartDepth = window->DC.TreeDepth;

	mov	eax, DWORD PTR [esi+244]
	mov	DWORD PTR [edi+11612], eax

; 6773 :     if (max_depth >= 0)

	mov	eax, DWORD PTR _max_depth$[ebp]
	pop	esi
	test	eax, eax
	js	SHORT $LN3@LogToTTY

; 6774 :         g.LogAutoExpandMaxDepth = max_depth;

	mov	DWORD PTR [edi+11616], eax
$LN3@LogToTTY:
	pop	edi

; 6775 : }

	pop	ebp
	ret	0
?LogToTTY@ImGui@@YAXH@Z ENDP				; ImGui::LogToTTY
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?CloseCurrentPopup@ImGui@@YAXXZ PROC			; ImGui::CloseCurrentPopup

; 4340 :     ImGuiContext& g = *GImGui;

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 4341 :     int popup_idx = g.CurrentPopupStack.Size - 1;

	mov	eax, DWORD PTR [ecx+6368]
	sub	eax, 1

; 4342 :     if (popup_idx < 0 || popup_idx > g.OpenPopupStack.Size || g.CurrentPopupStack[popup_idx].PopupId != g.OpenPopupStack[popup_idx].PopupId)

	js	SHORT $LN5@CloseCurre
	cmp	eax, DWORD PTR [ecx+6356]
	jg	SHORT $LN5@CloseCurre
	push	esi
	mov	esi, DWORD PTR [ecx+6364]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	mov	edx, eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4342 :     if (popup_idx < 0 || popup_idx > g.OpenPopupStack.Size || g.CurrentPopupStack[popup_idx].PopupId != g.OpenPopupStack[popup_idx].PopupId)

	mov	ecx, DWORD PTR [ecx+6376]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	shl	edx, 5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4342 :     if (popup_idx < 0 || popup_idx > g.OpenPopupStack.Size || g.CurrentPopupStack[popup_idx].PopupId != g.OpenPopupStack[popup_idx].PopupId)

	mov	ecx, DWORD PTR [edx+ecx]
	cmp	ecx, DWORD PTR [esi+edx]
	jne	SHORT $LN20@CloseCurre

; 4344 :     while (popup_idx > 0 && g.OpenPopupStack[popup_idx].Window && (g.OpenPopupStack[popup_idx].Window->Flags & ImGuiWindowFlags_ChildMenu))

	test	eax, eax
	jle	SHORT $LN19@CloseCurre
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	lea	ecx, DWORD PTR [esi+4]
	add	ecx, edx
	npad	4
$LL2@CloseCurre:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4344 :     while (popup_idx > 0 && g.OpenPopupStack[popup_idx].Window && (g.OpenPopupStack[popup_idx].Window->Flags & ImGuiWindowFlags_ChildMenu))

	mov	edx, DWORD PTR [ecx]
	test	edx, edx
	je	SHORT $LN19@CloseCurre
	test	DWORD PTR [edx+8], 134217728		; 08000000H
	je	SHORT $LN19@CloseCurre

; 4345 :         popup_idx--;

	dec	eax
	sub	ecx, 32					; 00000020H
	test	eax, eax
	jg	SHORT $LL2@CloseCurre
$LN19@CloseCurre:

; 4346 :     ClosePopupToLevel(popup_idx);

	push	eax
	call	?ClosePopupToLevel@@YAXH@Z		; ClosePopupToLevel
	add	esp, 4
$LN20@CloseCurre:
	pop	esi
$LN5@CloseCurre:

; 4347 : }

	ret	0
?CloseCurrentPopup@ImGui@@YAXXZ ENDP			; ImGui::CloseCurrentPopup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?EndPopup@ImGui@@YAXXZ PROC				; ImGui::EndPopup

; 4420 : {

	npad	2
	push	esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [esi+6240]
	mov	BYTE PTR [eax+134], 1
	mov	esi, DWORD PTR [esi+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4424 :     ImGui::End();

	call	?End@ImGui@@YAXXZ			; ImGui::End

; 4425 :     if (!(window->Flags & ImGuiWindowFlags_Modal))

	test	DWORD PTR [esi+8], 67108864		; 04000000H
	pop	esi
	jne	SHORT $LN2@EndPopup

; 4426 :         ImGui::PopStyleVar();

	push	1
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar
	pop	ecx
$LN2@EndPopup:

; 4427 : }

	ret	0
?EndPopup@ImGui@@YAXXZ ENDP				; ImGui::EndPopup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_str_id$ = 8						; size = 4
_mouse_button$ = 12					; size = 4
?BeginPopupContextVoid@ImGui@@YA_NPBDH@Z PROC		; ImGui::BeginPopupContextVoid

; 4454 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _str_id$[ebp]
	test	eax, eax
	push	esi
	mov	esi, OFFSET $SG117765
	cmovne	esi, eax

; 4455 :     if (!str_id) str_id = "void_context_menu";
; 4456 :     if (!IsAnyWindowHovered() && IsMouseClicked(mouse_button))

	call	?IsAnyWindowHovered@ImGui@@YA_NXZ	; ImGui::IsAnyWindowHovered
	test	al, al
	jne	SHORT $LN3@BeginPopup
	push	0
	push	DWORD PTR _mouse_button$[ebp]
	call	?IsMouseClicked@ImGui@@YA_NH_N@Z	; ImGui::IsMouseClicked
	add	esp, 8
	test	al, al
	je	SHORT $LN3@BeginPopup

; 4457 :         OpenPopupEx(str_id, true);

	push	1
	push	esi
	call	?OpenPopupEx@ImGui@@YAXPBD_N@Z		; ImGui::OpenPopupEx
	add	esp, 8
$LN3@BeginPopup:

; 4458 :     return BeginPopup(str_id);

	push	esi
	call	?BeginPopup@ImGui@@YA_NPBD@Z		; ImGui::BeginPopup
	add	esp, 4
	pop	esi

; 4459 : }

	pop	ebp
	ret	0
?BeginPopupContextVoid@ImGui@@YA_NPBDH@Z ENDP		; ImGui::BeginPopupContextVoid
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_also_over_items$ = 8					; size = 1
_str_id$ = 12						; size = 4
_mouse_button$ = 16					; size = 4
?BeginPopupContextWindow@ImGui@@YA_N_NPBDH@Z PROC	; ImGui::BeginPopupContextWindow

; 4445 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _str_id$[ebp]
	test	eax, eax
	push	esi
	mov	esi, OFFSET $SG117756
	cmovne	esi, eax

; 4446 :     if (!str_id) str_id = "window_context_menu";
; 4447 :     if (IsWindowHoveredRect() && IsMouseClicked(mouse_button))

	call	?IsWindowHoveredRect@ImGui@@YA_NXZ	; ImGui::IsWindowHoveredRect
	test	al, al
	je	SHORT $LN4@BeginPopup
	push	0
	push	DWORD PTR _mouse_button$[ebp]
	call	?IsMouseClicked@ImGui@@YA_NH_N@Z	; ImGui::IsMouseClicked
	add	esp, 8
	test	al, al
	je	SHORT $LN4@BeginPopup

; 4448 :         if (also_over_items || !IsAnyItemHovered())

	cmp	BYTE PTR _also_over_items$[ebp], 0
	jne	SHORT $LN5@BeginPopup
	call	?IsAnyItemHovered@ImGui@@YA_NXZ		; ImGui::IsAnyItemHovered
	test	al, al
	jne	SHORT $LN4@BeginPopup
$LN5@BeginPopup:

; 4449 :             OpenPopupEx(str_id, true);

	push	1
	push	esi
	call	?OpenPopupEx@ImGui@@YAXPBD_N@Z		; ImGui::OpenPopupEx
	add	esp, 8
$LN4@BeginPopup:

; 4450 :     return BeginPopup(str_id);

	push	esi
	call	?BeginPopup@ImGui@@YA_NPBD@Z		; ImGui::BeginPopup
	add	esp, 4
	pop	esi

; 4451 : }

	pop	ebp
	ret	0
?BeginPopupContextWindow@ImGui@@YA_N_NPBDH@Z ENDP	; ImGui::BeginPopupContextWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_str_id$ = 8						; size = 4
_mouse_button$ = 12					; size = 4
?BeginPopupContextItem@ImGui@@YA_NPBDH@Z PROC		; ImGui::BeginPopupContextItem

; 4438 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 4439 :     if (IsItemHovered() && IsMouseClicked(mouse_button))

	call	?IsItemHovered@ImGui@@YA_NXZ		; ImGui::IsItemHovered
	test	al, al
	je	SHORT $LN2@BeginPopup
	push	0
	push	DWORD PTR _mouse_button$[ebp]
	call	?IsMouseClicked@ImGui@@YA_NH_N@Z	; ImGui::IsMouseClicked
	add	esp, 8
	test	al, al
	je	SHORT $LN2@BeginPopup

; 4440 :         OpenPopupEx(str_id, false);

	push	0
	push	DWORD PTR _str_id$[ebp]
	call	?OpenPopupEx@ImGui@@YAXPBD_N@Z		; ImGui::OpenPopupEx
	add	esp, 8
$LN2@BeginPopup:

; 4441 :     return BeginPopup(str_id);

	push	DWORD PTR _str_id$[ebp]
	call	?BeginPopup@ImGui@@YA_NPBD@Z		; ImGui::BeginPopup
	add	esp, 4

; 4442 : }

	pop	ebp
	ret	0
?BeginPopupContextItem@ImGui@@YA_NPBDH@Z ENDP		; ImGui::BeginPopupContextItem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_name$ = 8						; size = 4
_p_open$ = 12						; size = 4
_extra_flags$ = 16					; size = 4
?BeginPopupModal@ImGui@@YA_NPBDPA_NH@Z PROC		; ImGui::BeginPopupModal

; 4396 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 4397 :     ImGuiContext& g = *GImGui;
; 4398 :     ImGuiWindow* window = g.CurrentWindow;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	ebx

; 4399 :     const ImGuiID id = window->GetID(name);

	mov	ebx, DWORD PTR _name$[ebp]
	push	edi
	mov	ecx, DWORD PTR [eax+6240]
	push	0
	push	ebx
	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID
	mov	edi, eax

; 4400 :     if (!IsPopupOpen(id))

	push	edi
	call	?IsPopupOpen@@YA_NI@Z			; IsPopupOpen
	add	esp, 4
	test	al, al
	jne	SHORT $LN2@BeginPopup

; 4351 :     ImGuiContext& g = *GImGui;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	pop	edi
	pop	ebx

; 4352 :     g.SetNextWindowPosCond = g.SetNextWindowSizeCond = g.SetNextWindowContentSizeCond = g.SetNextWindowCollapsedCond = 0;

	mov	DWORD PTR [eax+6560], 0
	mov	DWORD PTR [eax+6556], 0
	mov	DWORD PTR [eax+6552], 0
	mov	DWORD PTR [eax+6548], 0

; 4353 :     g.SetNextWindowSizeConstraint = g.SetNextWindowFocus = false;

	mov	WORD PTR [eax+6588], 0

; 4401 :     {
; 4402 :         ClearSetNextWindowData(); // We behave like Begin() and need to consume those values
; 4403 :         return false;

	xor	al, al

; 4417 : }

	pop	ebp
	ret	0
$LN2@BeginPopup:

; 4404 :     }
; 4405 : 
; 4406 :     ImGuiWindowFlags flags = extra_flags|ImGuiWindowFlags_Popup|ImGuiWindowFlags_Modal|ImGuiWindowFlags_NoCollapse|ImGuiWindowFlags_NoSavedSettings;

	mov	eax, DWORD PTR _extra_flags$[ebp]
	push	esi

; 4407 :     bool is_open = ImGui::Begin(name, p_open, flags);

	mov	esi, DWORD PTR _p_open$[ebp]
	or	eax, 100663584				; 06000120H
	push	eax
	push	esi
	push	ebx
	call	?Begin@ImGui@@YA_NPBDPA_NH@Z		; ImGui::Begin
	mov	bl, al
	add	esp, 12					; 0000000cH

; 4408 :     if (!is_open || (p_open && !*p_open)) // NB: is_open can be 'false' when the popup is completely clipped (e.g. zero size display)

	test	bl, bl
	je	SHORT $LN4@BeginPopup
	test	esi, esi
	je	SHORT $LN3@BeginPopup
	cmp	BYTE PTR [esi], 0
	je	SHORT $LN4@BeginPopup
$LN3@BeginPopup:
	pop	esi
	pop	edi

; 4414 :     }
; 4415 : 
; 4416 :     return is_open;

	mov	al, bl
	pop	ebx

; 4417 : }

	pop	ebp
	ret	0
$LN4@BeginPopup:

; 4409 :     {
; 4410 :         ImGui::EndPopup();

	call	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup

; 4411 :         if (is_open)

	test	bl, bl
	je	SHORT $LN5@BeginPopup

; 4412 :             ClosePopup(id);

	push	edi
	call	?ClosePopup@@YAXI@Z			; ClosePopup
	add	esp, 4
$LN5@BeginPopup:

; 4413 :         return false;

	pop	esi
	pop	edi
	xor	al, al
	pop	ebx

; 4417 : }

	pop	ebp
	ret	0
?BeginPopupModal@ImGui@@YA_NPBDPA_NH@Z ENDP		; ImGui::BeginPopupModal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_str_id$ = 8						; size = 4
?BeginPopup@ImGui@@YA_NPBD@Z PROC			; ImGui::BeginPopup

; 4386 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 4387 :     if (GImGui->OpenPopupStack.Size <= GImGui->CurrentPopupStack.Size)	// Early out for performance

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [ecx+6356]
	cmp	eax, DWORD PTR [ecx+6368]
	jg	SHORT $LN2@BeginPopup

; 4352 :     g.SetNextWindowPosCond = g.SetNextWindowSizeCond = g.SetNextWindowContentSizeCond = g.SetNextWindowCollapsedCond = 0;

	mov	DWORD PTR [ecx+6560], 0

; 4388 :     {
; 4389 :         ClearSetNextWindowData(); // We behave like Begin() and need to consume those values
; 4390 :         return false;

	xor	al, al

; 4352 :     g.SetNextWindowPosCond = g.SetNextWindowSizeCond = g.SetNextWindowContentSizeCond = g.SetNextWindowCollapsedCond = 0;

	mov	DWORD PTR [ecx+6556], 0
	mov	DWORD PTR [ecx+6552], 0
	mov	DWORD PTR [ecx+6548], 0

; 4353 :     g.SetNextWindowSizeConstraint = g.SetNextWindowFocus = false;

	mov	WORD PTR [ecx+6588], 0

; 4393 : }

	pop	ebp
	ret	0
$LN2@BeginPopup:

; 4391 :     }
; 4392 :     return BeginPopupEx(str_id, ImGuiWindowFlags_ShowBorders);

	push	128					; 00000080H
	push	DWORD PTR _str_id$[ebp]
	call	?BeginPopupEx@@YA_NPBDH@Z		; BeginPopupEx
	add	esp, 8

; 4393 : }

	pop	ebp
	ret	0
?BeginPopup@ImGui@@YA_NPBD@Z ENDP			; ImGui::BeginPopup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_str_id$ = 8						; size = 4
?OpenPopup@ImGui@@YAXPBD@Z PROC				; ImGui::OpenPopup

; 4274 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 4275 :     ImGui::OpenPopupEx(str_id, false);

	push	0
	push	DWORD PTR _str_id$[ebp]
	call	?OpenPopupEx@ImGui@@YAXPBD_N@Z		; ImGui::OpenPopupEx
	add	esp, 8

; 4276 : }

	pop	ebp
	ret	0
?OpenPopup@ImGui@@YAXPBD@Z ENDP				; ImGui::OpenPopup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_shortcut$ = 12						; size = 4
_p_selected$ = 16					; size = 4
_enabled$ = 20						; size = 1
?MenuItem@ImGui@@YA_NPBD0PA_N_N@Z PROC			; ImGui::MenuItem

; 9842 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 9843 :     if (MenuItem(label, shortcut, p_selected ? *p_selected : false, enabled))

	mov	esi, DWORD PTR _p_selected$[ebp]
	test	esi, esi
	je	SHORT $LN5@MenuItem
	mov	al, BYTE PTR [esi]
	jmp	SHORT $LN6@MenuItem
$LN5@MenuItem:
	xor	al, al
$LN6@MenuItem:
	push	DWORD PTR _enabled$[ebp]
	push	eax
	push	DWORD PTR _shortcut$[ebp]
	push	DWORD PTR _label$[ebp]
	call	?MenuItem@ImGui@@YA_NPBD0_N1@Z		; ImGui::MenuItem
	add	esp, 16					; 00000010H
	test	al, al
	je	SHORT $LN2@MenuItem

; 9844 :     {
; 9845 :         if (p_selected)

	test	esi, esi
	je	SHORT $LN3@MenuItem

; 9846 :             *p_selected = !*p_selected;

	cmp	BYTE PTR [esi], 0
	sete	al
	mov	BYTE PTR [esi], al
$LN3@MenuItem:

; 9847 :         return true;

	mov	al, 1
	pop	esi

; 9850 : }

	pop	ebp
	ret	0
$LN2@MenuItem:

; 9848 :     }
; 9849 :     return false;

	xor	al, al
	pop	esi

; 9850 : }

	pop	ebp
	ret	0
?MenuItem@ImGui@@YA_NPBD0PA_N_N@Z ENDP			; ImGui::MenuItem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T3 = -36						; size = 8
$T4 = -36						; size = 8
_label_size$ = -36					; size = 8
$T5 = -28						; size = 8
$T6 = -28						; size = 8
_shortcut_size$ = -28					; size = 8
_pos$ = -20						; size = 8
$T7 = -12						; size = 8
$T8 = -12						; size = 8
_extra_w$1$ = -8					; size = 4
_w$ = -8						; size = 4
_pressed$1$ = -1					; size = 1
_label$ = 8						; size = 4
_shortcut$ = 12						; size = 4
_selected$ = 16						; size = 1
_enabled$ = 20						; size = 1
?MenuItem@ImGui@@YA_NPBD0_N1@Z PROC			; ImGui::MenuItem

; 9815 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9815 : {

	sub	esp, 36					; 00000024H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	push	esi
	mov	BYTE PTR [eax+134], 1
	mov	esi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9817 :     if (window->SkipItems)

	cmp	BYTE PTR [esi+137], 0
	je	SHORT $LN2@MenuItem

; 9818 :         return false;

	xor	al, al
	pop	esi

; 9839 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@MenuItem:

; 9819 : 
; 9820 :     ImGuiContext& g = *GImGui;
; 9821 :     ImVec2 pos = window->DC.CursorPos;

	mov	eax, DWORD PTR [esi+192]
	push	ebx
	mov	ebx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	edi

; 9822 :     ImVec2 label_size = CalcTextSize(label, NULL, true);

	push	ecx
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	push	1
	mov	DWORD PTR _pos$[ebp], eax
	mov	eax, DWORD PTR [esi+196]
	push	0
	push	DWORD PTR _label$[ebp]
	mov	DWORD PTR _pos$[ebp+4], eax
	lea	eax, DWORD PTR _label_size$[ebp]
	push	eax
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize

; 9823 :     ImVec2 shortcut_size = shortcut ? CalcTextSize(shortcut, NULL) : ImVec2(0.0f, 0.0f);

	mov	edi, DWORD PTR _shortcut$[ebp]
	add	esp, 20					; 00000014H
	test	edi, edi
	je	SHORT $LN6@MenuItem
	push	ecx
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	lea	eax, DWORD PTR $T8[ebp]
	push	0
	push	0
	push	edi
	push	eax
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
	add	esp, 20					; 00000014H
	mov	ecx, eax
	jmp	SHORT $LN7@MenuItem
$LN6@MenuItem:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T7[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9823 :     ImVec2 shortcut_size = shortcut ? CalcTextSize(shortcut, NULL) : ImVec2(0.0f, 0.0f);

	lea	ecx, DWORD PTR $T7[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T7[ebp+4], 0
$LN7@MenuItem:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9824 :     float w = window->MenuColumns.DeclColumns(label_size.x, shortcut_size.x, (float)(int)(g.FontSize * 1.20f)); // Feedback for next frame

	movss	xmm0, DWORD PTR [ebx+6172]
	sub	esp, 12					; 0000000cH
	mulss	xmm0, DWORD PTR __real@3f99999a
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _shortcut_size$[ebp], eax
	mov	eax, DWORD PTR [ecx+4]
	lea	ecx, DWORD PTR [esi+528]
	mov	DWORD PTR _shortcut_size$[ebp+4], eax
	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _shortcut_size$[ebp]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _label_size$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?DeclColumns@ImGuiSimpleColumns@@QAEMMMM@Z ; ImGuiSimpleColumns::DeclColumns

; 9825 :     float extra_w = ImMax(0.0f, GetContentRegionAvail().x - w);

	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	fstp	DWORD PTR _w$[ebp]
	call	?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetContentRegionAvail
	movss	xmm0, DWORD PTR _w$[ebp]
	mov	ecx, 80					; 00000050H
	cmp	BYTE PTR _enabled$[ebp], 0
	xorps	xmm2, xmm2
	movss	xmm1, DWORD PTR [eax]

; 9827 :     bool pressed = Selectable(label, false, ImGuiSelectableFlags_MenuItem | ImGuiSelectableFlags_DrawFillAvailWidth | (enabled ? 0 : ImGuiSelectableFlags_Disabled), ImVec2(w, 0.0f));

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	subss	xmm1, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp], xmm0
	mov	eax, 112				; 00000070H
	mov	DWORD PTR $T3[ebp+4], 0
	cmovne	eax, ecx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9827 :     bool pressed = Selectable(label, false, ImGuiSelectableFlags_MenuItem | ImGuiSelectableFlags_DrawFillAvailWidth | (enabled ? 0 : ImGuiSelectableFlags_Disabled), ImVec2(w, 0.0f));

	push	eax
	push	0
	push	DWORD PTR _label$[ebp]
	maxss	xmm1, xmm2
	movss	DWORD PTR _extra_w$1$[ebp], xmm1
	call	?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ; ImGui::Selectable

; 9828 :     if (shortcut_size.x > 0.0f)

	movss	xmm0, DWORD PTR _shortcut_size$[ebp]
	xorps	xmm1, xmm1
	movss	xmm2, DWORD PTR _pos$[ebp]
	add	esp, 20					; 00000014H
	comiss	xmm0, xmm1
	mov	BYTE PTR _pressed$1$[ebp], al
	jbe	SHORT $LN3@MenuItem

; 9829 :     {
; 9830 :         PushStyleColor(ImGuiCol_Text, g.Style.Colors[ImGuiCol_TextDisabled]);

	lea	ecx, DWORD PTR [ebx+5464]
	push	ecx
	push	0
	call	?PushStyleColor@ImGui@@YAXHABUImVec4@@@Z ; ImGui::PushStyleColor

; 9831 :         RenderText(pos + ImVec2(window->MenuColumns.Pos[1] + extra_w, 0.0f), shortcut, NULL, false);

	movss	xmm1, DWORD PTR [esi+548]
	addss	xmm1, DWORD PTR _extra_w$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR _pos$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9831 :         RenderText(pos + ImVec2(window->MenuColumns.Pos[1] + extra_w, 0.0f), shortcut, NULL, false);

	push	0
	push	0
	push	edi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T6[ebp], xmm0
	movss	xmm0, DWORD PTR _pos$[ebp+4]
	movss	DWORD PTR $T6[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9831 :         RenderText(pos + ImVec2(window->MenuColumns.Pos[1] + extra_w, 0.0f), shortcut, NULL, false);

	push	DWORD PTR $T6[ebp+4]
	push	DWORD PTR $T6[ebp]
	call	?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z	; ImGui::RenderText

; 9832 :         PopStyleColor();

	push	1
	call	?PopStyleColor@ImGui@@YAXH@Z		; ImGui::PopStyleColor
	movss	xmm2, DWORD PTR _pos$[ebp]
	add	esp, 32					; 00000020H
$LN3@MenuItem:

; 9833 :     }
; 9834 : 
; 9835 :     if (selected)

	cmp	BYTE PTR _selected$[ebp], 0
	je	SHORT $LN4@MenuItem

; 9836 :         RenderCheckMark(pos + ImVec2(window->MenuColumns.Pos[2] + extra_w + g.FontSize * 0.20f, 0.0f), GetColorU32(enabled ? ImGuiCol_Text : ImGuiCol_TextDisabled));

	movss	xmm1, DWORD PTR [esi+552]
	movss	xmm0, DWORD PTR [ebx+6172]
	addss	xmm1, DWORD PTR _extra_w$1$[ebp]
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	movzx	eax, BYTE PTR _enabled$[ebp]
	push	ecx
	xor	eax, 1
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	addss	xmm1, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR _pos$[ebp+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9836 :         RenderCheckMark(pos + ImVec2(window->MenuColumns.Pos[2] + extra_w + g.FontSize * 0.20f, 0.0f), GetColorU32(enabled ? ImGuiCol_Text : ImGuiCol_TextDisabled));

	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T5[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm2, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T5[ebp], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9836 :         RenderCheckMark(pos + ImVec2(window->MenuColumns.Pos[2] + extra_w + g.FontSize * 0.20f, 0.0f), GetColorU32(enabled ? ImGuiCol_Text : ImGuiCol_TextDisabled));

	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	push	eax
	push	DWORD PTR $T5[ebp+4]
	push	DWORD PTR $T5[ebp]
	call	?RenderCheckMark@ImGui@@YAXUImVec2@@I@Z	; ImGui::RenderCheckMark
	add	esp, 20					; 00000014H
$LN4@MenuItem:

; 9837 : 
; 9838 :     return pressed;

	mov	al, BYTE PTR _pressed$1$[ebp]
	pop	edi
	pop	ebx
	pop	esi

; 9839 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?MenuItem@ImGui@@YA_NPBD0_N1@Z ENDP			; ImGui::MenuItem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?EndMenu@ImGui@@YAXXZ PROC				; ImGui::EndMenu

; 10045:     EndPopup();

	jmp	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup
?EndMenu@ImGui@@YAXXZ ENDP				; ImGui::EndMenu
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T2 = -60						; size = 8
$T3 = -60						; size = 8
$T4 = -60						; size = 8
$T5 = -60						; size = 8
$T6 = -60						; size = 8
$T7 = -60						; size = 8
_label_size$ = -60					; size = 8
_popup_pos$ = -52					; size = 8
_tb$8 = -44						; size = 8
$T9 = -44						; size = 8
$T10 = -44						; size = 8
_pos$ = -44						; size = 8
_next_window_rect$11 = -36				; size = 16
_tc$12 = -28						; size = 8
_backed_nav_window$1$ = -24				; size = 4
_ta$13 = -20						; size = 8
$T14 = -20						; size = 8
$T15 = -20						; size = 8
$T16 = -20						; size = 8
_extra_w$1$ = -16					; size = 4
$T17 = -16						; size = 4
_w$18 = -16						; size = 4
_menu_is_open$ = -12					; size = 1
_id$1$ = -8						; size = 4
_hovered$1$ = -4					; size = 1
_pressed$1$ = -3					; size = 1
_menu_is_open$1$ = -2					; size = 1
_moving_within_opened_triangle$1$ = -1			; size = 1
_want_open$1$ = -1					; size = 1
_menuset_is_open$1$ = -1				; size = 1
_label$ = 8						; size = 4
_enabled$ = 12						; size = 1
?BeginMenu@ImGui@@YA_NPBD_N@Z PROC			; ImGui::BeginMenu

; 9917 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9917 : {

	sub	esp, 60					; 0000003cH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	push	edi
	mov	BYTE PTR [eax+134], 1
	mov	edi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9919 :     if (window->SkipItems)

	cmp	BYTE PTR [edi+137], 0
	je	SHORT $LN2@BeginMenu

; 9920 :         return false;

	xor	al, al
	pop	edi

; 10041: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@BeginMenu:
	push	esi

; 9921 : 
; 9922 :     ImGuiContext& g = *GImGui;

	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 9923 :     const ImGuiStyle& style = g.Style;
; 9924 :     const ImGuiID id = window->GetID(label);

	mov	ecx, edi
	push	0
	push	DWORD PTR _label$[ebp]
	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID

; 9925 : 
; 9926 :     ImVec2 label_size = CalcTextSize(label, NULL, true);

	push	ecx
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	push	1
	push	0
	push	DWORD PTR _label$[ebp]
	mov	DWORD PTR _id$1$[ebp], eax
	lea	eax, DWORD PTR _label_size$[ebp]
	push	eax
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize

; 9927 : 
; 9928 :     bool pressed;
; 9929 :     bool menu_is_open = IsPopupOpen(id);

	push	DWORD PTR _id$1$[ebp]
	call	?IsPopupOpen@@YA_NI@Z			; IsPopupOpen
	add	esp, 24					; 00000018H
	mov	BYTE PTR _menu_is_open$1$[ebp], al

; 9930 :     bool menuset_is_open = !(window->Flags & ImGuiWindowFlags_Popup) && (g.OpenPopupStack.Size > g.CurrentPopupStack.Size && g.OpenPopupStack[g.CurrentPopupStack.Size].ParentMenuSet == window->GetID("##menus"));

	test	DWORD PTR [edi+8], 33554432		; 02000000H
	mov	BYTE PTR _menu_is_open$[ebp], al
	jne	SHORT $LN28@BeginMenu
	mov	eax, DWORD PTR [esi+6368]
	cmp	DWORD PTR [esi+6356], eax
	jle	SHORT $LN28@BeginMenu
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	shl	eax, 5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9930 :     bool menuset_is_open = !(window->Flags & ImGuiWindowFlags_Popup) && (g.OpenPopupStack.Size > g.CurrentPopupStack.Size && g.OpenPopupStack[g.CurrentPopupStack.Size].ParentMenuSet == window->GetID("##menus"));

	mov	ecx, edi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	add	eax, DWORD PTR [esi+6364]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9930 :     bool menuset_is_open = !(window->Flags & ImGuiWindowFlags_Popup) && (g.OpenPopupStack.Size > g.CurrentPopupStack.Size && g.OpenPopupStack[g.CurrentPopupStack.Size].ParentMenuSet == window->GetID("##menus"));

	push	0
	push	OFFSET $SG122175
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	mov	DWORD PTR $T17[ebp], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9930 :     bool menuset_is_open = !(window->Flags & ImGuiWindowFlags_Popup) && (g.OpenPopupStack.Size > g.CurrentPopupStack.Size && g.OpenPopupStack[g.CurrentPopupStack.Size].ParentMenuSet == window->GetID("##menus"));

	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID
	mov	ecx, DWORD PTR $T17[ebp]
	cmp	DWORD PTR [ecx+12], eax
	jne	SHORT $LN28@BeginMenu
	mov	al, 1
	jmp	SHORT $LN139@BeginMenu
$LN28@BeginMenu:
	xor	al, al
$LN139@BeginMenu:

; 9931 :     ImGuiWindow* backed_nav_window = g.NavWindow;

	mov	ecx, DWORD PTR [esi+6380]
	mov	BYTE PTR _menuset_is_open$1$[ebp], al
	mov	DWORD PTR _backed_nav_window$1$[ebp], ecx

; 9932 :     if (menuset_is_open)

	test	al, al
	je	SHORT $LN3@BeginMenu

; 9933 :         g.NavWindow = window;  // Odd hack to allow hovering across menus of a same menu-set (otherwise we wouldn't be able to hover parent)

	mov	DWORD PTR [esi+6380], edi
$LN3@BeginMenu:

; 9934 : 
; 9935 :     ImVec2 popup_pos, pos = window->DC.CursorPos;
; 9936 :     if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)

	cmp	DWORD PTR [edi+308], 1
	mov	eax, DWORD PTR [edi+192]
	mov	DWORD PTR _pos$[ebp], eax
	mov	eax, DWORD PTR [edi+196]
	mov	DWORD PTR _pos$[ebp+4], eax
	jne	$LN4@BeginMenu
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	test	DWORD PTR [edi+8], 1024			; 00000400H
	xorps	xmm1, xmm1
	je	SHORT $LN52@BeginMenu
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	movss	xmm0, DWORD PTR [eax+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm1, DWORD PTR [eax+6176]

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	addss	xmm0, xmm0

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm1, DWORD PTR [edi+620]

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	addss	xmm1, xmm0
$LN52@BeginMenu:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9938 :         popup_pos = ImVec2(pos.x - window->WindowPadding.x, pos.y - style.FramePadding.y + window->MenuBarHeight());

	movss	xmm0, DWORD PTR _pos$[ebp]
	subss	xmm0, DWORD PTR [edi+80]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T16[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9938 :         popup_pos = ImVec2(pos.x - window->WindowPadding.x, pos.y - style.FramePadding.y + window->MenuBarHeight());

	movss	xmm0, DWORD PTR _pos$[ebp+4]
	subss	xmm0, DWORD PTR [esi+5360]
	mov	eax, DWORD PTR $T16[ebp]
	mov	DWORD PTR _popup_pos$[ebp], eax
	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T16[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9939 :         window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * 0.5f);

	movss	xmm0, DWORD PTR [esi+5368]
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	eax, DWORD PTR $T16[ebp+4]
	mov	DWORD PTR _popup_pos$[ebp+4], eax
	cvttss2si eax, xmm0
	movd	xmm0, eax

; 9940 :         PushStyleVar(ImGuiStyleVar_ItemSpacing, style.ItemSpacing * 2.0f);

	lea	eax, DWORD PTR $T10[ebp]
	cvtdq2ps xmm0, xmm0
	push	eax
	push	7
	addss	xmm0, DWORD PTR [edi+192]
	movss	DWORD PTR [edi+192], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	movss	xmm0, DWORD PTR [esi+5368]
	addss	xmm0, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T10[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	movss	xmm0, DWORD PTR [esi+5372]
	addss	xmm0, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T10[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9940 :         PushStyleVar(ImGuiStyleVar_ItemSpacing, style.ItemSpacing * 2.0f);

	call	?PushStyleVar@ImGui@@YAXHABUImVec2@@@Z	; ImGui::PushStyleVar
	cmp	BYTE PTR _enabled$[ebp], 0

; 9942 :         pressed = Selectable(label, menu_is_open, ImGuiSelectableFlags_Menu | ImGuiSelectableFlags_DontClosePopups | (!enabled ? ImGuiSelectableFlags_Disabled : 0), ImVec2(w, 0.0f));

	lea	eax, DWORD PTR $T9[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR _label_size$[ebp]
	mov	ecx, 41					; 00000029H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9942 :         pressed = Selectable(label, menu_is_open, ImGuiSelectableFlags_Menu | ImGuiSelectableFlags_DontClosePopups | (!enabled ? ImGuiSelectableFlags_Disabled : 0), ImVec2(w, 0.0f));

	push	eax
	mov	eax, 9
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T9[ebp], xmm0
	cmove	eax, ecx
	mov	DWORD PTR $T9[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9942 :         pressed = Selectable(label, menu_is_open, ImGuiSelectableFlags_Menu | ImGuiSelectableFlags_DontClosePopups | (!enabled ? ImGuiSelectableFlags_Disabled : 0), ImVec2(w, 0.0f));

	push	eax
	push	DWORD PTR _menu_is_open$[ebp]
	push	DWORD PTR _label$[ebp]
	call	?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ; ImGui::Selectable

; 9943 :         PopStyleVar();

	push	1
	mov	BYTE PTR _pressed$1$[ebp], al
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar

; 9944 :         SameLine();

	add	esp, 20					; 00000014H
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 9945 :         window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * 0.5f);

	movss	xmm0, DWORD PTR [esi+5368]
	add	esp, 8

; 9956 :     }
; 9957 : 
; 9958 :     bool hovered = enabled && IsHovered(window->DC.LastItemRect, id); // FIXME: Why not using window->DC.LastItemHoveredAndUsable / IsItemHovered() ?

	cmp	BYTE PTR _enabled$[ebp], 0
	mulss	xmm0, DWORD PTR __real@3f000000
	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	addss	xmm0, DWORD PTR [edi+192]
	movss	DWORD PTR [edi+192], xmm0
	je	$LN30@BeginMenu
$LN123@BeginMenu:
	push	0
	push	DWORD PTR _id$1$[ebp]
	lea	eax, DWORD PTR [edi+252]
	push	eax
	call	?IsHovered@ImGui@@YA_NABUImRect@@I_N@Z	; ImGui::IsHovered
	add	esp, 12					; 0000000cH
	test	al, al
	je	$LN30@BeginMenu
	mov	ah, 1
	jmp	$LN140@BeginMenu
$LN4@BeginMenu:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR _pos$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9950 :         float w = window->MenuColumns.DeclColumns(label_size.x, 0.0f, (float)(int)(g.FontSize * 1.20f)); // Feedback to next frame

	lea	ecx, DWORD PTR [edi+528]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T15[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9950 :         float w = window->MenuColumns.DeclColumns(label_size.x, 0.0f, (float)(int)(g.FontSize * 1.20f)); // Feedback to next frame

	sub	esp, 12					; 0000000cH
	movss	xmm0, DWORD PTR _pos$[ebp+4]
	subss	xmm0, DWORD PTR [esi+5328]
	mov	eax, DWORD PTR $T15[ebp]
	mov	DWORD PTR _popup_pos$[ebp], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T15[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9950 :         float w = window->MenuColumns.DeclColumns(label_size.x, 0.0f, (float)(int)(g.FontSize * 1.20f)); // Feedback to next frame

	movss	xmm0, DWORD PTR [esi+6172]
	mulss	xmm0, DWORD PTR __real@3f99999a
	mov	eax, DWORD PTR $T15[ebp+4]
	mov	DWORD PTR _popup_pos$[ebp+4], eax
	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _label_size$[ebp]
	mov	DWORD PTR [esp+4], 0
	movss	DWORD PTR [esp], xmm0
	call	?DeclColumns@ImGuiSimpleColumns@@QAEMMMM@Z ; ImGuiSimpleColumns::DeclColumns

; 9951 :         float extra_w = ImMax(0.0f, GetContentRegionAvail().x - w);

	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	fstp	DWORD PTR _w$18[ebp]
	call	?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetContentRegionAvail
	movss	xmm0, DWORD PTR _w$18[ebp]
	mov	ecx, 105				; 00000069H
	cmp	BYTE PTR _enabled$[ebp], 0
	xorps	xmm1, xmm1
	movss	xmm2, DWORD PTR [eax]

; 9952 :         pressed = Selectable(label, menu_is_open, ImGuiSelectableFlags_Menu | ImGuiSelectableFlags_DontClosePopups | ImGuiSelectableFlags_DrawFillAvailWidth | (!enabled ? ImGuiSelectableFlags_Disabled : 0), ImVec2(w, 0.0f));

	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	subss	xmm2, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T6[ebp], xmm0
	mov	eax, 73					; 00000049H
	mov	DWORD PTR $T6[ebp+4], 0
	cmove	eax, ecx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9952 :         pressed = Selectable(label, menu_is_open, ImGuiSelectableFlags_Menu | ImGuiSelectableFlags_DontClosePopups | ImGuiSelectableFlags_DrawFillAvailWidth | (!enabled ? ImGuiSelectableFlags_Disabled : 0), ImVec2(w, 0.0f));

	push	eax
	push	DWORD PTR _menu_is_open$[ebp]
	maxss	xmm2, xmm1
	push	DWORD PTR _label$[ebp]
	movss	DWORD PTR _extra_w$1$[ebp], xmm2
	call	?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ; ImGui::Selectable
	add	esp, 20					; 00000014H
	mov	BYTE PTR _pressed$1$[ebp], al

; 9953 :         if (!enabled) PushStyleColor(ImGuiCol_Text, g.Style.Colors[ImGuiCol_TextDisabled]);

	cmp	BYTE PTR _enabled$[ebp], 0
	jne	SHORT $LN6@BeginMenu
	lea	eax, DWORD PTR [esi+5464]
	push	eax
	push	0
	call	?PushStyleColor@ImGui@@YAXHABUImVec4@@@Z ; ImGui::PushStyleColor
	add	esp, 8
$LN6@BeginMenu:

; 9954 :         RenderCollapseTriangle(pos + ImVec2(window->MenuColumns.Pos[2] + extra_w + g.FontSize * 0.20f, 0.0f), false);

	movss	xmm1, DWORD PTR [edi+552]
	addss	xmm1, DWORD PTR _extra_w$1$[ebp]
	movss	xmm0, DWORD PTR [esi+6172]
	mulss	xmm0, DWORD PTR __real@3e4ccccd
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	0
	addss	xmm1, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR _pos$[ebp+4]
	movss	DWORD PTR $T14[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9954 :         RenderCollapseTriangle(pos + ImVec2(window->MenuColumns.Pos[2] + extra_w + g.FontSize * 0.20f, 0.0f), false);

	push	DWORD PTR $T14[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm1, DWORD PTR _pos$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T14[ebp], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9954 :         RenderCollapseTriangle(pos + ImVec2(window->MenuColumns.Pos[2] + extra_w + g.FontSize * 0.20f, 0.0f), false);

	push	DWORD PTR $T14[ebp]
	call	?RenderCollapseTriangle@ImGui@@YAXUImVec2@@_NM@Z ; ImGui::RenderCollapseTriangle
	add	esp, 16					; 00000010H

; 9955 :         if (!enabled) PopStyleColor();

	cmp	BYTE PTR _enabled$[ebp], 0
	jne	$LN123@BeginMenu
	push	1
	call	?PopStyleColor@ImGui@@YAXH@Z		; ImGui::PopStyleColor
	add	esp, 4
$LN30@BeginMenu:

; 9956 :     }
; 9957 : 
; 9958 :     bool hovered = enabled && IsHovered(window->DC.LastItemRect, id); // FIXME: Why not using window->DC.LastItemHoveredAndUsable / IsItemHovered() ?

	xor	ah, ah
$LN140@BeginMenu:

; 9959 : 
; 9960 :     if (menuset_is_open)

	mov	cl, BYTE PTR _menuset_is_open$1$[ebp]
	mov	BYTE PTR _hovered$1$[ebp], ah
	test	cl, cl
	je	SHORT $LN8@BeginMenu

; 9961 :         g.NavWindow = backed_nav_window;

	mov	edx, DWORD PTR _backed_nav_window$1$[ebp]
	mov	DWORD PTR [esi+6380], edx
$LN8@BeginMenu:

; 9962 : 
; 9963 :     bool want_open = false, want_close = false;

	xor	dl, dl
	mov	BYTE PTR _want_open$1$[ebp], 0

; 9964 :     if (window->Flags & (ImGuiWindowFlags_Popup|ImGuiWindowFlags_ChildMenu))

	test	DWORD PTR [edi+8], 167772160		; 0a000000H
	je	$LN9@BeginMenu

; 9968 :         if (g.HoveredWindow == window && g.OpenPopupStack.Size > g.CurrentPopupStack.Size && g.OpenPopupStack[g.CurrentPopupStack.Size].ParentWindow == window && !(window->Flags & ImGuiWindowFlags_MenuBar))

	mov	ecx, DWORD PTR [esi+6244]
	xor	ah, ah
	mov	BYTE PTR _moving_within_opened_triangle$1$[ebp], ah
	cmp	ecx, edi
	jne	$LN12@BeginMenu
	mov	eax, DWORD PTR [esi+6368]
	cmp	DWORD PTR [esi+6356], eax
	jle	$LN135@BeginMenu
	mov	ecx, DWORD PTR [esi+6364]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	shl	eax, 5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9968 :         if (g.HoveredWindow == window && g.OpenPopupStack.Size > g.CurrentPopupStack.Size && g.OpenPopupStack[g.CurrentPopupStack.Size].ParentWindow == window && !(window->Flags & ImGuiWindowFlags_MenuBar))

	cmp	DWORD PTR [eax+ecx+8], edi
	jne	$LN136@BeginMenu
	test	DWORD PTR [edi+8], 1024			; 00000400H
	jne	$LN136@BeginMenu

; 9969 :         {
; 9970 :             if (ImGuiWindow* next_window = g.OpenPopupStack[g.CurrentPopupStack.Size].Window)

	mov	eax, DWORD PTR [eax+ecx+4]
	test	eax, eax
	je	$LN136@BeginMenu
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm3, DWORD PTR [eax+24]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9973 :                 ImVec2 ta = g.IO.MousePos - g.IO.MouseDelta;

	lea	edx, DWORD PTR [esi+208]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm4, DWORD PTR [eax+28]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9974 :                 ImVec2 tb = (window->Pos.x < next_window->Pos.x) ? next_window_rect.GetTL() : next_window_rect.GetTR();

	lea	ecx, DWORD PTR $T5[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 773  :     ImRect      Rect() const                            { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }

	movss	xmm0, DWORD PTR [eax+32]
	movss	xmm1, DWORD PTR [eax+36]
	addss	xmm0, xmm3

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm2, DWORD PTR [edx+4]

; 773  :     ImRect      Rect() const                            { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }

	addss	xmm1, xmm4

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm2, DWORD PTR [esi+876]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9974 :                 ImVec2 tb = (window->Pos.x < next_window->Pos.x) ? next_window_rect.GetTL() : next_window_rect.GetTR();

	movss	xmm5, DWORD PTR [edi+24]
	comiss	xmm3, xmm5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm6, DWORD PTR [edx]
	subss	xmm6, DWORD PTR [esi+872]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _next_window_rect$11[ebp], xmm3
	movss	DWORD PTR _next_window_rect$11[ebp+4], xmm4
	movss	DWORD PTR _next_window_rect$11[ebp+8], xmm0
	movss	DWORD PTR _next_window_rect$11[ebp+12], xmm1
	movss	DWORD PTR _ta$13[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9974 :                 ImVec2 tb = (window->Pos.x < next_window->Pos.x) ? next_window_rect.GetTL() : next_window_rect.GetTR();

	jbe	SHORT $LN32@BeginMenu
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 248  :     ImVec2      GetTL() const                   { return Min; }                   // Top-left

	mov	eax, DWORD PTR _next_window_rect$11[ebp]
	mov	DWORD PTR $T5[ebp], eax
	mov	eax, DWORD PTR _next_window_rect$11[ebp+4]
	mov	DWORD PTR $T5[ebp+4], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9974 :                 ImVec2 tb = (window->Pos.x < next_window->Pos.x) ? next_window_rect.GetTL() : next_window_rect.GetTR();

	jmp	SHORT $LN33@BeginMenu
$LN32@BeginMenu:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp], xmm0
	movss	DWORD PTR $T4[ebp+4], xmm4
$LN33@BeginMenu:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9975 :                 ImVec2 tc = (window->Pos.x < next_window->Pos.x) ? next_window_rect.GetBL() : next_window_rect.GetBR();

	comiss	xmm3, xmm5
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _tb$8[ebp], eax
	mov	eax, DWORD PTR [ecx+4]
	lea	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR _tb$8[ebp+4], eax
	jbe	SHORT $LN34@BeginMenu
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp], xmm3
	movss	DWORD PTR $T3[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9975 :                 ImVec2 tc = (window->Pos.x < next_window->Pos.x) ? next_window_rect.GetBL() : next_window_rect.GetBR();

	jmp	SHORT $LN35@BeginMenu
$LN34@BeginMenu:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 251  :     ImVec2      GetBR() const                   { return Max; }                   // Bottom-right

	mov	eax, DWORD PTR _next_window_rect$11[ebp+8]
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR _next_window_rect$11[ebp+12]
	mov	DWORD PTR $T2[ebp+4], eax
$LN35@BeginMenu:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9975 :                 ImVec2 tc = (window->Pos.x < next_window->Pos.x) ? next_window_rect.GetBL() : next_window_rect.GetBR();

	mov	eax, DWORD PTR [ecx]

; 9976 :                 float extra = ImClamp(fabsf(ta.x - tb.x) * 0.30f, 5.0f, 30.0f); // add a bit of extra slack.

	movaps	xmm0, xmm6
	subss	xmm0, DWORD PTR _tb$8[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	movss	xmm1, DWORD PTR __real@40a00000
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9975 :                 ImVec2 tc = (window->Pos.x < next_window->Pos.x) ? next_window_rect.GetBL() : next_window_rect.GetBR();

	mov	DWORD PTR _tc$12[ebp], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _tc$12[ebp+4], eax
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\math.h

; 658  :         return (float)fabs(_X);

	andps	xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9976 :                 float extra = ImClamp(fabsf(ta.x - tb.x) * 0.30f, 5.0f, 30.0f); // add a bit of extra slack.

	mulss	xmm0, DWORD PTR __real@3e99999a
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm1, xmm0
	ja	SHORT $LN113@BeginMenu
	movaps	xmm1, xmm0
	minss	xmm1, DWORD PTR __real@41f00000
$LN113@BeginMenu:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9977 :                 ta.x += (window->Pos.x < next_window->Pos.x) ? -0.5f : +0.5f;   // to avoid numerical issues

	comiss	xmm3, xmm5
	jbe	SHORT $LN36@BeginMenu
	movss	xmm0, DWORD PTR __real@bf000000
	jmp	SHORT $LN37@BeginMenu
$LN36@BeginMenu:
	movss	xmm0, DWORD PTR __real@3f000000
$LN37@BeginMenu:
	addss	xmm0, xmm6

; 9978 :                 tb.y = ta.y + ImMax((tb.y - extra) - ta.y, -100.0f);            // triangle is maximum 200 high to limit the slope and the bias toward large sub-menus // FIXME: Multiply by fb_scale?
; 9979 :                 tc.y = ta.y + ImMin((tc.y + extra) - ta.y, +100.0f);
; 9980 :                 moving_within_opened_triangle = ImIsPointInTriangle(g.IO.MousePos, ta, tb, tc);

	lea	eax, DWORD PTR _tc$12[ebp]
	push	eax
	lea	eax, DWORD PTR _tb$8[ebp]
	push	eax
	movss	DWORD PTR _ta$13[ebp], xmm0
	lea	eax, DWORD PTR _ta$13[ebp]
	movss	xmm0, DWORD PTR _tb$8[ebp+4]
	subss	xmm0, xmm1
	push	eax
	push	edx
	subss	xmm0, xmm2
	maxss	xmm0, DWORD PTR __real@c2c80000
	addss	xmm0, xmm2
	movss	DWORD PTR _tb$8[ebp+4], xmm0
	movss	xmm0, DWORD PTR _tc$12[ebp+4]
	addss	xmm0, xmm1
	subss	xmm0, xmm2
	minss	xmm0, DWORD PTR __real@42c80000
	addss	xmm0, xmm2
	movss	DWORD PTR _tc$12[ebp+4], xmm0
	call	?ImIsPointInTriangle@@YA_NABUImVec2@@000@Z ; ImIsPointInTriangle
	add	esp, 16					; 00000010H
	mov	ah, al
	jmp	SHORT $LN141@BeginMenu
$LN135@BeginMenu:
	mov	ah, BYTE PTR _moving_within_opened_triangle$1$[ebp]
	jmp	SHORT $LN12@BeginMenu
$LN136@BeginMenu:
	mov	ah, BYTE PTR _moving_within_opened_triangle$1$[ebp]
$LN141@BeginMenu:
	mov	ecx, DWORD PTR [esi+6244]
$LN12@BeginMenu:

; 9981 :                 //window->DrawList->PushClipRectFullScreen(); window->DrawList->AddTriangleFilled(ta, tb, tc, moving_within_opened_triangle ? IM_COL32(0,128,0,128) : IM_COL32(128,0,0,128)); window->DrawList->PopClipRect(); // Debug
; 9982 :             }
; 9983 :         }
; 9984 : 
; 9985 :         want_close = (menu_is_open && !hovered && g.HoveredWindow == window && g.HoveredIdPreviousFrame != 0 && g.HoveredIdPreviousFrame != id && !moving_within_opened_triangle);

	mov	al, BYTE PTR _menu_is_open$1$[ebp]
	mov	dh, BYTE PTR _hovered$1$[ebp]
	test	al, al
	je	SHORT $LN131@BeginMenu
	test	dh, dh
	jne	SHORT $LN131@BeginMenu
	cmp	ecx, edi
	mov	ecx, DWORD PTR _id$1$[ebp]
	jne	SHORT $LN38@BeginMenu
	cmp	DWORD PTR [esi+6260], 0
	je	SHORT $LN38@BeginMenu
	cmp	DWORD PTR [esi+6260], ecx
	je	SHORT $LN38@BeginMenu
	test	ah, ah
	jne	SHORT $LN38@BeginMenu
	mov	dl, 1
	jmp	SHORT $LN39@BeginMenu
$LN131@BeginMenu:
	mov	ecx, DWORD PTR _id$1$[ebp]
$LN38@BeginMenu:
	xor	dl, dl
$LN39@BeginMenu:

; 9986 :         want_open = (!menu_is_open && hovered && !moving_within_opened_triangle) || (!menu_is_open && hovered && pressed);

	test	al, al
	jne	SHORT $LN41@BeginMenu
	test	dh, dh
	je	SHORT $LN41@BeginMenu
	test	ah, ah
	je	SHORT $LN42@BeginMenu
	mov	dh, BYTE PTR _pressed$1$[ebp]
	test	dh, dh
	je	SHORT $LN41@BeginMenu
$LN42@BeginMenu:
	mov	BYTE PTR _want_open$1$[ebp], 1
	jmp	SHORT $LN43@BeginMenu
$LN41@BeginMenu:
	mov	BYTE PTR _want_open$1$[ebp], 0
$LN43@BeginMenu:

; 9987 : 
; 9988 :         if (g.NavActivateId == id)

	cmp	DWORD PTR [esi+6388], ecx
	jne	SHORT $LN13@BeginMenu

; 9989 :         {
; 9990 :             want_close = menu_is_open;
; 9991 :             want_open = !menu_is_open;

	test	al, al
	mov	dl, al
	sete	BYTE PTR _want_open$1$[ebp]
$LN13@BeginMenu:

; 9992 :         }
; 9993 :         if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiNavDir_Right) // Nav-Right to open

	cmp	DWORD PTR [esi+6384], ecx
	jne	SHORT $LN14@BeginMenu
	cmp	BYTE PTR [esi+6481], 0
	je	SHORT $LN14@BeginMenu
	cmp	DWORD PTR [esi+6484], 1
	jne	SHORT $LN14@BeginMenu

; 9994 :         {
; 9995 :             want_open = true;

	mov	BYTE PTR _want_open$1$[ebp], 1

; 9996 :             g.NavMoveRequest = false;

	mov	BYTE PTR [esi+6481], 0
$LN14@BeginMenu:

; 9997 :         }
; 9998 :         if (g.NavWindow && g.NavWindow->ParentWindow == window && g.NavMoveRequest && g.NavMoveDir == ImGuiNavDir_Left && IsPopupOpen(id)) // Nav-Left to close

	mov	eax, DWORD PTR [esi+6380]
	test	eax, eax
	je	$LN21@BeginMenu
	cmp	DWORD PTR [eax+628], edi
	jne	$LN21@BeginMenu
	cmp	BYTE PTR [esi+6481], 0
	je	$LN21@BeginMenu
	cmp	DWORD PTR [esi+6484], 0
	jne	SHORT $LN21@BeginMenu
	push	ecx
	call	?IsPopupOpen@@YA_NI@Z			; IsPopupOpen

; 10002:         }
; 10003:     }

	mov	ecx, DWORD PTR _id$1$[ebp]
	add	esp, 4
	test	al, al
	je	SHORT $LN21@BeginMenu

; 9999 :         {
; 10000:             want_close = true;
; 10001:             g.NavMoveRequest = false;

	mov	dl, 1
	mov	BYTE PTR [esi+6481], 0

; 10002:         }
; 10003:     }

	jmp	SHORT $LN21@BeginMenu
$LN9@BeginMenu:

; 10004:     else if (menu_is_open && pressed && menuset_is_open) // Menu bar: click an open menu again to close it

	mov	al, BYTE PTR _menu_is_open$1$[ebp]
	mov	dh, BYTE PTR _pressed$1$[ebp]
	test	al, al
	je	SHORT $LN16@BeginMenu
	test	dh, dh
	je	SHORT $LN122@BeginMenu
	test	cl, cl
	je	SHORT $LN16@BeginMenu

; 10005:     {
; 10006:         want_close = true;
; 10007:         want_open = menu_is_open = false;

	xor	al, al
	mov	dl, 1
	mov	BYTE PTR _menu_is_open$1$[ebp], al
	mov	BYTE PTR _want_open$1$[ebp], al
	jmp	SHORT $LN142@BeginMenu
$LN16@BeginMenu:

; 10008:     }
; 10009:     else if (pressed || (hovered && menuset_is_open && !menu_is_open)) // Menu bar: click to open a first menu, then hover to open others

	test	dh, dh
	jne	SHORT $LN20@BeginMenu
$LN122@BeginMenu:
	test	ah, ah
	je	SHORT $LN18@BeginMenu
	test	cl, cl
	je	SHORT $LN18@BeginMenu
	test	al, al
	je	SHORT $LN20@BeginMenu
$LN18@BeginMenu:

; 10011:     else if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiNavDir_Down) // Menu bar: Nav-Down to open

	mov	ecx, DWORD PTR _id$1$[ebp]
	cmp	DWORD PTR [esi+6384], ecx
	jne	SHORT $LN21@BeginMenu
	cmp	BYTE PTR [esi+6481], 0
	je	SHORT $LN21@BeginMenu
	cmp	DWORD PTR [esi+6484], 3
	jne	SHORT $LN21@BeginMenu

; 10012:     {
; 10013:         g.NavMoveRequest = false;

	mov	BYTE PTR [esi+6481], 0

; 10014:         want_open = true;

	mov	BYTE PTR _want_open$1$[ebp], 1
	jmp	SHORT $LN21@BeginMenu
$LN20@BeginMenu:

; 10010:         want_open = true;

	mov	BYTE PTR _want_open$1$[ebp], 1
$LN142@BeginMenu:
	mov	ecx, DWORD PTR _id$1$[ebp]
$LN21@BeginMenu:

; 10015:     }
; 10016: 
; 10017:     if (!enabled) // explicitly close if an open menu becomes disabled, facilitate users code a lot in pattern such as 'if (BeginMenu("options", has_object)) { ..use object.. }'

	cmp	BYTE PTR _enabled$[ebp], 0
	je	SHORT $LN125@BeginMenu

; 10018:         want_close = true;
; 10019:     if (want_close && IsPopupOpen(id))

	test	dl, dl
	je	SHORT $LN23@BeginMenu
$LN125@BeginMenu:
	push	ecx
	call	?IsPopupOpen@@YA_NI@Z			; IsPopupOpen
	add	esp, 4
	test	al, al
	je	SHORT $LN23@BeginMenu

; 10020:         ClosePopupToLevel(GImGui->CurrentPopupStack.Size);

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	DWORD PTR [eax+6368]
	call	?ClosePopupToLevel@@YAXH@Z		; ClosePopupToLevel
	add	esp, 4
$LN23@BeginMenu:

; 10021: 
; 10022:     if (!menu_is_open && want_open && g.OpenPopupStack.Size > g.CurrentPopupStack.Size)

	mov	cl, BYTE PTR _menu_is_open$1$[ebp]
	mov	dl, BYTE PTR _want_open$1$[ebp]
	test	cl, cl
	jne	SHORT $LN24@BeginMenu
	test	dl, dl
	je	SHORT $LN24@BeginMenu
	mov	eax, DWORD PTR [esi+6356]
	cmp	eax, DWORD PTR [esi+6368]
	jle	SHORT $LN24@BeginMenu

; 10023:     {
; 10024:         // Don't recycle same menu level in the same frame, first close the other menu and yield for a frame.
; 10025:         OpenPopup(label);

	push	DWORD PTR _label$[ebp]
	call	?OpenPopup@ImGui@@YAXPBD@Z		; ImGui::OpenPopup
	add	esp, 4

; 10026:         return false;

	xor	al, al
	pop	esi
	pop	edi

; 10041: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN24@BeginMenu:

; 10027:     }
; 10028: 
; 10029:     menu_is_open |= want_open;
; 10030:     if (want_open)
; 10031:         OpenPopup(label);

	mov	esi, DWORD PTR _label$[ebp]
	or	cl, dl
	mov	BYTE PTR _menu_is_open$1$[ebp], cl
	test	dl, dl
	je	SHORT $LN25@BeginMenu
	push	esi
	call	?OpenPopup@ImGui@@YAXPBD@Z		; ImGui::OpenPopup
	mov	cl, BYTE PTR _menu_is_open$1$[ebp]
	add	esp, 4
$LN25@BeginMenu:

; 10032: 
; 10033:     if (menu_is_open)

	test	cl, cl
	je	SHORT $LN26@BeginMenu

; 10034:     {
; 10035:         SetNextWindowPos(popup_pos, ImGuiSetCond_Always);

	lea	eax, DWORD PTR _popup_pos$[ebp]
	push	1
	push	eax
	call	?SetNextWindowPos@ImGui@@YAXABUImVec2@@H@Z ; ImGui::SetNextWindowPos

; 10036:         ImGuiWindowFlags flags = ImGuiWindowFlags_ShowBorders | ((window->Flags & (ImGuiWindowFlags_Popup|ImGuiWindowFlags_ChildMenu)) ? ImGuiWindowFlags_ChildMenu|ImGuiWindowFlags_ChildWindow : ImGuiWindowFlags_ChildMenu);

	mov	eax, DWORD PTR [edi+8]
	and	eax, 167772160				; 0a000000H
	neg	eax
	sbb	eax, eax
	and	eax, 4194304				; 00400000H
	add	eax, 134217856				; 08000080H

; 10037:         menu_is_open = BeginPopupEx(label, flags); // menu_is_open can be 'false' when the popup is completely clipped (e.g. zero size display)

	push	eax
	push	esi
	call	?BeginPopupEx@@YA_NPBDH@Z		; BeginPopupEx
	add	esp, 16					; 00000010H
	mov	cl, al
$LN26@BeginMenu:

; 10038:     }
; 10039: 
; 10040:     return menu_is_open;

	pop	esi
	mov	al, cl
	pop	edi

; 10041: }

	mov	esp, ebp
	pop	ebp
	ret	0
?BeginMenu@ImGui@@YA_NPBD_N@Z ENDP			; ImGui::BeginMenu
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
tv235 = -4						; size = 4
?EndMenuBar@ImGui@@YAXXZ PROC				; ImGui::EndMenuBar

; 9899 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	esi
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	esi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9901 :     if (window->SkipItems)

	cmp	BYTE PTR [esi+137], 0
	jne	SHORT $LN1@EndMenuBar

; 9902 :         return;
; 9903 : 
; 9904 :     IM_ASSERT(window->Flags & ImGuiWindowFlags_MenuBar);
; 9905 :     IM_ASSERT(window->DC.MenuBarAppending);
; 9906 :     PopClipRect();

	call	?PopClipRect@ImGui@@YAXXZ		; ImGui::PopClipRect

; 9907 :     PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 9908 :     window->DC.MenuBarOffsetX = window->DC.CursorPos.x - window->MenuBarRect().Min.x;

	movss	xmm0, DWORD PTR [esi+192]
	subss	xmm0, DWORD PTR [esi+24]
	movss	DWORD PTR [esi+288], xmm0

; 9909 :     window->DC.GroupStack.back().AdvanceCursor = false;

	mov	eax, DWORD PTR [esi+360]
	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [esi+368]
	mov	BYTE PTR [eax+ecx*8-3], 0

; 9910 :     EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup

; 9911 :     window->DC.LayoutType = ImGuiLayoutType_Vertical;
; 9912 :     window->DC.NavLayerCurrent--;

	dec	DWORD PTR [esi+272]
	mov	DWORD PTR [esi+308], 0

; 9913 :     window->DC.MenuBarAppending = false;

	mov	BYTE PTR [esi+284], 0
$LN1@EndMenuBar:
	pop	esi

; 9914 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?EndMenuBar@ImGui@@YAXXZ ENDP				; ImGui::EndMenuBar
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -28						; size = 8
$T2 = -20						; size = 8
_y1$1$ = -12						; size = 4
$T3 = -8						; size = 8
_rect$$sroa$151$1$ = -4					; size = 4
?BeginMenuBar@ImGui@@YA_NXZ PROC			; ImGui::BeginMenuBar

; 9878 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9878 : {

	sub	esp, 28					; 0000001cH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	push	esi
	mov	BYTE PTR [eax+134], 1
	mov	esi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9880 :     if (window->SkipItems)

	cmp	BYTE PTR [esi+137], 0
	je	SHORT $LN2@BeginMenuB
$LN41@BeginMenuB:

; 9881 :         return false;

	xor	al, al
	pop	esi

; 9896 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@BeginMenuB:

; 9882 :     if (!(window->Flags & ImGuiWindowFlags_MenuBar))

	test	DWORD PTR [esi+8], 1024			; 00000400H
	je	SHORT $LN41@BeginMenuB

; 9883 :         return false;
; 9884 : 
; 9885 :     IM_ASSERT(!window->DC.MenuBarAppending);
; 9886 :     BeginGroup(); // Save position

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup

; 9887 :     PushID("##menubar");

	push	OFFSET $SG122110
	call	?PushID@ImGui@@YAXPBD@Z			; ImGui::PushID
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	mov	ecx, DWORD PTR [esi+8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9887 :     PushID("##menubar");

	add	esp, 4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	xorps	xmm3, xmm3
	test	cl, 1
	je	SHORT $LN11@BeginMenuB
	xorps	xmm1, xmm1
	jmp	SHORT $LN12@BeginMenuB
$LN11@BeginMenuB:
	movss	xmm0, DWORD PTR [eax+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm1, DWORD PTR [eax+6176]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm0, xmm0

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm1, DWORD PTR [esi+620]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm1, xmm0
$LN12@BeginMenuB:

; 778  :     ImRect      MenuBarRect() const                     { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }

	movss	xmm4, DWORD PTR [esi+28]
	addss	xmm4, xmm1
	movss	DWORD PTR _y1$1$[ebp], xmm4

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	test	ecx, 1024				; 00000400H
	je	SHORT $LN17@BeginMenuB
	movss	xmm0, DWORD PTR [eax+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm3, DWORD PTR [eax+6176]

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	addss	xmm0, xmm0

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm3, DWORD PTR [esi+620]

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	addss	xmm3, xmm0
$LN17@BeginMenuB:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm2, DWORD PTR [esi+24]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 778  :     ImRect      MenuBarRect() const                     { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }

	addss	xmm3, xmm4
	movss	xmm0, DWORD PTR [esi+40]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9889 :     PushClipRect(ImVec2(ImFloor(rect.Min.x+0.5f), ImFloor(rect.Min.y + window->BorderSize + 0.5f)), ImVec2(ImFloor(rect.Max.x+0.5f), ImFloor(rect.Max.y+0.5f)), false);

	movss	xmm1, DWORD PTR __real@3f000000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 778  :     ImRect      MenuBarRect() const                     { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }

	addss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9889 :     PushClipRect(ImVec2(ImFloor(rect.Min.x+0.5f), ImFloor(rect.Min.y + window->BorderSize + 0.5f)), ImVec2(ImFloor(rect.Max.x+0.5f), ImFloor(rect.Max.y+0.5f)), false);

	push	0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _rect$$sroa$151$1$[ebp], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9889 :     PushClipRect(ImVec2(ImFloor(rect.Min.x+0.5f), ImFloor(rect.Min.y + window->BorderSize + 0.5f)), ImVec2(ImFloor(rect.Max.x+0.5f), ImFloor(rect.Max.y+0.5f)), false);

	addss	xmm3, xmm1
	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 140  : static inline float  ImFloor(float f)                                           { return (float)(int)f; }

	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	cvttss2si eax, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp], xmm0
	movd	xmm0, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 140  : static inline float  ImFloor(float f)                                           { return (float)(int)f; }

	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9889 :     PushClipRect(ImVec2(ImFloor(rect.Min.x+0.5f), ImFloor(rect.Min.y + window->BorderSize + 0.5f)), ImVec2(ImFloor(rect.Max.x+0.5f), ImFloor(rect.Max.y+0.5f)), false);

	movaps	xmm0, xmm2
	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 140  : static inline float  ImFloor(float f)                                           { return (float)(int)f; }

	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9889 :     PushClipRect(ImVec2(ImFloor(rect.Min.x+0.5f), ImFloor(rect.Min.y + window->BorderSize + 0.5f)), ImVec2(ImFloor(rect.Max.x+0.5f), ImFloor(rect.Max.y+0.5f)), false);

	movss	xmm0, DWORD PTR [esi+128]
	addss	xmm0, xmm4
	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 140  : static inline float  ImFloor(float f)                                           { return (float)(int)f; }

	cvttss2si eax, xmm0
	movd	xmm0, eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9889 :     PushClipRect(ImVec2(ImFloor(rect.Min.x+0.5f), ImFloor(rect.Min.y + window->BorderSize + 0.5f)), ImVec2(ImFloor(rect.Max.x+0.5f), ImFloor(rect.Max.y+0.5f)), false);

	lea	eax, DWORD PTR $T2[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 140  : static inline float  ImFloor(float f)                                           { return (float)(int)f; }

	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9889 :     PushClipRect(ImVec2(ImFloor(rect.Min.x+0.5f), ImFloor(rect.Min.y + window->BorderSize + 0.5f)), ImVec2(ImFloor(rect.Max.x+0.5f), ImFloor(rect.Max.y+0.5f)), false);

	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9889 :     PushClipRect(ImVec2(ImFloor(rect.Min.x+0.5f), ImFloor(rect.Min.y + window->BorderSize + 0.5f)), ImVec2(ImFloor(rect.Max.x+0.5f), ImFloor(rect.Max.y+0.5f)), false);

	call	?PushClipRect@ImGui@@YAXABUImVec2@@0_N@Z ; ImGui::PushClipRect

; 9890 :     window->DC.CursorPos = ImVec2(rect.Min.x + window->DC.MenuBarOffsetX, rect.Min.y);// + g.Style.FramePadding.y);

	movss	xmm0, DWORD PTR [esi+288]
	add	esp, 12					; 0000000cH
	addss	xmm0, DWORD PTR _rect$$sroa$151$1$[ebp]

; 9891 :     window->DC.LayoutType = ImGuiLayoutType_Horizontal;
; 9892 :     window->DC.NavLayerCurrent++;

	inc	DWORD PTR [esi+272]
	mov	DWORD PTR [esi+308], 1

; 9893 :     window->DC.MenuBarAppending = true;

	mov	BYTE PTR [esi+284], 1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp], xmm0
	movss	xmm0, DWORD PTR _y1$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9890 :     window->DC.CursorPos = ImVec2(rect.Min.x + window->DC.MenuBarOffsetX, rect.Min.y);// + g.Style.FramePadding.y);

	mov	eax, DWORD PTR $T3[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9890 :     window->DC.CursorPos = ImVec2(rect.Min.x + window->DC.MenuBarOffsetX, rect.Min.y);// + g.Style.FramePadding.y);

	mov	DWORD PTR [esi+192], eax
	mov	eax, DWORD PTR $T3[ebp+4]
	mov	DWORD PTR [esi+196], eax

; 9894 :     AlignFirstTextHeightToWidgets();

	call	?AlignFirstTextHeightToWidgets@ImGui@@YAXXZ ; ImGui::AlignFirstTextHeightToWidgets

; 9895 :     return true;

	mov	al, 1
	pop	esi

; 9896 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?BeginMenuBar@ImGui@@YA_NXZ ENDP			; ImGui::BeginMenuBar
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?EndMainMenuBar@ImGui@@YAXXZ PROC			; ImGui::EndMainMenuBar

; 9872 :     EndMenuBar();

	call	?EndMenuBar@ImGui@@YAXXZ		; ImGui::EndMenuBar

; 9873 :     End();

	call	?End@ImGui@@YAXXZ			; ImGui::End

; 9874 :     PopStyleVar(2);

	push	2
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar
	pop	ecx

; 9875 : }

	ret	0
?EndMainMenuBar@ImGui@@YAXXZ ENDP			; ImGui::EndMainMenuBar
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 8
$T2 = -8						; size = 8
$T3 = -8						; size = 8
?BeginMainMenuBar@ImGui@@YA_NXZ PROC			; ImGui::BeginMainMenuBar

; 9853 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 9854 :     ImGuiContext& g = *GImGui;

	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 9855 :     SetNextWindowPos(ImVec2(0.0f, 0.0f));

	lea	eax, DWORD PTR $T3[ebp]
	push	0
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T3[ebp], 0
	mov	DWORD PTR $T3[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9855 :     SetNextWindowPos(ImVec2(0.0f, 0.0f));

	call	?SetNextWindowPos@ImGui@@YAXABUImVec2@@H@Z ; ImGui::SetNextWindowPos
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR [esi+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9856 :     SetNextWindowSize(ImVec2(g.IO.DisplaySize.x, g.FontBaseSize + g.Style.FramePadding.y * 2.0f));

	lea	eax, DWORD PTR $T2[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9856 :     SetNextWindowSize(ImVec2(g.IO.DisplaySize.x, g.FontBaseSize + g.Style.FramePadding.y * 2.0f));

	movss	xmm0, DWORD PTR [esi+5360]
	addss	xmm0, xmm0
	push	0
	push	eax
	addss	xmm0, DWORD PTR [esi+6176]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9856 :     SetNextWindowSize(ImVec2(g.IO.DisplaySize.x, g.FontBaseSize + g.Style.FramePadding.y * 2.0f));

	call	?SetNextWindowSize@ImGui@@YAXABUImVec2@@H@Z ; ImGui::SetNextWindowSize

; 9857 :     PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);

	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esp], 0
	push	2
	call	?PushStyleVar@ImGui@@YAXHM@Z		; ImGui::PushStyleVar

; 9858 :     PushStyleVar(ImGuiStyleVar_WindowMinSize, ImVec2(0,0));

	lea	eax, DWORD PTR $T1[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9858 :     PushStyleVar(ImGuiStyleVar_WindowMinSize, ImVec2(0,0));

	push	eax
	push	3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9858 :     PushStyleVar(ImGuiStyleVar_WindowMinSize, ImVec2(0,0));

	call	?PushStyleVar@ImGui@@YAXHABUImVec2@@@Z	; ImGui::PushStyleVar

; 9859 :     if (!Begin("##MainMenuBar", NULL, ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoResize|ImGuiWindowFlags_NoMove|ImGuiWindowFlags_NoScrollbar|ImGuiWindowFlags_NoSavedSettings|ImGuiWindowFlags_MenuBar|ImGuiWindowFlags_AlwaysAutoResize)
; 9860 :         || !BeginMenuBar())

	push	1359					; 0000054fH
	push	0
	push	OFFSET $SG122096
	call	?Begin@ImGui@@YA_NPBDPA_NH@Z		; ImGui::Begin
	add	esp, 28					; 0000001cH
	test	al, al
	je	SHORT $LN3@BeginMainM
	call	?BeginMenuBar@ImGui@@YA_NXZ		; ImGui::BeginMenuBar
	test	al, al
	je	SHORT $LN3@BeginMainM

; 9865 :     }
; 9866 :     g.CurrentWindow->DC.MenuBarOffsetX += g.Style.DisplaySafeAreaPadding.x;

	mov	eax, DWORD PTR [esi+6240]
	movss	xmm0, DWORD PTR [esi+5432]
	pop	esi
	addss	xmm0, DWORD PTR [eax+288]
	movss	DWORD PTR [eax+288], xmm0

; 9867 :     return true;

	mov	al, 1

; 9868 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@BeginMainM:

; 9861 :     {
; 9862 :         End();

	call	?End@ImGui@@YAXXZ			; ImGui::End

; 9863 :         PopStyleVar(2);

	push	2
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar
	add	esp, 4

; 9864 :         return false;

	xor	al, al
	pop	esi

; 9868 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?BeginMainMenuBar@ImGui@@YA_NXZ ENDP			; ImGui::BeginMainMenuBar
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?EndTooltip@ImGui@@YAXXZ PROC				; ImGui::EndTooltip

; 4241 :     IM_ASSERT(GetCurrentWindowRead()->Flags & ImGuiWindowFlags_Tooltip);   // Mismatched BeginTooltip()/EndTooltip() calls
; 4242 :     ImGui::End();

	jmp	?End@ImGui@@YAXXZ			; ImGui::End
?EndTooltip@ImGui@@YAXXZ ENDP				; ImGui::EndTooltip
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?BeginTooltip@ImGui@@YAXXZ PROC				; ImGui::BeginTooltip

; 4235 :     ImGuiWindowFlags flags = ImGuiWindowFlags_Tooltip|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoMove|ImGuiWindowFlags_NoResize|ImGuiWindowFlags_NoSavedSettings|ImGuiWindowFlags_AlwaysAutoResize;
; 4236 :     ImGui::Begin("##Tooltip", NULL, flags);

	push	16777543				; 01000147H
	push	0
	push	OFFSET $SG117618
	call	?Begin@ImGui@@YA_NPBDPA_NH@Z		; ImGui::Begin
	add	esp, 12					; 0000000cH

; 4237 : }

	ret	0
?BeginTooltip@ImGui@@YAXXZ ENDP				; ImGui::BeginTooltip
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_fmt$ = 8						; size = 4
_args$ = 12						; size = 4
?SetTooltipV@ImGui@@YAXPBDPAD@Z PROC			; ImGui::SetTooltipV

; 4212 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 4213 :     ImGuiContext& g = *GImGui;
; 4214 :     ImFormatStringV(g.Tooltip, IM_ARRAYSIZE(g.Tooltip), fmt, args);

	push	DWORD PTR _args$[ebp]
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	DWORD PTR _fmt$[ebp]
	add	eax, 10548				; 00002934H
	push	1024					; 00000400H
	push	eax
	call	?ImFormatStringV@@YAHPADHPBD0@Z		; ImFormatStringV
	add	esp, 16					; 00000010H

; 4215 : }

	pop	ebp
	ret	0
?SetTooltipV@ImGui@@YAXPBDPAD@Z ENDP			; ImGui::SetTooltipV
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_fmt$ = 8						; size = 4
?SetTooltip@ImGui@@YAXPBDZZ PROC			; ImGui::SetTooltip

; 4218 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 4219 :     va_list args;
; 4220 :     va_start(args, fmt);
; 4221 :     SetTooltipV(fmt, args);

	lea	eax, DWORD PTR _fmt$[ebp+4]
	push	eax
	push	DWORD PTR _fmt$[ebp]
	call	?SetTooltipV@ImGui@@YAXPBDPAD@Z		; ImGui::SetTooltipV
	add	esp, 8

; 4222 :     va_end(args);
; 4223 : }

	pop	ebp
	ret	0
?SetTooltip@ImGui@@YAXPBDZZ ENDP			; ImGui::SetTooltip
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -16						; size = 16
_prefix$ = 8						; size = 4
_v$ = 12						; size = 4
?ValueColor@ImGui@@YAXPBDI@Z PROC			; ImGui::ValueColor

; 10698: {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 10699:     Text("%s: %08X", prefix, v);

	push	DWORD PTR _v$[ebp]
	push	DWORD PTR _prefix$[ebp]
	push	OFFSET $SG122612
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 10700:     SameLine();

	add	esp, 4
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	add	esp, 8

; 10701:     ColorButton(ColorConvertU32ToFloat4(v), true);

	lea	eax, DWORD PTR $T1[ebp]
	push	1
	push	1
	push	DWORD PTR _v$[ebp]
	push	eax
	call	?ColorConvertU32ToFloat4@ImGui@@YA?AUImVec4@@I@Z ; ImGui::ColorConvertU32ToFloat4
	add	esp, 8
	push	eax
	call	?ColorButton@ImGui@@YA_NABUImVec4@@_N1@Z ; ImGui::ColorButton
	add	esp, 12					; 0000000cH

; 10702: }

	mov	esp, ebp
	pop	ebp
	ret	0
?ValueColor@ImGui@@YAXPBDI@Z ENDP			; ImGui::ValueColor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_prefix$ = 8						; size = 4
_v$ = 12						; size = 4
?ValueColor@ImGui@@YAXPBDABUImVec4@@@Z PROC		; ImGui::ValueColor

; 10691: {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 10692:     Text("%s: (%.2f,%.2f,%.2f,%.2f)", prefix, v.x, v.y, v.z, v.w);

	mov	esi, DWORD PTR _v$[ebp]
	sub	esp, 32					; 00000020H
	movss	xmm0, DWORD PTR [esi+12]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+24], xmm0
	movss	xmm0, DWORD PTR [esi+8]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+16], xmm0
	movss	xmm0, DWORD PTR [esi+4]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR [esi]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR _prefix$[ebp]
	push	OFFSET $SG122606
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 10693:     SameLine();

	add	esp, 32					; 00000020H
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 10694:     ColorButton(v, true);

	push	1
	push	1
	push	esi
	call	?ColorButton@ImGui@@YA_NABUImVec4@@_N1@Z ; ImGui::ColorButton
	add	esp, 20					; 00000014H
	pop	esi

; 10695: }

	pop	ebp
	ret	0
?ValueColor@ImGui@@YAXPBDABUImVec4@@@Z ENDP		; ImGui::ValueColor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_fmt$1 = -64						; size = 64
_prefix$ = 8						; size = 4
_v$ = 12						; size = 4
_float_format$ = 16					; size = 4
?Value@ImGui@@YAXPBDM0@Z PROC				; ImGui::Value

; 10676: {

	npad	2
	push	ebp
	mov	ebp, esp

; 10677:     if (float_format)

	mov	eax, DWORD PTR _float_format$[ebp]
	sub	esp, 64					; 00000040H
	test	eax, eax
	je	SHORT $LN2@Value

; 10678:     {
; 10679:         char fmt[64];
; 10680:         ImFormatString(fmt, IM_ARRAYSIZE(fmt), "%%s: %s", float_format);

	push	eax
	push	OFFSET $SG122600
	lea	eax, DWORD PTR _fmt$1[ebp]
	push	64					; 00000040H
	push	eax
	call	?ImFormatString@@YAHPADHPBDZZ		; ImFormatString
	movss	xmm0, DWORD PTR _v$[ebp]

; 10681:         Text(fmt, prefix, v);

	lea	eax, DWORD PTR _fmt$1[ebp]
	cvtps2pd xmm0, xmm0
	add	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR _prefix$[ebp]
	push	eax

; 10682:     }
; 10683:     else
; 10684:     {
; 10685:         Text("%s: %.3f", prefix, v);

	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 16					; 00000010H

; 10686:     }
; 10687: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@Value:
	movss	xmm0, DWORD PTR _v$[ebp]

; 10682:     }
; 10683:     else
; 10684:     {
; 10685:         Text("%s: %.3f", prefix, v);

	sub	esp, 8
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR _prefix$[ebp]
	push	OFFSET $SG122601
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 16					; 00000010H

; 10686:     }
; 10687: }

	mov	esp, ebp
	pop	ebp
	ret	0
?Value@ImGui@@YAXPBDM0@Z ENDP				; ImGui::Value
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_prefix$ = 8						; size = 4
_v$ = 12						; size = 4
?Value@ImGui@@YAXPBDI@Z PROC				; ImGui::Value

; 10671: {

	npad	2
	push	ebp
	mov	ebp, esp

; 10672:     Text("%s: %d", prefix, v);

	push	DWORD PTR _v$[ebp]
	push	DWORD PTR _prefix$[ebp]
	push	OFFSET $SG122590
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 12					; 0000000cH

; 10673: }

	pop	ebp
	ret	0
?Value@ImGui@@YAXPBDI@Z ENDP				; ImGui::Value
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_prefix$ = 8						; size = 4
_v$ = 12						; size = 4
?Value@ImGui@@YAXPBDH@Z PROC				; ImGui::Value

; 10666: {

	npad	2
	push	ebp
	mov	ebp, esp

; 10667:     Text("%s: %d", prefix, v);

	push	DWORD PTR _v$[ebp]
	push	DWORD PTR _prefix$[ebp]
	push	OFFSET $SG122585
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 12					; 0000000cH

; 10668: }

	pop	ebp
	ret	0
?Value@ImGui@@YAXPBDH@Z ENDP				; ImGui::Value
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_prefix$ = 8						; size = 4
_b$ = 12						; size = 1
?Value@ImGui@@YAXPBD_N@Z PROC				; ImGui::Value

; 10661: {

	npad	2
	push	ebp
	mov	ebp, esp

; 10662:     Text("%s: %s", prefix, (b ? "true" : "false"));

	cmp	BYTE PTR _b$[ebp], 0
	mov	ecx, OFFSET $SG122579
	mov	eax, OFFSET $SG122578
	cmove	eax, ecx
	push	eax
	push	DWORD PTR _prefix$[ebp]
	push	OFFSET $SG122580
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 12					; 0000000cH

; 10663: }

	pop	ebp
	ret	0
?Value@ImGui@@YAXPBD_N@Z ENDP				; ImGui::Value
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_bb$ = -32						; size = 16
_bb$1$ = -16						; size = 16
?ListBoxFooter@ImGui@@YAXXZ PROC			; ImGui::ListBoxFooter

; 9763 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	push	edi

; 9764 :     ImGuiWindow* parent_window = GetParentWindow();

	call	?GetParentWindow@ImGui@@YAPAUImGuiWindow@@XZ ; ImGui::GetParentWindow
	mov	edi, eax

; 9765 :     const ImRect bb = parent_window->DC.LastItemRect;

	movups	xmm0, XMMWORD PTR [edi+252]
	movups	XMMWORD PTR _bb$1$[ebp], xmm0
	movups	XMMWORD PTR _bb$[ebp], xmm0

; 9766 :     const ImGuiStyle& style = GetStyle();

	call	?GetStyle@ImGui@@YAAAUImGuiStyle@@XZ	; ImGui::GetStyle
	mov	esi, eax

; 9767 : 
; 9768 :     EndChildFrame();

	call	?EndChildFrame@ImGui@@YAXXZ		; ImGui::EndChildFrame

; 9769 : 
; 9770 :     // Redeclare item size so that it includes the label (we have stored the full size in LastItemRect)
; 9771 :     // We call SameLine() to restore DC.CurrentLine* data
; 9772 :     SameLine();

	sub	esp, 8
	mov	DWORD PTR [esp+4], -1082130432		; bf800000H
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 9773 :     parent_window->DC.CursorPos = bb.Min;

	movups	xmm0, XMMWORD PTR _bb$1$[ebp]

; 9774 :     ItemSize(bb, style.FramePadding.y);

	add	esp, 4
	lea	eax, DWORD PTR _bb$[ebp]
	movd	DWORD PTR [edi+192], xmm0
	psrldq	xmm0, 4
	movd	DWORD PTR [edi+196], xmm0
	movss	xmm0, DWORD PTR [esi+40]
	movss	DWORD PTR [esp], xmm0
	push	eax
	call	?ItemSize@ImGui@@YAXABUImRect@@M@Z	; ImGui::ItemSize
	add	esp, 8

; 9775 :     EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup
	pop	edi
	pop	esi

; 9776 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ListBoxFooter@ImGui@@YAXXZ ENDP			; ImGui::ListBoxFooter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_size$ = -8						; size = 8
_label$ = 8						; size = 4
_items_count$ = 12					; size = 4
tv130 = 16						; size = 4
_height_in_items_f$ = 16				; size = 4
_height_in_items$ = 16					; size = 4
?ListBoxHeader@ImGui@@YA_NPBDHH@Z PROC			; ImGui::ListBoxHeader

; 9747 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 9748 :     // Size default to hold ~7 items. Fractional number of items helps seeing that we can scroll down/up without looking at scrollbar.
; 9749 :     // However we don't add +0.40f if items_count <= height_in_items. It is slightly dodgy, because it means a dynamic list of items will make the widget resize occasionally when it crosses that size.
; 9750 :     // I am expecting that someone will come and complain about this behavior in a remote future, then we can advise on a better solution.
; 9751 :     if (height_in_items < 0)

	mov	eax, DWORD PTR _height_in_items$[ebp]
	sub	esp, 8
	mov	ecx, DWORD PTR _items_count$[ebp]
	test	eax, eax
	jns	SHORT $LN2@ListBoxHea
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 125  : static inline int    ImMin(int lhs, int rhs)                                    { return lhs < rhs ? lhs : rhs; }

	mov	eax, 7
	cmp	ecx, eax
	cmovl	eax, ecx
$LN2@ListBoxHea:
	movd	xmm0, eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9753 :     float height_in_items_f = height_in_items < items_count ? (height_in_items + 0.40f) : (height_in_items + 0.00f);

	cvtdq2ps xmm0, xmm0
	cmp	eax, ecx
	jge	SHORT $LN4@ListBoxHea
	addss	xmm0, DWORD PTR __real@3ecccccd
$LN4@ListBoxHea:
	movss	DWORD PTR _height_in_items_f$[ebp], xmm0

; 9754 : 
; 9755 :     // We include ItemSpacing.y so that a list sized for the exact number of items doesn't make a scrollbar appears. We could also enforce that by passing a flag to BeginChild().
; 9756 :     ImVec2 size;
; 9757 :     size.x = 0.0f;

	mov	DWORD PTR _size$[ebp], 0

; 9758 :     size.y = GetTextLineHeightWithSpacing() * height_in_items_f + GetStyle().ItemSpacing.y;

	call	?GetTextLineHeightWithSpacing@ImGui@@YAMXZ ; ImGui::GetTextLineHeightWithSpacing
	fmul	DWORD PTR _height_in_items_f$[ebp]
	fstp	DWORD PTR tv130[ebp]
	call	?GetStyle@ImGui@@YAAAUImGuiStyle@@XZ	; ImGui::GetStyle
	fld	DWORD PTR tv130[ebp]
	fadd	DWORD PTR [eax+52]

; 9759 :     return ListBoxHeader(label, size);

	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	push	DWORD PTR _label$[ebp]
	fstp	DWORD PTR _size$[ebp+4]
	call	?ListBoxHeader@ImGui@@YA_NPBDABUImVec2@@@Z ; ImGui::ListBoxHeader
	add	esp, 8

; 9760 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ListBoxHeader@ImGui@@YA_NPBDHH@Z ENDP			; ImGui::ListBoxHeader
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_frame_bb$ = -60					; size = 16
_bb$ = -44						; size = 16
$T2 = -28						; size = 8
$T3 = -28						; size = 8
_label_size$ = -28					; size = 8
$T4 = -20						; size = 8
_size$ = -20						; size = 8
_id$1$ = -12						; size = 4
$T1$sroa$161$1$ = -8					; size = 4
$T1$sroa$229$1$ = -4					; size = 4
tv354 = -4						; size = 4
_label$ = 8						; size = 4
_size_arg$ = 12						; size = 4
?ListBoxHeader@ImGui@@YA_NPBDABUImVec2@@@Z PROC		; ImGui::ListBoxHeader

; 9722 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9722 : {

	sub	esp, 60					; 0000003cH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	push	esi
	mov	BYTE PTR [eax+134], 1
	mov	esi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9724 :     if (window->SkipItems)

	cmp	BYTE PTR [esi+137], 0
	je	SHORT $LN2@ListBoxHea

; 9725 :         return false;

	xor	al, al
	pop	esi

; 9744 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@ListBoxHea:
	push	ebx
	push	edi

; 9726 : 
; 9727 :     const ImGuiStyle& style = GetStyle();

	call	?GetStyle@ImGui@@YAAAUImGuiStyle@@XZ	; ImGui::GetStyle

; 9728 :     const ImGuiID id = GetID(label);

	mov	ebx, DWORD PTR _label$[ebp]
	mov	edi, eax
	push	ebx
	call	?GetID@ImGui@@YAIPBD@Z			; ImGui::GetID

; 9729 :     const ImVec2 label_size = CalcTextSize(label, NULL, true);

	mov	DWORD PTR [esp], -1082130432		; bf800000H
	push	1
	push	0
	mov	DWORD PTR _id$1$[ebp], eax
	lea	eax, DWORD PTR _label_size$[ebp]
	push	ebx
	push	eax
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize

; 9732 :     ImVec2 size = CalcItemSize(size_arg, CalcItemWidth(), GetTextLineHeightWithSpacing() * 7.4f + style.ItemSpacing.y);

	call	?GetTextLineHeightWithSpacing@ImGui@@YAMXZ ; ImGui::GetTextLineHeightWithSpacing
	fstp	DWORD PTR tv354[ebp]
	movss	xmm0, DWORD PTR tv354[ebp]
	add	esp, 16					; 00000010H
	mulss	xmm0, DWORD PTR __real@40eccccd
	addss	xmm0, DWORD PTR [edi+52]
	movss	DWORD PTR [esp], xmm0
	call	?CalcItemWidth@ImGui@@YAMXZ		; ImGui::CalcItemWidth
	mov	eax, DWORD PTR _size_arg$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR _size$[ebp]
	push	eax
	call	?CalcItemSize@ImGui@@YA?AUImVec2@@U2@MM@Z ; ImGui::CalcItemSize
	movss	xmm0, DWORD PTR _size$[ebp+4]
	xorps	xmm2, xmm2
	maxss	xmm0, DWORD PTR _label_size$[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm1, DWORD PTR [esi+192]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9732 :     ImVec2 size = CalcItemSize(size_arg, CalcItemWidth(), GetTextLineHeightWithSpacing() * 7.4f + style.ItemSpacing.y);

	add	esp, 20					; 00000014H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm3, DWORD PTR [esi+196]
	addss	xmm1, DWORD PTR _size$[ebp]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [esi+192]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm3, xmm0

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _frame_bb$[ebp], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9735 :     ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

	movss	xmm0, DWORD PTR _label_size$[ebp]
	comiss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [esi+196]
	mov	DWORD PTR _frame_bb$[ebp+4], eax

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	DWORD PTR $T1$sroa$229$1$[ebp], xmm1
	movss	DWORD PTR $T1$sroa$161$1$[ebp], xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9735 :     ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

	jbe	SHORT $LN5@ListBoxHea
	movss	xmm2, DWORD PTR [edi+56]
	addss	xmm2, xmm0
$LN5@ListBoxHea:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [esi+192]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movaps	xmm0, xmm1
	addss	xmm0, xmm2

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _bb$[ebp], eax
	mov	eax, DWORD PTR [esi+196]
	mov	DWORD PTR _bb$[ebp+4], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp+4], xmm3
	movss	DWORD PTR $T4[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR _bb$[ebp+8], eax
	mov	eax, DWORD PTR $T4[ebp+4]
	mov	DWORD PTR _bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9736 :     window->DC.LastItemRect = bb;

	movups	xmm0, XMMWORD PTR _bb$[ebp]
	movups	XMMWORD PTR [esi+252], xmm0

; 9737 : 
; 9738 :     BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup

; 9739 :     if (label_size.x > 0)

	movss	xmm0, DWORD PTR _label_size$[ebp]
	xorps	xmm1, xmm1
	comiss	xmm0, xmm1
	movss	xmm1, DWORD PTR _frame_bb$[ebp+4]
	jbe	SHORT $LN3@ListBoxHea

; 9740 :         RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

	movss	xmm0, DWORD PTR [edi+56]
	addss	xmm0, DWORD PTR $T1$sroa$229$1$[ebp]
	push	1
	push	0
	push	ebx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9740 :         RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

	movss	xmm0, DWORD PTR [edi+40]
	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9740 :         RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

	push	DWORD PTR $T3[ebp+4]
	push	DWORD PTR $T3[ebp]
	call	?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z	; ImGui::RenderText
	movss	xmm1, DWORD PTR _frame_bb$[ebp+4]
	add	esp, 20					; 00000014H
$LN3@ListBoxHea:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 245  :     ImVec2      GetSize() const                 { return ImVec2(Max.x-Min.x, Max.y-Min.y); }

	movss	xmm0, DWORD PTR $T1$sroa$229$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9742 :     BeginChildFrame(id, frame_bb.GetSize());

	lea	eax, DWORD PTR $T2[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 245  :     ImVec2      GetSize() const                 { return ImVec2(Max.x-Min.x, Max.y-Min.y); }

	subss	xmm0, DWORD PTR _frame_bb$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9742 :     BeginChildFrame(id, frame_bb.GetSize());

	push	0
	push	eax
	push	DWORD PTR _id$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 245  :     ImVec2      GetSize() const                 { return ImVec2(Max.x-Min.x, Max.y-Min.y); }

	movss	xmm0, DWORD PTR $T1$sroa$161$1$[ebp]
	subss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9742 :     BeginChildFrame(id, frame_bb.GetSize());

	call	?BeginChildFrame@ImGui@@YA_NIABUImVec2@@H@Z ; ImGui::BeginChildFrame
	add	esp, 12					; 0000000cH

; 9743 :     return true;

	mov	al, 1
	pop	edi
	pop	ebx
	pop	esi

; 9744 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ListBoxHeader@ImGui@@YA_NPBDABUImVec2@@@Z ENDP		; ImGui::ListBoxHeader
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_clipper$ = -44						; size = 24
$T1 = -20						; size = 8
_item_selected$2 = -12					; size = 1
_item_text$3 = -8					; size = 4
_value_changed$1$ = -1					; size = 1
_label$ = 8						; size = 4
_current_item$ = 12					; size = 4
_items_getter$ = 16					; size = 4
_data$ = 20						; size = 4
_items_count$ = 24					; size = 4
_height_in_items$ = 28					; size = 4
?ListBox@ImGui@@YA_NPBDPAHP6A_NPAXHPAPBD@Z2HH@Z PROC	; ImGui::ListBox

; 9785 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	esi

; 9786 :     if (!ListBoxHeader(label, items_count, height_in_items))

	push	DWORD PTR _height_in_items$[ebp]
	mov	esi, DWORD PTR _items_count$[ebp]
	push	esi
	push	DWORD PTR _label$[ebp]
	call	?ListBoxHeader@ImGui@@YA_NPBDHH@Z	; ImGui::ListBoxHeader
	add	esp, 12					; 0000000cH
	test	al, al
	jne	SHORT $LN7@ListBox
	pop	esi

; 9812 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@ListBox:
	push	ebx

; 9787 :         return false;
; 9788 : 
; 9789 :     // Assume all items have even height (= 1 line of text). If you need items of different or variable sizes you can create a custom version of ListBox() in your code without using the clipper.
; 9790 :     bool value_changed = false;

	xor	bl, bl
	mov	BYTE PTR _value_changed$1$[ebp], bl

; 9791 :     ImGuiListClipper clipper(items_count, GetTextLineHeightWithSpacing()); // We know exactly our line height here so we pass it as a minor optimization, but generally you don't need to.

	call	?GetTextLineHeightWithSpacing@ImGui@@YAMXZ ; ImGui::GetTextLineHeightWithSpacing
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1158 :     ImGuiListClipper(int items_count = -1, float items_height = -1.0f)  { Begin(items_count, items_height); } // NB: Begin() initialize every fields (as we allow user to call Begin/End multiple times on a same instance if they want).

	push	ecx
	fstp	DWORD PTR [esp]
	push	esi
	lea	ecx, DWORD PTR _clipper$[ebp]
	call	?Begin@ImGuiListClipper@@QAEXHM@Z	; ImGuiListClipper::Begin
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9792 :     while (clipper.Step())

	lea	ecx, DWORD PTR _clipper$[ebp]
	call	?Step@ImGuiListClipper@@QAE_NXZ		; ImGuiListClipper::Step
	test	al, al
	je	$LN3@ListBox
	push	edi
	npad	3
$LL2@ListBox:

; 9793 :         for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)

	mov	esi, DWORD PTR _clipper$[ebp+16]
	mov	ebx, DWORD PTR _clipper$[ebp+20]
	cmp	esi, ebx
	jge	SHORT $LN5@ListBox
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp], 0
	mov	DWORD PTR $T1[ebp+4], 0
$LL6@ListBox:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9795 :             const bool item_selected = (i == *current_item);

	mov	eax, DWORD PTR _current_item$[ebp]
	mov	edi, DWORD PTR [eax]

; 9796 :             const char* item_text;
; 9797 :             if (!items_getter(data, i, &item_text))

	lea	eax, DWORD PTR _item_text$3[ebp]
	push	eax
	push	esi
	push	DWORD PTR _data$[ebp]
	cmp	esi, edi
	sete	BYTE PTR _item_selected$2[ebp]
	call	DWORD PTR _items_getter$[ebp]
	test	al, al
	mov	ecx, OFFSET $SG122045

; 9798 :                 item_text = "*Unknown item*";
; 9799 : 
; 9800 :             PushID(i);

	push	esi
	cmovne	ecx, DWORD PTR _item_text$3[ebp]
	mov	DWORD PTR _item_text$3[ebp], ecx
	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID

; 9801 :             if (Selectable(item_text, item_selected))

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	push	0
	push	DWORD PTR _item_selected$2[ebp]
	push	DWORD PTR _item_text$3[ebp]
	call	?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ; ImGui::Selectable
	add	esp, 32					; 00000020H
	test	al, al
	je	SHORT $LN9@ListBox

; 9802 :             {
; 9803 :                 *current_item = i;

	mov	eax, DWORD PTR _current_item$[ebp]

; 9804 :                 value_changed = true;

	mov	BYTE PTR _value_changed$1$[ebp], 1
	mov	DWORD PTR [eax], esi
$LN9@ListBox:
	cmp	esi, edi

; 9805 :             }
; 9806 :             if (item_selected)

	jne	SHORT $LN10@ListBox

; 9807 :                 SetItemDefaultFocus();

	call	?SetItemDefaultFocus@ImGui@@YAXXZ	; ImGui::SetItemDefaultFocus
$LN10@ListBox:

; 9808 :             PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID
	inc	esi
	cmp	esi, ebx
	jl	SHORT $LL6@ListBox
$LN5@ListBox:

; 9792 :     while (clipper.Step())

	lea	ecx, DWORD PTR _clipper$[ebp]
	call	?Step@ImGuiListClipper@@QAE_NXZ		; ImGuiListClipper::Step
	test	al, al
	jne	$LL2@ListBox
	mov	bl, BYTE PTR _value_changed$1$[ebp]
	pop	edi
$LN3@ListBox:

; 9809 :         }
; 9810 :     ListBoxFooter();

	call	?ListBoxFooter@ImGui@@YAXXZ		; ImGui::ListBoxFooter

; 9811 :     return value_changed;

	mov	al, bl
	pop	ebx
	pop	esi

; 9812 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ListBox@ImGui@@YA_NPBDPAHP6A_NPAXHPAPBD@Z2HH@Z ENDP	; ImGui::ListBox
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_current_item$ = 12					; size = 4
_items$ = 16						; size = 4
_items_count$ = 20					; size = 4
_height_items$ = 24					; size = 4
?ListBox@ImGui@@YA_NPBDPAHPBQBDHH@Z PROC		; ImGui::ListBox

; 9779 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 9780 :     const bool value_changed = ListBox(label, current_item, Items_ArrayGetter, (void*)items, items_count, height_items);

	push	DWORD PTR _height_items$[ebp]
	push	DWORD PTR _items_count$[ebp]
	push	DWORD PTR _items$[ebp]
	push	OFFSET ?Items_ArrayGetter@@YA_NPAXHPAPBD@Z ; Items_ArrayGetter
	push	DWORD PTR _current_item$[ebp]
	push	DWORD PTR _label$[ebp]
	call	?ListBox@ImGui@@YA_NPBDPAHP6A_NPAXHPAPBD@Z2HH@Z ; ImGui::ListBox
	add	esp, 24					; 00000018H

; 9781 :     return value_changed;
; 9782 : }

	pop	ebp
	ret	0
?ListBox@ImGui@@YA_NPBDPAHPBQBDHH@Z ENDP		; ImGui::ListBox
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_p_selected$ = 12					; size = 4
_flags$ = 16						; size = 4
_size_arg$ = 20						; size = 4
?Selectable@ImGui@@YA_NPBDPA_NHABUImVec2@@@Z PROC	; ImGui::Selectable

; 9710 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 9711 :     if (Selectable(label, *p_selected, flags, size_arg))

	push	DWORD PTR _size_arg$[ebp]
	mov	esi, DWORD PTR _p_selected$[ebp]
	push	DWORD PTR _flags$[ebp]
	movzx	eax, BYTE PTR [esi]
	push	eax
	push	DWORD PTR _label$[ebp]
	call	?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ; ImGui::Selectable
	add	esp, 16					; 00000010H
	test	al, al
	je	SHORT $LN2@Selectable

; 9712 :     {
; 9713 :         *p_selected = !*p_selected;

	cmp	BYTE PTR [esi], 0
	sete	al
	mov	BYTE PTR [esi], al

; 9714 :         return true;

	mov	al, 1
	pop	esi

; 9717 : }

	pop	ebp
	ret	0
$LN2@Selectable:

; 9715 :     }
; 9716 :     return false;

	xor	al, al
	pop	esi

; 9717 : }

	pop	ebp
	ret	0
?Selectable@ImGui@@YA_NPBDPA_NHABUImVec2@@@Z ENDP	; ImGui::Selectable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_bb$ = -92						; size = 16
_bb_with_spacing$ = -76					; size = 16
$T1 = -60						; size = 8
$T2 = -60						; size = 8
$T3 = -52						; size = 8
_window_padding$ = -52					; size = 8
_label_size$ = -44					; size = 8
$T4 = -36						; size = 8
$T5 = -36						; size = 8
tv629 = -32						; size = 4
tv636 = -28						; size = 4
_bb_with_spacing$2$ = -24				; size = 4
$T6 = -20						; size = 8
_pos$3$ = -16						; size = 4
$T7 = -12						; size = 4
tv633 = -12						; size = 4
_id$ = -8						; size = 4
_pressed$1$ = -3					; size = 1
_held$ = -2						; size = 1
_hovered$ = -1						; size = 1
_label$ = 8						; size = 4
_selected$ = 12						; size = 1
_flags$ = 16						; size = 4
_size_arg$ = 20						; size = 4
?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z PROC		; ImGui::Selectable

; 9625 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9625 : {

	sub	esp, 92					; 0000005cH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	push	edi
	mov	BYTE PTR [eax+134], 1
	mov	edi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9627 :     if (window->SkipItems)

	cmp	BYTE PTR [edi+137], 0
	je	SHORT $LN2@Selectable

; 9628 :         return false;

	xor	al, al
	pop	edi

; 9707 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@Selectable:
	push	ebx

; 9629 : 
; 9630 :     ImGuiContext& g = *GImGui;

	mov	ebx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	esi

; 9631 :     const ImGuiStyle& style = g.Style;
; 9632 : 
; 9633 :     if ((flags & ImGuiSelectableFlags_SpanAllColumns) && window->DC.ColumnsCount > 1)

	mov	esi, DWORD PTR _flags$[ebp]
	and	esi, 2
	mov	DWORD PTR tv636[ebp], esi
	je	SHORT $LN3@Selectable
	cmp	DWORD PTR [edi+416], 1
	jle	SHORT $LN3@Selectable

; 9634 :         PopClipRect();

	call	?PopClipRect@ImGui@@YAXXZ		; ImGui::PopClipRect
$LN3@Selectable:

; 9635 : 
; 9636 :     ImGuiID id = window->GetID(label);

	push	0
	push	DWORD PTR _label$[ebp]
	mov	ecx, edi
	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID

; 9637 :     ImVec2 label_size = CalcTextSize(label, NULL, true);

	push	ecx
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	push	1
	push	0
	push	DWORD PTR _label$[ebp]
	mov	DWORD PTR _id$[ebp], eax
	lea	eax, DWORD PTR _label_size$[ebp]
	push	eax
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize

; 9638 :     ImVec2 size(size_arg.x != 0.0f ? size_arg.x : label_size.x, size_arg.y != 0.0f ? size_arg.y : label_size.y);

	mov	ecx, DWORD PTR _size_arg$[ebp]
	add	esp, 20					; 00000014H
	xorps	xmm0, xmm0
	movss	xmm1, DWORD PTR [ecx+4]
	ucomiss	xmm1, xmm0
	movss	DWORD PTR $T7[ebp], xmm1
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN23@Selectable
	movss	xmm1, DWORD PTR _label_size$[ebp+4]
	movss	DWORD PTR $T7[ebp], xmm1
$LN23@Selectable:
	movss	xmm2, DWORD PTR [ecx]
	ucomiss	xmm2, xmm0
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN25@Selectable
	movss	xmm2, DWORD PTR _label_size$[ebp]
$LN25@Selectable:
	movss	xmm4, DWORD PTR [edi+192]

; 9640 :     pos.y += window->DC.CurrentLineTextBaseOffset;

	movss	xmm3, DWORD PTR [edi+228]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movaps	xmm0, xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9640 :     pos.y += window->DC.CurrentLineTextBaseOffset;

	addss	xmm3, DWORD PTR [edi+196]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm2
	movss	DWORD PTR _pos$3$[ebp], xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9642 :     ItemSize(bb);

	push	ecx
	mov	DWORD PTR [esp], 0
	movss	DWORD PTR _bb$[ebp], xmm4
	movss	DWORD PTR _bb_with_spacing$2$[ebp], xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T5[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movaps	xmm0, xmm1

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T5[ebp]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm3

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _bb$[ebp+8], eax
	movss	DWORD PTR _bb$[ebp+4], xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T5[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T5[ebp+4]
	mov	DWORD PTR _bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9642 :     ItemSize(bb);

	lea	eax, DWORD PTR _bb$[ebp]
	push	eax
	call	?ItemSize@ImGui@@YAXABUImRect@@M@Z	; ImGui::ItemSize

; 9643 : 
; 9644 :     // Fill horizontal space.
; 9645 :     ImVec2 window_padding = window->WindowPadding;

	mov	eax, DWORD PTR [edi+80]
	add	esp, 8
	mov	DWORD PTR _window_padding$[ebp], eax
	mov	eax, DWORD PTR [edi+84]
	mov	DWORD PTR _window_padding$[ebp+4], eax
	test	esi, esi

; 9646 :     float max_x = (flags & ImGuiSelectableFlags_SpanAllColumns) ? GetWindowContentRegionMax().x : GetContentRegionMax().x;

	je	SHORT $LN26@Selectable
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	?GetWindowContentRegionMax@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetWindowContentRegionMax
	jmp	SHORT $LN63@Selectable
$LN26@Selectable:
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?GetContentRegionMax@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetContentRegionMax
$LN63@Selectable:
	movss	xmm1, DWORD PTR [eax]
	add	esp, 4

; 9647 :     float w_draw = ImMax(label_size.x, window->Pos.x + max_x - window_padding.x - window->DC.CursorPos.x);
; 9648 :     ImVec2 size_draw((size_arg.x != 0 && !(flags & ImGuiSelectableFlags_DrawFillAvailWidth)) ? size_arg.x : w_draw, size_arg.y != 0.0f ? size_arg.y : size.y);

	mov	ecx, DWORD PTR _size_arg$[ebp]
	movss	xmm0, DWORD PTR [edi+24]
	movss	xmm4, DWORD PTR _window_padding$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR tv629[ebp], xmm1
	xorps	xmm1, xmm1
	movss	xmm2, DWORD PTR [ecx+4]
	ucomiss	xmm2, xmm1
	subss	xmm0, xmm4
	lahf
	subss	xmm0, DWORD PTR [edi+192]
	maxss	xmm0, DWORD PTR _label_size$[ebp]
	test	ah, 68					; 00000044H
	jp	SHORT $LN29@Selectable
	movss	xmm2, DWORD PTR $T7[ebp]
$LN29@Selectable:
	movss	xmm3, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _flags$[ebp]
	ucomiss	xmm3, xmm1
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN30@Selectable
	test	cl, 64					; 00000040H
	jne	SHORT $LN30@Selectable
	movaps	xmm0, xmm3
$LN30@Selectable:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm7, DWORD PTR _pos$3$[ebp]
	movss	xmm6, DWORD PTR _bb_with_spacing$2$[ebp]
	movaps	xmm5, xmm7
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9650 :     if (size_arg.x == 0.0f || (flags & ImGuiSelectableFlags_DrawFillAvailWidth))

	ucomiss	xmm3, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm5, xmm0
	movss	DWORD PTR _bb_with_spacing$[ebp], xmm7
	addss	xmm2, xmm6
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T6[ebp], xmm5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR _bb_with_spacing$[ebp+8], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T6[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T6[ebp+4]
	mov	DWORD PTR _bb_with_spacing$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9650 :     if (size_arg.x == 0.0f || (flags & ImGuiSelectableFlags_DrawFillAvailWidth))

	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN5@Selectable
	test	cl, 64					; 00000040H
	jne	SHORT $LN5@Selectable

; 9651 :         bb_with_spacing.Max.x += window_padding.x;

	movss	xmm5, DWORD PTR _bb_with_spacing$[ebp+8]
	jmp	SHORT $LN4@Selectable
$LN5@Selectable:
	addss	xmm5, xmm4
$LN4@Selectable:

; 9652 : 
; 9653 :     // Selectables are tightly packed together, we extend the box to cover spacing between selectable.
; 9654 :     float spacing_L = (float)(int)(style.ItemSpacing.x * 0.5f);

	movss	xmm4, DWORD PTR [ebx+5368]

; 9655 :     float spacing_U = (float)(int)(style.ItemSpacing.y * 0.5f);
; 9656 :     float spacing_R = style.ItemSpacing.x - spacing_L;
; 9657 :     float spacing_D = style.ItemSpacing.y - spacing_U;
; 9658 :     bb_with_spacing.Min.x -= spacing_L;
; 9659 :     bb_with_spacing.Min.y -= spacing_U;
; 9660 :     bb_with_spacing.Max.x += spacing_R;
; 9661 :     bb_with_spacing.Max.y += spacing_D;
; 9662 :     if (!ItemAdd(bb_with_spacing, (flags & ImGuiSelectableFlags_Disabled) ? NULL : &id))

	and	ecx, 32					; 00000020H
	movss	xmm3, DWORD PTR [ebx+5372]
	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR __real@3f000000
	mov	DWORD PTR tv633[ebp], ecx
	mov	ecx, 0
	push	0
	cvttss2si eax, xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR __real@3f000000
	movd	xmm2, eax
	cvttss2si eax, xmm0
	cvtdq2ps xmm2, xmm2
	movd	xmm0, eax
	lea	eax, DWORD PTR _id$[ebp]
	cvtdq2ps xmm0, xmm0
	cmovne	eax, ecx
	push	eax
	lea	eax, DWORD PTR _bb_with_spacing$[ebp]
	push	eax
	subss	xmm4, xmm2
	subss	xmm3, xmm0
	subss	xmm7, xmm2
	subss	xmm6, xmm0
	addss	xmm4, xmm5
	addss	xmm3, DWORD PTR _bb_with_spacing$[ebp+12]
	movss	DWORD PTR _bb_with_spacing$[ebp], xmm7
	movss	DWORD PTR _bb_with_spacing$[ebp+4], xmm6
	movss	DWORD PTR _bb_with_spacing$[ebp+8], xmm4
	movss	DWORD PTR _bb_with_spacing$[ebp+12], xmm3
	call	?ItemAdd@ImGui@@YA_NABUImRect@@PBIPBU2@@Z ; ImGui::ItemAdd
	add	esp, 12					; 0000000cH
	test	al, al
	jne	SHORT $LN6@Selectable
	test	esi, esi

; 9663 :     {
; 9664 :         if ((flags & ImGuiSelectableFlags_SpanAllColumns) && window->DC.ColumnsCount > 1)

	je	SHORT $LN7@Selectable
	cmp	DWORD PTR [edi+416], 1
	jle	SHORT $LN7@Selectable

; 9665 :             PushColumnClipRect();

	push	-1
	call	?PushColumnClipRect@@YAXH@Z		; PushColumnClipRect
	add	esp, 4
$LN7@Selectable:

; 9666 :         return false;

	pop	esi
	pop	ebx
	xor	al, al
	pop	edi

; 9707 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@Selectable:
	mov	eax, DWORD PTR _flags$[ebp]
	mov	ecx, eax
	shr	ecx, 1
	and	ecx, 4
	mov	edx, ecx
	or	edx, 8

; 9667 :     }
; 9668 : 
; 9669 :     ImGuiButtonFlags button_flags = 0;
; 9670 :     if (flags & ImGuiSelectableFlags_Menu) button_flags |= ImGuiButtonFlags_PressedOnClick;
; 9671 :     if (flags & ImGuiSelectableFlags_MenuItem) button_flags |= ImGuiButtonFlags_PressedOnRelease;

	and	al, 16					; 00000010H

; 9672 :     if (flags & ImGuiSelectableFlags_Disabled) button_flags |= ImGuiButtonFlags_Disabled;
; 9673 :     if (flags & ImGuiSelectableFlags_AllowDoubleClick) button_flags |= ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnDoubleClick;

	mov	eax, DWORD PTR _flags$[ebp]
	cmove	edx, ecx
	mov	esi, edx
	or	esi, 128				; 00000080H
	cmp	DWORD PTR tv633[ebp], 0
	cmove	esi, edx
	mov	ecx, esi
	or	ecx, 18					; 00000012H
	and	al, 4

; 9674 :     bool hovered, held;
; 9675 :     bool pressed = ButtonBehavior(bb_with_spacing, id, &hovered, &held, button_flags);

	lea	eax, DWORD PTR _held$[ebp]
	cmove	ecx, esi
	push	ecx
	push	eax
	lea	eax, DWORD PTR _hovered$[ebp]
	push	eax
	push	DWORD PTR _id$[ebp]
	lea	eax, DWORD PTR _bb_with_spacing$[ebp]
	push	eax
	call	?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z ; ImGui::ButtonBehavior
	mov	esi, DWORD PTR tv633[ebp]
	add	esp, 20					; 00000014H
	movzx	ecx, BYTE PTR _selected$[ebp]

; 9676 :     if (flags & ImGuiSelectableFlags_Disabled)
; 9677 :         selected = false;
; 9678 : 
; 9679 :     // Hovering selectable with mouse updates NavId accordingly so navigation can be resumed with gamepad/keyboard (this doesn't happen on most widgets)
; 9680 :     if (hovered && !g.NavDisableMouseHover && g.NavWindow == window && (g.IO.MouseDelta.x != 0.0f || g.IO.MouseDelta.y != 0.0f))

	mov	dl, BYTE PTR _hovered$[ebp]
	mov	BYTE PTR _pressed$1$[ebp], al
	xor	eax, eax
	test	esi, esi
	cmove	eax, ecx
	test	dl, dl
	je	SHORT $LN58@Selectable
	cmp	BYTE PTR [ebx+6455], 0
	jne	SHORT $LN16@Selectable
	cmp	DWORD PTR [ebx+6380], edi
	jne	SHORT $LN16@Selectable
	movss	xmm0, DWORD PTR [ebx+872]
	xorps	xmm1, xmm1
	ucomiss	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN14@Selectable
	movss	xmm0, DWORD PTR [ebx+876]
	ucomiss	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN16@Selectable
$LN14@Selectable:

; 9681 :     {
; 9682 :         g.NavDisableHighlight = true;

	mov	BYTE PTR [ebx+6454], 1

; 9683 :         SetNavId(id);

	push	DWORD PTR _id$[ebp]
	call	?SetNavId@@YAXI@Z			; SetNavId
	add	esp, 4

; 9684 :     }
; 9685 : 
; 9686 :     // Render
; 9687 :     if (hovered || selected)

	jmp	SHORT $LN16@Selectable
$LN58@Selectable:
	test	al, al
	je	SHORT $LN15@Selectable
$LN16@Selectable:

; 9688 :     {
; 9689 :         const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);

	cmp	BYTE PTR _held$[ebp], 0
	je	SHORT $LN32@Selectable
	test	dl, dl
	je	SHORT $LN32@Selectable
	mov	eax, 27					; 0000001bH
	jmp	SHORT $LN33@Selectable
$LN32@Selectable:
	xor	eax, eax
	test	dl, dl
	setne	al
	add	eax, 25					; 00000019H
$LN33@Selectable:

; 9690 :         RenderFrame(bb_with_spacing.Min, bb_with_spacing.Max, col, false, 0.0f);

	push	ecx
	mov	DWORD PTR [esp], 0
	push	0
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	eax
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	add	esp, 8
	push	eax
	push	DWORD PTR _bb_with_spacing$[ebp+12]
	push	DWORD PTR _bb_with_spacing$[ebp+8]
	push	DWORD PTR _bb_with_spacing$[ebp+4]
	push	DWORD PTR _bb_with_spacing$[ebp]
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame
	add	esp, 28					; 0000001cH
$LN15@Selectable:
	cmp	DWORD PTR tv636[ebp], 0

; 9691 :     }
; 9692 : 
; 9693 :     if ((flags & ImGuiSelectableFlags_SpanAllColumns) && window->DC.ColumnsCount > 1)

	je	SHORT $LN17@Selectable
	cmp	DWORD PTR [edi+416], 1
	jle	SHORT $LN17@Selectable

; 9694 :     {
; 9695 :         PushColumnClipRect();

	push	-1
	call	?PushColumnClipRect@@YAXH@Z		; PushColumnClipRect

; 9696 :         bb_with_spacing.Max.x -= (GetContentRegionMax().x - max_x);

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?GetContentRegionMax@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetContentRegionMax
	movss	xmm0, DWORD PTR _bb_with_spacing$[ebp+8]
	add	esp, 8
	movss	xmm1, DWORD PTR [eax]
	subss	xmm1, DWORD PTR tv629[ebp]
	subss	xmm0, xmm1
	movss	DWORD PTR _bb_with_spacing$[ebp+8], xmm0
$LN17@Selectable:
	test	esi, esi

; 9697 :     }
; 9698 : 
; 9699 :     if (flags & ImGuiSelectableFlags_Disabled) PushStyleColor(ImGuiCol_Text, g.Style.Colors[ImGuiCol_TextDisabled]);

	je	SHORT $LN18@Selectable
	lea	eax, DWORD PTR [ebx+5464]
	push	eax
	push	0
	call	?PushStyleColor@ImGui@@YAXHABUImVec4@@@Z ; ImGui::PushStyleColor
	add	esp, 8
$LN18@Selectable:

; 9700 :     RenderTextClipped(bb.Min, bb_with_spacing.Max, label, NULL, &label_size, ImVec2(0.0f,0.0f));

	push	0
	lea	eax, DWORD PTR $T3[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T3[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9700 :     RenderTextClipped(bb.Min, bb_with_spacing.Max, label, NULL, &label_size, ImVec2(0.0f,0.0f));

	push	eax
	lea	eax, DWORD PTR _label_size$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T3[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9700 :     RenderTextClipped(bb.Min, bb_with_spacing.Max, label, NULL, &label_size, ImVec2(0.0f,0.0f));

	push	eax
	push	0
	push	DWORD PTR _label$[ebp]
	lea	eax, DWORD PTR _bb_with_spacing$[ebp+8]
	push	eax
	lea	eax, DWORD PTR _bb$[ebp]
	push	eax
	call	?RenderTextClipped@ImGui@@YAXABUImVec2@@0PBD1PBU2@0PBUImRect@@@Z ; ImGui::RenderTextClipped
	add	esp, 28					; 0000001cH
	test	esi, esi

; 9701 :     if (flags & ImGuiSelectableFlags_Disabled) PopStyleColor();

	je	SHORT $LN19@Selectable
	push	1
	call	?PopStyleColor@ImGui@@YAXH@Z		; ImGui::PopStyleColor
	add	esp, 4
$LN19@Selectable:

; 9702 : 
; 9703 :     // Automatically close popups
; 9704 :     if (pressed && (window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiSelectableFlags_DontClosePopups) && !((window->DC.ItemFlags & ImGuiItemFlags_SelectableDontClosePopup)))

	mov	bl, BYTE PTR _pressed$1$[ebp]
	test	bl, bl
	je	SHORT $LN20@Selectable
	test	DWORD PTR [edi+8], 33554432		; 02000000H
	je	SHORT $LN20@Selectable
	test	BYTE PTR _flags$[ebp], 1
	jne	SHORT $LN20@Selectable
	test	BYTE PTR [edi+312], 8
	jne	SHORT $LN20@Selectable

; 9705 :         CloseCurrentPopup();

	call	?CloseCurrentPopup@ImGui@@YAXXZ		; ImGui::CloseCurrentPopup
$LN20@Selectable:
	pop	esi

; 9706 :     return pressed;

	mov	al, bl
	pop	ebx
	pop	edi

; 9707 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ENDP		; ImGui::Selectable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -16						; size = 8
_id$1$ = -8						; size = 4
_is_open$1$ = -1					; size = 1
_label$ = 8						; size = 4
_p_open$ = 12						; size = 4
_flags$ = 16						; size = 4
?CollapsingHeader@ImGui@@YA_NPBDPA_NH@Z PROC		; ImGui::CollapsingHeader

; 7034 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7034 : {

	sub	esp, 16					; 00000010H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	push	ebx
	mov	BYTE PTR [eax+134], 1
	mov	ebx, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7036 :     if (window->SkipItems)

	cmp	BYTE PTR [ebx+137], 0
	je	SHORT $LN2@Collapsing

; 7037 :         return false;

	xor	al, al
	pop	ebx

; 7051 :     }
; 7052 : 
; 7053 :     return is_open;
; 7054 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@Collapsing:
	push	edi

; 7038 : 
; 7039 :     if (p_open && !*p_open)

	mov	edi, DWORD PTR _p_open$[ebp]
	test	edi, edi
	je	SHORT $LN3@Collapsing
	cmp	BYTE PTR [edi], 0
	jne	SHORT $LN3@Collapsing

; 7040 :         return false;

	pop	edi
	xor	al, al
	pop	ebx

; 7051 :     }
; 7052 : 
; 7053 :     return is_open;
; 7054 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@Collapsing:

; 7041 : 
; 7042 :     ImGuiID id = window->GetID(label);

	push	0
	push	DWORD PTR _label$[ebp]
	mov	ecx, ebx
	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID
	xor	ecx, ecx
	mov	DWORD PTR _id$1$[ebp], eax
	test	edi, edi

; 7043 :     bool is_open = TreeNodeBehavior(id, flags | ImGuiTreeNodeFlags_CollapsingHeader | ImGuiTreeNodeFlags_NoTreePushOnOpen | (p_open ? ImGuiTreeNodeFlags_AllowOverlapMode : 0), label);

	push	0
	push	DWORD PTR _label$[ebp]
	setne	cl
	lea	ecx, DWORD PTR [ecx*4+26]
	or	ecx, DWORD PTR _flags$[ebp]
	push	ecx
	push	eax
	call	?TreeNodeBehavior@ImGui@@YA_NIHPBD0@Z	; ImGui::TreeNodeBehavior
	add	esp, 16					; 00000010H
	mov	BYTE PTR _is_open$1$[ebp], al

; 7044 :     if (p_open)

	test	edi, edi
	je	SHORT $LN16@Collapsing

; 7045 :     {
; 7046 :         // Create a small overlapping close button // FIXME: We can evolve this into user accessible helpers to add extra buttons on title bars, headers, etc.
; 7047 :         ImGuiContext& g = *GImGui;

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 7049 :         if (CloseButton(window->GetID((void*)(intptr_t)(id+1)), ImVec2(ImMin(window->DC.LastItemRect.Max.x, window->ClipRect.Max.x) - g.Style.FramePadding.x - button_sz, window->DC.LastItemRect.Min.y + g.Style.FramePadding.y + button_sz), button_sz))

	lea	eax, DWORD PTR $T1[ebp]
	movss	xmm0, DWORD PTR [ebx+480]
	minss	xmm0, DWORD PTR [ebx+260]
	push	ecx
	movss	xmm1, DWORD PTR [ecx+6172]
	mulss	xmm1, DWORD PTR __real@3f000000
	subss	xmm0, DWORD PTR [ecx+5356]
	movss	DWORD PTR [esp], xmm1
	push	eax
	mov	eax, DWORD PTR _id$1$[ebp]
	subss	xmm0, xmm1
	inc	eax
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7049 :         if (CloseButton(window->GetID((void*)(intptr_t)(id+1)), ImVec2(ImMin(window->DC.LastItemRect.Max.x, window->ClipRect.Max.x) - g.Style.FramePadding.x - button_sz, window->DC.LastItemRect.Min.y + g.Style.FramePadding.y + button_sz), button_sz))

	movss	xmm0, DWORD PTR [ecx+5360]
	mov	ecx, ebx
	addss	xmm0, DWORD PTR [ebx+256]
	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7049 :         if (CloseButton(window->GetID((void*)(intptr_t)(id+1)), ImVec2(ImMin(window->DC.LastItemRect.Max.x, window->ClipRect.Max.x) - g.Style.FramePadding.x - button_sz, window->DC.LastItemRect.Min.y + g.Style.FramePadding.y + button_sz), button_sz))

	call	?GetID@ImGuiWindow@@QAEIPBX@Z		; ImGuiWindow::GetID
	push	eax
	call	?CloseButton@ImGui@@YA_NIABUImVec2@@M@Z	; ImGui::CloseButton
	add	esp, 12					; 0000000cH
	test	al, al
	mov	al, BYTE PTR _is_open$1$[ebp]
	je	SHORT $LN16@Collapsing

; 7050 :             *p_open = false;

	mov	BYTE PTR [edi], 0
$LN16@Collapsing:
	pop	edi
	pop	ebx

; 7051 :     }
; 7052 : 
; 7053 :     return is_open;
; 7054 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CollapsingHeader@ImGui@@YA_NPBDPA_NH@Z ENDP		; ImGui::CollapsingHeader
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_flags$ = 12						; size = 4
?CollapsingHeader@ImGui@@YA_NPBDH@Z PROC		; ImGui::CollapsingHeader

; 7025 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	ecx, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7027 :     if (window->SkipItems)

	cmp	BYTE PTR [ecx+137], 0
	je	SHORT $LN2@Collapsing

; 7028 :         return false;

	xor	al, al

; 7031 : }

	pop	ebp
	ret	0
$LN2@Collapsing:

; 7029 : 
; 7030 :     return TreeNodeBehavior(window->GetID(label), flags | ImGuiTreeNodeFlags_CollapsingHeader | ImGuiTreeNodeFlags_NoTreePushOnOpen, label);

	mov	edx, DWORD PTR _label$[ebp]
	mov	eax, DWORD PTR _flags$[ebp]
	push	0
	push	edx
	or	eax, 26					; 0000001aH
	push	eax
	push	0
	push	edx
	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID
	push	eax
	call	?TreeNodeBehavior@ImGui@@YA_NIHPBD0@Z	; ImGui::TreeNodeBehavior
	add	esp, 16					; 00000010H

; 7031 : }

	pop	ebp
	ret	0
?CollapsingHeader@ImGui@@YA_NPBDH@Z ENDP		; ImGui::CollapsingHeader
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_is_open$ = 8						; size = 1
_cond$ = 12						; size = 4
?SetNextTreeNodeOpen@ImGui@@YAX_NH@Z PROC		; ImGui::SetNextTreeNodeOpen

; 7155 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 7156 :     ImGuiContext& g = *GImGui;

	mov	edx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 7157 :     g.SetNextTreeNodeOpenVal = is_open;
; 7158 :     g.SetNextTreeNodeOpenCond = cond ? cond : ImGuiSetCond_Always;

	mov	ecx, 1
	mov	al, BYTE PTR _is_open$[ebp]
	mov	BYTE PTR [edx+6590], al
	mov	eax, DWORD PTR _cond$[ebp]
	test	eax, eax
	cmovne	ecx, eax
	mov	DWORD PTR [edx+6592], ecx

; 7159 : }

	pop	ebp
	ret	0
?SetNextTreeNodeOpen@ImGui@@YAX_NH@Z ENDP		; ImGui::SetNextTreeNodeOpen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?GetTreeNodeToLabelSpacing@ImGui@@YAMXZ PROC		; ImGui::GetTreeNodeToLabelSpacing

; 7150 :     ImGuiContext& g = *GImGui;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 7151 :     return g.FontSize + (g.Style.FramePadding.x * 2.0f);

	fld	DWORD PTR [eax+5356]
	fadd	ST(0), ST(0)
	fadd	DWORD PTR [eax+6172]

; 7152 : }

	ret	0
?GetTreeNodeToLabelSpacing@ImGui@@YAMXZ ENDP		; ImGui::GetTreeNodeToLabelSpacing
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?TreeAdvanceToLabelPos@ImGui@@YAXXZ PROC		; ImGui::TreeAdvanceToLabelPos

; 7143 :     ImGuiContext& g = *GImGui;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	esi

; 7144 :     g.CurrentWindow->DC.CursorPos.x += GetTreeNodeToLabelSpacing();

	mov	esi, DWORD PTR [eax+6240]
	call	?GetTreeNodeToLabelSpacing@ImGui@@YAMXZ	; ImGui::GetTreeNodeToLabelSpacing
	fadd	DWORD PTR [esi+192]
	fstp	DWORD PTR [esi+192]
	pop	esi

; 7145 : }

	ret	0
?TreeAdvanceToLabelPos@ImGui@@YAXXZ ENDP		; ImGui::TreeAdvanceToLabelPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?TreePop@ImGui@@YAXXZ PROC				; ImGui::TreePop
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10655:     Unindent();

	push	ecx
	mov	DWORD PTR [esp], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	esi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10655:     Unindent();

	call	?Unindent@ImGui@@YAXM@Z			; ImGui::Unindent
	add	esp, 4

; 10656:     window->DC.TreeDepth--;

	dec	DWORD PTR [esi+244]
	pop	esi

; 10657:     PopID();

	jmp	?PopID@ImGui@@YAXXZ			; ImGui::PopID
?TreePop@ImGui@@YAXXZ ENDP				; ImGui::TreePop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_ptr_id$ = 8						; size = 4
?TreePush@ImGui@@YAXPBX@Z PROC				; ImGui::TreePush

; 10637: {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10639:     Indent();

	push	ecx
	mov	DWORD PTR [esp], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	esi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10639:     Indent();

	call	?Indent@ImGui@@YAXM@Z			; ImGui::Indent

; 10640:     window->DC.TreeDepth++;

	inc	DWORD PTR [esi+244]
	add	esp, 4

; 10641:     PushID(ptr_id ? ptr_id : (const void*)"#TreePush");

	mov	eax, DWORD PTR _ptr_id$[ebp]
	mov	ecx, OFFSET $SG122566
	test	eax, eax
	cmovne	ecx, eax
	pop	esi
	mov	DWORD PTR _ptr_id$[ebp], ecx

; 10642: }

	pop	ebp

; 10641:     PushID(ptr_id ? ptr_id : (const void*)"#TreePush");

	jmp	?PushID@ImGui@@YAXPBX@Z			; ImGui::PushID
?TreePush@ImGui@@YAXPBX@Z ENDP				; ImGui::TreePush
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_str_id$ = 8						; size = 4
?TreePush@ImGui@@YAXPBD@Z PROC				; ImGui::TreePush

; 10629: {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10631:     Indent();

	push	ecx
	mov	DWORD PTR [esp], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	esi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10631:     Indent();

	call	?Indent@ImGui@@YAXM@Z			; ImGui::Indent

; 10632:     window->DC.TreeDepth++;

	inc	DWORD PTR [esi+244]
	add	esp, 4

; 10633:     PushID(str_id ? str_id : "#TreePush");

	mov	eax, DWORD PTR _str_id$[ebp]
	mov	ecx, OFFSET $SG122560
	test	eax, eax
	cmovne	ecx, eax
	pop	esi
	mov	DWORD PTR _str_id$[ebp], ecx

; 10634: }

	pop	ebp

; 10633:     PushID(str_id ? str_id : "#TreePush");

	jmp	?PushID@ImGui@@YAXPBD@Z			; ImGui::PushID
?TreePush@ImGui@@YAXPBD@Z ENDP				; ImGui::TreePush
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_ptr_id$ = 8						; size = 4
_flags$ = 12						; size = 4
_fmt$ = 16						; size = 4
_args$ = 20						; size = 4
?TreeNodeExV@ImGui@@YA_NPBXHPBDPAD@Z PROC		; ImGui::TreeNodeExV

; 7077 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	ebx
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	ebx, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7079 :     if (window->SkipItems)

	cmp	BYTE PTR [ebx+137], 0
	je	SHORT $LN2@TreeNodeEx

; 7080 :         return false;

	xor	al, al
	pop	ebx

; 7085 : }

	pop	ebp
	ret	0
$LN2@TreeNodeEx:
	push	esi

; 7081 : 
; 7082 :     ImGuiContext& g = *GImGui;

	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	edi

; 7083 :     const char* label_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);

	push	DWORD PTR _args$[ebp]
	push	DWORD PTR _fmt$[ebp]
	lea	edi, DWORD PTR [esi+12116]
	push	3073					; 00000c01H
	push	edi
	call	?ImFormatStringV@@YAHPADHPBD0@Z		; ImFormatStringV
	add	esp, 16					; 00000010H
	add	esi, 12116				; 00002f54H
	add	eax, esi

; 7084 :     return TreeNodeBehavior(window->GetID(ptr_id), flags, g.TempBuffer, label_end);

	mov	ecx, ebx
	push	eax
	push	edi
	push	DWORD PTR _flags$[ebp]
	push	DWORD PTR _ptr_id$[ebp]
	call	?GetID@ImGuiWindow@@QAEIPBX@Z		; ImGuiWindow::GetID
	push	eax
	call	?TreeNodeBehavior@ImGui@@YA_NIHPBD0@Z	; ImGui::TreeNodeBehavior
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	pop	ebx

; 7085 : }

	pop	ebp
	ret	0
?TreeNodeExV@ImGui@@YA_NPBXHPBDPAD@Z ENDP		; ImGui::TreeNodeExV
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_str_id$ = 8						; size = 4
_flags$ = 12						; size = 4
_fmt$ = 16						; size = 4
_args$ = 20						; size = 4
?TreeNodeExV@ImGui@@YA_NPBDH0PAD@Z PROC			; ImGui::TreeNodeExV

; 7066 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	ebx
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	ebx, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7068 :     if (window->SkipItems)

	cmp	BYTE PTR [ebx+137], 0
	je	SHORT $LN2@TreeNodeEx

; 7069 :         return false;

	xor	al, al
	pop	ebx

; 7074 : }

	pop	ebp
	ret	0
$LN2@TreeNodeEx:
	push	esi

; 7070 : 
; 7071 :     ImGuiContext& g = *GImGui;

	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	edi

; 7072 :     const char* label_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);

	push	DWORD PTR _args$[ebp]
	push	DWORD PTR _fmt$[ebp]
	lea	edi, DWORD PTR [esi+12116]
	push	3073					; 00000c01H
	push	edi
	call	?ImFormatStringV@@YAHPADHPBD0@Z		; ImFormatStringV
	add	esp, 16					; 00000010H
	add	esi, 12116				; 00002f54H
	add	eax, esi

; 7073 :     return TreeNodeBehavior(window->GetID(str_id), flags, g.TempBuffer, label_end);

	mov	ecx, ebx
	push	eax
	push	edi
	push	DWORD PTR _flags$[ebp]
	push	0
	push	DWORD PTR _str_id$[ebp]
	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID
	push	eax
	call	?TreeNodeBehavior@ImGui@@YA_NIHPBD0@Z	; ImGui::TreeNodeBehavior
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	pop	ebx

; 7074 : }

	pop	ebp
	ret	0
?TreeNodeExV@ImGui@@YA_NPBDH0PAD@Z ENDP			; ImGui::TreeNodeExV
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_ptr_id$ = 8						; size = 4
_flags$ = 12						; size = 4
_fmt$ = 16						; size = 4
?TreeNodeEx@ImGui@@YA_NPBXHPBDZZ PROC			; ImGui::TreeNodeEx

; 7107 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 7108 :     va_list args;
; 7109 :     va_start(args, fmt);
; 7110 :     bool is_open = TreeNodeExV(ptr_id, flags, fmt, args);

	lea	eax, DWORD PTR _fmt$[ebp+4]
	push	eax
	push	DWORD PTR _fmt$[ebp]
	push	DWORD PTR _flags$[ebp]
	push	DWORD PTR _ptr_id$[ebp]
	call	?TreeNodeExV@ImGui@@YA_NPBXHPBDPAD@Z	; ImGui::TreeNodeExV
	add	esp, 16					; 00000010H

; 7111 :     va_end(args);
; 7112 :     return is_open;
; 7113 : }

	pop	ebp
	ret	0
?TreeNodeEx@ImGui@@YA_NPBXHPBDZZ ENDP			; ImGui::TreeNodeEx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_str_id$ = 8						; size = 4
_flags$ = 12						; size = 4
_fmt$ = 16						; size = 4
?TreeNodeEx@ImGui@@YA_NPBDH0ZZ PROC			; ImGui::TreeNodeEx

; 7098 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 7099 :     va_list args;
; 7100 :     va_start(args, fmt);
; 7101 :     bool is_open = TreeNodeExV(str_id, flags, fmt, args);

	lea	eax, DWORD PTR _fmt$[ebp+4]
	push	eax
	push	DWORD PTR _fmt$[ebp]
	push	DWORD PTR _flags$[ebp]
	push	DWORD PTR _str_id$[ebp]
	call	?TreeNodeExV@ImGui@@YA_NPBDH0PAD@Z	; ImGui::TreeNodeExV
	add	esp, 16					; 00000010H

; 7102 :     va_end(args);
; 7103 :     return is_open;
; 7104 : }

	pop	ebp
	ret	0
?TreeNodeEx@ImGui@@YA_NPBDH0ZZ ENDP			; ImGui::TreeNodeEx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_flags$ = 12						; size = 4
?TreeNodeEx@ImGui@@YA_NPBDH@Z PROC			; ImGui::TreeNodeEx

; 7057 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	ecx, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7059 :     if (window->SkipItems)

	cmp	BYTE PTR [ecx+137], 0
	je	SHORT $LN2@TreeNodeEx

; 7060 :         return false;

	xor	al, al

; 7063 : }

	pop	ebp
	ret	0
$LN2@TreeNodeEx:

; 7061 : 
; 7062 :     return TreeNodeBehavior(window->GetID(label), flags, label, NULL);

	mov	eax, DWORD PTR _label$[ebp]
	push	0
	push	eax
	push	DWORD PTR _flags$[ebp]
	push	0
	push	eax
	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID
	push	eax
	call	?TreeNodeBehavior@ImGui@@YA_NIHPBD0@Z	; ImGui::TreeNodeBehavior
	add	esp, 16					; 00000010H

; 7063 : }

	pop	ebp
	ret	0
?TreeNodeEx@ImGui@@YA_NPBDH@Z ENDP			; ImGui::TreeNodeEx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_ptr_id$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?TreeNodeV@ImGui@@YA_NPBXPBDPAD@Z PROC			; ImGui::TreeNodeV

; 7093 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 7094 :     return TreeNodeExV(ptr_id, 0, fmt, args);

	push	DWORD PTR _args$[ebp]
	push	DWORD PTR _fmt$[ebp]
	push	0
	push	DWORD PTR _ptr_id$[ebp]
	call	?TreeNodeExV@ImGui@@YA_NPBXHPBDPAD@Z	; ImGui::TreeNodeExV
	add	esp, 16					; 00000010H

; 7095 : }

	pop	ebp
	ret	0
?TreeNodeV@ImGui@@YA_NPBXPBDPAD@Z ENDP			; ImGui::TreeNodeV
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_str_id$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?TreeNodeV@ImGui@@YA_NPBD0PAD@Z PROC			; ImGui::TreeNodeV

; 7088 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 7089 :     return TreeNodeExV(str_id, 0, fmt, args);

	push	DWORD PTR _args$[ebp]
	push	DWORD PTR _fmt$[ebp]
	push	0
	push	DWORD PTR _str_id$[ebp]
	call	?TreeNodeExV@ImGui@@YA_NPBDH0PAD@Z	; ImGui::TreeNodeExV
	add	esp, 16					; 00000010H

; 7090 : }

	pop	ebp
	ret	0
?TreeNodeV@ImGui@@YA_NPBD0PAD@Z ENDP			; ImGui::TreeNodeV
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_ptr_id$ = 8						; size = 4
_fmt$ = 12						; size = 4
?TreeNode@ImGui@@YA_NPBXPBDZZ PROC			; ImGui::TreeNode

; 7125 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 7126 :     va_list args;
; 7127 :     va_start(args, fmt);
; 7128 :     bool is_open = TreeNodeExV(ptr_id, 0, fmt, args);

	lea	eax, DWORD PTR _fmt$[ebp+4]
	push	eax
	push	DWORD PTR _fmt$[ebp]
	push	0
	push	DWORD PTR _ptr_id$[ebp]
	call	?TreeNodeExV@ImGui@@YA_NPBXHPBDPAD@Z	; ImGui::TreeNodeExV
	add	esp, 16					; 00000010H

; 7129 :     va_end(args);
; 7130 :     return is_open;
; 7131 : }

	pop	ebp
	ret	0
?TreeNode@ImGui@@YA_NPBXPBDZZ ENDP			; ImGui::TreeNode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_str_id$ = 8						; size = 4
_fmt$ = 12						; size = 4
?TreeNode@ImGui@@YA_NPBD0ZZ PROC			; ImGui::TreeNode

; 7116 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 7117 :     va_list args;
; 7118 :     va_start(args, fmt);
; 7119 :     bool is_open = TreeNodeExV(str_id, 0, fmt, args);

	lea	eax, DWORD PTR _fmt$[ebp+4]
	push	eax
	push	DWORD PTR _fmt$[ebp]
	push	0
	push	DWORD PTR _str_id$[ebp]
	call	?TreeNodeExV@ImGui@@YA_NPBDH0PAD@Z	; ImGui::TreeNodeExV
	add	esp, 16					; 00000010H

; 7120 :     va_end(args);
; 7121 :     return is_open;
; 7122 : }

	pop	ebp
	ret	0
?TreeNode@ImGui@@YA_NPBD0ZZ ENDP			; ImGui::TreeNode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
?TreeNode@ImGui@@YA_NPBD@Z PROC				; ImGui::TreeNode

; 7134 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	ecx, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7136 :     if (window->SkipItems)

	cmp	BYTE PTR [ecx+137], 0
	je	SHORT $LN2@TreeNode

; 7137 :         return false;

	xor	al, al

; 7139 : }

	pop	ebp
	ret	0
$LN2@TreeNode:

; 7138 :     return TreeNodeBehavior(window->GetID(label), 0, label, NULL);

	mov	eax, DWORD PTR _label$[ebp]
	push	0
	push	eax
	push	0
	push	0
	push	eax
	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID
	push	eax
	call	?TreeNodeBehavior@ImGui@@YA_NIHPBD0@Z	; ImGui::TreeNodeBehavior
	add	esp, 16					; 00000010H

; 7139 : }

	pop	ebp
	ret	0
?TreeNode@ImGui@@YA_NPBD@Z ENDP				; ImGui::TreeNode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_size$ = 12						; size = 4
_v_f$ = 16						; size = 4
_v$ = 16						; size = 4
_v_min$ = 20						; size = 4
_v_max$ = 24						; size = 4
_display_format$ = 28					; size = 4
?VSliderInt@ImGui@@YA_NPBDABUImVec2@@PAHHH0@Z PROC	; ImGui::VSliderInt

; 7736 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _display_format$[ebp]
	test	eax, eax
	push	esi

; 7737 :     if (!display_format)
; 7738 :         display_format = "%.0f";
; 7739 :     float v_f = (float)*v;

	mov	esi, DWORD PTR _v$[ebp]

; 7740 :     bool value_changed = VSliderFloat(label, size, &v_f, (float)v_min, (float)v_max, display_format, 1.0f);

	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	mov	ecx, OFFSET $SG120103
	cmovne	ecx, eax
	lea	eax, DWORD PTR _v_f$[ebp]
	movd	xmm0, DWORD PTR [esi]
	cvtdq2ps xmm0, xmm0
	push	ecx
	sub	esp, 8
	movss	DWORD PTR _v_f$[ebp], xmm0
	movd	xmm0, DWORD PTR _v_max$[ebp]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [esp+4], xmm0
	movd	xmm0, DWORD PTR _v_min$[ebp]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	eax
	push	DWORD PTR _size$[ebp]
	push	DWORD PTR _label$[ebp]
	call	?VSliderFloat@ImGui@@YA_NPBDABUImVec2@@PAMMM0M@Z ; ImGui::VSliderFloat

; 7741 :     *v = (int)v_f;

	cvttss2si ecx, DWORD PTR _v_f$[ebp]
	add	esp, 28					; 0000001cH
	mov	DWORD PTR [esi], ecx
	pop	esi

; 7742 :     return value_changed;
; 7743 : }

	pop	ebp
	ret	0
?VSliderInt@ImGui@@YA_NPBDABUImVec2@@PAHHH0@Z ENDP	; ImGui::VSliderInt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_value_buf$ = -124					; size = 64
_bb$ = -60						; size = 16
_frame_bb$ = -44					; size = 16
_label_size$ = -28					; size = 8
$T1 = -20						; size = 8
$T2 = -20						; size = 8
$T3 = -20						; size = 8
$T4 = -20						; size = 8
tv337 = -16						; size = 4
$T5 = -12						; size = 8
_decimal_precision$1$ = -8				; size = 4
_id$ = -8						; size = 4
_hovered$1$ = -1					; size = 1
_label$ = 8						; size = 4
_size$ = 12						; size = 4
_v$ = 16						; size = 4
_v_min$ = 20						; size = 4
_v_max$ = 24						; size = 4
_display_format$ = 28					; size = 4
_power$ = 32						; size = 4
?VSliderFloat@ImGui@@YA_NPBDABUImVec2@@PAMMM0M@Z PROC	; ImGui::VSliderFloat

; 7672 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7672 : {

	sub	esp, 124				; 0000007cH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	push	esi
	mov	BYTE PTR [eax+134], 1
	mov	esi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7674 :     if (window->SkipItems)

	cmp	BYTE PTR [esi+137], 0
	je	SHORT $LN2@VSliderFlo

; 7675 :         return false;

	xor	al, al
	pop	esi

; 7715 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@VSliderFlo:
	push	ebx
	push	edi

; 7676 : 
; 7677 :     ImGuiContext& g = *GImGui;

	mov	edi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 7678 :     const ImGuiStyle& style = g.Style;
; 7679 :     const ImGuiID id = window->GetID(label);

	mov	ecx, esi
	push	0
	push	DWORD PTR _label$[ebp]
	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID

; 7681 :     const ImVec2 label_size = CalcTextSize(label, NULL, true);

	push	ecx
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	mov	ebx, eax
	push	1
	push	0
	push	DWORD PTR _label$[ebp]
	lea	eax, DWORD PTR _label_size$[ebp]
	mov	DWORD PTR _id$[ebp], ebx
	push	eax
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	mov	eax, DWORD PTR _size$[ebp]
	xorps	xmm0, xmm0
	movss	xmm2, DWORD PTR [esi+196]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7681 :     const ImVec2 label_size = CalcTextSize(label, NULL, true);

	add	esp, 20					; 00000014H

; 7683 :     const ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

	movss	xmm3, DWORD PTR _label_size$[ebp]
	comiss	xmm3, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm1, DWORD PTR [eax]
	addss	xmm2, DWORD PTR [eax+4]
	addss	xmm1, DWORD PTR [esi+192]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [esi+192]
	mov	DWORD PTR _frame_bb$[ebp], eax
	mov	eax, DWORD PTR [esi+196]
	mov	DWORD PTR _frame_bb$[ebp+4], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T4[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _frame_bb$[ebp+8], eax
	mov	eax, DWORD PTR $T4[ebp+4]
	mov	DWORD PTR _frame_bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7683 :     const ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

	jbe	SHORT $LN11@VSliderFlo
	movss	xmm0, DWORD PTR [edi+5376]
	addss	xmm0, xmm3
$LN11@VSliderFlo:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [esi+192]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm1, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7685 :     ItemSize(bb, style.FramePadding.y);

	movss	xmm0, DWORD PTR [edi+5360]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _bb$[ebp], eax
	mov	eax, DWORD PTR [esi+196]
	mov	DWORD PTR _bb$[ebp+4], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR _bb$[ebp+8], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T3[ebp+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7685 :     ItemSize(bb, style.FramePadding.y);

	push	ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7685 :     ItemSize(bb, style.FramePadding.y);

	lea	eax, DWORD PTR _bb$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	eax
	call	?ItemSize@ImGui@@YAXABUImRect@@M@Z	; ImGui::ItemSize

; 7686 :     if (!ItemAdd(frame_bb, &id, &frame_bb))

	lea	eax, DWORD PTR _frame_bb$[ebp]
	push	eax
	lea	eax, DWORD PTR _id$[ebp]
	push	eax
	lea	eax, DWORD PTR _frame_bb$[ebp]
	push	eax
	call	?ItemAdd@ImGui@@YA_NABUImRect@@PBIPBU2@@Z ; ImGui::ItemAdd
	add	esp, 20					; 00000014H
	test	al, al
	jne	SHORT $LN3@VSliderFlo
	pop	edi
	pop	ebx
	pop	esi

; 7715 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@VSliderFlo:

; 7687 :         return false;
; 7688 : 
; 7689 :     const bool hovered = IsHovered(frame_bb, id);

	push	0
	lea	eax, DWORD PTR _frame_bb$[ebp]
	push	ebx
	push	eax
	call	?IsHovered@ImGui@@YA_NABUImRect@@I_N@Z	; ImGui::IsHovered
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _hovered$1$[ebp], al

; 7690 :     if (hovered)

	test	al, al
	je	SHORT $LN4@VSliderFlo

; 7691 :         SetHoveredID(id);

	push	ebx
	call	?SetHoveredID@ImGui@@YAXI@Z		; ImGui::SetHoveredID
	add	esp, 4
$LN4@VSliderFlo:

; 7692 : 
; 7693 :     if (!display_format)
; 7694 :         display_format = "%.3f";
; 7695 :     int decimal_precision = ParseFormatPrecision(display_format, 3);

	mov	eax, DWORD PTR _display_format$[ebp]
	mov	ecx, OFFSET $SG120059
	test	eax, eax
	push	3
	cmovne	ecx, eax
	push	ecx
	mov	DWORD PTR tv337[ebp], ecx
	call	?ParseFormatPrecision@ImGui@@YAHPBDH@Z	; ImGui::ParseFormatPrecision
	add	esp, 8
	mov	DWORD PTR _decimal_precision$1$[ebp], eax

; 7696 : 
; 7697 :     if ((hovered && g.IO.MouseClicked[0]) || g.NavActivateId == id || g.NavInputId == id)

	cmp	BYTE PTR _hovered$1$[ebp], 0
	je	SHORT $LN8@VSliderFlo
	cmp	BYTE PTR [edi+888], 0
	jne	SHORT $LN7@VSliderFlo
$LN8@VSliderFlo:
	cmp	DWORD PTR [edi+6388], ebx
	je	SHORT $LN7@VSliderFlo
	cmp	DWORD PTR [edi+6392], ebx
	jne	SHORT $LN6@VSliderFlo
$LN7@VSliderFlo:

; 7698 :     {
; 7699 :         SetActiveID(id, window);

	push	esi
	push	ebx
	call	?SetActiveID@ImGui@@YAXIPAUImGuiWindow@@@Z ; ImGui::SetActiveID

; 7700 :         FocusWindow(window);

	push	esi
	call	?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusWindow
	mov	eax, DWORD PTR _decimal_precision$1$[ebp]
	add	esp, 12					; 0000000cH
$LN6@VSliderFlo:

; 7701 :     }
; 7702 : 
; 7703 :     // Actual slider behavior + render grab
; 7704 :     bool value_changed = SliderBehavior(frame_bb, id, v, v_min, v_max, power, decimal_precision, ImGuiSliderFlags_Vertical);

	movss	xmm0, DWORD PTR _power$[ebp]
	mov	esi, DWORD PTR _v$[ebp]
	push	1
	push	eax
	sub	esp, 12					; 0000000cH
	lea	eax, DWORD PTR _frame_bb$[ebp]
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _v_max$[ebp]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _v_min$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	esi
	push	ebx
	push	eax
	call	?SliderBehavior@ImGui@@YA_NABUImRect@@IPAMMMMHH@Z ; ImGui::SliderBehavior
	movss	xmm0, DWORD PTR [esi]

; 7709 :     char* value_buf_end = value_buf + ImFormatString(value_buf, IM_ARRAYSIZE(value_buf), display_format, *v);

	add	esp, 24					; 00000018H
	cvtps2pd xmm0, xmm0
	mov	bl, al
	lea	eax, DWORD PTR _value_buf$[ebp]
	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR tv337[ebp]
	push	64					; 00000040H
	push	eax
	call	?ImFormatString@@YAHPADHPBDZZ		; ImFormatString
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR _frame_bb$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7709 :     char* value_buf_end = value_buf + ImFormatString(value_buf, IM_ARRAYSIZE(value_buf), display_format, *v);

	lea	ecx, DWORD PTR _value_buf$[ebp]
	add	eax, ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T5[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7710 :     RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f,0.0f));

	movss	xmm0, DWORD PTR [edi+5360]
	lea	ecx, DWORD PTR $T2[ebp]
	addss	xmm0, DWORD PTR _frame_bb$[ebp+4]
	push	0
	push	ecx
	push	0
	push	eax
	lea	eax, DWORD PTR _value_buf$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T2[ebp], 1056964608		; 3f000000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7710 :     RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f,0.0f));

	push	eax
	lea	eax, DWORD PTR _frame_bb$[ebp+8]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T2[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7710 :     RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f,0.0f));

	push	eax
	lea	eax, DWORD PTR $T5[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T5[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7710 :     RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f,0.0f));

	push	eax
	call	?RenderTextClipped@ImGui@@YAXABUImVec2@@0PBD1PBU2@0PBUImRect@@@Z ; ImGui::RenderTextClipped

; 7711 :     if (label_size.x > 0.0f)

	movss	xmm0, DWORD PTR _label_size$[ebp]
	xorps	xmm1, xmm1
	add	esp, 48					; 00000030H
	comiss	xmm0, xmm1
	jbe	SHORT $LN9@VSliderFlo

; 7712 :         RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

	movss	xmm0, DWORD PTR [edi+5376]
	addss	xmm0, DWORD PTR _frame_bb$[ebp+8]
	push	1
	push	0
	push	DWORD PTR _label$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7712 :         RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

	movss	xmm0, DWORD PTR [edi+5360]
	addss	xmm0, DWORD PTR _frame_bb$[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7712 :         RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

	push	DWORD PTR $T1[ebp+4]
	push	DWORD PTR $T1[ebp]
	call	?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z	; ImGui::RenderText
	add	esp, 20					; 00000014H
$LN9@VSliderFlo:

; 7713 : 
; 7714 :     return value_changed;

	pop	edi
	mov	al, bl
	pop	ebx
	pop	esi

; 7715 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?VSliderFloat@ImGui@@YA_NPBDABUImVec2@@PAMMM0M@Z ENDP	; ImGui::VSliderFloat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_v_min$ = 16						; size = 4
_v_max$ = 20						; size = 4
_display_format$ = 24					; size = 4
?SliderInt4@ImGui@@YA_NPBDQAHHH0@Z PROC			; ImGui::SliderInt4

; 7826 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 7827 :     return SliderIntN(label, v, 4, v_min, v_max, display_format);

	push	DWORD PTR _display_format$[ebp]
	push	DWORD PTR _v_max$[ebp]
	push	DWORD PTR _v_min$[ebp]
	push	4
	push	DWORD PTR _v$[ebp]
	push	DWORD PTR _label$[ebp]
	call	?SliderIntN@ImGui@@YA_NPBDPAHHHH0@Z	; ImGui::SliderIntN
	add	esp, 24					; 00000018H

; 7828 : }

	pop	ebp
	ret	0
?SliderInt4@ImGui@@YA_NPBDQAHHH0@Z ENDP			; ImGui::SliderInt4
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_v_min$ = 16						; size = 4
_v_max$ = 20						; size = 4
_display_format$ = 24					; size = 4
?SliderInt3@ImGui@@YA_NPBDQAHHH0@Z PROC			; ImGui::SliderInt3

; 7821 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 7822 :     return SliderIntN(label, v, 3, v_min, v_max, display_format);

	push	DWORD PTR _display_format$[ebp]
	push	DWORD PTR _v_max$[ebp]
	push	DWORD PTR _v_min$[ebp]
	push	3
	push	DWORD PTR _v$[ebp]
	push	DWORD PTR _label$[ebp]
	call	?SliderIntN@ImGui@@YA_NPBDPAHHHH0@Z	; ImGui::SliderIntN
	add	esp, 24					; 00000018H

; 7823 : }

	pop	ebp
	ret	0
?SliderInt3@ImGui@@YA_NPBDQAHHH0@Z ENDP			; ImGui::SliderInt3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_v_min$ = 16						; size = 4
_v_max$ = 20						; size = 4
_display_format$ = 24					; size = 4
?SliderInt2@ImGui@@YA_NPBDQAHHH0@Z PROC			; ImGui::SliderInt2

; 7816 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 7817 :     return SliderIntN(label, v, 2, v_min, v_max, display_format);

	push	DWORD PTR _display_format$[ebp]
	push	DWORD PTR _v_max$[ebp]
	push	DWORD PTR _v_min$[ebp]
	push	2
	push	DWORD PTR _v$[ebp]
	push	DWORD PTR _label$[ebp]
	call	?SliderIntN@ImGui@@YA_NPBDPAHHHH0@Z	; ImGui::SliderIntN
	add	esp, 24					; 00000018H

; 7818 : }

	pop	ebp
	ret	0
?SliderInt2@ImGui@@YA_NPBDQAHHH0@Z ENDP			; ImGui::SliderInt2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v_f$ = 12						; size = 4
_v$ = 12						; size = 4
_v_min$ = 16						; size = 4
_v_max$ = 20						; size = 4
_display_format$ = 24					; size = 4
?SliderInt@ImGui@@YA_NPBDPAHHH0@Z PROC			; ImGui::SliderInt

; 7726 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _display_format$[ebp]
	test	eax, eax
	push	esi

; 7727 :     if (!display_format)
; 7728 :         display_format = "%.0f";
; 7729 :     float v_f = (float)*v;

	mov	esi, DWORD PTR _v$[ebp]

; 7730 :     bool value_changed = SliderFloat(label, &v_f, (float)v_min, (float)v_max, display_format, 1.0f);

	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	mov	ecx, OFFSET $SG120087
	cmovne	ecx, eax
	lea	eax, DWORD PTR _v_f$[ebp]
	movd	xmm0, DWORD PTR [esi]
	cvtdq2ps xmm0, xmm0
	push	ecx
	sub	esp, 8
	movss	DWORD PTR _v_f$[ebp], xmm0
	movd	xmm0, DWORD PTR _v_max$[ebp]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [esp+4], xmm0
	movd	xmm0, DWORD PTR _v_min$[ebp]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [esp], xmm0
	push	eax
	push	DWORD PTR _label$[ebp]
	call	?SliderFloat@ImGui@@YA_NPBDPAMMM0M@Z	; ImGui::SliderFloat

; 7731 :     *v = (int)v_f;

	cvttss2si ecx, DWORD PTR _v_f$[ebp]
	add	esp, 24					; 00000018H
	mov	DWORD PTR [esi], ecx
	pop	esi

; 7732 :     return value_changed;
; 7733 : }

	pop	ebp
	ret	0
?SliderInt@ImGui@@YA_NPBDPAHHH0@Z ENDP			; ImGui::SliderInt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v_deg$ = 12						; size = 4
_v_rad$ = 12						; size = 4
_v_degrees_min$ = 16					; size = 4
_v_degrees_max$ = 20					; size = 4
?SliderAngle@ImGui@@YA_NPBDPAMMM@Z PROC			; ImGui::SliderAngle

; 7718 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 7719 :     float v_deg = (*v_rad) * 360.0f / (2*IM_PI);

	mov	esi, DWORD PTR _v_rad$[ebp]

; 7720 :     bool value_changed = SliderFloat(label, &v_deg, v_degrees_min, v_degrees_max, "%.0f deg", 1.0f);

	lea	eax, DWORD PTR _v_deg$[ebp]
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	OFFSET $SG120072
	movss	xmm0, DWORD PTR [esi]
	sub	esp, 8
	mulss	xmm0, DWORD PTR __real@42652ee0
	movss	DWORD PTR _v_deg$[ebp], xmm0
	movss	xmm0, DWORD PTR _v_degrees_max$[ebp]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _v_degrees_min$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	eax
	push	DWORD PTR _label$[ebp]
	call	?SliderFloat@ImGui@@YA_NPBDPAMMM0M@Z	; ImGui::SliderFloat

; 7721 :     *v_rad = v_deg * (2*IM_PI) / 360.0f;

	movss	xmm0, DWORD PTR _v_deg$[ebp]
	add	esp, 24					; 00000018H
	mulss	xmm0, DWORD PTR __real@40c90fdb
	mulss	xmm0, DWORD PTR __real@3b360b61
	movss	DWORD PTR [esi], xmm0
	pop	esi

; 7722 :     return value_changed;
; 7723 : }

	pop	ebp
	ret	0
?SliderAngle@ImGui@@YA_NPBDPAMMM@Z ENDP			; ImGui::SliderAngle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_v_min$ = 16						; size = 4
_v_max$ = 20						; size = 4
_display_format$ = 24					; size = 4
_power$ = 28						; size = 4
?SliderFloat4@ImGui@@YA_NPBDQAMMM0M@Z PROC		; ImGui::SliderFloat4

; 7784 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 7785 :     return SliderFloatN(label, v, 4, v_min, v_max, display_format, power);

	movss	xmm0, DWORD PTR _power$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _display_format$[ebp]
	movss	xmm0, DWORD PTR _v_max$[ebp]
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _v_min$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	4
	push	DWORD PTR _v$[ebp]
	push	DWORD PTR _label$[ebp]
	call	?SliderFloatN@ImGui@@YA_NPBDPAMHMM0M@Z	; ImGui::SliderFloatN
	add	esp, 28					; 0000001cH

; 7786 : }

	pop	ebp
	ret	0
?SliderFloat4@ImGui@@YA_NPBDQAMMM0M@Z ENDP		; ImGui::SliderFloat4
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_v_min$ = 16						; size = 4
_v_max$ = 20						; size = 4
_display_format$ = 24					; size = 4
_power$ = 28						; size = 4
?SliderFloat3@ImGui@@YA_NPBDQAMMM0M@Z PROC		; ImGui::SliderFloat3

; 7779 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 7780 :     return SliderFloatN(label, v, 3, v_min, v_max, display_format, power);

	movss	xmm0, DWORD PTR _power$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _display_format$[ebp]
	movss	xmm0, DWORD PTR _v_max$[ebp]
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _v_min$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	3
	push	DWORD PTR _v$[ebp]
	push	DWORD PTR _label$[ebp]
	call	?SliderFloatN@ImGui@@YA_NPBDPAMHMM0M@Z	; ImGui::SliderFloatN
	add	esp, 28					; 0000001cH

; 7781 : }

	pop	ebp
	ret	0
?SliderFloat3@ImGui@@YA_NPBDQAMMM0M@Z ENDP		; ImGui::SliderFloat3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_v_min$ = 16						; size = 4
_v_max$ = 20						; size = 4
_display_format$ = 24					; size = 4
_power$ = 28						; size = 4
?SliderFloat2@ImGui@@YA_NPBDQAMMM0M@Z PROC		; ImGui::SliderFloat2

; 7774 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 7775 :     return SliderFloatN(label, v, 2, v_min, v_max, display_format, power);

	movss	xmm0, DWORD PTR _power$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _display_format$[ebp]
	movss	xmm0, DWORD PTR _v_max$[ebp]
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _v_min$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	2
	push	DWORD PTR _v$[ebp]
	push	DWORD PTR _label$[ebp]
	call	?SliderFloatN@ImGui@@YA_NPBDPAMHMM0M@Z	; ImGui::SliderFloatN
	add	esp, 28					; 0000001cH

; 7776 : }

	pop	ebp
	ret	0
?SliderFloat2@ImGui@@YA_NPBDQAMMM0M@Z ENDP		; ImGui::SliderFloat2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_value_buf$ = -124					; size = 64
_total_bb$ = -60					; size = 16
_frame_bb$ = -44					; size = 16
$T2 = -28						; size = 8
_label_size$ = -28					; size = 8
$T3 = -20						; size = 8
tv395 = -16						; size = 4
_id$ = -16						; size = 4
$T4 = -12						; size = 8
$T5 = -12						; size = 8
_decimal_precision$1$ = -8				; size = 4
_w$ = -8						; size = 4
_tab_focus_requested$1$ = -2				; size = 1
_hovered$1$ = -1					; size = 1
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_v_min$ = 16						; size = 4
_v_max$ = 20						; size = 4
_display_format$ = 24					; size = 4
_power$ = 28						; size = 4
?SliderFloat@ImGui@@YA_NPBDPAMMM0M@Z PROC		; ImGui::SliderFloat

; 7610 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7610 : {

	sub	esp, 124				; 0000007cH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	push	esi
	mov	BYTE PTR [eax+134], 1
	mov	esi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7612 :     if (window->SkipItems)

	cmp	BYTE PTR [esi+137], 0
	je	SHORT $LN2@SliderFloa

; 7613 :         return false;

	xor	al, al
	pop	esi

; 7669 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@SliderFloa:
	push	ebx
	push	edi

; 7614 : 
; 7615 :     ImGuiContext& g = *GImGui;

	mov	edi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 7616 :     const ImGuiStyle& style = g.Style;
; 7617 :     const ImGuiID id = window->GetID(label);

	mov	ecx, esi
	push	0
	push	DWORD PTR _label$[ebp]
	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID
	mov	ebx, eax
	mov	DWORD PTR _id$[ebp], ebx

; 7618 :     const float w = CalcItemWidth();

	call	?CalcItemWidth@ImGui@@YAMXZ		; ImGui::CalcItemWidth

; 7619 : 
; 7620 :     const ImVec2 label_size = CalcTextSize(label, NULL, true);

	push	ecx
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	lea	eax, DWORD PTR _label_size$[ebp]
	push	1
	push	0
	push	DWORD PTR _label$[ebp]
	fstp	DWORD PTR _w$[ebp]
	push	eax
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize

; 7621 :     const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2.0f));

	movss	xmm0, DWORD PTR [edi+5360]
	add	esp, 20					; 00000014H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm1, DWORD PTR [esi+192]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7621 :     const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2.0f));

	addss	xmm0, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm1, DWORD PTR _w$[ebp]
	movss	xmm2, DWORD PTR [esi+196]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [esi+192]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7622 :     const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

	movss	xmm3, DWORD PTR _label_size$[ebp]
	addss	xmm0, DWORD PTR _label_size$[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _frame_bb$[ebp], eax
	mov	eax, DWORD PTR [esi+196]
	mov	DWORD PTR _frame_bb$[ebp+4], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T5[ebp], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T5[ebp]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm2, xmm0
	xorps	xmm0, xmm0

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _frame_bb$[ebp+8], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7622 :     const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

	comiss	xmm3, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T5[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T5[ebp+4]
	mov	DWORD PTR _frame_bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7622 :     const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

	jbe	SHORT $LN15@SliderFloa
	movss	xmm0, DWORD PTR [edi+5376]
	addss	xmm0, xmm3
$LN15@SliderFloa:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [esi+192]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm1, xmm0

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _total_bb$[ebp], eax
	mov	eax, DWORD PTR [esi+196]
	mov	DWORD PTR _total_bb$[ebp+4], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp+4], xmm2
	movss	DWORD PTR $T4[ebp], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR _total_bb$[ebp+8], eax
	mov	eax, DWORD PTR $T4[ebp+4]
	mov	DWORD PTR _total_bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7625 :     if (!ItemAdd(total_bb, &id, &frame_bb))

	lea	eax, DWORD PTR _frame_bb$[ebp]
	push	eax
	lea	eax, DWORD PTR _id$[ebp]
	push	eax
	lea	eax, DWORD PTR _total_bb$[ebp]
	push	eax
	call	?ItemAdd@ImGui@@YA_NABUImRect@@PBIPBU2@@Z ; ImGui::ItemAdd
	add	esp, 12					; 0000000cH
	test	al, al
	jne	SHORT $LN3@SliderFloa

; 7626 :     {
; 7627 :         ItemSize(total_bb, style.FramePadding.y);

	movss	xmm0, DWORD PTR [edi+5360]
	lea	eax, DWORD PTR _total_bb$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	eax
	call	?ItemSize@ImGui@@YAXABUImRect@@M@Z	; ImGui::ItemSize
	add	esp, 8

; 7628 :         return false;

	xor	al, al
	pop	edi
	pop	ebx
	pop	esi

; 7669 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@SliderFloa:

; 7629 :     }
; 7630 : 
; 7631 :     const bool hovered = IsHovered(frame_bb, id);

	push	0
	lea	eax, DWORD PTR _frame_bb$[ebp]
	push	ebx
	push	eax
	call	?IsHovered@ImGui@@YA_NABUImRect@@I_N@Z	; ImGui::IsHovered
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _hovered$1$[ebp], al

; 7632 :     if (hovered)

	test	al, al
	je	SHORT $LN4@SliderFloa

; 7633 :         SetHoveredID(id);

	push	ebx
	call	?SetHoveredID@ImGui@@YAXI@Z		; ImGui::SetHoveredID
	add	esp, 4
$LN4@SliderFloa:

; 7634 : 
; 7635 :     if (!display_format)
; 7636 :         display_format = "%.3f";
; 7637 :     int decimal_precision = ParseFormatPrecision(display_format, 3);

	mov	eax, DWORD PTR _display_format$[ebp]
	mov	ecx, OFFSET $SG120017
	test	eax, eax
	push	3
	cmovne	ecx, eax
	push	ecx
	mov	DWORD PTR tv395[ebp], ecx
	call	?ParseFormatPrecision@ImGui@@YAHPBDH@Z	; ImGui::ParseFormatPrecision

; 7638 : 
; 7639 :     // Tabbing or CTRL-clicking on Slider turns it into an input box
; 7640 :     bool start_text_input = false;
; 7641 :     const bool tab_focus_requested = FocusableItemRegister(window, id);

	push	1
	push	ebx
	push	esi
	mov	DWORD PTR _decimal_precision$1$[ebp], eax
	call	?FocusableItemRegister@ImGui@@YA_NPAUImGuiWindow@@I_N@Z ; ImGui::FocusableItemRegister
	add	esp, 20					; 00000014H
	mov	BYTE PTR _tab_focus_requested$1$[ebp], al

; 7642 :     if (tab_focus_requested || (hovered && g.IO.MouseClicked[0]) || g.NavActivateId == id || g.NavInputId == id)

	test	al, al
	jne	SHORT $LN7@SliderFloa
	cmp	BYTE PTR _hovered$1$[ebp], al
	je	SHORT $LN8@SliderFloa
	cmp	BYTE PTR [edi+888], al
	jne	SHORT $LN7@SliderFloa
$LN8@SliderFloa:
	cmp	DWORD PTR [edi+6388], ebx
	je	SHORT $LN7@SliderFloa
	cmp	DWORD PTR [edi+6392], ebx
	jne	SHORT $LN39@SliderFloa
$LN7@SliderFloa:

; 7643 :     {
; 7644 :         SetActiveID(id, window);

	push	esi
	push	ebx
	call	?SetActiveID@ImGui@@YAXIPAUImGuiWindow@@@Z ; ImGui::SetActiveID

; 7645 :         FocusWindow(window);

	push	esi
	call	?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusWindow
	add	esp, 12					; 0000000cH

; 7646 :         if (tab_focus_requested || g.IO.KeyCtrl || g.NavInputId == id)

	cmp	BYTE PTR _tab_focus_requested$1$[ebp], 0
	jne	$LN10@SliderFloa
	cmp	BYTE PTR [edi+229], 0
	jne	$LN10@SliderFloa
	cmp	DWORD PTR [edi+6392], ebx
	je	$LN10@SliderFloa
$LN39@SliderFloa:

; 7650 :         }
; 7651 :     }
; 7652 :     if (start_text_input || (g.ActiveId == id && g.ScalarAsInputTextId == id))

	cmp	DWORD PTR [edi+6264], ebx
	jne	SHORT $LN11@SliderFloa
	cmp	DWORD PTR [edi+10500], ebx
	je	$LN12@SliderFloa
$LN11@SliderFloa:

; 7654 : 
; 7655 :     ItemSize(total_bb, style.FramePadding.y);

	movss	xmm0, DWORD PTR [edi+5360]
	lea	eax, DWORD PTR _total_bb$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	eax
	call	?ItemSize@ImGui@@YAXABUImRect@@M@Z	; ImGui::ItemSize

; 7656 : 
; 7657 :     // Actual slider behavior + render grab
; 7658 :     const bool value_changed = SliderBehavior(frame_bb, id, v, v_min, v_max, power, decimal_precision);

	movss	xmm0, DWORD PTR _power$[ebp]
	lea	eax, DWORD PTR _frame_bb$[ebp]
	mov	esi, DWORD PTR _v$[ebp]
	add	esp, 8
	push	0
	push	DWORD PTR _decimal_precision$1$[ebp]
	sub	esp, 12					; 0000000cH
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _v_max$[ebp]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _v_min$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	esi
	push	ebx
	push	eax
	call	?SliderBehavior@ImGui@@YA_NABUImRect@@IPAMMMMHH@Z ; ImGui::SliderBehavior
	movss	xmm0, DWORD PTR [esi]

; 7662 :     const char* value_buf_end = value_buf + ImFormatString(value_buf, IM_ARRAYSIZE(value_buf), display_format, *v);

	add	esp, 24					; 00000018H
	cvtps2pd xmm0, xmm0
	mov	bl, al
	lea	eax, DWORD PTR _value_buf$[ebp]
	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR tv395[ebp]
	push	64					; 00000040H
	push	eax
	call	?ImFormatString@@YAHPADHPBDZZ		; ImFormatString

; 7663 :     RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f,0.5f));

	push	0
	lea	ecx, DWORD PTR _value_buf$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T3[ebp], 1056964608		; 3f000000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7662 :     const char* value_buf_end = value_buf + ImFormatString(value_buf, IM_ARRAYSIZE(value_buf), display_format, *v);

	add	eax, ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T3[ebp+4], 1056964608	; 3f000000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7663 :     RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f,0.5f));

	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	push	0
	push	eax
	lea	eax, DWORD PTR _value_buf$[ebp]
	push	eax
	lea	eax, DWORD PTR _frame_bb$[ebp+8]
	push	eax
	lea	eax, DWORD PTR _frame_bb$[ebp]
	push	eax
	call	?RenderTextClipped@ImGui@@YAXABUImVec2@@0PBD1PBU2@0PBUImRect@@@Z ; ImGui::RenderTextClipped

; 7664 : 
; 7665 :     if (label_size.x > 0.0f)

	movss	xmm0, DWORD PTR _label_size$[ebp]
	xorps	xmm1, xmm1
	add	esp, 48					; 00000030H
	comiss	xmm0, xmm1
	jbe	SHORT $LN13@SliderFloa

; 7666 :         RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

	movss	xmm0, DWORD PTR [edi+5376]
	addss	xmm0, DWORD PTR _frame_bb$[ebp+8]
	push	1
	push	0
	push	DWORD PTR _label$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7666 :         RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

	movss	xmm0, DWORD PTR [edi+5360]
	addss	xmm0, DWORD PTR _frame_bb$[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7666 :         RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

	push	DWORD PTR $T2[ebp+4]
	push	DWORD PTR $T2[ebp]
	call	?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z	; ImGui::RenderText
	add	esp, 20					; 00000014H
$LN13@SliderFloa:

; 7667 : 
; 7668 :     return value_changed;

	pop	edi
	mov	al, bl
	pop	ebx
	pop	esi

; 7669 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@SliderFloa:

; 7647 :         {
; 7648 :             start_text_input = true;
; 7649 :             g.ScalarAsInputTextId = 0;

	mov	DWORD PTR [edi+10500], 0
$LN12@SliderFloa:

; 7653 :         return InputScalarAsWidgetReplacement(frame_bb, label, ImGuiDataType_Float, v, id, decimal_precision);

	push	DWORD PTR _decimal_precision$1$[ebp]
	lea	eax, DWORD PTR _frame_bb$[ebp]
	push	ebx
	push	DWORD PTR _v$[ebp]
	push	1
	push	DWORD PTR _label$[ebp]
	push	eax
	call	?InputScalarAsWidgetReplacement@ImGui@@YA_NABUImRect@@PBDW4ImGuiDataType@@PAXIH@Z ; ImGui::InputScalarAsWidgetReplacement
	add	esp, 24					; 00000018H
	pop	edi
	pop	ebx
	pop	esi

; 7669 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SliderFloat@ImGui@@YA_NPBDPAMMM0M@Z ENDP		; ImGui::SliderFloat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_extra_flags$ = 16					; size = 4
?InputInt4@ImGui@@YA_NPBDQAHH@Z PROC			; ImGui::InputInt4

; 9450 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 9451 :     return InputIntN(label, v, 4, extra_flags);

	push	DWORD PTR _extra_flags$[ebp]
	push	4
	push	DWORD PTR _v$[ebp]
	push	DWORD PTR _label$[ebp]
	call	?InputIntN@ImGui@@YA_NPBDPAHHH@Z	; ImGui::InputIntN
	add	esp, 16					; 00000010H

; 9452 : }

	pop	ebp
	ret	0
?InputInt4@ImGui@@YA_NPBDQAHH@Z ENDP			; ImGui::InputInt4
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_extra_flags$ = 16					; size = 4
?InputInt3@ImGui@@YA_NPBDQAHH@Z PROC			; ImGui::InputInt3

; 9445 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 9446 :     return InputIntN(label, v, 3, extra_flags);

	push	DWORD PTR _extra_flags$[ebp]
	push	3
	push	DWORD PTR _v$[ebp]
	push	DWORD PTR _label$[ebp]
	call	?InputIntN@ImGui@@YA_NPBDPAHHH@Z	; ImGui::InputIntN
	add	esp, 16					; 00000010H

; 9447 : }

	pop	ebp
	ret	0
?InputInt3@ImGui@@YA_NPBDQAHH@Z ENDP			; ImGui::InputInt3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_extra_flags$ = 16					; size = 4
?InputInt2@ImGui@@YA_NPBDQAHH@Z PROC			; ImGui::InputInt2

; 9440 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 9441 :     return InputIntN(label, v, 2, extra_flags);

	push	DWORD PTR _extra_flags$[ebp]
	push	2
	push	DWORD PTR _v$[ebp]
	push	DWORD PTR _label$[ebp]
	call	?InputIntN@ImGui@@YA_NPBDPAHHH@Z	; ImGui::InputIntN
	add	esp, 16					; 00000010H

; 9442 : }

	pop	ebp
	ret	0
?InputInt2@ImGui@@YA_NPBDQAHH@Z ENDP			; ImGui::InputInt2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_step$ = 16						; size = 4
_step_fast$ = 20					; size = 4
_extra_flags$ = 24					; size = 4
?InputInt@ImGui@@YA_NPBDPAHHHH@Z PROC			; ImGui::InputInt

; 9362 : {

	npad	2
	push	ebp
	mov	ebp, esp
	movd	xmm0, DWORD PTR _step_fast$[ebp]

; 9363 :     // Hexadecimal input provided as a convenience but the flag name is awkward. Typically you'd use InputText() to parse your own data, if you want to handle prefixes.
; 9364 :     const char* scalar_format = (extra_flags & ImGuiInputTextFlags_CharsHexadecimal) ? "%08X" : "%d";

	mov	ecx, OFFSET $SG121727

; 9365 :     return InputScalarEx(label, ImGuiDataType_Int, (void*)v, (void*)(step>0.0f ? &step : NULL), (void*)(step_fast>0.0f ? &step_fast : NULL), scalar_format, extra_flags);

	mov	eax, DWORD PTR _extra_flags$[ebp]
	xorps	xmm1, xmm1
	push	eax
	test	al, 2
	mov	eax, OFFSET $SG121726
	cvtdq2ps xmm0, xmm0
	cmove	eax, ecx
	xor	ecx, ecx
	push	eax
	lea	eax, DWORD PTR _step_fast$[ebp]
	comiss	xmm0, xmm1
	movd	xmm0, DWORD PTR _step$[ebp]
	cvtdq2ps xmm0, xmm0
	cmovbe	eax, ecx
	push	eax
	lea	eax, DWORD PTR _step$[ebp]
	comiss	xmm0, xmm1
	cmovbe	eax, ecx
	push	eax
	push	DWORD PTR _v$[ebp]
	push	ecx
	push	DWORD PTR _label$[ebp]
	call	?InputScalarEx@ImGui@@YA_NPBDW4ImGuiDataType@@PAX220H@Z ; ImGui::InputScalarEx
	add	esp, 28					; 0000001cH

; 9366 : }

	pop	ebp
	ret	0
?InputInt@ImGui@@YA_NPBDPAHHHH@Z ENDP			; ImGui::InputInt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_decimal_precision$ = 16				; size = 4
_extra_flags$ = 20					; size = 4
?InputFloat4@ImGui@@YA_NPBDQAMHH@Z PROC			; ImGui::InputFloat4

; 9407 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 9408 :     return InputFloatN(label, v, 4, decimal_precision, extra_flags);

	push	DWORD PTR _extra_flags$[ebp]
	push	DWORD PTR _decimal_precision$[ebp]
	push	4
	push	DWORD PTR _v$[ebp]
	push	DWORD PTR _label$[ebp]
	call	?InputFloatN@ImGui@@YA_NPBDPAMHHH@Z	; ImGui::InputFloatN
	add	esp, 20					; 00000014H

; 9409 : }

	pop	ebp
	ret	0
?InputFloat4@ImGui@@YA_NPBDQAMHH@Z ENDP			; ImGui::InputFloat4
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_decimal_precision$ = 16				; size = 4
_extra_flags$ = 20					; size = 4
?InputFloat3@ImGui@@YA_NPBDQAMHH@Z PROC			; ImGui::InputFloat3

; 9402 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 9403 :     return InputFloatN(label, v, 3, decimal_precision, extra_flags);

	push	DWORD PTR _extra_flags$[ebp]
	push	DWORD PTR _decimal_precision$[ebp]
	push	3
	push	DWORD PTR _v$[ebp]
	push	DWORD PTR _label$[ebp]
	call	?InputFloatN@ImGui@@YA_NPBDPAMHHH@Z	; ImGui::InputFloatN
	add	esp, 20					; 00000014H

; 9404 : }

	pop	ebp
	ret	0
?InputFloat3@ImGui@@YA_NPBDQAMHH@Z ENDP			; ImGui::InputFloat3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_decimal_precision$ = 16				; size = 4
_extra_flags$ = 20					; size = 4
?InputFloat2@ImGui@@YA_NPBDQAMHH@Z PROC			; ImGui::InputFloat2

; 9397 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 9398 :     return InputFloatN(label, v, 2, decimal_precision, extra_flags);

	push	DWORD PTR _extra_flags$[ebp]
	push	DWORD PTR _decimal_precision$[ebp]
	push	2
	push	DWORD PTR _v$[ebp]
	push	DWORD PTR _label$[ebp]
	call	?InputFloatN@ImGui@@YA_NPBDPAMHHH@Z	; ImGui::InputFloatN
	add	esp, 20					; 00000014H

; 9399 : }

	pop	ebp
	ret	0
?InputFloat2@ImGui@@YA_NPBDQAMHH@Z ENDP			; ImGui::InputFloat2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_display_format$ = -16					; size = 16
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_step$ = 16						; size = 4
_step_fast$ = 20					; size = 4
_decimal_precision$ = 24				; size = 4
_extra_flags$ = 28					; size = 4
?InputFloat@ImGui@@YA_NPBDPAMMMHH@Z PROC		; ImGui::InputFloat

; 9352 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 9353 :     char display_format[16];
; 9354 :     if (decimal_precision < 0)

	mov	eax, DWORD PTR _decimal_precision$[ebp]
	sub	esp, 16					; 00000010H
	test	eax, eax
	jns	SHORT $LN2@InputFloat

; 9355 :         strcpy(display_format, "%f");      // Ideally we'd have a minimum decimal precision of 1 to visually denote that this is a float, while hiding non-significant digits? %f doesn't have a minimum of 1

	mov	ax, WORD PTR $SG121713
	mov	WORD PTR _display_format$[ebp], ax
	mov	al, BYTE PTR $SG121713+2
	mov	BYTE PTR _display_format$[ebp+2], al

; 9356 :     else

	jmp	SHORT $LN3@InputFloat
$LN2@InputFloat:

; 9357 :         ImFormatString(display_format, IM_ARRAYSIZE(display_format), "%%.%df", decimal_precision);

	push	eax
	push	OFFSET $SG121714
	lea	eax, DWORD PTR _display_format$[ebp]
	push	16					; 00000010H
	push	eax
	call	?ImFormatString@@YAHPADHPBDZZ		; ImFormatString
	add	esp, 16					; 00000010H
$LN3@InputFloat:

; 9358 :     return InputScalarEx(label, ImGuiDataType_Float, (void*)v, (void*)(step>0.0f ? &step : NULL), (void*)(step_fast>0.0f ? &step_fast : NULL), display_format, extra_flags);

	movss	xmm0, DWORD PTR _step_fast$[ebp]
	lea	eax, DWORD PTR _display_format$[ebp]
	push	DWORD PTR _extra_flags$[ebp]
	xor	ecx, ecx
	xorps	xmm1, xmm1
	comiss	xmm0, xmm1
	push	eax
	lea	eax, DWORD PTR _step_fast$[ebp]
	movss	xmm0, DWORD PTR _step$[ebp]
	cmovbe	eax, ecx
	comiss	xmm0, xmm1
	push	eax
	lea	eax, DWORD PTR _step$[ebp]
	cmovbe	eax, ecx
	push	eax
	push	DWORD PTR _v$[ebp]
	push	1
	push	DWORD PTR _label$[ebp]
	call	?InputScalarEx@ImGui@@YA_NPBDW4ImGuiDataType@@PAX220H@Z ; ImGui::InputScalarEx
	add	esp, 28					; 0000001cH

; 9359 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InputFloat@ImGui@@YA_NPBDPAMMMHH@Z ENDP		; ImGui::InputFloat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_buf$ = 12						; size = 4
_buf_size$ = 16						; size = 4
_size$ = 20						; size = 4
_flags$ = 24						; size = 4
_callback$ = 28						; size = 4
_user_data$ = 32					; size = 4
?InputTextMultiline@ImGui@@YA_NPBDPADIABUImVec2@@HP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z PROC ; ImGui::InputTextMultiline

; 9290 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 9291 :     return InputTextEx(label, buf, (int)buf_size, size, flags | ImGuiInputTextFlags_Multiline, callback, user_data);

	or	DWORD PTR _flags$[ebp], 1048576		; 00100000H

; 9292 : }

	pop	ebp

; 9291 :     return InputTextEx(label, buf, (int)buf_size, size, flags | ImGuiInputTextFlags_Multiline, callback, user_data);

	jmp	?InputTextEx@ImGui@@YA_NPBDPADHABUImVec2@@HP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ; ImGui::InputTextEx
?InputTextMultiline@ImGui@@YA_NPBDPADIABUImVec2@@HP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ENDP ; ImGui::InputTextMultiline
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 8
_label$ = 8						; size = 4
_buf$ = 12						; size = 4
_buf_size$ = 16						; size = 4
_flags$ = 20						; size = 4
_callback$ = 24						; size = 4
_user_data$ = 28					; size = 4
?InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z PROC ; ImGui::InputText

; 9284 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 9286 :     return InputTextEx(label, buf, (int)buf_size, ImVec2(0,0), flags, callback, user_data);

	push	DWORD PTR _user_data$[ebp]
	lea	eax, DWORD PTR $T1[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9286 :     return InputTextEx(label, buf, (int)buf_size, ImVec2(0,0), flags, callback, user_data);

	push	DWORD PTR _callback$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9286 :     return InputTextEx(label, buf, (int)buf_size, ImVec2(0,0), flags, callback, user_data);

	push	DWORD PTR _flags$[ebp]
	push	eax
	push	DWORD PTR _buf_size$[ebp]
	push	DWORD PTR _buf$[ebp]
	push	DWORD PTR _label$[ebp]
	call	?InputTextEx@ImGui@@YA_NPBDPADHABUImVec2@@HP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ; ImGui::InputTextEx
	add	esp, 28					; 0000001cH

; 9287 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ENDP ; ImGui::InputText
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_g$1$ = -8						; size = 4
_value_changed$1$ = -1					; size = 1
_label$ = 8						; size = 4
_v_current_min$ = 12					; size = 4
_v_current_max$ = 16					; size = 4
_v_speed$ = 20						; size = 4
_v_min$ = 24						; size = 4
_v_max$ = 28						; size = 4
_display_format$ = 32					; size = 4
_display_format_max$ = 36				; size = 4
?DragIntRange2@ImGui@@YA_NPBDPAH1MHH00@Z PROC		; ImGui::DragIntRange2

; 8100 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8100 : {

	sub	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8102 :     if (window->SkipItems)

	mov	eax, DWORD PTR [ecx+6240]
	cmp	BYTE PTR [eax+137], 0
	je	SHORT $LN2@DragIntRan

; 8103 :         return false;

	xor	al, al

; 8122 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@DragIntRan:

; 8104 : 
; 8105 :     ImGuiContext& g = *GImGui;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	ebx
	push	esi
	push	edi

; 8106 :     PushID(label);

	push	DWORD PTR _label$[ebp]
	mov	DWORD PTR _g$1$[ebp], eax
	call	?PushID@ImGui@@YAXPBD@Z			; ImGui::PushID

; 8107 :     BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup

; 8108 :     PushMultiItemsWidths(2);

	mov	DWORD PTR [esp], 0
	push	2
	call	?PushMultiItemsWidths@@YAXHM@Z		; PushMultiItemsWidths

; 8110 :     bool value_changed = DragInt("##min", v_current_min, v_speed, (v_min >= v_max) ? INT_MIN : v_min, (v_min >= v_max) ? *v_current_max : ImMin(v_max, *v_current_max), display_format);

	mov	ebx, DWORD PTR _v_current_max$[ebp]
	add	esp, 8
	mov	edi, DWORD PTR _v_min$[ebp]
	mov	esi, DWORD PTR _v_max$[ebp]
	mov	eax, DWORD PTR [ebx]
	cmp	edi, esi
	jge	SHORT $LN5@DragIntRan
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 125  : static inline int    ImMin(int lhs, int rhs)                                    { return lhs < rhs ? lhs : rhs; }

	cmp	esi, eax
	cmovl	eax, esi
$LN5@DragIntRan:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8110 :     bool value_changed = DragInt("##min", v_current_min, v_speed, (v_min >= v_max) ? INT_MIN : v_min, (v_min >= v_max) ? *v_current_max : ImMin(v_max, *v_current_max), display_format);

	push	DWORD PTR _display_format$[ebp]
	movss	xmm0, DWORD PTR _v_speed$[ebp]
	mov	ecx, -2147483648			; 80000000H
	push	eax
	cmp	edi, esi
	mov	eax, edi
	cmovge	eax, ecx
	push	eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _v_current_min$[ebp]
	push	OFFSET $SG120408
	call	?DragInt@ImGui@@YA_NPBDPAHMHH0@Z	; ImGui::DragInt
	mov	BYTE PTR _value_changed$1$[ebp], al

; 8111 :     PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 8112 :     SameLine(0, g.Style.ItemInnerSpacing.x);

	mov	ecx, DWORD PTR _g$1$[ebp]
	add	esp, 16					; 00000010H
	movss	xmm0, DWORD PTR [ecx+5376]
	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 8113 :     value_changed |= DragInt("##max", v_current_max, v_speed, (v_min >= v_max) ? *v_current_min : ImMax(v_min, *v_current_min), (v_min >= v_max) ? INT_MAX : v_max, display_format_max ? display_format_max : display_format);

	mov	eax, DWORD PTR _v_current_min$[ebp]
	add	esp, 8
	mov	ecx, DWORD PTR [eax]
	cmp	edi, esi
	jge	SHORT $LN7@DragIntRan
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 126  : static inline int    ImMax(int lhs, int rhs)                                    { return lhs >= rhs ? lhs : rhs; }

	cmp	edi, ecx
	cmovge	ecx, edi
$LN7@DragIntRan:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8113 :     value_changed |= DragInt("##max", v_current_max, v_speed, (v_min >= v_max) ? *v_current_min : ImMax(v_min, *v_current_min), (v_min >= v_max) ? INT_MAX : v_max, display_format_max ? display_format_max : display_format);

	mov	eax, DWORD PTR _display_format_max$[ebp]
	test	eax, eax
	mov	edx, DWORD PTR _display_format$[ebp]
	movss	xmm0, DWORD PTR _v_speed$[ebp]
	cmovne	edx, eax
	push	edx
	mov	eax, 2147483647				; 7fffffffH
	cmp	edi, esi
	cmovge	esi, eax
	push	esi
	push	ecx
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	ebx
	push	OFFSET $SG120409
	call	?DragInt@ImGui@@YA_NPBDPAHMHH0@Z	; ImGui::DragInt
	mov	bl, BYTE PTR _value_changed$1$[ebp]
	or	bl, al

; 8114 :     PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 8115 :     SameLine(0, g.Style.ItemInnerSpacing.x);

	mov	eax, DWORD PTR _g$1$[ebp]
	add	esp, 16					; 00000010H
	movss	xmm0, DWORD PTR [eax+5376]
	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 8116 : 
; 8117 :     TextUnformatted(label, FindRenderedTextEnd(label));

	mov	esi, DWORD PTR _label$[ebp]
	push	0
	push	esi
	call	?FindRenderedTextEnd@ImGui@@YAPBDPBD0@Z	; ImGui::FindRenderedTextEnd
	push	eax
	push	esi
	call	?TextUnformatted@ImGui@@YAXPBD0@Z	; ImGui::TextUnformatted
	add	esp, 24					; 00000018H

; 8118 :     EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup

; 8119 :     PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID
	pop	edi
	pop	esi

; 8120 : 
; 8121 :     return value_changed;

	mov	al, bl
	pop	ebx

; 8122 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DragIntRange2@ImGui@@YA_NPBDPAH1MHH00@Z ENDP		; ImGui::DragIntRange2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_v_speed$ = 16						; size = 4
_v_min$ = 20						; size = 4
_v_max$ = 24						; size = 4
_display_format$ = 28					; size = 4
?DragInt4@ImGui@@YA_NPBDQAHMHH0@Z PROC			; ImGui::DragInt4

; 8095 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 8096 :     return DragIntN(label, v, 4, v_speed, v_min, v_max, display_format);

	push	DWORD PTR _display_format$[ebp]
	movss	xmm0, DWORD PTR _v_speed$[ebp]
	push	DWORD PTR _v_max$[ebp]
	push	DWORD PTR _v_min$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	4
	push	DWORD PTR _v$[ebp]
	push	DWORD PTR _label$[ebp]
	call	?DragIntN@ImGui@@YA_NPBDPAHHMHH0@Z	; ImGui::DragIntN
	add	esp, 28					; 0000001cH

; 8097 : }

	pop	ebp
	ret	0
?DragInt4@ImGui@@YA_NPBDQAHMHH0@Z ENDP			; ImGui::DragInt4
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_v_speed$ = 16						; size = 4
_v_min$ = 20						; size = 4
_v_max$ = 24						; size = 4
_display_format$ = 28					; size = 4
?DragInt3@ImGui@@YA_NPBDQAHMHH0@Z PROC			; ImGui::DragInt3

; 8090 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 8091 :     return DragIntN(label, v, 3, v_speed, v_min, v_max, display_format);

	push	DWORD PTR _display_format$[ebp]
	movss	xmm0, DWORD PTR _v_speed$[ebp]
	push	DWORD PTR _v_max$[ebp]
	push	DWORD PTR _v_min$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	3
	push	DWORD PTR _v$[ebp]
	push	DWORD PTR _label$[ebp]
	call	?DragIntN@ImGui@@YA_NPBDPAHHMHH0@Z	; ImGui::DragIntN
	add	esp, 28					; 0000001cH

; 8092 : }

	pop	ebp
	ret	0
?DragInt3@ImGui@@YA_NPBDQAHMHH0@Z ENDP			; ImGui::DragInt3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_v_speed$ = 16						; size = 4
_v_min$ = 20						; size = 4
_v_max$ = 24						; size = 4
_display_format$ = 28					; size = 4
?DragInt2@ImGui@@YA_NPBDQAHMHH0@Z PROC			; ImGui::DragInt2

; 8085 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 8086 :     return DragIntN(label, v, 2, v_speed, v_min, v_max, display_format);

	push	DWORD PTR _display_format$[ebp]
	movss	xmm0, DWORD PTR _v_speed$[ebp]
	push	DWORD PTR _v_max$[ebp]
	push	DWORD PTR _v_min$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	2
	push	DWORD PTR _v$[ebp]
	push	DWORD PTR _label$[ebp]
	call	?DragIntN@ImGui@@YA_NPBDPAHHMHH0@Z	; ImGui::DragIntN
	add	esp, 28					; 0000001cH

; 8087 : }

	pop	ebp
	ret	0
?DragInt2@ImGui@@YA_NPBDQAHMHH0@Z ENDP			; ImGui::DragInt2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v_f$ = 12						; size = 4
_v$ = 12						; size = 4
_v_speed$ = 16						; size = 4
_v_min$ = 20						; size = 4
_v_max$ = 24						; size = 4
_display_format$ = 28					; size = 4
?DragInt@ImGui@@YA_NPBDPAHMHH0@Z PROC			; ImGui::DragInt

; 8048 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _display_format$[ebp]
	test	eax, eax
	push	esi

; 8049 :     if (!display_format)
; 8050 :         display_format = "%.0f";
; 8051 :     float v_f = (float)*v;

	mov	esi, DWORD PTR _v$[ebp]

; 8052 :     bool value_changed = DragFloat(label, &v_f, v_speed, (float)v_min, (float)v_max, display_format);

	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	mov	ecx, OFFSET $SG120351
	cmovne	ecx, eax
	lea	eax, DWORD PTR _v_f$[ebp]
	movd	xmm0, DWORD PTR [esi]
	cvtdq2ps xmm0, xmm0
	push	ecx
	sub	esp, 12					; 0000000cH
	movss	DWORD PTR _v_f$[ebp], xmm0
	movd	xmm0, DWORD PTR _v_max$[ebp]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [esp+8], xmm0
	movd	xmm0, DWORD PTR _v_min$[ebp]
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _v_speed$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	eax
	push	DWORD PTR _label$[ebp]
	call	?DragFloat@ImGui@@YA_NPBDPAMMMM0M@Z	; ImGui::DragFloat

; 8053 :     *v = (int)v_f;

	cvttss2si ecx, DWORD PTR _v_f$[ebp]
	add	esp, 28					; 0000001cH
	mov	DWORD PTR [esi], ecx
	pop	esi

; 8054 :     return value_changed;
; 8055 : }

	pop	ebp
	ret	0
?DragInt@ImGui@@YA_NPBDPAHMHH0@Z ENDP			; ImGui::DragInt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_g$1$ = -8						; size = 4
_value_changed$1$ = -1					; size = 1
_label$ = 8						; size = 4
_v_current_min$ = 12					; size = 4
_v_current_max$ = 16					; size = 4
_v_speed$ = 20						; size = 4
_v_min$ = 24						; size = 4
_v_max$ = 28						; size = 4
_display_format$ = 32					; size = 4
_display_format_max$ = 36				; size = 4
_power$ = 40						; size = 4
?DragFloatRange2@ImGui@@YA_NPBDPAM1MMM00M@Z PROC	; ImGui::DragFloatRange2

; 8022 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8022 : {

	sub	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8024 :     if (window->SkipItems)

	mov	eax, DWORD PTR [ecx+6240]
	cmp	BYTE PTR [eax+137], 0
	je	SHORT $LN2@DragFloatR

; 8025 :         return false;

	xor	al, al

; 8044 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@DragFloatR:

; 8026 : 
; 8027 :     ImGuiContext& g = *GImGui;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	ebx
	push	esi
	push	edi

; 8028 :     PushID(label);

	mov	edi, DWORD PTR _label$[ebp]
	push	edi
	mov	DWORD PTR _g$1$[ebp], eax
	call	?PushID@ImGui@@YAXPBD@Z			; ImGui::PushID

; 8029 :     BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup

; 8030 :     PushMultiItemsWidths(2);

	mov	DWORD PTR [esp], 0
	push	2
	call	?PushMultiItemsWidths@@YAXHM@Z		; PushMultiItemsWidths

; 8031 : 
; 8032 :     bool value_changed = DragFloat("##min", v_current_min, v_speed, (v_min >= v_max) ? -FLT_MAX : v_min, (v_min >= v_max) ? *v_current_max : ImMin(v_max, *v_current_max), display_format, power);

	mov	esi, DWORD PTR _v_current_max$[ebp]
	add	esp, 8
	movss	xmm1, DWORD PTR _v_max$[ebp]
	movss	xmm0, DWORD PTR _v_min$[ebp]
	comiss	xmm0, xmm1
	movss	xmm2, DWORD PTR [esi]
	jae	SHORT $LN23@DragFloatR
	minss	xmm2, xmm1
	jmp	SHORT $LN6@DragFloatR
$LN23@DragFloatR:
	movss	xmm0, DWORD PTR __real@ff7fffff
$LN6@DragFloatR:
	movss	xmm1, DWORD PTR _power$[ebp]
	mov	ebx, DWORD PTR _v_current_min$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm1
	push	DWORD PTR _display_format$[ebp]
	sub	esp, 12					; 0000000cH
	movss	DWORD PTR [esp+8], xmm2
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _v_speed$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	ebx
	push	OFFSET $SG120334
	call	?DragFloat@ImGui@@YA_NPBDPAMMMM0M@Z	; ImGui::DragFloat
	mov	BYTE PTR _value_changed$1$[ebp], al

; 8033 :     PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 8034 :     SameLine(0, g.Style.ItemInnerSpacing.x);

	mov	ecx, DWORD PTR _g$1$[ebp]
	add	esp, 20					; 00000014H
	movss	xmm0, DWORD PTR [ecx+5376]
	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 8035 :     value_changed |= DragFloat("##max", v_current_max, v_speed, (v_min >= v_max) ? *v_current_min : ImMax(v_min, *v_current_min), (v_min >= v_max) ? FLT_MAX : v_max, display_format_max ? display_format_max : display_format, power);

	movss	xmm0, DWORD PTR _v_min$[ebp]
	add	esp, 8
	movss	xmm1, DWORD PTR _v_max$[ebp]
	comiss	xmm0, xmm1
	jb	SHORT $LN8@DragFloatR
	movss	xmm2, DWORD PTR __real@7f7fffff
	jmp	SHORT $LN9@DragFloatR
$LN8@DragFloatR:
	movaps	xmm2, xmm1
$LN9@DragFloatR:
	comiss	xmm0, xmm1
	jb	SHORT $LN10@DragFloatR
	movss	xmm0, DWORD PTR [ebx]
	jmp	SHORT $LN11@DragFloatR
$LN10@DragFloatR:
	maxss	xmm0, DWORD PTR [ebx]
$LN11@DragFloatR:
	mov	eax, DWORD PTR _display_format_max$[ebp]
	test	eax, eax
	movss	xmm1, DWORD PTR _power$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _display_format$[ebp]
	movss	DWORD PTR [esp], xmm1
	cmovne	ecx, eax
	push	ecx
	sub	esp, 12					; 0000000cH
	movss	DWORD PTR [esp+8], xmm2
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _v_speed$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	esi
	push	OFFSET $SG120335
	call	?DragFloat@ImGui@@YA_NPBDPAMMMM0M@Z	; ImGui::DragFloat
	mov	bl, BYTE PTR _value_changed$1$[ebp]
	or	bl, al

; 8036 :     PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 8037 :     SameLine(0, g.Style.ItemInnerSpacing.x);

	mov	eax, DWORD PTR _g$1$[ebp]
	add	esp, 20					; 00000014H
	movss	xmm0, DWORD PTR [eax+5376]
	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 8038 : 
; 8039 :     TextUnformatted(label, FindRenderedTextEnd(label));

	push	0
	push	edi
	call	?FindRenderedTextEnd@ImGui@@YAPBDPBD0@Z	; ImGui::FindRenderedTextEnd
	push	eax
	push	edi
	call	?TextUnformatted@ImGui@@YAXPBD0@Z	; ImGui::TextUnformatted
	add	esp, 24					; 00000018H

; 8040 :     EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup

; 8041 :     PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID
	pop	edi
	pop	esi

; 8042 : 
; 8043 :     return value_changed;

	mov	al, bl
	pop	ebx

; 8044 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DragFloatRange2@ImGui@@YA_NPBDPAM1MMM00M@Z ENDP	; ImGui::DragFloatRange2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_v_speed$ = 16						; size = 4
_v_min$ = 20						; size = 4
_v_max$ = 24						; size = 4
_display_format$ = 28					; size = 4
_power$ = 32						; size = 4
?DragFloat4@ImGui@@YA_NPBDQAMMMM0M@Z PROC		; ImGui::DragFloat4

; 8017 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 8018 :     return DragFloatN(label, v, 4, v_speed, v_min, v_max, display_format, power);

	movss	xmm0, DWORD PTR _power$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _display_format$[ebp]
	movss	xmm0, DWORD PTR _v_max$[ebp]
	sub	esp, 12					; 0000000cH
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _v_min$[ebp]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _v_speed$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	4
	push	DWORD PTR _v$[ebp]
	push	DWORD PTR _label$[ebp]
	call	?DragFloatN@ImGui@@YA_NPBDPAMHMMM0M@Z	; ImGui::DragFloatN
	add	esp, 32					; 00000020H

; 8019 : }

	pop	ebp
	ret	0
?DragFloat4@ImGui@@YA_NPBDQAMMMM0M@Z ENDP		; ImGui::DragFloat4
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_v_speed$ = 16						; size = 4
_v_min$ = 20						; size = 4
_v_max$ = 24						; size = 4
_display_format$ = 28					; size = 4
_power$ = 32						; size = 4
?DragFloat3@ImGui@@YA_NPBDQAMMMM0M@Z PROC		; ImGui::DragFloat3

; 8012 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 8013 :     return DragFloatN(label, v, 3, v_speed, v_min, v_max, display_format, power);

	movss	xmm0, DWORD PTR _power$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _display_format$[ebp]
	movss	xmm0, DWORD PTR _v_max$[ebp]
	sub	esp, 12					; 0000000cH
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _v_min$[ebp]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _v_speed$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	3
	push	DWORD PTR _v$[ebp]
	push	DWORD PTR _label$[ebp]
	call	?DragFloatN@ImGui@@YA_NPBDPAMHMMM0M@Z	; ImGui::DragFloatN
	add	esp, 32					; 00000020H

; 8014 : }

	pop	ebp
	ret	0
?DragFloat3@ImGui@@YA_NPBDQAMMMM0M@Z ENDP		; ImGui::DragFloat3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_v_speed$ = 16						; size = 4
_v_min$ = 20						; size = 4
_v_max$ = 24						; size = 4
_display_format$ = 28					; size = 4
_power$ = 32						; size = 4
?DragFloat2@ImGui@@YA_NPBDQAMMMM0M@Z PROC		; ImGui::DragFloat2

; 8007 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 8008 :     return DragFloatN(label, v, 2, v_speed, v_min, v_max, display_format, power);

	movss	xmm0, DWORD PTR _power$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _display_format$[ebp]
	movss	xmm0, DWORD PTR _v_max$[ebp]
	sub	esp, 12					; 0000000cH
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _v_min$[ebp]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _v_speed$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	2
	push	DWORD PTR _v$[ebp]
	push	DWORD PTR _label$[ebp]
	call	?DragFloatN@ImGui@@YA_NPBDPAMHMMM0M@Z	; ImGui::DragFloatN
	add	esp, 32					; 00000020H

; 8009 : }

	pop	ebp
	ret	0
?DragFloat2@ImGui@@YA_NPBDQAMMMM0M@Z ENDP		; ImGui::DragFloat2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_value_buf$ = -132					; size = 64
_total_bb$ = -68					; size = 16
_frame_bb$ = -52					; size = 16
$T3 = -36						; size = 8
$T2$sroa$314$1$ = -32					; size = 4
$T4 = -28						; size = 8
tv479 = -24						; size = 4
_id$ = -24						; size = 4
$T5 = -20						; size = 8
_label_size$ = -20					; size = 8
$T6 = -12						; size = 8
_decimal_precision$1$ = -8				; size = 4
_w$ = -8						; size = 4
_tab_focus_requested$1$ = -2				; size = 1
_hovered$1$ = -1					; size = 1
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_v_speed$ = 16						; size = 4
_v_min$ = 20						; size = 4
_v_max$ = 24						; size = 4
_display_format$ = 28					; size = 4
_power$ = 32						; size = 4
?DragFloat@ImGui@@YA_NPBDPAMMMM0M@Z PROC		; ImGui::DragFloat

; 7918 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7918 : {

	sub	esp, 132				; 00000084H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	push	esi
	mov	BYTE PTR [eax+134], 1
	mov	esi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7920 :     if (window->SkipItems)

	cmp	BYTE PTR [esi+137], 0
	je	SHORT $LN2@DragFloat

; 7921 :         return false;

	xor	al, al
	pop	esi

; 7977 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@DragFloat:
	push	ebx
	push	edi

; 7922 : 
; 7923 :     ImGuiContext& g = *GImGui;

	mov	edi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 7924 :     const ImGuiStyle& style = g.Style;
; 7925 :     const ImGuiID id = window->GetID(label);

	mov	ecx, esi
	push	0
	push	DWORD PTR _label$[ebp]
	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID
	mov	ebx, eax
	mov	DWORD PTR _id$[ebp], ebx

; 7926 :     const float w = CalcItemWidth();

	call	?CalcItemWidth@ImGui@@YAMXZ		; ImGui::CalcItemWidth

; 7927 : 
; 7928 :     const ImVec2 label_size = CalcTextSize(label, NULL, true);

	push	ecx
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	lea	eax, DWORD PTR _label_size$[ebp]
	push	1
	push	0
	push	DWORD PTR _label$[ebp]
	fstp	DWORD PTR _w$[ebp]
	push	eax
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize

; 7929 :     const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2.0f));

	movss	xmm0, DWORD PTR [edi+5360]
	add	esp, 20					; 00000014H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm1, DWORD PTR [esi+192]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7929 :     const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2.0f));

	addss	xmm0, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm2, DWORD PTR [esi+196]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [esi+192]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm1, DWORD PTR _w$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7931 :     const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

	movss	xmm3, DWORD PTR _label_size$[ebp]
	addss	xmm0, DWORD PTR _label_size$[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _frame_bb$[ebp], eax
	mov	eax, DWORD PTR [esi+196]
	mov	DWORD PTR _frame_bb$[ebp+4], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T3[ebp]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [edi+5360]
	addss	xmm0, DWORD PTR _frame_bb$[ebp+4]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _frame_bb$[ebp+8], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T3[ebp+4]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	DWORD PTR $T2$sroa$314$1$[ebp], xmm0
	xorps	xmm0, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7931 :     const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

	comiss	xmm3, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _frame_bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7931 :     const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

	jbe	SHORT $LN15@DragFloat
	movss	xmm0, DWORD PTR [edi+5376]
	addss	xmm0, xmm3
$LN15@DragFloat:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [esi+192]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm1, xmm0

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _total_bb$[ebp], eax
	mov	eax, DWORD PTR [esi+196]
	mov	DWORD PTR _total_bb$[ebp+4], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T6[ebp+4], xmm2
	movss	DWORD PTR $T6[ebp], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR _total_bb$[ebp+8], eax
	mov	eax, DWORD PTR $T6[ebp+4]
	mov	DWORD PTR _total_bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7934 :     if (!ItemAdd(total_bb, &id, &frame_bb))

	lea	eax, DWORD PTR _frame_bb$[ebp]
	push	eax
	lea	eax, DWORD PTR _id$[ebp]
	push	eax
	lea	eax, DWORD PTR _total_bb$[ebp]
	push	eax
	call	?ItemAdd@ImGui@@YA_NABUImRect@@PBIPBU2@@Z ; ImGui::ItemAdd
	add	esp, 12					; 0000000cH
	test	al, al
	jne	SHORT $LN3@DragFloat

; 7935 :     {
; 7936 :         ItemSize(total_bb, style.FramePadding.y);

	movss	xmm0, DWORD PTR [edi+5360]
	lea	eax, DWORD PTR _total_bb$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	eax
	call	?ItemSize@ImGui@@YAXABUImRect@@M@Z	; ImGui::ItemSize
	add	esp, 8

; 7937 :         return false;

	xor	al, al
	pop	edi
	pop	ebx
	pop	esi

; 7977 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@DragFloat:

; 7938 :     }
; 7939 : 
; 7940 :     const bool hovered = IsHovered(frame_bb, id);

	push	0
	lea	eax, DWORD PTR _frame_bb$[ebp]
	push	ebx
	push	eax
	call	?IsHovered@ImGui@@YA_NABUImRect@@I_N@Z	; ImGui::IsHovered
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _hovered$1$[ebp], al

; 7941 :     if (hovered)

	test	al, al
	je	SHORT $LN4@DragFloat

; 7942 :         SetHoveredID(id);

	push	ebx
	call	?SetHoveredID@ImGui@@YAXI@Z		; ImGui::SetHoveredID
	add	esp, 4
$LN4@DragFloat:

; 7943 : 
; 7944 :     if (!display_format)
; 7945 :         display_format = "%.3f";
; 7946 :     int decimal_precision = ParseFormatPrecision(display_format, 3);

	mov	eax, DWORD PTR _display_format$[ebp]
	mov	ecx, OFFSET $SG120264
	test	eax, eax
	push	3
	cmovne	ecx, eax
	push	ecx
	mov	DWORD PTR tv479[ebp], ecx
	call	?ParseFormatPrecision@ImGui@@YAHPBDH@Z	; ImGui::ParseFormatPrecision

; 7947 : 
; 7948 :     // Tabbing or CTRL-clicking on Drag turns it into an input box
; 7949 :     bool start_text_input = false;
; 7950 :     const bool tab_focus_requested = FocusableItemRegister(window, id);

	push	1
	push	ebx
	push	esi
	mov	DWORD PTR _decimal_precision$1$[ebp], eax
	call	?FocusableItemRegister@ImGui@@YA_NPAUImGuiWindow@@I_N@Z ; ImGui::FocusableItemRegister
	add	esp, 20					; 00000014H
	mov	BYTE PTR _tab_focus_requested$1$[ebp], al

; 7951 :     if (tab_focus_requested || (hovered && (g.IO.MouseClicked[0] || g.IO.MouseDoubleClicked[0])) || g.NavActivateId == id || g.NavInputId == id)

	test	al, al
	jne	SHORT $LN7@DragFloat
	cmp	BYTE PTR _hovered$1$[ebp], al
	je	SHORT $LN8@DragFloat
	cmp	BYTE PTR [edi+888], al
	jne	SHORT $LN7@DragFloat
	cmp	BYTE PTR [edi+956], al
	jne	SHORT $LN7@DragFloat
$LN8@DragFloat:
	cmp	DWORD PTR [edi+6388], ebx
	je	SHORT $LN7@DragFloat
	cmp	DWORD PTR [edi+6392], ebx
	jne	SHORT $LN49@DragFloat
$LN7@DragFloat:

; 7952 :     {
; 7953 :         SetActiveID(id, window);

	push	esi
	push	ebx
	call	?SetActiveID@ImGui@@YAXIPAUImGuiWindow@@@Z ; ImGui::SetActiveID

; 7954 :         FocusWindow(window);

	push	esi
	call	?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusWindow
	add	esp, 12					; 0000000cH

; 7955 :         if (tab_focus_requested || g.IO.KeyCtrl || g.IO.MouseDoubleClicked[0] || g.NavInputId == id)

	cmp	BYTE PTR _tab_focus_requested$1$[ebp], 0
	jne	$LN10@DragFloat
	cmp	BYTE PTR [edi+229], 0
	jne	$LN10@DragFloat
	cmp	BYTE PTR [edi+956], 0
	jne	$LN10@DragFloat
	cmp	DWORD PTR [edi+6392], ebx
	je	$LN10@DragFloat
$LN49@DragFloat:

; 7959 :         }
; 7960 :     }
; 7961 :     if (start_text_input || (g.ActiveId == id && g.ScalarAsInputTextId == id))

	cmp	DWORD PTR [edi+6264], ebx
	jne	SHORT $LN11@DragFloat
	cmp	DWORD PTR [edi+10500], ebx
	je	$LN12@DragFloat
$LN11@DragFloat:

; 7963 : 
; 7964 :     // Actual drag behavior
; 7965 :     ItemSize(total_bb, style.FramePadding.y);

	movss	xmm0, DWORD PTR [edi+5360]
	lea	eax, DWORD PTR _total_bb$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	eax
	call	?ItemSize@ImGui@@YAXABUImRect@@M@Z	; ImGui::ItemSize

; 7966 :     const bool value_changed = DragBehavior(frame_bb, id, v, v_speed, v_min, v_max, decimal_precision, power);

	movss	xmm0, DWORD PTR _power$[ebp]
	lea	eax, DWORD PTR _frame_bb$[ebp]
	mov	esi, DWORD PTR _v$[ebp]
	add	esp, 4
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _decimal_precision$1$[ebp]
	movss	xmm0, DWORD PTR _v_max$[ebp]
	sub	esp, 12					; 0000000cH
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _v_min$[ebp]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _v_speed$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	esi
	push	ebx
	push	eax
	call	?DragBehavior@ImGui@@YA_NABUImRect@@IPAMMMMHM@Z ; ImGui::DragBehavior
	movss	xmm0, DWORD PTR [esi]

; 7970 :     const char* value_buf_end = value_buf + ImFormatString(value_buf, IM_ARRAYSIZE(value_buf), display_format, *v);

	add	esp, 24					; 00000018H
	cvtps2pd xmm0, xmm0
	mov	bl, al
	lea	eax, DWORD PTR _value_buf$[ebp]
	movsd	QWORD PTR [esp], xmm0
	push	DWORD PTR tv479[ebp]
	push	64					; 00000040H
	push	eax
	call	?ImFormatString@@YAHPADHPBDZZ		; ImFormatString

; 7971 :     RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f,0.5f));

	push	0
	lea	ecx, DWORD PTR _value_buf$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T4[ebp], 1056964608		; 3f000000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7970 :     const char* value_buf_end = value_buf + ImFormatString(value_buf, IM_ARRAYSIZE(value_buf), display_format, *v);

	add	eax, ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T4[ebp+4], 1056964608	; 3f000000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7971 :     RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f,0.5f));

	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	push	0
	push	eax
	lea	eax, DWORD PTR _value_buf$[ebp]
	push	eax
	lea	eax, DWORD PTR _frame_bb$[ebp+8]
	push	eax
	lea	eax, DWORD PTR _frame_bb$[ebp]
	push	eax
	call	?RenderTextClipped@ImGui@@YAXABUImVec2@@0PBD1PBU2@0PBUImRect@@@Z ; ImGui::RenderTextClipped

; 7972 : 
; 7973 :     if (label_size.x > 0.0f)

	movss	xmm0, DWORD PTR _label_size$[ebp]
	xorps	xmm1, xmm1
	add	esp, 48					; 00000030H
	comiss	xmm0, xmm1
	jbe	SHORT $LN13@DragFloat

; 7974 :         RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, inner_bb.Min.y), label);

	movss	xmm0, DWORD PTR [edi+5376]
	addss	xmm0, DWORD PTR _frame_bb$[ebp+8]
	push	1
	push	0
	push	DWORD PTR _label$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T5[ebp], xmm0
	movss	xmm0, DWORD PTR $T2$sroa$314$1$[ebp]
	movss	DWORD PTR $T5[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7974 :         RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, inner_bb.Min.y), label);

	push	DWORD PTR $T5[ebp+4]
	push	DWORD PTR $T5[ebp]
	call	?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z	; ImGui::RenderText
	add	esp, 20					; 00000014H
$LN13@DragFloat:

; 7975 : 
; 7976 :     return value_changed;

	pop	edi
	mov	al, bl
	pop	ebx
	pop	esi

; 7977 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@DragFloat:

; 7956 :         {
; 7957 :             start_text_input = true;
; 7958 :             g.ScalarAsInputTextId = 0;

	mov	DWORD PTR [edi+10500], 0
$LN12@DragFloat:

; 7962 :         return InputScalarAsWidgetReplacement(frame_bb, label, ImGuiDataType_Float, v, id, decimal_precision);

	push	DWORD PTR _decimal_precision$1$[ebp]
	lea	eax, DWORD PTR _frame_bb$[ebp]
	push	ebx
	push	DWORD PTR _v$[ebp]
	push	1
	push	DWORD PTR _label$[ebp]
	push	eax
	call	?InputScalarAsWidgetReplacement@ImGui@@YA_NABUImRect@@PBDW4ImGuiDataType@@PAXIH@Z ; ImGui::InputScalarAsWidgetReplacement
	add	esp, 24					; 00000018H
	pop	edi
	pop	ebx
	pop	esi

; 7977 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DragFloat@ImGui@@YA_NPBDPAMMMM0M@Z ENDP		; ImGui::DragFloat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_overlay_buf$ = -80					; size = 32
_bb$ = -48						; size = 16
_overlay_size$ = -32					; size = 8
$T2 = -32						; size = 8
$T3 = -24						; size = 8
_fill_br$ = -24						; size = 8
$T4 = -16						; size = 8
$T5 = -16						; size = 8
_bb$3$ = -12						; size = 4
_fill_br$1$ = -8					; size = 4
_pos$2$ = -8						; size = 4
$T6 = -4						; size = 4
_pos$1$ = -4						; size = 4
_fraction$ = 8						; size = 4
_size_arg$ = 12						; size = 4
_overlay$ = 16						; size = 4
?ProgressBar@ImGui@@YAXMABUImVec2@@PBD@Z PROC		; ImGui::ProgressBar

; 8276 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8276 : {

	sub	esp, 80					; 00000050H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	push	edi
	mov	BYTE PTR [eax+134], 1
	mov	edi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8278 :     if (window->SkipItems)

	cmp	BYTE PTR [edi+137], 0
	jne	$LN5@ProgressBa

; 8279 :         return;
; 8280 : 
; 8281 :     ImGuiContext& g = *GImGui;

	movss	xmm0, DWORD PTR [edi+192]
	movss	DWORD PTR _pos$1$[ebp], xmm0
	movss	xmm0, DWORD PTR [edi+196]
	push	esi
	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	movss	DWORD PTR _pos$2$[ebp], xmm0

; 8282 :     const ImGuiStyle& style = g.Style;
; 8283 : 
; 8284 :     ImVec2 pos = window->DC.CursorPos;
; 8285 :     ImRect bb(pos, pos + CalcItemSize(size_arg, CalcItemWidth(), g.FontSize + style.FramePadding.y*2.0f));

	push	ecx
	movss	xmm0, DWORD PTR [esi+5360]
	addss	xmm0, xmm0
	addss	xmm0, DWORD PTR [esi+6172]
	movss	DWORD PTR [esp], xmm0
	call	?CalcItemWidth@ImGui@@YAMXZ		; ImGui::CalcItemWidth
	mov	eax, DWORD PTR _size_arg$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?CalcItemSize@ImGui@@YA?AUImVec2@@U2@MM@Z ; ImGui::CalcItemSize
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm1, DWORD PTR _pos$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8286 :     ItemSize(bb, style.FramePadding.y);

	add	esp, 16					; 00000010H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm2, DWORD PTR _pos$2$[ebp]
	movss	DWORD PTR _bb$[ebp], xmm1
	movss	xmm0, DWORD PTR [eax]
	addss	xmm0, xmm1
	movss	DWORD PTR _bb$[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T5[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [eax+4]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T5[ebp]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm2

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _bb$[ebp+8], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T5[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T5[ebp+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8286 :     ItemSize(bb, style.FramePadding.y);

	movss	xmm0, DWORD PTR [esi+5360]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8286 :     ItemSize(bb, style.FramePadding.y);

	lea	eax, DWORD PTR _bb$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	eax
	call	?ItemSize@ImGui@@YAXABUImRect@@M@Z	; ImGui::ItemSize

; 8287 :     if (!ItemAdd(bb, NULL))

	push	0
	lea	eax, DWORD PTR _bb$[ebp]
	push	0
	push	eax
	call	?ItemAdd@ImGui@@YA_NABUImRect@@PBIPBU2@@Z ; ImGui::ItemAdd
	add	esp, 20					; 00000014H
	test	al, al
	je	$LN39@ProgressBa
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 134  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	movss	xmm0, DWORD PTR _fraction$[ebp]
	xorps	xmm1, xmm1
	comiss	xmm1, xmm0
	jbe	SHORT $LN19@ProgressBa
	movss	DWORD PTR _fraction$[ebp], xmm1
	jmp	SHORT $LN17@ProgressBa
$LN19@ProgressBa:
	minss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR _fraction$[ebp], xmm0
$LN17@ProgressBa:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8292 :     RenderFrame(bb.Min, bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);

	movss	xmm0, DWORD PTR [esi+5364]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	1
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	7
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	add	esp, 8
	push	eax
	push	DWORD PTR _bb$[ebp+12]
	push	DWORD PTR _bb$[ebp+8]
	push	DWORD PTR _bb$[ebp+4]
	push	DWORD PTR _bb$[ebp]
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame

; 8293 :     bb.Expand(ImVec2(-window->BorderSize, -window->BorderSize));

	movss	xmm0, DWORD PTR [edi+128]

; 8295 :     RenderFrame(bb.Min, fill_br, GetColorU32(ImGuiCol_PlotHistogram), false, style.FrameRounding);

	add	esp, 24					; 00000018H
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 258  :     void        Expand(const ImVec2& amount)    { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }

	movss	xmm2, DWORD PTR _bb$[ebp+4]
	movss	xmm1, DWORD PTR _bb$[ebp]
	subss	xmm2, xmm0
	subss	xmm1, xmm0
	movss	DWORD PTR _bb$[ebp+4], xmm2
	movaps	xmm2, xmm0
	addss	xmm2, DWORD PTR _bb$[ebp+8]
	addss	xmm0, DWORD PTR _bb$[ebp+12]
	movss	DWORD PTR $T6[ebp], xmm1
	movss	DWORD PTR _bb$[ebp], xmm1
	movss	DWORD PTR _bb$3$[ebp], xmm2
	movss	DWORD PTR _bb$[ebp+8], xmm2

; 135  : static inline float  ImLerp(float a, float b, float t)                          { return a + (b - a) * t; }

	subss	xmm2, xmm1

; 258  :     void        Expand(const ImVec2& amount)    { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }

	movss	DWORD PTR _bb$[ebp+12], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _fill_br$[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8295 :     RenderFrame(bb.Min, fill_br, GetColorU32(ImGuiCol_PlotHistogram), false, style.FrameRounding);

	movss	xmm0, DWORD PTR [esi+5364]
	movss	DWORD PTR [esp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 135  : static inline float  ImLerp(float a, float b, float t)                          { return a + (b - a) * t; }

	mulss	xmm2, DWORD PTR _fraction$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8295 :     RenderFrame(bb.Min, fill_br, GetColorU32(ImGuiCol_PlotHistogram), false, style.FrameRounding);

	push	0
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 135  : static inline float  ImLerp(float a, float b, float t)                          { return a + (b - a) * t; }

	addss	xmm2, xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8295 :     RenderFrame(bb.Min, fill_br, GetColorU32(ImGuiCol_PlotHistogram), false, style.FrameRounding);

	push	39					; 00000027H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 135  : static inline float  ImLerp(float a, float b, float t)                          { return a + (b - a) * t; }

	movss	DWORD PTR _fill_br$1$[ebp], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _fill_br$[ebp], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8295 :     RenderFrame(bb.Min, fill_br, GetColorU32(ImGuiCol_PlotHistogram), false, style.FrameRounding);

	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	add	esp, 8
	push	eax
	push	DWORD PTR _fill_br$[ebp+4]
	push	DWORD PTR _fill_br$[ebp]
	push	DWORD PTR _bb$[ebp+4]
	push	DWORD PTR _bb$[ebp]
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame

; 8296 : 
; 8297 :     // Default displaying the fraction as percentage string, but user can override it
; 8298 :     char overlay_buf[32];
; 8299 :     if (!overlay)

	mov	edi, DWORD PTR _overlay$[ebp]
	add	esp, 28					; 0000001cH
	test	edi, edi
	jne	SHORT $LN4@ProgressBa

; 8300 :     {
; 8301 :         ImFormatString(overlay_buf, IM_ARRAYSIZE(overlay_buf), "%.0f%%", fraction*100+0.01f);

	movss	xmm0, DWORD PTR _fraction$[ebp]
	lea	eax, DWORD PTR _overlay_buf$[ebp]
	mulss	xmm0, DWORD PTR __real@42c80000
	sub	esp, 8
	addss	xmm0, DWORD PTR __real@3c23d70a
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG120603
	push	32					; 00000020H
	push	eax
	call	?ImFormatString@@YAHPADHPBDZZ		; ImFormatString
	add	esp, 20					; 00000014H

; 8302 :         overlay = overlay_buf;

	lea	edi, DWORD PTR _overlay_buf$[ebp]
$LN4@ProgressBa:

; 8303 :     }
; 8304 : 
; 8305 :     ImVec2 overlay_size = CalcTextSize(overlay, NULL);

	push	ecx
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	lea	eax, DWORD PTR _overlay_size$[ebp]
	push	0
	push	0
	push	edi
	push	eax
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize

; 8306 :     if (overlay_size.x > 0.0f)

	movss	xmm2, DWORD PTR _overlay_size$[ebp]
	add	esp, 20					; 00000014H
	comiss	xmm2, DWORD PTR __real@00000000
	jbe	SHORT $LN39@ProgressBa

; 8307 :         RenderTextClipped(ImVec2(ImClamp(fill_br.x + style.ItemSpacing.x, bb.Min.x, bb.Max.x - overlay_size.x - style.ItemInnerSpacing.x), bb.Min.y), bb.Max, overlay, NULL, &overlay_size, ImVec2(0.0f,0.5f), &bb);

	movss	xmm1, DWORD PTR [esi+5368]
	addss	xmm1, DWORD PTR _fill_br$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	movss	xmm0, DWORD PTR $T6[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T3[ebp], 0
	mov	DWORD PTR $T3[ebp+4], 1056964608	; 3f000000H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm0, xmm1
	ja	SHORT $LN34@ProgressBa
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8307 :         RenderTextClipped(ImVec2(ImClamp(fill_br.x + style.ItemSpacing.x, bb.Min.x, bb.Max.x - overlay_size.x - style.ItemInnerSpacing.x), bb.Min.y), bb.Max, overlay, NULL, &overlay_size, ImVec2(0.0f,0.5f), &bb);

	movss	xmm0, DWORD PTR _bb$3$[ebp]
	subss	xmm0, xmm2
	subss	xmm0, DWORD PTR [esi+5376]
	minss	xmm0, xmm1
$LN34@ProgressBa:
	lea	eax, DWORD PTR _bb$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp], xmm0
	movss	xmm0, DWORD PTR _bb$[ebp+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8307 :         RenderTextClipped(ImVec2(ImClamp(fill_br.x + style.ItemSpacing.x, bb.Min.x, bb.Max.x - overlay_size.x - style.ItemInnerSpacing.x), bb.Min.y), bb.Max, overlay, NULL, &overlay_size, ImVec2(0.0f,0.5f), &bb);

	push	eax
	lea	eax, DWORD PTR $T3[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8307 :         RenderTextClipped(ImVec2(ImClamp(fill_br.x + style.ItemSpacing.x, bb.Min.x, bb.Max.x - overlay_size.x - style.ItemInnerSpacing.x), bb.Min.y), bb.Max, overlay, NULL, &overlay_size, ImVec2(0.0f,0.5f), &bb);

	push	eax
	lea	eax, DWORD PTR _overlay_size$[ebp]
	push	eax
	push	0
	push	edi
	lea	eax, DWORD PTR _bb$[ebp+8]
	push	eax
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	?RenderTextClipped@ImGui@@YAXABUImVec2@@0PBD1PBU2@0PBUImRect@@@Z ; ImGui::RenderTextClipped
	add	esp, 28					; 0000001cH
$LN39@ProgressBa:
	pop	esi
$LN5@ProgressBa:
	pop	edi

; 8308 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ProgressBar@ImGui@@YAXMABUImVec2@@PBD@Z ENDP		; ImGui::ProgressBar
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_values_getter$ = 12					; size = 4
_data$ = 16						; size = 4
_values_count$ = 20					; size = 4
_values_offset$ = 24					; size = 4
_overlay_text$ = 28					; size = 4
_scale_min$ = 32					; size = 4
_scale_max$ = 36					; size = 4
_graph_size$ = 40					; size = 8
?PlotHistogram@ImGui@@YAXPBDP6AMPAXH@Z1HH0MMUImVec2@@@Z PROC ; ImGui::PlotHistogram

; 8270 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 8271 :     PlotEx(ImGuiPlotType_Histogram, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);

	push	DWORD PTR _graph_size$[ebp+4]
	movss	xmm0, DWORD PTR _scale_max$[ebp]
	push	DWORD PTR _graph_size$[ebp]
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _scale_min$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _overlay_text$[ebp]
	push	DWORD PTR _values_offset$[ebp]
	push	DWORD PTR _values_count$[ebp]
	push	DWORD PTR _data$[ebp]
	push	DWORD PTR _values_getter$[ebp]
	push	DWORD PTR _label$[ebp]
	push	1
	call	?PlotEx@ImGui@@YAXW4ImGuiPlotType@@PBDP6AMPAXH@Z2HH1MMUImVec2@@@Z ; ImGui::PlotEx
	add	esp, 44					; 0000002cH

; 8272 : }

	pop	ebp
	ret	0
?PlotHistogram@ImGui@@YAXPBDP6AMPAXH@Z1HH0MMUImVec2@@@Z ENDP ; ImGui::PlotHistogram
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_data$ = -8						; size = 8
_label$ = 8						; size = 4
_values$ = 12						; size = 4
_values_count$ = 16					; size = 4
_values_offset$ = 20					; size = 4
_overlay_text$ = 24					; size = 4
_scale_min$ = 28					; size = 4
_scale_max$ = 32					; size = 4
_graph_size$ = 36					; size = 8
_stride$ = 44						; size = 4
?PlotHistogram@ImGui@@YAXPBDPBMHH0MMUImVec2@@H@Z PROC	; ImGui::PlotHistogram

; 8264 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 8265 :     ImGuiPlotArrayGetterData data(values, stride);
; 8266 :     PlotEx(ImGuiPlotType_Histogram, label, &Plot_ArrayGetter, (void*)&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);

	push	DWORD PTR _graph_size$[ebp+4]
	movss	xmm0, DWORD PTR _scale_max$[ebp]
	push	DWORD PTR _graph_size$[ebp]

; 8242 :     ImGuiPlotArrayGetterData(const float* values, int stride) { Values = values; Stride = stride; }

	mov	eax, DWORD PTR _values$[ebp]

; 8265 :     ImGuiPlotArrayGetterData data(values, stride);
; 8266 :     PlotEx(ImGuiPlotType_Histogram, label, &Plot_ArrayGetter, (void*)&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);

	sub	esp, 8

; 8242 :     ImGuiPlotArrayGetterData(const float* values, int stride) { Values = values; Stride = stride; }

	mov	DWORD PTR _data$[ebp], eax
	mov	eax, DWORD PTR _stride$[ebp]
	mov	DWORD PTR _data$[ebp+4], eax

; 8265 :     ImGuiPlotArrayGetterData data(values, stride);
; 8266 :     PlotEx(ImGuiPlotType_Histogram, label, &Plot_ArrayGetter, (void*)&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);

	lea	eax, DWORD PTR _data$[ebp]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _scale_min$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _overlay_text$[ebp]
	push	DWORD PTR _values_offset$[ebp]
	push	DWORD PTR _values_count$[ebp]
	push	eax
	push	OFFSET ?Plot_ArrayGetter@@YAMPAXH@Z	; Plot_ArrayGetter
	push	DWORD PTR _label$[ebp]
	push	1
	call	?PlotEx@ImGui@@YAXW4ImGuiPlotType@@PBDP6AMPAXH@Z2HH1MMUImVec2@@@Z ; ImGui::PlotEx
	add	esp, 44					; 0000002cH

; 8267 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PlotHistogram@ImGui@@YAXPBDPBMHH0MMUImVec2@@H@Z ENDP	; ImGui::PlotHistogram
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_data$ = -8						; size = 8
_label$ = 8						; size = 4
_values$ = 12						; size = 4
_values_count$ = 16					; size = 4
_values_offset$ = 20					; size = 4
_overlay_text$ = 24					; size = 4
_scale_min$ = 28					; size = 4
_scale_max$ = 32					; size = 4
_graph_size$ = 36					; size = 8
_stride$ = 44						; size = 4
_saturation$ = 48					; size = 4
_value$ = 52						; size = 4
_avg$ = 56						; size = 4
_inverse$ = 60						; size = 1
?PlotLinesC@ImGui@@YAXPBDPBMHH0MMUImVec2@@HMMM_N@Z PROC	; ImGui::PlotLinesC

; 12664: {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 12665:   ImGuiPlotArrayGetterData data =
; 12666:     ImGuiPlotArrayGetterData (values, stride);
; 12667: 
; 12668:   PlotCEx ( ImGuiPlotType_Lines, label,        &Plot_ArrayGetter,

	push	DWORD PTR _inverse$[ebp]
	movss	xmm0, DWORD PTR _avg$[ebp]
	sub	esp, 12					; 0000000cH

; 8242 :     ImGuiPlotArrayGetterData(const float* values, int stride) { Values = values; Stride = stride; }

	mov	eax, DWORD PTR _values$[ebp]
	mov	DWORD PTR _data$[ebp], eax
	mov	eax, DWORD PTR _stride$[ebp]
	mov	DWORD PTR _data$[ebp+4], eax

; 12665:   ImGuiPlotArrayGetterData data =
; 12666:     ImGuiPlotArrayGetterData (values, stride);
; 12667: 
; 12668:   PlotCEx ( ImGuiPlotType_Lines, label,        &Plot_ArrayGetter,

	lea	eax, DWORD PTR _data$[ebp]
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _value$[ebp]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _saturation$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _graph_size$[ebp+4]
	movss	xmm0, DWORD PTR _scale_max$[ebp]
	push	DWORD PTR _graph_size$[ebp]
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _scale_min$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _overlay_text$[ebp]
	push	DWORD PTR _values_offset$[ebp]
	push	DWORD PTR _values_count$[ebp]
	push	eax
	push	OFFSET ?Plot_ArrayGetter@@YAMPAXH@Z	; Plot_ArrayGetter
	push	DWORD PTR _label$[ebp]
	push	0
	call	?PlotCEx@ImGui@@YAXW4ImGuiPlotType@@PBDP6AMPAXH@Z2HH1MMUImVec2@@MMM_N@Z ; ImGui::PlotCEx
	add	esp, 60					; 0000003cH

; 12669:               reinterpret_cast <void *>(&data), values_count,
; 12670:                                                 values_offset,
; 12671:                 overlay_text,   scale_min, scale_max,
; 12672:                   graph_size,
; 12673:                     saturation, value,     avg,
; 12674:                       inverse
; 12675:           );
; 12676: }

	mov	esp, ebp
	pop	ebp
	ret	0
?PlotLinesC@ImGui@@YAXPBDPBMHH0MMUImVec2@@HMMM_N@Z ENDP	; ImGui::PlotLinesC
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_values_getter$ = 12					; size = 4
_data$ = 16						; size = 4
_values_count$ = 20					; size = 4
_values_offset$ = 24					; size = 4
_overlay_text$ = 28					; size = 4
_scale_min$ = 32					; size = 4
_scale_max$ = 36					; size = 4
_graph_size$ = 40					; size = 8
?PlotLines@ImGui@@YAXPBDP6AMPAXH@Z1HH0MMUImVec2@@@Z PROC ; ImGui::PlotLines

; 8259 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 8260 :     PlotEx(ImGuiPlotType_Lines, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);

	push	DWORD PTR _graph_size$[ebp+4]
	movss	xmm0, DWORD PTR _scale_max$[ebp]
	push	DWORD PTR _graph_size$[ebp]
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _scale_min$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _overlay_text$[ebp]
	push	DWORD PTR _values_offset$[ebp]
	push	DWORD PTR _values_count$[ebp]
	push	DWORD PTR _data$[ebp]
	push	DWORD PTR _values_getter$[ebp]
	push	DWORD PTR _label$[ebp]
	push	0
	call	?PlotEx@ImGui@@YAXW4ImGuiPlotType@@PBDP6AMPAXH@Z2HH1MMUImVec2@@@Z ; ImGui::PlotEx
	add	esp, 44					; 0000002cH

; 8261 : }

	pop	ebp
	ret	0
?PlotLines@ImGui@@YAXPBDP6AMPAXH@Z1HH0MMUImVec2@@@Z ENDP ; ImGui::PlotLines
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_data$ = -8						; size = 8
_label$ = 8						; size = 4
_values$ = 12						; size = 4
_values_count$ = 16					; size = 4
_values_offset$ = 20					; size = 4
_overlay_text$ = 24					; size = 4
_scale_min$ = 28					; size = 4
_scale_max$ = 32					; size = 4
_graph_size$ = 36					; size = 8
_stride$ = 44						; size = 4
?PlotLines@ImGui@@YAXPBDPBMHH0MMUImVec2@@H@Z PROC	; ImGui::PlotLines

; 8253 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 8254 :     ImGuiPlotArrayGetterData data(values, stride);
; 8255 :     PlotEx(ImGuiPlotType_Lines, label, &Plot_ArrayGetter, (void*)&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);

	push	DWORD PTR _graph_size$[ebp+4]
	movss	xmm0, DWORD PTR _scale_max$[ebp]
	push	DWORD PTR _graph_size$[ebp]

; 8242 :     ImGuiPlotArrayGetterData(const float* values, int stride) { Values = values; Stride = stride; }

	mov	eax, DWORD PTR _values$[ebp]

; 8254 :     ImGuiPlotArrayGetterData data(values, stride);
; 8255 :     PlotEx(ImGuiPlotType_Lines, label, &Plot_ArrayGetter, (void*)&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);

	sub	esp, 8

; 8242 :     ImGuiPlotArrayGetterData(const float* values, int stride) { Values = values; Stride = stride; }

	mov	DWORD PTR _data$[ebp], eax
	mov	eax, DWORD PTR _stride$[ebp]
	mov	DWORD PTR _data$[ebp+4], eax

; 8254 :     ImGuiPlotArrayGetterData data(values, stride);
; 8255 :     PlotEx(ImGuiPlotType_Lines, label, &Plot_ArrayGetter, (void*)&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);

	lea	eax, DWORD PTR _data$[ebp]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _scale_min$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _overlay_text$[ebp]
	push	DWORD PTR _values_offset$[ebp]
	push	DWORD PTR _values_count$[ebp]
	push	eax
	push	OFFSET ?Plot_ArrayGetter@@YAMPAXH@Z	; Plot_ArrayGetter
	push	DWORD PTR _label$[ebp]
	push	0
	call	?PlotEx@ImGui@@YAXW4ImGuiPlotType@@PBDP6AMPAXH@Z2HH1MMUImVec2@@@Z ; ImGui::PlotEx
	add	esp, 44					; 0000002cH

; 8256 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PlotLines@ImGui@@YAXPBDPBMHH0MMUImVec2@@H@Z ENDP	; ImGui::PlotLines
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_mode$ = 8						; size = 4
?ColorEditMode@ImGui@@YAXH@Z PROC			; ImGui::ColorEditMode

; 10228: {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10230:     window->DC.ColorEditMode = mode;

	mov	ecx, DWORD PTR [ecx+6240]
	mov	eax, DWORD PTR _mode$[ebp]
	mov	DWORD PTR [ecx+372], eax

; 10231: }

	pop	ebp
	ret	0
?ColorEditMode@ImGui@@YAXH@Z ENDP			; ImGui::ColorEditMode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_buf$1 = -144						; size = 64
_fmt_table$2 = -128					; size = 48
_col_display$ = -80					; size = 16
_ids$3 = -80						; size = 16
_window$1$ = -64					; size = 4
$T4 = -60						; size = 8
_w_slider_all$1$ = -56					; size = 4
_g$1$ = -56						; size = 4
_label_display_end$1$ = -52				; size = 4
_id$1$ = -52						; size = 4
_w_item_last$1$ = -48					; size = 4
_square_sz$1$ = -48					; size = 4
_i$ = -44						; size = 16
_f$ = -28						; size = 16
_button_titles$5 = -24					; size = 12
$T6 = -20						; size = 8
_w_item_one$1$ = -12					; size = 4
_fmt$1$ = -12						; size = 4
_w_full$ = -12						; size = 4
_edit_mode$1$ = -8					; size = 4
_value_changed$1$ = -1					; size = 1
_label$ = 8						; size = 4
_col$ = 12						; size = 4
_alpha$ = 16						; size = 1
?ColorEdit4@ImGui@@YA_NPBDQAM_N@Z PROC			; ImGui::ColorEdit4

; 10093: {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	ebx
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	ebx, DWORD PTR [ecx+6240]
	mov	DWORD PTR _window$1$[ebp], ebx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10095:     if (window->SkipItems)

	cmp	BYTE PTR [ebx+137], 0
	je	SHORT $LN12@ColorEdit4

; 10096:         return false;

	xor	al, al
	pop	ebx

; 10225: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@ColorEdit4:
	push	esi
	push	edi

; 10097: 
; 10098:     ImGuiContext& g = *GImGui;

	mov	edi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 10099:     const ImGuiStyle& style = g.Style;
; 10100:     const ImGuiID id = window->GetID(label);

	mov	ecx, ebx
	push	0
	push	DWORD PTR _label$[ebp]
	mov	DWORD PTR _g$1$[ebp], edi
	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID
	mov	esi, eax
	mov	DWORD PTR _id$1$[ebp], esi

; 10101:     const float w_full = CalcItemWidth();

	call	?CalcItemWidth@ImGui@@YAMXZ		; ImGui::CalcItemWidth

; 10102:     const float square_sz = (g.FontSize + style.FramePadding.y * 2.0f);

	movss	xmm0, DWORD PTR [edi+5360]

; 10103: 
; 10104:     ImGuiColorEditMode edit_mode = window->DC.ColorEditMode;

	mov	eax, DWORD PTR [ebx+372]
	addss	xmm0, xmm0
	mov	DWORD PTR _edit_mode$1$[ebp], eax

; 10105:     if (edit_mode == ImGuiColorEditMode_UserSelect || edit_mode == ImGuiColorEditMode_UserSelectShowButton)

	mov	ebx, 3
	fstp	DWORD PTR _w_full$[ebp]
	addss	xmm0, DWORD PTR [edi+6172]
	movss	DWORD PTR _square_sz$1$[ebp], xmm0
	cmp	eax, -2					; fffffffeH
	je	SHORT $LN14@ColorEdit4
	cmp	eax, -1
	jne	SHORT $LN13@ColorEdit4
$LN14@ColorEdit4:

; 10106:         edit_mode = g.ColorEditModeStorage.GetInt(id, 0) % 3;

	push	0
	push	esi
	lea	ecx, DWORD PTR [edi+10504]
	call	?GetInt@ImGuiStorage@@QBEHIH@Z		; ImGuiStorage::GetInt
	cdq
	idiv	ebx
	mov	eax, edx
	mov	DWORD PTR _edit_mode$1$[ebp], edx
$LN13@ColorEdit4:

; 10107: 
; 10108:     float f[4] = { col[0], col[1], col[2], col[3] };

	mov	esi, DWORD PTR _col$[ebp]
	movss	xmm0, DWORD PTR [esi]
	movss	xmm1, DWORD PTR [esi+4]
	movss	xmm2, DWORD PTR [esi+8]
	movss	xmm3, DWORD PTR [esi+12]
	movss	DWORD PTR _f$[ebp], xmm0
	movss	DWORD PTR _f$[ebp+4], xmm1
	movss	DWORD PTR _f$[ebp+8], xmm2
	movss	DWORD PTR _f$[ebp+12], xmm3

; 10109:     if (edit_mode == ImGuiColorEditMode_HSV)

	cmp	eax, 1
	jne	SHORT $LN15@ColorEdit4

; 10110:         ColorConvertRGBtoHSV(f[0], f[1], f[2], f[0], f[1], f[2]);

	lea	eax, DWORD PTR _f$[ebp+8]
	push	eax
	lea	eax, DWORD PTR _f$[ebp+4]
	push	eax
	lea	eax, DWORD PTR _f$[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	movss	DWORD PTR [esp+8], xmm2
	movss	DWORD PTR [esp+4], xmm1
	movss	DWORD PTR [esp], xmm0
	call	?ColorConvertRGBtoHSV@ImGui@@YAXMMMAAM00@Z ; ImGui::ColorConvertRGBtoHSV
	movss	xmm3, DWORD PTR _f$[ebp+12]
	add	esp, 24					; 00000018H
	movss	xmm2, DWORD PTR _f$[ebp+8]
	movss	xmm1, DWORD PTR _f$[ebp+4]
	movss	xmm0, DWORD PTR _f$[ebp]
$LN15@ColorEdit4:

; 10111: 
; 10112:     int i[4] = { IM_F32_TO_INT8_UNBOUND(f[0]), IM_F32_TO_INT8_UNBOUND(f[1]), IM_F32_TO_INT8_UNBOUND(f[2]), IM_F32_TO_INT8_UNBOUND(f[3]) };

	movss	xmm4, DWORD PTR __real@bf000000
	xorps	xmm5, xmm5
	comiss	xmm0, xmm5
	movss	xmm7, DWORD PTR __real@3f000000
	jb	SHORT $LN35@ColorEdit4
	movaps	xmm6, xmm7
	jmp	SHORT $LN36@ColorEdit4
$LN35@ColorEdit4:
	movaps	xmm6, xmm4
$LN36@ColorEdit4:
	comiss	xmm1, xmm5
	mulss	xmm0, DWORD PTR __real@437f0000
	addss	xmm0, xmm6
	cvttss2si eax, xmm0
	mov	DWORD PTR _i$[ebp], eax
	jb	SHORT $LN37@ColorEdit4
	movaps	xmm0, xmm7
	jmp	SHORT $LN38@ColorEdit4
$LN37@ColorEdit4:
	movaps	xmm0, xmm4
$LN38@ColorEdit4:
	comiss	xmm2, xmm5
	movss	xmm6, DWORD PTR __real@437f0000
	mulss	xmm1, xmm6
	addss	xmm1, xmm0
	cvttss2si eax, xmm1
	mov	DWORD PTR _i$[ebp+4], eax
	jb	SHORT $LN39@ColorEdit4
	movaps	xmm0, xmm7
	jmp	SHORT $LN40@ColorEdit4
$LN39@ColorEdit4:
	movaps	xmm0, xmm4
$LN40@ColorEdit4:
	comiss	xmm3, xmm5
	mulss	xmm2, xmm6
	addss	xmm2, xmm0
	cvttss2si eax, xmm2
	mov	DWORD PTR _i$[ebp+8], eax
	jb	SHORT $LN41@ColorEdit4
	movaps	xmm4, xmm7
$LN41@ColorEdit4:
	mulss	xmm3, xmm6

; 10113: 
; 10114:     int components = alpha ? 4 : 3;

	xor	ebx, ebx
	cmp	BYTE PTR _alpha$[ebp], bl

; 10115:     bool value_changed = false;

	mov	BYTE PTR _value_changed$1$[ebp], 0
	setne	bl
	addss	xmm3, xmm4
	add	ebx, 3
	cvttss2si eax, xmm3
	mov	DWORD PTR _i$[ebp+12], eax

; 10116: 
; 10117:     BeginGroup();

	call	?BeginGroup@ImGui@@YAXXZ		; ImGui::BeginGroup

; 10118:     PushID(label);

	mov	ecx, DWORD PTR _label$[ebp]
	push	ecx
	call	?PushID@ImGui@@YAXPBD@Z			; ImGui::PushID

; 10119: 
; 10120:     const bool hsv = (edit_mode == 1);
; 10121:     switch (edit_mode)

	mov	eax, DWORD PTR _edit_mode$1$[ebp]
	add	esp, 4
	movss	xmm5, DWORD PTR __real@3f800000
	test	eax, eax
	js	$LN125@ColorEdit4
	cmp	eax, 1
	jle	$LN16@ColorEdit4
	mov	ebx, eax
	cmp	ebx, 2
	jne	$LN2@ColorEdit4

; 10152:         }
; 10153:         break;
; 10154:     case ImGuiColorEditMode_HEX:
; 10155:         {
; 10156:             // RGB Hexadecimal Input
; 10157:             const float w_slider_all = w_full - square_sz;
; 10158:             char buf[64];
; 10159:             if (alpha)

	cmp	BYTE PTR _alpha$[ebp], 0

; 10160:                 ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X%02X", i[0], i[1], i[2], i[3]);

	lea	eax, DWORD PTR _buf$1[ebp]
	movss	xmm0, DWORD PTR _w_full$[ebp]
	subss	xmm0, DWORD PTR _square_sz$1$[ebp]
	movss	DWORD PTR _w_slider_all$1$[ebp], xmm0
	je	SHORT $LN20@ColorEdit4
	push	DWORD PTR _i$[ebp+12]
	push	DWORD PTR _i$[ebp+8]
	push	DWORD PTR _i$[ebp+4]
	push	DWORD PTR _i$[ebp]
	push	OFFSET $SG122327
	push	64					; 00000040H
	push	eax
	call	?ImFormatString@@YAHPADHPBDZZ		; ImFormatString
	add	esp, 28					; 0000001cH

; 10161:             else

	jmp	SHORT $LN21@ColorEdit4
$LN20@ColorEdit4:

; 10162:                 ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X", i[0], i[1], i[2]);

	push	DWORD PTR _i$[ebp+8]
	push	DWORD PTR _i$[ebp+4]
	push	DWORD PTR _i$[ebp]
	push	OFFSET $SG122328
	push	64					; 00000040H
	push	eax
	call	?ImFormatString@@YAHPADHPBDZZ		; ImFormatString
	add	esp, 24					; 00000018H
$LN21@ColorEdit4:

; 10163:             PushItemWidth(w_slider_all - style.ItemInnerSpacing.x);

	movss	xmm0, DWORD PTR _w_slider_all$1$[ebp]
	subss	xmm0, DWORD PTR [edi+5376]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth

; 10164:             if (InputText("##Text", buf, IM_ARRAYSIZE(buf), ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase))

	push	0
	push	0
	push	6
	push	64					; 00000040H
	lea	eax, DWORD PTR _buf$1[ebp]
	push	eax
	push	OFFSET $SG122330
	call	?InputText@ImGui@@YA_NPBDPADIHP6AHPAUImGuiTextEditCallbackData@@@ZPAX@Z ; ImGui::InputText
	add	esp, 28					; 0000001cH
	test	al, al
	je	$LN25@ColorEdit4

; 10165:             {
; 10166:                 value_changed |= true;

	mov	BYTE PTR _value_changed$1$[ebp], 1

; 10167:                 char* p = buf;

	lea	ecx, DWORD PTR _buf$1[ebp]
$LL7@ColorEdit4:

; 10168:                 while (*p == '#' || ImCharIsSpace(*p))

	mov	al, BYTE PTR [ecx]
	cmp	al, 35					; 00000023H
	je	SHORT $LN61@ColorEdit4
	movsx	eax, al
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 96   : static inline bool      ImCharIsSpace(int c)            { return c == ' ' || c == '\t' || c == 0x3000; }

	cmp	eax, 32					; 00000020H
	je	SHORT $LN61@ColorEdit4
	cmp	eax, 9
	je	SHORT $LN61@ColorEdit4
	cmp	eax, 12288				; 00003000H
	jne	SHORT $LN124@ColorEdit4
$LN61@ColorEdit4:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10169:                     p++;

	inc	ecx
	jmp	SHORT $LL7@ColorEdit4
$LN124@ColorEdit4:

; 10170:                 i[0] = i[1] = i[2] = i[3] = 0;
; 10171:                 if (alpha)

	cmp	BYTE PTR _alpha$[ebp], 0
	mov	DWORD PTR _i$[ebp+12], 0
	mov	DWORD PTR _i$[ebp+8], 0
	mov	DWORD PTR _i$[ebp+4], 0
	mov	DWORD PTR _i$[ebp], 0
	je	SHORT $LN24@ColorEdit4

; 10172:                     sscanf(p, "%02X%02X%02X%02X", (unsigned int*)&i[0], (unsigned int*)&i[1], (unsigned int*)&i[2], (unsigned int*)&i[3]); // Treat at unsigned (%X is unsigned)

	lea	eax, DWORD PTR _i$[ebp+12]
	push	eax
	lea	eax, DWORD PTR _i$[ebp+8]
	push	eax
	lea	eax, DWORD PTR _i$[ebp+4]
	push	eax
	lea	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET $SG122334
	push	ecx
	call	_sscanf
	add	esp, 24					; 00000018H

; 10175:             }
; 10176:             PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth
	jmp	$LN2@ColorEdit4
$LN24@ColorEdit4:

; 10173:                 else
; 10174:                     sscanf(p, "%02X%02X%02X", (unsigned int*)&i[0], (unsigned int*)&i[1], (unsigned int*)&i[2]);

	lea	eax, DWORD PTR _i$[ebp+8]
	push	eax
	lea	eax, DWORD PTR _i$[ebp+4]
	push	eax
	lea	eax, DWORD PTR _i$[ebp]
	push	eax
	push	OFFSET $SG122335
	push	ecx
	call	_sscanf
	add	esp, 20					; 00000014H
$LN25@ColorEdit4:

; 10175:             }
; 10176:             PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth
	jmp	$LN2@ColorEdit4
$LN16@ColorEdit4:

; 10122:     {
; 10123:     case ImGuiColorEditMode_RGB:
; 10124:     case ImGuiColorEditMode_HSV:
; 10125:         {
; 10126:             // RGB/HSV 0..255 Sliders
; 10127:             const float w_items_all = w_full - (square_sz + style.ItemInnerSpacing.x);

	movss	xmm4, DWORD PTR [edi+5376]

; 10128:             const float w_item_one  = ImMax(1.0f, (float)(int)((w_items_all - (style.ItemInnerSpacing.x) * (components-1)) / (float)components));

	lea	eax, DWORD PTR [ebx-1]
	movss	xmm3, DWORD PTR _w_full$[ebp]
	movaps	xmm0, xmm4
	addss	xmm0, DWORD PTR _square_sz$1$[ebp]
	movd	xmm2, eax
	cvtdq2ps xmm2, xmm2

; 10129:             const float w_item_last = ImMax(1.0f, (float)(int)(w_items_all - (w_item_one + style.ItemInnerSpacing.x) * (components-1)));
; 10130: 
; 10131:             const bool hide_prefix = (w_item_one <= CalcTextSize("M:999").x);

	push	ecx
	mov	DWORD PTR [esp], -1082130432		; bf800000H

; 10132:             const char* ids[4] = { "##X", "##Y", "##Z", "##W" };

	mov	DWORD PTR _ids$3[ebp], OFFSET $SG122306
	mov	DWORD PTR _ids$3[ebp+4], OFFSET $SG122307
	subss	xmm3, xmm0
	mov	DWORD PTR _ids$3[ebp+8], OFFSET $SG122308
	movaps	xmm0, xmm2
	mov	DWORD PTR _ids$3[ebp+12], OFFSET $SG122309
	mulss	xmm0, xmm4
	push	0
	push	0
	movaps	xmm1, xmm3

; 10133:             const char* fmt_table[3][4] =
; 10134:             {
; 10135:                 {   "%3.0f",   "%3.0f",   "%3.0f",   "%3.0f" },

	mov	DWORD PTR _fmt_table$2[ebp], OFFSET $SG122310
	subss	xmm1, xmm0
	mov	DWORD PTR _fmt_table$2[ebp+4], OFFSET $SG122311
	movd	xmm0, ebx
	cvtdq2ps xmm0, xmm0
	push	OFFSET $SG122305
	mov	DWORD PTR _fmt_table$2[ebp+8], OFFSET $SG122312
	mov	DWORD PTR _fmt_table$2[ebp+12], OFFSET $SG122313

; 10136:                 { "R:%3.0f", "G:%3.0f", "B:%3.0f", "A:%3.0f" },

	mov	DWORD PTR _fmt_table$2[ebp+16], OFFSET $SG122314
	mov	DWORD PTR _fmt_table$2[ebp+20], OFFSET $SG122315
	divss	xmm1, xmm0
	mov	DWORD PTR _fmt_table$2[ebp+24], OFFSET $SG122316
	mov	DWORD PTR _fmt_table$2[ebp+28], OFFSET $SG122317

; 10137:                 { "H:%3.0f", "S:%3.0f", "V:%3.0f", "A:%3.0f" }

	mov	DWORD PTR _fmt_table$2[ebp+32], OFFSET $SG122318
	mov	DWORD PTR _fmt_table$2[ebp+36], OFFSET $SG122319
	mov	DWORD PTR _fmt_table$2[ebp+40], OFFSET $SG122320
	mov	DWORD PTR _fmt_table$2[ebp+44], OFFSET $SG122321
	cvttss2si eax, xmm1
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	maxss	xmm0, xmm5
	addss	xmm4, xmm0
	movss	DWORD PTR _w_item_one$1$[ebp], xmm0
	mulss	xmm4, xmm2
	subss	xmm3, xmm4
	cvttss2si eax, xmm3
	movd	xmm0, eax
	lea	eax, DWORD PTR $T6[ebp]
	cvtdq2ps xmm0, xmm0
	push	eax
	maxss	xmm0, xmm5
	movss	DWORD PTR _w_item_last$1$[ebp], xmm0
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
	movss	xmm1, DWORD PTR _w_item_one$1$[ebp]
	add	esp, 20					; 00000014H
	movss	xmm0, DWORD PTR [eax]
	comiss	xmm0, xmm1

; 10138:             };
; 10139:             const char** fmt = hide_prefix ? fmt_table[0] : hsv ? fmt_table[2] : fmt_table[1];

	jb	SHORT $LN45@ColorEdit4
	lea	edi, DWORD PTR _fmt_table$2[ebp]
	jmp	SHORT $LN43@ColorEdit4
$LN45@ColorEdit4:
	cmp	DWORD PTR _edit_mode$1$[ebp], 1
	lea	edi, DWORD PTR _fmt_table$2[ebp+32]
	lea	eax, DWORD PTR _fmt_table$2[ebp+16]
	cmovne	edi, eax
$LN43@ColorEdit4:

; 10140: 
; 10141:             PushItemWidth(w_item_one);

	push	ecx
	movss	DWORD PTR [esp], xmm1
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth

; 10142:             for (int n = 0; n < components; n++)

	lea	eax, DWORD PTR _i$[ebp]
	add	esp, 4
	xor	esi, esi
	sub	edi, eax
	mov	DWORD PTR _fmt$1$[ebp], edi
$LL6@ColorEdit4:

; 10143:             {
; 10144:                 if (n > 0)

	test	esi, esi
	jle	SHORT $LN17@ColorEdit4

; 10145:                     SameLine(0, style.ItemInnerSpacing.x);

	mov	eax, DWORD PTR _g$1$[ebp]
	sub	esp, 8
	movss	xmm0, DWORD PTR [eax+5376]
	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	add	esp, 8
$LN17@ColorEdit4:

; 10146:                 if (n + 1 == components)

	lea	edi, DWORD PTR [esi+1]
	cmp	edi, ebx
	jne	SHORT $LN18@ColorEdit4

; 10147:                     PushItemWidth(w_item_last);

	movss	xmm0, DWORD PTR _w_item_last$1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth
	add	esp, 4
$LN18@ColorEdit4:

; 10148:                 value_changed |= DragInt(ids[n], &i[n], 1.0f, 0, 255, fmt[n]);

	mov	ecx, DWORD PTR _fmt$1$[ebp]
	lea	eax, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [eax+esi*4]
	push	DWORD PTR [eax+ecx]
	push	255					; 000000ffH
	push	0
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	eax
	push	DWORD PTR _ids$3[ebp+esi*4]
	call	?DragInt@ImGui@@YA_NPBDPAHMHH0@Z	; ImGui::DragInt
	or	BYTE PTR _value_changed$1$[ebp], al
	mov	esi, edi
	add	esp, 24					; 00000018H
	cmp	esi, ebx
	jl	SHORT $LL6@ColorEdit4

; 10149:             }
; 10150:             PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 10151:             PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth
	mov	esi, DWORD PTR _col$[ebp]
	mov	edi, DWORD PTR _g$1$[ebp]
$LN125@ColorEdit4:
	mov	ebx, DWORD PTR _edit_mode$1$[ebp]
$LN2@ColorEdit4:

; 10177:         }
; 10178:         break;
; 10179:     }
; 10180: 
; 10181:     SameLine(0, style.ItemInnerSpacing.x);

	movss	xmm0, DWORD PTR [edi+5376]
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 109  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

	movss	xmm0, DWORD PTR [esi]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10184:     if (ColorButton(col_display))

	lea	eax, DWORD PTR _col_display$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 109  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

	movss	DWORD PTR _col_display$[ebp], xmm0
	movss	xmm0, DWORD PTR [esi+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10184:     if (ColorButton(col_display))

	push	1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 109  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

	movss	DWORD PTR _col_display$[ebp+4], xmm0
	movss	xmm0, DWORD PTR [esi+8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10184:     if (ColorButton(col_display))

	push	0
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 109  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

	movss	DWORD PTR _col_display$[ebp+8], xmm0
	mov	DWORD PTR _col_display$[ebp+12], 1065353216 ; 3f800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10184:     if (ColorButton(col_display))

	call	?ColorButton@ImGui@@YA_NABUImVec4@@_N1@Z ; ImGui::ColorButton
	add	esp, 20					; 00000014H
	test	al, al
	je	SHORT $LN26@ColorEdit4

; 10185:         g.ColorEditModeStorage.SetInt(id, (edit_mode + 1) % 3); // Don't set local copy of 'edit_mode' right away!

	lea	eax, DWORD PTR [ebx+1]
	mov	ecx, 3
	cdq
	idiv	ecx
	lea	ecx, DWORD PTR [edi+10504]
	push	edx
	push	DWORD PTR _id$1$[ebp]
	call	?SetInt@ImGuiStorage@@QAEXIH@Z		; ImGuiStorage::SetInt
$LN26@ColorEdit4:

; 10186: 
; 10187:     // Recreate our own tooltip over's ColorButton() one because we want to display correct alpha here
; 10188:     if (IsItemHovered())

	call	?IsItemHovered@ImGui@@YA_NXZ		; ImGui::IsItemHovered
	test	al, al
	je	$LN27@ColorEdit4

; 10189:         SetTooltip("Color:\n(%.2f,%.2f,%.2f,%.2f)\n#%02X%02X%02X%02X", col[0], col[1], col[2], col[3], IM_F32_TO_INT8_SAT(col[0]), IM_F32_TO_INT8_SAT(col[1]), IM_F32_TO_INT8_SAT(col[2]), IM_F32_TO_INT8_SAT(col[3]));

	movss	xmm7, DWORD PTR [esi+12]
	xorps	xmm0, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 134  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm0, xmm7
	movss	xmm4, DWORD PTR __real@3f800000
	jbe	SHORT $LN69@ColorEdit4
	xorps	xmm3, xmm3
	jmp	SHORT $LN68@ColorEdit4
$LN69@ColorEdit4:
	movaps	xmm3, xmm7
	minss	xmm3, xmm4
$LN68@ColorEdit4:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10189:         SetTooltip("Color:\n(%.2f,%.2f,%.2f,%.2f)\n#%02X%02X%02X%02X", col[0], col[1], col[2], col[3], IM_F32_TO_INT8_SAT(col[0]), IM_F32_TO_INT8_SAT(col[1]), IM_F32_TO_INT8_SAT(col[2]), IM_F32_TO_INT8_SAT(col[3]));

	movss	xmm6, DWORD PTR [esi+8]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 134  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm0, xmm6
	jbe	SHORT $LN75@ColorEdit4
	xorps	xmm2, xmm2
	jmp	SHORT $LN74@ColorEdit4
$LN75@ColorEdit4:
	movaps	xmm2, xmm6
	minss	xmm2, xmm4
$LN74@ColorEdit4:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10189:         SetTooltip("Color:\n(%.2f,%.2f,%.2f,%.2f)\n#%02X%02X%02X%02X", col[0], col[1], col[2], col[3], IM_F32_TO_INT8_SAT(col[0]), IM_F32_TO_INT8_SAT(col[1]), IM_F32_TO_INT8_SAT(col[2]), IM_F32_TO_INT8_SAT(col[3]));

	movss	xmm5, DWORD PTR [esi+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 134  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm0, xmm5
	jbe	SHORT $LN81@ColorEdit4
	xorps	xmm1, xmm1
	jmp	SHORT $LN80@ColorEdit4
$LN81@ColorEdit4:
	movaps	xmm1, xmm5
	minss	xmm1, xmm4
$LN80@ColorEdit4:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10189:         SetTooltip("Color:\n(%.2f,%.2f,%.2f,%.2f)\n#%02X%02X%02X%02X", col[0], col[1], col[2], col[3], IM_F32_TO_INT8_SAT(col[0]), IM_F32_TO_INT8_SAT(col[1]), IM_F32_TO_INT8_SAT(col[2]), IM_F32_TO_INT8_SAT(col[3]));

	movss	xmm4, DWORD PTR [esi]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 134  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm0, xmm4
	ja	SHORT $LN86@ColorEdit4
	movaps	xmm0, xmm4
	minss	xmm0, DWORD PTR __real@3f800000
$LN86@ColorEdit4:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10189:         SetTooltip("Color:\n(%.2f,%.2f,%.2f,%.2f)\n#%02X%02X%02X%02X", col[0], col[1], col[2], col[3], IM_F32_TO_INT8_SAT(col[0]), IM_F32_TO_INT8_SAT(col[1]), IM_F32_TO_INT8_SAT(col[2]), IM_F32_TO_INT8_SAT(col[3]));

	mulss	xmm3, DWORD PTR __real@437f0000
	mulss	xmm2, DWORD PTR __real@437f0000
	addss	xmm3, DWORD PTR __real@3f000000
	mulss	xmm1, DWORD PTR __real@437f0000
	mulss	xmm0, DWORD PTR __real@437f0000
	cvttss2si eax, xmm3
	movss	xmm3, DWORD PTR __real@3f000000
	push	eax
	addss	xmm2, xmm3
	addss	xmm1, xmm3
	addss	xmm0, xmm3
	cvttss2si eax, xmm2
	push	eax
	cvttss2si eax, xmm1
	push	eax
	cvttss2si eax, xmm0
	cvtps2pd xmm0, xmm7
	push	eax
	sub	esp, 32					; 00000020H
	movsd	QWORD PTR [esp+24], xmm0
	cvtps2pd xmm0, xmm6
	movsd	QWORD PTR [esp+16], xmm0
	cvtps2pd xmm0, xmm5
	movsd	QWORD PTR [esp+8], xmm0
	cvtps2pd xmm0, xmm4
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG122338
	call	?SetTooltip@ImGui@@YAXPBDZZ		; ImGui::SetTooltip
	add	esp, 52					; 00000034H
$LN27@ColorEdit4:

; 10190: 
; 10191:     if (window->DC.ColorEditMode == ImGuiColorEditMode_UserSelectShowButton)

	mov	eax, DWORD PTR _window$1$[ebp]
	cmp	DWORD PTR [eax+372], -1
	jne	SHORT $LN29@ColorEdit4

; 10192:     {
; 10193:         SameLine(0, style.ItemInnerSpacing.x);

	movss	xmm0, DWORD PTR [edi+5376]
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 10195:         if (ButtonEx(button_titles[edit_mode], ImVec2(0,0), ImGuiButtonFlags_DontClosePopups))

	push	64					; 00000040H
	lea	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR _button_titles$5[ebp], OFFSET $SG122340
	push	eax
	mov	DWORD PTR _button_titles$5[ebp+4], OFFSET $SG122341
	mov	DWORD PTR _button_titles$5[ebp+8], OFFSET $SG122342
	push	DWORD PTR _button_titles$5[ebp+ebx*4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T4[ebp], 0
	mov	DWORD PTR $T4[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10195:         if (ButtonEx(button_titles[edit_mode], ImVec2(0,0), ImGuiButtonFlags_DontClosePopups))

	call	?ButtonEx@ImGui@@YA_NPBDABUImVec2@@H@Z	; ImGui::ButtonEx
	add	esp, 20					; 00000014H
	test	al, al
	je	SHORT $LN29@ColorEdit4

; 10196:             g.ColorEditModeStorage.SetInt(id, (edit_mode + 1) % 3); // Don't set local copy of 'edit_mode' right away!

	lea	eax, DWORD PTR [ebx+1]
	mov	ecx, 3
	cdq
	idiv	ecx
	lea	ecx, DWORD PTR [edi+10504]
	push	edx
	push	DWORD PTR _id$1$[ebp]
	call	?SetInt@ImGuiStorage@@QAEXIH@Z		; ImGuiStorage::SetInt
$LN29@ColorEdit4:

; 10197:     }
; 10198: 
; 10199:     const char* label_display_end = FindRenderedTextEnd(label);

	push	0
	push	DWORD PTR _label$[ebp]
	call	?FindRenderedTextEnd@ImGui@@YAPBDPBD0@Z	; ImGui::FindRenderedTextEnd
	add	esp, 8
	mov	DWORD PTR _label_display_end$1$[ebp], eax

; 10200:     if (label != label_display_end)

	cmp	DWORD PTR _label$[ebp], eax
	je	SHORT $LN30@ColorEdit4

; 10201:     {
; 10202:         SameLine(0, (window->DC.ColorEditMode == ImGuiColorEditMode_UserSelectShowButton) ? -1.0f : style.ItemInnerSpacing.x);

	mov	eax, DWORD PTR _window$1$[ebp]
	cmp	DWORD PTR [eax+372], -1
	jne	SHORT $LN47@ColorEdit4
	movss	xmm0, DWORD PTR __real@bf800000
	jmp	SHORT $LN48@ColorEdit4
$LN47@ColorEdit4:
	movss	xmm0, DWORD PTR [edi+5376]
$LN48@ColorEdit4:
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine

; 10203:         TextUnformatted(label, label_display_end);

	push	DWORD PTR _label_display_end$1$[ebp]
	push	DWORD PTR _label$[ebp]
	call	?TextUnformatted@ImGui@@YAXPBD0@Z	; ImGui::TextUnformatted
	add	esp, 16					; 00000010H
$LN30@ColorEdit4:

; 10204:     }
; 10205: 
; 10206:     // Convert back
; 10207:     for (int n = 0; n < 4; n++)
; 10208:         f[n] = i[n] / 255.0f;

	movups	xmm0, XMMWORD PTR _i$[ebp]
	cvtdq2ps xmm0, xmm0
	mulps	xmm0, XMMWORD PTR __xmm@3b8080813b8080813b8080813b808081
	movups	XMMWORD PTR _f$[ebp], xmm0

; 10209:     if (edit_mode == 1)

	cmp	ebx, 1
	jne	SHORT $LN31@ColorEdit4

; 10210:         ColorConvertHSVtoRGB(f[0], f[1], f[2], f[0], f[1], f[2]);

	movss	xmm0, DWORD PTR _f$[ebp+8]
	lea	eax, DWORD PTR _f$[ebp+8]
	push	eax
	lea	eax, DWORD PTR _f$[ebp+4]
	push	eax
	lea	eax, DWORD PTR _f$[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	movss	DWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR _f$[ebp+4]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR _f$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?ColorConvertHSVtoRGB@ImGui@@YAXMMMAAM00@Z ; ImGui::ColorConvertHSVtoRGB
	add	esp, 24					; 00000018H
$LN31@ColorEdit4:

; 10211: 
; 10212:     if (value_changed)

	mov	bl, BYTE PTR _value_changed$1$[ebp]
	test	bl, bl
	je	SHORT $LN33@ColorEdit4

; 10213:     {
; 10214:         col[0] = f[0];
; 10215:         col[1] = f[1];
; 10216:         col[2] = f[2];
; 10217:         if (alpha)

	cmp	BYTE PTR _alpha$[ebp], 0
	movss	xmm0, DWORD PTR _f$[ebp]
	movss	DWORD PTR [esi], xmm0
	movss	xmm0, DWORD PTR _f$[ebp+4]
	movss	DWORD PTR [esi+4], xmm0
	movss	xmm0, DWORD PTR _f$[ebp+8]
	movss	DWORD PTR [esi+8], xmm0
	je	SHORT $LN33@ColorEdit4

; 10218:             col[3] = f[3];

	movss	xmm0, DWORD PTR _f$[ebp+12]
	movss	DWORD PTR [esi+12], xmm0
$LN33@ColorEdit4:

; 10219:     }
; 10220: 
; 10221:     PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 10222:     EndGroup();

	call	?EndGroup@ImGui@@YAXXZ			; ImGui::EndGroup
	pop	edi
	pop	esi

; 10223: 
; 10224:     return value_changed;

	mov	al, bl
	pop	ebx

; 10225: }

	mov	esp, ebp
	pop	ebp
	ret	0
?ColorEdit4@ImGui@@YA_NPBDQAM_N@Z ENDP			; ImGui::ColorEdit4
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_col4$ = -16						; size = 16
_label$ = 8						; size = 4
_col$ = 12						; size = 4
?ColorEdit3@ImGui@@YA_NPBDQAM@Z PROC			; ImGui::ColorEdit3

; 10077: {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi

; 10078:     float col4[4];
; 10079:     col4[0] = col[0];

	mov	esi, DWORD PTR _col$[ebp]

; 10080:     col4[1] = col[1];
; 10081:     col4[2] = col[2];
; 10082:     col4[3] = 1.0f;
; 10083:     const bool value_changed = ColorEdit4(label, col4, false);

	lea	eax, DWORD PTR _col4$[ebp]
	push	0
	push	eax
	push	DWORD PTR _label$[ebp]
	movss	xmm0, DWORD PTR [esi]
	movss	DWORD PTR _col4$[ebp], xmm0
	movss	xmm0, DWORD PTR [esi+4]
	movss	DWORD PTR _col4$[ebp+4], xmm0
	movss	xmm0, DWORD PTR [esi+8]
	movss	DWORD PTR _col4$[ebp+8], xmm0
	mov	DWORD PTR _col4$[ebp+12], 1065353216	; 3f800000H
	call	?ColorEdit4@ImGui@@YA_NPBDQAM_N@Z	; ImGui::ColorEdit4

; 10084:     col[0] = col4[0];

	movss	xmm0, DWORD PTR _col4$[ebp]
	add	esp, 12					; 0000000cH
	movss	DWORD PTR [esi], xmm0

; 10085:     col[1] = col4[1];

	movss	xmm0, DWORD PTR _col4$[ebp+4]
	movss	DWORD PTR [esi+4], xmm0

; 10086:     col[2] = col4[2];

	movss	xmm0, DWORD PTR _col4$[ebp+8]
	movss	DWORD PTR [esi+8], xmm0
	pop	esi

; 10087:     return value_changed;
; 10088: }

	mov	esp, ebp
	pop	ebp
	ret	0
?ColorEdit3@ImGui@@YA_NPBDQAM@Z ENDP			; ImGui::ColorEdit3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_bb$ = -32						; size = 16
$T2 = -16						; size = 8
_id$ = -8						; size = 4
_hovered$ = -2						; size = 1
_pressed$1$ = -1					; size = 1
_held$ = -1						; size = 1
_col$ = 8						; size = 4
_small_height$ = 12					; size = 1
_outline_border$ = 16					; size = 1
?ColorButton@ImGui@@YA_NABUImVec4@@_N1@Z PROC		; ImGui::ColorButton

; 10051: {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10051: {

	sub	esp, 32					; 00000020H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	push	esi
	mov	BYTE PTR [eax+134], 1
	mov	esi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10053:     if (window->SkipItems)

	cmp	BYTE PTR [esi+137], 0
	je	SHORT $LN2@ColorButto

; 10054:         return false;

	xor	al, al
	pop	esi

; 10074: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@ColorButto:
	push	ebx
	push	edi

; 10055: 
; 10056:     ImGuiContext& g = *GImGui;

	mov	edi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 10057:     const ImGuiStyle& style = g.Style;
; 10058:     const ImGuiID id = window->GetID("#colorbutton");

	mov	ecx, esi
	push	0
	push	OFFSET $SG122223
	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID

; 10060:     const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(square_size + style.FramePadding.y*2, square_size + (small_height ? 0 : style.FramePadding.y*2)));

	mov	cl, BYTE PTR _small_height$[ebp]
	mov	ebx, eax
	movss	xmm0, DWORD PTR [edi+6172]
	mov	DWORD PTR _id$[ebp], ebx
	test	cl, cl
	je	SHORT $LN6@ColorButto
	xorps	xmm3, xmm3
	jmp	SHORT $LN7@ColorButto
$LN6@ColorButto:
	movss	xmm3, DWORD PTR [edi+5360]
	addss	xmm3, xmm3
$LN7@ColorButto:
	movss	xmm4, DWORD PTR [edi+5360]
	addss	xmm3, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [esi+192]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10060:     const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(square_size + style.FramePadding.y*2, square_size + (small_height ? 0 : style.FramePadding.y*2)));

	movaps	xmm1, xmm4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _bb$[ebp], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10060:     const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(square_size + style.FramePadding.y*2, square_size + (small_height ? 0 : style.FramePadding.y*2)));

	addss	xmm1, xmm4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [esi+196]
	mov	DWORD PTR _bb$[ebp+4], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10060:     const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(square_size + style.FramePadding.y*2, square_size + (small_height ? 0 : style.FramePadding.y*2)));

	addss	xmm1, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [esi+192]
	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [esi+196]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T2[ebp]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm3

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _bb$[ebp+8], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T2[ebp+4]
	mov	DWORD PTR _bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10061:     ItemSize(bb, small_height ? 0.0f : style.FramePadding.y);

	test	cl, cl
	je	SHORT $LN8@ColorButto
	xorps	xmm4, xmm4
$LN8@ColorButto:
	push	ecx
	lea	eax, DWORD PTR _bb$[ebp]
	movss	DWORD PTR [esp], xmm4
	push	eax
	call	?ItemSize@ImGui@@YAXABUImRect@@M@Z	; ImGui::ItemSize

; 10062:     if (!ItemAdd(bb, &id))

	push	0
	lea	eax, DWORD PTR _id$[ebp]
	push	eax
	lea	eax, DWORD PTR _bb$[ebp]
	push	eax
	call	?ItemAdd@ImGui@@YA_NABUImRect@@PBIPBU2@@Z ; ImGui::ItemAdd
	add	esp, 20					; 00000014H
	test	al, al
	jne	SHORT $LN3@ColorButto
	pop	edi
	pop	ebx
	pop	esi

; 10074: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@ColorButto:

; 10063:         return false;
; 10064: 
; 10065:     bool hovered, held;
; 10066:     bool pressed = ButtonBehavior(bb, id, &hovered, &held);

	push	0
	lea	eax, DWORD PTR _held$[ebp]
	push	eax
	lea	eax, DWORD PTR _hovered$[ebp]
	push	eax
	lea	eax, DWORD PTR _bb$[ebp]
	push	ebx
	push	eax
	call	?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z ; ImGui::ButtonBehavior
	mov	BYTE PTR _pressed$1$[ebp], al

; 10067:     RenderNavHighlight(bb, id);

	lea	eax, DWORD PTR _bb$[ebp]
	push	ebx
	push	eax
	call	?RenderNavHighlight@ImGui@@YAXABUImRect@@I@Z ; ImGui::RenderNavHighlight

; 10068:     RenderFrame(bb.Min, bb.Max, GetColorU32(col), outline_border, style.FrameRounding);

	movss	xmm0, DWORD PTR [edi+5364]
	add	esp, 24					; 00000018H
	mov	esi, DWORD PTR _col$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	DWORD PTR _outline_border$[ebp]
	push	esi
	call	?GetColorU32@ImGui@@YAIABUImVec4@@@Z	; ImGui::GetColorU32
	add	esp, 4
	push	eax
	push	DWORD PTR _bb$[ebp+12]
	push	DWORD PTR _bb$[ebp+8]
	push	DWORD PTR _bb$[ebp+4]
	push	DWORD PTR _bb$[ebp]
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame
	add	esp, 28					; 0000001cH

; 10069: 
; 10070:     if (IsItemHovered()) // hovered?

	call	?IsItemHovered@ImGui@@YA_NXZ		; ImGui::IsItemHovered
	test	al, al
	je	$LN4@ColorButto

; 10071:         SetTooltip("Color:\n(%.2f,%.2f,%.2f,%.2f)\n#%02X%02X%02X%02X", col.x, col.y, col.z, col.w, IM_F32_TO_INT8_SAT(col.x), IM_F32_TO_INT8_SAT(col.y), IM_F32_TO_INT8_SAT(col.z), IM_F32_TO_INT8_SAT(col.w));

	movss	xmm6, DWORD PTR [esi+12]
	xorps	xmm2, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 134  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm2, xmm6
	movss	xmm1, DWORD PTR __real@3f800000
	jbe	SHORT $LN24@ColorButto
	xorps	xmm3, xmm3
	jmp	SHORT $LN25@ColorButto
$LN24@ColorButto:
	movaps	xmm3, xmm6
	minss	xmm3, xmm1
$LN25@ColorButto:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10071:         SetTooltip("Color:\n(%.2f,%.2f,%.2f,%.2f)\n#%02X%02X%02X%02X", col.x, col.y, col.z, col.w, IM_F32_TO_INT8_SAT(col.x), IM_F32_TO_INT8_SAT(col.y), IM_F32_TO_INT8_SAT(col.z), IM_F32_TO_INT8_SAT(col.w));

	movss	xmm7, DWORD PTR [esi+8]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 134  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm2, xmm7
	jbe	SHORT $LN30@ColorButto
	xorps	xmm4, xmm4
	jmp	SHORT $LN31@ColorButto
$LN30@ColorButto:
	movaps	xmm4, xmm7
	minss	xmm4, xmm1
$LN31@ColorButto:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10071:         SetTooltip("Color:\n(%.2f,%.2f,%.2f,%.2f)\n#%02X%02X%02X%02X", col.x, col.y, col.z, col.w, IM_F32_TO_INT8_SAT(col.x), IM_F32_TO_INT8_SAT(col.y), IM_F32_TO_INT8_SAT(col.z), IM_F32_TO_INT8_SAT(col.w));

	movss	xmm0, DWORD PTR [esi+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 134  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm2, xmm0
	jbe	SHORT $LN36@ColorButto
	xorps	xmm5, xmm5
	jmp	SHORT $LN37@ColorButto
$LN36@ColorButto:
	movaps	xmm5, xmm0
	minss	xmm5, xmm1
$LN37@ColorButto:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10071:         SetTooltip("Color:\n(%.2f,%.2f,%.2f,%.2f)\n#%02X%02X%02X%02X", col.x, col.y, col.z, col.w, IM_F32_TO_INT8_SAT(col.x), IM_F32_TO_INT8_SAT(col.y), IM_F32_TO_INT8_SAT(col.z), IM_F32_TO_INT8_SAT(col.w));

	movss	xmm0, DWORD PTR [esi]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 134  : static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }

	comiss	xmm2, xmm0
	ja	SHORT $LN43@ColorButto
	minss	xmm0, xmm1
	movaps	xmm2, xmm0
$LN43@ColorButto:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10071:         SetTooltip("Color:\n(%.2f,%.2f,%.2f,%.2f)\n#%02X%02X%02X%02X", col.x, col.y, col.z, col.w, IM_F32_TO_INT8_SAT(col.x), IM_F32_TO_INT8_SAT(col.y), IM_F32_TO_INT8_SAT(col.z), IM_F32_TO_INT8_SAT(col.w));

	movss	xmm1, DWORD PTR __real@437f0000
	movss	xmm0, DWORD PTR __real@3f000000
	mulss	xmm3, xmm1
	mulss	xmm4, xmm1
	addss	xmm3, xmm0
	mulss	xmm5, xmm1
	addss	xmm4, xmm0
	mulss	xmm2, xmm1
	addss	xmm5, xmm0
	cvttss2si eax, xmm3
	addss	xmm2, xmm0
	push	eax
	cvttss2si eax, xmm4
	cvtps2pd xmm0, xmm6
	push	eax
	cvttss2si eax, xmm5
	push	eax
	cvttss2si eax, xmm2
	push	eax
	sub	esp, 32					; 00000020H
	movsd	QWORD PTR [esp+24], xmm0
	cvtps2pd xmm0, xmm7
	movsd	QWORD PTR [esp+16], xmm0
	movss	xmm0, DWORD PTR [esi+4]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR [esi]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG122226
	call	?SetTooltip@ImGui@@YAXPBDZZ		; ImGui::SetTooltip
	add	esp, 52					; 00000034H
$LN4@ColorButto:

; 10072: 
; 10073:     return pressed;

	mov	al, BYTE PTR _pressed$1$[ebp]
	pop	edi
	pop	ebx
	pop	esi

; 10074: }

	mov	esp, ebp
	pop	ebp
	ret	0
?ColorButton@ImGui@@YA_NABUImVec4@@_N1@Z ENDP		; ImGui::ColorButton
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_popup_rect$3 = -80					; size = 16
_value_bb$ = -80					; size = 16
_frame_bb$ = -64					; size = 16
_total_bb$ = -48					; size = 16
$T4 = -40						; size = 8
$T5 = -40						; size = 8
$T6 = -40						; size = 8
$T7 = -32						; size = 8
$T8 = -32						; size = 8
$T9 = -32						; size = 8
$T10 = -32						; size = 8
$T11 = -32						; size = 8
$T12 = -24						; size = 8
_label_size$ = -24					; size = 8
$T13 = -16						; size = 8
$T14 = -16						; size = 8
$T15 = -16						; size = 8
_popup_y1$1$ = -12					; size = 4
_arrow_size$1$ = -12					; size = 4
_item_text$16 = -12					; size = 4
_item_text$17 = -12					; size = 4
_w$ = -12						; size = 4
_popup_y2$1$ = -8					; size = 4
_item_selected$18 = -8					; size = 1
_id$ = -8						; size = 4
_navigated$1$ = -2					; size = 1
_hovered$1$ = -1					; size = 1
_label$ = 8						; size = 4
_current_item$ = 12					; size = 4
_items_getter$ = 16					; size = 4
_data$ = 20						; size = 4
_items_count$ = 24					; size = 4
_height_in_items$ = 28					; size = 4
?Combo@ImGui@@YA_NPBDPAHP6A_NPAXHPAPBD@Z2HH@Z PROC	; ImGui::Combo

; 9505 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9505 : {

	sub	esp, 80					; 00000050H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	push	edi
	mov	BYTE PTR [eax+134], 1
	mov	edi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9507 :     if (window->SkipItems)

	cmp	BYTE PTR [edi+137], 0
	je	SHORT $LN5@Combo

; 9508 :         return false;

	xor	al, al
	pop	edi

; 9620 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@Combo:
	push	ebx
	push	esi

; 9509 : 
; 9510 :     ImGuiContext& g = *GImGui;

	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 9511 :     const ImGuiStyle& style = g.Style;
; 9512 :     const ImGuiID id = window->GetID(label);

	mov	ecx, edi
	push	0
	push	DWORD PTR _label$[ebp]
	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID
	mov	ebx, eax
	mov	DWORD PTR _id$[ebp], ebx

; 9513 :     const float w = CalcItemWidth();

	call	?CalcItemWidth@ImGui@@YAMXZ		; ImGui::CalcItemWidth

; 9514 : 
; 9515 :     const ImVec2 label_size = CalcTextSize(label, NULL, true);

	push	ecx
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	lea	eax, DWORD PTR _label_size$[ebp]
	push	1
	push	0
	push	DWORD PTR _label$[ebp]
	fstp	DWORD PTR _w$[ebp]
	push	eax
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize

; 9516 :     const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2.0f));

	movss	xmm3, DWORD PTR [esi+5360]
	add	esp, 20					; 00000014H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm1, DWORD PTR [edi+192]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9516 :     const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2.0f));

	movaps	xmm0, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm1, DWORD PTR _w$[ebp]
	movss	xmm2, DWORD PTR [edi+196]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9516 :     const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2.0f));

	addss	xmm0, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [edi+192]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9517 :     const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

	movss	xmm4, DWORD PTR _label_size$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _frame_bb$[ebp], eax
	mov	eax, DWORD PTR [edi+196]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9516 :     const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2.0f));

	addss	xmm0, DWORD PTR _label_size$[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _frame_bb$[ebp+4], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T15[ebp], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T15[ebp]
	mov	DWORD PTR _frame_bb$[ebp+8], eax

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm2, xmm0
	xorps	xmm0, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9517 :     const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

	comiss	xmm4, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T15[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T15[ebp+4]
	mov	DWORD PTR _frame_bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9517 :     const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

	jbe	SHORT $LN25@Combo
	movss	xmm0, DWORD PTR [esi+5376]
	addss	xmm0, xmm4
$LN25@Combo:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [edi+192]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm1, xmm0

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _total_bb$[ebp], eax
	mov	eax, DWORD PTR [edi+196]
	mov	DWORD PTR _total_bb$[ebp+4], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T14[ebp+4], xmm2
	movss	DWORD PTR $T14[ebp], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T14[ebp]
	mov	DWORD PTR _total_bb$[ebp+8], eax
	mov	eax, DWORD PTR $T14[ebp+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9518 :     ItemSize(total_bb, style.FramePadding.y);

	push	ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _total_bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9518 :     ItemSize(total_bb, style.FramePadding.y);

	lea	eax, DWORD PTR _total_bb$[ebp]
	movss	DWORD PTR [esp], xmm3
	push	eax
	call	?ItemSize@ImGui@@YAXABUImRect@@M@Z	; ImGui::ItemSize

; 9519 :     if (!ItemAdd(total_bb, &id, &frame_bb))

	lea	eax, DWORD PTR _frame_bb$[ebp]
	push	eax
	lea	eax, DWORD PTR _id$[ebp]
	push	eax
	lea	eax, DWORD PTR _total_bb$[ebp]
	push	eax
	call	?ItemAdd@ImGui@@YA_NABUImRect@@PBIPBU2@@Z ; ImGui::ItemAdd
	add	esp, 20					; 00000014H
	test	al, al
	jne	SHORT $LN6@Combo
	pop	esi
	pop	ebx
	pop	edi

; 9620 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@Combo:

; 9520 :         return false;
; 9521 : 
; 9522 :     const float arrow_size = (g.FontSize + style.FramePadding.x * 2.0f);

	movss	xmm0, DWORD PTR [esi+5356]

; 9523 :     const bool hovered = IsHovered(frame_bb, id);

	lea	eax, DWORD PTR _frame_bb$[ebp]
	addss	xmm0, xmm0
	push	0
	push	ebx
	push	eax
	addss	xmm0, DWORD PTR [esi+6172]
	movss	DWORD PTR _arrow_size$1$[ebp], xmm0
	call	?IsHovered@ImGui@@YA_NABUImRect@@I_N@Z	; ImGui::IsHovered

; 9524 :     const bool navigated = g.NavId == id;

	cmp	DWORD PTR [esi+6384], ebx

; 9525 :     bool popup_open = IsPopupOpen(id);

	push	ebx
	mov	BYTE PTR _hovered$1$[ebp], al
	sete	BYTE PTR _navigated$1$[ebp]
	call	?IsPopupOpen@@YA_NI@Z			; IsPopupOpen
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR _frame_bb$[ebp+8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9525 :     bool popup_open = IsPopupOpen(id);

	mov	bl, al
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm0, DWORD PTR _arrow_size$1$[ebp]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	ecx, DWORD PTR _frame_bb$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9528 :     RenderNavHighlight(frame_bb, id);

	push	DWORD PTR _id$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _value_bb$[ebp], ecx
	mov	ecx, DWORD PTR _frame_bb$[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T11[ebp], xmm0
	movss	xmm0, DWORD PTR _frame_bb$[ebp+12]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T11[ebp]
	mov	DWORD PTR _value_bb$[ebp+8], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T11[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T11[ebp+4]
	mov	DWORD PTR _value_bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9528 :     RenderNavHighlight(frame_bb, id);

	lea	eax, DWORD PTR _frame_bb$[ebp]
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _value_bb$[ebp+4], ecx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9528 :     RenderNavHighlight(frame_bb, id);

	call	?RenderNavHighlight@ImGui@@YAXABUImRect@@I@Z ; ImGui::RenderNavHighlight

; 9529 :     RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);

	movss	xmm0, DWORD PTR [esi+5364]
	add	esp, 20					; 00000014H
	movss	DWORD PTR [esp], xmm0
	push	1
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	7
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	add	esp, 8
	push	eax
	push	DWORD PTR _frame_bb$[ebp+12]
	push	DWORD PTR _frame_bb$[ebp+8]
	push	DWORD PTR _frame_bb$[ebp+4]
	push	DWORD PTR _frame_bb$[ebp]
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame

; 9530 :     RenderFrame(ImVec2(frame_bb.Max.x-arrow_size, frame_bb.Min.y), frame_bb.Max, GetColorU32(popup_open || hovered || navigated ? ImGuiCol_ButtonHovered : ImGuiCol_Button), true, style.FrameRounding); // FIXME-ROUNDING

	mov	bh, BYTE PTR _hovered$1$[ebp]
	add	esp, 28					; 0000001cH
	test	bl, bl
	jne	SHORT $LN27@Combo
	test	bh, bh
	jne	SHORT $LN27@Combo
	mov	eax, 22					; 00000016H
	cmp	BYTE PTR _navigated$1$[ebp], bl
	je	SHORT $LN28@Combo
$LN27@Combo:
	mov	eax, 23					; 00000017H
$LN28@Combo:
	movss	xmm0, DWORD PTR _frame_bb$[ebp+8]
	subss	xmm0, DWORD PTR _arrow_size$1$[ebp]
	push	ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T13[ebp], xmm0
	movss	xmm0, DWORD PTR _frame_bb$[ebp+4]
	movss	DWORD PTR $T13[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9530 :     RenderFrame(ImVec2(frame_bb.Max.x-arrow_size, frame_bb.Min.y), frame_bb.Max, GetColorU32(popup_open || hovered || navigated ? ImGuiCol_ButtonHovered : ImGuiCol_Button), true, style.FrameRounding); // FIXME-ROUNDING

	movss	xmm0, DWORD PTR [esi+5364]
	movss	DWORD PTR [esp], xmm0
	push	1
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	eax
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	add	esp, 8
	push	eax
	push	DWORD PTR _frame_bb$[ebp+12]
	push	DWORD PTR _frame_bb$[ebp+8]
	push	DWORD PTR $T13[ebp+4]
	push	DWORD PTR $T13[ebp]
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR $T13[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9531 :     RenderCollapseTriangle(ImVec2(frame_bb.Max.x-arrow_size, frame_bb.Min.y) + style.FramePadding, true);

	add	esp, 24					; 00000018H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, DWORD PTR [esi+5356]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9531 :     RenderCollapseTriangle(ImVec2(frame_bb.Max.x-arrow_size, frame_bb.Min.y) + style.FramePadding, true);

	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T10[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [esi+5360]
	addss	xmm0, DWORD PTR _frame_bb$[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T10[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9531 :     RenderCollapseTriangle(ImVec2(frame_bb.Max.x-arrow_size, frame_bb.Min.y) + style.FramePadding, true);

	push	DWORD PTR $T10[ebp+4]
	push	DWORD PTR $T10[ebp]
	call	?RenderCollapseTriangle@ImGui@@YAXUImVec2@@_NM@Z ; ImGui::RenderCollapseTriangle

; 9532 : 
; 9533 :     if (*current_item >= 0 && *current_item < items_count)

	mov	eax, DWORD PTR _current_item$[ebp]
	add	esp, 16					; 00000010H
	mov	eax, DWORD PTR [eax]
	test	eax, eax
	js	SHORT $LN8@Combo
	cmp	eax, DWORD PTR _items_count$[ebp]
	jge	SHORT $LN8@Combo

; 9534 :     {
; 9535 :         const char* item_text;
; 9536 :         if (items_getter(data, *current_item, &item_text))

	lea	ecx, DWORD PTR _item_text$17[ebp]
	push	ecx
	push	eax
	push	DWORD PTR _data$[ebp]
	call	DWORD PTR _items_getter$[ebp]
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN8@Combo
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [esi+5356]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9537 :             RenderTextClipped(frame_bb.Min + style.FramePadding, value_bb.Max, item_text, NULL, NULL, ImVec2(0.0f,0.0f));

	lea	eax, DWORD PTR $T9[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, DWORD PTR _frame_bb$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9537 :             RenderTextClipped(frame_bb.Min + style.FramePadding, value_bb.Max, item_text, NULL, NULL, ImVec2(0.0f,0.0f));

	push	0
	push	eax
	push	0
	push	0
	push	DWORD PTR _item_text$17[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T6[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9537 :             RenderTextClipped(frame_bb.Min + style.FramePadding, value_bb.Max, item_text, NULL, NULL, ImVec2(0.0f,0.0f));

	lea	eax, DWORD PTR _value_bb$[ebp+8]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [esi+5360]
	addss	xmm0, DWORD PTR _frame_bb$[ebp+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9537 :             RenderTextClipped(frame_bb.Min + style.FramePadding, value_bb.Max, item_text, NULL, NULL, ImVec2(0.0f,0.0f));

	push	eax
	lea	eax, DWORD PTR $T6[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T9[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9537 :             RenderTextClipped(frame_bb.Min + style.FramePadding, value_bb.Max, item_text, NULL, NULL, ImVec2(0.0f,0.0f));

	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T9[ebp+4], 0
	movss	DWORD PTR $T6[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9537 :             RenderTextClipped(frame_bb.Min + style.FramePadding, value_bb.Max, item_text, NULL, NULL, ImVec2(0.0f,0.0f));

	call	?RenderTextClipped@ImGui@@YAXABUImVec2@@0PBD1PBU2@0PBUImRect@@@Z ; ImGui::RenderTextClipped
	add	esp, 28					; 0000001cH
$LN8@Combo:

; 9538 :     }
; 9539 : 
; 9540 :     if (label_size.x > 0)

	movss	xmm0, DWORD PTR _label_size$[ebp]
	xorps	xmm1, xmm1
	comiss	xmm0, xmm1
	jbe	SHORT $LN9@Combo

; 9541 :         RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

	movss	xmm0, DWORD PTR [esi+5376]
	addss	xmm0, DWORD PTR _frame_bb$[ebp+8]
	push	1
	push	0
	push	DWORD PTR _label$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T8[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9541 :         RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

	movss	xmm0, DWORD PTR [esi+5360]
	addss	xmm0, DWORD PTR _frame_bb$[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T8[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9541 :         RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

	push	DWORD PTR $T8[ebp+4]
	push	DWORD PTR $T8[ebp]
	call	?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z	; ImGui::RenderText
	add	esp, 20					; 00000014H
$LN9@Combo:

; 9542 : 
; 9543 :     bool popup_toggled = false;

	xor	bl, bl

; 9544 :     if (hovered)

	test	bh, bh
	je	SHORT $LN11@Combo

; 9545 :     {
; 9546 :         SetHoveredID(id);

	push	DWORD PTR _id$[ebp]
	call	?SetHoveredID@ImGui@@YAXI@Z		; ImGui::SetHoveredID
	add	esp, 4

; 9547 :         if (g.IO.MouseClicked[0])

	cmp	BYTE PTR [esi+888], bl
	je	SHORT $LN11@Combo

; 9548 :         {
; 9549 :             ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID

; 9550 :             popup_toggled = true;

	mov	bl, 1
$LN11@Combo:

; 9551 :         }
; 9552 :     }
; 9553 :     if (g.NavActivateId == id)

	mov	edx, DWORD PTR _id$[ebp]
	cmp	DWORD PTR [esi+6388], edx
	jne	SHORT $LN12@Combo

; 9554 :         popup_toggled = true;

	mov	bl, 1

; 9555 :     if (popup_toggled)

	jmp	SHORT $LN105@Combo
$LN12@Combo:
	test	bl, bl
	je	SHORT $LN15@Combo
$LN105@Combo:

; 9556 :     {
; 9557 :         if (IsPopupOpen(id))

	push	edx
	call	?IsPopupOpen@@YA_NI@Z			; IsPopupOpen
	add	esp, 4
	test	al, al
	je	SHORT $LN14@Combo

; 9558 :         {
; 9559 :             ClosePopup(id);

	push	edx
	call	?ClosePopup@@YAXI@Z			; ClosePopup
	add	esp, 4

; 9560 :         }
; 9561 :         else

	jmp	SHORT $LN109@Combo
$LN14@Combo:

; 9562 :         {
; 9563 :             if (window->DC.NavLayerCurrent == 0) 

	cmp	DWORD PTR [edi+272], 0
	jne	SHORT $LN16@Combo

; 9564 :                 window->NavLastId = id;

	mov	DWORD PTR [edi+148], edx
$LN16@Combo:

; 9565 :             FocusWindow(window);

	push	edi
	call	?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusWindow

; 9566 :             OpenPopup(label);

	push	DWORD PTR _label$[ebp]
	call	?OpenPopup@ImGui@@YAXPBD@Z		; ImGui::OpenPopup
	add	esp, 8
$LN109@Combo:
	mov	edx, DWORD PTR _id$[ebp]
$LN15@Combo:

; 9567 :             popup_open = true;
; 9568 :         }
; 9569 :     }
; 9570 : 
; 9571 :     bool value_changed = false;
; 9572 :     if (IsPopupOpen(id))

	push	edx
	xor	bh, bh
	call	?IsPopupOpen@@YA_NI@Z			; IsPopupOpen
	add	esp, 4
	test	al, al
	je	$LN17@Combo

; 9578 :         float popup_height = (label_size.y + style.ItemSpacing.y) * ImMin(items_count, height_in_items) + (style.FramePadding.y * 3);

	mov	eax, DWORD PTR _height_in_items$[ebp]
	mov	ecx, 7
	movss	xmm0, DWORD PTR [esi+5372]
	test	eax, eax
	addss	xmm0, DWORD PTR _label_size$[ebp+4]

; 9579 :         float popup_y1 = frame_bb.Max.y;

	movss	xmm3, DWORD PTR _frame_bb$[ebp+12]
	cmovns	ecx, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 125  : static inline int    ImMin(int lhs, int rhs)                                    { return lhs < rhs ? lhs : rhs; }

	cmp	DWORD PTR _items_count$[ebp], ecx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9579 :         float popup_y1 = frame_bb.Max.y;

	movss	DWORD PTR _popup_y1$1$[ebp], xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 125  : static inline int    ImMin(int lhs, int rhs)                                    { return lhs < rhs ? lhs : rhs; }

	cmovl	ecx, DWORD PTR _items_count$[ebp]
	movd	xmm5, ecx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9578 :         float popup_height = (label_size.y + style.ItemSpacing.y) * ImMin(items_count, height_in_items) + (style.FramePadding.y * 3);

	cvtdq2ps xmm5, xmm5
	mulss	xmm5, xmm0
	movss	xmm0, DWORD PTR [esi+5360]
	mulss	xmm0, DWORD PTR __real@40400000
	addss	xmm5, xmm0

; 9580 :         float popup_y2 = ImClamp(popup_y1 + popup_height, popup_y1, g.IO.DisplaySize.y - style.DisplaySafeAreaPadding.y);

	movaps	xmm0, xmm3
	addss	xmm0, xmm5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm3, xmm0
	jbe	SHORT $LN77@Combo
	movaps	xmm2, xmm3
	jmp	SHORT $LN110@Combo
$LN77@Combo:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9580 :         float popup_y2 = ImClamp(popup_y1 + popup_height, popup_y1, g.IO.DisplaySize.y - style.DisplaySafeAreaPadding.y);

	movss	xmm2, DWORD PTR [esi+8]
	subss	xmm2, DWORD PTR [esi+5436]
	minss	xmm2, xmm0
$LN110@Combo:

; 9581 :         if ((popup_y2 - popup_y1) < ImMin(popup_height, frame_bb.Min.y - style.DisplaySafeAreaPadding.y))

	movss	xmm4, DWORD PTR _frame_bb$[ebp+4]
	movaps	xmm1, xmm2
	movss	xmm6, DWORD PTR [esi+5436]
	subss	xmm1, xmm3
	movaps	xmm0, xmm4
	movss	DWORD PTR _popup_y2$1$[ebp], xmm2
	subss	xmm0, xmm6
	minss	xmm0, xmm5
	comiss	xmm0, xmm1
	jbe	SHORT $LN19@Combo

; 9582 :         {
; 9583 :             // Position our combo ABOVE because there's more space to fit! (FIXME: Handle in Begin() or use a shared helper. We have similar code in Begin() for popup placement)
; 9584 :             popup_y1 = ImClamp(frame_bb.Min.y - popup_height, style.DisplaySafeAreaPadding.y, frame_bb.Min.y);

	movaps	xmm0, xmm4
	movaps	xmm3, xmm6
	subss	xmm0, xmm5
	movss	DWORD PTR _popup_y1$1$[ebp], xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm3, xmm0
	ja	SHORT $LN88@Combo
	movaps	xmm3, xmm0
	minss	xmm3, xmm4
	movss	DWORD PTR _popup_y1$1$[ebp], xmm3
$LN88@Combo:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9585 :             popup_y2 = frame_bb.Min.y;

	movaps	xmm2, xmm4
	movss	DWORD PTR _popup_y2$1$[ebp], xmm2
$LN19@Combo:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR _frame_bb$[ebp+8]
	movss	DWORD PTR $T12[ebp], xmm0
	movss	xmm0, DWORD PTR _frame_bb$[ebp]
	movss	DWORD PTR $T7[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T7[ebp]
	mov	DWORD PTR _popup_rect$3[ebp], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T7[ebp+4], xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T7[ebp+4]
	mov	DWORD PTR _popup_rect$3[ebp+4], eax
	mov	eax, DWORD PTR $T12[ebp]
	mov	DWORD PTR _popup_rect$3[ebp+8], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T12[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T12[ebp+4]
	mov	DWORD PTR _popup_rect$3[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9588 :         SetNextWindowPos(popup_rect.Min);

	lea	eax, DWORD PTR _popup_rect$3[ebp]
	push	0
	push	eax
	call	?SetNextWindowPos@ImGui@@YAXABUImVec2@@H@Z ; ImGui::SetNextWindowPos
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 245  :     ImVec2      GetSize() const                 { return ImVec2(Max.x-Min.x, Max.y-Min.y); }

	movss	xmm0, DWORD PTR _frame_bb$[ebp+8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9589 :         SetNextWindowSize(popup_rect.GetSize());

	lea	eax, DWORD PTR $T5[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 245  :     ImVec2      GetSize() const                 { return ImVec2(Max.x-Min.x, Max.y-Min.y); }

	subss	xmm0, DWORD PTR _frame_bb$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9589 :         SetNextWindowSize(popup_rect.GetSize());

	push	0
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T5[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 245  :     ImVec2      GetSize() const                 { return ImVec2(Max.x-Min.x, Max.y-Min.y); }

	movss	xmm0, DWORD PTR _popup_y2$1$[ebp]
	subss	xmm0, DWORD PTR _popup_y1$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T5[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9589 :         SetNextWindowSize(popup_rect.GetSize());

	call	?SetNextWindowSize@ImGui@@YAXABUImVec2@@H@Z ; ImGui::SetNextWindowSize

; 9590 :         PushStyleVar(ImGuiStyleVar_WindowPadding, style.FramePadding);

	lea	eax, DWORD PTR [esi+5356]
	push	eax
	push	1
	call	?PushStyleVar@ImGui@@YAXHABUImVec2@@@Z	; ImGui::PushStyleVar

; 9591 : 
; 9592 :         const ImGuiWindowFlags flags = ImGuiWindowFlags_ComboBox | ((window->Flags & ImGuiWindowFlags_ShowBorders) ? ImGuiWindowFlags_ShowBorders : 0);

	mov	eax, DWORD PTR [edi+8]
	and	eax, 128				; 00000080H
	or	eax, 8388608				; 00800000H

; 9593 :         if (BeginPopupEx(label, flags))

	push	eax
	push	DWORD PTR _label$[ebp]
	call	?BeginPopupEx@@YA_NPBDH@Z		; BeginPopupEx
	add	esp, 32					; 00000020H
	test	al, al
	je	SHORT $LN20@Combo

; 9594 :         {
; 9595 :             // Display items
; 9596 :             // FIXME-OPT: Use clipper
; 9597 :             Spacing();

	call	?Spacing@ImGui@@YAXXZ			; ImGui::Spacing

; 9598 :             for (int i = 0; i < items_count; i++)

	xor	esi, esi
	cmp	DWORD PTR _items_count$[ebp], esi
	jle	SHORT $LN3@Combo
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T4[ebp], esi
	mov	DWORD PTR $T4[ebp+4], esi
$LL4@Combo:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 9600 :                 PushID((void*)(intptr_t)i);

	push	esi
	call	?PushID@ImGui@@YAXPBX@Z			; ImGui::PushID

; 9601 :                 const bool item_selected = (i == *current_item);

	mov	eax, DWORD PTR _current_item$[ebp]
	mov	edi, DWORD PTR [eax]

; 9602 :                 const char* item_text;
; 9603 :                 if (!items_getter(data, i, &item_text))

	lea	eax, DWORD PTR _item_text$16[ebp]
	push	eax
	push	esi
	push	DWORD PTR _data$[ebp]
	cmp	esi, edi
	sete	BYTE PTR _item_selected$18[ebp]
	call	DWORD PTR _items_getter$[ebp]
	test	al, al
	mov	ecx, OFFSET $SG121909

; 9604 :                     item_text = "*Unknown item*";
; 9605 :                 if (Selectable(item_text, item_selected))

	lea	eax, DWORD PTR $T4[ebp]
	cmovne	ecx, DWORD PTR _item_text$16[ebp]
	push	eax
	push	0
	push	DWORD PTR _item_selected$18[ebp]
	mov	DWORD PTR _item_text$16[ebp], ecx
	push	ecx
	call	?Selectable@ImGui@@YA_NPBD_NHABUImVec2@@@Z ; ImGui::Selectable
	add	esp, 32					; 00000020H
	test	al, al
	je	SHORT $LN22@Combo

; 9606 :                 {
; 9607 :                     ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID

; 9608 :                     value_changed = true;
; 9609 :                     *current_item = i;

	mov	eax, DWORD PTR _current_item$[ebp]
	mov	bh, 1
	mov	DWORD PTR [eax], esi
$LN22@Combo:
	cmp	esi, edi

; 9610 :                 }
; 9611 :                 if (item_selected && popup_toggled)

	jne	SHORT $LN23@Combo
	test	bl, bl
	je	SHORT $LN23@Combo

; 9612 :                     SetItemDefaultFocus(); //SetScrollHere();

	call	?SetItemDefaultFocus@ImGui@@YAXXZ	; ImGui::SetItemDefaultFocus
$LN23@Combo:

; 9613 :                 PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID
	inc	esi
	cmp	esi, DWORD PTR _items_count$[ebp]
	jl	SHORT $LL4@Combo
$LN3@Combo:

; 9614 :             }
; 9615 :             EndPopup();

	call	?EndPopup@ImGui@@YAXXZ			; ImGui::EndPopup
$LN20@Combo:

; 9616 :         }
; 9617 :         PopStyleVar();

	push	1
	call	?PopStyleVar@ImGui@@YAXH@Z		; ImGui::PopStyleVar
	add	esp, 4
$LN17@Combo:

; 9618 :     }
; 9619 :     return value_changed;

	pop	esi
	mov	al, bh
	pop	ebx
	pop	edi

; 9620 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Combo@ImGui@@YA_NPBDPAHP6A_NPAXHPAPBD@Z2HH@Z ENDP	; ImGui::Combo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_current_item$ = 12					; size = 4
_items_separated_by_zeros$ = 16				; size = 4
_height_in_items$ = 20					; size = 4
?Combo@ImGui@@YA_NPBDPAH0H@Z PROC			; ImGui::Combo

; 9491 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx

; 9492 :     int items_count = 0;
; 9493 :     const char* p = items_separated_by_zeros;       // FIXME-OPT: Avoid computing this, or at least only when combo is open

	mov	ebx, DWORD PTR _items_separated_by_zeros$[ebp]
	mov	edx, ebx
	push	esi
	xor	esi, esi

; 9494 :     while (*p)

	cmp	BYTE PTR [ebx], 0
	je	SHORT $LN3@Combo
	push	edi
$LL2@Combo:

; 9495 :     {
; 9496 :         p += strlen(p) + 1;

	mov	eax, edx
	lea	edi, DWORD PTR [eax+1]
	npad	7
$LL9@Combo:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL9@Combo
	sub	eax, edi
	inc	edx
	add	edx, eax

; 9497 :         items_count++;

	inc	esi
	cmp	BYTE PTR [edx], cl
	jne	SHORT $LL2@Combo
	pop	edi
$LN3@Combo:

; 9498 :     }
; 9499 :     bool value_changed = Combo(label, current_item, Items_SingleStringGetter, (void*)items_separated_by_zeros, items_count, height_in_items);

	push	DWORD PTR _height_in_items$[ebp]
	push	esi
	push	ebx
	push	OFFSET ?Items_SingleStringGetter@@YA_NPAXHPAPBD@Z ; Items_SingleStringGetter
	push	DWORD PTR _current_item$[ebp]
	push	DWORD PTR _label$[ebp]
	call	?Combo@ImGui@@YA_NPBDPAHP6A_NPAXHPAPBD@Z2HH@Z ; ImGui::Combo
	add	esp, 24					; 00000018H
	pop	esi
	pop	ebx

; 9500 :     return value_changed;
; 9501 : }

	pop	ebp
	ret	0
?Combo@ImGui@@YA_NPBDPAH0H@Z ENDP			; ImGui::Combo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_current_item$ = 12					; size = 4
_items$ = 16						; size = 4
_items_count$ = 20					; size = 4
_height_in_items$ = 24					; size = 4
?Combo@ImGui@@YA_NPBDPAHPBQBDHH@Z PROC			; ImGui::Combo

; 9484 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 9485 :     const bool value_changed = Combo(label, current_item, Items_ArrayGetter, (void*)items, items_count, height_in_items);

	push	DWORD PTR _height_in_items$[ebp]
	push	DWORD PTR _items_count$[ebp]
	push	DWORD PTR _items$[ebp]
	push	OFFSET ?Items_ArrayGetter@@YA_NPAXHPAPBD@Z ; Items_ArrayGetter
	push	DWORD PTR _current_item$[ebp]
	push	DWORD PTR _label$[ebp]
	call	?Combo@ImGui@@YA_NPBDPAHP6A_NPAXHPAPBD@Z2HH@Z ; ImGui::Combo
	add	esp, 24					; 00000018H

; 9486 :     return value_changed;
; 9487 : }

	pop	ebp
	ret	0
?Combo@ImGui@@YA_NPBDPAHPBQBDHH@Z ENDP			; ImGui::Combo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_v$ = 12						; size = 4
_v_button$ = 16						; size = 4
?RadioButton@ImGui@@YA_NPBDPAHH@Z PROC			; ImGui::RadioButton

; 8433 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 8434 :     const bool pressed = RadioButton(label, *v == v_button);

	mov	esi, DWORD PTR _v_button$[ebp]
	push	edi
	mov	edi, DWORD PTR _v$[ebp]
	cmp	DWORD PTR [edi], esi
	sete	al
	movzx	eax, al
	push	eax
	push	DWORD PTR _label$[ebp]
	call	?RadioButton@ImGui@@YA_NPBD_N@Z		; ImGui::RadioButton
	add	esp, 8

; 8435 :     if (pressed)

	test	al, al
	je	SHORT $LN2@RadioButto

; 8436 :     {
; 8437 :         *v = v_button;

	mov	DWORD PTR [edi], esi
$LN2@RadioButto:
	pop	edi
	pop	esi

; 8438 :     }
; 8439 :     return pressed;
; 8440 : }

	pop	ebp
	ret	0
?RadioButton@ImGui@@YA_NPBDPAHH@Z ENDP			; ImGui::RadioButton
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_total_bb$ = -100					; size = 16
_check_bb$ = -84					; size = 16
$T6 = -68						; size = 8
$T7 = -68						; size = 8
$T8 = -68						; size = 8
$T9 = -60						; size = 8
_label_size$ = -52					; size = 8
_center$ = -44						; size = 8
$T10 = -36						; size = 8
$T4$sroa$243$1$ = -32					; size = 4
$T4$sroa$550$1$ = -28					; size = 4
$T11 = -24						; size = 4
_id$ = -20						; size = 4
_radius$1$ = -16					; size = 4
$T12 = -16						; size = 4
$T13 = -12						; size = 4
$T14 = -8						; size = 4
_hovered$ = -2						; size = 1
_held$ = -1						; size = 1
_label$ = 8						; size = 4
_active$ = 12						; size = 1
?RadioButton@ImGui@@YA_NPBD_N@Z PROC			; ImGui::RadioButton

; 8375 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8375 : {

	sub	esp, 100				; 00000064H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	push	esi
	mov	BYTE PTR [eax+134], 1
	mov	esi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8377 :     if (window->SkipItems)

	cmp	BYTE PTR [esi+137], 0
	je	SHORT $LN2@RadioButto

; 8378 :         return false;

	xor	al, al
	pop	esi

; 8430 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@RadioButto:
	push	ebx
	push	edi

; 8379 : 
; 8380 :     ImGuiContext& g = *GImGui;

	mov	edi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 8381 :     const ImGuiStyle& style = g.Style;
; 8382 :     const ImGuiID id = window->GetID(label);

	mov	ecx, esi
	push	0
	push	DWORD PTR _label$[ebp]
	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID

; 8383 :     const ImVec2 label_size = CalcTextSize(label, NULL, true);

	push	ecx
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	mov	ebx, eax
	push	1
	push	0
	push	DWORD PTR _label$[ebp]
	lea	eax, DWORD PTR _label_size$[ebp]
	mov	DWORD PTR _id$[ebp], ebx
	push	eax
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize

; 8385 :     const ImRect check_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(label_size.y + style.FramePadding.y*2-1, label_size.y + style.FramePadding.y*2-1));

	movss	xmm1, DWORD PTR [edi+5360]

; 8386 :     ItemSize(check_bb, style.FramePadding.y);

	add	esp, 16					; 00000010H
	movaps	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [esi+192]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8385 :     const ImRect check_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(label_size.y + style.FramePadding.y*2-1, label_size.y + style.FramePadding.y*2-1));

	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _check_bb$[ebp], eax
	mov	eax, DWORD PTR [esi+196]
	mov	DWORD PTR _check_bb$[ebp+4], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8386 :     ItemSize(check_bb, style.FramePadding.y);

	movss	DWORD PTR [esp], xmm1
	addss	xmm0, DWORD PTR _label_size$[ebp+4]
	subss	xmm0, DWORD PTR __real@3f800000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movaps	xmm2, xmm0
	addss	xmm2, DWORD PTR [esi+192]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T10[ebp], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T10[ebp]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	DWORD PTR $T13[ebp], xmm2
	movss	xmm2, DWORD PTR [esi+196]
	addss	xmm2, xmm0

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _check_bb$[ebp+8], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T10[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T10[ebp+4]
	mov	DWORD PTR _check_bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8386 :     ItemSize(check_bb, style.FramePadding.y);

	lea	eax, DWORD PTR _check_bb$[ebp]
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	DWORD PTR $T14[ebp], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8386 :     ItemSize(check_bb, style.FramePadding.y);

	call	?ItemSize@ImGui@@YAXABUImRect@@M@Z	; ImGui::ItemSize

; 8387 : 
; 8388 :     ImRect total_bb = check_bb;

	movss	xmm0, DWORD PTR _check_bb$[ebp]
	add	esp, 8

; 8389 :     if (label_size.x > 0)

	movss	xmm6, DWORD PTR _label_size$[ebp]
	movss	xmm4, DWORD PTR _check_bb$[ebp+4]
	movss	xmm1, DWORD PTR $T14[ebp]
	movss	DWORD PTR _total_bb$[ebp], xmm0
	movss	xmm0, DWORD PTR $T13[ebp]
	movss	DWORD PTR _total_bb$[ebp+8], xmm0
	xorps	xmm0, xmm0
	comiss	xmm6, xmm0
	movss	DWORD PTR _total_bb$[ebp+4], xmm4
	movss	DWORD PTR _total_bb$[ebp+12], xmm1
	jbe	SHORT $LN3@RadioButto

; 8390 :         SameLine(0, style.ItemInnerSpacing.x);

	movss	xmm0, DWORD PTR [edi+5376]
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	movss	xmm1, DWORD PTR $T14[ebp]
	add	esp, 8
	movss	xmm4, DWORD PTR _check_bb$[ebp+4]
	movss	xmm6, DWORD PTR _label_size$[ebp]
$LN3@RadioButto:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm5, DWORD PTR [edi+5360]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm2, DWORD PTR [esi+196]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR [esi+192]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm2, xmm5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm3, DWORD PTR [esi+192]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm6
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T12[ebp], xmm3
	movss	DWORD PTR $T9[ebp], xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm2, DWORD PTR _label_size$[ebp+4]
	movss	DWORD PTR $T4$sroa$550$1$[ebp], xmm0
	movss	DWORD PTR $T4$sroa$243$1$[ebp], xmm2
	movss	xmm2, DWORD PTR [esi+196]
	addss	xmm2, xmm5
	movss	DWORD PTR $T11[ebp], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T9[ebp+4], xmm2
	xorps	xmm2, xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8392 :     if (label_size.x > 0)

	comiss	xmm6, xmm2
	jbe	SHORT $LN51@RadioButto
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 246  :     float       GetWidth() const                { return Max.x-Min.x; }

	subss	xmm0, xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8394 :         ItemSize(ImVec2(text_bb.GetWidth(), check_bb.GetHeight()), style.FramePadding.y);

	push	ecx
	lea	eax, DWORD PTR $T8[ebp]
	movss	DWORD PTR [esp], xmm5
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T8[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 247  :     float       GetHeight() const               { return Max.y-Min.y; }

	movaps	xmm0, xmm1
	subss	xmm0, xmm4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T8[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8394 :         ItemSize(ImVec2(text_bb.GetWidth(), check_bb.GetHeight()), style.FramePadding.y);

	call	?ItemSize@ImGui@@YAXABUImVec2@@M@Z	; ImGui::ItemSize
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 256  :     void        Add(const ImRect& rhs)          { if (Min.x > rhs.Min.x) Min.x = rhs.Min.x; if (Min.y > rhs.Min.y) Min.y = rhs.Min.y; if (Max.x < rhs.Max.x) Max.x = rhs.Max.x; if (Max.y < rhs.Max.y) Max.y = rhs.Max.y; }

	movss	xmm0, DWORD PTR $T12[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8394 :         ItemSize(ImVec2(text_bb.GetWidth(), check_bb.GetHeight()), style.FramePadding.y);

	add	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 256  :     void        Add(const ImRect& rhs)          { if (Min.x > rhs.Min.x) Min.x = rhs.Min.x; if (Min.y > rhs.Min.y) Min.y = rhs.Min.y; if (Max.x < rhs.Max.x) Max.x = rhs.Max.x; if (Max.y < rhs.Max.y) Max.y = rhs.Max.y; }

	movss	xmm1, DWORD PTR _check_bb$[ebp]
	comiss	xmm1, xmm0
	jbe	SHORT $LN48@RadioButto
	movss	DWORD PTR _total_bb$[ebp], xmm0
$LN48@RadioButto:
	movss	xmm0, DWORD PTR $T11[ebp]
	movss	xmm1, DWORD PTR _check_bb$[ebp+4]
	comiss	xmm1, xmm0
	jbe	SHORT $LN49@RadioButto
	movss	DWORD PTR _total_bb$[ebp+4], xmm0
$LN49@RadioButto:
	movss	xmm0, DWORD PTR $T4$sroa$550$1$[ebp]
	comiss	xmm0, DWORD PTR $T13[ebp]
	jbe	SHORT $LN50@RadioButto
	movss	DWORD PTR _total_bb$[ebp+8], xmm0
$LN50@RadioButto:
	movss	xmm0, DWORD PTR $T4$sroa$243$1$[ebp]
	comiss	xmm0, DWORD PTR $T14[ebp]
	jbe	SHORT $LN51@RadioButto
	movss	DWORD PTR _total_bb$[ebp+12], xmm0
$LN51@RadioButto:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8398 :     if (!ItemAdd(total_bb, &id))

	push	0
	lea	eax, DWORD PTR _id$[ebp]
	push	eax
	lea	eax, DWORD PTR _total_bb$[ebp]
	push	eax
	call	?ItemAdd@ImGui@@YA_NABUImRect@@PBIPBU2@@Z ; ImGui::ItemAdd
	add	esp, 12					; 0000000cH
	test	al, al
	jne	SHORT $LN5@RadioButto
	pop	edi
	pop	ebx
	pop	esi

; 8430 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@RadioButto:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR _check_bb$[ebp]
	addss	xmm0, DWORD PTR $T13[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 244  :     ImVec2      GetCenter() const               { return ImVec2((Min.x+Max.x)*0.5f, (Min.y+Max.y)*0.5f); }

	movss	xmm2, DWORD PTR __real@3f000000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm3, DWORD PTR $T14[ebp]
	movss	xmm1, DWORD PTR _check_bb$[ebp+4]
	addss	xmm1, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 244  :     ImVec2      GetCenter() const               { return ImVec2((Min.x+Max.x)*0.5f, (Min.y+Max.y)*0.5f); }

	mulss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8407 :     bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);

	push	0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 247  :     float       GetHeight() const               { return Max.y-Min.y; }

	subss	xmm3, DWORD PTR _check_bb$[ebp+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8402 :     center.x = (float)(int)center.x + 0.5f;

	cvttss2si eax, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 244  :     ImVec2      GetCenter() const               { return ImVec2((Min.x+Max.x)*0.5f, (Min.y+Max.y)*0.5f); }

	mulss	xmm1, xmm2

; 247  :     float       GetHeight() const               { return Max.y-Min.y; }

	movss	DWORD PTR $T14[ebp], xmm3
	movd	xmm0, eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8402 :     center.x = (float)(int)center.x + 0.5f;

	cvtdq2ps xmm0, xmm0

; 8403 :     center.y = (float)(int)center.y + 0.5f;

	cvttss2si eax, xmm1
	addss	xmm0, xmm2
	movss	DWORD PTR _center$[ebp], xmm0
	movd	xmm0, eax

; 8407 :     bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);

	lea	eax, DWORD PTR _held$[ebp]
	cvtdq2ps xmm0, xmm0
	push	eax
	lea	eax, DWORD PTR _hovered$[ebp]
	push	eax
	lea	eax, DWORD PTR _total_bb$[ebp]
	push	ebx
	addss	xmm0, xmm2
	push	eax
	movss	DWORD PTR _center$[ebp+4], xmm0
	movaps	xmm0, xmm3
	mulss	xmm0, xmm2
	movss	DWORD PTR _radius$1$[ebp], xmm0
	call	?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z ; ImGui::ButtonBehavior

; 8408 : 
; 8409 :     RenderNavHighlight(total_bb, id);

	push	DWORD PTR _id$[ebp]
	mov	bh, al
	lea	eax, DWORD PTR _total_bb$[ebp]
	push	eax
	call	?RenderNavHighlight@ImGui@@YAXABUImRect@@I@Z ; ImGui::RenderNavHighlight

; 8410 :     window->DrawList->AddCircleFilled(center, radius, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), 16);

	mov	cl, BYTE PTR _hovered$[ebp]
	add	esp, 28					; 0000001cH
	cmp	BYTE PTR _held$[ebp], 0
	je	SHORT $LN11@RadioButto
	test	cl, cl
	je	SHORT $LN11@RadioButto
	mov	eax, 9
	jmp	SHORT $LN12@RadioButto
$LN11@RadioButto:
	xor	eax, eax
	test	cl, cl
	setne	al
	add	eax, 7
$LN12@RadioButto:
	push	16					; 00000010H
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	eax
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	movss	xmm0, DWORD PTR _radius$1$[ebp]
	add	esp, 8
	push	eax
	push	ecx
	mov	ecx, DWORD PTR [esi+624]
	lea	eax, DWORD PTR _center$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	eax
	call	?AddCircleFilled@ImDrawList@@QAEXABUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled

; 8411 :     if (active)

	mov	bl, BYTE PTR _active$[ebp]
	test	bl, bl
	je	SHORT $LN6@RadioButto

; 8415 :         window->DrawList->AddCircleFilled(center, radius-pad, GetColorU32(ImGuiCol_CheckMark), 16);

	push	16					; 00000010H
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	19					; 00000013H
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 246  :     float       GetWidth() const                { return Max.x-Min.x; }

	movss	xmm0, DWORD PTR $T13[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8415 :         window->DrawList->AddCircleFilled(center, radius-pad, GetColorU32(ImGuiCol_CheckMark), 16);

	add	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 246  :     float       GetWidth() const                { return Max.x-Min.x; }

	subss	xmm0, DWORD PTR _check_bb$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8415 :         window->DrawList->AddCircleFilled(center, radius-pad, GetColorU32(ImGuiCol_CheckMark), 16);

	movss	xmm1, DWORD PTR _radius$1$[ebp]
	push	eax
	push	ecx
	minss	xmm0, DWORD PTR $T14[ebp]
	mov	ecx, DWORD PTR [esi+624]
	mulss	xmm0, DWORD PTR __real@3e2aaaab
	cvttss2si eax, xmm0
	movd	xmm0, eax
	lea	eax, DWORD PTR _center$[ebp]
	cvtdq2ps xmm0, xmm0
	maxss	xmm0, DWORD PTR __real@3f800000
	subss	xmm1, xmm0
	movss	DWORD PTR [esp], xmm1
	push	eax
	call	?AddCircleFilled@ImDrawList@@QAEXABUImVec2@@MIH@Z ; ImDrawList::AddCircleFilled
$LN6@RadioButto:

; 8416 :     }
; 8417 : 
; 8418 :     if (window->Flags & ImGuiWindowFlags_ShowBorders)

	test	BYTE PTR [esi+8], 128			; 00000080H
	je	$LN7@RadioButto
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR _center$[ebp]
	addss	xmm0, DWORD PTR __real@3f800000
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8420 :         window->DrawList->AddCircle(center+ImVec2(1,1), radius, GetColorU32(ImGuiCol_BorderShadow), 16);

	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	16					; 00000010H
	push	ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T7[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR _center$[ebp+4]
	addss	xmm0, DWORD PTR __real@3f800000
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8420 :         window->DrawList->AddCircle(center+ImVec2(1,1), radius, GetColorU32(ImGuiCol_BorderShadow), 16);

	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	6
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T7[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8420 :         window->DrawList->AddCircle(center+ImVec2(1,1), radius, GetColorU32(ImGuiCol_BorderShadow), 16);

	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	movss	xmm0, DWORD PTR _radius$1$[ebp]
	add	esp, 8
	push	eax
	push	ecx
	mov	ecx, DWORD PTR [esi+624]
	lea	eax, DWORD PTR $T7[ebp]
	movss	DWORD PTR [esp], xmm0
	push	eax
	call	?AddCircle@ImDrawList@@QAEXABUImVec2@@MIHM@Z ; ImDrawList::AddCircle

; 8421 :         window->DrawList->AddCircle(center, radius, GetColorU32(ImGuiCol_Border), 16);

	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	16					; 00000010H
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	5
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	movss	xmm0, DWORD PTR _radius$1$[ebp]
	add	esp, 8
	push	eax
	push	ecx
	mov	ecx, DWORD PTR [esi+624]
	lea	eax, DWORD PTR _center$[ebp]
	movss	DWORD PTR [esp], xmm0
	push	eax
	call	?AddCircle@ImDrawList@@QAEXABUImVec2@@MIHM@Z ; ImDrawList::AddCircle
$LN7@RadioButto:

; 8422 :     }
; 8423 : 
; 8424 :     if (g.LogEnabled)

	cmp	BYTE PTR [edi+11600], 0
	mov	esi, DWORD PTR $T9[ebp+4]
	mov	edi, DWORD PTR $T9[ebp]
	je	SHORT $LN8@RadioButto

; 8425 :         LogRenderedText(text_bb.GetTL(), active ? "(x)" : "( )");

	mov	ecx, OFFSET $SG120709
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 248  :     ImVec2      GetTL() const                   { return Min; }                   // Top-left

	mov	DWORD PTR $T6[ebp], edi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8425 :         LogRenderedText(text_bb.GetTL(), active ? "(x)" : "( )");

	test	bl, bl
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 248  :     ImVec2      GetTL() const                   { return Min; }                   // Top-left

	mov	DWORD PTR $T6[ebp+4], esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8425 :         LogRenderedText(text_bb.GetTL(), active ? "(x)" : "( )");

	mov	eax, OFFSET $SG120708
	cmove	eax, ecx
	push	0
	push	eax
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	call	?LogRenderedText@@YAXABUImVec2@@PBD1@Z	; LogRenderedText
	add	esp, 12					; 0000000cH
$LN8@RadioButto:

; 8426 :     if (label_size.x > 0.0f)

	movss	xmm0, DWORD PTR _label_size$[ebp]
	xorps	xmm1, xmm1
	comiss	xmm0, xmm1
	jbe	SHORT $LN9@RadioButto

; 8427 :         RenderText(text_bb.GetTL(), label);

	push	1
	push	0
	push	DWORD PTR _label$[ebp]
	push	esi
	push	edi
	call	?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z	; ImGui::RenderText
	add	esp, 20					; 00000014H
$LN9@RadioButto:

; 8428 : 
; 8429 :     return pressed;

	pop	edi
	mov	al, bh
	pop	ebx
	pop	esi

; 8430 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?RadioButton@ImGui@@YA_NPBD_N@Z ENDP			; ImGui::RadioButton
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_flags$ = 12						; size = 4
_v$ = 15						; size = 1
_flags_value$ = 16					; size = 4
?CheckboxFlags@ImGui@@YA_NPBDPAII@Z PROC		; ImGui::CheckboxFlags

; 8360 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 8361 :     bool v = ((*flags & flags_value) == flags_value);

	mov	esi, DWORD PTR _flags_value$[ebp]
	push	edi
	mov	edi, DWORD PTR _flags$[ebp]
	mov	eax, DWORD PTR [edi]
	and	eax, esi
	cmp	eax, esi

; 8362 :     bool pressed = Checkbox(label, &v);

	lea	eax, DWORD PTR _v$[ebp]
	push	eax
	push	DWORD PTR _label$[ebp]
	sete	BYTE PTR _v$[ebp]
	call	?Checkbox@ImGui@@YA_NPBDPA_N@Z		; ImGui::Checkbox
	add	esp, 8

; 8363 :     if (pressed)

	test	al, al
	je	SHORT $LN4@CheckboxFl

; 8364 :     {
; 8365 :         if (v)

	cmp	BYTE PTR _v$[ebp], 0
	je	SHORT $LN3@CheckboxFl

; 8366 :             *flags |= flags_value;

	or	DWORD PTR [edi], esi
	pop	edi
	pop	esi

; 8369 :     }
; 8370 : 
; 8371 :     return pressed;
; 8372 : }

	pop	ebp
	ret	0
$LN3@CheckboxFl:

; 8367 :         else
; 8368 :             *flags &= ~flags_value;

	not	esi
	and	DWORD PTR [edi], esi
$LN4@CheckboxFl:
	pop	edi
	pop	esi

; 8369 :     }
; 8370 : 
; 8371 :     return pressed;
; 8372 : }

	pop	ebp
	ret	0
?CheckboxFlags@ImGui@@YA_NPBDPAII@Z ENDP		; ImGui::CheckboxFlags
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_check_bb$ = -104					; size = 16
$T6 = -88						; size = 16
_total_bb$ = -88					; size = 16
$T7 = -80						; size = 8
$T8 = -80						; size = 8
$T9 = -80						; size = 8
$T10 = -72						; size = 8
_label_size$ = -64					; size = 8
$T11 = -56						; size = 8
$T12 = -56						; size = 8
_check_bb$3$ = -48					; size = 4
_check_bb$4$ = -44					; size = 4
$T13 = -40						; size = 4
$T14 = -36						; size = 8
$T15 = -32						; size = 4
$T4$sroa$421$1$ = -28					; size = 4
$T16 = -24						; size = 8
$T4$sroa$429$1$ = -20					; size = 4
_id$ = -16						; size = 4
$T17 = -12						; size = 4
$T18 = -8						; size = 4
_pressed$1$ = -3					; size = 1
_hovered$ = -2						; size = 1
_held$ = -1						; size = 1
_label$ = 8						; size = 4
_v$ = 12						; size = 4
?Checkbox@ImGui@@YA_NPBDPA_N@Z PROC			; ImGui::Checkbox

; 8311 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8311 : {

	sub	esp, 104				; 00000068H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	push	esi
	mov	BYTE PTR [eax+134], 1
	mov	esi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8313 :     if (window->SkipItems)

	cmp	BYTE PTR [esi+137], 0
	je	SHORT $LN2@Checkbox

; 8314 :         return false;

	xor	al, al
	pop	esi

; 8357 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@Checkbox:
	push	ebx

; 8315 : 
; 8316 :     ImGuiContext& g = *GImGui;

	mov	ebx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 8317 :     const ImGuiStyle& style = g.Style;
; 8318 :     const ImGuiID id = window->GetID(label);

	mov	ecx, esi
	push	edi
	push	0
	push	DWORD PTR _label$[ebp]
	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID

; 8319 :     const ImVec2 label_size = CalcTextSize(label, NULL, true);

	push	ecx
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	mov	edi, eax
	push	1
	push	0
	push	DWORD PTR _label$[ebp]
	lea	eax, DWORD PTR _label_size$[ebp]
	mov	DWORD PTR _id$[ebp], edi
	push	eax
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize

; 8321 :     const ImRect check_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(label_size.y + style.FramePadding.y*2, label_size.y + style.FramePadding.y*2));

	movss	xmm1, DWORD PTR [ebx+5360]

; 8322 :     ItemSize(check_bb, style.FramePadding.y);

	add	esp, 16					; 00000010H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm2, DWORD PTR [esi+192]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8321 :     const ImRect check_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(label_size.y + style.FramePadding.y*2, label_size.y + style.FramePadding.y*2));

	movaps	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [esi+192]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8321 :     const ImRect check_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(label_size.y + style.FramePadding.y*2, label_size.y + style.FramePadding.y*2));

	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _check_bb$3$[ebp], eax
	mov	DWORD PTR _check_bb$[ebp], eax
	mov	eax, DWORD PTR [esi+196]
	mov	DWORD PTR _check_bb$4$[ebp], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8321 :     const ImRect check_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(label_size.y + style.FramePadding.y*2, label_size.y + style.FramePadding.y*2));

	addss	xmm0, DWORD PTR _label_size$[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _check_bb$[ebp+4], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8322 :     ItemSize(check_bb, style.FramePadding.y);

	movss	DWORD PTR [esp], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm2, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T12[ebp], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T12[ebp]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	DWORD PTR $T17[ebp], xmm2
	movss	xmm2, DWORD PTR [esi+196]
	addss	xmm2, xmm0

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _check_bb$[ebp+8], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T12[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T12[ebp+4]
	mov	DWORD PTR _check_bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8322 :     ItemSize(check_bb, style.FramePadding.y);

	lea	eax, DWORD PTR _check_bb$[ebp]
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	DWORD PTR $T18[ebp], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8322 :     ItemSize(check_bb, style.FramePadding.y);

	call	?ItemSize@ImGui@@YAXABUImRect@@M@Z	; ImGui::ItemSize

; 8323 : 
; 8324 :     ImRect total_bb = check_bb;

	movss	xmm0, DWORD PTR _check_bb$[ebp]
	add	esp, 8

; 8325 :     if (label_size.x > 0)

	movss	xmm6, DWORD PTR _label_size$[ebp]
	movss	xmm2, DWORD PTR _check_bb$[ebp+4]
	movss	xmm1, DWORD PTR $T18[ebp]
	movss	DWORD PTR _total_bb$[ebp], xmm0
	movss	xmm0, DWORD PTR $T17[ebp]
	movss	DWORD PTR _total_bb$[ebp+8], xmm0
	xorps	xmm0, xmm0
	comiss	xmm6, xmm0
	movss	DWORD PTR _total_bb$[ebp+4], xmm2
	movss	DWORD PTR _total_bb$[ebp+12], xmm1
	jbe	SHORT $LN3@Checkbox

; 8326 :         SameLine(0, style.ItemInnerSpacing.x);

	movss	xmm0, DWORD PTR [ebx+5376]
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	movss	xmm1, DWORD PTR $T18[ebp]
	add	esp, 8
	movss	xmm2, DWORD PTR _check_bb$[ebp+4]
	movss	xmm6, DWORD PTR _label_size$[ebp]
$LN3@Checkbox:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm5, DWORD PTR [ebx+5360]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [esi+196]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm3, DWORD PTR [esi+192]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm4, DWORD PTR [esi+192]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm3, xmm6
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T15[ebp], xmm4
	movss	DWORD PTR $T10[ebp], xmm4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, DWORD PTR _label_size$[ebp+4]
	movss	DWORD PTR $T4$sroa$429$1$[ebp], xmm3
	movss	DWORD PTR $T4$sroa$421$1$[ebp], xmm0
	movss	xmm0, DWORD PTR [esi+196]
	addss	xmm0, xmm5
	movss	DWORD PTR $T13[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T10[ebp+4], xmm0
	xorps	xmm0, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8328 :     if (label_size.x > 0)

	comiss	xmm6, xmm0
	jbe	$LN4@Checkbox
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 246  :     float       GetWidth() const                { return Max.x-Min.x; }

	movaps	xmm0, xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8330 :         ItemSize(ImVec2(text_bb.GetWidth(), check_bb.GetHeight()), style.FramePadding.y);

	lea	eax, DWORD PTR $T9[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 246  :     float       GetWidth() const                { return Max.x-Min.x; }

	subss	xmm0, xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8330 :         ItemSize(ImVec2(text_bb.GetWidth(), check_bb.GetHeight()), style.FramePadding.y);

	push	ecx
	movss	DWORD PTR [esp], xmm5
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T9[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 247  :     float       GetHeight() const               { return Max.y-Min.y; }

	movaps	xmm0, xmm1
	subss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T9[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8330 :         ItemSize(ImVec2(text_bb.GetWidth(), check_bb.GetHeight()), style.FramePadding.y);

	call	?ItemSize@ImGui@@YAXABUImVec2@@M@Z	; ImGui::ItemSize
	movss	xmm0, DWORD PTR $T4$sroa$429$1$[ebp]
	add	esp, 8
	maxss	xmm0, DWORD PTR $T17[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T16[ebp], xmm0
	movss	xmm0, DWORD PTR $T4$sroa$421$1$[ebp]
	maxss	xmm0, DWORD PTR $T18[ebp]
	movss	DWORD PTR $T16[ebp+4], xmm0
	movss	xmm0, DWORD PTR _check_bb$[ebp]
	minss	xmm0, DWORD PTR $T15[ebp]
	movss	DWORD PTR $T14[ebp], xmm0
	movss	xmm0, DWORD PTR _check_bb$[ebp+4]
	minss	xmm0, DWORD PTR $T13[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T14[ebp]
	mov	DWORD PTR $T6[ebp], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T14[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T14[ebp+4]
	mov	DWORD PTR $T6[ebp+4], eax
	mov	eax, DWORD PTR $T16[ebp]
	mov	DWORD PTR $T6[ebp+8], eax
	mov	eax, DWORD PTR $T16[ebp+4]
	mov	DWORD PTR $T6[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8331 :         total_bb = ImRect(ImMin(check_bb.Min, text_bb.Min), ImMax(check_bb.Max, text_bb.Max));

	movups	xmm0, XMMWORD PTR $T6[ebp]
	movups	XMMWORD PTR _total_bb$[ebp], xmm0
$LN4@Checkbox:

; 8332 :     }
; 8333 : 
; 8334 :     if (!ItemAdd(total_bb, &id))

	push	0
	lea	eax, DWORD PTR _id$[ebp]
	push	eax
	lea	eax, DWORD PTR _total_bb$[ebp]
	push	eax
	call	?ItemAdd@ImGui@@YA_NABUImRect@@PBIPBU2@@Z ; ImGui::ItemAdd
	add	esp, 12					; 0000000cH
	test	al, al
	jne	SHORT $LN5@Checkbox
	pop	edi
	pop	ebx
	pop	esi

; 8357 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@Checkbox:

; 8335 :         return false;
; 8336 : 
; 8337 :     bool hovered, held;
; 8338 :     bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);

	push	0
	lea	eax, DWORD PTR _held$[ebp]
	push	eax
	lea	eax, DWORD PTR _hovered$[ebp]
	push	eax
	lea	eax, DWORD PTR _total_bb$[ebp]
	push	edi
	push	eax
	call	?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z ; ImGui::ButtonBehavior

; 8339 :     if (pressed)

	mov	edi, DWORD PTR _v$[ebp]
	add	esp, 20					; 00000014H
	mov	BYTE PTR _pressed$1$[ebp], al
	test	al, al
	je	SHORT $LN6@Checkbox

; 8340 :         *v = !(*v);

	cmp	BYTE PTR [edi], 0
	sete	cl
	mov	BYTE PTR [edi], cl
$LN6@Checkbox:

; 8341 : 
; 8342 :     RenderNavHighlight(total_bb, id);

	push	DWORD PTR _id$[ebp]
	lea	eax, DWORD PTR _total_bb$[ebp]
	push	eax
	call	?RenderNavHighlight@ImGui@@YAXABUImRect@@I@Z ; ImGui::RenderNavHighlight

; 8343 :     RenderFrame(check_bb.Min, check_bb.Max, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), true, style.FrameRounding);

	mov	cl, BYTE PTR _hovered$[ebp]
	add	esp, 8
	cmp	BYTE PTR _held$[ebp], 0
	je	SHORT $LN11@Checkbox
	test	cl, cl
	je	SHORT $LN11@Checkbox
	mov	eax, 9
	jmp	SHORT $LN12@Checkbox
$LN11@Checkbox:
	xor	eax, eax
	test	cl, cl
	setne	al
	add	eax, 7
$LN12@Checkbox:
	movss	xmm0, DWORD PTR [ebx+5364]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	1
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	eax
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	add	esp, 8
	push	eax
	push	DWORD PTR $T12[ebp+4]
	push	DWORD PTR $T12[ebp]
	push	DWORD PTR _check_bb$4$[ebp]
	push	DWORD PTR _check_bb$3$[ebp]
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame
	add	esp, 28					; 0000001cH

; 8344 :     if (*v)

	cmp	BYTE PTR [edi], 0
	je	$LN7@Checkbox
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 246  :     float       GetWidth() const                { return Max.x-Min.x; }

	movss	xmm4, DWORD PTR $T17[ebp]

; 247  :     float       GetHeight() const               { return Max.y-Min.y; }

	movss	xmm2, DWORD PTR $T18[ebp]

; 246  :     float       GetWidth() const                { return Max.x-Min.x; }

	movaps	xmm1, xmm4
	movss	xmm5, DWORD PTR _check_bb$[ebp]

; 247  :     float       GetHeight() const               { return Max.y-Min.y; }

	movaps	xmm0, xmm2
	movss	xmm3, DWORD PTR _check_bb$[ebp+4]

; 246  :     float       GetWidth() const                { return Max.x-Min.x; }

	subss	xmm1, xmm5

; 247  :     float       GetHeight() const               { return Max.y-Min.y; }

	subss	xmm0, xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8348 :         window->DrawList->AddRectFilled(check_bb.Min+ImVec2(pad,pad), check_bb.Max-ImVec2(pad,pad), GetColorU32(ImGuiCol_CheckMark), style.FrameRounding);

	push	-1
	sub	esp, 8
	minss	xmm1, xmm0
	mulss	xmm1, DWORD PTR __real@3e2aaaab
	cvttss2si eax, xmm1
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	maxss	xmm0, DWORD PTR __real@3f800000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm4, xmm0
	subss	xmm2, xmm0

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm5, xmm0
	addss	xmm3, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8348 :         window->DrawList->AddRectFilled(check_bb.Min+ImVec2(pad,pad), check_bb.Max-ImVec2(pad,pad), GetColorU32(ImGuiCol_CheckMark), style.FrameRounding);

	movss	xmm0, DWORD PTR [ebx+5364]
	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	19					; 00000013H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T8[ebp], xmm4
	movss	DWORD PTR $T8[ebp+4], xmm2
	movss	DWORD PTR $T11[ebp], xmm5
	movss	DWORD PTR $T11[ebp+4], xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8348 :         window->DrawList->AddRectFilled(check_bb.Min+ImVec2(pad,pad), check_bb.Max-ImVec2(pad,pad), GetColorU32(ImGuiCol_CheckMark), style.FrameRounding);

	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	ecx, DWORD PTR [esi+624]
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	lea	eax, DWORD PTR $T11[ebp]
	push	eax
	call	?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
$LN7@Checkbox:

; 8349 :     }
; 8350 : 
; 8351 :     if (g.LogEnabled)

	cmp	BYTE PTR [ebx+11600], 0
	mov	esi, DWORD PTR $T10[ebp+4]
	mov	ebx, DWORD PTR $T10[ebp]
	je	SHORT $LN8@Checkbox

; 8352 :         LogRenderedText(text_bb.GetTL(), *v ? "[x]" : "[ ]");

	cmp	BYTE PTR [edi], 0
	mov	ecx, OFFSET $SG120650
	mov	eax, OFFSET $SG120649
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 248  :     ImVec2      GetTL() const                   { return Min; }                   // Top-left

	mov	DWORD PTR $T7[ebp], ebx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8352 :         LogRenderedText(text_bb.GetTL(), *v ? "[x]" : "[ ]");

	cmove	eax, ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 248  :     ImVec2      GetTL() const                   { return Min; }                   // Top-left

	mov	DWORD PTR $T7[ebp+4], esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 8352 :         LogRenderedText(text_bb.GetTL(), *v ? "[x]" : "[ ]");

	push	0
	push	eax
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	call	?LogRenderedText@@YAXABUImVec2@@PBD1@Z	; LogRenderedText
	add	esp, 12					; 0000000cH
$LN8@Checkbox:

; 8353 :     if (label_size.x > 0.0f)

	movss	xmm0, DWORD PTR _label_size$[ebp]
	xorps	xmm1, xmm1
	comiss	xmm0, xmm1
	jbe	SHORT $LN9@Checkbox

; 8354 :         RenderText(text_bb.GetTL(), label);

	push	1
	push	0
	push	DWORD PTR _label$[ebp]
	push	esi
	push	ebx
	call	?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z	; ImGui::RenderText
	add	esp, 20					; 00000014H
$LN9@Checkbox:

; 8355 : 
; 8356 :     return pressed;

	mov	al, BYTE PTR _pressed$1$[ebp]
	pop	edi
	pop	ebx
	pop	esi

; 8357 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Checkbox@ImGui@@YA_NPBDPA_N@Z ENDP			; ImGui::Checkbox
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_image_bb$ = -64					; size = 16
_bb$ = -48						; size = 16
$T4 = -32						; size = 8
$T5 = -32						; size = 8
$T6 = -32						; size = 8
$T7 = -24						; size = 8
$T8 = -24						; size = 8
_padding$ = -16						; size = 8
_col$1$ = -8						; size = 4
_id$ = -8						; size = 4
_pressed$1$ = -3					; size = 1
_held$ = -2						; size = 1
_hovered$ = -1						; size = 1
_user_texture_id$ = 8					; size = 4
_size$ = 12						; size = 4
_uv0$ = 16						; size = 4
_uv1$ = 20						; size = 4
_frame_padding$ = 24					; size = 4
_bg_col$ = 28						; size = 4
_tint_col$ = 32						; size = 4
?ImageButton@ImGui@@YA_NPAXABUImVec2@@11HABUImVec4@@2@Z PROC ; ImGui::ImageButton

; 6727 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6727 : {

	sub	esp, 64					; 00000040H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	push	esi
	mov	BYTE PTR [eax+134], 1
	mov	esi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6729 :     if (window->SkipItems)

	cmp	BYTE PTR [esi+137], 0
	je	SHORT $LN2@ImageButto

; 6730 :         return false;

	xor	al, al
	pop	esi

; 6760 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@ImageButto:
	push	ebx
	push	edi

; 6731 : 
; 6732 :     ImGuiContext& g = *GImGui;
; 6733 :     const ImGuiStyle& style = g.Style;
; 6734 : 
; 6735 :     // Default to using texture ID as ID. User can still push string/integer prefixes.
; 6736 :     // We could hash the size/uv to create a unique ID but that would prevent the user from animating UV.
; 6737 :     PushID((void *)user_texture_id);

	push	DWORD PTR _user_texture_id$[ebp]
	mov	edi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	call	?PushID@ImGui@@YAXPBX@Z			; ImGui::PushID
	add	esp, 4

; 6738 :     const ImGuiID id = window->GetID("#image");

	mov	ecx, esi
	push	0
	push	OFFSET $SG119349
	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID
	mov	ebx, eax
	mov	DWORD PTR _id$[ebp], ebx

; 6739 :     PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 6741 :     const ImVec2 padding = (frame_padding >= 0) ? ImVec2((float)frame_padding, (float)frame_padding) : style.FramePadding;

	mov	eax, DWORD PTR _frame_padding$[ebp]
	lea	ecx, DWORD PTR $T6[ebp]
	test	eax, eax
	js	SHORT $LN6@ImageButto
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T6[ebp], xmm0
	movss	DWORD PTR $T6[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6741 :     const ImVec2 padding = (frame_padding >= 0) ? ImVec2((float)frame_padding, (float)frame_padding) : style.FramePadding;

	jmp	SHORT $LN7@ImageButto
$LN6@ImageButto:
	mov	eax, DWORD PTR [edi+5356]
	mov	DWORD PTR $T5[ebp], eax
	mov	eax, DWORD PTR [edi+5360]
	mov	DWORD PTR $T5[ebp+4], eax
$LN7@ImageButto:
	mov	eax, DWORD PTR [ecx]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [esi+196]
	movss	xmm1, DWORD PTR [esi+192]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6741 :     const ImVec2 padding = (frame_padding >= 0) ? ImVec2((float)frame_padding, (float)frame_padding) : style.FramePadding;

	mov	DWORD PTR _padding$[ebp], eax
	mov	eax, DWORD PTR [ecx+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	movss	xmm6, DWORD PTR _padding$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6741 :     const ImVec2 padding = (frame_padding >= 0) ? ImVec2((float)frame_padding, (float)frame_padding) : style.FramePadding;

	mov	DWORD PTR _padding$[ebp+4], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	movaps	xmm3, xmm6

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	mov	eax, DWORD PTR _size$[ebp]

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	movss	xmm7, DWORD PTR _padding$[ebp+4]
	mulss	xmm3, DWORD PTR __real@40000000
	movaps	xmm2, xmm7
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6744 :     ItemSize(bb);

	push	ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm4, DWORD PTR [eax+4]
	movss	xmm5, DWORD PTR [eax]
	addss	xmm0, xmm4

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	mulss	xmm2, DWORD PTR __real@40000000

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm1, xmm5

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [esi+192]
	mov	DWORD PTR _bb$[ebp], eax
	mov	eax, DWORD PTR [esi+196]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm2, xmm0

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _bb$[ebp+4], eax

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [esi+192]
	addss	xmm3, xmm1
	movss	xmm1, DWORD PTR [esi+196]
	addss	xmm0, xmm6
	addss	xmm1, xmm7
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6744 :     ItemSize(bb);

	mov	DWORD PTR [esp], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T8[ebp+4], xmm2
	movss	DWORD PTR $T8[ebp], xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T8[ebp]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm5, xmm0
	movss	xmm0, DWORD PTR [esi+192]
	addss	xmm4, xmm1
	addss	xmm0, xmm6

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _bb$[ebp+8], eax
	mov	eax, DWORD PTR $T8[ebp+4]
	mov	DWORD PTR _bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp], xmm5
	movss	DWORD PTR $T4[ebp+4], xmm4
	movss	DWORD PTR $T7[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [esi+196]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T7[ebp]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm7

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _image_bb$[ebp], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T7[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T7[ebp+4]
	mov	DWORD PTR _image_bb$[ebp+4], eax
	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR _image_bb$[ebp+8], eax
	mov	eax, DWORD PTR $T4[ebp+4]
	mov	DWORD PTR _image_bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6744 :     ItemSize(bb);

	lea	eax, DWORD PTR _bb$[ebp]
	push	eax
	call	?ItemSize@ImGui@@YAXABUImRect@@M@Z	; ImGui::ItemSize

; 6745 :     if (!ItemAdd(bb, &id))

	push	0
	lea	eax, DWORD PTR _id$[ebp]
	push	eax
	lea	eax, DWORD PTR _bb$[ebp]
	push	eax
	call	?ItemAdd@ImGui@@YA_NABUImRect@@PBIPBU2@@Z ; ImGui::ItemAdd
	add	esp, 20					; 00000014H
	test	al, al
	jne	SHORT $LN3@ImageButto
	pop	edi
	pop	ebx
	pop	esi

; 6760 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@ImageButto:

; 6746 :         return false;
; 6747 : 
; 6748 :     bool hovered, held;
; 6749 :     bool pressed = ButtonBehavior(bb, id, &hovered, &held);

	push	0
	lea	eax, DWORD PTR _held$[ebp]
	push	eax
	lea	eax, DWORD PTR _hovered$[ebp]
	push	eax
	lea	eax, DWORD PTR _bb$[ebp]
	push	ebx
	push	eax
	call	?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z ; ImGui::ButtonBehavior

; 6750 : 
; 6751 :     // Render
; 6752 :     const ImU32 col = GetColorU32((hovered && held) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);

	mov	dl, BYTE PTR _hovered$[ebp]
	add	esp, 20					; 00000014H
	mov	BYTE PTR _pressed$1$[ebp], al
	test	dl, dl
	je	SHORT $LN8@ImageButto
	cmp	BYTE PTR _held$[ebp], 0
	je	SHORT $LN8@ImageButto
	mov	ecx, 24					; 00000018H
	jmp	SHORT $LN9@ImageButto
$LN8@ImageButto:
	xor	ecx, ecx
	test	dl, dl
	setne	cl
	add	ecx, 22					; 00000016H
$LN9@ImageButto:
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	ecx
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	DWORD PTR _col$1$[ebp], eax

; 6753 :     RenderNavHighlight(bb, id);

	lea	eax, DWORD PTR _bb$[ebp]
	push	ebx
	push	eax
	call	?RenderNavHighlight@ImGui@@YAXABUImRect@@I@Z ; ImGui::RenderNavHighlight
	movss	xmm1, DWORD PTR _padding$[ebp]
	xorps	xmm0, xmm0
	minss	xmm1, DWORD PTR _padding$[ebp+4]
	add	esp, 16					; 00000010H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm0, xmm1
	ja	SHORT $LN51@ImageButto
	movss	xmm0, DWORD PTR [edi+5364]
	minss	xmm0, xmm1
$LN51@ImageButto:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6754 :     RenderFrame(bb.Min, bb.Max, col, true, ImClamp((float)ImMin(padding.x, padding.y), 0.0f, style.FrameRounding));

	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	1
	push	DWORD PTR _col$1$[ebp]
	push	DWORD PTR _bb$[ebp+12]
	push	DWORD PTR _bb$[ebp+8]
	push	DWORD PTR _bb$[ebp+4]
	push	DWORD PTR _bb$[ebp]
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame

; 6755 :     if (bg_col.w > 0.0f)

	mov	eax, DWORD PTR _bg_col$[ebp]
	add	esp, 28					; 0000001cH
	movss	xmm0, DWORD PTR [eax+12]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN4@ImageButto

; 6756 :         window->DrawList->AddRectFilled(image_bb.Min, image_bb.Max, GetColorU32(bg_col));

	push	-1
	push	ecx
	mov	DWORD PTR [esp], 0
	push	eax
	call	?GetColorU32@ImGui@@YAIABUImVec4@@@Z	; ImGui::GetColorU32
	mov	ecx, DWORD PTR [esi+624]
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _image_bb$[ebp+8]
	push	eax
	lea	eax, DWORD PTR _image_bb$[ebp]
	push	eax
	call	?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
$LN4@ImageButto:

; 6757 :     window->DrawList->AddImage(user_texture_id, image_bb.Min, image_bb.Max, uv0, uv1, GetColorU32(tint_col));

	push	DWORD PTR _tint_col$[ebp]
	call	?GetColorU32@ImGui@@YAIABUImVec4@@@Z	; ImGui::GetColorU32
	mov	ecx, DWORD PTR [esi+624]
	add	esp, 4
	push	eax
	push	DWORD PTR _uv1$[ebp]
	lea	eax, DWORD PTR _image_bb$[ebp+8]
	push	DWORD PTR _uv0$[ebp]
	push	eax
	lea	eax, DWORD PTR _image_bb$[ebp]
	push	eax
	push	DWORD PTR _user_texture_id$[ebp]
	call	?AddImage@ImDrawList@@QAEXPAXABUImVec2@@111I@Z ; ImDrawList::AddImage

; 6758 : 
; 6759 :     return pressed;

	mov	al, BYTE PTR _pressed$1$[ebp]
	pop	edi
	pop	ebx
	pop	esi

; 6760 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ImageButton@ImGui@@YA_NPAXABUImVec2@@11HABUImVec4@@2@Z ENDP ; ImGui::ImageButton
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_bb$ = -32						; size = 16
$T1 = -16						; size = 8
$T2 = -8						; size = 8
$T3 = -8						; size = 8
_user_texture_id$ = 8					; size = 4
_size$ = 12						; size = 4
_uv0$ = 16						; size = 4
_uv1$ = 20						; size = 4
_tint_col$ = 24						; size = 4
_border_col$ = 28					; size = 4
?Image@ImGui@@YAXPAXABUImVec2@@11ABUImVec4@@2@Z PROC	; ImGui::Image

; 6699 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6699 : {

	sub	esp, 32					; 00000020H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	push	esi
	mov	BYTE PTR [eax+134], 1
	mov	esi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6701 :     if (window->SkipItems)

	cmp	BYTE PTR [esi+137], 0
	jne	$LN6@Image
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	mov	eax, DWORD PTR _size$[ebp]
	xorps	xmm1, xmm1
	movss	xmm0, DWORD PTR [esi+196]
	push	edi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6705 :     if (border_col.w > 0.0f)

	mov	edi, DWORD PTR _border_col$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm2, DWORD PTR [eax]
	addss	xmm0, DWORD PTR [eax+4]
	addss	xmm2, DWORD PTR [esi+192]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [esi+192]
	mov	DWORD PTR _bb$[ebp], eax
	mov	eax, DWORD PTR [esi+196]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6705 :     if (border_col.w > 0.0f)

	movss	xmm0, DWORD PTR [edi+12]
	comiss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _bb$[ebp+4], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR _bb$[ebp+8], eax
	mov	eax, DWORD PTR $T3[ebp+4]
	mov	DWORD PTR _bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6705 :     if (border_col.w > 0.0f)

	jbe	SHORT $LN3@Image
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 118  : static inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }

	movss	xmm0, DWORD PTR _bb$[ebp+12]
	addss	xmm2, DWORD PTR __real@40000000
	addss	xmm0, DWORD PTR __real@40000000
	movss	DWORD PTR _bb$[ebp+8], xmm2
	movss	DWORD PTR _bb$[ebp+12], xmm0
$LN3@Image:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6707 :     ItemSize(bb);

	push	ecx
	lea	eax, DWORD PTR _bb$[ebp]
	mov	DWORD PTR [esp], 0
	push	eax
	call	?ItemSize@ImGui@@YAXABUImRect@@M@Z	; ImGui::ItemSize

; 6708 :     if (!ItemAdd(bb, NULL))

	push	0
	lea	eax, DWORD PTR _bb$[ebp]
	push	0
	push	eax
	call	?ItemAdd@ImGui@@YA_NABUImRect@@PBIPBU2@@Z ; ImGui::ItemAdd
	add	esp, 20					; 00000014H
	test	al, al
	je	$LN32@Image

; 6709 :         return;
; 6710 : 
; 6711 :     if (border_col.w > 0.0f)

	movss	xmm0, DWORD PTR [edi+12]
	xorps	xmm1, xmm1
	comiss	xmm0, xmm1
	jbe	$LN5@Image

; 6712 :     {
; 6713 :         window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(border_col), 0.0f);

	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	-1
	push	ecx
	mov	DWORD PTR [esp], 0
	push	edi
	call	?GetColorU32@ImGui@@YAIABUImVec4@@@Z	; ImGui::GetColorU32
	mov	ecx, DWORD PTR [esi+624]
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _bb$[ebp+8]
	push	eax
	lea	eax, DWORD PTR _bb$[ebp]
	push	eax
	call	?AddRect@ImDrawList@@QAEXABUImVec2@@0IMHM@Z ; ImDrawList::AddRect
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm1, DWORD PTR __real@3f800000
	movss	xmm0, DWORD PTR _bb$[ebp+8]
	subss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6714 :         window->DrawList->AddImage(user_texture_id, bb.Min+ImVec2(1,1), bb.Max-ImVec2(1,1), uv0, uv1, GetColorU32(tint_col));

	push	DWORD PTR _tint_col$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR _bb$[ebp+12]
	subss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR _bb$[ebp]
	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR _bb$[ebp+4]
	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6714 :         window->DrawList->AddImage(user_texture_id, bb.Min+ImVec2(1,1), bb.Max-ImVec2(1,1), uv0, uv1, GetColorU32(tint_col));

	call	?GetColorU32@ImGui@@YAIABUImVec4@@@Z	; ImGui::GetColorU32
	add	esp, 4
	push	eax
	push	DWORD PTR _uv1$[ebp]
	lea	eax, DWORD PTR $T2[ebp]
	push	DWORD PTR _uv0$[ebp]
	push	eax
	lea	eax, DWORD PTR $T1[ebp]

; 6715 :     }
; 6716 :     else

	jmp	SHORT $LN33@Image
$LN5@Image:

; 6717 :     {
; 6718 :         window->DrawList->AddImage(user_texture_id, bb.Min, bb.Max, uv0, uv1, GetColorU32(tint_col));

	push	DWORD PTR _tint_col$[ebp]
	call	?GetColorU32@ImGui@@YAIABUImVec4@@@Z	; ImGui::GetColorU32
	add	esp, 4
	push	eax
	push	DWORD PTR _uv1$[ebp]
	lea	eax, DWORD PTR _bb$[ebp+8]
	push	DWORD PTR _uv0$[ebp]
	push	eax
	lea	eax, DWORD PTR _bb$[ebp]
$LN33@Image:
	mov	ecx, DWORD PTR [esi+624]
	push	eax
	push	DWORD PTR _user_texture_id$[ebp]
	call	?AddImage@ImDrawList@@QAEXPAXABUImVec2@@111I@Z ; ImDrawList::AddImage
$LN32@Image:
	pop	edi
$LN6@Image:
	pop	esi

; 6719 :     }
; 6720 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Image@ImGui@@YAXPAXABUImVec2@@11ABUImVec4@@2@Z ENDP	; ImGui::Image
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_bb$ = -32						; size = 16
_size$ = -24						; size = 8
$T1 = -16						; size = 8
_id$ = -8						; size = 4
_hovered$ = -2						; size = 1
_held$ = -1						; size = 1
_str_id$ = 8						; size = 4
_size_arg$ = 12						; size = 4
?InvisibleButton@ImGui@@YA_NPBDABUImVec2@@@Z PROC	; ImGui::InvisibleButton

; 6653 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6653 : {

	sub	esp, 32					; 00000020H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	push	esi
	mov	BYTE PTR [eax+134], 1
	mov	esi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6655 :     if (window->SkipItems)

	cmp	BYTE PTR [esi+137], 0
	je	SHORT $LN2@InvisibleB

; 6656 :         return false;

	xor	al, al
	pop	esi

; 6667 : 
; 6668 :     return pressed;
; 6669 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@InvisibleB:
	push	edi

; 6657 : 
; 6658 :     const ImGuiID id = window->GetID(str_id);

	push	0
	push	DWORD PTR _str_id$[ebp]
	mov	ecx, esi
	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID

; 6659 :     ImVec2 size = CalcItemSize(size_arg, 0.0f, 0.0f);

	mov	ecx, DWORD PTR _size_arg$[ebp]
	sub	esp, 8
	mov	edi, eax
	lea	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _id$[ebp], edi
	mov	DWORD PTR [esp+4], 0
	mov	DWORD PTR [esp], 0
	push	DWORD PTR [ecx+4]
	push	DWORD PTR [ecx]
	push	eax
	call	?CalcItemSize@ImGui@@YA?AUImVec2@@U2@MM@Z ; ImGui::CalcItemSize
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [esi+192]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6661 :     ItemSize(bb);

	add	esp, 16					; 00000010H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, DWORD PTR _size$[ebp]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [esi+192]
	mov	DWORD PTR _bb$[ebp], eax
	mov	eax, DWORD PTR [esi+196]
	mov	DWORD PTR _bb$[ebp+4], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [esi+196]
	addss	xmm0, DWORD PTR _size$[ebp+4]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _bb$[ebp+8], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6661 :     ItemSize(bb);

	mov	DWORD PTR [esp], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR _bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6661 :     ItemSize(bb);

	lea	eax, DWORD PTR _bb$[ebp]
	push	eax
	call	?ItemSize@ImGui@@YAXABUImRect@@M@Z	; ImGui::ItemSize

; 6662 :     if (!ItemAdd(bb, &id))

	push	0
	lea	eax, DWORD PTR _id$[ebp]
	push	eax
	lea	eax, DWORD PTR _bb$[ebp]
	push	eax
	call	?ItemAdd@ImGui@@YA_NABUImRect@@PBIPBU2@@Z ; ImGui::ItemAdd
	add	esp, 20					; 00000014H
	test	al, al
	jne	SHORT $LN3@InvisibleB
	pop	edi
	pop	esi

; 6667 : 
; 6668 :     return pressed;
; 6669 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@InvisibleB:

; 6663 :         return false;
; 6664 : 
; 6665 :     bool hovered, held;
; 6666 :     bool pressed = ButtonBehavior(bb, id, &hovered, &held);

	push	0
	lea	eax, DWORD PTR _held$[ebp]
	push	eax
	lea	eax, DWORD PTR _hovered$[ebp]
	push	eax
	lea	eax, DWORD PTR _bb$[ebp]
	push	edi
	push	eax
	call	?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z ; ImGui::ButtonBehavior
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi

; 6667 : 
; 6668 :     return pressed;
; 6669 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InvisibleButton@ImGui@@YA_NPBDABUImVec2@@@Z ENDP	; ImGui::InvisibleButton
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 8
_backup_padding_y$1$ = -4				; size = 4
_label$ = 8						; size = 4
?SmallButton@ImGui@@YA_NPBD@Z PROC			; ImGui::SmallButton

; 6641 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi

; 6642 :     ImGuiContext& g = *GImGui;

	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 6645 :     bool pressed = ButtonEx(label, ImVec2(0,0), ImGuiButtonFlags_AlignTextBaseLine);

	lea	eax, DWORD PTR $T1[ebp]
	push	256					; 00000100H
	push	eax
	push	DWORD PTR _label$[ebp]
	movss	xmm0, DWORD PTR [esi+5360]
	movss	DWORD PTR _backup_padding_y$1$[ebp], xmm0
	mov	DWORD PTR [esi+5360], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp], 0
	mov	DWORD PTR $T1[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6645 :     bool pressed = ButtonEx(label, ImVec2(0,0), ImGuiButtonFlags_AlignTextBaseLine);

	call	?ButtonEx@ImGui@@YA_NPBDABUImVec2@@H@Z	; ImGui::ButtonEx

; 6646 :     g.Style.FramePadding.y = backup_padding_y;

	movss	xmm0, DWORD PTR _backup_padding_y$1$[ebp]
	add	esp, 12					; 0000000cH
	movss	DWORD PTR [esi+5360], xmm0
	pop	esi

; 6647 :     return pressed;
; 6648 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SmallButton@ImGui@@YA_NPBD@Z ENDP			; ImGui::SmallButton
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_size_arg$ = 12						; size = 4
?Button@ImGui@@YA_NPBDABUImVec2@@@Z PROC		; ImGui::Button

; 6635 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 6636 :     return ButtonEx(label, size_arg, 0);

	push	0
	push	DWORD PTR _size_arg$[ebp]
	push	DWORD PTR _label$[ebp]
	call	?ButtonEx@ImGui@@YA_NPBDABUImVec2@@H@Z	; ImGui::ButtonEx
	add	esp, 12					; 0000000cH

; 6637 : }

	pop	ebp
	ret	0
?Button@ImGui@@YA_NPBDABUImVec2@@@Z ENDP		; ImGui::Button
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_bb$ = -36						; size = 16
$T4 = -20						; size = 8
$T5 = -20						; size = 8
$T6 = -20						; size = 8
_label_size$ = -20					; size = 8
_text_end$1$ = -12					; size = 4
_text_base_offset_y$1$ = -8				; size = 4
_line_height$1$ = -4					; size = 4
_fmt$ = 8						; size = 4
_args$ = 12						; size = 4
?BulletTextV@ImGui@@YAXPBDPAD@Z PROC			; ImGui::BulletTextV

; 7231 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7231 : {

	sub	esp, 36					; 00000024H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	push	esi
	mov	BYTE PTR [eax+134], 1
	mov	esi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7233 :     if (window->SkipItems)

	cmp	BYTE PTR [esi+137], 0
	jne	$LN1@BulletText

; 7234 :         return;
; 7235 : 
; 7236 :     ImGuiContext& g = *GImGui;
; 7237 :     const ImGuiStyle& style = g.Style;
; 7238 : 
; 7239 :     const char* text_begin = g.TempBuffer;
; 7240 :     const char* text_end = text_begin + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);

	push	ebx
	push	edi
	push	DWORD PTR _args$[ebp]
	mov	edi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	DWORD PTR _fmt$[ebp]
	push	3073					; 00000c01H
	lea	ebx, DWORD PTR [edi+12116]
	push	ebx
	call	?ImFormatStringV@@YAHPADHPBD0@Z		; ImFormatStringV

; 7241 :     const ImVec2 label_size = CalcTextSize(text_begin, text_end, false);

	add	esp, 12					; 0000000cH
	add	eax, ebx
	mov	DWORD PTR _text_end$1$[ebp], eax
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	push	0
	push	eax
	lea	eax, DWORD PTR _label_size$[ebp]
	push	ebx
	push	eax
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize

; 7242 :     const float text_base_offset_y = ImMax(0.0f, window->DC.CurrentLineTextBaseOffset); // Latch before ItemSize changes it
; 7243 :     const float line_height = ImMax(ImMin(window->DC.CurrentLineHeight, g.FontSize + g.Style.FramePadding.y*2), g.FontSize);

	movss	xmm2, DWORD PTR [edi+5360]
	xorps	xmm0, xmm0
	mulss	xmm2, DWORD PTR __real@40000000
	add	esp, 20					; 00000014H
	movss	xmm3, DWORD PTR [edi+6172]
	movss	xmm1, DWORD PTR [esi+228]
	addss	xmm2, xmm3
	maxss	xmm1, xmm0
	minss	xmm2, DWORD PTR [esi+224]
	movss	DWORD PTR _text_base_offset_y$1$[ebp], xmm1

; 7244 :     const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(g.FontSize + (label_size.x > 0.0f ? (label_size.x + style.FramePadding.x*2) : 0.0f), ImMax(line_height, label_size.y)));  // Empty text doesn't add padding

	movss	xmm1, DWORD PTR _label_size$[ebp]
	comiss	xmm1, xmm0
	maxss	xmm2, xmm3
	movss	DWORD PTR _line_height$1$[ebp], xmm2
	jbe	SHORT $LN5@BulletText
	movss	xmm0, DWORD PTR [edi+5356]
	addss	xmm0, xmm0
	addss	xmm0, xmm1
$LN5@BulletText:
	movss	xmm1, DWORD PTR _label_size$[ebp+4]
	addss	xmm3, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [esi+192]
	maxss	xmm1, xmm2

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [esi+192]
	mov	DWORD PTR _bb$[ebp], eax
	mov	eax, DWORD PTR [esi+196]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm3

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _bb$[ebp+4], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7245 :     ItemSize(bb);

	push	ecx
	mov	DWORD PTR [esp], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T6[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [esi+196]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T6[ebp]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm1

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _bb$[ebp+8], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T6[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T6[ebp+4]
	mov	DWORD PTR _bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7245 :     ItemSize(bb);

	lea	eax, DWORD PTR _bb$[ebp]
	push	eax
	call	?ItemSize@ImGui@@YAXABUImRect@@M@Z	; ImGui::ItemSize

; 7246 :     if (!ItemAdd(bb, NULL))

	push	0
	lea	eax, DWORD PTR _bb$[ebp]
	push	0
	push	eax
	call	?ItemAdd@ImGui@@YA_NABUImRect@@PBIPBU2@@Z ; ImGui::ItemAdd
	add	esp, 20					; 00000014H
	test	al, al
	je	$LN45@BulletText

; 7250 :     RenderBullet(bb.Min + ImVec2(style.FramePadding.x + g.FontSize*0.5f, line_height*0.5f));

	movss	xmm1, DWORD PTR [edi+6172]
	mulss	xmm1, DWORD PTR __real@3f000000
	movss	xmm2, DWORD PTR _line_height$1$[ebp]
	mulss	xmm2, DWORD PTR __real@3f000000
	addss	xmm1, DWORD PTR [edi+5356]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR _bb$[ebp]
	addss	xmm2, DWORD PTR _bb$[ebp+4]
	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T5[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7250 :     RenderBullet(bb.Min + ImVec2(style.FramePadding.x + g.FontSize*0.5f, line_height*0.5f));

	push	DWORD PTR $T5[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T5[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7250 :     RenderBullet(bb.Min + ImVec2(style.FramePadding.x + g.FontSize*0.5f, line_height*0.5f));

	push	DWORD PTR $T5[ebp]
	call	?RenderBullet@ImGui@@YAXUImVec2@@@Z	; ImGui::RenderBullet

; 7251 :     RenderText(bb.Min+ImVec2(g.FontSize + style.FramePadding.x*2, text_base_offset_y), text_begin, text_end, false);

	movss	xmm0, DWORD PTR [edi+5356]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm1, DWORD PTR _bb$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7251 :     RenderText(bb.Min+ImVec2(g.FontSize + style.FramePadding.x*2, text_base_offset_y), text_begin, text_end, false);

	addss	xmm0, xmm0
	push	0
	push	DWORD PTR _text_end$1$[ebp]
	push	ebx
	addss	xmm0, DWORD PTR [edi+6172]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR _bb$[ebp+4]
	addss	xmm0, DWORD PTR _text_base_offset_y$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp], xmm1
	movss	DWORD PTR $T4[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7251 :     RenderText(bb.Min+ImVec2(g.FontSize + style.FramePadding.x*2, text_base_offset_y), text_begin, text_end, false);

	push	DWORD PTR $T4[ebp+4]
	push	DWORD PTR $T4[ebp]
	call	?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z	; ImGui::RenderText
	add	esp, 28					; 0000001cH
$LN45@BulletText:
	pop	edi
	pop	ebx
$LN1@BulletText:
	pop	esi

; 7252 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?BulletTextV@ImGui@@YAXPBDPAD@Z ENDP			; ImGui::BulletTextV
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_fmt$ = 8						; size = 4
?BulletText@ImGui@@YAXPBDZZ PROC			; ImGui::BulletText

; 7255 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 7256 :     va_list args;
; 7257 :     va_start(args, fmt);
; 7258 :     BulletTextV(fmt, args);

	lea	eax, DWORD PTR _fmt$[ebp+4]
	push	eax
	push	DWORD PTR _fmt$[ebp]
	call	?BulletTextV@ImGui@@YAXPBDPAD@Z		; ImGui::BulletTextV
	add	esp, 8

; 7259 :     va_end(args);
; 7260 : }

	pop	ebp
	ret	0
?BulletText@ImGui@@YAXPBDZZ ENDP			; ImGui::BulletText
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_bb$ = -28						; size = 16
$T3 = -12						; size = 8
$T4 = -12						; size = 8
_line_height$1$ = -4					; size = 4
?Bullet@ImGui@@YAXXZ PROC				; ImGui::Bullet

; 7208 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7208 : {

	sub	esp, 28					; 0000001cH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	ecx, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7210 :     if (window->SkipItems)

	cmp	BYTE PTR [ecx+137], 0
	jne	$LN1@Bullet
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [ecx+192]
	push	esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7213 :     ImGuiContext& g = *GImGui;

	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [ecx+192]
	mov	DWORD PTR _bb$[ebp], eax
	mov	eax, DWORD PTR [ecx+196]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7215 :     const float line_height = ImMax(ImMin(window->DC.CurrentLineHeight, g.FontSize + g.Style.FramePadding.y*2), g.FontSize);

	movss	xmm2, DWORD PTR [esi+5360]
	mulss	xmm2, DWORD PTR __real@40000000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _bb$[ebp+4], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7215 :     const float line_height = ImMax(ImMin(window->DC.CurrentLineHeight, g.FontSize + g.Style.FramePadding.y*2), g.FontSize);

	movss	xmm1, DWORD PTR [esi+6172]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7215 :     const float line_height = ImMax(ImMin(window->DC.CurrentLineHeight, g.FontSize + g.Style.FramePadding.y*2), g.FontSize);

	addss	xmm2, xmm1

; 7217 :     ItemSize(bb);

	push	ecx
	mov	DWORD PTR [esp], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp], xmm0
	minss	xmm2, DWORD PTR [ecx+224]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [ecx+196]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR _bb$[ebp+8], eax
	maxss	xmm2, xmm1

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm2
	movss	DWORD PTR _line_height$1$[ebp], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T4[ebp+4]
	mov	DWORD PTR _bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7217 :     ItemSize(bb);

	lea	eax, DWORD PTR _bb$[ebp]
	push	eax
	call	?ItemSize@ImGui@@YAXABUImRect@@M@Z	; ImGui::ItemSize

; 7218 :     if (!ItemAdd(bb, NULL))

	push	0
	lea	eax, DWORD PTR _bb$[ebp]
	push	0
	push	eax
	call	?ItemAdd@ImGui@@YA_NABUImRect@@PBIPBU2@@Z ; ImGui::ItemAdd
	add	esp, 20					; 00000014H
	test	al, al
	jne	SHORT $LN3@Bullet

; 7219 :     {
; 7220 :         SameLine(0, style.FramePadding.x*2);

	sub	esp, 8

; 7221 :         return;

	jmp	SHORT $LN30@Bullet
$LN3@Bullet:

; 7225 :     RenderBullet(bb.Min + ImVec2(style.FramePadding.x + g.FontSize*0.5f, line_height*0.5f));

	movss	xmm1, DWORD PTR [esi+6172]
	mulss	xmm1, DWORD PTR __real@3f000000
	movss	xmm2, DWORD PTR _line_height$1$[ebp]
	mulss	xmm2, DWORD PTR __real@3f000000
	addss	xmm1, DWORD PTR [esi+5356]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm2, DWORD PTR _bb$[ebp+4]
	addss	xmm1, DWORD PTR _bb$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7225 :     RenderBullet(bb.Min + ImVec2(style.FramePadding.x + g.FontSize*0.5f, line_height*0.5f));

	push	DWORD PTR $T3[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7225 :     RenderBullet(bb.Min + ImVec2(style.FramePadding.x + g.FontSize*0.5f, line_height*0.5f));

	push	DWORD PTR $T3[ebp]
	call	?RenderBullet@ImGui@@YAXUImVec2@@@Z	; ImGui::RenderBullet
$LN30@Bullet:

; 7226 :     SameLine(0, style.FramePadding.x*2);

	movss	xmm0, DWORD PTR [esi+5356]
	addss	xmm0, xmm0
	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	add	esp, 8
	pop	esi
$LN1@Bullet:

; 7227 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Bullet@ImGui@@YAXXZ ENDP				; ImGui::Bullet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_total_bb$ = -48					; size = 16
_value_bb$ = -32					; size = 16
$T4 = -16						; size = 8
_label_size$ = -16					; size = 8
$T5 = -8						; size = 8
$T6 = -8						; size = 8
$T7 = -8						; size = 8
_w$ = -4						; size = 4
_label$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?LabelTextV@ImGui@@YAXPBD0PAD@Z PROC			; ImGui::LabelTextV

; 6443 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6443 : {

	sub	esp, 48					; 00000030H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	push	esi
	mov	BYTE PTR [eax+134], 1
	mov	esi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6445 :     if (window->SkipItems)

	cmp	BYTE PTR [esi+137], 0
	jne	$LN4@LabelTextV

; 6446 :         return;
; 6447 : 
; 6448 :     ImGuiContext& g = *GImGui;

	push	edi
	mov	edi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 6449 :     const ImGuiStyle& style = g.Style;
; 6450 :     const float w = CalcItemWidth();

	call	?CalcItemWidth@ImGui@@YAMXZ		; ImGui::CalcItemWidth

; 6451 : 
; 6452 :     const ImVec2 label_size = CalcTextSize(label, NULL, true);

	push	ecx
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	lea	eax, DWORD PTR _label_size$[ebp]
	push	1
	push	0
	push	DWORD PTR _label$[ebp]
	fstp	DWORD PTR _w$[ebp]
	push	eax
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize

; 6453 :     const ImRect value_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2));

	movss	xmm4, DWORD PTR [edi+5360]
	add	esp, 20					; 00000014H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [esi+192]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6453 :     const ImRect value_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2));

	movaps	xmm3, xmm4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm6, DWORD PTR _w$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6453 :     const ImRect value_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2));

	addss	xmm3, xmm4
	movss	xmm5, DWORD PTR _label_size$[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm6

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [esi+192]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6454 :     const ImRect total_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w + (label_size.x > 0.0f ? style.ItemInnerSpacing.x : 0.0f), style.FramePadding.y*2) + label_size);

	movss	xmm2, DWORD PTR _label_size$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _value_bb$[ebp], eax
	mov	eax, DWORD PTR [esi+196]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6453 :     const ImRect value_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2));

	movaps	xmm1, xmm3
	addss	xmm1, xmm5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T7[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [esi+196]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _value_bb$[ebp+4], eax
	mov	eax, DWORD PTR $T7[ebp]
	mov	DWORD PTR _value_bb$[ebp+8], eax

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T7[ebp+4], xmm0
	xorps	xmm0, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6454 :     const ImRect total_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w + (label_size.x > 0.0f ? style.ItemInnerSpacing.x : 0.0f), style.FramePadding.y*2) + label_size);

	comiss	xmm2, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T7[ebp+4]
	mov	DWORD PTR _value_bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6454 :     const ImRect total_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w + (label_size.x > 0.0f ? style.ItemInnerSpacing.x : 0.0f), style.FramePadding.y*2) + label_size);

	jbe	SHORT $LN6@LabelTextV
	movss	xmm1, DWORD PTR [edi+5376]
	jmp	SHORT $LN7@LabelTextV
$LN6@LabelTextV:
	xorps	xmm1, xmm1
$LN7@LabelTextV:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [esi+192]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6454 :     const ImRect total_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w + (label_size.x > 0.0f ? style.ItemInnerSpacing.x : 0.0f), style.FramePadding.y*2) + label_size);

	addss	xmm1, xmm6
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [esi+192]
	mov	DWORD PTR _total_bb$[ebp], eax
	mov	eax, DWORD PTR [esi+196]
	mov	DWORD PTR _total_bb$[ebp+4], eax

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR [esi+196]
	addss	xmm1, xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6455 :     ItemSize(total_bb, style.FramePadding.y);

	push	ecx
	movss	DWORD PTR [esp], xmm4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm2
	addss	xmm1, xmm5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T6[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR _total_bb$[ebp+8], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T6[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T6[ebp+4]
	mov	DWORD PTR _total_bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6455 :     ItemSize(total_bb, style.FramePadding.y);

	lea	eax, DWORD PTR _total_bb$[ebp]
	push	eax
	call	?ItemSize@ImGui@@YAXABUImRect@@M@Z	; ImGui::ItemSize

; 6456 :     if (!ItemAdd(total_bb, NULL))

	push	0
	lea	eax, DWORD PTR _total_bb$[ebp]
	push	0
	push	eax
	call	?ItemAdd@ImGui@@YA_NABUImRect@@PBIPBU2@@Z ; ImGui::ItemAdd
	add	esp, 20					; 00000014H
	test	al, al
	je	$LN34@LabelTextV

; 6457 :         return;
; 6458 : 
; 6459 :     // Render
; 6460 :     const char* value_text_begin = &g.TempBuffer[0];
; 6461 :     const char* value_text_end = value_text_begin + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);

	push	DWORD PTR _args$[ebp]
	lea	esi, DWORD PTR [edi+12116]
	push	DWORD PTR _fmt$[ebp]
	push	3073					; 00000c01H
	push	esi
	call	?ImFormatStringV@@YAHPADHPBD0@Z		; ImFormatStringV

; 6462 :     RenderTextClipped(value_bb.Min, value_bb.Max, value_text_begin, value_text_end, NULL, ImVec2(0.0f,0.5f));

	push	0
	lea	ecx, DWORD PTR $T5[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T5[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6462 :     RenderTextClipped(value_bb.Min, value_bb.Max, value_text_begin, value_text_end, NULL, ImVec2(0.0f,0.5f));

	push	ecx
	add	eax, esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T5[ebp+4], 1056964608	; 3f000000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6462 :     RenderTextClipped(value_bb.Min, value_bb.Max, value_text_begin, value_text_end, NULL, ImVec2(0.0f,0.5f));

	push	0
	push	eax
	push	esi
	lea	eax, DWORD PTR _value_bb$[ebp+8]
	push	eax
	lea	eax, DWORD PTR _value_bb$[ebp]
	push	eax
	call	?RenderTextClipped@ImGui@@YAXABUImVec2@@0PBD1PBU2@0PBUImRect@@@Z ; ImGui::RenderTextClipped

; 6463 :     if (label_size.x > 0.0f)

	movss	xmm1, DWORD PTR _label_size$[ebp]
	xorps	xmm0, xmm0
	add	esp, 44					; 0000002cH
	comiss	xmm1, xmm0
	jbe	SHORT $LN34@LabelTextV

; 6464 :         RenderText(ImVec2(value_bb.Max.x + style.ItemInnerSpacing.x, value_bb.Min.y + style.FramePadding.y), label);

	movss	xmm0, DWORD PTR [edi+5376]
	addss	xmm0, DWORD PTR _value_bb$[ebp+8]
	push	1
	push	0
	push	DWORD PTR _label$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6464 :         RenderText(ImVec2(value_bb.Max.x + style.ItemInnerSpacing.x, value_bb.Min.y + style.FramePadding.y), label);

	movss	xmm0, DWORD PTR [edi+5360]
	addss	xmm0, DWORD PTR _value_bb$[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6464 :         RenderText(ImVec2(value_bb.Max.x + style.ItemInnerSpacing.x, value_bb.Min.y + style.FramePadding.y), label);

	push	DWORD PTR $T4[ebp+4]
	push	DWORD PTR $T4[ebp]
	call	?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z	; ImGui::RenderText
	add	esp, 20					; 00000014H
$LN34@LabelTextV:
	pop	edi
$LN4@LabelTextV:
	pop	esi

; 6465 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?LabelTextV@ImGui@@YAXPBD0PAD@Z ENDP			; ImGui::LabelTextV
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_label$ = 8						; size = 4
_fmt$ = 12						; size = 4
?LabelText@ImGui@@YAXPBD0ZZ PROC			; ImGui::LabelText

; 6468 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 6469 :     va_list args;
; 6470 :     va_start(args, fmt);
; 6471 :     LabelTextV(label, fmt, args);

	lea	eax, DWORD PTR _fmt$[ebp+4]
	push	eax
	push	DWORD PTR _fmt$[ebp]
	push	DWORD PTR _label$[ebp]
	call	?LabelTextV@ImGui@@YAXPBD0PAD@Z		; ImGui::LabelTextV
	add	esp, 12					; 0000000cH

; 6472 :     va_end(args);
; 6473 : }

	pop	ebp
	ret	0
?LabelText@ImGui@@YAXPBD0ZZ ENDP			; ImGui::LabelText
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_bb$3 = -72						; size = 16
_bb$4 = -72						; size = 16
_line_rect$5 = -72					; size = 16
_clip_rect$6 = -72					; size = 16
_line_size$7 = -56					; size = 8
_text_pos$8 = -48					; size = 8
_text_pos$9 = -48					; size = 8
$T10 = -40						; size = 8
$T11 = -40						; size = 8
_pos$12 = -40						; size = 8
_text_size$13 = -32					; size = 8
_pos$2$ = -28						; size = 4
_wrap_width$14 = -28					; size = 4
_text_pos$2$ = -24					; size = 4
$T15 = -20						; size = 8
_line_rect$2$ = -16					; size = 4
_lines_skippable$1$ = -16				; size = 4
_line_rect$1$ = -12					; size = 4
_line_height$16 = -8					; size = 4
_wrap_width$1$ = -4					; size = 4
_text$ = 8						; size = 4
_text_end$ = 12						; size = 4
?TextUnformatted@ImGui@@YAXPBD0@Z PROC			; ImGui::TextUnformatted

; 6323 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6323 : {

	sub	esp, 72					; 00000048H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	push	ebx
	mov	BYTE PTR [eax+134], 1
	mov	ebx, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6325 :     if (window->SkipItems)

	cmp	BYTE PTR [ebx+137], 0
	jne	$LN11@TextUnform

; 6326 :         return;
; 6327 : 
; 6328 :     ImGuiContext& g = *GImGui;
; 6329 :     IM_ASSERT(text != NULL);
; 6330 :     const char* text_begin = text;
; 6331 :     if (text_end == NULL)

	push	esi
	mov	esi, DWORD PTR _text$[ebp]
	push	edi
	mov	edi, DWORD PTR _text_end$[ebp]
	test	edi, edi
	jne	SHORT $LN9@TextUnform

; 6332 :         text_end = text + strlen(text); // FIXME-OPT

	mov	ecx, esi
	lea	edx, DWORD PTR [ecx+1]
$LL78@TextUnform:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL78@TextUnform
	sub	ecx, edx
	lea	edi, DWORD PTR [ecx+esi]
$LN9@TextUnform:

; 6333 : 
; 6334 :     const float wrap_pos_x = window->DC.TextWrapPos;

	movss	xmm1, DWORD PTR [ebx+320]
	xorps	xmm0, xmm0

; 6335 :     const bool wrap_enabled = wrap_pos_x >= 0.0f;

	comiss	xmm1, xmm0

; 6336 :     if (text_end - text > 2000 && !wrap_enabled)

	mov	eax, edi
	movss	DWORD PTR _wrap_width$1$[ebp], xmm0
	setae	cl
	sub	eax, esi
	cmp	eax, 2000				; 000007d0H
	jle	$LN10@TextUnform
	test	cl, cl
	jne	$LN77@TextUnform

; 6337 :     {
; 6338 :         // Long text!
; 6339 :         // Perform manual coarse clipping to optimize for long multi-line text
; 6340 :         // From this point we will only compute the width of lines that are visible. Optimization only available when word-wrapping is disabled.
; 6341 :         // We also don't vertically center the text within the line full height, which is unlikely to matter because we are likely the biggest and only item on the line.
; 6342 :         const char* line = text;
; 6343 :         const float line_height = GetTextLineHeight();

	call	?GetTextLineHeight@ImGui@@YAMXZ		; ImGui::GetTextLineHeight
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm3, DWORD PTR [ebx+196]
	xorps	xmm1, xmm1
	addss	xmm3, DWORD PTR [ebx+228]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6345 :         const ImRect clip_rect = window->ClipRect;

	movups	xmm0, XMMWORD PTR [ebx+472]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm4, DWORD PTR [ebx+192]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6345 :         const ImRect clip_rect = window->ClipRect;

	movups	XMMWORD PTR _clip_rect$6[ebp], xmm0

; 6348 :         if (text_pos.y <= clip_rect.Max.y)

	shufps	xmm0, xmm0, 255				; 000000ffH
	comiss	xmm0, xmm3
	fstp	DWORD PTR _line_height$16[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _pos$2$[ebp], xmm4
	movss	DWORD PTR _text_pos$9[ebp], xmm4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	DWORD PTR _text_pos$2$[ebp], xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _text_pos$9[ebp+4], xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6348 :         if (text_pos.y <= clip_rect.Max.y)

	jb	$LN12@TextUnform

; 6349 :         {
; 6350 :             ImVec2 pos = text_pos;
; 6351 : 
; 6352 :             // Lines to skip (can't skip when logging text)
; 6353 :             if (!g.LogEnabled)

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	movaps	xmm1, xmm3
	mov	ecx, DWORD PTR __imp__strchr
	movss	xmm2, DWORD PTR _line_height$16[ebp]
	movss	DWORD PTR _pos$12[ebp], xmm4
	cmp	BYTE PTR [eax+11600], 0
	movss	DWORD PTR _pos$12[ebp+4], xmm1
	jne	SHORT $LN14@TextUnform

; 6354 :             {
; 6355 :                 int lines_skippable = (int)((clip_rect.Min.y - text_pos.y) / line_height);

	movss	xmm0, DWORD PTR _clip_rect$6[ebp+4]
	subss	xmm0, xmm3
	divss	xmm0, xmm2
	cvttss2si eax, xmm0
	mov	DWORD PTR _lines_skippable$1$[ebp], eax

; 6356 :                 if (lines_skippable > 0)

	test	eax, eax
	jle	SHORT $LN14@TextUnform

; 6357 :                 {
; 6358 :                     int lines_skipped = 0;

	xor	ebx, ebx

; 6359 :                     while (line < text_end && lines_skipped < lines_skippable)

	cmp	esi, edi
	jae	SHORT $LN3@TextUnform
	npad	4
$LL2@TextUnform:
	cmp	ebx, eax
	jge	SHORT $LN79@TextUnform

; 6360 :                     {
; 6361 :                         const char* line_end = strchr(line, '\n');

	push	10					; 0000000aH
	push	esi
	call	ecx
	mov	ecx, DWORD PTR __imp__strchr
	add	esp, 8

; 6362 :                         if (!line_end)

	test	eax, eax
	cmove	eax, edi

; 6363 :                             line_end = text_end;
; 6364 :                         line = line_end + 1;
; 6365 :                         lines_skipped++;

	inc	ebx
	lea	esi, DWORD PTR [eax+1]
	mov	eax, DWORD PTR _lines_skippable$1$[ebp]
	cmp	esi, edi
	jb	SHORT $LL2@TextUnform
$LN79@TextUnform:
	movss	xmm2, DWORD PTR _line_height$16[ebp]
	movss	xmm3, DWORD PTR _text_pos$2$[ebp]
	movss	xmm4, DWORD PTR _pos$2$[ebp]
$LN3@TextUnform:
	movd	xmm1, ebx

; 6366 :                     }
; 6367 :                     pos.y += lines_skipped * line_height;

	cvtdq2ps xmm1, xmm1
	mulss	xmm1, xmm2
	addss	xmm1, xmm3
	movss	DWORD PTR _pos$12[ebp+4], xmm1
$LN14@TextUnform:

; 6368 :                 }
; 6369 :             }
; 6370 : 
; 6371 :             // Lines to render
; 6372 :             if (line < text_end)

	cmp	esi, edi
	jae	$LN16@TextUnform
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movaps	xmm0, xmm4
	movss	DWORD PTR _line_rect$5[ebp], xmm4
	addss	xmm0, DWORD PTR __real@7f7fffff
	movss	DWORD PTR _line_rect$1$[ebp], xmm1
	movss	DWORD PTR _line_rect$5[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T15[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movaps	xmm0, xmm1

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T15[ebp]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm2

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _line_rect$5[ebp+8], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T15[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T15[ebp+4]
	mov	DWORD PTR _line_rect$5[ebp+12], eax
	movss	xmm0, DWORD PTR _line_rect$5[ebp+12]
	movss	DWORD PTR _line_rect$2$[ebp], xmm0
	npad	2
$LL4@TextUnform:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6377 :                     const char* line_end = strchr(line, '\n');

	push	10					; 0000000aH
	push	esi
	call	ecx

; 6378 :                     if (IsClippedEx(line_rect, NULL, false))

	push	0
	mov	ebx, eax
	lea	eax, DWORD PTR _line_rect$5[ebp]
	push	0
	push	eax
	call	?IsClippedEx@ImGui@@YA_NABUImRect@@PBI_N@Z ; ImGui::IsClippedEx
	add	esp, 20					; 00000014H
	test	al, al
	jne	$LN67@TextUnform

; 6381 :                     const ImVec2 line_size = CalcTextSize(line, line_end, false);

	push	ecx
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	lea	eax, DWORD PTR _line_size$7[ebp]
	push	0
	push	ebx
	push	esi
	push	eax
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 128  : static inline float  ImMax(float lhs, float rhs)                                { return lhs >= rhs ? lhs : rhs; }

	movss	xmm1, DWORD PTR _line_size$7[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6381 :                     const ImVec2 line_size = CalcTextSize(line, line_end, false);

	add	esp, 20					; 00000014H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 128  : static inline float  ImMax(float lhs, float rhs)                                { return lhs >= rhs ? lhs : rhs; }

	movss	xmm0, DWORD PTR _wrap_width$1$[ebp]
	comiss	xmm0, xmm1
	jae	SHORT $LN45@TextUnform
	movss	DWORD PTR _wrap_width$1$[ebp], xmm1
$LN45@TextUnform:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6383 :                     RenderText(pos, line, line_end, false);

	push	0
	push	ebx
	push	esi
	push	DWORD PTR _pos$12[ebp+4]
	push	DWORD PTR _pos$12[ebp]
	call	?RenderText@ImGui@@YAXUImVec2@@PBD1_N@Z	; ImGui::RenderText

; 6384 :                     if (!line_end)
; 6385 :                         line_end = text_end;
; 6386 :                     line = line_end + 1;
; 6387 :                     line_rect.Min.y += line_height;

	movss	xmm0, DWORD PTR _line_rect$1$[ebp]
	add	esp, 20					; 00000014H
	movss	xmm1, DWORD PTR _line_height$16[ebp]
	test	ebx, ebx
	mov	ecx, DWORD PTR __imp__strchr
	addss	xmm0, xmm1
	cmove	ebx, edi
	movss	DWORD PTR _line_rect$1$[ebp], xmm0
	lea	esi, DWORD PTR [ebx+1]
	movss	DWORD PTR _line_rect$5[ebp+4], xmm0

; 6388 :                     line_rect.Max.y += line_height;

	movss	xmm0, DWORD PTR _line_rect$2$[ebp]
	addss	xmm0, xmm1
	movss	DWORD PTR _line_rect$2$[ebp], xmm0
	movss	DWORD PTR _line_rect$5[ebp+12], xmm0

; 6389 :                     pos.y += line_height;

	movss	xmm0, DWORD PTR _pos$12[ebp+4]
	addss	xmm0, xmm1
	movss	DWORD PTR _pos$12[ebp+4], xmm0
	cmp	esi, edi
	jb	$LL4@TextUnform
$LN67@TextUnform:

; 6390 :                 }
; 6391 : 
; 6392 :                 // Count remaining lines
; 6393 :                 int lines_skipped = 0;

	xor	ebx, ebx

; 6394 :                 while (line < text_end)

	cmp	esi, edi
	jae	SHORT $LN7@TextUnform
$LL6@TextUnform:

; 6395 :                 {
; 6396 :                     const char* line_end = strchr(line, '\n');

	push	10					; 0000000aH
	push	esi
	call	DWORD PTR __imp__strchr
	add	esp, 8

; 6397 :                     if (!line_end)

	test	eax, eax
	cmove	eax, edi

; 6398 :                         line_end = text_end;
; 6399 :                     line = line_end + 1;
; 6400 :                     lines_skipped++;

	inc	ebx
	lea	esi, DWORD PTR [eax+1]
	cmp	esi, edi
	jb	SHORT $LL6@TextUnform
$LN7@TextUnform:

; 6401 :                 }
; 6402 :                 pos.y += lines_skipped * line_height;

	movss	xmm1, DWORD PTR _pos$12[ebp+4]
	movss	xmm3, DWORD PTR _text_pos$2$[ebp]
	movd	xmm0, ebx
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR _line_height$16[ebp]
	addss	xmm1, xmm0
$LN16@TextUnform:
	movss	xmm4, DWORD PTR _pos$2$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm1, xmm3
$LN12@TextUnform:

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR _wrap_width$1$[ebp]
	addss	xmm1, xmm3

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR _text_pos$9[ebp]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm4

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _bb$4[ebp], eax
	mov	eax, DWORD PTR _text_pos$9[ebp+4]
	mov	DWORD PTR _bb$4[ebp+4], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T11[ebp+4], xmm1
	movss	DWORD PTR $T11[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T11[ebp]
	mov	DWORD PTR _bb$4[ebp+8], eax
	mov	eax, DWORD PTR $T11[ebp+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6409 :         ItemSize(bb);

	push	ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _bb$4[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6409 :         ItemSize(bb);

	lea	eax, DWORD PTR _bb$4[ebp]
	mov	DWORD PTR [esp], 0
	push	eax
	call	?ItemSize@ImGui@@YAXABUImRect@@M@Z	; ImGui::ItemSize

; 6410 :         ItemAdd(bb, NULL);

	push	0
	lea	eax, DWORD PTR _bb$4[ebp]
	push	0
	push	eax
	call	?ItemAdd@ImGui@@YA_NABUImRect@@PBIPBU2@@Z ; ImGui::ItemAdd

; 6422 :             return;
; 6423 : 
; 6424 :         // Render (we don't hide text after ## in this end-user function)
; 6425 :         RenderTextWrapped(bb.Min, text_begin, text_end, wrap_width);

	add	esp, 20					; 00000014H
	pop	edi
	pop	esi
	pop	ebx

; 6426 :     }
; 6427 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@TextUnform:

; 6411 :     }
; 6412 :     else
; 6413 :     {
; 6414 :         const float wrap_width = wrap_enabled ? CalcWrapWidthForPos(window->DC.CursorPos, wrap_pos_x) : 0.0f;

	test	cl, cl
	je	SHORT $LN22@TextUnform
$LN77@TextUnform:
	push	ecx
	lea	eax, DWORD PTR [ebx+192]
	movss	DWORD PTR [esp], xmm1
	push	eax
	call	?CalcWrapWidthForPos@ImGui@@YAMABUImVec2@@M@Z ; ImGui::CalcWrapWidthForPos
	fstp	DWORD PTR _wrap_width$14[ebp]
	movss	xmm0, DWORD PTR _wrap_width$14[ebp]
	add	esp, 8
	movss	DWORD PTR _wrap_width$1$[ebp], xmm0
$LN22@TextUnform:

; 6415 :         const ImVec2 text_size = CalcTextSize(text_begin, text_end, false, wrap_width);

	push	ecx
	movss	DWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _text_size$13[ebp]
	push	0
	push	edi
	push	esi
	push	eax
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm1, DWORD PTR [ebx+192]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6420 :         ItemSize(text_size);

	add	esp, 16					; 00000010H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR _text_size$13[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6418 :         ImVec2 text_pos(window->DC.CursorPos.x, window->DC.CursorPos.y + window->DC.CurrentLineTextBaseOffset);

	movss	xmm2, DWORD PTR [ebx+228]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6418 :         ImVec2 text_pos(window->DC.CursorPos.x, window->DC.CursorPos.y + window->DC.CurrentLineTextBaseOffset);

	addss	xmm2, DWORD PTR [ebx+196]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _text_pos$8[ebp], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR _text_pos$8[ebp]
	mov	DWORD PTR _bb$3[ebp], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T10[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR _text_size$13[ebp+4]
	addss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _text_pos$8[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR _text_pos$8[ebp+4]
	mov	DWORD PTR _bb$3[ebp+4], eax
	mov	eax, DWORD PTR $T10[ebp]
	mov	DWORD PTR _bb$3[ebp+8], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T10[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T10[ebp+4]
	mov	DWORD PTR _bb$3[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6420 :         ItemSize(text_size);

	lea	eax, DWORD PTR _text_size$13[ebp]
	mov	DWORD PTR [esp], 0
	push	eax
	call	?ItemSize@ImGui@@YAXABUImVec2@@M@Z	; ImGui::ItemSize

; 6421 :         if (!ItemAdd(bb, NULL))

	push	0
	lea	eax, DWORD PTR _bb$3[ebp]
	push	0
	push	eax
	call	?ItemAdd@ImGui@@YA_NABUImRect@@PBIPBU2@@Z ; ImGui::ItemAdd
	add	esp, 20					; 00000014H
	test	al, al
	je	SHORT $LN80@TextUnform

; 6422 :             return;
; 6423 : 
; 6424 :         // Render (we don't hide text after ## in this end-user function)
; 6425 :         RenderTextWrapped(bb.Min, text_begin, text_end, wrap_width);

	movss	xmm0, DWORD PTR _wrap_width$1$[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	push	edi
	push	esi
	push	DWORD PTR _bb$3[ebp+4]
	push	DWORD PTR _bb$3[ebp]
	call	?RenderTextWrapped@ImGui@@YAXUImVec2@@PBD1M@Z ; ImGui::RenderTextWrapped
	add	esp, 20					; 00000014H
$LN80@TextUnform:
	pop	edi
	pop	esi
$LN11@TextUnform:
	pop	ebx

; 6426 :     }
; 6427 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?TextUnformatted@ImGui@@YAXPBD0@Z ENDP			; ImGui::TextUnformatted
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_fmt$ = 8						; size = 4
_args$ = 12						; size = 4
?TextWrappedV@ImGui@@YAXPBDPAD@Z PROC			; ImGui::TextWrappedV

; 6307 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 6308 :     bool need_wrap = (GImGui->CurrentWindow->DC.TextWrapPos < 0.0f);    // Keep existing wrap position is one ia already set

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	xorps	xmm0, xmm0
	push	ebx
	mov	eax, DWORD PTR [eax+6240]
	comiss	xmm0, DWORD PTR [eax+320]
	seta	bl

; 6309 :     if (need_wrap) PushTextWrapPos(0.0f);

	test	bl, bl
	je	SHORT $LN2@TextWrappe
	push	ecx
	mov	DWORD PTR [esp], 0
	call	?PushTextWrapPos@ImGui@@YAXM@Z		; ImGui::PushTextWrapPos
	add	esp, 4
$LN2@TextWrappe:

; 6310 :     TextV(fmt, args);

	push	DWORD PTR _args$[ebp]
	push	DWORD PTR _fmt$[ebp]
	call	?TextV@ImGui@@YAXPBDPAD@Z		; ImGui::TextV
	add	esp, 8

; 6311 :     if (need_wrap) PopTextWrapPos();

	test	bl, bl
	pop	ebx
	je	SHORT $LN3@TextWrappe

; 6312 : }

	pop	ebp

; 6311 :     if (need_wrap) PopTextWrapPos();

	jmp	?PopTextWrapPos@ImGui@@YAXXZ		; ImGui::PopTextWrapPos
$LN3@TextWrappe:

; 6312 : }

	pop	ebp
	ret	0
?TextWrappedV@ImGui@@YAXPBDPAD@Z ENDP			; ImGui::TextWrappedV
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_fmt$ = 8						; size = 4
?TextWrapped@ImGui@@YAXPBDZZ PROC			; ImGui::TextWrapped

; 6315 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 6316 :     va_list args;
; 6317 :     va_start(args, fmt);
; 6318 :     TextWrappedV(fmt, args);

	lea	eax, DWORD PTR _fmt$[ebp+4]
	push	eax
	push	DWORD PTR _fmt$[ebp]
	call	?TextWrappedV@ImGui@@YAXPBDPAD@Z	; ImGui::TextWrappedV
	add	esp, 8

; 6319 :     va_end(args);
; 6320 : }

	pop	ebp
	ret	0
?TextWrapped@ImGui@@YAXPBDZZ ENDP			; ImGui::TextWrapped
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_fmt$ = 8						; size = 4
_args$ = 12						; size = 4
?TextDisabledV@ImGui@@YAXPBDPAD@Z PROC			; ImGui::TextDisabledV

; 6292 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 6293 :     PushStyleColor(ImGuiCol_Text, GImGui->Style.Colors[ImGuiCol_TextDisabled]);

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	add	eax, 5464				; 00001558H
	push	eax
	push	0
	call	?PushStyleColor@ImGui@@YAXHABUImVec4@@@Z ; ImGui::PushStyleColor

; 6294 :     TextV(fmt, args);

	push	DWORD PTR _args$[ebp]
	push	DWORD PTR _fmt$[ebp]
	call	?TextV@ImGui@@YAXPBDPAD@Z		; ImGui::TextV

; 6295 :     PopStyleColor();

	push	1
	call	?PopStyleColor@ImGui@@YAXH@Z		; ImGui::PopStyleColor
	add	esp, 20					; 00000014H

; 6296 : }

	pop	ebp
	ret	0
?TextDisabledV@ImGui@@YAXPBDPAD@Z ENDP			; ImGui::TextDisabledV
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_fmt$ = 8						; size = 4
?TextDisabled@ImGui@@YAXPBDZZ PROC			; ImGui::TextDisabled

; 6299 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 6300 :     va_list args;
; 6301 :     va_start(args, fmt);
; 6302 :     TextDisabledV(fmt, args);

	lea	eax, DWORD PTR _fmt$[ebp+4]
	push	eax
	push	DWORD PTR _fmt$[ebp]
	call	?TextDisabledV@ImGui@@YAXPBDPAD@Z	; ImGui::TextDisabledV
	add	esp, 8

; 6303 :     va_end(args);
; 6304 : }

	pop	ebp
	ret	0
?TextDisabled@ImGui@@YAXPBDZZ ENDP			; ImGui::TextDisabled
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_col$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?TextColoredV@ImGui@@YAXABUImVec4@@PBDPAD@Z PROC	; ImGui::TextColoredV

; 6277 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 6278 :     PushStyleColor(ImGuiCol_Text, col);

	push	DWORD PTR _col$[ebp]
	push	0
	call	?PushStyleColor@ImGui@@YAXHABUImVec4@@@Z ; ImGui::PushStyleColor

; 6279 :     TextV(fmt, args);

	push	DWORD PTR _args$[ebp]
	push	DWORD PTR _fmt$[ebp]
	call	?TextV@ImGui@@YAXPBDPAD@Z		; ImGui::TextV

; 6280 :     PopStyleColor();

	push	1
	call	?PopStyleColor@ImGui@@YAXH@Z		; ImGui::PopStyleColor
	add	esp, 20					; 00000014H

; 6281 : }

	pop	ebp
	ret	0
?TextColoredV@ImGui@@YAXABUImVec4@@PBDPAD@Z ENDP	; ImGui::TextColoredV
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_col$ = 8						; size = 4
_fmt$ = 12						; size = 4
?TextColored@ImGui@@YAXABUImVec4@@PBDZZ PROC		; ImGui::TextColored

; 6284 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 6285 :     va_list args;
; 6286 :     va_start(args, fmt);
; 6287 :     TextColoredV(col, fmt, args);

	lea	eax, DWORD PTR _fmt$[ebp+4]
	push	eax
	push	DWORD PTR _fmt$[ebp]
	push	DWORD PTR _col$[ebp]
	call	?TextColoredV@ImGui@@YAXABUImVec4@@PBDPAD@Z ; ImGui::TextColoredV
	add	esp, 12					; 0000000cH

; 6288 :     va_end(args);
; 6289 : }

	pop	ebp
	ret	0
?TextColored@ImGui@@YAXABUImVec4@@PBDZZ ENDP		; ImGui::TextColored
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_fmt$ = 8						; size = 4
_args$ = 12						; size = 4
?TextV@ImGui@@YAXPBDPAD@Z PROC				; ImGui::TextV

; 6258 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6260 :     if (window->SkipItems)

	mov	eax, DWORD PTR [ecx+6240]
	cmp	BYTE PTR [eax+137], 0
	jne	SHORT $LN1@TextV

; 6261 :         return;
; 6262 : 
; 6263 :     ImGuiContext& g = *GImGui;

	push	esi
	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	edi

; 6264 :     const char* text_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);

	push	DWORD PTR _args$[ebp]
	push	DWORD PTR _fmt$[ebp]
	lea	edi, DWORD PTR [esi+12116]
	push	3073					; 00000c01H
	push	edi
	call	?ImFormatStringV@@YAHPADHPBD0@Z		; ImFormatStringV
	add	esi, 12116				; 00002f54H
	add	eax, esi

; 6265 :     TextUnformatted(g.TempBuffer, text_end);

	push	eax
	push	edi
	call	?TextUnformatted@ImGui@@YAXPBD0@Z	; ImGui::TextUnformatted
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
$LN1@TextV:

; 6266 : }

	pop	ebp
	ret	0
?TextV@ImGui@@YAXPBDPAD@Z ENDP				; ImGui::TextV
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_fmt$ = 8						; size = 4
?Text@ImGui@@YAXPBDZZ PROC				; ImGui::Text

; 6269 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 6270 :     va_list args;
; 6271 :     va_start(args, fmt);
; 6272 :     TextV(fmt, args);

	lea	eax, DWORD PTR _fmt$[ebp+4]
	push	eax
	push	DWORD PTR _fmt$[ebp]
	call	?TextV@ImGui@@YAXPBDPAD@Z		; ImGui::TextV
	add	esp, 8

; 6273 :     va_end(args);
; 6274 : }

	pop	ebp
	ret	0
?Text@ImGui@@YAXPBDZZ ENDP				; ImGui::Text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_ptr_id$ = 8						; size = 4
?GetID@ImGui@@YAIPBX@Z PROC				; ImGui::GetID

; 7203 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 7204 :     return GImGui->CurrentWindow->GetID(ptr_id);

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	DWORD PTR _ptr_id$[ebp]
	mov	ecx, DWORD PTR [ecx+6240]
	call	?GetID@ImGuiWindow@@QAEIPBX@Z		; ImGuiWindow::GetID

; 7205 : }

	pop	ebp
	ret	0
?GetID@ImGui@@YAIPBX@Z ENDP				; ImGui::GetID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_str_id_begin$ = 8					; size = 4
_str_id_end$ = 12					; size = 4
?GetID@ImGui@@YAIPBD0@Z PROC				; ImGui::GetID

; 7198 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 7199 :     return GImGui->CurrentWindow->GetID(str_id_begin, str_id_end);

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	DWORD PTR _str_id_end$[ebp]
	push	DWORD PTR _str_id_begin$[ebp]
	mov	ecx, DWORD PTR [ecx+6240]
	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID

; 7200 : }

	pop	ebp
	ret	0
?GetID@ImGui@@YAIPBD0@Z ENDP				; ImGui::GetID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_str_id$ = 8						; size = 4
?GetID@ImGui@@YAIPBD@Z PROC				; ImGui::GetID

; 7193 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 7194 :     return GImGui->CurrentWindow->GetID(str_id);

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	0
	push	DWORD PTR _str_id$[ebp]
	mov	ecx, DWORD PTR [ecx+6240]
	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID

; 7195 : }

	pop	ebp
	ret	0
?GetID@ImGui@@YAIPBD@Z ENDP				; ImGui::GetID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?PopID@ImGui@@YAXXZ PROC				; ImGui::PopID
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7189 :     window->IDStack.pop_back();

	mov	eax, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [eax+460]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7190 : }

	ret	0
?PopID@ImGui@@YAXXZ ENDP				; ImGui::PopID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = 8							; size = 4
_int_id$ = 8						; size = 4
?PushID@ImGui@@YAXH@Z PROC				; ImGui::PushID

; 7180 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7183 :     window->IDStack.push_back(window->GetID(ptr_id));

	push	DWORD PTR _int_id$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	esi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7183 :     window->IDStack.push_back(window->GetID(ptr_id));

	mov	ecx, esi
	call	?GetID@ImGuiWindow@@QAEIPBX@Z		; ImGuiWindow::GetID
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR [esi+460]
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?push_back@?$ImVector@I@@QAEXABI@Z	; ImVector<unsigned int>::push_back
	pop	esi

; 7184 : }

	pop	ebp
	ret	0
?PushID@ImGui@@YAXH@Z ENDP				; ImGui::PushID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -4						; size = 4
_ptr_id$ = 8						; size = 4
?PushID@ImGui@@YAXPBX@Z PROC				; ImGui::PushID

; 7174 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7176 :     window->IDStack.push_back(window->GetID(ptr_id));

	push	DWORD PTR _ptr_id$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	esi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7176 :     window->IDStack.push_back(window->GetID(ptr_id));

	mov	ecx, esi
	call	?GetID@ImGuiWindow@@QAEIPBX@Z		; ImGuiWindow::GetID
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR [esi+460]
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?push_back@?$ImVector@I@@QAEXABI@Z	; ImVector<unsigned int>::push_back
	pop	esi

; 7177 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PushID@ImGui@@YAXPBX@Z ENDP				; ImGui::PushID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -4						; size = 4
_str_id_begin$ = 8					; size = 4
_str_id_end$ = 12					; size = 4
?PushID@ImGui@@YAXPBD0@Z PROC				; ImGui::PushID

; 7168 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7170 :     window->IDStack.push_back(window->GetID(str_id_begin, str_id_end));

	push	DWORD PTR _str_id_end$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7170 :     window->IDStack.push_back(window->GetID(str_id_begin, str_id_end));

	push	DWORD PTR _str_id_begin$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	BYTE PTR [eax+134], 1
	mov	esi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7170 :     window->IDStack.push_back(window->GetID(str_id_begin, str_id_end));

	mov	ecx, esi
	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR [esi+460]
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?push_back@?$ImVector@I@@QAEXABI@Z	; ImVector<unsigned int>::push_back
	pop	esi

; 7171 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PushID@ImGui@@YAXPBD0@Z ENDP				; ImGui::PushID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -4						; size = 4
_str_id$ = 8						; size = 4
?PushID@ImGui@@YAXPBD@Z PROC				; ImGui::PushID

; 7162 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7164 :     window->IDStack.push_back(window->GetID(str_id));

	push	0
	push	DWORD PTR _str_id$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	esi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 7164 :     window->IDStack.push_back(window->GetID(str_id));

	mov	ecx, esi
	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR [esi+460]
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?push_back@?$ImVector@I@@QAEXABI@Z	; ImVector<unsigned int>::push_back
	pop	esi

; 7165 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PushID@ImGui@@YAXPBD@Z ENDP				; ImGui::PushID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?GetColumnsCount@ImGui@@YAHXZ PROC			; ImGui::GetColumnsCount

; 10446:     ImGuiWindow* window = GetCurrentWindowRead();
; 10447:     return window->DC.ColumnsCount;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [eax+6240]
	mov	eax, DWORD PTR [eax+416]

; 10448: }

	ret	0
?GetColumnsCount@ImGui@@YAHXZ ENDP			; ImGui::GetColumnsCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
tv130 = 8						; size = 4
_column_index$ = 8					; size = 4
?GetColumnWidth@ImGui@@YAMH@Z PROC			; ImGui::GetColumnWidth

; 10500: {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 10501:     ImGuiWindow* window = GetCurrentWindowRead();
; 10502:     if (column_index < 0)

	mov	esi, DWORD PTR _column_index$[ebp]
	test	esi, esi
	jns	SHORT $LN2@GetColumnW

; 10503:         column_index = window->DC.ColumnsCurrent;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [eax+6240]
	mov	esi, DWORD PTR [eax+412]
$LN2@GetColumnW:

; 10504: 
; 10505:     float w = GetColumnOffset(column_index+1) - GetColumnOffset(column_index);

	lea	eax, DWORD PTR [esi+1]
	push	eax
	call	?GetColumnOffset@ImGui@@YAMH@Z		; ImGui::GetColumnOffset
	fstp	DWORD PTR tv130[ebp]
	push	esi
	call	?GetColumnOffset@ImGui@@YAMH@Z		; ImGui::GetColumnOffset
	fsubr	DWORD PTR tv130[ebp]
	add	esp, 8
	pop	esi

; 10506:     return w;
; 10507: }

	pop	ebp
	ret	0
?GetColumnWidth@ImGui@@YAMH@Z ENDP			; ImGui::GetColumnWidth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_column_index$ = 8					; size = 4
_offset$ = 12						; size = 4
?SetColumnOffset@ImGui@@YAXHM@Z PROC			; ImGui::SetColumnOffset

; 10486: {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10488:     if (column_index < 0)

	mov	edx, DWORD PTR _column_index$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	ecx, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10488:     if (column_index < 0)

	test	edx, edx
	jns	SHORT $LN2@SetColumnO

; 10489:         column_index = window->DC.ColumnsCurrent;

	mov	edx, DWORD PTR [ecx+412]
$LN2@SetColumnO:

; 10490: 
; 10491:     IM_ASSERT(column_index < window->DC.ColumnsData.Size);
; 10492:     const float t = (offset - window->DC.ColumnsMinX) / (window->DC.ColumnsMaxX - window->DC.ColumnsMinX);

	movss	xmm1, DWORD PTR [ecx+420]
	movss	xmm0, DWORD PTR [ecx+424]
	movss	xmm2, DWORD PTR _offset$[ebp]
	subss	xmm0, xmm1
	subss	xmm2, xmm1

; 10493:     window->DC.ColumnsData[column_index].OffsetNorm = t;

	mov	eax, DWORD PTR [ecx+456]

; 10494: 
; 10495:     const ImGuiID column_id = window->DC.ColumnsSetId + ImGuiID(column_index);
; 10496:     window->DC.StateStorage->SetFloat(column_id, t);

	push	ecx
	divss	xmm2, xmm0
	movss	DWORD PTR [eax+edx*4], xmm2
	mov	eax, DWORD PTR [ecx+444]
	mov	ecx, DWORD PTR [ecx+304]
	add	eax, edx
	movss	DWORD PTR [esp], xmm2
	push	eax
	call	?SetFloat@ImGuiStorage@@QAEXIM@Z	; ImGuiStorage::SetFloat

; 10497: }

	pop	ebp
	ret	0
?SetColumnOffset@ImGui@@YAXHM@Z ENDP			; ImGui::SetColumnOffset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
tv192 = 8						; size = 4
_column_index$ = 8					; size = 4
?GetColumnOffset@ImGui@@YAMH@Z PROC			; ImGui::GetColumnOffset

; 10466: {

	npad	2
	push	ebp
	mov	ebp, esp

; 10469:     if (column_index < 0)

	mov	ecx, DWORD PTR _column_index$[ebp]
	push	esi
	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 792  :     inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }

	mov	edx, DWORD PTR [esi+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10469:     if (column_index < 0)

	test	ecx, ecx
	jns	SHORT $LN2@GetColumnO

; 10470:         column_index = window->DC.ColumnsCurrent;

	mov	ecx, DWORD PTR [edx+412]
$LN2@GetColumnO:

; 10471: 
; 10472:     if (g.ActiveId)

	mov	esi, DWORD PTR [esi+6264]
	test	esi, esi
	je	SHORT $LN4@GetColumnO

; 10473:     {
; 10474:         const ImGuiID column_id = window->DC.ColumnsSetId + ImGuiID(column_index);

	mov	eax, DWORD PTR [edx+444]
	add	eax, ecx

; 10475:         if (g.ActiveId == column_id)

	cmp	esi, eax
	jne	SHORT $LN4@GetColumnO
	pop	esi

; 10476:             return GetDraggedColumnOffset(column_index);

	mov	DWORD PTR _column_index$[ebp], ecx

; 10483: }

	pop	ebp

; 10476:             return GetDraggedColumnOffset(column_index);

	jmp	?GetDraggedColumnOffset@@YAMH@Z		; GetDraggedColumnOffset
$LN4@GetColumnO:

; 10477:     }
; 10478: 
; 10479:     IM_ASSERT(column_index < window->DC.ColumnsData.Size);
; 10480:     const float t = window->DC.ColumnsData[column_index].OffsetNorm;
; 10481:     const float x_offset = window->DC.ColumnsMinX + t * (window->DC.ColumnsMaxX - window->DC.ColumnsMinX);

	movss	xmm1, DWORD PTR [edx+420]
	movss	xmm0, DWORD PTR [edx+424]
	mov	eax, DWORD PTR [edx+456]
	subss	xmm0, xmm1
	pop	esi
	mulss	xmm0, DWORD PTR [eax+ecx*4]
	addss	xmm0, xmm1

; 10482:     return (float)(int)x_offset;

	cvttss2si eax, xmm0
	mov	DWORD PTR tv192[ebp], eax
	fild	DWORD PTR tv192[ebp]

; 10483: }

	pop	ebp
	ret	0
?GetColumnOffset@ImGui@@YAMH@Z ENDP			; ImGui::GetColumnOffset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?GetColumnIndex@ImGui@@YAHXZ PROC			; ImGui::GetColumnIndex

; 10440:     ImGuiWindow* window = GetCurrentWindowRead();
; 10441:     return window->DC.ColumnsCurrent;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [eax+6240]
	mov	eax, DWORD PTR [eax+412]

; 10442: }

	ret	0
?GetColumnIndex@ImGui@@YAHXZ ENDP			; ImGui::GetColumnIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
tv66 = -4						; size = 4
?NextColumn@ImGui@@YAXXZ PROC				; ImGui::NextColumn

; 10406: {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	esi
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	esi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10408:     if (window->SkipItems || window->DC.ColumnsCount <= 1)

	cmp	BYTE PTR [esi+137], 0
	jne	$LN3@NextColumn
	cmp	DWORD PTR [esi+416], 1
	jle	$LN3@NextColumn

; 10409:         return;
; 10410: 
; 10411:     ImGuiContext& g = *GImGui;

	push	edi
	mov	edi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 10412:     PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 10413:     PopClipRect();

	call	?PopClipRect@ImGui@@YAXXZ		; ImGui::PopClipRect
	movss	xmm1, DWORD PTR [esi+436]
	maxss	xmm1, DWORD PTR [esi+196]

; 10414: 
; 10415:     window->DC.ColumnsCellMaxY = ImMax(window->DC.ColumnsCellMaxY, window->DC.CursorPos.y);
; 10416:     if (++window->DC.ColumnsCurrent < window->DC.ColumnsCount)

	inc	DWORD PTR [esi+412]
	mov	eax, DWORD PTR [esi+412]
	movss	DWORD PTR [esi+436], xmm1
	cmp	eax, DWORD PTR [esi+416]
	jge	SHORT $LN4@NextColumn

; 10417:     {
; 10418:         // Columns 1+ cancel out IndentX
; 10419:         window->DC.ColumnsOffsetX = GetColumnOffset(window->DC.ColumnsCurrent) - window->DC.IndentX + g.Style.ItemSpacing.x;

	push	eax
	call	?GetColumnOffset@ImGui@@YAMH@Z		; ImGui::GetColumnOffset
	fsub	DWORD PTR [esi+400]
	add	esp, 4
	movss	xmm0, DWORD PTR [edi+5368]

; 10420:         window->DrawList->ChannelsSetCurrent(window->DC.ColumnsCurrent);

	push	DWORD PTR [esi+412]
	fstp	DWORD PTR tv66[ebp]
	addss	xmm0, DWORD PTR tv66[ebp]
	movss	DWORD PTR [esi+408], xmm0

; 10421:     }
; 10422:     else

	jmp	SHORT $LN13@NextColumn
$LN4@NextColumn:

; 10423:     {
; 10424:         window->DC.ColumnsCurrent = 0;

	mov	DWORD PTR [esi+412], 0

; 10425:         window->DC.ColumnsOffsetX = 0.0f;

	mov	DWORD PTR [esi+408], 0

; 10426:         window->DC.ColumnsCellMinY = window->DC.ColumnsCellMaxY;

	movss	DWORD PTR [esi+432], xmm1

; 10427:         window->DrawList->ChannelsSetCurrent(0);

	push	0
$LN13@NextColumn:
	mov	ecx, DWORD PTR [esi+624]
	call	?ChannelsSetCurrent@ImDrawList@@QAEXH@Z	; ImDrawList::ChannelsSetCurrent

; 10428:     }
; 10429:     window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.IndentX + window->DC.ColumnsOffsetX);

	movss	xmm0, DWORD PTR [esi+400]
	addss	xmm0, DWORD PTR [esi+24]

; 10430:     window->DC.CursorPos.y = window->DC.ColumnsCellMinY;
; 10431:     window->DC.CurrentLineHeight = 0.0f;
; 10432:     window->DC.CurrentLineTextBaseOffset = 0.0f;
; 10433: 
; 10434:     PushColumnClipRect();

	push	-1
	mov	DWORD PTR [esi+224], 0
	mov	DWORD PTR [esi+228], 0
	addss	xmm0, DWORD PTR [esi+408]
	cvttss2si eax, xmm0
	movd	xmm0, eax
	mov	eax, DWORD PTR [esi+432]
	cvtdq2ps xmm0, xmm0
	mov	DWORD PTR [esi+196], eax
	movss	DWORD PTR [esi+192], xmm0
	call	?PushColumnClipRect@@YAXH@Z		; PushColumnClipRect

; 10435:     PushItemWidth(GetColumnWidth() * 0.65f);  // FIXME: Move on columns setup

	push	-1
	call	?GetColumnWidth@ImGui@@YAMH@Z		; ImGui::GetColumnWidth
	fmul	DWORD PTR __real@3f266666
	add	esp, 4
	fstp	DWORD PTR [esp]
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth
	add	esp, 4
	pop	edi
$LN3@NextColumn:
	pop	esi

; 10436: }

	mov	esp, ebp
	pop	ebp
	ret	0
?NextColumn@ImGui@@YAXXZ ENDP				; ImGui::NextColumn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_column_rect$1 = -72					; size = 16
$T2 = -56						; size = 8
$T3 = -48						; size = 8
$T4 = -40						; size = 8
$T5 = -40						; size = 8
$T6 = -32						; size = 8
_y1$1$ = -24						; size = 4
_y2$1$ = -20						; size = 4
_column_id$1$ = -16					; size = 4
_column_id$7 = -12					; size = 4
_x$8 = -8						; size = 4
_hovered$9 = -2						; size = 1
_held$10 = -1						; size = 1
_columns_count$ = 8					; size = 4
_id$ = 12						; size = 4
_border$ = 16						; size = 1
?Columns@ImGui@@YAXHPBD_N@Z PROC			; ImGui::Columns

; 10521: {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx

; 10522:     ImGuiContext& g = *GImGui;

	mov	ebx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	esi
	push	edi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ebx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	edi, DWORD PTR [ebx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10526:     if (window->DC.ColumnsCount != 1)

	cmp	DWORD PTR [edi+416], 1
	je	SHORT $LN8@Columns

; 10527:     {
; 10528:         if (window->DC.ColumnsCurrent != 0)

	cmp	DWORD PTR [edi+412], 0
	je	SHORT $LN9@Columns

; 10529:             ItemSize(ImVec2(0,0));   // Advance to column 0

	push	ecx
	lea	eax, DWORD PTR $T5[ebp]
	mov	DWORD PTR [esp], 0
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T5[ebp], 0
	mov	DWORD PTR $T5[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10529:             ItemSize(ImVec2(0,0));   // Advance to column 0

	call	?ItemSize@ImGui@@YAXABUImVec2@@M@Z	; ImGui::ItemSize
	add	esp, 8
$LN9@Columns:

; 10530:         PopItemWidth();

	call	?PopItemWidth@ImGui@@YAXXZ		; ImGui::PopItemWidth

; 10531:         PopClipRect();

	call	?PopClipRect@ImGui@@YAXXZ		; ImGui::PopClipRect

; 10532:         window->DrawList->ChannelsMerge();

	mov	ecx, DWORD PTR [edi+624]
	call	?ChannelsMerge@ImDrawList@@QAEXXZ	; ImDrawList::ChannelsMerge
	movss	xmm0, DWORD PTR [edi+436]
	maxss	xmm0, DWORD PTR [edi+196]
	movss	DWORD PTR [edi+436], xmm0

; 10533: 
; 10534:         window->DC.ColumnsCellMaxY = ImMax(window->DC.ColumnsCellMaxY, window->DC.CursorPos.y);
; 10535:         window->DC.CursorPos.y = window->DC.ColumnsCellMaxY;

	movss	DWORD PTR [edi+196], xmm0
$LN8@Columns:

; 10536:     }
; 10537: 
; 10538:     // Draw columns borders and handle resize at the time of "closing" a columns set
; 10539:     if (window->DC.ColumnsCount != columns_count && window->DC.ColumnsCount != 1 && window->DC.ColumnsShowBorders && !window->SkipItems)

	mov	eax, DWORD PTR [edi+416]
	cmp	eax, DWORD PTR _columns_count$[ebp]
	je	$LN3@Columns
	cmp	eax, 1
	je	$LN3@Columns
	cmp	BYTE PTR [edi+440], 0
	je	$LN3@Columns
	cmp	BYTE PTR [edi+137], 0
	jne	$LN3@Columns

; 10540:     {
; 10541:         const float y1 = window->DC.ColumnsStartPosY;

	movss	xmm0, DWORD PTR [edi+428]

; 10542:         const float y2 = window->DC.CursorPos.y;
; 10543:         for (int i = 1; i < window->DC.ColumnsCount; i++)

	mov	esi, 1
	movss	xmm1, DWORD PTR [edi+196]
	movss	DWORD PTR _y1$1$[ebp], xmm0
	movss	DWORD PTR _y2$1$[ebp], xmm1
	cmp	eax, esi
	jle	$LN3@Columns
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp+4], xmm1
	movss	DWORD PTR $T6[ebp+4], xmm0
$LL4@Columns:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10545:             float x = window->Pos.x + GetColumnOffset(i);

	push	esi
	call	?GetColumnOffset@ImGui@@YAMH@Z		; ImGui::GetColumnOffset
	fadd	DWORD PTR [edi+24]

; 10546:             const ImGuiID column_id = window->DC.ColumnsSetId + ImGuiID(i);

	mov	eax, DWORD PTR [edi+444]
	add	eax, esi
	mov	DWORD PTR _column_id$1$[ebp], eax
	mov	DWORD PTR _column_id$7[ebp], eax
	fstp	DWORD PTR _x$8[ebp]

; 10547:             const ImRect column_rect(ImVec2(x-4,y1),ImVec2(x+4,y2));

	movss	xmm0, DWORD PTR _x$8[ebp]
	addss	xmm0, DWORD PTR __real@40800000

; 10548:             if (IsClippedEx(column_rect, &column_id, false))

	push	0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10547:             const ImRect column_rect(ImVec2(x-4,y1),ImVec2(x+4,y2));

	movss	xmm0, DWORD PTR _x$8[ebp]
	subss	xmm0, DWORD PTR __real@40800000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T6[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR _column_rect$1[ebp], eax
	mov	eax, DWORD PTR $T6[ebp+4]
	mov	DWORD PTR _column_rect$1[ebp+4], eax
	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR _column_rect$1[ebp+8], eax
	mov	eax, DWORD PTR $T4[ebp+4]
	mov	DWORD PTR _column_rect$1[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10548:             if (IsClippedEx(column_rect, &column_id, false))

	lea	eax, DWORD PTR _column_id$7[ebp]
	push	eax
	lea	eax, DWORD PTR _column_rect$1[ebp]
	push	eax
	call	?IsClippedEx@ImGui@@YA_NABUImRect@@PBI_N@Z ; ImGui::IsClippedEx
	add	esp, 16					; 00000010H
	test	al, al
	jne	$LN2@Columns

; 10549:                 continue;
; 10550: 
; 10551:             bool hovered, held;
; 10552:             ButtonBehavior(column_rect, column_id, &hovered, &held);

	push	0
	lea	eax, DWORD PTR _held$10[ebp]
	push	eax
	lea	eax, DWORD PTR _hovered$9[ebp]
	push	eax
	push	DWORD PTR _column_id$1$[ebp]
	lea	eax, DWORD PTR _column_rect$1[ebp]
	push	eax
	call	?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z ; ImGui::ButtonBehavior

; 10553:             if (hovered || held)

	mov	dl, BYTE PTR _hovered$9[ebp]
	add	esp, 20					; 00000014H
	mov	al, BYTE PTR _held$10[ebp]
	test	dl, dl
	jne	SHORT $LN13@Columns
	test	al, al
	je	SHORT $LN19@Columns
$LN13@Columns:

; 10554:                 g.MouseCursor = ImGuiMouseCursor_ResizeEW;

	mov	DWORD PTR [ebx+6764], 4

; 10557:             const ImU32 col = GetColorU32(held ? ImGuiCol_ColumnActive : hovered ? ImGuiCol_ColumnHovered : ImGuiCol_Column);

	test	al, al
	je	SHORT $LN19@Columns
	mov	ecx, 30					; 0000001eH
	jmp	SHORT $LN20@Columns
$LN19@Columns:
	xor	ecx, ecx
	test	dl, dl
	setne	cl
	add	ecx, 28					; 0000001cH
$LN20@Columns:

; 10558:             const float xi = (float)(int)x;

	cvttss2si eax, DWORD PTR _x$8[ebp]

; 10559:             window->DrawList->AddLine(ImVec2(xi, y1+1.0f), ImVec2(xi, y2), col);

	sub	esp, 8
	mov	DWORD PTR [esp+4], 1065353216		; 3f800000H
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm1, DWORD PTR _y2$1$[ebp]
	movss	DWORD PTR $T3[ebp+4], xmm1
	movd	xmm0, eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10558:             const float xi = (float)(int)x;

	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp], xmm0
	movss	DWORD PTR $T2[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10559:             window->DrawList->AddLine(ImVec2(xi, y1+1.0f), ImVec2(xi, y2), col);

	movss	xmm0, DWORD PTR _y1$1$[ebp]
	addss	xmm0, DWORD PTR __real@3f800000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10557:             const ImU32 col = GetColorU32(held ? ImGuiCol_ColumnActive : hovered ? ImGuiCol_ColumnHovered : ImGuiCol_Column);

	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32

; 10559:             window->DrawList->AddLine(ImVec2(xi, y1+1.0f), ImVec2(xi, y2), col);

	mov	ecx, DWORD PTR [edi+624]
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?AddLine@ImDrawList@@QAEXABUImVec2@@0IM@Z ; ImDrawList::AddLine

; 10560: 
; 10561:             if (held)

	cmp	BYTE PTR _held$10[ebp], 0
	je	SHORT $LN2@Columns

; 10562:             {
; 10563:                 if (g.ActiveIdIsJustActivated)

	cmp	BYTE PTR [ebx+6273], 0
	je	SHORT $LN15@Columns

; 10564:                     g.ActiveIdClickOffset.x -= 4;   // Store from center of column line (we used a 8 wide rect for columns clicking)

	movss	xmm0, DWORD PTR [ebx+6280]
	subss	xmm0, DWORD PTR __real@40800000
	movss	DWORD PTR [ebx+6280], xmm0
$LN15@Columns:

; 10565:                 x = GetDraggedColumnOffset(i);

	push	esi
	call	?GetDraggedColumnOffset@@YAMH@Z		; GetDraggedColumnOffset
	fstp	DWORD PTR _x$8[ebp]

; 10566:                 SetColumnOffset(i, x);

	movss	xmm0, DWORD PTR _x$8[ebp]
	movss	DWORD PTR [esp], xmm0
	push	esi
	call	?SetColumnOffset@ImGui@@YAXHM@Z		; ImGui::SetColumnOffset
	add	esp, 8
$LN2@Columns:

; 10542:         const float y2 = window->DC.CursorPos.y;
; 10543:         for (int i = 1; i < window->DC.ColumnsCount; i++)

	inc	esi
	cmp	esi, DWORD PTR [edi+416]
	jl	$LL4@Columns
$LN3@Columns:

; 10567:             }
; 10568:         }
; 10569:     }
; 10570: 
; 10571:     // Differentiate column ID with an arbitrary prefix for cases where users name their columns set the same as another widget.
; 10572:     // In addition, when an identifier isn't explicitly provided we include the number of columns in the hash to make it uniquer.
; 10573:     PushID(0x11223347 + (id ? 0 : columns_count));

	mov	esi, DWORD PTR _id$[ebp]
	xor	ecx, ecx
	mov	eax, DWORD PTR _columns_count$[ebp]
	test	esi, esi
	cmovne	eax, ecx
	add	eax, 287454023				; 11223347H
	push	eax
	call	?PushID@ImGui@@YAXH@Z			; ImGui::PushID
	add	esp, 4

; 10574:     window->DC.ColumnsSetId = window->GetID(id ? id : "columns");

	mov	eax, OFFSET $SG122543
	test	esi, esi
	mov	ecx, edi
	cmovne	eax, esi
	push	0
	push	eax
	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID
	mov	DWORD PTR [edi+444], eax

; 10575:     PopID();

	call	?PopID@ImGui@@YAXXZ			; ImGui::PopID

; 10576: 
; 10577:     // Set state for first column
; 10578:     window->DC.ColumnsCurrent = 0;
; 10579:     window->DC.ColumnsCount = columns_count;
; 10580:     window->DC.ColumnsShowBorders = border;
; 10581: 
; 10582:     const float content_region_width = (window->SizeContentsExplicit.x != 0.0f) ? window->SizeContentsExplicit.x : window->Size.x;

	movss	xmm0, DWORD PTR [edi+56]
	xorps	xmm2, xmm2
	mov	al, BYTE PTR _border$[ebp]
	mov	ecx, DWORD PTR _columns_count$[ebp]
	ucomiss	xmm0, xmm2
	mov	DWORD PTR [edi+412], 0
	mov	DWORD PTR [edi+416], ecx
	mov	BYTE PTR [edi+440], al
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN22@Columns
	movss	xmm0, DWORD PTR [edi+32]
$LN22@Columns:

; 10583:     window->DC.ColumnsMinX = window->DC.IndentX; // Lock our horizontal range
; 10584:     window->DC.ColumnsMaxX = content_region_width - window->Scroll.x - ((window->Flags & ImGuiWindowFlags_NoScrollbar) ? 0 : g.Style.ScrollbarSize);// - window->WindowPadding().x;

	test	BYTE PTR [edi+8], 8
	movss	xmm1, DWORD PTR [edi+400]
	movss	DWORD PTR [edi+420], xmm1
	jne	SHORT $LN24@Columns
	movss	xmm2, DWORD PTR [ebx+5400]
$LN24@Columns:
	mov	DWORD PTR [edi+408], 0
	subss	xmm0, DWORD PTR [edi+92]
	subss	xmm0, xmm2
	movss	DWORD PTR [edi+424], xmm0

; 10585:     window->DC.ColumnsStartPosY = window->DC.CursorPos.y;

	movss	xmm0, DWORD PTR [edi+196]
	movss	DWORD PTR [edi+428], xmm0
	movss	DWORD PTR [edi+436], xmm0

; 10586:     window->DC.ColumnsCellMinY = window->DC.ColumnsCellMaxY = window->DC.CursorPos.y;

	movss	DWORD PTR [edi+432], xmm0

; 10587:     window->DC.ColumnsOffsetX = 0.0f;
; 10588:     window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.IndentX + window->DC.ColumnsOffsetX);

	movss	xmm0, DWORD PTR [edi+24]
	addss	xmm0, xmm1
	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [edi+192], xmm0

; 10589: 
; 10590:     if (window->DC.ColumnsCount != 1)

	cmp	ecx, 1
	je	$LN16@Columns

; 10591:     {
; 10592:         // Cache column offsets
; 10593:         window->DC.ColumnsData.resize(columns_count + 1);

	lea	esi, DWORD PTR [ecx+1]
	push	esi
	lea	ecx, DWORD PTR [edi+448]
	call	?resize@?$ImVector@UImGuiColumnData@@@@QAEXH@Z ; ImVector<ImGuiColumnData>::resize

; 10594:         for (int column_index = 0; column_index < columns_count + 1; column_index++)

	xor	ebx, ebx
	test	esi, esi
	jle	SHORT $LN6@Columns
$LL7@Columns:

; 10595:         {
; 10596:             const ImGuiID column_id = window->DC.ColumnsSetId + ImGuiID(column_index);

	mov	esi, DWORD PTR [edi+444]
	add	esi, ebx

; 10597:             KeepAliveID(column_id);

	push	esi
	call	?KeepAliveID@ImGui@@YAXI@Z		; ImGui::KeepAliveID
	movd	xmm0, DWORD PTR [edi+416]
	movd	xmm1, ebx

; 10598:             const float default_t = column_index / (float)window->DC.ColumnsCount;

	cvtdq2ps xmm1, xmm1

; 10599:             const float t = window->DC.StateStorage->GetFloat(column_id, default_t);      // Cheaply store our floating point value inside the integer (could store a union into the map?)

	mov	ecx, DWORD PTR [edi+304]
	cvtdq2ps xmm0, xmm0
	divss	xmm1, xmm0
	movss	DWORD PTR [esp], xmm1
	push	esi
	call	?GetFloat@ImGuiStorage@@QBEMIM@Z	; ImGuiStorage::GetFloat

; 10600:             window->DC.ColumnsData[column_index].OffsetNorm = t;

	mov	eax, DWORD PTR [edi+456]
	fstp	DWORD PTR [eax+ebx*4]
	mov	eax, DWORD PTR _columns_count$[ebp]
	inc	ebx
	inc	eax
	cmp	ebx, eax
	jl	SHORT $LL7@Columns
$LN6@Columns:

; 10601:         }
; 10602:         window->DrawList->ChannelsSplit(window->DC.ColumnsCount);

	push	DWORD PTR [edi+416]
	mov	ecx, DWORD PTR [edi+624]
	call	?ChannelsSplit@ImDrawList@@QAEXH@Z	; ImDrawList::ChannelsSplit

; 10603:         PushColumnClipRect();

	push	-1
	call	?PushColumnClipRect@@YAXH@Z		; PushColumnClipRect

; 10604:         PushItemWidth(GetColumnWidth() * 0.65f);

	push	-1
	call	?GetColumnWidth@ImGui@@YAMH@Z		; ImGui::GetColumnWidth
	fmul	DWORD PTR __real@3f266666
	add	esp, 4
	fstp	DWORD PTR [esp]
	call	?PushItemWidth@ImGui@@YAXM@Z		; ImGui::PushItemWidth
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx

; 10609:     }
; 10610: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN16@Columns:

; 10605:     }
; 10606:     else
; 10607:     {
; 10608:         window->DC.ColumnsData.resize(0);

	push	0
	lea	ecx, DWORD PTR [edi+448]
	call	?resize@?$ImVector@UImGuiColumnData@@@@QAEXH@Z ; ImVector<ImGuiColumnData>::resize
	pop	edi
	pop	esi
	pop	ebx

; 10609:     }
; 10610: }

	mov	esp, ebp
	pop	ebp
	ret	0
?Columns@ImGui@@YAXHPBD_N@Z ENDP			; ImGui::Columns
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
tv151 = -4						; size = 4
?GetItemsLineHeightWithSpacing@ImGui@@YAMXZ PROC	; ImGui::GetItemsLineHeightWithSpacing

; 6089 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 6090 :     ImGuiContext& g = *GImGui;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 6091 :     return g.FontSize + g.Style.FramePadding.y * 2.0f + g.Style.ItemSpacing.y;

	movss	xmm0, DWORD PTR [eax+5360]
	addss	xmm0, xmm0
	addss	xmm0, DWORD PTR [eax+6172]
	addss	xmm0, DWORD PTR [eax+5372]
	movss	DWORD PTR tv151[ebp], xmm0
	fld	DWORD PTR tv151[ebp]

; 6092 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetItemsLineHeightWithSpacing@ImGui@@YAMXZ ENDP	; ImGui::GetItemsLineHeightWithSpacing
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?GetTextLineHeightWithSpacing@ImGui@@YAMXZ PROC		; ImGui::GetTextLineHeightWithSpacing

; 6084 :     ImGuiContext& g = *GImGui;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 6085 :     return g.FontSize + g.Style.ItemSpacing.y;

	fld	DWORD PTR [eax+6172]
	fadd	DWORD PTR [eax+5372]

; 6086 : }

	ret	0
?GetTextLineHeightWithSpacing@ImGui@@YAMXZ ENDP		; ImGui::GetTextLineHeightWithSpacing
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?GetTextLineHeight@ImGui@@YAMXZ PROC			; ImGui::GetTextLineHeight

; 6078 :     ImGuiContext& g = *GImGui;
; 6079 :     return g.FontSize;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	fld	DWORD PTR [eax+6172]

; 6080 : }

	ret	0
?GetTextLineHeight@ImGui@@YAMXZ ENDP			; ImGui::GetTextLineHeight
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 8
?AlignFirstTextHeightToWidgets@ImGui@@YAXXZ PROC	; ImGui::AlignFirstTextHeightToWidgets

; 6430 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6430 : {

	sub	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6432 :     if (window->SkipItems)

	mov	eax, DWORD PTR [ecx+6240]
	cmp	BYTE PTR [eax+137], 0
	jne	SHORT $LN1@AlignFirst

; 6433 :         return;
; 6434 : 
; 6435 :     // Declare a dummy item size to that upcoming items that are smaller will center-align on the newly expanded line height.
; 6436 :     ImGuiContext& g = *GImGui;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 6437 :     ItemSize(ImVec2(0, g.FontSize + g.Style.FramePadding.y*2), g.Style.FramePadding.y);

	push	ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6437 :     ItemSize(ImVec2(0, g.FontSize + g.Style.FramePadding.y*2), g.Style.FramePadding.y);

	movss	xmm1, DWORD PTR [eax+5360]
	movaps	xmm0, xmm1
	movss	DWORD PTR [esp], xmm1
	addss	xmm0, xmm1
	addss	xmm0, DWORD PTR [eax+6172]
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6437 :     ItemSize(ImVec2(0, g.FontSize + g.Style.FramePadding.y*2), g.Style.FramePadding.y);

	call	?ItemSize@ImGui@@YAXABUImVec2@@M@Z	; ImGui::ItemSize

; 6438 :     SameLine(0, 0);

	mov	DWORD PTR [esp+4], 0
	mov	DWORD PTR [esp], 0
	call	?SameLine@ImGui@@YAXMM@Z		; ImGui::SameLine
	add	esp, 8
$LN1@AlignFirst:

; 6439 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AlignFirstTextHeightToWidgets@ImGui@@YAXXZ ENDP	; ImGui::AlignFirstTextHeightToWidgets
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 8
_screen_pos$ = 8					; size = 4
?SetCursorScreenPos@ImGui@@YAXABUImVec2@@@Z PROC	; ImGui::SetCursorScreenPos

; 6177 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	edx, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6179 :     window->DC.CursorPos = screen_pos;

	mov	ecx, DWORD PTR _screen_pos$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx+192], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+196], eax
	movss	xmm0, DWORD PTR [edx+216]
	maxss	xmm0, DWORD PTR [edx+192]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm0
	movss	xmm0, DWORD PTR [edx+220]
	maxss	xmm0, DWORD PTR [edx+196]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6180 :     window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);

	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR [edx+216], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6180 :     window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);

	mov	eax, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR [edx+220], eax

; 6181 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetCursorScreenPos@ImGui@@YAXABUImVec2@@@Z ENDP	; ImGui::SetCursorScreenPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetCursorScreenPos@ImGui@@YA?AUImVec2@@XZ PROC		; ImGui::GetCursorScreenPos

; 6171 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 6172 :     ImGuiWindow* window = GetCurrentWindowRead();
; 6173 :     return window->DC.CursorPos;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	edx, DWORD PTR [eax+6240]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [edx+192]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+196]
	mov	DWORD PTR [eax+4], ecx

; 6174 : }

	pop	ebp
	ret	0
?GetCursorScreenPos@ImGui@@YA?AUImVec2@@XZ ENDP		; ImGui::GetCursorScreenPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetCursorStartPos@ImGui@@YA?AUImVec2@@XZ PROC		; ImGui::GetCursorStartPos

; 6165 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 792  :     inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	ecx, DWORD PTR [eax+6240]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [ecx+208]
	subss	xmm0, DWORD PTR [ecx+24]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [ecx+212]
	subss	xmm0, DWORD PTR [ecx+28]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6168 : }

	pop	ebp
	ret	0
?GetCursorStartPos@ImGui@@YA?AUImVec2@@XZ ENDP		; ImGui::GetCursorStartPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_y$ = 8							; size = 4
?SetCursorPosY@ImGui@@YAXM@Z PROC			; ImGui::SetCursorPosY

; 6158 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	eax, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6160 :     window->DC.CursorPos.y = window->Pos.y - window->Scroll.y + y;

	movss	xmm1, DWORD PTR [eax+28]
	subss	xmm1, DWORD PTR [eax+96]
	movss	xmm0, DWORD PTR [eax+220]
	addss	xmm1, DWORD PTR _y$[ebp]
	maxss	xmm0, xmm1
	movss	DWORD PTR [eax+196], xmm1

; 6161 :     window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y);

	movss	DWORD PTR [eax+220], xmm0

; 6162 : }

	pop	ebp
	ret	0
?SetCursorPosY@ImGui@@YAXM@Z ENDP			; ImGui::SetCursorPosY
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_x$ = 8							; size = 4
?SetCursorPosX@ImGui@@YAXM@Z PROC			; ImGui::SetCursorPosX

; 6151 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	eax, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6153 :     window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + x;

	movss	xmm1, DWORD PTR [eax+24]
	subss	xmm1, DWORD PTR [eax+92]
	movss	xmm0, DWORD PTR [eax+216]
	addss	xmm1, DWORD PTR _x$[ebp]
	maxss	xmm0, xmm1
	movss	DWORD PTR [eax+192], xmm1

; 6154 :     window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPos.x);

	movss	DWORD PTR [eax+216], xmm0

; 6155 : }

	pop	ebp
	ret	0
?SetCursorPosX@ImGui@@YAXM@Z ENDP			; ImGui::SetCursorPosX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T2 = -8						; size = 8
$T3 = -8						; size = 8
_local_pos$ = 8						; size = 4
?SetCursorPos@ImGui@@YAXABUImVec2@@@Z PROC		; ImGui::SetCursorPos

; 6144 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	ecx, DWORD PTR [ecx+6240]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	mov	eax, DWORD PTR _local_pos$[ebp]

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm1, DWORD PTR [ecx+24]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [eax]

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm1, DWORD PTR [ecx+92]
	movss	xmm2, DWORD PTR [ecx+28]
	subss	xmm2, DWORD PTR [ecx+96]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [eax+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6146 :     window->DC.CursorPos = window->Pos - window->Scroll + local_pos;

	mov	eax, DWORD PTR $T3[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6146 :     window->DC.CursorPos = window->Pos - window->Scroll + local_pos;

	mov	DWORD PTR [ecx+192], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6146 :     window->DC.CursorPos = window->Pos - window->Scroll + local_pos;

	mov	eax, DWORD PTR $T3[ebp+4]
	mov	DWORD PTR [ecx+196], eax
	movss	xmm0, DWORD PTR [ecx+216]
	maxss	xmm0, DWORD PTR [ecx+192]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp], xmm0
	movss	xmm0, DWORD PTR [ecx+220]
	maxss	xmm0, DWORD PTR [ecx+196]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6147 :     window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);

	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR [ecx+216], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6147 :     window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);

	mov	eax, DWORD PTR $T2[ebp+4]
	mov	DWORD PTR [ecx+220], eax

; 6148 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetCursorPos@ImGui@@YAXABUImVec2@@@Z ENDP		; ImGui::SetCursorPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?GetCursorPosY@ImGui@@YAMXZ PROC			; ImGui::GetCursorPosY
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 792  :     inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [eax+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6140 :     return window->DC.CursorPos.y - window->Pos.y + window->Scroll.y;

	fld	DWORD PTR [eax+196]
	fsub	DWORD PTR [eax+28]
	fadd	DWORD PTR [eax+96]

; 6141 : }

	ret	0
?GetCursorPosY@ImGui@@YAMXZ ENDP			; ImGui::GetCursorPosY
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?GetCursorPosX@ImGui@@YAMXZ PROC			; ImGui::GetCursorPosX
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 792  :     inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [eax+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6134 :     return window->DC.CursorPos.x - window->Pos.x + window->Scroll.x;

	fld	DWORD PTR [eax+192]
	fsub	DWORD PTR [eax+24]
	fadd	DWORD PTR [eax+92]

; 6135 : }

	ret	0
?GetCursorPosX@ImGui@@YAMXZ ENDP			; ImGui::GetCursorPosX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetCursorPos@ImGui@@YA?AUImVec2@@XZ PROC		; ImGui::GetCursorPos

; 6126 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 792  :     inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	ecx, DWORD PTR [eax+6240]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm1, DWORD PTR [ecx+192]
	subss	xmm1, DWORD PTR [ecx+24]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [ecx+92]

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm2, DWORD PTR [ecx+196]
	subss	xmm2, DWORD PTR [ecx+28]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [ecx+96]
	addss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [eax+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6129 : }

	pop	ebp
	ret	0
?GetCursorPos@ImGui@@YA?AUImVec2@@XZ ENDP		; ImGui::GetCursorPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_group_bb$ = -28					; size = 16
$T1 = -12						; size = 8
$T2 = -12						; size = 8
$T3 = -12						; size = 8
tv390 = -4						; size = 4
?EndGroup@ImGui@@YAXXZ PROC				; ImGui::EndGroup

; 10326: {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi

; 10327:     ImGuiContext& g = *GImGui;

	mov	edi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [edi+6240]
	mov	BYTE PTR [eax+134], 1
	mov	esi, DWORD PTR [edi+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10332:     ImGuiGroupData& group_data = window->DC.GroupStack.back();

	mov	ecx, DWORD PTR [esi+368]
	mov	eax, DWORD PTR [esi+360]
	mov	DWORD PTR tv390[ebp], ecx
	lea	ebx, DWORD PTR [eax+eax*4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [ecx+ebx*8-40]
	mov	DWORD PTR _group_bb$[ebp], eax
	mov	eax, DWORD PTR [ecx+ebx*8-36]
	movss	xmm3, DWORD PTR _group_bb$[ebp]
	mov	DWORD PTR _group_bb$[ebp+4], eax
	mov	eax, DWORD PTR [esi+216]
	movss	xmm4, DWORD PTR _group_bb$[ebp+4]
	mov	DWORD PTR _group_bb$[ebp+8], eax
	movaps	xmm2, xmm4
	mov	eax, DWORD PTR [esi+220]
	movss	xmm1, DWORD PTR _group_bb$[ebp+8]
	mov	DWORD PTR _group_bb$[ebp+12], eax
	maxss	xmm1, xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10335:     group_bb.Max.y -= g.Style.ItemSpacing.y;      // Cancel out last vertical spacing because we are adding one ourselves.

	movss	xmm0, DWORD PTR _group_bb$[ebp+12]
	subss	xmm0, DWORD PTR [edi+5372]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10336:     group_bb.Max = ImMax(group_bb.Min, group_bb.Max);

	mov	eax, DWORD PTR $T3[ebp]
	maxss	xmm2, xmm0
	mov	DWORD PTR _group_bb$[ebp+8], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10336:     group_bb.Max = ImMax(group_bb.Min, group_bb.Max);

	mov	eax, DWORD PTR $T3[ebp+4]
	mov	DWORD PTR _group_bb$[ebp+12], eax

; 10337: 
; 10338:     window->DC.CursorPos = group_data.BackupCursorPos;

	mov	eax, DWORD PTR [ecx+ebx*8-40]
	mov	DWORD PTR [esi+192], eax
	mov	eax, DWORD PTR [ecx+ebx*8-36]
	mov	DWORD PTR [esi+196], eax
	movss	xmm0, DWORD PTR [ecx+ebx*8-32]
	maxss	xmm0, DWORD PTR [esi+216]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp], xmm0
	movss	xmm0, DWORD PTR [ecx+ebx*8-28]
	maxss	xmm0, DWORD PTR [esi+220]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10339:     window->DC.CursorMaxPos = ImMax(group_data.BackupCursorMaxPos, window->DC.CursorMaxPos);

	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR [esi+216], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10339:     window->DC.CursorMaxPos = ImMax(group_data.BackupCursorMaxPos, window->DC.CursorMaxPos);

	mov	eax, DWORD PTR $T2[ebp+4]

; 10340:     window->DC.CurrentLineHeight = group_data.BackupCurrentLineHeight;
; 10341:     window->DC.CurrentLineTextBaseOffset = group_data.BackupCurrentLineTextBaseOffset;
; 10342:     window->DC.IndentX = group_data.BackupIndentX;
; 10343:     window->DC.GroupOffsetX = group_data.BackupGroupOffsetX;
; 10344:     window->DC.LogLinePosY = window->DC.CursorPos.y - 9999.0f;

	movss	xmm0, DWORD PTR [esi+196]
	subss	xmm0, DWORD PTR __real@461c3c00
	mov	DWORD PTR [esi+220], eax
	mov	eax, DWORD PTR [ecx+ebx*8-16]
	mov	DWORD PTR [esi+224], eax
	mov	eax, DWORD PTR [ecx+ebx*8-12]
	mov	DWORD PTR [esi+228], eax
	mov	eax, DWORD PTR [ecx+ebx*8-24]
	mov	DWORD PTR [esi+400], eax
	mov	eax, DWORD PTR [ecx+ebx*8-20]
	mov	DWORD PTR [esi+404], eax
	movss	DWORD PTR [esi+240], xmm0

; 10345: 
; 10346:     if (group_data.AdvanceCursor)

	cmp	BYTE PTR [ecx+ebx*8-3], 0
	je	SHORT $LN2@EndGroup
	movss	xmm0, DWORD PTR [esi+236]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 245  :     ImVec2      GetSize() const                 { return ImVec2(Max.x-Min.x, Max.y-Min.y); }

	subss	xmm1, xmm3
	maxss	xmm0, DWORD PTR [ecx+ebx*8-12]
	subss	xmm2, xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10349:         ItemSize(group_bb.GetSize(), group_data.BackupCurrentLineTextBaseOffset);

	push	ecx
	lea	eax, DWORD PTR $T1[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10348:         window->DC.CurrentLineTextBaseOffset = ImMax(window->DC.PrevLineTextBaseOffset, group_data.BackupCurrentLineTextBaseOffset);      // FIXME: Incorrect, we should grab the base offset from the *first line* of the group but it is hard to obtain now.

	movss	DWORD PTR [esi+228], xmm0

; 10349:         ItemSize(group_bb.GetSize(), group_data.BackupCurrentLineTextBaseOffset);

	movss	xmm0, DWORD PTR [ecx+ebx*8-12]
	movss	DWORD PTR [esp], xmm0
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10349:         ItemSize(group_bb.GetSize(), group_data.BackupCurrentLineTextBaseOffset);

	call	?ItemSize@ImGui@@YAXABUImVec2@@M@Z	; ImGui::ItemSize

; 10350:         ItemAdd(group_bb, NULL);

	push	0
	lea	eax, DWORD PTR _group_bb$[ebp]
	push	0
	push	eax
	call	?ItemAdd@ImGui@@YA_NABUImRect@@PBIPBU2@@Z ; ImGui::ItemAdd
	mov	ecx, DWORD PTR tv390[ebp]
	add	esp, 20					; 00000014H
$LN2@EndGroup:

; 10351:     }
; 10352: 
; 10353:     // If the current ActiveId was declared within the boundary of our group, we copy it to LastItemId so IsItemActive() will function on the entire group.
; 10354:     // It would be be neater if we replaced window.DC.LastItemId by e.g. 'bool LastItemIsActive', but if you search for LastItemId you'll notice it is only used in that context.
; 10355:     const bool active_id_within_group = (!group_data.BackupActiveIdIsAlive && g.ActiveIdIsAlive && g.ActiveId && g.ActiveIdWindow->RootWindow == window->RootWindow);

	cmp	BYTE PTR [ecx+ebx*8-4], 0
	jne	SHORT $LN4@EndGroup
	cmp	BYTE PTR [edi+6272], 0
	je	SHORT $LN4@EndGroup
	mov	ecx, DWORD PTR [edi+6264]
	test	ecx, ecx
	je	SHORT $LN4@EndGroup
	mov	eax, DWORD PTR [edi+6288]
	mov	eax, DWORD PTR [eax+632]
	cmp	eax, DWORD PTR [esi+632]
	jne	SHORT $LN4@EndGroup

; 10356:     if (active_id_within_group)
; 10357:         window->DC.LastItemId = g.ActiveId;

	mov	DWORD PTR [esi+248], ecx

; 10358:     if (active_id_within_group && g.HoveredId == g.ActiveId)

	mov	eax, DWORD PTR [edi+6252]
	cmp	eax, DWORD PTR [edi+6264]
	jne	SHORT $LN4@EndGroup

; 10359:         window->DC.LastItemHoveredAndUsable = window->DC.LastItemHoveredRect = true;

	mov	WORD PTR [esi+268], 257			; 00000101H
$LN4@EndGroup:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [esi+360]
	pop	edi
	pop	esi
	pop	ebx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10364: }

	mov	esp, ebp
	pop	ebp
	ret	0
?EndGroup@ImGui@@YAXXZ ENDP				; ImGui::EndGroup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?BeginGroup@ImGui@@YAXXZ PROC				; ImGui::BeginGroup
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	esi
	push	edi
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	edi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10306:     window->DC.GroupStack.resize(window->DC.GroupStack.Size + 1);

	mov	eax, DWORD PTR [edi+360]
	lea	ecx, DWORD PTR [edi+360]
	inc	eax
	push	eax
	call	?resize@?$ImVector@UImGuiGroupData@@@@QAEXH@Z ; ImVector<ImGuiGroupData>::resize

; 10307:     ImGuiGroupData& group_data = window->DC.GroupStack.back();

	mov	eax, DWORD PTR [edi+360]
	mov	ecx, DWORD PTR [edi+368]
	lea	edx, DWORD PTR [eax+eax*4]

; 10308:     group_data.BackupCursorPos = window->DC.CursorPos;

	mov	eax, DWORD PTR [edi+192]
	mov	DWORD PTR [ecx+edx*8-40], eax
	mov	eax, DWORD PTR [edi+196]
	mov	DWORD PTR [ecx+edx*8-36], eax

; 10309:     group_data.BackupCursorMaxPos = window->DC.CursorMaxPos;

	mov	eax, DWORD PTR [edi+216]
	mov	DWORD PTR [ecx+edx*8-32], eax
	mov	eax, DWORD PTR [edi+220]
	mov	DWORD PTR [ecx+edx*8-28], eax

; 10310:     group_data.BackupIndentX = window->DC.IndentX;

	mov	eax, DWORD PTR [edi+400]
	mov	DWORD PTR [ecx+edx*8-24], eax

; 10311:     group_data.BackupGroupOffsetX = window->DC.GroupOffsetX;

	mov	eax, DWORD PTR [edi+404]
	mov	DWORD PTR [ecx+edx*8-20], eax

; 10312:     group_data.BackupCurrentLineHeight = window->DC.CurrentLineHeight;

	mov	eax, DWORD PTR [edi+224]
	mov	DWORD PTR [ecx+edx*8-16], eax

; 10313:     group_data.BackupCurrentLineTextBaseOffset = window->DC.CurrentLineTextBaseOffset;

	mov	eax, DWORD PTR [edi+228]
	mov	DWORD PTR [ecx+edx*8-12], eax

; 10314:     group_data.BackupLogLinePosY = window->DC.LogLinePosY;

	mov	eax, DWORD PTR [edi+240]
	mov	DWORD PTR [ecx+edx*8-8], eax

; 10315:     group_data.BackupActiveIdIsAlive = GImGui->ActiveIdIsAlive;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	al, BYTE PTR [eax+6272]
	mov	BYTE PTR [ecx+edx*8-4], al

; 10316:     group_data.AdvanceCursor = true;

	mov	BYTE PTR [ecx+edx*8-3], 1

; 10317: 
; 10318:     window->DC.GroupOffsetX = window->DC.CursorPos.x - window->Pos.x - window->DC.ColumnsOffsetX;

	movss	xmm0, DWORD PTR [edi+192]
	subss	xmm0, DWORD PTR [edi+24]

; 10319:     window->DC.IndentX = window->DC.GroupOffsetX;
; 10320:     window->DC.CursorMaxPos = window->DC.CursorPos;

	mov	eax, DWORD PTR [edi+192]
	mov	DWORD PTR [edi+216], eax
	mov	eax, DWORD PTR [edi+196]
	mov	DWORD PTR [edi+220], eax
	subss	xmm0, DWORD PTR [edi+408]

; 10321:     window->DC.CurrentLineHeight = 0.0f;

	mov	DWORD PTR [edi+224], 0
	movss	DWORD PTR [edi+404], xmm0
	movss	DWORD PTR [edi+400], xmm0

; 10322:     window->DC.LogLinePosY = window->DC.CursorPos.y - 9999.0f;

	movss	xmm0, DWORD PTR [edi+196]
	subss	xmm0, DWORD PTR __real@461c3c00
	movss	DWORD PTR [edi+240], xmm0
	pop	edi
	pop	esi

; 10323: }

	ret	0
?BeginGroup@ImGui@@YAXXZ ENDP				; ImGui::BeginGroup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_indent_w$ = 8						; size = 4
?Unindent@ImGui@@YAXM@Z PROC				; ImGui::Unindent

; 10621: {

	npad	2
	push	ebp
	mov	ebp, esp

; 10622:     ImGuiContext& g = *GImGui;

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 10624:     window->DC.IndentX -= (indent_w > 0.0f) ? indent_w : g.Style.IndentSpacing;

	movss	xmm0, DWORD PTR _indent_w$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	eax, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10624:     window->DC.IndentX -= (indent_w > 0.0f) ? indent_w : g.Style.IndentSpacing;

	ja	SHORT $LN4@Unindent
	movss	xmm0, DWORD PTR [ecx+5392]
$LN4@Unindent:
	movss	xmm1, DWORD PTR [eax+400]
	subss	xmm1, xmm0

; 10625:     window->DC.CursorPos.x = window->Pos.x + window->DC.IndentX + window->DC.ColumnsOffsetX;

	movss	xmm0, DWORD PTR [eax+24]
	addss	xmm0, xmm1
	movss	DWORD PTR [eax+400], xmm1
	addss	xmm0, DWORD PTR [eax+408]
	movss	DWORD PTR [eax+192], xmm0

; 10626: }

	pop	ebp
	ret	0
?Unindent@ImGui@@YAXM@Z ENDP				; ImGui::Unindent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_indent_w$ = 8						; size = 4
?Indent@ImGui@@YAXM@Z PROC				; ImGui::Indent

; 10613: {

	npad	2
	push	ebp
	mov	ebp, esp

; 10614:     ImGuiContext& g = *GImGui;

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 10616:     window->DC.IndentX += (indent_w > 0.0f) ? indent_w : g.Style.IndentSpacing;

	movss	xmm0, DWORD PTR _indent_w$[ebp]
	comiss	xmm0, DWORD PTR __real@00000000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	eax, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10616:     window->DC.IndentX += (indent_w > 0.0f) ? indent_w : g.Style.IndentSpacing;

	ja	SHORT $LN4@Indent
	movss	xmm0, DWORD PTR [ecx+5392]
$LN4@Indent:
	movss	xmm1, DWORD PTR [eax+400]
	addss	xmm1, xmm0

; 10617:     window->DC.CursorPos.x = window->Pos.x + window->DC.IndentX + window->DC.ColumnsOffsetX;

	movss	xmm0, DWORD PTR [eax+24]
	addss	xmm0, xmm1
	movss	DWORD PTR [eax+400], xmm1
	addss	xmm0, DWORD PTR [eax+408]
	movss	DWORD PTR [eax+192], xmm0

; 10618: }

	pop	ebp
	ret	0
?Indent@ImGui@@YAXM@Z ENDP				; ImGui::Indent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_bb$ = -24						; size = 16
$T1 = -8						; size = 8
_size$ = 8						; size = 4
?Dummy@ImGui@@YAXABUImVec2@@@Z PROC			; ImGui::Dummy

; 10279: {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10279: {

	sub	esp, 24					; 00000018H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	ecx, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10281:     if (window->SkipItems)

	cmp	BYTE PTR [ecx+137], 0
	jne	SHORT $LN1@Dummy
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	mov	eax, DWORD PTR _size$[ebp]
	movss	xmm0, DWORD PTR [ecx+192]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10285:     ItemSize(bb);

	push	ecx
	mov	DWORD PTR [esp], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, DWORD PTR [eax]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [ecx+196]
	addss	xmm0, DWORD PTR [eax+4]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [ecx+192]
	mov	DWORD PTR _bb$[ebp], eax
	mov	eax, DWORD PTR [ecx+196]
	mov	DWORD PTR _bb$[ebp+4], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _bb$[ebp+8], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR _bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10285:     ItemSize(bb);

	lea	eax, DWORD PTR _bb$[ebp]
	push	eax
	call	?ItemSize@ImGui@@YAXABUImRect@@M@Z	; ImGui::ItemSize

; 10286:     ItemAdd(bb, NULL);

	push	0
	lea	eax, DWORD PTR _bb$[ebp]
	push	0
	push	eax
	call	?ItemAdd@ImGui@@YA_NABUImRect@@PBIPBU2@@Z ; ImGui::ItemAdd
	add	esp, 20					; 00000014H
$LN1@Dummy:

; 10287: }

	mov	esp, ebp
	pop	ebp
	ret	0
?Dummy@ImGui@@YAXABUImVec2@@@Z ENDP			; ImGui::Dummy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 8
?Spacing@ImGui@@YAXXZ PROC				; ImGui::Spacing

; 10271: {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10271: {

	sub	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10273:     if (window->SkipItems)

	mov	eax, DWORD PTR [ecx+6240]
	cmp	BYTE PTR [eax+137], 0
	jne	SHORT $LN1@Spacing

; 10275:     ItemSize(ImVec2(0,0));

	push	ecx
	lea	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR [esp], 0
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp], 0
	mov	DWORD PTR $T1[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10275:     ItemSize(ImVec2(0,0));

	call	?ItemSize@ImGui@@YAXABUImVec2@@M@Z	; ImGui::ItemSize
	add	esp, 8
$LN1@Spacing:

; 10276: }

	mov	esp, ebp
	pop	ebp
	ret	0
?Spacing@ImGui@@YAXXZ ENDP				; ImGui::Spacing
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 8
$T2 = -8						; size = 8
?NewLine@ImGui@@YAXXZ PROC				; ImGui::NewLine

; 10395: {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10395: {

	sub	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	eax, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10397:     if (window->SkipItems)

	cmp	BYTE PTR [eax+137], 0
	jne	SHORT $LN4@NewLine

; 10398:         return;
; 10399:     if (window->DC.CurrentLineHeight > 0.0f)     // In the event that we are on a line with items that is smaller that FontSize high, we will preserve its height.

	movss	xmm1, DWORD PTR [eax+224]
	xorps	xmm0, xmm0
	comiss	xmm1, xmm0

; 10400:         ItemSize(ImVec2(0,0));

	push	ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T2[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10400:         ItemSize(ImVec2(0,0));

	mov	DWORD PTR [esp], 0
	jbe	SHORT $LN3@NewLine

; 10402:         ItemSize(ImVec2(0.0f, GImGui->FontSize));

	lea	eax, DWORD PTR $T1[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T2[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10402:         ItemSize(ImVec2(0.0f, GImGui->FontSize));

	push	eax
	call	?ItemSize@ImGui@@YAXABUImVec2@@M@Z	; ImGui::ItemSize
	add	esp, 8

; 10403: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@NewLine:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	movss	xmm0, DWORD PTR [eax+6172]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10402:         ItemSize(ImVec2(0.0f, GImGui->FontSize));

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10402:         ItemSize(ImVec2(0.0f, GImGui->FontSize));

	call	?ItemSize@ImGui@@YAXABUImVec2@@M@Z	; ImGui::ItemSize
	add	esp, 8
$LN4@NewLine:

; 10403: }

	mov	esp, ebp
	pop	ebp
	ret	0
?NewLine@ImGui@@YAXXZ ENDP				; ImGui::NewLine
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_pos_x$ = 8						; size = 4
_spacing_w$ = 12					; size = 4
?SameLine@ImGui@@YAXMM@Z PROC				; ImGui::SameLine

; 10372: {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	ecx, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10374:     if (window->SkipItems)

	cmp	BYTE PTR [ecx+137], 0
	jne	$LN1@SameLine

; 10375:         return;
; 10376: 
; 10377:     ImGuiContext& g = *GImGui;
; 10378:     if (pos_x != 0.0f)

	movss	xmm0, DWORD PTR _pos_x$[ebp]
	xorps	xmm2, xmm2
	mov	edx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	ucomiss	xmm0, xmm2
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN3@SameLine

; 10379:     {
; 10380:         if (spacing_w < 0.0f) spacing_w = 0.0f;
; 10381:         window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + pos_x + spacing_w + window->DC.GroupOffsetX + window->DC.ColumnsOffsetX;

	movss	xmm1, DWORD PTR [ecx+24]
	subss	xmm1, DWORD PTR [ecx+92]
	addss	xmm1, xmm0
	movss	xmm0, DWORD PTR _spacing_w$[ebp]
	maxss	xmm0, xmm2
	addss	xmm1, xmm0
	addss	xmm1, DWORD PTR [ecx+404]
	addss	xmm1, DWORD PTR [ecx+408]
	movss	DWORD PTR [ecx+192], xmm1

; 10382:         window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;
; 10383:     }
; 10384:     else

	jmp	SHORT $LN10@SameLine
$LN3@SameLine:

; 10385:     {
; 10386:         if (spacing_w < 0.0f) spacing_w = g.Style.ItemSpacing.x;

	movss	xmm1, DWORD PTR _spacing_w$[ebp]
	comiss	xmm2, xmm1
	jbe	SHORT $LN6@SameLine
	movss	xmm1, DWORD PTR [edx+5368]
$LN6@SameLine:

; 10387:         window->DC.CursorPos.x = window->DC.CursorPosPrevLine.x + spacing_w;

	movss	xmm0, DWORD PTR [ecx+200]
	addss	xmm0, xmm1
	movss	DWORD PTR [ecx+192], xmm0
$LN10@SameLine:

; 10388:         window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;

	mov	eax, DWORD PTR [ecx+204]
	mov	DWORD PTR [ecx+196], eax

; 10389:     }
; 10390:     window->DC.CurrentLineHeight = window->DC.PrevLineHeight;

	mov	eax, DWORD PTR [ecx+232]
	mov	DWORD PTR [ecx+224], eax

; 10391:     window->DC.CurrentLineTextBaseOffset = window->DC.PrevLineTextBaseOffset;

	mov	eax, DWORD PTR [ecx+236]
	mov	DWORD PTR [ecx+228], eax
$LN1@SameLine:

; 10392: }

	pop	ebp
	ret	0
?SameLine@ImGui@@YAXMM@Z ENDP				; ImGui::SameLine
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_bb$ = -32						; size = 16
$T1 = -16						; size = 8
$T2 = -16						; size = 8
$T3 = -16						; size = 8
$T4 = -8						; size = 8
?Separator@ImGui@@YAXXZ PROC				; ImGui::Separator

; 10235: {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10235: {

	sub	esp, 32					; 00000020H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	push	esi
	mov	BYTE PTR [eax+134], 1
	mov	esi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10237:     if (window->SkipItems)

	cmp	BYTE PTR [esi+137], 0
	jne	$LN8@Separator

; 10238:         return;
; 10239: 
; 10240:     if (window->DC.ColumnsCount > 1)

	cmp	DWORD PTR [esi+416], 1
	jle	SHORT $LN3@Separator

; 10241:         PopClipRect();

	call	?PopClipRect@ImGui@@YAXXZ		; ImGui::PopClipRect
$LN3@Separator:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	cmp	DWORD PTR [esi+360], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10243:     float x1 = window->Pos.x;

	movss	xmm2, DWORD PTR [esi+24]

; 10244:     float x2 = window->Pos.x + window->Size.x;

	movss	xmm1, DWORD PTR [esi+32]
	addss	xmm1, xmm2

; 10245:     if (!window->DC.GroupStack.empty())

	je	SHORT $LN4@Separator

; 10246:         x1 += window->DC.IndentX;

	addss	xmm2, DWORD PTR [esi+400]
$LN4@Separator:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10248:     const ImRect bb(ImVec2(x1, window->DC.CursorPos.y), ImVec2(x2, window->DC.CursorPos.y+1.0f));

	movss	xmm1, DWORD PTR [esi+196]
	movaps	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10248:     const ImRect bb(ImVec2(x1, window->DC.CursorPos.y), ImVec2(x2, window->DC.CursorPos.y+1.0f));

	addss	xmm0, DWORD PTR __real@3f800000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR _bb$[ebp], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T4[ebp+4]
	mov	DWORD PTR _bb$[ebp+4], eax
	mov	eax, DWORD PTR $T3[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _bb$[ebp+8], eax
	mov	eax, DWORD PTR $T3[ebp+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10249:     ItemSize(ImVec2(0.0f, 0.0f)); // NB: we don't provide our width so that it doesn't get feed back into AutoFit, we don't provide height to not alter layout.

	push	ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _bb$[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10249:     ItemSize(ImVec2(0.0f, 0.0f)); // NB: we don't provide our width so that it doesn't get feed back into AutoFit, we don't provide height to not alter layout.

	lea	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR [esp], 0
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR $T2[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10249:     ItemSize(ImVec2(0.0f, 0.0f)); // NB: we don't provide our width so that it doesn't get feed back into AutoFit, we don't provide height to not alter layout.

	call	?ItemSize@ImGui@@YAXABUImVec2@@M@Z	; ImGui::ItemSize

; 10250:     if (!ItemAdd(bb, NULL))

	push	0
	lea	eax, DWORD PTR _bb$[ebp]
	push	0
	push	eax
	call	?ItemAdd@ImGui@@YA_NABUImRect@@PBIPBU2@@Z ; ImGui::ItemAdd
	add	esp, 20					; 00000014H
	test	al, al
	jne	SHORT $LN5@Separator

; 10251:     {
; 10252:         if (window->DC.ColumnsCount > 1)

	cmp	DWORD PTR [esi+416], 1
	jle	$LN8@Separator

; 10253:             PushColumnClipRect();

	push	-1
	call	?PushColumnClipRect@@YAXH@Z		; PushColumnClipRect

; 10264:     {
; 10265:         PushColumnClipRect();

	add	esp, 4
	pop	esi

; 10267:     }
; 10268: }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@Separator:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR _bb$[ebp+8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10257:     window->DrawList->AddLine(bb.Min, ImVec2(bb.Max.x,bb.Min.y), GetColorU32(ImGuiCol_Border));

	sub	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm0
	movss	xmm0, DWORD PTR _bb$[ebp+4]
	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 10257:     window->DrawList->AddLine(bb.Min, ImVec2(bb.Max.x,bb.Min.y), GetColorU32(ImGuiCol_Border));

	mov	DWORD PTR [esp+4], 1065353216		; 3f800000H
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	5
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	ecx, DWORD PTR [esi+624]
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	eax, DWORD PTR _bb$[ebp]
	push	eax
	call	?AddLine@ImDrawList@@QAEXABUImVec2@@0IM@Z ; ImDrawList::AddLine

; 10258: 
; 10259:     ImGuiContext& g = *GImGui;
; 10260:     if (g.LogEnabled)

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	cmp	BYTE PTR [eax+11600], 0
	je	SHORT $LN7@Separator

; 10261:         LogText(IM_NEWLINE "--------------------------------");

	push	OFFSET $SG122369
	call	?LogText@ImGui@@YAXPBDZZ		; ImGui::LogText
	add	esp, 4
$LN7@Separator:

; 10262: 
; 10263:     if (window->DC.ColumnsCount > 1)

	cmp	DWORD PTR [esi+416], 1
	jle	SHORT $LN8@Separator

; 10264:     {
; 10265:         PushColumnClipRect();

	push	-1
	call	?PushColumnClipRect@@YAXH@Z		; PushColumnClipRect

; 10266:         window->DC.ColumnsCellMinY = window->DC.CursorPos.y;

	mov	eax, DWORD PTR [esi+196]
	add	esp, 4
	mov	DWORD PTR [esi+432], eax
$LN8@Separator:
	pop	esi

; 10267:     }
; 10268: }

	mov	esp, ebp
	pop	ebp
	ret	0
?Separator@ImGui@@YAXXZ ENDP				; ImGui::Separator
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?PopButtonRepeat@ImGui@@YAXXZ PROC			; ImGui::PopButtonRepeat

; 5630 :     PopItemFlag();

	jmp	?PopItemFlag@ImGui@@YAXXZ		; ImGui::PopItemFlag
?PopButtonRepeat@ImGui@@YAXXZ ENDP			; ImGui::PopButtonRepeat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_repeat$ = 8						; size = 1
?PushButtonRepeat@ImGui@@YAX_N@Z PROC			; ImGui::PushButtonRepeat

; 5624 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 5625 :     PushItemFlag(ImGuiItemFlags_ButtonRepeat, repeat);

	push	DWORD PTR _repeat$[ebp]
	push	4
	call	?PushItemFlag@ImGui@@YAXH_N@Z		; ImGui::PushItemFlag
	add	esp, 8

; 5626 : }

	pop	ebp
	ret	0
?PushButtonRepeat@ImGui@@YAX_N@Z ENDP			; ImGui::PushButtonRepeat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?PopAllowKeyboardFocus@ImGui@@YAXXZ PROC		; ImGui::PopAllowKeyboardFocus

; 5620 :     PopItemFlag();

	jmp	?PopItemFlag@ImGui@@YAXXZ		; ImGui::PopItemFlag
?PopAllowKeyboardFocus@ImGui@@YAXXZ ENDP		; ImGui::PopAllowKeyboardFocus
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_allow_keyboard_focus$ = 8				; size = 1
?PushAllowKeyboardFocus@ImGui@@YAX_N@Z PROC		; ImGui::PushAllowKeyboardFocus

; 5614 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 5615 :     PushItemFlag(ImGuiItemFlags_AllowKeyboardFocus, allow_keyboard_focus);

	push	DWORD PTR _allow_keyboard_focus$[ebp]
	push	1
	call	?PushItemFlag@ImGui@@YAXH_N@Z		; ImGui::PushItemFlag
	add	esp, 8

; 5616 : }

	pop	ebp
	ret	0
?PushAllowKeyboardFocus@ImGui@@YAX_N@Z ENDP		; ImGui::PushAllowKeyboardFocus
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?PopTextWrapPos@ImGui@@YAXXZ PROC			; ImGui::PopTextWrapPos
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	edx, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [edx+348]

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	cmp	DWORD PTR [edx+348], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5644 :     window->DC.TextWrapPos = window->DC.TextWrapPosStack.empty() ? -1.0f : window->DC.TextWrapPosStack.back();

	jne	SHORT $LN3@PopTextWra
	movss	xmm0, DWORD PTR __real@bf800000
	movss	DWORD PTR [edx+320], xmm0

; 5645 : }

	ret	0
$LN3@PopTextWra:

; 5644 :     window->DC.TextWrapPos = window->DC.TextWrapPosStack.empty() ? -1.0f : window->DC.TextWrapPosStack.back();

	mov	ecx, DWORD PTR [edx+348]
	mov	eax, DWORD PTR [edx+356]
	movss	xmm0, DWORD PTR [eax+ecx*4-4]
	movss	DWORD PTR [edx+320], xmm0

; 5645 : }

	ret	0
?PopTextWrapPos@ImGui@@YAXXZ ENDP			; ImGui::PopTextWrapPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_wrap_pos_x$ = 8					; size = 4
?PushTextWrapPos@ImGui@@YAXM@Z PROC			; ImGui::PushTextWrapPos

; 5634 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5636 :     window->DC.TextWrapPos = wrap_pos_x;

	movss	xmm0, DWORD PTR _wrap_pos_x$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5637 :     window->DC.TextWrapPosStack.push_back(wrap_pos_x);

	lea	eax, DWORD PTR _wrap_pos_x$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5637 :     window->DC.TextWrapPosStack.push_back(wrap_pos_x);

	push	eax
	movss	DWORD PTR [ecx+320], xmm0
	add	ecx, 348				; 0000015cH
	call	?push_back@?$ImVector@M@@QAEXABM@Z	; ImVector<float>::push_back

; 5638 : }

	pop	ebp
	ret	0
?PushTextWrapPos@ImGui@@YAXM@Z ENDP			; ImGui::PushTextWrapPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 8
tv136 = -4						; size = 4
_w$1$ = -4						; size = 4
?CalcItemWidth@ImGui@@YAMXZ PROC			; ImGui::CalcItemWidth

; 5548 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 5549 :     ImGuiWindow* window = GetCurrentWindowRead();
; 5550 :     float w = window->DC.ItemWidth;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	xorps	xmm0, xmm0
	mov	eax, DWORD PTR [eax+6240]
	movss	xmm1, DWORD PTR [eax+316]

; 5551 :     if (w < 0.0f)

	comiss	xmm0, xmm1
	movss	DWORD PTR _w$1$[ebp], xmm1
	jbe	SHORT $LN2@CalcItemWi

; 5552 :     {
; 5553 :         // Align to a right-side limit. We include 1 frame padding in the calculation because this is how the width is always used (we add 2 frame padding to it), but we could move that responsibility to the widget as well.
; 5554 :         float width_to_right_edge = GetContentRegionAvail().x;

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetContentRegionAvail

; 5555 :         w = ImMax(1.0f, width_to_right_edge + w);

	movss	xmm1, DWORD PTR _w$1$[ebp]
	add	esp, 4
	addss	xmm1, DWORD PTR [eax]
	maxss	xmm1, DWORD PTR __real@3f800000
$LN2@CalcItemWi:

; 5556 :     }
; 5557 :     w = (float)(int)w;

	cvttss2si eax, xmm1
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0

; 5558 :     return w;

	movss	DWORD PTR tv136[ebp], xmm0
	fld	DWORD PTR tv136[ebp]

; 5559 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?CalcItemWidth@ImGui@@YAMXZ ENDP			; ImGui::CalcItemWidth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?PopItemWidth@ImGui@@YAXXZ PROC				; ImGui::PopItemWidth
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	edx, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [edx+336]

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	cmp	DWORD PTR [edx+336], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5544 :     window->DC.ItemWidth = window->DC.ItemWidthStack.empty() ? window->ItemWidthDefault : window->DC.ItemWidthStack.back();

	jne	SHORT $LN3@PopItemWid
	movss	xmm0, DWORD PTR [edx+524]
	movss	DWORD PTR [edx+316], xmm0

; 5545 : }

	ret	0
$LN3@PopItemWid:

; 5544 :     window->DC.ItemWidth = window->DC.ItemWidthStack.empty() ? window->ItemWidthDefault : window->DC.ItemWidthStack.back();

	mov	ecx, DWORD PTR [edx+336]
	mov	eax, DWORD PTR [edx+344]
	movss	xmm0, DWORD PTR [eax+ecx*4-4]
	movss	DWORD PTR [edx+316], xmm0

; 5545 : }

	ret	0
?PopItemWidth@ImGui@@YAXXZ ENDP				; ImGui::PopItemWidth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_item_width$ = 8					; size = 4
?PushItemWidth@ImGui@@YAXM@Z PROC			; ImGui::PushItemWidth

; 5520 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 5522 :     window->DC.ItemWidth = (item_width == 0.0f ? window->ItemWidthDefault : item_width);

	movss	xmm0, DWORD PTR _item_width$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5522 :     window->DC.ItemWidth = (item_width == 0.0f ? window->ItemWidthDefault : item_width);

	ucomiss	xmm0, DWORD PTR __real@00000000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	ecx, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5522 :     window->DC.ItemWidth = (item_width == 0.0f ? window->ItemWidthDefault : item_width);

	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@PushItemWi
	movss	xmm0, DWORD PTR [ecx+524]
$LN3@PushItemWi:
	lea	eax, DWORD PTR [ecx+316]

; 5523 :     window->DC.ItemWidthStack.push_back(window->DC.ItemWidth);

	add	ecx, 336				; 00000150H
	movss	DWORD PTR [eax], xmm0
	push	eax
	call	?push_back@?$ImVector@M@@QAEXABM@Z	; ImVector<float>::push_back

; 5524 : }

	pop	ebp
	ret	0
?PushItemWidth@ImGui@@YAXM@Z ENDP			; ImGui::PushItemWidth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_c$ = -16						; size = 16
_col$ = 8						; size = 4
?GetColorU32@ImGui@@YAIABUImVec4@@@Z PROC		; ImGui::GetColorU32

; 1296 : { 

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1297 :     ImVec4 c = col; 

	mov	eax, DWORD PTR _col$[ebp]
	movups	xmm1, XMMWORD PTR [eax]

; 1298 :     c.w *= GImGui->Style.Alpha; 

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	movups	XMMWORD PTR _c$[ebp], xmm1
	movss	xmm0, DWORD PTR [eax+5320]

; 1299 :     return ColorConvertFloat4ToU32(c); 

	lea	eax, DWORD PTR _c$[ebp]
	shufps	xmm1, xmm1, 255				; 000000ffH
	mulss	xmm0, xmm1
	push	eax
	movss	DWORD PTR _c$[ebp+12], xmm0
	call	?ColorConvertFloat4ToU32@ImGui@@YAIABUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	add	esp, 4

; 1300 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetColorU32@ImGui@@YAIABUImVec4@@@Z ENDP		; ImGui::GetColorU32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_c$ = -16						; size = 16
_idx$ = 8						; size = 4
_alpha_mul$ = 12					; size = 4
?GetColorU32@ImGui@@YAIHM@Z PROC			; ImGui::GetColorU32

; 1289 : { 

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1290 :     ImVec4 c = GImGui->Style.Colors[idx]; 

	mov	eax, DWORD PTR _idx$[ebp]
	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	add	eax, eax
	movups	xmm1, XMMWORD PTR [ecx+eax*8+5448]

; 1291 :     c.w *= GImGui->Style.Alpha * alpha_mul; 
; 1292 :     return ColorConvertFloat4ToU32(c); 

	lea	eax, DWORD PTR _c$[ebp]
	movss	xmm0, DWORD PTR [ecx+5320]
	mulss	xmm0, DWORD PTR _alpha_mul$[ebp]
	push	eax
	movups	XMMWORD PTR _c$[ebp], xmm1
	shufps	xmm1, xmm1, 255				; 000000ffH
	mulss	xmm0, xmm1
	movss	DWORD PTR _c$[ebp+12], xmm0
	call	?ColorConvertFloat4ToU32@ImGui@@YAIABUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	add	esp, 4

; 1293 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetColorU32@ImGui@@YAIHM@Z ENDP			; ImGui::GetColorU32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetFontTexUvWhitePixel@ImGui@@YA?AUImVec2@@XZ PROC	; ImGui::GetFontTexUvWhitePixel

; 6111 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 6112 :     return GImGui->FontTexUvWhitePixel;

	mov	edx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [edx+6180]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+6184]
	mov	DWORD PTR [eax+4], ecx

; 6113 : }

	pop	ebp
	ret	0
?GetFontTexUvWhitePixel@ImGui@@YA?AUImVec2@@XZ ENDP	; ImGui::GetFontTexUvWhitePixel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?GetFontSize@ImGui@@YAMXZ PROC				; ImGui::GetFontSize

; 6107 :     return GImGui->FontSize;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	fld	DWORD PTR [eax+6172]

; 6108 : }

	ret	0
?GetFontSize@ImGui@@YAMXZ ENDP				; ImGui::GetFontSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?GetFont@ImGui@@YAPAUImFont@@XZ PROC			; ImGui::GetFont

; 6102 :     return GImGui->Font;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [eax+6168]

; 6103 : }

	ret	0
?GetFont@ImGui@@YAPAUImFont@@XZ ENDP			; ImGui::GetFont
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 8
_this$1$ = 8						; size = 4
_count$ = 8						; size = 4
?PopStyleVar@ImGui@@YAXH@Z PROC				; ImGui::PopStyleVar

; 5725 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 5726 :     ImGuiContext& g = *GImGui;

	mov	edx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	sub	esp, 8
	push	esi

; 5727 :     while (count > 0)

	mov	esi, DWORD PTR _count$[ebp]
	test	esi, esi
	jle	$LN29@PopStyleVa
	push	ebx
	lea	ebx, DWORD PTR [edx+6332]
	mov	DWORD PTR _this$1$[ebp], ebx
	push	edi
$LL2@PopStyleVa:

; 5728 :     {
; 5729 :         ImGuiStyleMod& backup = g.StyleModifiers.back();

	mov	eax, DWORD PTR [ebx]
	mov	ebx, DWORD PTR [ebx+8]
	lea	edi, DWORD PTR [eax+eax*2]

; 5730 :         const ImGuiStyleVarInfo* info = GetStyleVarInfo(backup.VarIdx);

	push	DWORD PTR [ebx+edi*4-12]
	call	?GetStyleVarInfo@@YAPBUImGuiStyleVarInfo@@H@Z ; GetStyleVarInfo
	add	esp, 4

; 5731 :         if (info->Type == ImGuiDataType_Float)          (*(float*)info->GetVarPtr()) = backup.BackupFloat[0];

	mov	ecx, DWORD PTR [eax]
	cmp	ecx, 1
	je	SHORT $LN32@PopStyleVa

; 5732 :         else if (info->Type == ImGuiDataType_Float2)    (*(ImVec2*)info->GetVarPtr()) = ImVec2(backup.BackupFloat[0], backup.BackupFloat[1]);

	cmp	ecx, 2
	jne	SHORT $LN6@PopStyleVa
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR [ebx+edi*4-8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5732 :         else if (info->Type == ImGuiDataType_Float2)    (*(ImVec2*)info->GetVarPtr()) = ImVec2(backup.BackupFloat[0], backup.BackupFloat[1]);

	mov	ecx, DWORD PTR [eax+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm0
	movss	xmm0, DWORD PTR [ebx+edi*4-4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5732 :         else if (info->Type == ImGuiDataType_Float2)    (*(ImVec2*)info->GetVarPtr()) = ImVec2(backup.BackupFloat[0], backup.BackupFloat[1]);

	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR [ecx+edx+5320], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5732 :         else if (info->Type == ImGuiDataType_Float2)    (*(ImVec2*)info->GetVarPtr()) = ImVec2(backup.BackupFloat[0], backup.BackupFloat[1]);

	mov	eax, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR [ecx+edx+5324], eax
	jmp	SHORT $LN8@PopStyleVa
$LN6@PopStyleVa:

; 5733 :         else if (info->Type == ImGuiDataType_Int)       (*(int*)info->GetVarPtr()) = backup.BackupInt[0];

	test	ecx, ecx
	jne	SHORT $LN8@PopStyleVa
$LN32@PopStyleVa:
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ebx+edi*4-8]
	mov	DWORD PTR [ecx+edx+5320], eax
$LN8@PopStyleVa:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	mov	ebx, DWORD PTR _this$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5735 :         count--;

	dec	esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [ebx]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5727 :     while (count > 0)

	test	esi, esi
	jle	SHORT $LN31@PopStyleVa
	mov	edx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	jmp	SHORT $LL2@PopStyleVa
$LN31@PopStyleVa:
	pop	edi
	pop	ebx
$LN29@PopStyleVa:
	pop	esi

; 5736 :     }
; 5737 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PopStyleVar@ImGui@@YAXH@Z ENDP				; ImGui::PopStyleVar
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -20						; size = 12
_v$ = -8						; size = 8
_idx$ = 8						; size = 4
_val$ = 12						; size = 4
?PushStyleVar@ImGui@@YAXHABUImVec2@@@Z PROC		; ImGui::PushStyleVar

; 5712 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 5713 :     const ImGuiStyleVarInfo* var_info = GetStyleVarInfo(idx);

	mov	ecx, DWORD PTR _idx$[ebp]
	sub	esp, 20					; 00000014H
	push	ecx
	call	?GetStyleVarInfo@@YAPBUImGuiStyleVarInfo@@H@Z ; GetStyleVarInfo
	add	esp, 4

; 5714 :     if (var_info->Type == ImGuiDataType_Float2)

	cmp	DWORD PTR [eax], 2
	jne	SHORT $LN2@PushStyleV
	push	esi

; 5673 :     void*           GetVarPtr() const { return (void*)((unsigned char*)&GImGui->Style + Offset); }

	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	edi
	mov	edi, DWORD PTR [eax+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 288  :     ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v)  { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }

	mov	DWORD PTR $T1[ebp], ecx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5717 :         GImGui->StyleModifiers.push_back(ImGuiStyleMod(idx, *pvar));

	lea	ecx, DWORD PTR [esi+6332]
	mov	eax, DWORD PTR [edi+esi+5320]
	mov	DWORD PTR _v$[ebp], eax
	mov	eax, DWORD PTR [edi+esi+5324]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 288  :     ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v)  { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }

	movss	xmm0, DWORD PTR _v$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5717 :         GImGui->StyleModifiers.push_back(ImGuiStyleMod(idx, *pvar));

	mov	DWORD PTR _v$[ebp+4], eax
	lea	eax, DWORD PTR $T1[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 288  :     ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v)  { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }

	movss	DWORD PTR $T1[ebp+4], xmm0
	movss	xmm0, DWORD PTR _v$[ebp+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5717 :         GImGui->StyleModifiers.push_back(ImGuiStyleMod(idx, *pvar));

	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 288  :     ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v)  { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }

	movss	DWORD PTR $T1[ebp+8], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5717 :         GImGui->StyleModifiers.push_back(ImGuiStyleMod(idx, *pvar));

	call	?push_back@?$ImVector@UImGuiStyleMod@@@@QAEXABUImGuiStyleMod@@@Z ; ImVector<ImGuiStyleMod>::push_back

; 5718 :         *pvar = val;

	mov	ecx, DWORD PTR _val$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edi+esi+5320], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edi+esi+5324], eax
	pop	edi
	pop	esi
$LN2@PushStyleV:

; 5719 :         return;
; 5720 :     }
; 5721 :     IM_ASSERT(0); // Called function with wrong-type? Variable is not a ImVec2.
; 5722 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PushStyleVar@ImGui@@YAXHABUImVec2@@@Z ENDP		; ImGui::PushStyleVar
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 12
_idx$ = 8						; size = 4
_val$ = 12						; size = 4
?PushStyleVar@ImGui@@YAXHM@Z PROC			; ImGui::PushStyleVar

; 5699 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 5700 :     const ImGuiStyleVarInfo* var_info = GetStyleVarInfo(idx);

	mov	ecx, DWORD PTR _idx$[ebp]
	sub	esp, 12					; 0000000cH
	push	ecx
	call	?GetStyleVarInfo@@YAPBUImGuiStyleVarInfo@@H@Z ; GetStyleVarInfo
	add	esp, 4

; 5701 :     if (var_info->Type == ImGuiDataType_Float)

	cmp	DWORD PTR [eax], 1
	jne	SHORT $LN2@PushStyleV
	push	esi

; 5673 :     void*           GetVarPtr() const { return (void*)((unsigned char*)&GImGui->Style + Offset); }

	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 5704 :         GImGui->StyleModifiers.push_back(ImGuiStyleMod(idx, *pvar));

	lea	eax, DWORD PTR $T1[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 287  :     ImGuiStyleMod(ImGuiStyleVar idx, float v)   { VarIdx = idx; BackupFloat[0] = v; }

	mov	DWORD PTR $T1[ebp], ecx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5704 :         GImGui->StyleModifiers.push_back(ImGuiStyleMod(idx, *pvar));

	push	eax
	lea	ecx, DWORD PTR [esi+6332]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 287  :     ImGuiStyleMod(ImGuiStyleVar idx, float v)   { VarIdx = idx; BackupFloat[0] = v; }

	movss	xmm0, DWORD PTR [edi+esi+5320]
	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5704 :         GImGui->StyleModifiers.push_back(ImGuiStyleMod(idx, *pvar));

	call	?push_back@?$ImVector@UImGuiStyleMod@@@@QAEXABUImGuiStyleMod@@@Z ; ImVector<ImGuiStyleMod>::push_back

; 5705 :         *pvar = val;

	movss	xmm0, DWORD PTR _val$[ebp]
	movss	DWORD PTR [edi+esi+5320], xmm0
	pop	edi
	pop	esi
$LN2@PushStyleV:

; 5706 :         return;
; 5707 :     }
; 5708 :     IM_ASSERT(0); // Called function with wrong-type? Variable is not a float.
; 5709 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PushStyleVar@ImGui@@YAXHM@Z ENDP			; ImGui::PushStyleVar
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_count$ = 8						; size = 4
?PopStyleColor@ImGui@@YAXH@Z PROC			; ImGui::PopStyleColor

; 5658 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 5659 :     ImGuiContext& g = *GImGui;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	esi

; 5660 :     while (count > 0)

	mov	esi, DWORD PTR _count$[ebp]
	test	esi, esi
	jle	SHORT $LN3@PopStyleCo
$LL2@PopStyleCo:

; 5661 :     {
; 5662 :         ImGuiColMod& backup = g.ColorModifiers.back();

	mov	ecx, DWORD PTR [eax+6320]

; 5663 :         g.Style.Colors[backup.Col] = backup.BackupValue;
; 5664 :         g.ColorModifiers.pop_back();
; 5665 :         count--;

	dec	esi
	lea	edx, DWORD PTR [ecx+ecx*4]
	mov	ecx, DWORD PTR [eax+6328]
	movups	xmm0, XMMWORD PTR [ecx+edx*4-16]
	lea	edx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [edx-20]
	add	ecx, ecx
	movups	XMMWORD PTR [eax+ecx*8+5448], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [eax+6320]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5660 :     while (count > 0)

	test	esi, esi
	jg	SHORT $LL2@PopStyleCo
$LN3@PopStyleCo:
	pop	esi

; 5666 :     }
; 5667 : }

	pop	ebp
	ret	0
?PopStyleColor@ImGui@@YAXH@Z ENDP			; ImGui::PopStyleColor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_backup$ = -20						; size = 20
_idx$ = 8						; size = 4
_col$ = 12						; size = 4
?PushStyleColor@ImGui@@YAXHABUImVec4@@@Z PROC		; ImGui::PushStyleColor

; 5648 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi

; 5649 :     ImGuiContext& g = *GImGui;
; 5650 :     ImGuiColMod backup;
; 5651 :     backup.Col = idx;

	mov	esi, DWORD PTR _idx$[ebp]

; 5652 :     backup.BackupValue = g.Style.Colors[idx];
; 5653 :     g.ColorModifiers.push_back(backup);

	lea	eax, DWORD PTR _backup$[ebp]
	push	edi
	mov	edi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	DWORD PTR _backup$[ebp], esi
	add	esi, esi
	push	eax
	lea	ecx, DWORD PTR [edi+6320]
	movups	xmm0, XMMWORD PTR [edi+esi*8+5448]
	movups	XMMWORD PTR _backup$[ebp+4], xmm0
	call	?push_back@?$ImVector@UImGuiColMod@@@@QAEXABUImGuiColMod@@@Z ; ImVector<ImGuiColMod>::push_back

; 5654 :     g.Style.Colors[idx] = col;

	mov	eax, DWORD PTR _col$[ebp]
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [edi+esi*8+5448], xmm0
	pop	edi
	pop	esi

; 5655 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?PushStyleColor@ImGui@@YAXHABUImVec4@@@Z ENDP		; ImGui::PushStyleColor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?PopFont@ImGui@@YAXXZ PROC				; ImGui::PopFont

; 5589 : {

	npad	2
	push	esi

; 5590 :     ImGuiContext& g = *GImGui;

	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 5591 :     g.CurrentWindow->DrawList->PopTextureID();

	mov	ecx, DWORD PTR [esi+6240]
	mov	ecx, DWORD PTR [ecx+624]
	call	?PopTextureID@ImDrawList@@QAEXXZ	; ImDrawList::PopTextureID
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [esi+6344]

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	cmp	DWORD PTR [esi+6344], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5593 :     SetCurrentFont(g.FontStack.empty() ? GetDefaultFont() : g.FontStack.back());

	jne	SHORT $LN3@PopFont
	call	?GetDefaultFont@@YAPAUImFont@@XZ	; GetDefaultFont
	push	eax
	call	?SetCurrentFont@@YAXPAUImFont@@@Z	; SetCurrentFont
	add	esp, 4
	pop	esi

; 5594 : }

	ret	0
$LN3@PopFont:

; 5593 :     SetCurrentFont(g.FontStack.empty() ? GetDefaultFont() : g.FontStack.back());

	mov	ecx, DWORD PTR [esi+6344]
	mov	eax, DWORD PTR [esi+6352]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	push	eax
	call	?SetCurrentFont@@YAXPAUImFont@@@Z	; SetCurrentFont
	add	esp, 4
	pop	esi

; 5594 : }

	ret	0
?PopFont@ImGui@@YAXXZ ENDP				; ImGui::PopFont
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_font$ = 8						; size = 4
?PushFont@ImGui@@YAXPAUImFont@@@Z PROC			; ImGui::PushFont

; 5579 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 5580 :     ImGuiContext& g = *GImGui;
; 5581 :     if (!font)

	mov	esi, DWORD PTR _font$[ebp]
	push	edi
	mov	edi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	test	esi, esi
	jne	SHORT $LN2@PushFont

; 5582 :         font = GetDefaultFont();

	call	?GetDefaultFont@@YAPAUImFont@@XZ	; GetDefaultFont
	mov	esi, eax
	mov	DWORD PTR _font$[ebp], esi
$LN2@PushFont:

; 5583 :     SetCurrentFont(font);

	push	esi
	call	?SetCurrentFont@@YAXPAUImFont@@@Z	; SetCurrentFont
	add	esp, 4

; 5584 :     g.FontStack.push_back(font);

	lea	eax, DWORD PTR _font$[ebp]
	lea	ecx, DWORD PTR [edi+6344]
	push	eax
	call	?push_back@?$ImVector@PAUImFont@@@@QAEXABQAUImFont@@@Z ; ImVector<ImFont *>::push_back

; 5585 :     g.CurrentWindow->DrawList->PushTextureID(font->ContainerAtlas->TexID);

	mov	ecx, DWORD PTR [edi+6240]
	push	DWORD PTR [esi+68]
	mov	ecx, DWORD PTR [ecx+624]
	call	?PushTextureID@ImDrawList@@QAEXABQAX@Z	; ImDrawList::PushTextureID
	pop	edi
	pop	esi

; 5586 : }

	pop	ebp
	ret	0
?PushFont@ImGui@@YAXPAUImFont@@@Z ENDP			; ImGui::PushFont
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?GetStateStorage@ImGui@@YAPAUImGuiStorage@@XZ PROC	; ImGui::GetStateStorage

; 6253 :     ImGuiWindow* window = GetCurrentWindowRead();
; 6254 :     return window->DC.StateStorage;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [eax+6240]
	mov	eax, DWORD PTR [eax+304]

; 6255 : }

	ret	0
?GetStateStorage@ImGui@@YAPAUImGuiStorage@@XZ ENDP	; ImGui::GetStateStorage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_tree$ = 8						; size = 4
?SetStateStorage@ImGui@@YAXPAUImGuiStorage@@@Z PROC	; ImGui::SetStateStorage

; 6246 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6248 :     window->DC.StateStorage = tree ? tree : &window->StateStorage;

	mov	eax, DWORD PTR _tree$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6248 :     window->DC.StateStorage = tree ? tree : &window->StateStorage;

	test	eax, eax
	jne	SHORT $LN7@SetStateSt
	lea	eax, DWORD PTR [ecx+608]
$LN7@SetStateSt:
	mov	DWORD PTR [ecx+304], eax

; 6249 : }

	pop	ebp
	ret	0
?SetStateStorage@ImGui@@YAXPAUImGuiStorage@@@Z ENDP	; ImGui::SetStateStorage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_offset$ = 8						; size = 4
?SetKeyboardFocusHere@ImGui@@YAXH@Z PROC		; ImGui::SetKeyboardFocusHere

; 6239 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	edx, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6241 :     window->FocusIdxAllRequestNext = window->FocusIdxAllCounter + 1 + offset;

	mov	eax, DWORD PTR _offset$[ebp]
	inc	eax
	add	eax, DWORD PTR [edx+644]
	mov	DWORD PTR [edx+660], eax

; 6242 :     window->FocusIdxTabRequestNext = INT_MAX;

	mov	DWORD PTR [edx+664], 2147483647		; 7fffffffH

; 6243 : }

	pop	ebp
	ret	0
?SetKeyboardFocusHere@ImGui@@YAXH@Z ENDP		; ImGui::SetKeyboardFocusHere
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_pos_y$ = 8						; size = 4
_center_y_ratio$ = 12					; size = 4
?SetScrollFromPosY@ImGui@@YAXMM@Z PROC			; ImGui::SetScrollFromPosY

; 6220 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6225 :     if (center_y_ratio <= 0.0f && window->ScrollTarget.y <= window->WindowPadding.y)    // Minor hack to make "scroll to top" take account of WindowPadding, else it would scroll to (WindowPadding.y - ItemSpacing.y)

	movss	xmm1, DWORD PTR _center_y_ratio$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	ecx, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6224 :     window->ScrollTarget.y = (float)(int)(pos_y + window->Scroll.y);

	movss	xmm0, DWORD PTR [ecx+96]
	addss	xmm0, DWORD PTR _pos_y$[ebp]

; 6227 :     window->ScrollTargetCenterRatio.y = center_y_ratio;

	movss	DWORD PTR [ecx+112], xmm1
	cvttss2si eax, xmm0
	xorps	xmm0, xmm0
	comiss	xmm0, xmm1
	movd	xmm2, eax
	cvtdq2ps xmm2, xmm2
	movss	DWORD PTR [ecx+104], xmm2
	jb	SHORT $LN2@SetScrollF

; 6225 :     if (center_y_ratio <= 0.0f && window->ScrollTarget.y <= window->WindowPadding.y)    // Minor hack to make "scroll to top" take account of WindowPadding, else it would scroll to (WindowPadding.y - ItemSpacing.y)

	movss	xmm0, DWORD PTR [ecx+84]
	comiss	xmm0, xmm2
	jb	SHORT $LN2@SetScrollF

; 6226 :         window->ScrollTarget.y = 0.0f;

	mov	DWORD PTR [ecx+104], 0
$LN2@SetScrollF:

; 6228 : }

	pop	ebp
	ret	0
?SetScrollFromPosY@ImGui@@YAXMM@Z ENDP			; ImGui::SetScrollFromPosY
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_center_y_ratio$ = 8					; size = 4
?SetScrollHere@ImGui@@YAXM@Z PROC			; ImGui::SetScrollHere

; 6232 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6235 :     SetScrollFromPosY(target_y - window->Pos.y, center_y_ratio);

	sub	esp, 8
	movss	xmm1, DWORD PTR _center_y_ratio$[ebp]
	movaps	xmm0, xmm1
	subss	xmm0, DWORD PTR __real@3f000000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6235 :     SetScrollFromPosY(target_y - window->Pos.y, center_y_ratio);

	movss	DWORD PTR [esp+4], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	BYTE PTR [eax+134], 1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6234 :     float target_y = window->DC.CursorPosPrevLine.y + (window->DC.PrevLineHeight * center_y_ratio) + (GImGui->Style.ItemSpacing.y * (center_y_ratio - 0.5f) * 2.0f); // Precisely aim above, in the middle or below the last line.

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6234 :     float target_y = window->DC.CursorPosPrevLine.y + (window->DC.PrevLineHeight * center_y_ratio) + (GImGui->Style.ItemSpacing.y * (center_y_ratio - 0.5f) * 2.0f); // Precisely aim above, in the middle or below the last line.

	movss	xmm2, DWORD PTR [eax+5372]
	mulss	xmm2, xmm0
	movss	xmm0, DWORD PTR [ecx+232]
	mulss	xmm0, xmm1
	addss	xmm2, xmm2
	addss	xmm0, DWORD PTR [ecx+204]
	addss	xmm0, xmm2

; 6235 :     SetScrollFromPosY(target_y - window->Pos.y, center_y_ratio);

	subss	xmm0, DWORD PTR [ecx+28]
	movss	DWORD PTR [esp], xmm0
	call	?SetScrollFromPosY@ImGui@@YAXMM@Z	; ImGui::SetScrollFromPosY
	add	esp, 8

; 6236 : }

	pop	ebp
	ret	0
?SetScrollHere@ImGui@@YAXM@Z ENDP			; ImGui::SetScrollHere
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_scroll_y$ = 8						; size = 4
?SetScrollY@ImGui@@YAXM@Z PROC				; ImGui::SetScrollY

; 6213 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	xorps	xmm2, xmm2
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	eax, DWORD PTR [ecx+6240]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	edx, DWORD PTR [eax+8]
	test	dl, 1
	je	SHORT $LN7@SetScrollY
	xorps	xmm1, xmm1
	jmp	SHORT $LN8@SetScrollY
$LN7@SetScrollY:
	movss	xmm0, DWORD PTR [ecx+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm1, DWORD PTR [ecx+6176]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm0, xmm0

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm1, DWORD PTR [eax+620]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm1, xmm0
$LN8@SetScrollY:

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	test	edx, 1024				; 00000400H
	je	SHORT $LN13@SetScrollY
	movss	xmm0, DWORD PTR [ecx+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm2, DWORD PTR [ecx+6176]

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	addss	xmm0, xmm0

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm2, DWORD PTR [eax+620]

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	addss	xmm2, xmm0
$LN13@SetScrollY:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6215 :     window->ScrollTarget.y = scroll_y + window->TitleBarHeight() + window->MenuBarHeight(); // title bar height canceled out when using ScrollTargetRelY

	addss	xmm1, DWORD PTR _scroll_y$[ebp]

; 6216 :     window->ScrollTargetCenterRatio.y = 0.0f;

	mov	DWORD PTR [eax+112], 0
	addss	xmm1, xmm2
	movss	DWORD PTR [eax+104], xmm1

; 6217 : }

	pop	ebp
	ret	0
?SetScrollY@ImGui@@YAXM@Z ENDP				; ImGui::SetScrollY
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_scroll_x$ = 8						; size = 4
?SetScrollX@ImGui@@YAXM@Z PROC				; ImGui::SetScrollX

; 6206 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6208 :     window->ScrollTarget.x = scroll_x;

	movss	xmm0, DWORD PTR _scroll_x$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	eax, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6208 :     window->ScrollTarget.x = scroll_x;

	movss	DWORD PTR [eax+100], xmm0

; 6209 :     window->ScrollTargetCenterRatio.x = 0.0f;

	mov	DWORD PTR [eax+108], 0

; 6210 : }

	pop	ebp
	ret	0
?SetScrollX@ImGui@@YAXM@Z ENDP				; ImGui::SetScrollX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?GetScrollMaxY@ImGui@@YAMXZ PROC			; ImGui::GetScrollMaxY
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 792  :     inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [eax+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6202 :     return window->SizeContents.y - window->SizeFull.y - window->ScrollbarSizes.y;

	fld	DWORD PTR [eax+52]
	fsub	DWORD PTR [eax+44]
	fsub	DWORD PTR [eax+124]

; 6203 : }

	ret	0
?GetScrollMaxY@ImGui@@YAMXZ ENDP			; ImGui::GetScrollMaxY
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?GetScrollMaxX@ImGui@@YAMXZ PROC			; ImGui::GetScrollMaxX
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 792  :     inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [eax+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6196 :     return window->SizeContents.x - window->SizeFull.x - window->ScrollbarSizes.x;

	fld	DWORD PTR [eax+48]
	fsub	DWORD PTR [eax+40]
	fsub	DWORD PTR [eax+120]

; 6197 : }

	ret	0
?GetScrollMaxX@ImGui@@YAMXZ ENDP			; ImGui::GetScrollMaxX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?GetScrollY@ImGui@@YAMXZ PROC				; ImGui::GetScrollY

; 6190 :     return GImGui->CurrentWindow->Scroll.y;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [eax+6240]
	fld	DWORD PTR [eax+96]

; 6191 : }

	ret	0
?GetScrollY@ImGui@@YAMXZ ENDP				; ImGui::GetScrollY
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?GetScrollX@ImGui@@YAMXZ PROC				; ImGui::GetScrollX

; 6185 :     return GImGui->CurrentWindow->Scroll.x;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [eax+6240]
	fld	DWORD PTR [eax+92]

; 6186 : }

	ret	0
?GetScrollX@ImGui@@YAMXZ ENDP				; ImGui::GetScrollX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_name$ = 8						; size = 4
?SetWindowFocus@ImGui@@YAXPBD@Z PROC			; ImGui::SetWindowFocus

; 5967 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 5968 :     if (name)

	mov	eax, DWORD PTR _name$[ebp]
	test	eax, eax
	je	SHORT $LN2@SetWindowF

; 5969 :     {
; 5970 :         if (ImGuiWindow* window = FindWindowByName(name))

	push	eax
	call	?FindWindowByName@ImGui@@YAPAUImGuiWindow@@PBD@Z ; ImGui::FindWindowByName
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@SetWindowF

; 5971 :             FocusWindow(window);

	mov	DWORD PTR _name$[ebp], eax

; 5976 :     }
; 5977 : }

	pop	ebp

; 5971 :             FocusWindow(window);

	jmp	?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusWindow
$LN2@SetWindowF:

; 5972 :     }
; 5973 :     else
; 5974 :     {
; 5975 :         FocusWindow(NULL);

	mov	DWORD PTR _name$[ebp], 0

; 5976 :     }
; 5977 : }

	pop	ebp

; 5972 :     }
; 5973 :     else
; 5974 :     {
; 5975 :         FocusWindow(NULL);

	jmp	?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusWindow
$LN3@SetWindowF:

; 5976 :     }
; 5977 : }

	pop	ebp
	ret	0
?SetWindowFocus@ImGui@@YAXPBD@Z ENDP			; ImGui::SetWindowFocus
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_name$ = 8						; size = 4
_collapsed$ = 12					; size = 1
_cond$ = 16						; size = 4
?SetWindowCollapsed@ImGui@@YAXPBD_NH@Z PROC		; ImGui::SetWindowCollapsed

; 5955 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 5956 :     ImGuiWindow* window = FindWindowByName(name);

	push	DWORD PTR _name$[ebp]
	call	?FindWindowByName@ImGui@@YAPAUImGuiWindow@@PBD@Z ; ImGui::FindWindowByName
	add	esp, 4

; 5957 :     if (window)

	test	eax, eax
	je	SHORT $LN2@SetWindowC

; 5958 :         SetWindowCollapsed(window, collapsed, cond);

	mov	DWORD PTR _name$[ebp], eax

; 5959 : }

	pop	ebp

; 5958 :         SetWindowCollapsed(window, collapsed, cond);

	jmp	?SetWindowCollapsed@@YAXPAUImGuiWindow@@_NH@Z ; SetWindowCollapsed
$LN2@SetWindowC:

; 5959 : }

	pop	ebp
	ret	0
?SetWindowCollapsed@ImGui@@YAXPBD_NH@Z ENDP		; ImGui::SetWindowCollapsed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_name$ = 8						; size = 4
_size$ = 12						; size = 4
_cond$ = 16						; size = 4
?SetWindowSize@ImGui@@YAXPBDABUImVec2@@H@Z PROC		; ImGui::SetWindowSize

; 5927 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 5928 :     ImGuiWindow* window = FindWindowByName(name);

	push	DWORD PTR _name$[ebp]
	call	?FindWindowByName@ImGui@@YAPAUImGuiWindow@@PBD@Z ; ImGui::FindWindowByName
	add	esp, 4

; 5929 :     if (window)

	test	eax, eax
	je	SHORT $LN2@SetWindowS

; 5930 :         SetWindowSize(window, size, cond);

	mov	DWORD PTR _name$[ebp], eax

; 5931 : }

	pop	ebp

; 5930 :         SetWindowSize(window, size, cond);

	jmp	?SetWindowSize@@YAXPAUImGuiWindow@@ABUImVec2@@H@Z ; SetWindowSize
$LN2@SetWindowS:

; 5931 : }

	pop	ebp
	ret	0
?SetWindowSize@ImGui@@YAXPBDABUImVec2@@H@Z ENDP		; ImGui::SetWindowSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_name$ = 8						; size = 4
_pos$ = 12						; size = 4
_cond$ = 16						; size = 4
?SetWindowPos@ImGui@@YAXPBDABUImVec2@@H@Z PROC		; ImGui::SetWindowPos

; 5880 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 5881 :     if (ImGuiWindow* window = FindWindowByName(name))

	push	DWORD PTR _name$[ebp]
	call	?FindWindowByName@ImGui@@YAPAUImGuiWindow@@PBD@Z ; ImGui::FindWindowByName
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@SetWindowP

; 5882 :         SetWindowPos(window, pos, cond);

	mov	DWORD PTR _name$[ebp], eax

; 5883 : }

	pop	ebp

; 5882 :         SetWindowPos(window, pos, cond);

	jmp	?SetWindowPos@@YAXPAUImGuiWindow@@ABUImVec2@@H@Z ; SetWindowPos
$LN2@SetWindowP:

; 5883 : }

	pop	ebp
	ret	0
?SetWindowPos@ImGui@@YAXPBDABUImVec2@@H@Z ENDP		; ImGui::SetWindowPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?SetWindowFocus@ImGui@@YAXXZ PROC			; ImGui::SetWindowFocus

; 5963 :     FocusWindow(GImGui->CurrentWindow);

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	DWORD PTR [eax+6240]
	call	?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusWindow
	pop	ecx

; 5964 : }

	ret	0
?SetWindowFocus@ImGui@@YAXXZ ENDP			; ImGui::SetWindowFocus
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_collapsed$ = 8						; size = 1
_cond$ = 12						; size = 4
?SetWindowCollapsed@ImGui@@YAX_NH@Z PROC		; ImGui::SetWindowCollapsed

; 5945 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 5946 :     SetWindowCollapsed(GImGui->CurrentWindow, collapsed, cond);

	push	DWORD PTR _cond$[ebp]
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	DWORD PTR _collapsed$[ebp]
	push	DWORD PTR [eax+6240]
	call	?SetWindowCollapsed@@YAXPAUImGuiWindow@@_NH@Z ; SetWindowCollapsed
	add	esp, 12					; 0000000cH

; 5947 : }

	pop	ebp
	ret	0
?SetWindowCollapsed@ImGui@@YAX_NH@Z ENDP		; ImGui::SetWindowCollapsed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_size$ = 8						; size = 4
_cond$ = 12						; size = 4
?SetWindowSize@ImGui@@YAXABUImVec2@@H@Z PROC		; ImGui::SetWindowSize

; 5922 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 5923 :     SetWindowSize(GImGui->CurrentWindow, size, cond);

	push	DWORD PTR _cond$[ebp]
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	DWORD PTR _size$[ebp]
	push	DWORD PTR [eax+6240]
	call	?SetWindowSize@@YAXPAUImGuiWindow@@ABUImVec2@@H@Z ; SetWindowSize
	add	esp, 12					; 0000000cH

; 5924 : }

	pop	ebp
	ret	0
?SetWindowSize@ImGui@@YAXABUImVec2@@H@Z ENDP		; ImGui::SetWindowSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_pos$ = 8						; size = 4
_cond$ = 12						; size = 4
?SetWindowPos@ImGui@@YAXABUImVec2@@H@Z PROC		; ImGui::SetWindowPos

; 5874 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 5875 :     ImGuiWindow* window = GetCurrentWindowRead();
; 5876 :     SetWindowPos(window, pos, cond);

	push	DWORD PTR _cond$[ebp]
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	DWORD PTR _pos$[ebp]
	push	DWORD PTR [eax+6240]
	call	?SetWindowPos@@YAXPAUImGuiWindow@@ABUImVec2@@H@Z ; SetWindowPos
	add	esp, 12					; 0000000cH

; 5877 : }

	pop	ebp
	ret	0
?SetWindowPos@ImGui@@YAXABUImVec2@@H@Z ENDP		; ImGui::SetWindowPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?SetNextWindowFocus@ImGui@@YAXXZ PROC			; ImGui::SetNextWindowFocus

; 6032 :     ImGuiContext& g = *GImGui;
; 6033 :     g.SetNextWindowFocus = true;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	BYTE PTR [eax+6589], 1

; 6034 : }

	ret	0
?SetNextWindowFocus@ImGui@@YAXXZ ENDP			; ImGui::SetNextWindowFocus
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_collapsed$ = 8						; size = 1
_cond$ = 12						; size = 4
?SetNextWindowCollapsed@ImGui@@YAX_NH@Z PROC		; ImGui::SetNextWindowCollapsed

; 6024 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 6025 :     ImGuiContext& g = *GImGui;

	mov	edx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 6026 :     g.SetNextWindowCollapsedVal = collapsed;
; 6027 :     g.SetNextWindowCollapsedCond = cond ? cond : ImGuiSetCond_Always;

	mov	ecx, 1
	mov	al, BYTE PTR _collapsed$[ebp]
	mov	BYTE PTR [edx+6544], al
	mov	eax, DWORD PTR _cond$[ebp]
	test	eax, eax
	cmovne	ecx, eax
	mov	DWORD PTR [edx+6560], ecx

; 6028 : }

	pop	ebp
	ret	0
?SetNextWindowCollapsed@ImGui@@YAX_NH@Z ENDP		; ImGui::SetNextWindowCollapsed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 8
_width$ = 8						; size = 4
?SetNextWindowContentWidth@ImGui@@YAXM@Z PROC		; ImGui::SetNextWindowContentWidth

; 6017 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 6018 :     ImGuiContext& g = *GImGui;

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	sub	esp, 8

; 6019 :     g.SetNextWindowContentSizeVal = ImVec2(width, g.SetNextWindowContentSizeCond ? g.SetNextWindowContentSizeVal.y : 0.0f);

	cmp	DWORD PTR [ecx+6556], 0
	je	SHORT $LN3@SetNextWin
	movss	xmm1, DWORD PTR [ecx+6540]
	jmp	SHORT $LN4@SetNextWin
$LN3@SetNextWin:
	xorps	xmm1, xmm1
$LN4@SetNextWin:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR _width$[ebp]
	movss	DWORD PTR $T1[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6019 :     g.SetNextWindowContentSizeVal = ImVec2(width, g.SetNextWindowContentSizeCond ? g.SetNextWindowContentSizeVal.y : 0.0f);

	mov	eax, DWORD PTR $T1[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6019 :     g.SetNextWindowContentSizeVal = ImVec2(width, g.SetNextWindowContentSizeCond ? g.SetNextWindowContentSizeVal.y : 0.0f);

	mov	DWORD PTR [ecx+6536], eax
	mov	eax, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR [ecx+6540], eax

; 6020 :     g.SetNextWindowContentSizeCond = ImGuiSetCond_Always;

	mov	DWORD PTR [ecx+6556], 1

; 6021 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetNextWindowContentWidth@ImGui@@YAXM@Z ENDP		; ImGui::SetNextWindowContentWidth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_size$ = 8						; size = 4
?SetNextWindowContentSize@ImGui@@YAXABUImVec2@@@Z PROC	; ImGui::SetNextWindowContentSize

; 6010 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 6011 :     ImGuiContext& g = *GImGui;

	mov	edx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 6012 :     g.SetNextWindowContentSizeVal = size;

	mov	ecx, DWORD PTR _size$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx+6536], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+6540], eax

; 6013 :     g.SetNextWindowContentSizeCond = ImGuiSetCond_Always;

	mov	DWORD PTR [edx+6556], 1

; 6014 : }

	pop	ebp
	ret	0
?SetNextWindowContentSize@ImGui@@YAXABUImVec2@@@Z ENDP	; ImGui::SetNextWindowContentSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -16						; size = 16
_size_min$ = 8						; size = 4
_size_max$ = 12						; size = 4
_custom_callback$ = 16					; size = 4
_custom_callback_user_data$ = 20			; size = 4
?SetNextWindowSizeConstraints@ImGui@@YAXABUImVec2@@0P6AXPAUImGuiSizeConstraintCallbackData@@@ZPAX@Z PROC ; ImGui::SetNextWindowSizeConstraints

; 6001 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 6002 :     ImGuiContext& g = *GImGui;

	mov	edx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	ecx, DWORD PTR _size_min$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6003 :     g.SetNextWindowSizeConstraint = true;

	mov	BYTE PTR [edx+6588], 1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _size_max$[ebp]
	mov	DWORD PTR $T1[ebp+4], eax
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR $T1[ebp+8], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR $T1[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6004 :     g.SetNextWindowSizeConstraintRect = ImRect(size_min, size_max);

	movups	xmm0, XMMWORD PTR $T1[ebp]

; 6005 :     g.SetNextWindowSizeConstraintCallback = custom_callback;

	mov	eax, DWORD PTR _custom_callback$[ebp]
	mov	DWORD PTR [edx+6580], eax

; 6006 :     g.SetNextWindowSizeConstraintCallbackUserData = custom_callback_user_data;

	mov	eax, DWORD PTR _custom_callback_user_data$[ebp]
	movups	XMMWORD PTR [edx+6564], xmm0
	mov	DWORD PTR [edx+6584], eax

; 6007 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetNextWindowSizeConstraints@ImGui@@YAXABUImVec2@@0P6AXPAUImGuiSizeConstraintCallbackData@@@ZPAX@Z ENDP ; ImGui::SetNextWindowSizeConstraints
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_size$ = 8						; size = 4
_cond$ = 12						; size = 4
?SetNextWindowSize@ImGui@@YAXABUImVec2@@H@Z PROC	; ImGui::SetNextWindowSize

; 5994 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 5995 :     ImGuiContext& g = *GImGui;
; 5996 :     g.SetNextWindowSizeVal = size;

	mov	ecx, DWORD PTR _size$[ebp]
	mov	edx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx+6528], eax
	mov	eax, DWORD PTR [ecx+4]

; 5997 :     g.SetNextWindowSizeCond = cond ? cond : ImGuiSetCond_Always;

	mov	ecx, 1
	mov	DWORD PTR [edx+6532], eax
	mov	eax, DWORD PTR _cond$[ebp]
	test	eax, eax
	cmovne	ecx, eax
	mov	DWORD PTR [edx+6552], ecx

; 5998 : }

	pop	ebp
	ret	0
?SetNextWindowSize@ImGui@@YAXABUImVec2@@H@Z ENDP	; ImGui::SetNextWindowSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 8
_cond$ = 8						; size = 4
?SetNextWindowPosCenter@ImGui@@YAXH@Z PROC		; ImGui::SetNextWindowPosCenter

; 5987 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 5988 :     ImGuiContext& g = *GImGui;

	mov	edx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 5990 :     g.SetNextWindowPosCond = cond ? cond : ImGuiSetCond_Always;

	mov	ecx, 1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp], -8388609		; ff7fffffH
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5989 :     g.SetNextWindowPosVal = ImVec2(-FLT_MAX, -FLT_MAX);

	mov	eax, DWORD PTR $T1[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp+4], -8388609		; ff7fffffH
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5989 :     g.SetNextWindowPosVal = ImVec2(-FLT_MAX, -FLT_MAX);

	mov	DWORD PTR [edx+6520], eax
	mov	eax, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR [edx+6524], eax

; 5990 :     g.SetNextWindowPosCond = cond ? cond : ImGuiSetCond_Always;

	mov	eax, DWORD PTR _cond$[ebp]
	test	eax, eax
	cmovne	ecx, eax
	mov	DWORD PTR [edx+6548], ecx

; 5991 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SetNextWindowPosCenter@ImGui@@YAXH@Z ENDP		; ImGui::SetNextWindowPosCenter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_pos$ = 8						; size = 4
_cond$ = 12						; size = 4
?SetNextWindowPos@ImGui@@YAXABUImVec2@@H@Z PROC		; ImGui::SetNextWindowPos

; 5980 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 5981 :     ImGuiContext& g = *GImGui;
; 5982 :     g.SetNextWindowPosVal = pos;

	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx+6520], eax
	mov	eax, DWORD PTR [ecx+4]

; 5983 :     g.SetNextWindowPosCond = cond ? cond : ImGuiSetCond_Always;

	mov	ecx, 1
	mov	DWORD PTR [edx+6524], eax
	mov	eax, DWORD PTR _cond$[ebp]
	test	eax, eax
	cmovne	ecx, eax
	mov	DWORD PTR [edx+6548], ecx

; 5984 : }

	pop	ebp
	ret	0
?SetNextWindowPos@ImGui@@YAXABUImVec2@@H@Z ENDP		; ImGui::SetNextWindowPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_scale$ = 8						; size = 4
?SetWindowFontScale@ImGui@@YAXM@Z PROC			; ImGui::SetWindowFontScale

; 6116 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 6117 :     ImGuiContext& g = *GImGui;

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 6119 :     window->FontWindowScale = scale;

	movss	xmm1, DWORD PTR _scale$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	eax, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6119 :     window->FontWindowScale = scale;

	movss	DWORD PTR [eax+620], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	movss	xmm0, DWORD PTR [eax+6176]
	mulss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6120 :     g.FontSize = window->CalcFontSize();

	movss	DWORD PTR [ecx+6172], xmm0

; 6121 : }

	pop	ebp
	ret	0
?SetWindowFontScale@ImGui@@YAXM@Z ENDP			; ImGui::SetWindowFontScale
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?IsWindowCollapsed@ImGui@@YA_NXZ PROC			; ImGui::IsWindowCollapsed

; 5951 :     return GImGui->CurrentWindow->Collapsed;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [eax+6240]
	mov	al, BYTE PTR [eax+135]

; 5952 : }

	ret	0
?IsWindowCollapsed@ImGui@@YA_NXZ ENDP			; ImGui::IsWindowCollapsed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?GetWindowHeight@ImGui@@YAMXZ PROC			; ImGui::GetWindowHeight

; 5832 :     ImGuiWindow* window = GImGui->CurrentWindow;
; 5833 :     return window->Size.y;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [eax+6240]
	fld	DWORD PTR [eax+36]

; 5834 : }

	ret	0
?GetWindowHeight@ImGui@@YAMXZ ENDP			; ImGui::GetWindowHeight
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?GetWindowWidth@ImGui@@YAMXZ PROC			; ImGui::GetWindowWidth

; 5826 :     ImGuiWindow* window = GImGui->CurrentWindow;
; 5827 :     return window->Size.x;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [eax+6240]
	fld	DWORD PTR [eax+32]

; 5828 : }

	ret	0
?GetWindowWidth@ImGui@@YAMXZ ENDP			; ImGui::GetWindowWidth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetWindowSize@ImGui@@YA?AUImVec2@@XZ PROC		; ImGui::GetWindowSize

; 5886 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 5887 :     ImGuiWindow* window = GetCurrentWindowRead();
; 5888 :     return window->Size;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	edx, DWORD PTR [eax+6240]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+36]
	mov	DWORD PTR [eax+4], ecx

; 5889 : }

	pop	ebp
	ret	0
?GetWindowSize@ImGui@@YA?AUImVec2@@XZ ENDP		; ImGui::GetWindowSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetWindowPos@ImGui@@YA?AUImVec2@@XZ PROC		; ImGui::GetWindowPos

; 5837 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 5838 :     ImGuiContext& g = *GImGui;
; 5839 :     ImGuiWindow* window = g.CurrentWindow;
; 5840 :     return window->Pos;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	edx, DWORD PTR [eax+6240]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+28]
	mov	DWORD PTR [eax+4], ecx

; 5841 : }

	pop	ebp
	ret	0
?GetWindowPos@ImGui@@YA?AUImVec2@@XZ ENDP		; ImGui::GetWindowPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?GetWindowDrawList@ImGui@@YAPAUImDrawList@@XZ PROC	; ImGui::GetWindowDrawList
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6097 :     return window->DrawList;

	mov	eax, DWORD PTR [ecx+6240]
	mov	eax, DWORD PTR [eax+624]

; 6098 : }

	ret	0
?GetWindowDrawList@ImGui@@YAPAUImDrawList@@XZ ENDP	; ImGui::GetWindowDrawList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?GetWindowContentRegionWidth@ImGui@@YAMXZ PROC		; ImGui::GetWindowContentRegionWidth
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 792  :     inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [eax+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6073 :     return window->ContentsRegionRect.Max.x - window->ContentsRegionRect.Min.x;

	fld	DWORD PTR [eax+72]
	fsub	DWORD PTR [eax+64]

; 6074 : }

	ret	0
?GetWindowContentRegionWidth@ImGui@@YAMXZ ENDP		; ImGui::GetWindowContentRegionWidth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetWindowContentRegionMax@ImGui@@YA?AUImVec2@@XZ PROC	; ImGui::GetWindowContentRegionMax

; 6065 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 6066 :     ImGuiWindow* window = GetCurrentWindowRead();
; 6067 :     return window->ContentsRegionRect.Max;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	edx, DWORD PTR [eax+6240]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [edx+72]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+76]
	mov	DWORD PTR [eax+4], ecx

; 6068 : }

	pop	ebp
	ret	0
?GetWindowContentRegionMax@ImGui@@YA?AUImVec2@@XZ ENDP	; ImGui::GetWindowContentRegionMax
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetWindowContentRegionMin@ImGui@@YA?AUImVec2@@XZ PROC	; ImGui::GetWindowContentRegionMin

; 6059 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 6060 :     ImGuiWindow* window = GetCurrentWindowRead();
; 6061 :     return window->ContentsRegionRect.Min;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	edx, DWORD PTR [eax+6240]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [edx+64]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+68]
	mov	DWORD PTR [eax+4], ecx

; 6062 : }

	pop	ebp
	ret	0
?GetWindowContentRegionMin@ImGui@@YA?AUImVec2@@XZ ENDP	; ImGui::GetWindowContentRegionMin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 8
?GetContentRegionAvailWidth@ImGui@@YAMXZ PROC		; ImGui::GetContentRegionAvailWidth

; 6053 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 6054 :     return GetContentRegionAvail().x;

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetContentRegionAvail
	add	esp, 4
	fld	DWORD PTR [eax]

; 6055 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetContentRegionAvailWidth@ImGui@@YAMXZ ENDP		; ImGui::GetContentRegionAvailWidth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T2 = -16						; size = 8
$T1$sroa$86$1$ = -8					; size = 4
$T1$sroa$92$1$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ PROC	; ImGui::GetContentRegionAvail

; 6047 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 792  :     inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	eax, DWORD PTR [eax+6240]

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [eax+192]
	subss	xmm0, DWORD PTR [eax+24]
	movss	DWORD PTR $T1$sroa$92$1$[ebp], xmm0
	movss	xmm0, DWORD PTR [eax+196]
	subss	xmm0, DWORD PTR [eax+28]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6049 :     return GetContentRegionMax() - (window->DC.CursorPos - window->Pos);

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	DWORD PTR $T1$sroa$86$1$[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6049 :     return GetContentRegionMax() - (window->DC.CursorPos - window->Pos);

	call	?GetContentRegionMax@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetContentRegionMax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6049 :     return GetContentRegionMax() - (window->DC.CursorPos - window->Pos);

	add	esp, 4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [eax]
	subss	xmm0, DWORD PTR $T1$sroa$92$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [ecx], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [eax+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6049 :     return GetContentRegionMax() - (window->DC.CursorPos - window->Pos);

	mov	eax, ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm0, DWORD PTR $T1$sroa$86$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR [ecx+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6050 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ ENDP	; ImGui::GetContentRegionAvail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetContentRegionMax@ImGui@@YA?AUImVec2@@XZ PROC	; ImGui::GetContentRegionMax

; 6038 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 792  :     inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6040 :     ImVec2 mx = window->ContentsRegionRect.Max;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	edi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 792  :     inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }

	mov	edi, DWORD PTR [eax+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 6041 :     if (window->DC.ColumnsCount != 1)

	cmp	DWORD PTR [edi+416], 1
	mov	eax, DWORD PTR [edi+72]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edi+76]
	mov	DWORD PTR [esi+4], eax
	je	SHORT $LN6@GetContent

; 6042 :         mx.x = GetColumnOffset(window->DC.ColumnsCurrent + 1) - window->WindowPadding.x;

	mov	ecx, DWORD PTR [edi+412]
	inc	ecx
	push	ecx
	call	?GetColumnOffset@ImGui@@YAMH@Z		; ImGui::GetColumnOffset
	fsub	DWORD PTR [edi+80]
	add	esp, 4
	fstp	DWORD PTR [esi]
$LN6@GetContent:

; 6043 :     return mx;

	pop	edi
	mov	eax, esi
	pop	esi

; 6044 : }

	pop	ebp
	ret	0
?GetContentRegionMax@ImGui@@YA?AUImVec2@@XZ ENDP	; ImGui::GetContentRegionMax
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_bb$1 = -36						; size = 16
$T2 = -20						; size = 8
_sz$3 = -12						; size = 8
_id$4 = -4						; size = 4
?EndChild@ImGui@@YAXXZ PROC				; ImGui::EndChild

; 4514 : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4514 : {

	sub	esp, 36					; 00000024H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	push	edi
	mov	BYTE PTR [eax+134], 1
	mov	edi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4518 :     if ((window->Flags & ImGuiWindowFlags_ComboBox) || window->BeginCount > 1)

	test	DWORD PTR [edi+8], 8388608		; 00800000H
	jne	$LN4@EndChild
	cmp	DWORD PTR [edi+140], 1
	jg	$LN4@EndChild

; 4521 :     }
; 4522 :     else
; 4523 :     {
; 4524 :         // When using auto-filling child window, we don't provide full width/height to ItemSize so that it doesn't feed back into automatic size-fitting.
; 4525 :         ImVec2 sz = GetWindowSize();

	lea	eax, DWORD PTR _sz$3[ebp]
	push	eax
	call	?GetWindowSize@ImGui@@YA?AUImVec2@@XZ	; ImGui::GetWindowSize

; 4526 :         if (window->AutoFitChildAxises & 0x01) // Arbitrary minimum zero-ish child size of 4.0f causes less trouble than a 0.0f

	mov	eax, DWORD PTR [edi+164]
	add	esp, 4
	movss	xmm0, DWORD PTR __real@40800000
	test	al, 1
	je	SHORT $LN29@EndChild
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 128  : static inline float  ImMax(float lhs, float rhs)                                { return lhs >= rhs ? lhs : rhs; }

	comiss	xmm0, DWORD PTR _sz$3[ebp]
	jb	SHORT $LN29@EndChild
	movss	DWORD PTR _sz$3[ebp], xmm0
$LN29@EndChild:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4528 :         if (window->AutoFitChildAxises & 0x02)

	test	al, 2
	je	SHORT $LN30@EndChild
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 128  : static inline float  ImMax(float lhs, float rhs)                                { return lhs >= rhs ? lhs : rhs; }

	comiss	xmm0, DWORD PTR _sz$3[ebp+4]
	jb	SHORT $LN30@EndChild
	movss	DWORD PTR _sz$3[ebp+4], xmm0
$LN30@EndChild:
	push	ebx
	push	esi
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4530 :         ImGui::End();

	call	?End@ImGui@@YAXXZ			; ImGui::End
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4533 :         ImGuiID id = parent_window->GetChildID(window);

	push	edi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
	mov	BYTE PTR [eax+134], 1
	mov	esi, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4533 :         ImGuiID id = parent_window->GetChildID(window);

	mov	ecx, esi
	call	?GetChildID@ImGuiWindow@@QAEIPAU1@@Z	; ImGuiWindow::GetChildID
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [esi+192]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4533 :         ImGuiID id = parent_window->GetChildID(window);

	mov	ebx, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, DWORD PTR _sz$3[ebp]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [esi+192]
	mov	DWORD PTR _bb$1[ebp], eax
	mov	eax, DWORD PTR [esi+196]
	mov	DWORD PTR _bb$1[ebp+4], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [esi+196]
	addss	xmm0, DWORD PTR _sz$3[ebp+4]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _bb$1[ebp+8], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4535 :         ItemSize(sz);

	push	ecx
	mov	DWORD PTR [esp], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T2[ebp+4]
	mov	DWORD PTR _bb$1[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4535 :         ItemSize(sz);

	lea	eax, DWORD PTR _sz$3[ebp]
	push	eax
	mov	DWORD PTR _id$4[ebp], ebx
	call	?ItemSize@ImGui@@YAXABUImVec2@@M@Z	; ImGui::ItemSize
	add	esp, 8

; 4536 :         if (!(window->Flags & ImGuiWindowFlags_NavFlattened) && (window->DC.NavLayerActiveFlags != 0 || window->DC.NavHasScroll))

	test	DWORD PTR [edi+8], 524288		; 00080000H
	jne	SHORT $LN7@EndChild
	cmp	DWORD PTR [edi+276], 0
	jne	SHORT $LN9@EndChild
	cmp	BYTE PTR [edi+270], 0
	je	SHORT $LN7@EndChild
$LN9@EndChild:

; 4537 :         {
; 4538 :             ItemAdd(bb, &id);

	push	0
	lea	eax, DWORD PTR _id$4[ebp]
	push	eax
	lea	eax, DWORD PTR _bb$1[ebp]
	push	eax
	call	?ItemAdd@ImGui@@YA_NABUImRect@@PBIPBU2@@Z ; ImGui::ItemAdd

; 4539 :             RenderNavHighlight(bb, id);

	lea	eax, DWORD PTR _bb$1[ebp]
	push	ebx
	push	eax
	call	?RenderNavHighlight@ImGui@@YAXABUImRect@@I@Z ; ImGui::RenderNavHighlight
	add	esp, 20					; 00000014H
	pop	esi
	pop	ebx
	pop	edi

; 4544 :         }
; 4545 :     }
; 4546 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN7@EndChild:

; 4540 :         }
; 4541 :         else
; 4542 :         {
; 4543 :             ItemAdd(bb, NULL);

	push	0
	lea	eax, DWORD PTR _bb$1[ebp]
	push	0
	push	eax
	call	?ItemAdd@ImGui@@YA_NABUImRect@@PBIPBU2@@Z ; ImGui::ItemAdd
	add	esp, 12					; 0000000cH
	pop	esi
	pop	ebx
	pop	edi

; 4544 :         }
; 4545 :     }
; 4546 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN4@EndChild:

; 4519 :     {
; 4520 :         ImGui::End();

	call	?End@ImGui@@YAXXZ			; ImGui::End
	pop	edi

; 4544 :         }
; 4545 :     }
; 4546 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?EndChild@ImGui@@YAXXZ ENDP				; ImGui::EndChild
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_id$ = 8						; size = 4
_size_arg$ = 12						; size = 4
_border$ = 16						; size = 1
_extra_flags$ = 20					; size = 4
?BeginChild@ImGui@@YA_NIABUImVec2@@_NH@Z PROC		; ImGui::BeginChild

; 4509 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 4510 :     return BeginChildEx(NULL, id, size_arg, border, extra_flags);

	push	DWORD PTR _extra_flags$[ebp]
	push	DWORD PTR _border$[ebp]
	push	DWORD PTR _size_arg$[ebp]
	push	DWORD PTR _id$[ebp]
	push	0
	call	?BeginChildEx@@YA_NPBDIABUImVec2@@_NH@Z	; BeginChildEx
	add	esp, 20					; 00000014H

; 4511 : }

	pop	ebp
	ret	0
?BeginChild@ImGui@@YA_NIABUImVec2@@_NH@Z ENDP		; ImGui::BeginChild
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_str_id$ = 8						; size = 4
_size_arg$ = 12						; size = 4
_border$ = 16						; size = 1
_extra_flags$ = 20					; size = 4
?BeginChild@ImGui@@YA_NPBDABUImVec2@@_NH@Z PROC		; ImGui::BeginChild

; 4503 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 4505 :     return BeginChildEx(str_id, window->GetID(str_id), size_arg, border, extra_flags);

	push	DWORD PTR _extra_flags$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	ecx, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4505 :     return BeginChildEx(str_id, window->GetID(str_id), size_arg, border, extra_flags);

	push	DWORD PTR _border$[ebp]
	push	DWORD PTR _size_arg$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	eax, DWORD PTR [ecx+6240]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4505 :     return BeginChildEx(str_id, window->GetID(str_id), size_arg, border, extra_flags);

	push	0
	push	DWORD PTR _str_id$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 793  :     inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }

	mov	BYTE PTR [eax+134], 1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4505 :     return BeginChildEx(str_id, window->GetID(str_id), size_arg, border, extra_flags);

	mov	ecx, DWORD PTR [ecx+6240]
	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID
	push	eax
	push	DWORD PTR _str_id$[ebp]
	call	?BeginChildEx@@YA_NPBDIABUImVec2@@_NH@Z	; BeginChildEx
	add	esp, 20					; 00000014H

; 4506 : }

	pop	ebp
	ret	0
?BeginChild@ImGui@@YA_NPBDABUImVec2@@_NH@Z ENDP		; ImGui::BeginChild
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?End@ImGui@@YAXXZ PROC					; ImGui::End

; 5356 : {

	npad	2
	push	esi

; 5357 :     ImGuiContext& g = *GImGui;

	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	edi

; 5358 :     ImGuiWindow* window = g.CurrentWindow;
; 5359 : 
; 5360 :     Columns(1, "#CloseColumns");

	push	1
	push	OFFSET $SG118312
	mov	edi, DWORD PTR [esi+6240]
	push	1
	call	?Columns@ImGui@@YAXHPBD_N@Z		; ImGui::Columns
	add	esp, 12					; 0000000cH

; 5361 :     PopClipRect();   // inner window clip rectangle

	call	?PopClipRect@ImGui@@YAXXZ		; ImGui::PopClipRect

; 5362 : 
; 5363 :     // Stop logging
; 5364 :     if (!(window->Flags & ImGuiWindowFlags_ChildWindow))    // FIXME: add more options for scope of logging

	test	DWORD PTR [edi+8], 4194304		; 00400000H
	jne	SHORT $LN2@End

; 5365 :         LogFinish();

	call	?LogFinish@ImGui@@YAXXZ			; ImGui::LogFinish
$LN2@End:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [esi+6228]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5370 :     if (window->Flags & ImGuiWindowFlags_Popup)

	test	DWORD PTR [edi+8], 33554432		; 02000000H
	je	SHORT $LN3@End
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 941  :     inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }

	dec	DWORD PTR [esi+6368]
$LN3@End:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5372 :     CheckStacksSize(window, false);

	push	0
	push	edi
	call	?CheckStacksSize@@YAXPAUImGuiWindow@@_N@Z ; CheckStacksSize
	add	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	cmp	DWORD PTR [esi+6228], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5373 :     SetCurrentWindow(g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back());

	jne	SHORT $LN5@End
	xor	eax, eax
	push	eax
	call	?SetCurrentWindow@@YAXPAUImGuiWindow@@@Z ; SetCurrentWindow
	add	esp, 4
	pop	edi
	pop	esi

; 5374 : }

	ret	0
$LN5@End:

; 5373 :     SetCurrentWindow(g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back());

	mov	ecx, DWORD PTR [esi+6228]
	mov	eax, DWORD PTR [esi+6236]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	push	eax
	call	?SetCurrentWindow@@YAXPAUImGuiWindow@@@Z ; SetCurrentWindow
	add	esp, 4
	pop	edi
	pop	esi

; 5374 : }

	ret	0
?End@ImGui@@YAXXZ ENDP					; ImGui::End
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_bb$31 = -176						; size = 16
$T32 = -168						; size = 8
_style$1$ = -164					; size = 4
tv7505 = -164						; size = 4
tv7611 = -160						; size = 4
tv7601 = -156						; size = 4
tv7534 = -152						; size = 4
_clip_rect$ = -148					; size = 16
_title_bar_rect$ = -148					; size = 16
_fullscreen_rect$33 = -148				; size = 16
_bg_color$34 = -132					; size = 16
$T35 = -124						; size = 8
_size_auto_fit$2$ = -120				; size = 4
_new_capacity$1$ = -120					; size = 4
_new_capacity$1$ = -120					; size = 4
_current_frame$1$ = -116				; size = 4
_menu_bar_rect$36 = -112				; size = 16
_text_size$37 = -104					; size = 8
$T38 = -104						; size = 8
$T39 = -104						; size = 8
_title_bar_rect$2$ = -100				; size = 4
__y$1$ = -100						; size = 4
tv7543 = -100						; size = 4
$T40 = -96						; size = 8
$T41 = -96						; size = 8
_title_bar_rect$5$ = -92				; size = 4
tv7530 = -92						; size = 4
_size_auto_fit$3$ = -88					; size = 4
tv7507 = -88						; size = 4
$T20$sroa$2251$1$ = -84					; size = 4
tv7613 = -84						; size = 4
_parent_window$1$ = -80					; size = 4
$T42 = -76						; size = 16
$T43 = -68						; size = 8
_text_max$44 = -68					; size = 8
$T45 = -68						; size = 8
$T46 = -68						; size = 8
$T47 = -68						; size = 8
$T48 = -68						; size = 8
$T49 = -68						; size = 8
$T50 = -68						; size = 8
$T51 = -68						; size = 8
$T52 = -68						; size = 8
$T53 = -68						; size = 8
$T54 = -68						; size = 8
$T55 = -68						; size = 8
$T56 = -68						; size = 8
$T57 = -68						; size = 8
$T58 = -68						; size = 8
_title_bar_rect$3$ = -64				; size = 4
_backup_cursor_pos$2$ = -64				; size = 4
$T18$sroa$81$1$ = -64					; size = 4
_new_capacity$1$ = -64					; size = 4
_new_capacity$1$ = -64					; size = 4
_window_rounding$1$ = -60				; size = 4
_g$1$ = -60						; size = 4
_window_size_set_by_api$1$ = -53			; size = 1
$T59 = -52						; size = 16
_clip_rect$60 = -52					; size = 16
$T61 = -52						; size = 16
_resize_rect$62 = -52					; size = 16
_title_bar_rect$63 = -52				; size = 16
_bb$64 = -52						; size = 16
_rect_to_avoid$65 = -52					; size = 16
_rect_to_avoid$66 = -52					; size = 16
$T67 = -52						; size = 16
$T68 = -52						; size = 16
_rect_to_avoid$69 = -52					; size = 16
$T70 = -52						; size = 16
_title_bar_rect$71 = -52				; size = 16
_flags$1$ = -36						; size = 4
$T72 = -32						; size = 8
_text_min$73 = -32					; size = 8
_ref_pos$74 = -32					; size = 8
$T75 = -32						; size = 8
$T76 = -32						; size = 8
$T77 = -32						; size = 8
$T78 = -32						; size = 8
$T79 = -32						; size = 8
$T80 = -32						; size = 8
$T81 = -32						; size = 8
$T82 = -32						; size = 8
$T83 = -32						; size = 8
_backup_item_options$1$ = -28				; size = 4
tv7522 = -28						; size = 4
_window_is_new$1$ = -21					; size = 1
_hovered$84 = -21					; size = 1
$T85 = -20						; size = 8
$T86 = -20						; size = 8
$T87 = -20						; size = 8
$T88 = -20						; size = 8
$T89 = -20						; size = 8
$T90 = -20						; size = 8
$T91 = -20						; size = 8
$T92 = -20						; size = 8
$T93 = -20						; size = 8
$T94 = -20						; size = 8
_new_capacity$1$ = -16					; size = 4
_new_capacity$1$ = -16					; size = 4
_new_capacity$1$ = -16					; size = 4
_new_capacity$1$ = -16					; size = 4
_new_capacity$1$ = -16					; size = 4
_new_capacity$1$ = -16					; size = 4
_new_data$1$ = -16					; size = 4
_new_data$1$ = -16					; size = 4
_new_data$1$ = -16					; size = 4
tv7547 = -16						; size = 4
tv7502 = -16						; size = 4
tv7497 = -16						; size = 4
tv7492 = -16						; size = 4
tv7451 = -16						; size = 4
$T95 = -12						; size = 8
$T96 = -12						; size = 8
$T97 = -12						; size = 8
$T98 = -12						; size = 8
$T99 = -12						; size = 8
$T100 = -12						; size = 8
$T101 = -12						; size = 8
_size_target$102 = -12					; size = 8
_nav_resize_delta$103 = -12				; size = 8
$T104 = -12						; size = 8
_backup_cursor_pos$1$ = -8				; size = 4
$T105 = -8						; size = 4
_new_capacity$1$ = -8					; size = 4
_new_data$1$ = -8					; size = 4
_new_data$1$ = -8					; size = 4
_resize_col$1$ = -8					; size = 4
tv7526 = -8						; size = 4
_window_was_active$1$ = -1				; size = 1
_name$ = 8						; size = 4
_p_open$ = 12						; size = 4
_size_on_first_use$ = 16				; size = 4
_bg_alpha$ = 20						; size = 4
_title_bar_rect$4$ = 24					; size = 4
_new_data$1$ = 24					; size = 4
_new_data$1$ = 24					; size = 4
_new_data$1$ = 24					; size = 4
_new_data$1$ = 24					; size = 4
_new_data$1$ = 24					; size = 4
_new_data$1$ = 24					; size = 4
_this$1$ = 24						; size = 4
_this$1$ = 24						; size = 4
_this$1$ = 24						; size = 4
tv7861 = 24						; size = 4
_id$106 = 24						; size = 4
_window$ = 24						; size = 4
_flags$ = 24						; size = 4
_held$1$ = 27						; size = 1
_window_pos_set_by_api$1$ = 27				; size = 1
_held$107 = 27						; size = 1
?Begin@ImGui@@YA_NPBDPA_NABUImVec2@@MH@Z PROC		; ImGui::Begin

; 4739 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H

; 4740 :     ImGuiContext& g = *GImGui;
; 4741 :     const ImGuiStyle& style = g.Style;
; 4742 :     IM_ASSERT(name != NULL);                        // Window name required
; 4743 :     IM_ASSERT(g.Initialized);                       // Forgot to call ImGui::NewFrame()
; 4744 :     IM_ASSERT(g.FrameCountEnded != g.FrameCount);   // Called ImGui::Render() or ImGui::EndFrame() and haven't called ImGui::NewFrame() again yet
; 4745 : 
; 4746 :     if (flags & ImGuiWindowFlags_NoInputs)

	mov	ecx, DWORD PTR _flags$[ebp]
	mov	edx, ecx
	push	esi
	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	or	edx, 6
	push	edi

; 4747 :         flags |= ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize;
; 4748 : 
; 4749 :     if (flags & ImGuiWindowFlags_NavFlattened)
; 4750 :         IM_ASSERT(flags & ImGuiWindowFlags_ChildWindow);
; 4751 : 
; 4752 :     // Find or create
; 4753 :     bool window_is_new = false;
; 4754 :     ImGuiWindow* window = FindWindowByName(name);

	push	DWORD PTR _name$[ebp]
	mov	DWORD PTR _g$1$[ebp], esi
	lea	eax, DWORD PTR [esi+5320]
	mov	BYTE PTR _window_is_new$1$[ebp], 0
	mov	DWORD PTR _style$1$[ebp], eax
	mov	eax, ecx
	and	eax, 512				; 00000200H
	cmove	edx, ecx
	mov	DWORD PTR _flags$1$[ebp], edx
	call	?FindWindowByName@ImGui@@YAPAUImGuiWindow@@PBD@Z ; ImGui::FindWindowByName
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR _window$[ebp], edi

; 4755 :     if (!window)

	test	edi, edi
	jne	SHORT $LN12@Begin

; 4756 :     {
; 4757 :         window = CreateNewWindow(name, size_on_first_use, flags);

	mov	eax, DWORD PTR _size_on_first_use$[ebp]
	push	DWORD PTR _flags$1$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	push	DWORD PTR _name$[ebp]
	call	?CreateNewWindow@@YAPAUImGuiWindow@@PBDUImVec2@@H@Z ; CreateNewWindow
	mov	edi, eax

; 4758 :         window_is_new = true;

	mov	BYTE PTR _window_is_new$1$[ebp], 1
	add	esp, 16					; 00000010H
	mov	DWORD PTR _window$[ebp], edi
$LN12@Begin:

; 4759 :     }
; 4760 : 
; 4761 :     const int current_frame = ImGui::GetFrameCount();

	call	?GetFrameCount@ImGui@@YAHXZ		; ImGui::GetFrameCount

; 4762 :     const bool first_begin_of_the_frame = (window->LastFrameActive != current_frame);

	mov	ecx, DWORD PTR [edi+520]
	mov	DWORD PTR _current_frame$1$[ebp], eax
	mov	DWORD PTR tv7611[ebp], ecx
	cmp	ecx, eax

; 4763 :     if (first_begin_of_the_frame)

	je	SHORT $LN13@Begin

; 4764 :         window->Flags = (ImGuiWindowFlags)flags;

	mov	eax, DWORD PTR _flags$1$[ebp]
	mov	DWORD PTR [edi+8], eax

; 4765 :     else

	jmp	SHORT $LN14@Begin
$LN13@Begin:

; 4766 :         flags = window->Flags;

	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR _flags$1$[ebp], eax
$LN14@Begin:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	cmp	DWORD PTR [esi+6228], 0
	lea	edx, DWORD PTR [esi+6228]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4769 :     ImGuiWindow* parent_window = !g.CurrentWindowStack.empty() ? g.CurrentWindowStack.back() : NULL;

	je	SHORT $LN129@Begin
	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+8]
	mov	eax, DWORD PTR [eax+ecx*4-4]
	mov	DWORD PTR _parent_window$1$[ebp], eax
	jmp	SHORT $LN130@Begin
$LN129@Begin:
	mov	DWORD PTR _parent_window$1$[ebp], 0
$LN130@Begin:

; 4770 :     g.CurrentWindowStack.push_back(window);

	lea	eax, DWORD PTR _window$[ebp]
	mov	ecx, edx
	push	eax
	call	?push_back@?$ImVector@PAUImGuiWindow@@@@QAEXABQAUImGuiWindow@@@Z ; ImVector<ImGuiWindow *>::push_back

; 4771 :     SetCurrentWindow(window);

	push	edi
	call	?SetCurrentWindow@@YAXPAUImGuiWindow@@@Z ; SetCurrentWindow

; 4772 :     CheckStacksSize(window, true);

	push	1
	push	edi
	call	?CheckStacksSize@@YAXPAUImGuiWindow@@_N@Z ; CheckStacksSize

; 4773 :     IM_ASSERT(parent_window != NULL || !(flags & ImGuiWindowFlags_ChildWindow));
; 4774 : 
; 4775 :     bool window_was_active = (window->LastFrameActive == current_frame - 1);   // Not using !WasActive because the implicit "Debug" window would always toggle off->on

	mov	eax, DWORD PTR _current_frame$1$[ebp]
	add	esp, 12					; 0000000cH
	dec	eax
	cmp	DWORD PTR [edi+520], eax

; 4776 :     if (flags & ImGuiWindowFlags_Popup)

	mov	eax, DWORD PTR _flags$1$[ebp]
	sete	dh
	and	eax, 33554432				; 02000000H
	mov	BYTE PTR _window_was_active$1$[ebp], dh
	mov	DWORD PTR tv7601[ebp], eax
	je	SHORT $LN15@Begin
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	mov	eax, DWORD PTR _g$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4778 :         ImGuiPopupRef& popup_ref = g.OpenPopupStack[g.CurrentPopupStack.Size];

	lea	ecx, DWORD PTR [esi+6368]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	mov	esi, DWORD PTR [ecx]
	shl	esi, 5
	add	esi, DWORD PTR [eax+6364]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4779 :         window_was_active &= (window->PopupId == popup_ref.PopupId);

	mov	eax, DWORD PTR [edi+144]

; 4780 :         window_was_active &= (window == popup_ref.Window);
; 4781 :         popup_ref.Window = window;
; 4782 :         g.CurrentPopupStack.push_back(popup_ref);

	push	esi
	cmp	edi, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+4], edi
	sete	dl
	cmp	eax, DWORD PTR [esi]
	sete	al
	and	dl, al
	and	dh, dl
	mov	BYTE PTR _window_was_active$1$[ebp], dh
	call	?push_back@?$ImVector@UImGuiPopupRef@@@@QAEXABUImGuiPopupRef@@@Z ; ImVector<ImGuiPopupRef>::push_back

; 4783 :         window->PopupId = popup_ref.PopupId;

	mov	eax, DWORD PTR [esi]
	mov	esi, DWORD PTR _g$1$[ebp]
	mov	dh, BYTE PTR _window_was_active$1$[ebp]
	mov	DWORD PTR [edi+144], eax
$LN15@Begin:

; 4784 :     }
; 4785 : 
; 4786 :     const bool window_appearing_after_being_hidden = (window->HiddenFrames == 1);

	mov	ecx, DWORD PTR [edi+172]
	mov	DWORD PTR tv7613[ebp], ecx
	cmp	ecx, 1

; 4787 :     if (window_appearing_after_being_hidden)

	jne	SHORT $LN16@Begin

; 4788 :         window->NavLastId = 0;

	mov	DWORD PTR [edi+148], 0
$LN16@Begin:

; 4789 : 
; 4790 :     // Process SetNextWindow***() calls
; 4791 :     bool window_pos_set_by_api = false, window_size_set_by_api = false;
; 4792 :     if (g.SetNextWindowPosCond)

	cmp	DWORD PTR [esi+6548], 0
	movss	xmm2, DWORD PTR __real@ff7fffff
	mov	BYTE PTR _window_pos_set_by_api$1$[ebp], 0
	mov	BYTE PTR _window_size_set_by_api$1$[ebp], 0
	je	$LN17@Begin

; 4793 :     {
; 4794 :         const ImVec2 backup_cursor_pos = window->DC.CursorPos;                  // FIXME: not sure of the exact reason of this saving/restore anymore :( need to look into that.

	mov	eax, DWORD PTR [edi+192]
	mov	DWORD PTR _backup_cursor_pos$1$[ebp], eax
	mov	eax, DWORD PTR [edi+196]
	mov	DWORD PTR _backup_cursor_pos$2$[ebp], eax

; 4795 :         if (!window_was_active || window_appearing_after_being_hidden) window->SetWindowPosAllowFlags |= ImGuiSetCond_Appearing;

	test	dh, dh
	je	SHORT $LN19@Begin
	cmp	ecx, 1
	jne	SHORT $LN18@Begin
$LN19@Begin:
	or	DWORD PTR [edi+176], 8
$LN18@Begin:

; 4796 :         window_pos_set_by_api = (window->SetWindowPosAllowFlags & g.SetNextWindowPosCond) != 0;

	mov	eax, DWORD PTR [edi+176]
	mov	ecx, DWORD PTR [esi+6548]
	and	eax, ecx
	setne	BYTE PTR _window_pos_set_by_api$1$[ebp]
	test	eax, eax

; 4797 :         if (window_pos_set_by_api && ImLengthSqr(g.SetNextWindowPosVal - ImVec2(-FLT_MAX,-FLT_MAX)) < 0.001f)

	je	SHORT $LN20@Begin
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [esi+6524]
	movss	xmm1, DWORD PTR [esi+6520]
	subss	xmm0, xmm2
	subss	xmm1, xmm2

; 137  : static inline float  ImLengthSqr(const ImVec2& lhs)                             { return lhs.x*lhs.x + lhs.y*lhs.y; }

	mulss	xmm0, xmm0
	mulss	xmm1, xmm1
	addss	xmm1, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4797 :         if (window_pos_set_by_api && ImLengthSqr(g.SetNextWindowPosVal - ImVec2(-FLT_MAX,-FLT_MAX)) < 0.001f)

	movss	xmm0, DWORD PTR __real@3a83126f
	comiss	xmm0, xmm1
	jbe	SHORT $LN20@Begin

; 4798 :         {
; 4799 :             window->SetWindowPosCenterWanted = true;                            // May be processed on the next frame if this is our first frame and we are measuring size

	mov	BYTE PTR [edi+188], 1

; 4800 :             window->SetWindowPosAllowFlags &= ~(ImGuiSetCond_Once | ImGuiSetCond_FirstUseEver | ImGuiSetCond_Appearing);

	and	DWORD PTR [edi+176], -15		; fffffff1H

; 4801 :         }
; 4802 :         else

	jmp	SHORT $LN21@Begin
$LN20@Begin:

; 4803 :         {
; 4804 :             SetWindowPos(window, g.SetNextWindowPosVal, g.SetNextWindowPosCond);

	push	ecx
	lea	eax, DWORD PTR [esi+6520]
	push	eax
	push	edi
	call	?SetWindowPos@@YAXPAUImGuiWindow@@ABUImVec2@@H@Z ; SetWindowPos
	mov	dh, BYTE PTR _window_was_active$1$[ebp]
	add	esp, 12					; 0000000cH
$LN21@Begin:

; 4805 :         }
; 4806 :         window->DC.CursorPos = backup_cursor_pos;

	mov	eax, DWORD PTR _backup_cursor_pos$1$[ebp]
	mov	ecx, DWORD PTR tv7613[ebp]
	mov	DWORD PTR [edi+192], eax
	mov	eax, DWORD PTR _backup_cursor_pos$2$[ebp]
	mov	DWORD PTR [edi+196], eax

; 4807 :         g.SetNextWindowPosCond = 0;

	mov	DWORD PTR [esi+6548], 0
$LN17@Begin:

; 4808 :     }
; 4809 :     if (g.SetNextWindowSizeCond)

	cmp	DWORD PTR [esi+6552], 0
	je	SHORT $LN22@Begin

; 4810 :     {
; 4811 :         if (!window_was_active || window_appearing_after_being_hidden) window->SetWindowSizeAllowFlags |= ImGuiSetCond_Appearing;

	test	dh, dh
	je	SHORT $LN24@Begin
	cmp	ecx, 1
	jne	SHORT $LN23@Begin
$LN24@Begin:
	or	DWORD PTR [edi+180], 8
$LN23@Begin:

; 4812 :         window_size_set_by_api = (window->SetWindowSizeAllowFlags & g.SetNextWindowSizeCond) != 0;

	mov	eax, DWORD PTR [esi+6552]
	test	DWORD PTR [edi+180], eax

; 4813 :         SetWindowSize(window, g.SetNextWindowSizeVal, g.SetNextWindowSizeCond);

	push	eax
	lea	eax, DWORD PTR [esi+6528]
	setne	BYTE PTR _window_size_set_by_api$1$[ebp]
	push	eax
	push	edi
	call	?SetWindowSize@@YAXPAUImGuiWindow@@ABUImVec2@@H@Z ; SetWindowSize
	add	esp, 12					; 0000000cH

; 4814 :         g.SetNextWindowSizeCond = 0;

	mov	DWORD PTR [esi+6552], 0
$LN22@Begin:

; 4815 :     }
; 4816 :     if (g.SetNextWindowContentSizeCond)

	cmp	DWORD PTR [esi+6556], 0
	je	SHORT $LN25@Begin

; 4817 :     {
; 4818 :         window->SizeContentsExplicit = g.SetNextWindowContentSizeVal;

	mov	eax, DWORD PTR [esi+6536]
	mov	DWORD PTR [edi+56], eax
	mov	eax, DWORD PTR [esi+6540]
	mov	DWORD PTR [edi+60], eax

; 4819 :         g.SetNextWindowContentSizeCond = 0;

	mov	DWORD PTR [esi+6556], 0
	jmp	SHORT $LN27@Begin
$LN25@Begin:
	mov	eax, DWORD PTR tv7611[ebp]
	cmp	eax, DWORD PTR _current_frame$1$[ebp]

; 4820 :     }
; 4821 :     else if (first_begin_of_the_frame)

	je	SHORT $LN27@Begin
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T83[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4823 :         window->SizeContentsExplicit = ImVec2(0.0f, 0.0f);

	mov	eax, DWORD PTR $T83[ebp]
	mov	DWORD PTR [edi+56], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T83[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4823 :         window->SizeContentsExplicit = ImVec2(0.0f, 0.0f);

	mov	eax, DWORD PTR $T83[ebp+4]
	mov	DWORD PTR [edi+60], eax
$LN27@Begin:

; 4824 :     }
; 4825 :     if (g.SetNextWindowCollapsedCond)

	cmp	DWORD PTR [esi+6560], 0
	je	SHORT $LN28@Begin

; 4826 :     {
; 4827 :         if (!window_was_active || window_appearing_after_being_hidden) window->SetWindowCollapsedAllowFlags |= ImGuiSetCond_Appearing;

	cmp	BYTE PTR _window_was_active$1$[ebp], 0
	je	SHORT $LN30@Begin
	cmp	DWORD PTR tv7613[ebp], 1
	jne	SHORT $LN29@Begin
$LN30@Begin:
	or	DWORD PTR [edi+184], 8
$LN29@Begin:

; 4828 :         SetWindowCollapsed(window, g.SetNextWindowCollapsedVal, g.SetNextWindowCollapsedCond);

	push	DWORD PTR [esi+6560]
	movzx	eax, BYTE PTR [esi+6544]
	push	eax
	push	edi
	call	?SetWindowCollapsed@@YAXPAUImGuiWindow@@_NH@Z ; SetWindowCollapsed
	add	esp, 12					; 0000000cH

; 4829 :         g.SetNextWindowCollapsedCond = 0;

	mov	DWORD PTR [esi+6560], 0
$LN28@Begin:

; 4830 :     }
; 4831 :     if (g.SetNextWindowFocus)

	cmp	BYTE PTR [esi+6589], 0
	je	SHORT $LN31@Begin

; 4832 :     {
; 4833 :         ImGui::SetWindowFocus();

	call	?SetWindowFocus@ImGui@@YAXXZ		; ImGui::SetWindowFocus

; 4834 :         g.SetNextWindowFocus = false;

	mov	BYTE PTR [esi+6589], 0
$LN31@Begin:

; 4835 :     }
; 4836 : 
; 4837 :     // Update known root window (if we are a child window, otherwise window == window->RootWindow)
; 4838 :     int root_idx, root_non_popup_idx;
; 4839 :     for (root_idx = g.CurrentWindowStack.Size - 1; root_idx > 0; root_idx--)

	mov	ecx, DWORD PTR [esi+6228]
	dec	ecx
	test	ecx, ecx
	jle	SHORT $LN1009@Begin
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	mov	eax, DWORD PTR [esi+6236]
	lea	edx, DWORD PTR [eax+ecx*4]
	npad	2
$LL4@Begin:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4840 :         if (!(g.CurrentWindowStack[root_idx]->Flags & ImGuiWindowFlags_ChildWindow))

	mov	eax, DWORD PTR [edx]
	test	DWORD PTR [eax+8], 4194304		; 00400000H
	je	SHORT $LN1009@Begin

; 4835 :     }
; 4836 : 
; 4837 :     // Update known root window (if we are a child window, otherwise window == window->RootWindow)
; 4838 :     int root_idx, root_non_popup_idx;
; 4839 :     for (root_idx = g.CurrentWindowStack.Size - 1; root_idx > 0; root_idx--)

	dec	ecx
	sub	edx, 4
	test	ecx, ecx
	jg	SHORT $LL4@Begin
$LN1009@Begin:

; 4841 :             break;
; 4842 :     for (root_non_popup_idx = root_idx; root_non_popup_idx > 0; root_non_popup_idx--)

	mov	edx, ecx
	test	ecx, ecx
	jle	SHORT $LN997@Begin
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	mov	eax, DWORD PTR [esi+6236]
	mov	esi, eax
	mov	DWORD PTR $T105[ebp], eax
$LL7@Begin:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4843 :         if (!(g.CurrentWindowStack[root_non_popup_idx]->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)) || (g.CurrentWindowStack[root_non_popup_idx]->Flags & ImGuiWindowFlags_Modal))

	mov	eax, DWORD PTR [esi+edx*4]
	mov	eax, DWORD PTR [eax+8]
	test	eax, 37748736				; 02400000H
	je	SHORT $LN1010@Begin
	test	eax, 67108864				; 04000000H
	jne	SHORT $LN1010@Begin

; 4841 :             break;
; 4842 :     for (root_non_popup_idx = root_idx; root_non_popup_idx > 0; root_non_popup_idx--)

	dec	edx
	test	edx, edx
	jg	SHORT $LL7@Begin
$LN1010@Begin:
	mov	esi, DWORD PTR _g$1$[ebp]
$LN997@Begin:

; 4844 :             break;
; 4845 :     window->ParentWindow = parent_window;

	mov	eax, DWORD PTR _parent_window$1$[ebp]
	mov	DWORD PTR [edi+628], eax

; 4846 :     window->RootWindow = g.CurrentWindowStack[root_idx];

	mov	eax, DWORD PTR [esi+6236]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edi+632], eax

; 4847 :     window->RootNonPopupWindow = g.CurrentWindowStack[root_non_popup_idx];      // Used to display TitleBgActive color and for selecting which window to use for NavWindowing

	mov	eax, DWORD PTR [esi+6236]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [edi+636], eax

; 4848 :     window->RootNavWindow = window;

	mov	DWORD PTR [edi+640], edi
	npad	3
$LL8@Begin:

; 4849 :     while (window->RootNavWindow && window->RootNavWindow->Flags & ImGuiWindowFlags_NavFlattened)

	mov	eax, DWORD PTR [edi+640]
	test	DWORD PTR [eax+8], 524288		; 00080000H
	je	SHORT $LN9@Begin

; 4850 :         window->RootNavWindow = window->RootNavWindow->ParentWindow;

	mov	eax, DWORD PTR [eax+628]
	mov	DWORD PTR [edi+640], eax
	test	eax, eax
	jne	SHORT $LL8@Begin
$LN9@Begin:
	mov	eax, DWORD PTR _current_frame$1$[ebp]

; 4851 : 
; 4852 :     // When reusing window again multiple times a frame, just append content (don't need to setup again)
; 4853 :     if (first_begin_of_the_frame)

	movss	xmm5, DWORD PTR __real@3f000000
	cmp	DWORD PTR tv7611[ebp], eax
	je	$LN35@Begin

; 4854 :     {
; 4855 :         window->Active = true;

	movaps	xmm0, XMMWORD PTR __xmm@7f7fffff7f7fffffff7fffffff7fffff
	mov	BYTE PTR [edi+132], 1

; 4856 :         window->IndexWithinParent = 0;

	mov	DWORD PTR [edi+12], 0

; 4857 :         window->BeginCount = 0;

	mov	DWORD PTR [edi+140], 0

; 4858 :         window->ClipRect = ImVec4(-FLT_MAX,-FLT_MAX,+FLT_MAX,+FLT_MAX);

	movups	XMMWORD PTR [edi+472], xmm0

; 4859 :         window->LastFrameActive = current_frame;

	mov	DWORD PTR [edi+520], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	ecx, DWORD PTR [edi+464]
	cmp	ecx, 1
	jge	SHORT $LN243@Begin

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN241@Begin
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN242@Begin
$LN241@Begin:
	mov	eax, 8
$LN242@Begin:
	mov	ecx, 1
	cmp	eax, ecx
	cmovg	ecx, eax
	mov	DWORD PTR _new_capacity$1$[ebp], ecx

; 931  :         if (new_capacity <= Capacity) return;

	cmp	ecx, DWORD PTR [edi+464]
	jle	SHORT $LN243@Begin

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [ecx*4]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [edi+468]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN245@Begin

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [edi+460]
	shl	ecx, 2
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN245@Begin:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [edi+468]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [edi+468], eax

; 937  :         Capacity = new_capacity;

	mov	eax, DWORD PTR _new_capacity$1$[ebp]
	mov	DWORD PTR [edi+464], eax
$LN243@Begin:

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [edi+460], 1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4863 :         window->DrawList->Clear();

	mov	ecx, DWORD PTR [edi+624]
	call	?Clear@ImDrawList@@QAEXXZ		; ImDrawList::Clear

; 4864 :         window->DrawList->PushTextureID(g.Font->ContainerAtlas->TexID);

	mov	eax, DWORD PTR [esi+6168]
	mov	ecx, DWORD PTR [edi+624]
	push	DWORD PTR [eax+68]
	call	?PushTextureID@ImDrawList@@QAEXABQAX@Z	; ImDrawList::PushTextureID

; 4865 :         ImRect fullscreen_rect(GetVisibleRect());

	lea	eax, DWORD PTR _fullscreen_rect$33[ebp]
	push	eax
	call	?GetVisibleRect@@YA?AUImRect@@XZ	; GetVisibleRect
	mov	eax, DWORD PTR _flags$1$[ebp]
	add	esp, 4
	and	eax, 46137344				; 02c00000H

; 4866 :         if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & (ImGuiWindowFlags_ComboBox|ImGuiWindowFlags_Popup)))
; 4867 :             PushClipRect(parent_window->ClipRect.Min, parent_window->ClipRect.Max, true);

	push	1
	cmp	eax, 4194304				; 00400000H
	jne	SHORT $LN36@Begin
	mov	ecx, DWORD PTR _parent_window$1$[ebp]
	lea	eax, DWORD PTR [ecx+480]
	push	eax
	lea	eax, DWORD PTR [ecx+472]

; 4868 :         else

	jmp	SHORT $LN1024@Begin
$LN36@Begin:

; 4869 :             PushClipRect(fullscreen_rect.Min, fullscreen_rect.Max, true);

	lea	eax, DWORD PTR _fullscreen_rect$33[ebp+8]
	push	eax
	lea	eax, DWORD PTR _fullscreen_rect$33[ebp]
$LN1024@Begin:
	push	eax
	call	?PushClipRect@ImGui@@YAXABUImVec2@@0_N@Z ; ImGui::PushClipRect
	add	esp, 12					; 0000000cH

; 4870 : 
; 4871 :         if (!window_was_active)

	cmp	BYTE PTR _window_was_active$1$[ebp], 0
	jne	SHORT $LN39@Begin

; 4872 :         {
; 4873 :             // Popup first latch mouse position, will position itself when it appears next frame
; 4874 :             window->AutoPosLastDirection = -1;

	cmp	DWORD PTR tv7601[ebp], 0
	mov	DWORD PTR [edi+168], -1

; 4875 :             if ((flags & ImGuiWindowFlags_Popup) != 0 && !window_pos_set_by_api)

	je	SHORT $LN39@Begin
	cmp	BYTE PTR _window_pos_set_by_api$1$[ebp], 0
	jne	SHORT $LN39@Begin

; 4876 :                 window->PosFloat = g.CurrentPopupStack.back().PopupPosOnOpen;

	mov	edx, DWORD PTR [esi+6368]
	mov	ecx, DWORD PTR [esi+6376]
	shl	edx, 5
	mov	eax, DWORD PTR [ecx+edx-16]
	mov	DWORD PTR [edi+16], eax
	mov	eax, DWORD PTR [ecx+edx-12]
	mov	DWORD PTR [edi+20], eax
$LN39@Begin:

; 4877 :         }
; 4878 : 
; 4879 :         // Collapse window by double-clicking on title bar
; 4880 :         // At this point we don't have a clipping rectangle setup yet, so we can use the title bar area for hit detection and drawing
; 4881 :         if (!(flags & ImGuiWindowFlags_NoTitleBar) && !(flags & ImGuiWindowFlags_NoCollapse))

	mov	edx, DWORD PTR _flags$1$[ebp]
	test	dl, 33					; 00000021H
	jne	$LN40@Begin
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	test	BYTE PTR [edi+8], 1
	je	SHORT $LN253@Begin
	xorps	xmm1, xmm1
	jmp	SHORT $LN254@Begin
$LN253@Begin:
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	movss	xmm0, DWORD PTR [eax+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm1, DWORD PTR [eax+6176]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm0, xmm0

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm1, DWORD PTR [edi+620]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm1, xmm0
$LN254@Begin:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4884 :             if (window->CollapseToggleWanted || (g.HoveredWindow == window && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max) && g.IO.MouseDoubleClicked[0]))

	cmp	BYTE PTR [edi+136], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 776  :     ImRect      TitleBarRect() const                    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }

	movss	xmm0, DWORD PTR [edi+40]
	addss	xmm0, DWORD PTR [edi+24]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [edi+24]
	mov	DWORD PTR _title_bar_rect$71[ebp], eax
	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR _title_bar_rect$71[ebp+4], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T72[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 776  :     ImRect      TitleBarRect() const                    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }

	movss	xmm0, DWORD PTR [edi+28]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T72[ebp]

; 776  :     ImRect      TitleBarRect() const                    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }

	addss	xmm0, xmm1

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _title_bar_rect$71[ebp+8], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T72[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T72[ebp+4]
	mov	DWORD PTR _title_bar_rect$71[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4884 :             if (window->CollapseToggleWanted || (g.HoveredWindow == window && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max) && g.IO.MouseDoubleClicked[0]))

	jne	SHORT $LN43@Begin
	cmp	DWORD PTR [esi+6244], edi
	jne	SHORT $LN41@Begin
	push	1
	lea	eax, DWORD PTR _title_bar_rect$71[ebp+8]
	push	eax
	lea	eax, DWORD PTR _title_bar_rect$71[ebp]
	push	eax
	call	?IsMouseHoveringRect@ImGui@@YA_NABUImVec2@@0_N@Z ; ImGui::IsMouseHoveringRect
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN1020@Begin
	cmp	BYTE PTR [esi+956], 0
	je	SHORT $LN1020@Begin
$LN43@Begin:

; 4885 :             {
; 4886 :                 window->Collapsed = !window->Collapsed;

	cmp	BYTE PTR [edi+135], 0

; 4887 :                 MarkIniSettingsDirty(window);

	push	edi
	sete	al
	mov	BYTE PTR [edi+135], al
	call	?MarkIniSettingsDirty@@YAXPAUImGuiWindow@@@Z ; MarkIniSettingsDirty

; 4888 :                 FocusWindow(window);

	push	edi
	call	?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusWindow
	add	esp, 8
$LN1020@Begin:
	mov	edx, DWORD PTR _flags$1$[ebp]
$LN41@Begin:

; 4894 :         }
; 4895 :         window->CollapseToggleWanted = false;
; 4896 : 
; 4897 :         // SIZE
; 4898 : 
; 4899 :         // Save contents size from last frame for auto-fitting (unless explicitly specified)
; 4900 :         window->SizeContents.x = (float)(int)((window->SizeContentsExplicit.x != 0.0f) ? window->SizeContentsExplicit.x : ((window_is_new ? 0.0f : window->DC.CursorMaxPos.x - window->Pos.x) + window->Scroll.x));

	mov	cl, BYTE PTR _window_is_new$1$[ebp]
	xorps	xmm5, xmm5
	mov	BYTE PTR [edi+136], 0
	movss	xmm0, DWORD PTR [edi+56]
	ucomiss	xmm0, xmm5
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN134@Begin
	test	cl, cl
	je	SHORT $LN131@Begin
	xorps	xmm1, xmm1
	jmp	SHORT $LN132@Begin
$LN40@Begin:

; 4889 :             }
; 4890 :         }
; 4891 :         else
; 4892 :         {
; 4893 :             window->Collapsed = false;

	mov	BYTE PTR [edi+135], 0
	jmp	SHORT $LN41@Begin
$LN131@Begin:

; 4894 :         }
; 4895 :         window->CollapseToggleWanted = false;
; 4896 : 
; 4897 :         // SIZE
; 4898 : 
; 4899 :         // Save contents size from last frame for auto-fitting (unless explicitly specified)
; 4900 :         window->SizeContents.x = (float)(int)((window->SizeContentsExplicit.x != 0.0f) ? window->SizeContentsExplicit.x : ((window_is_new ? 0.0f : window->DC.CursorMaxPos.x - window->Pos.x) + window->Scroll.x));

	movss	xmm1, DWORD PTR [edi+216]
	subss	xmm1, DWORD PTR [edi+24]
$LN132@Begin:
	movss	xmm0, DWORD PTR [edi+92]
	addss	xmm0, xmm1
$LN134@Begin:
	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [edi+48], xmm0

; 4901 :         window->SizeContents.y = (float)(int)((window->SizeContentsExplicit.y != 0.0f) ? window->SizeContentsExplicit.y : ((window_is_new ? 0.0f : window->DC.CursorMaxPos.y - window->Pos.y) + window->Scroll.y));

	movss	xmm0, DWORD PTR [edi+60]
	ucomiss	xmm0, xmm5
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN138@Begin
	test	cl, cl
	je	SHORT $LN135@Begin
	xorps	xmm1, xmm1
	jmp	SHORT $LN136@Begin
$LN135@Begin:
	movss	xmm1, DWORD PTR [edi+220]
	subss	xmm1, DWORD PTR [edi+28]
$LN136@Begin:
	movss	xmm0, DWORD PTR [edi+96]
	addss	xmm0, xmm1
$LN138@Begin:
	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [edi+52], xmm0

; 4902 : 
; 4903 :         // Hide popup/tooltip window when first appearing while we measure size (because we recycle them)
; 4904 :         if (window->HiddenFrames > 0)

	mov	eax, DWORD PTR [edi+172]
	test	eax, eax
	jle	SHORT $LN44@Begin

; 4905 :             window->HiddenFrames--;

	dec	eax
	mov	DWORD PTR [edi+172], eax
$LN44@Begin:

; 4906 :         if ((flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) != 0 && !window_was_active)

	mov	eax, edx
	and	eax, 50331648				; 03000000H
	mov	DWORD PTR tv7547[ebp], eax
	je	SHORT $LN46@Begin
	cmp	BYTE PTR _window_was_active$1$[ebp], 0
	jne	SHORT $LN46@Begin

; 4907 :         {
; 4908 :             window->HiddenFrames = 1;

	mov	DWORD PTR [edi+172], 1

; 4909 :             if (flags & ImGuiWindowFlags_AlwaysAutoResize)

	test	dl, 64					; 00000040H
	je	SHORT $LN46@Begin

; 4910 :             {
; 4911 :                 if (!window_size_set_by_api)

	cmp	BYTE PTR _window_size_set_by_api$1$[ebp], 0
	jne	SHORT $LN47@Begin
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T82[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4912 :                     window->Size = window->SizeFull = ImVec2(0.f, 0.f);

	mov	ecx, DWORD PTR $T82[ebp]
	mov	DWORD PTR [edi+40], ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T82[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4912 :                     window->Size = window->SizeFull = ImVec2(0.f, 0.f);

	mov	eax, DWORD PTR $T82[ebp+4]
	mov	DWORD PTR [edi+44], eax
	mov	DWORD PTR [edi+32], ecx
	mov	DWORD PTR [edi+36], eax
$LN47@Begin:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T81[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4913 :                 window->SizeContents = ImVec2(0.f, 0.f);

	mov	eax, DWORD PTR $T81[ebp]
	mov	DWORD PTR [edi+48], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T81[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4913 :                 window->SizeContents = ImVec2(0.f, 0.f);

	mov	eax, DWORD PTR $T81[ebp+4]
	mov	DWORD PTR [edi+52], eax
$LN46@Begin:

; 4918 :         window->WindowPadding = ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & (ImGuiWindowFlags_AlwaysUseWindowPadding | ImGuiWindowFlags_ShowBorders | ImGuiWindowFlags_ComboBox | ImGuiWindowFlags_Popup))) ? ImVec2(0,0) : style.WindowPadding;

	mov	eax, edx
	lea	ecx, DWORD PTR $T80[ebp]
	and	eax, 46203008				; 02c10080H
	cmp	eax, 4194304				; 00400000H
	jne	SHORT $LN139@Begin
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T80[ebp], 0
	mov	DWORD PTR $T80[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4918 :         window->WindowPadding = ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & (ImGuiWindowFlags_AlwaysUseWindowPadding | ImGuiWindowFlags_ShowBorders | ImGuiWindowFlags_ComboBox | ImGuiWindowFlags_Popup))) ? ImVec2(0,0) : style.WindowPadding;

	jmp	SHORT $LN140@Begin
$LN139@Begin:
	mov	eax, DWORD PTR [esi+5324]
	mov	DWORD PTR $T79[ebp], eax
	mov	eax, DWORD PTR [esi+5328]
	mov	DWORD PTR $T79[ebp+4], eax
$LN140@Begin:
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edi+80], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edi+84], eax

; 4919 : 
; 4920 :         // Calculate auto-fit size
; 4921 :         ImVec2 size_auto_fit;
; 4922 :         if ((flags & ImGuiWindowFlags_Tooltip) != 0)

	mov	eax, edx
	and	eax, 16777216				; 01000000H
	mov	DWORD PTR tv7543[ebp], eax
	je	SHORT $LN48@Begin
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm2, DWORD PTR [edi+80]
	movss	xmm1, DWORD PTR [edi+52]
	addss	xmm2, DWORD PTR [edi+48]
	addss	xmm1, DWORD PTR [edi+84]
	movss	DWORD PTR _size_auto_fit$3$[ebp], xmm2

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm1, DWORD PTR [esi+5372]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4927 :         else

	jmp	$LN1025@Begin
$LN48@Begin:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm1, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [esi+5320]
	movss	xmm0, DWORD PTR [esi+4]
	subss	xmm0, DWORD PTR [esi+5432]
	subss	xmm1, DWORD PTR [esi+5436]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm2, DWORD PTR [edi+52]
	addss	xmm2, DWORD PTR [edi+84]
	movss	xmm3, DWORD PTR [ecx+16]
	movss	xmm4, DWORD PTR [ecx+12]
	maxss	xmm4, xmm0
	movss	xmm0, DWORD PTR [edi+80]
	addss	xmm0, DWORD PTR [edi+48]
	maxss	xmm3, xmm1

; 133  : static inline ImVec2 ImClamp(const ImVec2& f, const ImVec2& mn, ImVec2 mx)      { return ImVec2(ImClamp(f.x,mn.x,mx.x), ImClamp(f.y,mn.y,mx.y)); }

	movss	xmm1, DWORD PTR [ecx+16]

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm1, xmm2
	ja	SHORT $LN306@Begin
	movaps	xmm1, xmm2
	minss	xmm1, xmm3
$LN306@Begin:

; 133  : static inline ImVec2 ImClamp(const ImVec2& f, const ImVec2& mn, ImVec2 mx)      { return ImVec2(ImClamp(f.x,mn.x,mx.x), ImClamp(f.y,mn.y,mx.y)); }

	movss	xmm2, DWORD PTR [ecx+12]

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm2, xmm0

; 133  : static inline ImVec2 ImClamp(const ImVec2& f, const ImVec2& mn, ImVec2 mx)      { return ImVec2(ImClamp(f.x,mn.x,mx.x), ImClamp(f.y,mn.y,mx.y)); }

	movss	DWORD PTR _size_auto_fit$3$[ebp], xmm2

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	ja	SHORT $LN312@Begin
	movaps	xmm2, xmm4
	minss	xmm2, xmm0
	movss	DWORD PTR _size_auto_fit$3$[ebp], xmm2
$LN312@Begin:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4932 :             if (size_auto_fit.x < window->SizeContents.x && !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar))

	movss	xmm0, DWORD PTR [edi+48]
	comiss	xmm0, xmm2
	jbe	SHORT $LN50@Begin
	mov	eax, edx
	and	eax, 2056				; 00000808H
	cmp	eax, 2048				; 00000800H
	jne	SHORT $LN50@Begin

; 4933 :                 size_auto_fit.y += style.ScrollbarSize;

	addss	xmm1, DWORD PTR [ecx+80]
$LN50@Begin:

; 4934 :             if (size_auto_fit.y < window->SizeContents.y && !(flags & ImGuiWindowFlags_NoScrollbar))

	movss	xmm0, DWORD PTR [edi+52]
	comiss	xmm0, xmm1
	jbe	SHORT $LN51@Begin
	test	dl, 8
	jne	SHORT $LN51@Begin

; 4935 :                 size_auto_fit.x += style.ScrollbarSize;

	movss	xmm0, DWORD PTR [ecx+80]
	addss	xmm0, xmm2
	movaps	xmm2, xmm0
	movss	DWORD PTR _size_auto_fit$3$[ebp], xmm2
$LN51@Begin:

; 4936 :             size_auto_fit.y = ImMax(size_auto_fit.y - style.ItemSpacing.y, 0.0f);

	subss	xmm1, DWORD PTR [ecx+52]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 128  : static inline float  ImMax(float lhs, float rhs)                                { return lhs >= rhs ? lhs : rhs; }

	comiss	xmm1, xmm5
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4936 :             size_auto_fit.y = ImMax(size_auto_fit.y - style.ItemSpacing.y, 0.0f);

	movss	DWORD PTR _size_auto_fit$2$[ebp], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 128  : static inline float  ImMax(float lhs, float rhs)                                { return lhs >= rhs ? lhs : rhs; }

	jae	SHORT $LN318@Begin
	xorps	xmm1, xmm1
$LN1025@Begin:
	movss	DWORD PTR _size_auto_fit$2$[ebp], xmm1
$LN318@Begin:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4940 :         if (window->Collapsed)

	cmp	BYTE PTR [edi+135], 0
	je	SHORT $LN52@Begin

; 4941 :         {
; 4942 :             // We still process initial auto-fit on collapsed windows to get a window width,
; 4943 :             // But otherwise we don't honor ImGuiWindowFlags_AlwaysAutoResize when collapsed.
; 4944 :             if (window->AutoFitFramesX > 0)

	cmp	DWORD PTR [edi+152], 0
	jle	SHORT $LN54@Begin

; 4945 :                 window->SizeFull.x = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.x, size_auto_fit.x) : size_auto_fit.x;

	cmp	BYTE PTR [edi+160], 0
	je	SHORT $LN141@Begin
	movss	xmm0, DWORD PTR [edi+40]
	maxss	xmm0, xmm2
	jmp	SHORT $LN142@Begin
$LN141@Begin:
	movaps	xmm0, xmm2
$LN142@Begin:
	movss	DWORD PTR [edi+40], xmm0
$LN54@Begin:

; 4946 :             if (window->AutoFitFramesY > 0)

	cmp	DWORD PTR [edi+156], 0
	jle	$LN58@Begin

; 4947 :                 window->SizeFull.y = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.y, size_auto_fit.y) : size_auto_fit.y;

	cmp	BYTE PTR [edi+160], 0
	je	SHORT $LN143@Begin
	movss	xmm0, DWORD PTR [edi+44]
	maxss	xmm0, xmm1
	movss	DWORD PTR [edi+44], xmm0

; 4948 :         }
; 4949 :         else

	jmp	$LN58@Begin
$LN143@Begin:

; 4947 :                 window->SizeFull.y = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.y, size_auto_fit.y) : size_auto_fit.y;

	movaps	xmm0, xmm1
	movss	DWORD PTR [edi+44], xmm0

; 4948 :         }
; 4949 :         else

	jmp	$LN58@Begin
$LN52@Begin:

; 4950 :         {
; 4951 :             if ((flags & ImGuiWindowFlags_AlwaysAutoResize) && !window_size_set_by_api)

	mov	cl, BYTE PTR _window_size_set_by_api$1$[ebp]
	test	dl, 64					; 00000040H
	je	SHORT $LN56@Begin
	test	cl, cl
	jne	SHORT $LN56@Begin

; 4952 :             {
; 4953 :                 window->SizeFull = size_auto_fit;

	movss	DWORD PTR [edi+40], xmm2
	movss	DWORD PTR [edi+44], xmm1
	jmp	SHORT $LN58@Begin
$LN56@Begin:

; 4954 :             }
; 4955 :             else if ((window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0) && !window_size_set_by_api)

	mov	eax, DWORD PTR [edi+152]
	test	eax, eax
	jg	SHORT $LN59@Begin
	cmp	DWORD PTR [edi+156], 0
	jle	SHORT $LN58@Begin
$LN59@Begin:
	test	cl, cl
	jne	SHORT $LN58@Begin

; 4956 :             {
; 4957 :                 // Auto-fit only grows during the first few frames
; 4958 :                 if (window->AutoFitFramesX > 0)

	test	eax, eax
	jle	SHORT $LN60@Begin

; 4959 :                     window->SizeFull.x = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.x, size_auto_fit.x) : size_auto_fit.x;

	cmp	BYTE PTR [edi+160], cl
	je	SHORT $LN145@Begin
	movss	xmm0, DWORD PTR [edi+40]
	maxss	xmm0, xmm2
	jmp	SHORT $LN146@Begin
$LN145@Begin:
	movaps	xmm0, xmm2
$LN146@Begin:
	movss	DWORD PTR [edi+40], xmm0
$LN60@Begin:

; 4960 :                 if (window->AutoFitFramesY > 0)

	cmp	DWORD PTR [edi+156], 0
	jle	SHORT $LN61@Begin

; 4961 :                     window->SizeFull.y = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.y, size_auto_fit.y) : size_auto_fit.y;

	cmp	BYTE PTR [edi+160], 0
	je	SHORT $LN147@Begin
	movss	xmm0, DWORD PTR [edi+44]
	maxss	xmm0, xmm1
	jmp	SHORT $LN148@Begin
$LN147@Begin:
	movaps	xmm0, xmm1
$LN148@Begin:
	movss	DWORD PTR [edi+44], xmm0
$LN61@Begin:

; 4962 :                 MarkIniSettingsDirty(window);

	push	edi
	call	?MarkIniSettingsDirty@@YAXPAUImGuiWindow@@@Z ; MarkIniSettingsDirty
	add	esp, 4
$LN58@Begin:

; 4963 :             }
; 4964 :         }
; 4965 : 
; 4966 :         // Apply minimum/maximum window size constraints and final size
; 4967 :         ApplySizeFullWithConstraint(window, window->SizeFull);

	push	DWORD PTR [edi+44]
	push	DWORD PTR [edi+40]
	push	edi
	call	?ApplySizeFullWithConstraint@@YAXPAUImGuiWindow@@UImVec2@@@Z ; ApplySizeFullWithConstraint
	add	esp, 12					; 0000000cH

; 4968 :         window->Size = window->Collapsed ? window->TitleBarRect().GetSize() : window->SizeFull;

	cmp	BYTE PTR [edi+135], 0
	je	SHORT $LN149@Begin
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	test	BYTE PTR [edi+8], 1
	je	SHORT $LN339@Begin
	xorps	xmm2, xmm2
	jmp	SHORT $LN340@Begin
$LN339@Begin:
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	movss	xmm0, DWORD PTR [eax+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm2, DWORD PTR [eax+6176]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm0, xmm0

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm2, DWORD PTR [edi+620]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm2, xmm0
$LN340@Begin:

; 776  :     ImRect      TitleBarRect() const                    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }

	movss	xmm0, DWORD PTR [edi+40]
	movss	xmm1, DWORD PTR [edi+28]
	addss	xmm0, DWORD PTR [edi+24]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [edi+24]

; 776  :     ImRect      TitleBarRect() const                    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }

	addss	xmm1, xmm2

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR $T70[ebp], eax
	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR $T70[ebp+4], eax

; 245  :     ImVec2      GetSize() const                 { return ImVec2(Max.x-Min.x, Max.y-Min.y); }

	subss	xmm0, DWORD PTR $T70[ebp]
	subss	xmm1, DWORD PTR $T70[ebp+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T78[ebp], xmm0
	movss	DWORD PTR $T78[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4968 :         window->Size = window->Collapsed ? window->TitleBarRect().GetSize() : window->SizeFull;

	jmp	SHORT $LN1026@Begin
$LN149@Begin:
	mov	eax, DWORD PTR [edi+40]
	mov	DWORD PTR $T77[ebp], eax
	mov	eax, DWORD PTR [edi+44]
	mov	DWORD PTR $T77[ebp+4], eax
$LN1026@Begin:

; 4969 :         
; 4970 :         // POSITION
; 4971 : 
; 4972 :         // Position child window
; 4973 :         if (flags & ImGuiWindowFlags_ChildWindow)

	mov	edx, DWORD PTR _flags$1$[ebp]
	lea	ecx, DWORD PTR $T77[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edi+32], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edi+36], eax
	mov	eax, edx
	and	eax, 4194304				; 00400000H
	mov	DWORD PTR tv7534[ebp], eax
	je	$LN1023@Begin

; 4974 :         {
; 4975 :             window->IndexWithinParent = parent_window->DC.ChildWindows.Size;

	mov	eax, DWORD PTR _parent_window$1$[ebp]
	mov	eax, DWORD PTR [eax+292]
	mov	DWORD PTR [edi+12], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	eax, DWORD PTR _parent_window$1$[ebp]
	mov	ecx, DWORD PTR [eax+292]
	mov	eax, DWORD PTR [eax+296]
	mov	DWORD PTR tv7530[ebp], eax
	cmp	ecx, eax
	jne	$LN358@Begin
	inc	ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	eax, eax
	je	SHORT $LN356@Begin
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR tv7530[ebp]
	sar	eax, 1
	add	eax, edx
	jmp	SHORT $LN357@Begin
$LN356@Begin:
	mov	edx, DWORD PTR tv7530[ebp]
	mov	eax, 8
$LN357@Begin:
	cmp	eax, ecx
	cmovg	ecx, eax
	mov	DWORD PTR _new_capacity$1$[ebp], ecx

; 931  :         if (new_capacity <= Capacity) return;

	cmp	ecx, edx
	jle	SHORT $LN1018@Begin

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [ecx*4]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	ecx, DWORD PTR _parent_window$1$[ebp]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	mov	edx, DWORD PTR [ecx+300]
	test	edx, edx
	je	SHORT $LN360@Begin

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [ecx+292]
	shl	ecx, 2
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	mov	ecx, DWORD PTR _parent_window$1$[ebp]
	add	esp, 12					; 0000000cH
$LN360@Begin:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [ecx+300]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	ecx, DWORD PTR _parent_window$1$[ebp]
	add	esp, 4
	mov	eax, DWORD PTR _new_data$1$[ebp]
	mov	DWORD PTR [ecx+300], eax

; 937  :         Capacity = new_capacity;

	mov	eax, DWORD PTR _new_capacity$1$[ebp]
	mov	DWORD PTR [ecx+296], eax
$LN1018@Begin:
	mov	edx, DWORD PTR _flags$1$[ebp]
$LN358@Begin:

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	eax, DWORD PTR _parent_window$1$[ebp]
	mov	ecx, DWORD PTR [eax+292]
	mov	eax, DWORD PTR [eax+300]
	mov	DWORD PTR [eax+ecx*4], edi
	mov	ecx, DWORD PTR _parent_window$1$[ebp]
	inc	DWORD PTR [ecx+292]
	jmp	SHORT $LN62@Begin
$LN1023@Begin:
	mov	ecx, DWORD PTR _parent_window$1$[ebp]
$LN62@Begin:
	mov	eax, edx
	and	eax, 37748736				; 02400000H
	cmp	eax, 4194304				; 00400000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4978 :         if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup))

	jne	SHORT $LN63@Begin

; 4979 :         {
; 4980 :             window->Pos = window->PosFloat = parent_window->DC.CursorPos;

	mov	eax, DWORD PTR [ecx+192]
	mov	DWORD PTR [edi+16], eax
	mov	eax, DWORD PTR [ecx+196]
	mov	DWORD PTR [edi+20], eax
	mov	eax, DWORD PTR [ecx+192]
	mov	DWORD PTR [edi+24], eax
	mov	eax, DWORD PTR [ecx+196]

; 4981 :             window->Size = window->SizeFull = size_on_first_use; // NB: argument name 'size_on_first_use' misleading here, it's really just 'size' as provided by user passed via BeginChild()->Begin().

	mov	ecx, DWORD PTR _size_on_first_use$[ebp]
	mov	DWORD PTR [edi+28], eax
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edi+40], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edi+44], eax
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edi+32], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edi+36], eax
$LN63@Begin:

; 4982 :         }
; 4983 : 
; 4984 :         bool window_pos_center = false;
; 4985 :         window_pos_center |= (window->SetWindowPosCenterWanted && window->HiddenFrames == 0);

	cmp	BYTE PTR [edi+188], 0
	je	SHORT $LN151@Begin
	cmp	DWORD PTR [edi+172], 0
	jne	SHORT $LN151@Begin
	mov	ecx, 1
	jmp	SHORT $LN152@Begin
$LN151@Begin:
	xor	ecx, ecx
$LN152@Begin:

; 4986 :         window_pos_center |= ((flags & ImGuiWindowFlags_Modal) && !window_pos_set_by_api && window_appearing_after_being_hidden);

	mov	eax, edx
	and	eax, 67108864				; 04000000H
	mov	DWORD PTR tv7526[ebp], eax
	je	SHORT $LN153@Begin
	cmp	BYTE PTR _window_pos_set_by_api$1$[ebp], 0
	jne	SHORT $LN153@Begin
	cmp	DWORD PTR tv7613[ebp], 1
	jne	SHORT $LN153@Begin
	mov	eax, 1
	jmp	SHORT $LN154@Begin
$LN153@Begin:
	xor	eax, eax
$LN154@Begin:
	or	al, cl

; 4987 :         if (window_pos_center)

	movss	xmm3, DWORD PTR __real@3f800000
	je	$LN64@Begin
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm3, DWORD PTR _fullscreen_rect$33[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4990 :             SetWindowPos(window, ImMax(style.DisplaySafeAreaPadding, fullscreen_rect.GetCenter() - window->SizeFull * 0.5f), 0);

	lea	eax, DWORD PTR $T76[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	addss	xmm3, DWORD PTR _fullscreen_rect$33[ebp+8]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	movss	xmm4, DWORD PTR __real@3f000000
	movss	xmm0, DWORD PTR [edi+40]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm2, DWORD PTR _fullscreen_rect$33[ebp+4]
	addss	xmm2, DWORD PTR _fullscreen_rect$33[ebp+12]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	movss	xmm1, DWORD PTR [edi+44]
	mulss	xmm0, xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4990 :             SetWindowPos(window, ImMax(style.DisplaySafeAreaPadding, fullscreen_rect.GetCenter() - window->SizeFull * 0.5f), 0);

	push	0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 244  :     ImVec2      GetCenter() const               { return ImVec2((Min.x+Max.x)*0.5f, (Min.y+Max.y)*0.5f); }

	mulss	xmm3, xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4990 :             SetWindowPos(window, ImMax(style.DisplaySafeAreaPadding, fullscreen_rect.GetCenter() - window->SizeFull * 0.5f), 0);

	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	mulss	xmm1, xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4990 :             SetWindowPos(window, ImMax(style.DisplaySafeAreaPadding, fullscreen_rect.GetCenter() - window->SizeFull * 0.5f), 0);

	push	edi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm3, xmm0

; 244  :     ImVec2      GetCenter() const               { return ImVec2((Min.x+Max.x)*0.5f, (Min.y+Max.y)*0.5f); }

	mulss	xmm2, xmm4
	movss	xmm0, DWORD PTR [esi+5432]

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm2, xmm1
	maxss	xmm0, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T76[ebp], xmm0
	movss	xmm0, DWORD PTR [esi+5436]
	maxss	xmm0, xmm2
	movss	DWORD PTR $T76[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4990 :             SetWindowPos(window, ImMax(style.DisplaySafeAreaPadding, fullscreen_rect.GetCenter() - window->SizeFull * 0.5f), 0);

	call	?SetWindowPos@@YAXPAUImGuiWindow@@ABUImVec2@@H@Z ; SetWindowPos
	add	esp, 12					; 0000000cH
	jmp	$LN1022@Begin
$LN64@Begin:

; 4991 :         }
; 4992 :         else if (flags & ImGuiWindowFlags_ChildMenu)

	test	edx, 134217728				; 08000000H
	je	$LN66@Begin

; 4993 :         {
; 4994 :             IM_ASSERT(window_pos_set_by_api);
; 4995 :             ImRect rect_to_avoid;
; 4996 :             if (parent_window && parent_window->DC.MenuBarAppending)

	movaps	xmm0, XMMWORD PTR __xmm@ff7fffffff7fffff7f7fffff7f7fffff
	mov	esi, DWORD PTR _parent_window$1$[ebp]
	movups	XMMWORD PTR _rect_to_avoid$69[ebp], xmm0
	test	esi, esi
	je	$LN70@Begin
	cmp	BYTE PTR [esi+284], 0
	je	$LN68@Begin
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	mov	edx, DWORD PTR [esi+8]
	mov	ecx, edx
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	and	ecx, 1
	je	SHORT $LN394@Begin
	xorps	xmm1, xmm1
	jmp	SHORT $LN395@Begin
$LN394@Begin:
	movss	xmm0, DWORD PTR [eax+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm1, DWORD PTR [eax+6176]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm0, xmm0

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm1, DWORD PTR [esi+620]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm1, xmm0
$LN395@Begin:

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	test	edx, 1024				; 00000400H
	je	SHORT $LN400@Begin
	movss	xmm0, DWORD PTR [eax+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm3, DWORD PTR [eax+6176]

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	addss	xmm0, xmm0

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm3, DWORD PTR [esi+620]

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	addss	xmm3, xmm0
	jmp	SHORT $LN401@Begin
$LN400@Begin:
	xorps	xmm3, xmm3
$LN401@Begin:
	test	ecx, ecx

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	je	SHORT $LN406@Begin
	xorps	xmm2, xmm2
	jmp	SHORT $LN407@Begin
$LN406@Begin:
	movss	xmm0, DWORD PTR [eax+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm2, DWORD PTR [eax+6176]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm0, xmm0

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm2, DWORD PTR [esi+620]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm2, xmm0
$LN407@Begin:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4997 :                 rect_to_avoid = ImRect(-FLT_MAX, parent_window->Pos.y + parent_window->TitleBarHeight(), FLT_MAX, parent_window->Pos.y + parent_window->TitleBarHeight() + parent_window->MenuBarHeight());

	addss	xmm1, DWORD PTR [esi+28]
	addss	xmm2, DWORD PTR [esi+28]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T68[ebp], -8388609		; ff7fffffH
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5000 :             window->PosFloat = FindBestPopupWindowPos(window->PosFloat, window->Size, &window->AutoPosLastDirection, rect_to_avoid);

	lea	esi, DWORD PTR [edi+16]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T68[ebp+8], 2139095039	; 7f7fffffH
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4997 :                 rect_to_avoid = ImRect(-FLT_MAX, parent_window->Pos.y + parent_window->TitleBarHeight(), FLT_MAX, parent_window->Pos.y + parent_window->TitleBarHeight() + parent_window->MenuBarHeight());

	addss	xmm1, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T68[ebp+4], xmm2
	movss	DWORD PTR $T68[ebp+12], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4999 :                 rect_to_avoid = ImRect(parent_window->Pos.x + style.ItemSpacing.x, -FLT_MAX, parent_window->Pos.x + parent_window->Size.x - style.ItemSpacing.x - parent_window->ScrollbarSizes.x, FLT_MAX); // We want some overlap to convey the relative depth of each popup (here hard-coded to 4)

	movups	xmm0, XMMWORD PTR $T67[ebp]
	movups	XMMWORD PTR _rect_to_avoid$69[ebp], xmm0

; 5000 :             window->PosFloat = FindBestPopupWindowPos(window->PosFloat, window->Size, &window->AutoPosLastDirection, rect_to_avoid);

	jmp	$LN1031@Begin
$LN68@Begin:

; 4999 :                 rect_to_avoid = ImRect(parent_window->Pos.x + style.ItemSpacing.x, -FLT_MAX, parent_window->Pos.x + parent_window->Size.x - style.ItemSpacing.x - parent_window->ScrollbarSizes.x, FLT_MAX); // We want some overlap to convey the relative depth of each popup (here hard-coded to 4)

	mov	eax, DWORD PTR _style$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T67[ebp+4], -8388609		; ff7fffffH
	mov	DWORD PTR $T67[ebp+12], 2139095039	; 7f7fffffH
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4999 :                 rect_to_avoid = ImRect(parent_window->Pos.x + style.ItemSpacing.x, -FLT_MAX, parent_window->Pos.x + parent_window->Size.x - style.ItemSpacing.x - parent_window->ScrollbarSizes.x, FLT_MAX); // We want some overlap to convey the relative depth of each popup (here hard-coded to 4)

	movss	xmm0, DWORD PTR [eax+48]
	addss	xmm0, DWORD PTR [esi+24]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T67[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4999 :                 rect_to_avoid = ImRect(parent_window->Pos.x + style.ItemSpacing.x, -FLT_MAX, parent_window->Pos.x + parent_window->Size.x - style.ItemSpacing.x - parent_window->ScrollbarSizes.x, FLT_MAX); // We want some overlap to convey the relative depth of each popup (here hard-coded to 4)

	movss	xmm0, DWORD PTR [esi+32]
	addss	xmm0, DWORD PTR [esi+24]
	subss	xmm0, DWORD PTR [eax+48]
	subss	xmm0, DWORD PTR [esi+120]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T67[ebp+8], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4999 :                 rect_to_avoid = ImRect(parent_window->Pos.x + style.ItemSpacing.x, -FLT_MAX, parent_window->Pos.x + parent_window->Size.x - style.ItemSpacing.x - parent_window->ScrollbarSizes.x, FLT_MAX); // We want some overlap to convey the relative depth of each popup (here hard-coded to 4)

	movups	xmm0, XMMWORD PTR $T67[ebp]
	movups	XMMWORD PTR _rect_to_avoid$69[ebp], xmm0
$LN70@Begin:

; 5000 :             window->PosFloat = FindBestPopupWindowPos(window->PosFloat, window->Size, &window->AutoPosLastDirection, rect_to_avoid);

	lea	esi, DWORD PTR [edi+16]
	jmp	SHORT $LN1031@Begin
$LN66@Begin:
	cmp	DWORD PTR tv7601[ebp], 0

; 5001 :         }
; 5002 :         else if ((flags & ImGuiWindowFlags_Popup) != 0 && !window_pos_set_by_api && window_appearing_after_being_hidden)

	je	SHORT $LN1022@Begin
	mov	al, BYTE PTR _window_pos_set_by_api$1$[ebp]
	test	al, al
	jne	SHORT $LN71@Begin
	cmp	DWORD PTR tv7613[ebp], 1
	jne	SHORT $LN71@Begin

; 5004 :             ImRect rect_to_avoid(window->PosFloat.x - 1, window->PosFloat.y - 1, window->PosFloat.x + 1, window->PosFloat.y + 1);

	movss	xmm2, DWORD PTR [edi+16]
	lea	esi, DWORD PTR [edi+16]
	movss	xmm1, DWORD PTR [edi+20]
	movaps	xmm0, xmm2
	subss	xmm0, xmm3
	addss	xmm2, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _rect_to_avoid$66[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5004 :             ImRect rect_to_avoid(window->PosFloat.x - 1, window->PosFloat.y - 1, window->PosFloat.x + 1, window->PosFloat.y + 1);

	movaps	xmm0, xmm1
	subss	xmm0, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _rect_to_avoid$66[ebp+8], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5004 :             ImRect rect_to_avoid(window->PosFloat.x - 1, window->PosFloat.y - 1, window->PosFloat.x + 1, window->PosFloat.y + 1);

	addss	xmm1, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _rect_to_avoid$66[ebp+4], xmm0
	movss	DWORD PTR _rect_to_avoid$66[ebp+12], xmm1
$LN1031@Begin:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5005 :             window->PosFloat = FindBestPopupWindowPos(window->PosFloat, window->Size, &window->AutoPosLastDirection, rect_to_avoid);

	lea	eax, DWORD PTR _rect_to_avoid$66[ebp]
	push	eax
	lea	eax, DWORD PTR [edi+168]
	push	eax
	lea	eax, DWORD PTR [edi+32]
	push	eax
	lea	eax, DWORD PTR $T75[ebp]
	push	esi
	push	eax
	call	?FindBestPopupWindowPos@@YA?AUImVec2@@ABU1@0PAHABUImRect@@@Z ; FindBestPopupWindowPos
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi], ecx
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], eax
	mov	esi, DWORD PTR _g$1$[ebp]
$LN1022@Begin:
	mov	al, BYTE PTR _window_pos_set_by_api$1$[ebp]
$LN71@Begin:
	cmp	DWORD PTR tv7543[ebp], 0

; 5006 :         }
; 5007 : 
; 5008 :         // Position tooltip (always follows mouse)
; 5009 :         if ((flags & ImGuiWindowFlags_Tooltip) != 0 && !window_pos_set_by_api)

	movss	xmm5, DWORD PTR __real@41800000
	je	$LN73@Begin
	test	al, al
	jne	$LN73@Begin

; 5010 :         {
; 5011 :             ImVec2 ref_pos = (!g.NavDisableHighlight && g.NavDisableMouseHover) ? NavCalcPreferredMousePos() : g.IO.MousePos;

	cmp	BYTE PTR [esi+6454], al
	jne	SHORT $LN155@Begin
	cmp	BYTE PTR [esi+6455], al
	je	SHORT $LN155@Begin
	lea	eax, DWORD PTR $T58[ebp]
	push	eax
	call	?NavCalcPreferredMousePos@@YA?AUImVec2@@XZ ; NavCalcPreferredMousePos
	add	esp, 4
	mov	ecx, eax
	jmp	SHORT $LN156@Begin
$LN155@Begin:
	mov	eax, DWORD PTR [esi+208]
	lea	ecx, DWORD PTR $T57[ebp]
	mov	DWORD PTR $T57[ebp], eax
	mov	eax, DWORD PTR [esi+212]
	mov	DWORD PTR $T57[ebp+4], eax
$LN156@Begin:
	mov	eax, DWORD PTR [ecx]

; 5013 :             window->PosFloat = FindBestPopupWindowPos(ref_pos, window->Size, &window->AutoPosLastDirection, rect_to_avoid);

	lea	esi, DWORD PTR [edi+168]
	mov	DWORD PTR _ref_pos$74[ebp], eax
	movss	xmm0, DWORD PTR _ref_pos$74[ebp]
	mov	eax, DWORD PTR [ecx+4]
	subss	xmm0, xmm5
	mov	DWORD PTR _ref_pos$74[ebp+4], eax
	lea	eax, DWORD PTR _rect_to_avoid$65[ebp]
	push	eax
	push	esi
	lea	eax, DWORD PTR [edi+32]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _rect_to_avoid$65[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5012 :             ImRect rect_to_avoid(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 24, ref_pos.y + 24); // FIXME: Completely hard-coded. Perhaps center on cursor hit-point instead?

	movss	xmm0, DWORD PTR _ref_pos$74[ebp+4]
	subss	xmm0, DWORD PTR __real@41000000

; 5013 :             window->PosFloat = FindBestPopupWindowPos(ref_pos, window->Size, &window->AutoPosLastDirection, rect_to_avoid);

	push	eax
	lea	eax, DWORD PTR _ref_pos$74[ebp]
	push	eax
	lea	eax, DWORD PTR $T39[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _rect_to_avoid$65[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5012 :             ImRect rect_to_avoid(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 24, ref_pos.y + 24); // FIXME: Completely hard-coded. Perhaps center on cursor hit-point instead?

	movss	xmm0, DWORD PTR _ref_pos$74[ebp]
	addss	xmm0, DWORD PTR __real@41c00000

; 5013 :             window->PosFloat = FindBestPopupWindowPos(ref_pos, window->Size, &window->AutoPosLastDirection, rect_to_avoid);

	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _rect_to_avoid$65[ebp+8], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5012 :             ImRect rect_to_avoid(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 24, ref_pos.y + 24); // FIXME: Completely hard-coded. Perhaps center on cursor hit-point instead?

	movss	xmm0, DWORD PTR _ref_pos$74[ebp+4]
	addss	xmm0, DWORD PTR __real@41c00000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _rect_to_avoid$65[ebp+12], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5013 :             window->PosFloat = FindBestPopupWindowPos(ref_pos, window->Size, &window->AutoPosLastDirection, rect_to_avoid);

	call	?FindBestPopupWindowPos@@YA?AUImVec2@@ABU1@0PAHABUImRect@@@Z ; FindBestPopupWindowPos
	movss	xmm5, DWORD PTR __real@41800000
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edi+16], ecx
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+20], eax

; 5014 :             if (window->AutoPosLastDirection == -1)

	cmp	DWORD PTR [esi], -1
	jne	SHORT $LN73@Begin
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR _ref_pos$74[ebp]
	addss	xmm0, DWORD PTR __real@40000000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T56[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR _ref_pos$74[ebp+4]
	addss	xmm0, DWORD PTR __real@40000000
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5015 :                 window->PosFloat = ref_pos + ImVec2(2,2); // If there's not enough room, for tooltip we prefer avoiding the cursor at all cost even if it means that part of the tooltip won't be visible.

	mov	eax, DWORD PTR $T56[ebp]
	mov	DWORD PTR [edi+16], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T56[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5015 :                 window->PosFloat = ref_pos + ImVec2(2,2); // If there's not enough room, for tooltip we prefer avoiding the cursor at all cost even if it means that part of the tooltip won't be visible.

	mov	eax, DWORD PTR $T56[ebp+4]
	mov	DWORD PTR [edi+20], eax
$LN73@Begin:

; 5016 :         }
; 5017 : 
; 5018 :         // Clamp position so it stays visible
; 5019 :         if (!(flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Tooltip))
; 5020 :         {
; 5021 :             if (!window_pos_set_by_api && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && g.IO.DisplaySize.x > 0.0f && g.IO.DisplaySize.y > 0.0f) // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.

	mov	edx, DWORD PTR _flags$1$[ebp]
	xorps	xmm4, xmm4
	mov	esi, DWORD PTR _g$1$[ebp]
	mov	eax, edx
	and	eax, 20971520				; 01400000H
	mov	DWORD PTR tv7522[ebp], eax
	jne	$LN75@Begin
	cmp	BYTE PTR _window_pos_set_by_api$1$[ebp], 0
	jne	$LN75@Begin
	cmp	DWORD PTR [edi+152], 0
	jg	$LN75@Begin
	cmp	DWORD PTR [edi+156], 0
	jg	$LN75@Begin
	movss	xmm0, DWORD PTR [esi+4]
	comiss	xmm0, xmm4
	jbe	$LN75@Begin
	movss	xmm0, DWORD PTR [esi+8]
	comiss	xmm0, xmm4
	jbe	$LN75@Begin
	movss	xmm2, DWORD PTR [esi+5424]
	maxss	xmm2, DWORD PTR [esi+5432]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm1, DWORD PTR [edi+16]
	addss	xmm1, DWORD PTR [edi+32]
	movss	xmm0, DWORD PTR [edi+20]
	addss	xmm0, DWORD PTR [edi+36]
	movss	xmm3, DWORD PTR [esi+5428]
	maxss	xmm3, DWORD PTR [esi+5436]
	maxss	xmm1, xmm2
	maxss	xmm0, xmm3

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm1, DWORD PTR [edi+32]
	subss	xmm0, DWORD PTR [edi+36]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T55[ebp], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5024 :                 window->PosFloat = ImMax(window->PosFloat + window->Size, padding) - window->Size;

	mov	eax, DWORD PTR $T55[ebp]
	mov	DWORD PTR [edi+16], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T55[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5024 :                 window->PosFloat = ImMax(window->PosFloat + window->Size, padding) - window->Size;

	mov	eax, DWORD PTR $T55[ebp+4]
	mov	DWORD PTR [edi+20], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm1, DWORD PTR [esi+4]
	movss	xmm0, DWORD PTR [edi+16]
	subss	xmm1, xmm2
	movss	xmm2, DWORD PTR [esi+8]
	subss	xmm2, xmm3
	minss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T54[ebp], xmm0
	movss	xmm0, DWORD PTR [edi+20]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5025 :                 window->PosFloat = ImMin(window->PosFloat, g.IO.DisplaySize - padding);

	mov	eax, DWORD PTR $T54[ebp]
	minss	xmm0, xmm2
	mov	DWORD PTR [edi+16], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T54[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5025 :                 window->PosFloat = ImMin(window->PosFloat, g.IO.DisplaySize - padding);

	mov	eax, DWORD PTR $T54[ebp+4]
	mov	DWORD PTR [edi+20], eax
$LN75@Begin:

; 5028 :         window->Pos = ImVec2((float)(int)window->PosFloat.x, (float)(int)window->PosFloat.y);

	cvttss2si eax, DWORD PTR [edi+16]
	movd	xmm0, eax
	cvttss2si eax, DWORD PTR [edi+20]
	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T53[ebp], xmm0
	movd	xmm0, eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5028 :         window->Pos = ImVec2((float)(int)window->PosFloat.x, (float)(int)window->PosFloat.y);

	mov	eax, DWORD PTR $T53[ebp]
	cvtdq2ps xmm0, xmm0
	mov	DWORD PTR [edi+24], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T53[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5028 :         window->Pos = ImVec2((float)(int)window->PosFloat.x, (float)(int)window->PosFloat.y);

	mov	eax, DWORD PTR $T53[ebp+4]
	mov	DWORD PTR [edi+28], eax

; 5029 : 
; 5030 :         // Default item width. Make it proportional to window size if window manually resizes
; 5031 :         if (window->Size.x > 0.0f && !(flags & ImGuiWindowFlags_Tooltip) && !(flags & ImGuiWindowFlags_AlwaysAutoResize))

	movss	xmm0, DWORD PTR [edi+32]
	comiss	xmm0, xmm4
	jbe	SHORT $LN76@Begin
	test	edx, 16777280				; 01000040H
	jne	SHORT $LN76@Begin

; 5032 :             window->ItemWidthDefault = (float)(int)(window->Size.x * 0.65f);

	mulss	xmm0, DWORD PTR __real@3f266666

; 5033 :         else

	jmp	SHORT $LN1028@Begin
$LN76@Begin:

; 5034 :             window->ItemWidthDefault = (float)(int)(g.FontSize * 16.0f);

	movss	xmm0, DWORD PTR [esi+6172]
	mulss	xmm0, xmm5
$LN1028@Begin:
	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [edi+524], xmm0

; 5035 : 
; 5036 :         // Prepare for focus requests
; 5037 :         window->FocusIdxAllRequestCurrent = (window->FocusIdxAllRequestNext == INT_MAX || window->FocusIdxAllCounter == -1) ? INT_MAX : (window->FocusIdxAllRequestNext + (window->FocusIdxAllCounter+1)) % (window->FocusIdxAllCounter+1);

	mov	eax, DWORD PTR [edi+660]
	cmp	eax, 2147483647				; 7fffffffH
	je	SHORT $LN157@Begin
	mov	ecx, DWORD PTR [edi+644]
	cmp	ecx, -1
	je	SHORT $LN157@Begin
	inc	eax
	add	eax, ecx
	inc	ecx
	cdq
	idiv	ecx
	jmp	SHORT $LN158@Begin
$LN157@Begin:
	mov	edx, 2147483647				; 7fffffffH
$LN158@Begin:
	mov	DWORD PTR [edi+652], edx

; 5038 :         window->FocusIdxTabRequestCurrent = (window->FocusIdxTabRequestNext == INT_MAX || window->FocusIdxTabCounter == -1) ? INT_MAX : (window->FocusIdxTabRequestNext + (window->FocusIdxTabCounter+1)) % (window->FocusIdxTabCounter+1);

	mov	eax, DWORD PTR [edi+664]
	cmp	eax, 2147483647				; 7fffffffH
	je	SHORT $LN159@Begin
	mov	ecx, DWORD PTR [edi+648]
	cmp	ecx, -1
	je	SHORT $LN159@Begin
	inc	eax
	add	eax, ecx
	inc	ecx
	cdq
	idiv	ecx
	jmp	SHORT $LN160@Begin
$LN159@Begin:
	mov	edx, 2147483647				; 7fffffffH
$LN160@Begin:
	mov	DWORD PTR [edi+656], edx

; 5039 :         window->FocusIdxAllCounter = window->FocusIdxTabCounter = -1;
; 5040 :         window->FocusIdxAllRequestNext = window->FocusIdxTabRequestNext = INT_MAX;
; 5041 : 
; 5042 :         // Apply scrolling
; 5043 :         window->Scroll = CalcNextScrollFromScrollTargetAndClamp(window);

	lea	eax, DWORD PTR $T52[ebp]
	mov	DWORD PTR [edi+648], -1
	mov	DWORD PTR [edi+644], -1
	push	edi
	mov	DWORD PTR [edi+664], 2147483647		; 7fffffffH
	push	eax
	mov	DWORD PTR [edi+660], 2147483647		; 7fffffffH
	call	?CalcNextScrollFromScrollTargetAndClamp@@YA?AUImVec2@@PAUImGuiWindow@@@Z ; CalcNextScrollFromScrollTargetAndClamp
	add	esp, 8
	cmp	DWORD PTR tv7526[ebp], 0
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edi+92], ecx
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+96], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T51[ebp], 2139095039		; 7f7fffffH
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5044 :         window->ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);

	mov	eax, DWORD PTR $T51[ebp]
	mov	DWORD PTR [edi+100], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T51[ebp+4], 2139095039	; 7f7fffffH
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5044 :         window->ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);

	mov	eax, DWORD PTR $T51[ebp+4]
	mov	DWORD PTR [edi+104], eax

; 5045 : 
; 5046 :         // Modal window darkens what is behind them
; 5047 :         if ((flags & ImGuiWindowFlags_Modal) != 0 && window == GetFrontMostModalRootWindow())

	je	SHORT $LN78@Begin
	call	?GetFrontMostModalRootWindow@@YAPAUImGuiWindow@@XZ ; GetFrontMostModalRootWindow
	cmp	edi, eax
	jne	SHORT $LN78@Begin

; 5048 :             window->DrawList->AddRectFilled(fullscreen_rect.Min, fullscreen_rect.Max, GetColorU32(ImGuiCol_ModalWindowDarkening, g.ModalWindowDarkeningRatio));

	movss	xmm0, DWORD PTR [esi+6652]
	push	-1
	sub	esp, 8
	mov	DWORD PTR [esp+4], 0
	movss	DWORD PTR [esp], xmm0
	push	42					; 0000002aH
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	ecx, DWORD PTR [edi+624]
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR _fullscreen_rect$33[ebp+8]
	push	eax
	lea	eax, DWORD PTR _fullscreen_rect$33[ebp]
	push	eax
	call	?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
$LN78@Begin:

; 5049 : 
; 5050 :         // Navigation windowing (via ImGuiKey_NavWindowing key) shows whole window selected
; 5051 :         if (g.NavWindowingTarget == window)

	cmp	DWORD PTR [esi+6432], edi
	jne	$LN79@Begin
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 773  :     ImRect      Rect() const                            { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }

	movss	xmm1, DWORD PTR [edi+24]
	movss	xmm4, DWORD PTR [edi+28]
	movaps	xmm2, xmm1
	movss	xmm3, DWORD PTR [edi+36]
	addss	xmm2, DWORD PTR [edi+32]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5054 :             bb.Expand(g.FontSize);

	movss	xmm0, DWORD PTR [esi+6172]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 773  :     ImRect      Rect() const                            { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }

	addss	xmm3, xmm4
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5055 :             window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_NavWindowingHighlight, g.NavWindowingDisplayAlpha), g.Style.WindowRounding);

	push	-1
	sub	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 257  :     void        Expand(const float amount)      { Min.x -= amount;   Min.y -= amount;   Max.x += amount;   Max.y += amount; }

	subss	xmm1, xmm0
	subss	xmm4, xmm0
	addss	xmm2, xmm0
	addss	xmm3, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5055 :             window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_NavWindowingHighlight, g.NavWindowingDisplayAlpha), g.Style.WindowRounding);

	movss	xmm0, DWORD PTR [esi+5340]
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR [esi+6436]
	movss	DWORD PTR [esp], xmm0
	push	44					; 0000002cH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 257  :     void        Expand(const float amount)      { Min.x -= amount;   Min.y -= amount;   Max.x += amount;   Max.y += amount; }

	movss	DWORD PTR _bb$64[ebp], xmm1
	movss	DWORD PTR _bb$64[ebp+4], xmm4
	movss	DWORD PTR _bb$64[ebp+8], xmm2
	movss	DWORD PTR _bb$64[ebp+12], xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5055 :             window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_NavWindowingHighlight, g.NavWindowingDisplayAlpha), g.Style.WindowRounding);

	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	ecx, DWORD PTR [edi+624]
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR _bb$64[ebp+8]
	push	eax
	lea	eax, DWORD PTR _bb$64[ebp]
	push	eax
	call	?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled

; 5056 :             window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_HeaderHovered, g.NavWindowingDisplayAlpha), g.Style.WindowRounding);

	movss	xmm0, DWORD PTR [esi+5340]
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	-1
	sub	esp, 8
	movss	DWORD PTR [esp+4], xmm0
	movss	xmm0, DWORD PTR [esi+6436]
	movss	DWORD PTR [esp], xmm0
	push	26					; 0000001aH
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	ecx, DWORD PTR [edi+624]
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR _bb$64[ebp+8]
	push	eax
	lea	eax, DWORD PTR _bb$64[ebp]
	push	eax
	call	?AddRect@ImDrawList@@QAEXABUImVec2@@0IMHM@Z ; ImDrawList::AddRect
$LN79@Begin:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	test	BYTE PTR [edi+8], 1
	je	SHORT $LN506@Begin
	xorps	xmm1, xmm1
	jmp	SHORT $LN507@Begin
$LN506@Begin:
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	movss	xmm0, DWORD PTR [eax+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm1, DWORD PTR [eax+6176]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm0, xmm0

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm1, DWORD PTR [edi+620]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm1, xmm0
$LN507@Begin:
	cmp	DWORD PTR tv7534[ebp], 0

; 776  :     ImRect      TitleBarRect() const                    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }

	lea	ecx, DWORD PTR [edi+24]
	movss	xmm2, DWORD PTR [ecx]
	movss	xmm3, DWORD PTR [edi+28]
	movaps	xmm0, xmm2
	addss	xmm0, DWORD PTR [edi+40]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _title_bar_rect$2$[ebp], eax
	mov	DWORD PTR _title_bar_rect$63[ebp], eax
	mov	eax, DWORD PTR [ecx+4]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T95[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 776  :     ImRect      TitleBarRect() const                    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }

	movaps	xmm0, xmm3
	addss	xmm0, xmm1

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _title_bar_rect$3$[ebp], eax
	mov	DWORD PTR _title_bar_rect$63[ebp+4], eax
	mov	eax, DWORD PTR $T95[ebp]
	mov	DWORD PTR _title_bar_rect$4$[ebp], eax
	mov	DWORD PTR _title_bar_rect$63[ebp+8], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T95[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T95[ebp+4]
	mov	DWORD PTR _title_bar_rect$5$[ebp], eax
	mov	DWORD PTR _title_bar_rect$63[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5061 :         const float window_rounding = (flags & ImGuiWindowFlags_ChildWindow) ? style.ChildWindowRounding : style.WindowRounding;

	je	SHORT $LN161@Begin
	movss	xmm5, DWORD PTR [esi+5352]
	jmp	SHORT $LN1029@Begin
$LN161@Begin:
	movss	xmm5, DWORD PTR [esi+5340]
$LN1029@Begin:

; 5062 :         if (window->Collapsed)

	cmp	BYTE PTR [edi+135], 0
	movss	DWORD PTR _window_rounding$1$[ebp], xmm5
	je	SHORT $LN80@Begin

; 5063 :         {
; 5064 :             // Title bar only
; 5065 :             const bool is_focused = g.NavWindow && window->RootNonPopupWindow == g.NavWindow->RootNonPopupWindow && !g.NavDisableHighlight;

	mov	ecx, DWORD PTR [esi+6380]
	test	ecx, ecx
	je	SHORT $LN163@Begin
	mov	eax, DWORD PTR [edi+636]
	cmp	eax, DWORD PTR [ecx+636]
	jne	SHORT $LN163@Begin
	cmp	BYTE PTR [esi+6454], 0
	jne	SHORT $LN163@Begin
	mov	cl, 1
	jmp	SHORT $LN164@Begin
$LN163@Begin:
	xor	cl, cl
$LN164@Begin:

; 5066 :             RenderFrame(title_bar_rect.GetTL(), title_bar_rect.GetBR(),  GetColorU32(is_focused ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBgCollapsed), true, window_rounding);

	push	ecx
	xor	eax, eax
	movss	DWORD PTR [esp], xmm5
	test	cl, cl
	push	1
	push	ecx
	setne	al
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	add	eax, 11					; 0000000bH
	push	eax
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR $T95[ebp+4]
	push	eax
	mov	eax, DWORD PTR $T95[ebp]
	push	eax
	push	DWORD PTR [edi+28]
	push	DWORD PTR [edi+24]
	call	?RenderFrame@ImGui@@YAXUImVec2@@0I_NM@Z	; ImGui::RenderFrame
	add	esp, 28					; 0000001cH

; 5067 :         }
; 5068 :         else

	jmp	$LN110@Begin
$LN80@Begin:

; 5069 :         {
; 5070 :             ImU32 resize_col = 0;
; 5071 :             const float resize_corner_size = ImMax(g.FontSize * 1.35f, window_rounding + 1.0f + g.FontSize * 0.2f);

	movss	xmm0, DWORD PTR [esi+6172]
	movss	xmm6, DWORD PTR __real@3f800000
	movaps	xmm4, xmm0
	mulss	xmm4, DWORD PTR __real@3e4ccccd

; 5072 :             if (!(flags & ImGuiWindowFlags_AlwaysAutoResize) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && !(flags & ImGuiWindowFlags_NoResize))

	mov	edx, DWORD PTR _flags$1$[ebp]
	mulss	xmm0, DWORD PTR __real@3faccccd
	mov	DWORD PTR _resize_col$1$[ebp], 0
	addss	xmm4, xmm5
	addss	xmm4, xmm6
	maxss	xmm4, xmm0
	movss	DWORD PTR $T20$sroa$2251$1$[ebp], xmm4
	test	dl, 64					; 00000040H
	jne	$LN82@Begin
	cmp	DWORD PTR [edi+152], 0
	jg	$LN82@Begin
	cmp	DWORD PTR [edi+156], 0
	jg	$LN82@Begin
	test	dl, 2
	jne	$LN82@Begin
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 773  :     ImRect      Rect() const                            { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }

	addss	xmm2, DWORD PTR [edi+32]
	movss	xmm1, DWORD PTR [edi+36]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5076 :                 const ImRect resize_rect(br - ImVec2(resize_corner_size * 0.75f, resize_corner_size * 0.75f), br);

	movaps	xmm0, xmm4
	mulss	xmm0, DWORD PTR __real@3f400000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 773  :     ImRect      Rect() const                            { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }

	addss	xmm1, xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5077 :                 const ImGuiID resize_id = window->GetID("#RESIZE");

	push	0
	push	OFFSET $SG118260
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T42[ebp+8], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5077 :                 const ImGuiID resize_id = window->GetID("#RESIZE");

	mov	ecx, edi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm2, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T42[ebp+12], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm1, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T104[ebp], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T104[ebp]
	mov	DWORD PTR _resize_rect$62[ebp], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T104[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T104[ebp+4]
	mov	DWORD PTR _resize_rect$62[ebp+4], eax
	mov	eax, DWORD PTR $T42[ebp+8]
	mov	DWORD PTR _resize_rect$62[ebp+8], eax
	mov	eax, DWORD PTR $T42[ebp+12]
	mov	DWORD PTR _resize_rect$62[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5077 :                 const ImGuiID resize_id = window->GetID("#RESIZE");

	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID

; 5078 :                 bool hovered, held;
; 5079 :                 ButtonBehavior(resize_rect, resize_id, &hovered, &held, ImGuiButtonFlags_FlattenChilds | ImGuiButtonFlags_NoNavOverride);

	push	2080					; 00000820H
	lea	ecx, DWORD PTR _held$107[ebp]
	push	ecx
	lea	ecx, DWORD PTR _hovered$84[ebp]
	push	ecx
	push	eax
	lea	eax, DWORD PTR _resize_rect$62[ebp]
	push	eax
	call	?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z ; ImGui::ButtonBehavior

; 5080 :                 if (hovered || held)

	mov	al, BYTE PTR _held$107[ebp]
	add	esp, 20					; 00000014H
	cmp	BYTE PTR _hovered$84[ebp], 0
	mov	BYTE PTR _held$1$[ebp], al
	jne	SHORT $LN84@Begin
	test	al, al
	je	SHORT $LN83@Begin
$LN84@Begin:

; 5081 :                     g.MouseCursor = ImGuiMouseCursor_ResizeNWSE;

	mov	DWORD PTR [esi+6764], 6
$LN83@Begin:
	xorps	xmm0, xmm0
	xorps	xmm3, xmm3
	xorps	xmm2, xmm2

; 5082 : 
; 5083 :                 ImVec2 nav_resize_delta(0.0f, 0.0f);
; 5084 :                 if (g.NavWindowingTarget == window)

	cmp	DWORD PTR [esi+6432], edi
	jne	$LN86@Begin

; 5085 :                 {
; 5086 :                     nav_resize_delta = GetNavInputAmount2d(0, ImGuiNavReadMode_Down);

	sub	esp, 8
	lea	eax, DWORD PTR $T50[ebp]
	mov	DWORD PTR [esp+4], 0
	mov	DWORD PTR [esp], 0
	push	0
	push	0
	push	eax
	call	?GetNavInputAmount2d@@YA?AUImVec2@@HW4ImGuiNavReadMode@@MM@Z ; GetNavInputAmount2d
	add	esp, 20					; 00000014H
	xorps	xmm0, xmm0
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _nav_resize_delta$103[ebp], ecx

; 5087 :                     if (nav_resize_delta.x != 0.0f || nav_resize_delta.y != 0.0f)

	movss	xmm3, DWORD PTR _nav_resize_delta$103[ebp]
	ucomiss	xmm3, xmm0
	mov	DWORD PTR _nav_resize_delta$103[ebp+4], eax
	movss	xmm2, DWORD PTR _nav_resize_delta$103[ebp+4]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN87@Begin
	ucomiss	xmm2, xmm0
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN1016@Begin
$LN87@Begin:
	movss	xmm1, DWORD PTR [esi+152]

; 5088 :                     {
; 5089 :                         nav_resize_delta *= ImFloor(600 * g.IO.DeltaTime * ImMin(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y));

	movss	xmm0, DWORD PTR [esi+12]
	mulss	xmm0, DWORD PTR __real@44160000

; 5090 :                         g.NavDisableMouseHover = true;

	mov	BYTE PTR [esi+6455], 1
	minss	xmm1, DWORD PTR [esi+148]
	mulss	xmm1, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 140  : static inline float  ImFloor(float f)                                           { return (float)(int)f; }

	cvttss2si eax, xmm1
	movd	xmm0, eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5091 :                         held = true; // For coloring

	mov	al, 1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 140  : static inline float  ImFloor(float f)                                           { return (float)(int)f; }

	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5091 :                         held = true; // For coloring

	mov	BYTE PTR _held$1$[ebp], al
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 120  : static inline ImVec2& operator*=(ImVec2& lhs, const float rhs)                  { lhs.x *= rhs; lhs.y *= rhs; return lhs; }

	mulss	xmm3, xmm0
	mulss	xmm2, xmm0
	xorps	xmm0, xmm0
	jmp	SHORT $LN86@Begin
$LN1016@Begin:
	mov	al, BYTE PTR _held$1$[ebp]
$LN86@Begin:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5096 :                 if (g.HoveredWindow == window && held && g.IO.MouseDoubleClicked[0])

	cmp	DWORD PTR [esi+6244], edi
	jne	SHORT $LN88@Begin
	test	al, al
	je	SHORT $LN88@Begin
	cmp	BYTE PTR [esi+956], 0
	je	SHORT $LN88@Begin

; 5097 :                 {
; 5098 :                     // Manual auto-fit when double-clicking
; 5099 :                     size_target = size_auto_fit;
; 5100 :                     ClearActiveID();

	movss	xmm0, DWORD PTR _size_auto_fit$3$[ebp]
	movss	DWORD PTR _size_target$102[ebp], xmm0
	movss	xmm0, DWORD PTR _size_auto_fit$2$[ebp]
	movss	DWORD PTR _size_target$102[ebp+4], xmm0
	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
	mov	ecx, DWORD PTR _size_target$102[ebp+4]
	mov	edx, DWORD PTR _size_target$102[ebp]
	jmp	$LN93@Begin
$LN88@Begin:

; 5101 :                 }
; 5102 :                 else if (nav_resize_delta.x != 0.0f || nav_resize_delta.y != 0.0f)

	ucomiss	xmm3, xmm0
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN92@Begin
	ucomiss	xmm2, xmm0
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN92@Begin

; 5107 :                 }
; 5108 :                 else if (held)

	test	al, al
	je	$LN165@Begin
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 245  :     ImVec2      GetSize() const                 { return ImVec2(Max.x-Min.x, Max.y-Min.y); }

	movss	xmm3, DWORD PTR _resize_rect$62[ebp+8]
	movss	xmm2, DWORD PTR _resize_rect$62[ebp+12]

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [esi+208]
	movss	xmm1, DWORD PTR [esi+212]

; 245  :     ImVec2      GetSize() const                 { return ImVec2(Max.x-Min.x, Max.y-Min.y); }

	subss	xmm3, DWORD PTR _resize_rect$62[ebp]

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm1, DWORD PTR [esi+6284]

; 245  :     ImVec2      GetSize() const                 { return ImVec2(Max.x-Min.x, Max.y-Min.y); }

	subss	xmm2, DWORD PTR _resize_rect$62[ebp+4]

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm0, DWORD PTR [esi+6280]

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm1, xmm2
	addss	xmm3, xmm0

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm1, DWORD PTR [edi+28]
	subss	xmm3, DWORD PTR [edi+24]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T48[ebp+4], xmm1
	movss	DWORD PTR $T48[ebp], xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5111 :                     size_target = (g.IO.MousePos - g.ActiveIdClickOffset + resize_rect.GetSize()) - window->Pos;

	jmp	SHORT $LN1030@Begin
$LN92@Begin:

; 5103 :                 {
; 5104 :                     // FIXME-NAVIGATION: Should store and accumulate into a separate size buffer to handle sizing constraints properly
; 5105 :                     g.NavWindowingToggleLayer = false;

	mov	BYTE PTR [esi+6440], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [edi+40]
	addss	xmm0, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T49[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [edi+44]
	addss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T49[ebp+4], xmm0
$LN1030@Begin:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5106 :                     size_target = window->SizeFull + nav_resize_delta;

	mov	ecx, DWORD PTR $T49[ebp+4]
	mov	edx, DWORD PTR $T49[ebp]
	mov	DWORD PTR _size_target$102[ebp+4], ecx
	mov	DWORD PTR _size_target$102[ebp], edx
$LN93@Begin:

; 5112 :                 }
; 5113 : 
; 5114 :                 if (size_target.x != FLT_MAX && size_target.y != FLT_MAX)

	movss	xmm0, DWORD PTR _size_target$102[ebp]
	movss	xmm1, DWORD PTR __real@7f7fffff
	ucomiss	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN94@Begin
	movss	xmm0, DWORD PTR _size_target$102[ebp+4]
	ucomiss	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN94@Begin

; 5115 :                 {
; 5116 :                     ApplySizeFullWithConstraint(window, size_target);

	push	ecx
	push	edx
	push	edi
	call	?ApplySizeFullWithConstraint@@YAXPAUImGuiWindow@@UImVec2@@@Z ; ApplySizeFullWithConstraint

; 5117 :                     MarkIniSettingsDirty(window);

	push	edi
	call	?MarkIniSettingsDirty@@YAXPAUImGuiWindow@@@Z ; MarkIniSettingsDirty
	add	esp, 16					; 00000010H
$LN94@Begin:

; 5120 :                 resize_col = GetColorU32(held ? ImGuiCol_ResizeGripActive : hovered ? ImGuiCol_ResizeGripHovered : ImGuiCol_ResizeGrip);

	cmp	BYTE PTR _held$1$[ebp], 0
	je	SHORT $LN165@Begin
	mov	eax, 33					; 00000021H
	jmp	SHORT $LN166@Begin
$LN165@Begin:
	xor	eax, eax
	cmp	BYTE PTR _hovered$84[ebp], al
	setne	al
	add	eax, 31					; 0000001fH
$LN166@Begin:
	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	eax
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32

; 5121 :                 window->Size = window->SizeFull;

	mov	ecx, DWORD PTR [edi+40]
	add	esp, 8
	mov	DWORD PTR [edi+32], ecx
	mov	ecx, DWORD PTR [edi+44]
	mov	DWORD PTR [edi+36], ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	test	BYTE PTR [edi+8], 1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5120 :                 resize_col = GetColorU32(held ? ImGuiCol_ResizeGripActive : hovered ? ImGuiCol_ResizeGripHovered : ImGuiCol_ResizeGrip);

	mov	DWORD PTR _resize_col$1$[ebp], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	je	SHORT $LN576@Begin
	xorps	xmm1, xmm1
	jmp	SHORT $LN577@Begin
$LN576@Begin:
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	movss	xmm0, DWORD PTR [eax+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm1, DWORD PTR [eax+6176]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm0, xmm0

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm1, DWORD PTR [edi+620]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm1, xmm0
$LN577@Begin:

; 776  :     ImRect      TitleBarRect() const                    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }

	movss	xmm0, DWORD PTR [edi+40]
	lea	ecx, DWORD PTR [edi+24]
	addss	xmm0, DWORD PTR [ecx]
	addss	xmm1, DWORD PTR [edi+28]

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [ecx]
	movss	xmm5, DWORD PTR _window_rounding$1$[ebp]
	movss	xmm6, DWORD PTR __real@3f800000
	mov	edx, DWORD PTR _flags$1$[ebp]
	mov	DWORD PTR $T61[ebp], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR $T61[ebp+4], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T43[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T43[ebp]
	mov	DWORD PTR $T61[ebp+8], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T43[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T43[ebp+4]
	mov	DWORD PTR $T61[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5122 :                 title_bar_rect = window->TitleBarRect();

	movups	xmm0, XMMWORD PTR $T61[ebp]
	movups	XMMWORD PTR _title_bar_rect$63[ebp], xmm0
	mov	eax, DWORD PTR _title_bar_rect$63[ebp+12]
	mov	DWORD PTR _title_bar_rect$5$[ebp], eax
	mov	eax, DWORD PTR _title_bar_rect$63[ebp+8]
	mov	DWORD PTR _title_bar_rect$4$[ebp], eax
	mov	eax, DWORD PTR _title_bar_rect$63[ebp+4]
	mov	DWORD PTR _title_bar_rect$3$[ebp], eax
	mov	eax, DWORD PTR _title_bar_rect$63[ebp]
	mov	DWORD PTR _title_bar_rect$2$[ebp], eax
$LN82@Begin:

; 5123 :             }
; 5124 : 
; 5125 :             // Scrollbars
; 5126 :             window->ScrollbarY = (flags & ImGuiWindowFlags_AlwaysVerticalScrollbar) || ((window->SizeContents.y > window->Size.y + style.ItemSpacing.y) && !(flags & ImGuiWindowFlags_NoScrollbar));

	test	edx, 16384				; 00004000H
	jne	SHORT $LN168@Begin
	movss	xmm1, DWORD PTR [edi+36]
	addss	xmm1, DWORD PTR [esi+5372]
	movss	xmm0, DWORD PTR [edi+52]
	comiss	xmm0, xmm1
	jbe	SHORT $LN167@Begin
	test	dl, 8
	je	SHORT $LN168@Begin
$LN167@Begin:
	xor	eax, eax
	jmp	SHORT $LN169@Begin
$LN168@Begin:
	mov	eax, 1
$LN169@Begin:
	mov	BYTE PTR [edi+117], al

; 5127 :             window->ScrollbarX = (flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar) || ((window->SizeContents.x > window->Size.x - (window->ScrollbarY ? style.ScrollbarSize : 0.0f) - window->WindowPadding.x) && !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar));

	test	edx, 32768				; 00008000H
	jne	SHORT $LN173@Begin
	test	al, al
	je	SHORT $LN170@Begin
	movss	xmm0, DWORD PTR [esi+5400]
	jmp	SHORT $LN171@Begin
$LN170@Begin:
	xorps	xmm0, xmm0
$LN171@Begin:
	movss	xmm1, DWORD PTR [edi+32]
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR [edi+48]
	subss	xmm1, DWORD PTR [edi+80]
	comiss	xmm0, xmm1
	jbe	SHORT $LN172@Begin
	mov	eax, edx
	and	eax, 2056				; 00000808H
	cmp	eax, 2048				; 00000800H
	je	SHORT $LN173@Begin
$LN172@Begin:
	xor	eax, eax
	jmp	SHORT $LN174@Begin
$LN173@Begin:
	mov	eax, 1
$LN174@Begin:
	mov	BYTE PTR [edi+116], al

; 5128 :             window->ScrollbarSizes = ImVec2(window->ScrollbarY ? style.ScrollbarSize : 0.0f, window->ScrollbarX ? style.ScrollbarSize : 0.0f);

	test	al, al
	xorps	xmm2, xmm2
	lea	eax, DWORD PTR [esi+5320]
	je	SHORT $LN175@Begin
	movss	xmm1, DWORD PTR [eax+80]
	jmp	SHORT $LN176@Begin
$LN175@Begin:
	xorps	xmm1, xmm1
$LN176@Begin:
	cmp	BYTE PTR [edi+117], 0
	je	SHORT $LN177@Begin
	movss	xmm0, DWORD PTR [eax+80]
	jmp	SHORT $LN178@Begin
$LN177@Begin:
	xorps	xmm0, xmm0
$LN178@Begin:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T35[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5128 :             window->ScrollbarSizes = ImVec2(window->ScrollbarY ? style.ScrollbarSize : 0.0f, window->ScrollbarX ? style.ScrollbarSize : 0.0f);

	mov	eax, DWORD PTR $T35[ebp]
	mov	DWORD PTR [edi+120], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T35[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5128 :             window->ScrollbarSizes = ImVec2(window->ScrollbarY ? style.ScrollbarSize : 0.0f, window->ScrollbarX ? style.ScrollbarSize : 0.0f);

	mov	eax, DWORD PTR $T35[ebp+4]
	mov	DWORD PTR [edi+124], eax

; 5129 :             window->BorderSize = (flags & ImGuiWindowFlags_ShowBorders) ? 1.0f : 0.0f;

	mov	eax, edx
	and	eax, 128				; 00000080H
	mov	DWORD PTR tv7507[ebp], eax
	je	SHORT $LN179@Begin
	movaps	xmm0, xmm6
	jmp	SHORT $LN180@Begin
$LN179@Begin:
	xorps	xmm0, xmm0
$LN180@Begin:
	movss	DWORD PTR [edi+128], xmm0

; 5130 : 
; 5131 :             // Window background, Default Alpha
; 5132 :             ImGuiCol bg_color_idx = ImGuiCol_WindowBg;

	mov	eax, 2

; 5133 :             if ((flags & ImGuiWindowFlags_ComboBox) != 0)

	test	edx, 8388608				; 00800000H
	je	SHORT $LN95@Begin

; 5134 :                 bg_color_idx = ImGuiCol_ComboBg;

	mov	eax, 18					; 00000012H
	jmp	SHORT $LN100@Begin
$LN95@Begin:
	cmp	DWORD PTR tv7547[ebp], 0

; 5135 :             else if ((flags & ImGuiWindowFlags_Tooltip) != 0 || (flags & ImGuiWindowFlags_Popup) != 0)

	jne	SHORT $LN99@Begin
	cmp	DWORD PTR tv7534[ebp], 0

; 5137 :             else if ((flags & ImGuiWindowFlags_ChildWindow) != 0)

	je	SHORT $LN100@Begin

; 5138 :                 bg_color_idx = ImGuiCol_ChildWindowBg;

	mov	eax, 3
	jmp	SHORT $LN100@Begin
$LN99@Begin:

; 5136 :                 bg_color_idx = ImGuiCol_PopupBg;

	mov	eax, 4
$LN100@Begin:

; 5139 :             ImVec4 bg_color = style.Colors[bg_color_idx];
; 5140 :             if (bg_alpha >= 0.0f)

	movss	xmm1, DWORD PTR _bg_alpha$[ebp]
	add	eax, 8
	shl	eax, 4
	add	eax, DWORD PTR _style$1$[ebp]
	comiss	xmm1, xmm2
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR _bg_color$34[ebp], xmm0
	jae	SHORT $LN101@Begin

; 5141 :                 bg_color.w = bg_alpha;

	movss	xmm1, DWORD PTR _bg_color$34[ebp+12]
$LN101@Begin:

; 5142 :             bg_color.w *= style.Alpha;

	movss	xmm0, DWORD PTR [esi+5320]
	mulss	xmm0, xmm1

; 5143 :             if (bg_color.w > 0.0f)

	comiss	xmm0, xmm2
	movss	DWORD PTR _bg_color$34[ebp+12], xmm0
	jbe	$LN102@Begin
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm1, DWORD PTR [ecx+4]
	movss	xmm0, DWORD PTR [ecx]
	addss	xmm1, DWORD PTR [edi+36]
	addss	xmm0, DWORD PTR [edi+32]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T94[ebp+4], xmm1
	movss	DWORD PTR $T94[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	test	BYTE PTR [edi+8], 1
	jne	SHORT $LN593@Begin
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	movss	xmm0, DWORD PTR [eax+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm2, DWORD PTR [eax+6176]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm0, xmm0

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm2, DWORD PTR [edi+620]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm2, xmm0
$LN593@Begin:

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm1, DWORD PTR [ecx+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5144 :                 window->DrawList->AddRectFilled(window->Pos+ImVec2(0,window->TitleBarHeight()), window->Pos+window->Size, ColorConvertFloat4ToU32(bg_color), window_rounding, (flags & ImGuiWindowFlags_NoTitleBar) ? ImGuiCorner_All : ImGuiCorner_BottomLeft|ImGuiCorner_BottomRight);

	test	dl, 1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR [ecx]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm1, xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5144 :                 window->DrawList->AddRectFilled(window->Pos+ImVec2(0,window->TitleBarHeight()), window->Pos+window->Size, ColorConvertFloat4ToU32(bg_color), window_rounding, (flags & ImGuiWindowFlags_NoTitleBar) ? ImGuiCorner_All : ImGuiCorner_BottomLeft|ImGuiCorner_BottomRight);

	mov	ecx, 15					; 0000000fH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T32[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5144 :                 window->DrawList->AddRectFilled(window->Pos+ImVec2(0,window->TitleBarHeight()), window->Pos+window->Size, ColorConvertFloat4ToU32(bg_color), window_rounding, (flags & ImGuiWindowFlags_NoTitleBar) ? ImGuiCorner_All : ImGuiCorner_BottomLeft|ImGuiCorner_BottomRight);

	mov	eax, 12					; 0000000cH
	cmovne	eax, ecx
	push	eax
	push	ecx
	lea	eax, DWORD PTR _bg_color$34[ebp]
	movss	DWORD PTR [esp], xmm5
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T32[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5144 :                 window->DrawList->AddRectFilled(window->Pos+ImVec2(0,window->TitleBarHeight()), window->Pos+window->Size, ColorConvertFloat4ToU32(bg_color), window_rounding, (flags & ImGuiWindowFlags_NoTitleBar) ? ImGuiCorner_All : ImGuiCorner_BottomLeft|ImGuiCorner_BottomRight);

	call	?ColorConvertFloat4ToU32@ImGui@@YAIABUImVec4@@@Z ; ImGui::ColorConvertFloat4ToU32
	mov	ecx, DWORD PTR [edi+624]
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR $T94[ebp]
	push	eax
	lea	eax, DWORD PTR $T32[ebp]
	push	eax
	call	?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	mov	edx, DWORD PTR _flags$1$[ebp]
$LN102@Begin:

; 5145 : 
; 5146 :             // Title bar
; 5147 :             const bool is_focused = g.NavWindow && window->RootNonPopupWindow == g.NavWindow->RootNonPopupWindow;

	mov	ecx, DWORD PTR [esi+6380]
	test	ecx, ecx
	je	SHORT $LN181@Begin
	mov	eax, DWORD PTR [edi+636]
	cmp	eax, DWORD PTR [ecx+636]
	jne	SHORT $LN181@Begin
	mov	cl, 1
	jmp	SHORT $LN182@Begin
$LN181@Begin:
	xor	cl, cl
$LN182@Begin:

; 5148 :             if (!(flags & ImGuiWindowFlags_NoTitleBar))

	mov	eax, edx
	and	eax, 1
	mov	DWORD PTR tv7505[ebp], eax
	jne	SHORT $LN103@Begin
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 251  :     ImVec2      GetBR() const                   { return Max; }                   // Bottom-right

	mov	eax, DWORD PTR _title_bar_rect$4$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5149 :                 window->DrawList->AddRectFilled(title_bar_rect.GetTL(), title_bar_rect.GetBR(), GetColorU32(is_focused ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBg), window_rounding, ImGuiCorner_TopLeft|ImGuiCorner_TopRight);

	movss	xmm0, DWORD PTR _window_rounding$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 251  :     ImVec2      GetBR() const                   { return Max; }                   // Bottom-right

	mov	DWORD PTR $T93[ebp], eax
	mov	eax, DWORD PTR _title_bar_rect$5$[ebp]
	mov	DWORD PTR $T93[ebp+4], eax

; 248  :     ImVec2      GetTL() const                   { return Min; }                   // Top-left

	mov	eax, DWORD PTR _title_bar_rect$2$[ebp]
	mov	DWORD PTR $T38[ebp], eax
	mov	eax, DWORD PTR _title_bar_rect$3$[ebp]
	mov	DWORD PTR $T38[ebp+4], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5149 :                 window->DrawList->AddRectFilled(title_bar_rect.GetTL(), title_bar_rect.GetBR(), GetColorU32(is_focused ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBg), window_rounding, ImGuiCorner_TopLeft|ImGuiCorner_TopRight);

	xor	eax, eax
	push	3
	sub	esp, 8
	test	cl, cl
	setne	al
	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	lea	eax, DWORD PTR [eax*2+10]
	push	eax
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	ecx, DWORD PTR [edi+624]
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR $T93[ebp]
	push	eax
	lea	eax, DWORD PTR $T38[ebp]
	push	eax
	call	?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
	mov	edx, DWORD PTR _flags$1$[ebp]
$LN103@Begin:

; 5150 : 
; 5151 :             // Menu bar
; 5152 :             if (flags & ImGuiWindowFlags_MenuBar)

	test	edx, 1024				; 00000400H
	je	$LN104@Begin
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	mov	ecx, DWORD PTR [edi+8]
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	test	cl, 1
	je	SHORT $LN610@Begin
	xorps	xmm1, xmm1
	jmp	SHORT $LN611@Begin
$LN610@Begin:
	movss	xmm0, DWORD PTR [eax+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm1, DWORD PTR [eax+6176]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm0, xmm0

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm1, DWORD PTR [edi+620]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm1, xmm0
$LN611@Begin:

; 778  :     ImRect      MenuBarRect() const                     { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }

	movss	xmm2, DWORD PTR [edi+28]
	addss	xmm2, xmm1

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	test	ecx, 1024				; 00000400H
	je	SHORT $LN616@Begin
	movss	xmm0, DWORD PTR [eax+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm1, DWORD PTR [eax+6176]

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	addss	xmm0, xmm0

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm1, DWORD PTR [edi+620]

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	addss	xmm1, xmm0
	jmp	SHORT $LN617@Begin
$LN616@Begin:
	xorps	xmm1, xmm1
$LN617@Begin:
	cmp	DWORD PTR tv7507[ebp], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm3, DWORD PTR [edi+24]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 778  :     ImRect      MenuBarRect() const                     { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }

	movss	xmm0, DWORD PTR [edi+40]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _menu_bar_rect$36[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 778  :     ImRect      MenuBarRect() const                     { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }

	addss	xmm0, xmm3
	addss	xmm2, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _menu_bar_rect$36[ebp], xmm3
	movss	DWORD PTR _menu_bar_rect$36[ebp+8], xmm0
	movss	DWORD PTR _menu_bar_rect$36[ebp+12], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5155 :                 if (flags & ImGuiWindowFlags_ShowBorders)

	je	SHORT $LN105@Begin
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 251  :     ImVec2      GetBR() const                   { return Max; }                   // Bottom-right

	mov	eax, DWORD PTR _menu_bar_rect$36[ebp+8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5156 :                     window->DrawList->AddLine(menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32(ImGuiCol_Border));

	sub	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 251  :     ImVec2      GetBR() const                   { return Max; }                   // Bottom-right

	mov	DWORD PTR $T92[ebp], eax
	mov	eax, DWORD PTR _menu_bar_rect$36[ebp+12]
	mov	DWORD PTR $T92[ebp+4], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5156 :                     window->DrawList->AddLine(menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32(ImGuiCol_Border));

	mov	DWORD PTR [esp+4], 1065353216		; 3f800000H
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T47[ebp], xmm3
	movss	DWORD PTR $T47[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5156 :                     window->DrawList->AddLine(menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32(ImGuiCol_Border));

	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	ecx, DWORD PTR [edi+624]
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR $T92[ebp]
	push	eax
	lea	eax, DWORD PTR $T47[ebp]
	push	eax
	call	?AddLine@ImDrawList@@QAEXABUImVec2@@0IM@Z ; ImDrawList::AddLine
$LN105@Begin:
	cmp	DWORD PTR tv7505[ebp], 0

; 5157 :                 window->DrawList->AddRectFilled(menu_bar_rect.GetTL(), menu_bar_rect.GetBR(), GetColorU32(ImGuiCol_MenuBarBg), (flags & ImGuiWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImGuiCorner_TopLeft|ImGuiCorner_TopRight);

	je	SHORT $LN183@Begin
	movss	xmm0, DWORD PTR _window_rounding$1$[ebp]
	jmp	SHORT $LN184@Begin
$LN183@Begin:
	xorps	xmm0, xmm0
$LN184@Begin:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 251  :     ImVec2      GetBR() const                   { return Max; }                   // Bottom-right

	mov	eax, DWORD PTR _menu_bar_rect$36[ebp+8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5157 :                 window->DrawList->AddRectFilled(menu_bar_rect.GetTL(), menu_bar_rect.GetBR(), GetColorU32(ImGuiCol_MenuBarBg), (flags & ImGuiWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImGuiCorner_TopLeft|ImGuiCorner_TopRight);

	push	3
	sub	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 251  :     ImVec2      GetBR() const                   { return Max; }                   // Bottom-right

	mov	DWORD PTR $T91[ebp], eax
	mov	eax, DWORD PTR _menu_bar_rect$36[ebp+12]
	mov	DWORD PTR $T91[ebp+4], eax

; 248  :     ImVec2      GetTL() const                   { return Min; }                   // Top-left

	mov	eax, DWORD PTR _menu_bar_rect$36[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5157 :                 window->DrawList->AddRectFilled(menu_bar_rect.GetTL(), menu_bar_rect.GetBR(), GetColorU32(ImGuiCol_MenuBarBg), (flags & ImGuiWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImGuiCorner_TopLeft|ImGuiCorner_TopRight);

	movss	DWORD PTR [esp+4], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 248  :     ImVec2      GetTL() const                   { return Min; }                   // Top-left

	mov	DWORD PTR $T46[ebp], eax
	mov	eax, DWORD PTR _menu_bar_rect$36[ebp+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5157 :                 window->DrawList->AddRectFilled(menu_bar_rect.GetTL(), menu_bar_rect.GetBR(), GetColorU32(ImGuiCol_MenuBarBg), (flags & ImGuiWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImGuiCorner_TopLeft|ImGuiCorner_TopRight);

	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	13					; 0000000dH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 248  :     ImVec2      GetTL() const                   { return Min; }                   // Top-left

	mov	DWORD PTR $T46[ebp+4], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5157 :                 window->DrawList->AddRectFilled(menu_bar_rect.GetTL(), menu_bar_rect.GetBR(), GetColorU32(ImGuiCol_MenuBarBg), (flags & ImGuiWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImGuiCorner_TopLeft|ImGuiCorner_TopRight);

	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	ecx, DWORD PTR [edi+624]
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR $T91[ebp]
	push	eax
	lea	eax, DWORD PTR $T46[ebp]
	push	eax
	call	?AddRectFilled@ImDrawList@@QAEXABUImVec2@@0IMH@Z ; ImDrawList::AddRectFilled
$LN104@Begin:

; 5158 :             }
; 5159 : 
; 5160 :             // Scrollbars
; 5161 :             if (window->ScrollbarX)

	cmp	BYTE PTR [edi+116], 0
	je	SHORT $LN106@Begin

; 5162 :                 Scrollbar(window, true);

	push	1
	push	edi
	call	?Scrollbar@@YAXPAUImGuiWindow@@_N@Z	; Scrollbar
	add	esp, 8
$LN106@Begin:

; 5163 :             if (window->ScrollbarY)

	cmp	BYTE PTR [edi+117], 0
	je	SHORT $LN107@Begin

; 5164 :                 Scrollbar(window, false);

	push	0
	push	edi
	call	?Scrollbar@@YAXPAUImGuiWindow@@_N@Z	; Scrollbar
	add	esp, 8
$LN107@Begin:

; 5165 : 
; 5166 :             // Render resize grip
; 5167 :             // (after the input handling so we don't have a frame of latency)
; 5168 :             if (!(flags & ImGuiWindowFlags_NoResize))

	test	BYTE PTR _flags$1$[ebp], 2
	jne	$LN108@Begin
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 773  :     ImRect      Rect() const                            { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }

	movss	xmm2, DWORD PTR [edi+32]
	movss	xmm3, DWORD PTR [edi+36]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5171 :                 window->DrawList->PathLineTo(br + ImVec2(-resize_corner_size, -window->BorderSize));

	movss	xmm4, DWORD PTR $T20$sroa$2251$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 773  :     ImRect      Rect() const                            { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }

	addss	xmm2, DWORD PTR [edi+24]
	addss	xmm3, DWORD PTR [edi+28]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5171 :                 window->DrawList->PathLineTo(br + ImVec2(-resize_corner_size, -window->BorderSize));

	xorps	xmm4, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm1, DWORD PTR [edi+128]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movaps	xmm0, xmm4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1270 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	mov	eax, DWORD PTR [edi+624]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5171 :                 window->DrawList->PathLineTo(br + ImVec2(-resize_corner_size, -window->BorderSize));

	xorps	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1270 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	add	eax, 76					; 0000004cH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 773  :     ImRect      Rect() const                            { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }

	movss	DWORD PTR $T18$sroa$81$1$[ebp], xmm2

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm1, xmm3

; 773  :     ImRect      Rect() const                            { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }

	movss	DWORD PTR __y$1$[ebp], xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5171 :                 window->DrawList->PathLineTo(br + ImVec2(-resize_corner_size, -window->BorderSize));

	movss	DWORD PTR $T20$sroa$2251$1$[ebp], xmm4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1270 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	mov	DWORD PTR _this$1$[ebp], eax

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T41[ebp], xmm0
	movss	DWORD PTR $T41[ebp+4], xmm1

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	DWORD PTR tv7502[ebp], ecx
	cmp	edx, ecx
	jne	$LN661@Begin
	inc	edx
	mov	DWORD PTR _new_capacity$1$[ebp], edx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN659@Begin
	mov	eax, ecx
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _new_capacity$1$[ebp]
	mov	ecx, eax
	mov	eax, DWORD PTR _this$1$[ebp]
	sar	ecx, 1
	add	ecx, DWORD PTR tv7502[ebp]
	jmp	SHORT $LN660@Begin
$LN659@Begin:
	mov	ecx, 8
$LN660@Begin:
	cmp	ecx, edx
	cmovg	edx, ecx
	mov	DWORD PTR _new_capacity$1$[ebp], edx

; 931  :         if (new_capacity <= Capacity) return;

	cmp	edx, DWORD PTR [eax+4]
	jle	SHORT $LN661@Begin

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edx*8]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	edx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR _new_data$1$[ebp], edx
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN663@Begin

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [eax]
	shl	ecx, 3
	push	ecx
	push	DWORD PTR [eax+8]
	push	edx
	call	_memcpy
	mov	eax, DWORD PTR _this$1$[ebp]
	add	esp, 12					; 0000000cH
$LN663@Begin:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [eax+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _this$1$[ebp]
	add	esp, 4
	mov	ecx, DWORD PTR _new_data$1$[ebp]
	movss	xmm2, DWORD PTR $T18$sroa$81$1$[ebp]
	movss	xmm3, DWORD PTR __y$1$[ebp]
	movss	xmm4, DWORD PTR $T20$sroa$2251$1$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 937  :         Capacity = new_capacity;

	mov	ecx, DWORD PTR _new_capacity$1$[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN661@Begin:

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR $T41[ebp]
	mov	DWORD PTR [edx+ecx*8], eax
	mov	eax, DWORD PTR $T41[ebp+4]
	mov	DWORD PTR [edx+ecx*8+4], eax
	mov	eax, DWORD PTR _this$1$[ebp]
	inc	DWORD PTR [eax]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5172 :                 window->DrawList->PathLineTo(br + ImVec2(-window->BorderSize, -resize_corner_size));

	movss	xmm0, DWORD PTR [edi+128]
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1270 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	mov	eax, DWORD PTR [edi+624]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1270 :     inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }

	add	eax, 76					; 0000004cH
	mov	DWORD PTR _this$1$[ebp], eax

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T40[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movaps	xmm0, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	DWORD PTR tv7497[ebp], ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T40[ebp+4], xmm0

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	cmp	edx, ecx
	jne	$LN680@Begin
	inc	edx
	mov	DWORD PTR _new_capacity$1$[ebp], edx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	ecx, ecx
	je	SHORT $LN678@Begin
	mov	eax, ecx
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _new_capacity$1$[ebp]
	mov	ecx, eax
	mov	eax, DWORD PTR _this$1$[ebp]
	sar	ecx, 1
	add	ecx, DWORD PTR tv7497[ebp]
	jmp	SHORT $LN679@Begin
$LN678@Begin:
	mov	ecx, 8
$LN679@Begin:
	cmp	ecx, edx
	cmovg	edx, ecx
	mov	DWORD PTR _new_capacity$1$[ebp], edx

; 931  :         if (new_capacity <= Capacity) return;

	cmp	edx, DWORD PTR [eax+4]
	jle	SHORT $LN680@Begin

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edx*8]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	edx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR _new_data$1$[ebp], edx
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN682@Begin

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [eax]
	shl	ecx, 3
	push	ecx
	push	DWORD PTR [eax+8]
	push	edx
	call	_memcpy
	mov	eax, DWORD PTR _this$1$[ebp]
	add	esp, 12					; 0000000cH
$LN682@Begin:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [eax+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _this$1$[ebp]
	add	esp, 4
	mov	ecx, DWORD PTR _new_data$1$[ebp]
	movss	xmm2, DWORD PTR $T18$sroa$81$1$[ebp]
	movss	xmm3, DWORD PTR __y$1$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 937  :         Capacity = new_capacity;

	mov	ecx, DWORD PTR _new_capacity$1$[ebp]
	mov	DWORD PTR [eax+4], ecx
$LN680@Begin:

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR $T40[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5173 :                 window->DrawList->PathArcToFast(ImVec2(br.x - window_rounding - window->BorderSize, br.y - window_rounding - window->BorderSize), window_rounding, 0, 3);

	movss	xmm1, DWORD PTR _window_rounding$1$[ebp]
	subss	xmm3, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	DWORD PTR [edx+ecx*8], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5173 :                 window->DrawList->PathArcToFast(ImVec2(br.x - window_rounding - window->BorderSize, br.y - window_rounding - window->BorderSize), window_rounding, 0, 3);

	subss	xmm2, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	eax, DWORD PTR $T40[ebp+4]
	mov	DWORD PTR [edx+ecx*8+4], eax
	mov	eax, DWORD PTR _this$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5173 :                 window->DrawList->PathArcToFast(ImVec2(br.x - window_rounding - window->BorderSize, br.y - window_rounding - window->BorderSize), window_rounding, 0, 3);

	push	3
	push	0
	push	ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	inc	DWORD PTR [eax]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5173 :                 window->DrawList->PathArcToFast(ImVec2(br.x - window_rounding - window->BorderSize, br.y - window_rounding - window->BorderSize), window_rounding, 0, 3);

	lea	eax, DWORD PTR $T90[ebp]
	movss	xmm0, DWORD PTR [edi+128]
	subss	xmm3, xmm0
	movss	DWORD PTR [esp], xmm1
	subss	xmm2, xmm0
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T90[ebp+4], xmm3
	movss	DWORD PTR $T90[ebp], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5173 :                 window->DrawList->PathArcToFast(ImVec2(br.x - window_rounding - window->BorderSize, br.y - window_rounding - window->BorderSize), window_rounding, 0, 3);

	mov	ecx, DWORD PTR [edi+624]
	call	?PathArcToFast@ImDrawList@@QAEXABUImVec2@@MHH@Z ; ImDrawList::PathArcToFast

; 5174 :                 window->DrawList->PathFill(resize_col);

	mov	eax, DWORD PTR [edi+624]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1272 :     inline    void  PathFill(ImU32 col)                                         { AddConvexPolyFilled(_Path.Data, _Path.Size, col, true); PathClear(); }

	mov	ecx, eax
	push	1
	push	DWORD PTR _resize_col$1$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5174 :                 window->DrawList->PathFill(resize_col);

	mov	DWORD PTR _this$1$[ebp], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 1272 :     inline    void  PathFill(ImU32 col)                                         { AddConvexPolyFilled(_Path.Data, _Path.Size, col, true); PathClear(); }

	push	DWORD PTR [eax+76]
	push	DWORD PTR [eax+84]
	call	?AddConvexPolyFilled@ImDrawList@@QAEXPBUImVec2@@HI_N@Z ; ImDrawList::AddConvexPolyFilled

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR tv7492[ebp], ecx
	test	ecx, ecx
	jns	SHORT $LN697@Begin

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	je	SHORT $LN695@Begin
	mov	eax, ecx
	cdq
	sub	eax, edx
	mov	ecx, eax
	mov	eax, DWORD PTR _this$1$[ebp]
	sar	ecx, 1
	add	ecx, DWORD PTR tv7492[ebp]
	jmp	SHORT $LN696@Begin
$LN695@Begin:
	mov	ecx, 8
$LN696@Begin:
	xor	edx, edx
	test	ecx, ecx
	cmovg	edx, ecx
	mov	DWORD PTR _new_capacity$1$[ebp], edx

; 931  :         if (new_capacity <= Capacity) return;

	cmp	edx, DWORD PTR [eax+80]
	jle	SHORT $LN697@Begin

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edx*8]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc
	mov	edx, eax
	add	esp, 4

; 933  :         if (Data)

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR _new_data$1$[ebp], edx
	cmp	DWORD PTR [eax+84], 0
	je	SHORT $LN699@Begin

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [eax+76]
	shl	ecx, 3
	push	ecx
	push	DWORD PTR [eax+84]
	push	edx
	call	_memcpy
	mov	eax, DWORD PTR _this$1$[ebp]
	add	esp, 12					; 0000000cH
$LN699@Begin:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [eax+84]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _this$1$[ebp]
	add	esp, 4
	mov	ecx, DWORD PTR _new_data$1$[ebp]
	mov	DWORD PTR [eax+84], ecx

; 937  :         Capacity = new_capacity;

	mov	ecx, DWORD PTR _new_capacity$1$[ebp]
	mov	DWORD PTR [eax+80], ecx
$LN697@Begin:

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [eax+76], 0
$LN108@Begin:
	cmp	DWORD PTR tv7507[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5178 :             if (flags & ImGuiWindowFlags_ShowBorders)

	je	$LN110@Begin
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [edi+24]
	lea	ecx, DWORD PTR [edi+32]
	addss	xmm0, DWORD PTR [ecx]
	movss	xmm1, DWORD PTR [edi+28]
	addss	xmm1, DWORD PTR [ecx+4]
	movss	xmm2, DWORD PTR __real@3f800000
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5180 :                 window->DrawList->AddRect(window->Pos+ImVec2(1,1), window->Pos+window->Size+ImVec2(1,1), GetColorU32(ImGuiCol_BorderShadow), window_rounding);

	push	ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5180 :                 window->DrawList->AddRect(window->Pos+ImVec2(1,1), window->Pos+window->Size+ImVec2(1,1), GetColorU32(ImGuiCol_BorderShadow), window_rounding);

	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	-1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm1, xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5180 :                 window->DrawList->AddRect(window->Pos+ImVec2(1,1), window->Pos+window->Size+ImVec2(1,1), GetColorU32(ImGuiCol_BorderShadow), window_rounding);

	sub	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T89[ebp], xmm0
	movss	DWORD PTR $T89[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [edi+24]
	movss	xmm1, DWORD PTR [edi+28]
	addss	xmm0, xmm2
	addss	xmm1, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T101[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5180 :                 window->DrawList->AddRect(window->Pos+ImVec2(1,1), window->Pos+window->Size+ImVec2(1,1), GetColorU32(ImGuiCol_BorderShadow), window_rounding);

	movss	xmm0, DWORD PTR _window_rounding$1$[ebp]
	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	6
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T101[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5180 :                 window->DrawList->AddRect(window->Pos+ImVec2(1,1), window->Pos+window->Size+ImVec2(1,1), GetColorU32(ImGuiCol_BorderShadow), window_rounding);

	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	ecx, DWORD PTR [edi+624]
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR $T89[ebp]
	push	eax
	lea	eax, DWORD PTR $T101[ebp]
	push	eax
	call	?AddRect@ImDrawList@@QAEXABUImVec2@@0IMHM@Z ; ImDrawList::AddRect
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [edi+24]
	lea	ecx, DWORD PTR [edi+32]
	addss	xmm0, DWORD PTR [ecx]
	movss	xmm1, DWORD PTR [edi+28]
	addss	xmm1, DWORD PTR [ecx+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5181 :                 window->DrawList->AddRect(window->Pos, window->Pos+window->Size, GetColorU32(ImGuiCol_Border), window_rounding);

	push	ecx
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	-1
	sub	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T88[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5181 :                 window->DrawList->AddRect(window->Pos, window->Pos+window->Size, GetColorU32(ImGuiCol_Border), window_rounding);

	movss	xmm0, DWORD PTR _window_rounding$1$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T88[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5181 :                 window->DrawList->AddRect(window->Pos, window->Pos+window->Size, GetColorU32(ImGuiCol_Border), window_rounding);

	movss	DWORD PTR [esp+4], xmm0
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
	push	5
	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	ecx, DWORD PTR [edi+624]
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR $T88[ebp]
	push	eax
	lea	eax, DWORD PTR [edi+24]
	push	eax
	call	?AddRect@ImDrawList@@QAEXABUImVec2@@0IMHM@Z ; ImDrawList::AddRect
	cmp	DWORD PTR tv7505[ebp], 0

; 5182 :                 if (!(flags & ImGuiWindowFlags_NoTitleBar))

	jne	SHORT $LN110@Begin
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR _title_bar_rect$63[ebp+8]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5183 :                     window->DrawList->AddLine(title_bar_rect.GetBL()+ImVec2(1,0), title_bar_rect.GetBR()-ImVec2(1,0), GetColorU32(ImGuiCol_Border));

	sub	esp, 8
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm0, DWORD PTR __real@3f800000
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm1, DWORD PTR _title_bar_rect$63[ebp+12]
	movss	DWORD PTR $T87[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5183 :                     window->DrawList->AddLine(title_bar_rect.GetBL()+ImVec2(1,0), title_bar_rect.GetBR()-ImVec2(1,0), GetColorU32(ImGuiCol_Border));

	mov	DWORD PTR [esp+4], 1065353216		; 3f800000H
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T87[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR _title_bar_rect$63[ebp]
	addss	xmm0, DWORD PTR __real@3f800000
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5183 :                     window->DrawList->AddLine(title_bar_rect.GetBL()+ImVec2(1,0), title_bar_rect.GetBR()-ImVec2(1,0), GetColorU32(ImGuiCol_Border));

	push	5
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T100[ebp+4], xmm1
	movss	DWORD PTR $T100[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5183 :                     window->DrawList->AddLine(title_bar_rect.GetBL()+ImVec2(1,0), title_bar_rect.GetBR()-ImVec2(1,0), GetColorU32(ImGuiCol_Border));

	call	?GetColorU32@ImGui@@YAIHM@Z		; ImGui::GetColorU32
	mov	ecx, DWORD PTR [edi+624]
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR $T87[ebp]
	push	eax
	lea	eax, DWORD PTR $T100[ebp]
	push	eax
	call	?AddLine@ImDrawList@@QAEXABUImVec2@@0IM@Z ; ImDrawList::AddLine
$LN110@Begin:

; 5184 :             }
; 5185 :         }
; 5186 : 
; 5187 :         // Update ContentsRegionMax. All the variable it depends on are set above in this function.
; 5188 :         window->ContentsRegionRect.Min.x = -window->Scroll.x + window->WindowPadding.x;

	movss	xmm0, DWORD PTR [edi+80]
	xorps	xmm3, xmm3
	subss	xmm0, DWORD PTR [edi+92]
	movss	DWORD PTR [edi+64], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	mov	ecx, DWORD PTR [edi+8]
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	test	cl, 1
	je	SHORT $LN741@Begin
	xorps	xmm2, xmm2
	jmp	SHORT $LN742@Begin
$LN741@Begin:
	movss	xmm0, DWORD PTR [eax+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm2, DWORD PTR [eax+6176]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm0, xmm0

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm2, DWORD PTR [edi+620]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm2, xmm0
$LN742@Begin:

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	test	ecx, 1024				; 00000400H
	je	SHORT $LN747@Begin
	movss	xmm0, DWORD PTR [eax+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm1, DWORD PTR [eax+6176]

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	addss	xmm0, xmm0

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm1, DWORD PTR [edi+620]

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	addss	xmm1, xmm0
	jmp	SHORT $LN748@Begin
$LN747@Begin:
	xorps	xmm1, xmm1
$LN748@Begin:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5189 :         window->ContentsRegionRect.Min.y = -window->Scroll.y + window->WindowPadding.y + window->TitleBarHeight() + window->MenuBarHeight();

	movss	xmm0, DWORD PTR [edi+84]
	subss	xmm0, DWORD PTR [edi+96]
	addss	xmm0, xmm2
	addss	xmm0, xmm1
	movss	DWORD PTR [edi+68], xmm0

; 5190 :         window->ContentsRegionRect.Max.x = -window->Scroll.x - window->WindowPadding.x + (window->SizeContentsExplicit.x != 0.0f ? window->SizeContentsExplicit.x : (window->Size.x - window->ScrollbarSizes.x)); 

	movss	xmm1, DWORD PTR [edi+56]
	ucomiss	xmm1, xmm3
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN186@Begin
	movss	xmm1, DWORD PTR [edi+32]
	subss	xmm1, DWORD PTR [edi+120]
$LN186@Begin:
	movss	xmm0, DWORD PTR [edi+80]
	addss	xmm0, DWORD PTR [edi+92]
	subss	xmm1, xmm0
	movss	DWORD PTR [edi+72], xmm1

; 5191 :         window->ContentsRegionRect.Max.y = -window->Scroll.y - window->WindowPadding.y + (window->SizeContentsExplicit.y != 0.0f ? window->SizeContentsExplicit.y : (window->Size.y - window->ScrollbarSizes.y)); 

	movss	xmm1, DWORD PTR [edi+60]
	ucomiss	xmm1, xmm3
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN188@Begin
	movss	xmm1, DWORD PTR [edi+36]
	subss	xmm1, DWORD PTR [edi+124]
$LN188@Begin:
	movss	xmm0, DWORD PTR [edi+96]
	addss	xmm0, DWORD PTR [edi+84]
	subss	xmm1, xmm0
	movss	DWORD PTR [edi+76], xmm1

; 5192 : 
; 5193 :         // Setup drawing context
; 5194 :         window->DC.IndentX = 0.0f + window->WindowPadding.x - window->Scroll.x;

	movss	xmm0, DWORD PTR [edi+80]
	subss	xmm0, DWORD PTR [edi+92]
	movss	DWORD PTR [edi+400], xmm0

; 5195 :         window->DC.GroupOffsetX = 0.0f;

	mov	DWORD PTR [edi+404], 0

; 5196 :         window->DC.ColumnsOffsetX = 0.0f;

	mov	DWORD PTR [edi+408], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	mov	ecx, DWORD PTR [edi+8]
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	test	cl, 1
	je	SHORT $LN753@Begin
	xorps	xmm2, xmm2
	jmp	SHORT $LN754@Begin
$LN753@Begin:
	movss	xmm0, DWORD PTR [eax+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm2, DWORD PTR [eax+6176]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm0, xmm0

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm2, DWORD PTR [edi+620]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm2, xmm0
$LN754@Begin:

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	test	ecx, 1024				; 00000400H
	je	SHORT $LN759@Begin
	movss	xmm0, DWORD PTR [eax+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm1, DWORD PTR [eax+6176]

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	addss	xmm0, xmm0

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm1, DWORD PTR [edi+620]

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	addss	xmm1, xmm0
	jmp	SHORT $LN760@Begin
$LN759@Begin:
	xorps	xmm1, xmm1
$LN760@Begin:

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [edi+24]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5197 :         window->DC.CursorStartPos = window->Pos + ImVec2(window->DC.IndentX + window->DC.ColumnsOffsetX, window->TitleBarHeight() + window->MenuBarHeight() + window->WindowPadding.y - window->Scroll.y);

	addss	xmm1, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, DWORD PTR [edi+400]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5197 :         window->DC.CursorStartPos = window->Pos + ImVec2(window->DC.IndentX + window->DC.ColumnsOffsetX, window->TitleBarHeight() + window->MenuBarHeight() + window->WindowPadding.y - window->Scroll.y);

	addss	xmm1, DWORD PTR [edi+84]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T86[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [edi+28]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5197 :         window->DC.CursorStartPos = window->Pos + ImVec2(window->DC.IndentX + window->DC.ColumnsOffsetX, window->TitleBarHeight() + window->MenuBarHeight() + window->WindowPadding.y - window->Scroll.y);

	mov	ecx, DWORD PTR $T86[ebp]
	subss	xmm1, DWORD PTR [edi+96]
	mov	DWORD PTR [edi+208], ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T86[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5197 :         window->DC.CursorStartPos = window->Pos + ImVec2(window->DC.IndentX + window->DC.ColumnsOffsetX, window->TitleBarHeight() + window->MenuBarHeight() + window->WindowPadding.y - window->Scroll.y);

	mov	eax, DWORD PTR $T86[ebp+4]
	mov	DWORD PTR [edi+212], eax

; 5198 :         window->DC.CursorPos = window->DC.CursorStartPos;

	mov	DWORD PTR [edi+192], ecx
	mov	DWORD PTR [edi+196], eax

; 5199 :         window->DC.CursorPosPrevLine = window->DC.CursorPos;

	mov	DWORD PTR [edi+200], ecx
	mov	DWORD PTR [edi+204], eax

; 5200 :         window->DC.CursorMaxPos = window->DC.CursorStartPos;

	mov	eax, DWORD PTR [edi+208]
	mov	DWORD PTR [edi+216], eax
	mov	eax, DWORD PTR [edi+212]
	mov	DWORD PTR [edi+220], eax

; 5201 :         window->DC.CurrentLineHeight = window->DC.PrevLineHeight = 0.0f;

	mov	DWORD PTR [edi+232], 0
	mov	DWORD PTR [edi+224], 0

; 5202 :         window->DC.CurrentLineTextBaseOffset = window->DC.PrevLineTextBaseOffset = 0.0f;

	mov	DWORD PTR [edi+236], 0
	mov	DWORD PTR [edi+228], 0

; 5203 :         window->DC.NavLayerActiveFlags = window->DC.NavLayerActiveFlagsNext;

	mov	eax, DWORD PTR [edi+280]
	mov	DWORD PTR [edi+276], eax

; 5204 :         window->DC.NavLayerActiveFlagsNext = 0x00;

	mov	DWORD PTR [edi+280], 0

; 5205 :         window->DC.NavHasScroll = (GetScrollMaxY() > 0.0f);

	call	?GetScrollMaxY@ImGui@@YAMXZ		; ImGui::GetScrollMaxY
	fstp	DWORD PTR tv7861[ebp]
	movss	xmm0, DWORD PTR tv7861[ebp]
	xorps	xmm4, xmm4
	comiss	xmm0, xmm4
	seta	al
	mov	BYTE PTR [edi+270], al

; 5206 :         window->DC.MenuBarAppending = false;

	mov	BYTE PTR [edi+284], 0
	movss	xmm0, DWORD PTR [edi+80]
	maxss	xmm0, DWORD PTR [esi+5368]

; 5207 :         window->DC.MenuBarOffsetX = ImMax(window->WindowPadding.x, style.ItemSpacing.x);

	movss	DWORD PTR [edi+288], xmm0

; 5208 :         window->DC.LogLinePosY = window->DC.CursorPos.y - 9999.0f;

	movss	xmm0, DWORD PTR [edi+196]
	subss	xmm0, DWORD PTR __real@461c3c00
	movss	DWORD PTR [edi+240], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	ecx, DWORD PTR [edi+296]
	test	ecx, ecx
	jns	SHORT $LN780@Begin

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	je	SHORT $LN778@Begin
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN779@Begin
$LN778@Begin:
	mov	eax, 8
$LN779@Begin:
	xor	ecx, ecx
	test	eax, eax
	cmovg	ecx, eax
	mov	DWORD PTR _new_capacity$1$[ebp], ecx

; 931  :         if (new_capacity <= Capacity) return;

	cmp	ecx, DWORD PTR [edi+296]
	jle	SHORT $LN780@Begin

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [ecx*4]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [edi+300]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN782@Begin

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [edi+292]
	shl	ecx, 2
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN782@Begin:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [edi+300]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [edi+300], eax

; 937  :         Capacity = new_capacity;

	mov	eax, DWORD PTR _new_capacity$1$[ebp]
	mov	DWORD PTR [edi+296], eax
$LN780@Begin:

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [edi+292], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5210 :         window->DC.LayoutType = ImGuiLayoutType_Vertical;

	mov	DWORD PTR [edi+308], 0

; 5211 :         window->DC.ItemFlags = ImGuiItemFlags_Default_;

	mov	DWORD PTR [edi+312], 3

; 5212 :         window->DC.ItemWidth = window->ItemWidthDefault;

	mov	eax, DWORD PTR [edi+524]
	mov	DWORD PTR [edi+316], eax

; 5213 :         window->DC.TextWrapPos = -1.0f; // disabled

	mov	DWORD PTR [edi+320], -1082130432	; bf800000H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	ecx, DWORD PTR [edi+328]
	test	ecx, ecx
	jns	SHORT $LN791@Begin

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	je	SHORT $LN789@Begin
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN790@Begin
$LN789@Begin:
	mov	eax, 8
$LN790@Begin:
	xor	edx, edx
	test	eax, eax
	cmovg	edx, eax
	mov	DWORD PTR _new_capacity$1$[ebp], edx

; 931  :         if (new_capacity <= Capacity) return;

	cmp	edx, ecx
	jle	SHORT $LN791@Begin

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edx*4]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [edi+332]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN793@Begin

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [edi+324]
	shl	ecx, 2
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN793@Begin:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [edi+332]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [edi+332], eax

; 937  :         Capacity = new_capacity;

	mov	eax, DWORD PTR _new_capacity$1$[ebp]
	mov	DWORD PTR [edi+328], eax
$LN791@Begin:

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [edi+324], 0
	mov	ecx, DWORD PTR [edi+340]
	test	ecx, ecx
	jns	SHORT $LN802@Begin

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	je	SHORT $LN800@Begin
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN801@Begin
$LN800@Begin:
	mov	eax, 8
$LN801@Begin:
	xor	edx, edx
	test	eax, eax
	cmovg	edx, eax
	mov	DWORD PTR _new_capacity$1$[ebp], edx

; 931  :         if (new_capacity <= Capacity) return;

	cmp	edx, ecx
	jle	SHORT $LN802@Begin

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edx*4]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [edi+344]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN804@Begin

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [edi+336]
	shl	ecx, 2
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN804@Begin:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [edi+344]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [edi+344], eax

; 937  :         Capacity = new_capacity;

	mov	eax, DWORD PTR _new_capacity$1$[ebp]
	mov	DWORD PTR [edi+340], eax
$LN802@Begin:

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [edi+336], 0
	mov	ecx, DWORD PTR [edi+352]
	test	ecx, ecx
	jns	SHORT $LN813@Begin

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	je	SHORT $LN811@Begin
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN812@Begin
$LN811@Begin:
	mov	eax, 8
$LN812@Begin:
	xor	edx, edx
	test	eax, eax
	cmovg	edx, eax
	mov	DWORD PTR _new_capacity$1$[ebp], edx

; 931  :         if (new_capacity <= Capacity) return;

	cmp	edx, ecx
	jle	SHORT $LN813@Begin

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edx*4]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [edi+356]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN815@Begin

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [edi+348]
	shl	ecx, 2
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN815@Begin:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [edi+356]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [edi+356], eax

; 937  :         Capacity = new_capacity;

	mov	eax, DWORD PTR _new_capacity$1$[ebp]
	mov	DWORD PTR [edi+352], eax
$LN813@Begin:

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [edi+348], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5222 :         window->DC.StateStorage = &window->StateStorage;

	lea	eax, DWORD PTR [edi+608]
	mov	DWORD PTR [edi+412], 0
	mov	DWORD PTR [edi+416], 1
	movss	xmm0, DWORD PTR [edi+196]
	movss	DWORD PTR [edi+428], xmm0
	movss	DWORD PTR [edi+436], xmm0
	movss	DWORD PTR [edi+432], xmm0
	mov	DWORD PTR [edi+244], 0
	mov	DWORD PTR [edi+304], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	ecx, DWORD PTR [edi+364]
	test	ecx, ecx
	jns	SHORT $LN824@Begin

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	je	SHORT $LN822@Begin
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN823@Begin
$LN822@Begin:
	mov	eax, 8
$LN823@Begin:
	xor	ecx, ecx
	test	eax, eax
	cmovg	ecx, eax
	mov	DWORD PTR _new_capacity$1$[ebp], ecx

; 931  :         if (new_capacity <= Capacity) return;

	cmp	ecx, DWORD PTR [edi+364]
	jle	SHORT $LN824@Begin

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [ecx+ecx*4]
	shl	eax, 3
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [edi+368]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN826@Begin

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [edi+360]
	lea	ecx, DWORD PTR [ecx+ecx*4]
	shl	ecx, 3
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN826@Begin:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [edi+368]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [edi+368], eax

; 937  :         Capacity = new_capacity;

	mov	eax, DWORD PTR _new_capacity$1$[ebp]
	mov	DWORD PTR [edi+364], eax
$LN824@Begin:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5225 :         window->MenuColumns.Update(3, style.ItemSpacing.x, !window_was_active);

	mov	al, BYTE PTR _window_was_active$1$[ebp]
	xor	al, 1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [edi+360], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5225 :         window->MenuColumns.Update(3, style.ItemSpacing.x, !window_was_active);

	movzx	eax, al
	push	eax
	push	ecx
	mov	DWORD PTR [edi+372], -2			; fffffffeH
	lea	ecx, DWORD PTR [edi+528]
	movss	xmm0, DWORD PTR [esi+5368]
	movss	DWORD PTR [esp], xmm0
	push	3
	call	?Update@ImGuiSimpleColumns@@QAEXHM_N@Z	; ImGuiSimpleColumns::Update
	cmp	DWORD PTR tv7534[ebp], 0

; 5226 : 
; 5227 :         if ((flags & ImGuiWindowFlags_ChildWindow) && (window->DC.ItemFlags != parent_window->DC.ItemFlags))

	je	$LN111@Begin
	mov	eax, DWORD PTR _parent_window$1$[ebp]
	mov	eax, DWORD PTR [eax+312]
	cmp	DWORD PTR [edi+312], eax
	je	$LN111@Begin

; 5228 :         {
; 5229 :             window->DC.ItemFlags = parent_window->DC.ItemFlags;

	mov	DWORD PTR [edi+312], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	ecx, DWORD PTR [edi+324]
	mov	eax, DWORD PTR [edi+328]
	cmp	ecx, eax
	jne	$LN835@Begin
	inc	ecx

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	eax, eax
	je	SHORT $LN833@Begin
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR [edi+328]
	sar	eax, 1
	add	eax, edx
	jmp	SHORT $LN834@Begin
$LN833@Begin:
	mov	edx, DWORD PTR [edi+328]
	mov	eax, 8
$LN834@Begin:
	cmp	eax, ecx
	cmovg	ecx, eax
	mov	DWORD PTR _new_capacity$1$[ebp], ecx

; 931  :         if (new_capacity <= Capacity) return;

	cmp	ecx, edx
	jle	SHORT $LN835@Begin

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [ecx*4]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [edi+332]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN837@Begin

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [edi+324]
	shl	ecx, 2
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN837@Begin:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [edi+332]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [edi+332], eax

; 937  :         Capacity = new_capacity;

	mov	eax, DWORD PTR _new_capacity$1$[ebp]
	mov	DWORD PTR [edi+328], eax
$LN835@Begin:

; 940  :     inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }

	mov	edx, DWORD PTR [edi+324]
	mov	ecx, DWORD PTR [edi+332]
	mov	eax, DWORD PTR [edi+312]
	mov	DWORD PTR [ecx+edx*4], eax
	inc	DWORD PTR [edi+324]
$LN111@Begin:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5233 :         if (window->AutoFitFramesX > 0)

	mov	eax, DWORD PTR [edi+152]
	test	eax, eax
	jle	SHORT $LN112@Begin

; 5234 :             window->AutoFitFramesX--;

	dec	eax
	mov	DWORD PTR [edi+152], eax
$LN112@Begin:

; 5235 :         if (window->AutoFitFramesY > 0)

	mov	eax, DWORD PTR [edi+156]
	test	eax, eax
	jle	SHORT $LN113@Begin

; 5236 :             window->AutoFitFramesY--;

	dec	eax
	mov	DWORD PTR [edi+156], eax
$LN113@Begin:

; 5237 : 
; 5238 :         // New windows appears in front (we need to do that AFTER setting DC.CursorStartPos so our initial navigation reference rectangle can start around there)
; 5239 :         if (!window_was_active && !(flags & ImGuiWindowFlags_NoFocusOnAppearing))

	cmp	BYTE PTR _window_was_active$1$[ebp], 0
	mov	eax, DWORD PTR _flags$1$[ebp]
	jne	SHORT $LN115@Begin
	test	eax, 4096				; 00001000H
	jne	SHORT $LN115@Begin
	cmp	DWORD PTR tv7522[ebp], 0

; 5240 :             if (!(flags & (ImGuiWindowFlags_ChildWindow|ImGuiWindowFlags_Tooltip)) || (flags & ImGuiWindowFlags_Popup))

	je	SHORT $LN116@Begin
	cmp	DWORD PTR tv7601[ebp], 0
	je	SHORT $LN115@Begin
$LN116@Begin:

; 5241 :             {
; 5242 :                 FocusWindow(window);

	push	edi
	call	?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusWindow

; 5243 :                 NavInitWindow(window, false);

	push	0
	push	edi
	call	?NavInitWindow@@YAXPAUImGuiWindow@@_N@Z	; NavInitWindow
	mov	eax, DWORD PTR _flags$1$[ebp]
	add	esp, 12					; 0000000cH
$LN115@Begin:

; 5244 :             }
; 5245 : 
; 5246 :         // Title bar
; 5247 :         if (!(flags & ImGuiWindowFlags_NoTitleBar))

	test	al, 1
	jne	$LN117@Begin

; 5248 :         {
; 5249 :             // Close & collapse button are on layer 1 (same as menus) and don't default focus
; 5250 :             const ImGuiItemFlags backup_item_options = window->DC.ItemFlags;

	mov	eax, DWORD PTR [edi+312]

; 5251 :             window->DC.ItemFlags &= ~ImGuiItemFlags_AllowNavDefaultFocus;
; 5252 :             window->DC.NavLayerCurrent++;
; 5253 : 
; 5254 :             // Collapse button
; 5255 :             const ImVec2 text_size = CalcTextSize(name, NULL, true);

	push	ecx
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	push	1
	mov	DWORD PTR _backup_item_options$1$[ebp], eax
	and	eax, -3					; fffffffdH
	push	0
	push	DWORD PTR _name$[ebp]
	mov	DWORD PTR [edi+312], eax
	lea	eax, DWORD PTR _text_size$37[ebp]
	inc	DWORD PTR [edi+272]
	push	eax
	call	?CalcTextSize@ImGui@@YA?AUImVec2@@PBD0_NM@Z ; ImGui::CalcTextSize

; 5256 :             if (!(flags & ImGuiWindowFlags_NoCollapse))

	mov	eax, DWORD PTR _flags$1$[ebp]
	add	esp, 20					; 00000014H
	and	eax, 32					; 00000020H
	mov	DWORD PTR tv7451[ebp], eax
	jne	$LN118@Begin

; 5258 :                 ImGuiID id = window->GetID("#COLLAPSE");

	push	0
	push	OFFSET $SG118297
	mov	ecx, edi
	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm1, DWORD PTR [esi+5356]
	addss	xmm1, DWORD PTR [edi+24]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm2, DWORD PTR [esi+6172]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [edi+28]
	addss	xmm0, DWORD PTR [esi+5360]

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm3, DWORD PTR __real@3f800000

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm1, xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5258 :                 ImGuiID id = window->GetID("#COLLAPSE");

	mov	DWORD PTR _id$106[ebp], eax

; 5260 :                 ItemAdd(bb, &id); // To allow navigation

	push	0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm2, xmm0
	movss	xmm0, DWORD PTR [esi+5356]
	addss	xmm0, DWORD PTR [edi+24]

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm1, xmm3
	subss	xmm2, xmm3

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T45[ebp], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm1, DWORD PTR [edi+28]
	addss	xmm1, DWORD PTR [esi+5360]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T45[ebp+4], xmm2
	movss	DWORD PTR $T99[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T99[ebp]
	mov	DWORD PTR _bb$31[ebp], eax

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm1, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T99[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR $T99[ebp+4]
	mov	DWORD PTR _bb$31[ebp+4], eax
	mov	eax, DWORD PTR $T45[ebp]
	mov	DWORD PTR _bb$31[ebp+8], eax
	mov	eax, DWORD PTR $T45[ebp+4]
	mov	DWORD PTR _bb$31[ebp+12], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5260 :                 ItemAdd(bb, &id); // To allow navigation

	lea	eax, DWORD PTR _id$106[ebp]
	push	eax
	lea	eax, DWORD PTR _bb$31[ebp]
	push	eax
	call	?ItemAdd@ImGui@@YA_NABUImRect@@PBIPBU2@@Z ; ImGui::ItemAdd

; 5261 :                 if (ButtonBehavior(bb, id, NULL, NULL))

	push	0
	push	0
	push	0
	push	DWORD PTR _id$106[ebp]
	lea	eax, DWORD PTR _bb$31[ebp]
	push	eax
	call	?ButtonBehavior@ImGui@@YA_NABUImRect@@IPA_N1H@Z ; ImGui::ButtonBehavior
	add	esp, 32					; 00000020H
	test	al, al
	je	SHORT $LN119@Begin

; 5262 :                     window->CollapseToggleWanted = true; // Defer collapsing to next frame as we are too far in the Begin() function

	mov	BYTE PTR [edi+136], 1
$LN119@Begin:

; 5263 :                 RenderNavHighlight(bb, id);

	push	DWORD PTR _id$106[ebp]
	lea	eax, DWORD PTR _bb$31[ebp]
	push	eax
	call	?RenderNavHighlight@ImGui@@YAXABUImRect@@I@Z ; ImGui::RenderNavHighlight
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [esi+5356]
	lea	ecx, DWORD PTR [esi+5320]
	addss	xmm0, DWORD PTR [edi+24]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5264 :                 RenderCollapseTriangle(window->Pos + style.FramePadding, !window->Collapsed, 1.0f);

	add	esp, 4
	cmp	BYTE PTR [edi+135], 0
	sete	al
	movzx	eax, al
	mov	DWORD PTR [esp], 1065353216		; 3f800000H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T98[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR [edi+28]
	addss	xmm0, DWORD PTR [ecx+40]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5264 :                 RenderCollapseTriangle(window->Pos + style.FramePadding, !window->Collapsed, 1.0f);

	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T98[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5264 :                 RenderCollapseTriangle(window->Pos + style.FramePadding, !window->Collapsed, 1.0f);

	push	DWORD PTR $T98[ebp+4]
	push	DWORD PTR $T98[ebp]
	call	?RenderCollapseTriangle@ImGui@@YAXUImVec2@@_NM@Z ; ImGui::RenderCollapseTriangle
	add	esp, 16					; 00000010H
$LN118@Begin:

; 5265 :             }
; 5266 : 
; 5267 :             // Close button
; 5268 :             if (p_open != NULL)

	cmp	DWORD PTR _p_open$[ebp], 0
	je	$LN121@Begin
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	test	BYTE PTR [edi+8], 1
	je	SHORT $LN873@Begin
	xorps	xmm3, xmm3
	jmp	SHORT $LN874@Begin
$LN873@Begin:
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	movss	xmm0, DWORD PTR [eax+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm3, DWORD PTR [eax+6176]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm0, xmm0

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm3, DWORD PTR [edi+620]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm3, xmm0
$LN874@Begin:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5271 :                 const float rad = (window->TitleBarHeight() - PAD*2.0f) * 0.5f;

	subss	xmm3, DWORD PTR __real@40800000

; 5272 :                 if (CloseButton(window->GetID("#CLOSE"), window->Rect().GetTR() + ImVec2(-PAD - rad, PAD + rad), rad))

	movss	xmm1, DWORD PTR __real@c0000000
	lea	eax, DWORD PTR $T97[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 773  :     ImRect      Rect() const                            { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }

	movss	xmm0, DWORD PTR [edi+32]
	addss	xmm0, DWORD PTR [edi+24]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5272 :                 if (CloseButton(window->GetID("#CLOSE"), window->Rect().GetTR() + ImVec2(-PAD - rad, PAD + rad), rad))

	push	ecx
	mulss	xmm3, DWORD PTR __real@3f000000
	mov	ecx, edi
	movaps	xmm2, xmm3
	movss	DWORD PTR [esp], xmm3
	addss	xmm2, DWORD PTR __real@40000000
	subss	xmm1, xmm3
	push	eax
	push	0
	push	OFFSET $SG118301
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm2, DWORD PTR [edi+28]
	addss	xmm1, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T97[ebp+4], xmm2
	movss	DWORD PTR $T97[ebp], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5272 :                 if (CloseButton(window->GetID("#CLOSE"), window->Rect().GetTR() + ImVec2(-PAD - rad, PAD + rad), rad))

	call	?GetID@ImGuiWindow@@QAEIPBD0@Z		; ImGuiWindow::GetID
	push	eax
	call	?CloseButton@ImGui@@YA_NIABUImVec2@@M@Z	; ImGui::CloseButton
	add	esp, 12					; 0000000cH
	test	al, al
	je	SHORT $LN121@Begin

; 5273 :                     *p_open = false;

	mov	eax, DWORD PTR _p_open$[ebp]
	mov	BYTE PTR [eax], 0
$LN121@Begin:

; 5274 :             }
; 5275 : 
; 5276 :             window->DC.NavLayerCurrent--;

	dec	DWORD PTR [edi+272]

; 5281 :             ImVec2 text_max = window->Pos + ImVec2(window->Size.x, style.FramePadding.y*2 + text_size.y);

	lea	edx, DWORD PTR [esi+5320]

; 5283 :             clip_rect.Max = ImVec2(window->Pos.x + window->Size.x - (p_open ? title_bar_rect.GetHeight() - 3 : style.FramePadding.x), text_max.y); // Match the size of CloseWindowButton()

	cmp	DWORD PTR _p_open$[ebp], 0
	mov	eax, DWORD PTR _backup_item_options$1$[ebp]
	mov	DWORD PTR [edi+312], eax
	movss	xmm0, DWORD PTR [edx+40]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm2, DWORD PTR [edi+28]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5281 :             ImVec2 text_max = window->Pos + ImVec2(window->Size.x, style.FramePadding.y*2 + text_size.y);

	addss	xmm0, xmm0
	mov	eax, DWORD PTR [edi+24]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm1, DWORD PTR [edi+32]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm3, DWORD PTR [edi+24]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5280 :             ImVec2 text_min = window->Pos;

	mov	DWORD PTR _text_min$73[ebp], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm3, xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5281 :             ImVec2 text_max = window->Pos + ImVec2(window->Size.x, style.FramePadding.y*2 + text_size.y);

	addss	xmm0, DWORD PTR _text_size$37[ebp+4]
	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR _text_min$73[ebp+4], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm2, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _text_max$44[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5283 :             clip_rect.Max = ImVec2(window->Pos.x + window->Size.x - (p_open ? title_bar_rect.GetHeight() - 3 : style.FramePadding.x), text_max.y); // Match the size of CloseWindowButton()

	je	SHORT $LN189@Begin
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 247  :     float       GetHeight() const               { return Max.y-Min.y; }

	movss	xmm0, DWORD PTR _title_bar_rect$63[ebp+12]
	subss	xmm0, DWORD PTR _title_bar_rect$63[ebp+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5283 :             clip_rect.Max = ImVec2(window->Pos.x + window->Size.x - (p_open ? title_bar_rect.GetHeight() - 3 : style.FramePadding.x), text_max.y); // Match the size of CloseWindowButton()

	subss	xmm0, DWORD PTR __real@40400000
	jmp	SHORT $LN190@Begin
$LN189@Begin:
	movss	xmm0, DWORD PTR [edx+36]
$LN190@Begin:
	cmp	DWORD PTR tv7451[ebp], 0
	addss	xmm1, DWORD PTR [edi+24]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T96[ebp+4], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5283 :             clip_rect.Max = ImVec2(window->Pos.x + window->Size.x - (p_open ? title_bar_rect.GetHeight() - 3 : style.FramePadding.x), text_max.y); // Match the size of CloseWindowButton()

	subss	xmm1, xmm0

; 5284 :             float pad_left = (flags & ImGuiWindowFlags_NoCollapse) == 0 ? (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x) : style.FramePadding.x;

	movss	xmm0, DWORD PTR [edx+36]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T96[ebp], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5283 :             clip_rect.Max = ImVec2(window->Pos.x + window->Size.x - (p_open ? title_bar_rect.GetHeight() - 3 : style.FramePadding.x), text_max.y); // Match the size of CloseWindowButton()

	mov	eax, DWORD PTR $T96[ebp]
	mov	DWORD PTR _clip_rect$60[ebp+8], eax
	mov	eax, DWORD PTR $T96[ebp+4]
	mov	DWORD PTR _clip_rect$60[ebp+12], eax

; 5284 :             float pad_left = (flags & ImGuiWindowFlags_NoCollapse) == 0 ? (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x) : style.FramePadding.x;

	jne	SHORT $LN191@Begin
	movss	xmm2, DWORD PTR [esi+6172]
	addss	xmm2, xmm0
	addss	xmm2, DWORD PTR [edx+56]
	jmp	SHORT $LN192@Begin
$LN191@Begin:
	movaps	xmm2, xmm0
$LN192@Begin:

; 5285 :             float pad_right = (p_open != NULL) ? (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x) : style.FramePadding.x;

	cmp	DWORD PTR _p_open$[ebp], 0
	je	SHORT $LN193@Begin
	movss	xmm1, DWORD PTR [esi+6172]
	addss	xmm1, xmm0
	addss	xmm1, DWORD PTR [edx+56]
	jmp	SHORT $LN194@Begin
$LN193@Begin:
	movaps	xmm1, xmm0
$LN194@Begin:

; 5286 :             if (style.WindowTitleAlign.x > 0.0f) pad_right = ImLerp(pad_right, pad_left, style.WindowTitleAlign.x);

	movss	xmm4, DWORD PTR [edx+24]
	lea	ecx, DWORD PTR [edx+24]
	comiss	xmm4, DWORD PTR __real@00000000
	jbe	SHORT $LN122@Begin
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 135  : static inline float  ImLerp(float a, float b, float t)                          { return a + (b - a) * t; }

	movaps	xmm0, xmm2
	subss	xmm0, xmm1
	mulss	xmm0, xmm4
	addss	xmm1, xmm0
$LN122@Begin:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5287 :             text_min.x += pad_left;

	movss	xmm0, DWORD PTR _text_min$73[ebp]

; 5288 :             text_max.x -= pad_right;

	subss	xmm3, xmm1
	addss	xmm0, xmm2
	movss	DWORD PTR _text_max$44[ebp], xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T85[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5289 :             clip_rect.Min = ImVec2(text_min.x, window->Pos.y);

	mov	eax, DWORD PTR $T85[ebp]
	mov	DWORD PTR _clip_rect$60[ebp], eax
	movss	DWORD PTR _text_min$73[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR [edi+28]
	movss	DWORD PTR $T85[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5289 :             clip_rect.Min = ImVec2(text_min.x, window->Pos.y);

	mov	eax, DWORD PTR $T85[ebp+4]
	mov	DWORD PTR _clip_rect$60[ebp+4], eax

; 5290 :             RenderTextClipped(text_min, text_max, name, NULL, &text_size, style.WindowTitleAlign, &clip_rect);

	lea	eax, DWORD PTR _clip_rect$60[ebp]
	push	eax
	push	ecx
	lea	eax, DWORD PTR _text_size$37[ebp]
	push	eax
	push	0
	push	DWORD PTR _name$[ebp]
	lea	eax, DWORD PTR _text_max$44[ebp]
	push	eax
	lea	eax, DWORD PTR _text_min$73[ebp]
	push	eax
	call	?RenderTextClipped@ImGui@@YAXABUImVec2@@0PBD1PBU2@0PBUImRect@@@Z ; ImGui::RenderTextClipped
	add	esp, 28					; 0000001cH
$LN117@Begin:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	xmm0, DWORD PTR [edi+24]
	movss	xmm1, DWORD PTR [edi+28]
	movss	DWORD PTR $T59[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 773  :     ImRect      Rect() const                            { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }

	addss	xmm0, DWORD PTR [edi+32]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T59[ebp+4], xmm1
	movss	DWORD PTR $T59[ebp+8], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 773  :     ImRect      Rect() const                            { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }

	movss	xmm0, DWORD PTR [edi+36]
	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T59[ebp+12], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5294 :         window->WindowRectClipped = window->Rect();

	movups	xmm0, XMMWORD PTR $T59[ebp]
	movups	XMMWORD PTR [edi+488], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 260  :     void        Clip(ImRect& r) const           { r.Min.x = ImClamp(r.Min.x, Min.x, Max.x); r.Min.y = ImClamp(r.Min.y, Min.y, Max.y); r.Max.x = ImClamp(r.Max.x, Min.x, Max.x); r.Max.y = ImClamp(r.Max.y, Min.y, Max.y); }

	movss	xmm1, DWORD PTR [edi+488]
	movss	xmm0, DWORD PTR [edi+472]

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm0, xmm1
	ja	SHORT $LN930@Begin
	movss	xmm0, DWORD PTR [edi+480]
	minss	xmm0, xmm1
$LN930@Begin:

; 260  :     void        Clip(ImRect& r) const           { r.Min.x = ImClamp(r.Min.x, Min.x, Max.x); r.Min.y = ImClamp(r.Min.y, Min.y, Max.y); r.Max.x = ImClamp(r.Max.x, Min.x, Max.x); r.Max.y = ImClamp(r.Max.y, Min.y, Max.y); }

	movss	xmm1, DWORD PTR [edi+492]
	movss	DWORD PTR [edi+488], xmm0
	movss	xmm0, DWORD PTR [edi+476]

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm0, xmm1
	ja	SHORT $LN936@Begin
	movss	xmm0, DWORD PTR [edi+484]
	minss	xmm0, xmm1
$LN936@Begin:

; 260  :     void        Clip(ImRect& r) const           { r.Min.x = ImClamp(r.Min.x, Min.x, Max.x); r.Min.y = ImClamp(r.Min.y, Min.y, Max.y); r.Max.x = ImClamp(r.Max.x, Min.x, Max.x); r.Max.y = ImClamp(r.Max.y, Min.y, Max.y); }

	movss	xmm1, DWORD PTR [edi+496]
	movss	DWORD PTR [edi+492], xmm0
	movss	xmm0, DWORD PTR [edi+472]

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm0, xmm1
	ja	SHORT $LN942@Begin
	movss	xmm0, DWORD PTR [edi+480]
	minss	xmm0, xmm1
$LN942@Begin:

; 260  :     void        Clip(ImRect& r) const           { r.Min.x = ImClamp(r.Min.x, Min.x, Max.x); r.Min.y = ImClamp(r.Min.y, Min.y, Max.y); r.Max.x = ImClamp(r.Max.x, Min.x, Max.x); r.Max.y = ImClamp(r.Max.y, Min.y, Max.y); }

	movss	xmm1, DWORD PTR [edi+500]
	movss	DWORD PTR [edi+496], xmm0
	movss	xmm0, DWORD PTR [edi+476]

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm0, xmm1
	ja	SHORT $LN948@Begin
	movss	xmm0, DWORD PTR [edi+484]
	minss	xmm0, xmm1
$LN948@Begin:
	movss	xmm5, DWORD PTR __real@3f000000

; 260  :     void        Clip(ImRect& r) const           { r.Min.x = ImClamp(r.Min.x, Min.x, Max.x); r.Min.y = ImClamp(r.Min.y, Min.y, Max.y); r.Max.x = ImClamp(r.Max.x, Min.x, Max.x); r.Max.y = ImClamp(r.Max.y, Min.y, Max.y); }

	movss	DWORD PTR [edi+500], xmm0
$LN35@Begin:

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	test	BYTE PTR [edi+8], 1
	je	SHORT $LN953@Begin
	xorps	xmm1, xmm1
	jmp	SHORT $LN954@Begin
$LN953@Begin:
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	movss	xmm0, DWORD PTR [eax+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm1, DWORD PTR [eax+6176]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm0, xmm0

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm1, DWORD PTR [edi+620]

; 775  :     float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }

	addss	xmm1, xmm0
$LN954@Begin:

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	eax, DWORD PTR [edi+24]

; 776  :     ImRect      TitleBarRect() const                    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }

	movss	xmm2, DWORD PTR [edi+28]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5311 :     const float border_size = window->BorderSize;

	movss	xmm3, DWORD PTR [edi+128]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 776  :     ImRect      TitleBarRect() const                    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }

	addss	xmm2, xmm1

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _title_bar_rect$[ebp], eax
	mov	eax, DWORD PTR [edi+28]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5312 :     window->InnerRect.Min.x = title_bar_rect.Min.x;

	movss	xmm0, DWORD PTR _title_bar_rect$[ebp]
	movss	DWORD PTR [edi+504], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	test	DWORD PTR [edi+8], 1024			; 00000400H

; 240  :     ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}

	mov	DWORD PTR _title_bar_rect$[ebp+4], eax

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	je	SHORT $LN963@Begin
	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	movss	xmm0, DWORD PTR [eax+5360]

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm1, DWORD PTR [eax+6176]

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	addss	xmm0, xmm0

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm1, DWORD PTR [edi+620]

; 777  :     float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }

	addss	xmm1, xmm0
	jmp	SHORT $LN964@Begin
$LN963@Begin:
	xorps	xmm1, xmm1
$LN964@Begin:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5313 :     window->InnerRect.Min.y = title_bar_rect.Max.y + window->MenuBarHeight();

	addss	xmm2, xmm1

; 5324 :     PushClipRect(clip_rect.Min, clip_rect.Max, true);

	push	1
	movss	DWORD PTR [edi+508], xmm2
	movss	xmm0, DWORD PTR [edi+32]
	addss	xmm0, DWORD PTR [edi+24]
	subss	xmm0, DWORD PTR [edi+120]
	movss	DWORD PTR [edi+512], xmm0
	movss	xmm2, DWORD PTR [edi+36]
	addss	xmm2, DWORD PTR [edi+28]
	subss	xmm2, DWORD PTR [edi+124]
	movss	DWORD PTR [edi+516], xmm2
	addss	xmm2, xmm5
	movss	xmm0, DWORD PTR [edi+80]
	mulss	xmm0, xmm5
	subss	xmm2, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 140  : static inline float  ImFloor(float f)                                           { return (float)(int)f; }

	cvttss2si eax, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5320 :     clip_rect.Min.x = ImFloor(0.5f + window->InnerRect.Min.x + ImMax(border_size, ImFloor(window->WindowPadding.x*0.5f)));

	movss	xmm0, DWORD PTR [edi+504]
	addss	xmm0, xmm5
	movd	xmm1, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 140  : static inline float  ImFloor(float f)                                           { return (float)(int)f; }

	cvtdq2ps xmm1, xmm1
	maxss	xmm1, xmm3
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5320 :     clip_rect.Min.x = ImFloor(0.5f + window->InnerRect.Min.x + ImMax(border_size, ImFloor(window->WindowPadding.x*0.5f)));

	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 140  : static inline float  ImFloor(float f)                                           { return (float)(int)f; }

	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5320 :     clip_rect.Min.x = ImFloor(0.5f + window->InnerRect.Min.x + ImMax(border_size, ImFloor(window->WindowPadding.x*0.5f)));

	movss	DWORD PTR _clip_rect$[ebp], xmm0

; 5321 :     clip_rect.Min.y = ImFloor(0.5f + window->InnerRect.Min.y + border_size);

	movss	xmm0, DWORD PTR [edi+508]
	addss	xmm0, xmm5
	addss	xmm0, xmm3
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 140  : static inline float  ImFloor(float f)                                           { return (float)(int)f; }

	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5321 :     clip_rect.Min.y = ImFloor(0.5f + window->InnerRect.Min.y + border_size);

	movss	DWORD PTR _clip_rect$[ebp+4], xmm0

; 5322 :     clip_rect.Max.x = ImFloor(0.5f + window->InnerRect.Max.x - ImMax(border_size, ImFloor(window->WindowPadding.x*0.5f)));

	movss	xmm0, DWORD PTR [edi+512]
	addss	xmm0, xmm5
	subss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 140  : static inline float  ImFloor(float f)                                           { return (float)(int)f; }

	cvttss2si eax, xmm0
	movd	xmm0, eax
	cvttss2si eax, xmm2
	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5322 :     clip_rect.Max.x = ImFloor(0.5f + window->InnerRect.Max.x - ImMax(border_size, ImFloor(window->WindowPadding.x*0.5f)));

	movss	DWORD PTR _clip_rect$[ebp+8], xmm0
	movd	xmm0, eax

; 5324 :     PushClipRect(clip_rect.Min, clip_rect.Max, true);

	lea	eax, DWORD PTR _clip_rect$[ebp+8]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 140  : static inline float  ImFloor(float f)                                           { return (float)(int)f; }

	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 5324 :     PushClipRect(clip_rect.Min, clip_rect.Max, true);

	push	eax
	lea	eax, DWORD PTR _clip_rect$[ebp]
	push	eax
	movss	DWORD PTR _clip_rect$[ebp+12], xmm0
	call	?PushClipRect@ImGui@@YAXABUImVec2@@0_N@Z ; ImGui::PushClipRect
	mov	eax, DWORD PTR tv7611[ebp]
	add	esp, 12					; 0000000cH
	cmp	eax, DWORD PTR _current_frame$1$[ebp]

; 5325 : 
; 5326 :     // Clear 'accessed' flag last thing
; 5327 :     if (first_begin_of_the_frame)

	je	SHORT $LN123@Begin

; 5328 :         window->Accessed = false;

	mov	BYTE PTR [edi+134], 0
$LN123@Begin:

; 5329 :     window->BeginCount++;

	inc	DWORD PTR [edi+140]

; 5330 :     g.SetNextWindowSizeConstraint = false;
; 5331 : 
; 5332 :     // Child window can be out of sight and have "negative" clip windows.
; 5333 :     // Mark them as collapsed so commands are skipped earlier (we can't manually collapse because they have no title bar).
; 5334 :     if (flags & ImGuiWindowFlags_ChildWindow)

	mov	eax, DWORD PTR _flags$1$[ebp]
	mov	BYTE PTR [esi+6588], 0
	test	eax, 4194304				; 00400000H
	je	SHORT $LN126@Begin

; 5335 :     {
; 5336 :         IM_ASSERT((flags & ImGuiWindowFlags_NoTitleBar) != 0);
; 5337 :         window->Collapsed = parent_window && parent_window->Collapsed;

	mov	ecx, DWORD PTR _parent_window$1$[ebp]
	test	ecx, ecx
	je	SHORT $LN195@Begin
	cmp	BYTE PTR [ecx+135], 0
	je	SHORT $LN195@Begin
	mov	ecx, 1
	jmp	SHORT $LN196@Begin
$LN195@Begin:
	xor	ecx, ecx
$LN196@Begin:
	mov	BYTE PTR [edi+135], cl

; 5338 : 
; 5339 :         if (!(flags & ImGuiWindowFlags_AlwaysAutoResize) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)

	test	al, 64					; 00000040H
	jne	SHORT $LN125@Begin
	cmp	DWORD PTR [edi+152], 0
	jg	SHORT $LN125@Begin
	cmp	DWORD PTR [edi+156], 0
	jg	SHORT $LN125@Begin

; 5340 :             window->Collapsed |= (window->WindowRectClipped.Min.x >= window->WindowRectClipped.Max.x || window->WindowRectClipped.Min.y >= window->WindowRectClipped.Max.y);

	movss	xmm0, DWORD PTR [edi+488]
	comiss	xmm0, DWORD PTR [edi+496]
	jae	SHORT $LN197@Begin
	movss	xmm0, DWORD PTR [edi+492]
	comiss	xmm0, DWORD PTR [edi+500]
	jae	SHORT $LN197@Begin
	xor	eax, eax
	jmp	SHORT $LN198@Begin
$LN197@Begin:
	mov	eax, 1
$LN198@Begin:
	or	al, cl
	mov	BYTE PTR [edi+135], al
$LN125@Begin:

; 5341 : 
; 5342 :         // We also hide the window from rendering because we've already added its border to the command list.
; 5343 :         // (we could perform the check earlier in the function but it is simpler at this point)
; 5344 :         if (window->Collapsed)

	cmp	BYTE PTR [edi+135], 0
	je	SHORT $LN126@Begin

; 5345 :             window->Active = false;

	mov	BYTE PTR [edi+132], 0
$LN126@Begin:
	xorps	xmm0, xmm0

; 5346 :     }
; 5347 :     if (style.Alpha <= 0.0f)

	comiss	xmm0, DWORD PTR [esi+5320]
	jb	SHORT $LN127@Begin

; 5348 :         window->Active = false;

	mov	BYTE PTR [edi+132], 0
$LN127@Begin:

; 5349 : 
; 5350 :     // Return false if we don't intend to display anything to allow user to perform an early out optimization
; 5351 :     window->SkipItems = (window->Collapsed || !window->Active) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0;

	cmp	BYTE PTR [edi+135], 0
	jne	SHORT $LN199@Begin
	cmp	BYTE PTR [edi+132], 0
	jne	SHORT $LN200@Begin
$LN199@Begin:
	cmp	DWORD PTR [edi+152], 0
	jg	SHORT $LN200@Begin
	cmp	DWORD PTR [edi+156], 0
	jg	SHORT $LN200@Begin
	mov	eax, 1
	mov	BYTE PTR [edi+137], al
	test	al, al
	pop	edi
	sete	al
	pop	esi

; 5352 :     return !window->SkipItems;
; 5353 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN200@Begin:

; 5349 : 
; 5350 :     // Return false if we don't intend to display anything to allow user to perform an early out optimization
; 5351 :     window->SkipItems = (window->Collapsed || !window->Active) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0;

	xor	eax, eax
	mov	BYTE PTR [edi+137], al
	test	al, al
	pop	edi
	sete	al
	pop	esi

; 5352 :     return !window->SkipItems;
; 5353 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Begin@ImGui@@YA_NPBDPA_NABUImVec2@@MH@Z ENDP		; ImGui::Begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 8
_name$ = 8						; size = 4
_p_open$ = 12						; size = 4
_flags$ = 16						; size = 4
?Begin@ImGui@@YA_NPBDPA_NH@Z PROC			; ImGui::Begin

; 4734 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 4735 :     return ImGui::Begin(name, p_open, ImVec2(0.f, 0.f), -1.0f, flags);

	push	DWORD PTR _flags$[ebp]
	lea	eax, DWORD PTR $T1[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4735 :     return ImGui::Begin(name, p_open, ImVec2(0.f, 0.f), -1.0f, flags);

	push	ecx
	mov	DWORD PTR [esp], -1082130432		; bf800000H
	push	eax
	push	DWORD PTR _p_open$[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T1[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 4735 :     return ImGui::Begin(name, p_open, ImVec2(0.f, 0.f), -1.0f, flags);

	push	DWORD PTR _name$[ebp]
	call	?Begin@ImGui@@YA_NPBDPA_NABUImVec2@@MH@Z ; ImGui::Begin
	add	esp, 20					; 00000014H

; 4736 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Begin@ImGui@@YA_NPBDPA_NH@Z ENDP			; ImGui::Begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
_input_source_names$1 = -12				; size = 12
_p_open$ = 8						; size = 4
?ShowMetricsWindow@ImGui@@YAXPA_N@Z PROC		; ImGui::ShowMetricsWindow

; 10812: {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 10813:     if (ImGui::Begin("ImGui Metrics", p_open))

	push	0
	push	DWORD PTR _p_open$[ebp]
	push	OFFSET $SG122785
	call	?Begin@ImGui@@YA_NPBDPA_NH@Z		; ImGui::Begin
	add	esp, 12					; 0000000cH
	test	al, al
	je	$LN11@ShowMetric

; 10814:     {
; 10815:         ImGui::Text("ImGui %s", ImGui::GetVersion());

	push	esi
	push	edi
	call	?GetVersion@ImGui@@YAPBDXZ		; ImGui::GetVersion
	push	eax
	push	OFFSET $SG122786
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 10816:         ImGui::Text("Application average %.3f ms/frame (%.1f FPS)", 1000.0f / ImGui::GetIO().Framerate, ImGui::GetIO().Framerate);

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	movss	xmm1, DWORD PTR [eax+848]
	cvtps2pd xmm0, xmm1
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movss	xmm0, DWORD PTR __real@447a0000
	divss	xmm0, xmm1
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG122787
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 10817:         ImGui::Text("%d vertices, %d indices (%d triangles)", ImGui::GetIO().MetricsRenderVertices, ImGui::GetIO().MetricsRenderIndices, ImGui::GetIO().MetricsRenderIndices / 3);

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	edi, eax
	mov	eax, 1431655766				; 55555556H
	mov	esi, DWORD PTR [edi+860]
	imul	esi
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	push	ecx
	push	esi
	push	DWORD PTR [edi+856]
	push	OFFSET $SG122788
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 10818:         ImGui::Text("%d allocations", ImGui::GetIO().MetricsAllocs);

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	eax, DWORD PTR [eax+852]
	push	eax
	push	OFFSET $SG122789
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 10819:         ImGui::Text("sizeof(ImGuiContext) = %u, sizeof(ImGuiWindow) = %u", (int)sizeof(ImGuiContext), (int)sizeof(ImGuiWindow));

	push	668					; 0000029cH
	push	15192					; 00003b58H
	push	OFFSET $SG122790
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 10820:         static bool show_clip_rects = true;
; 10821:         ImGui::Checkbox("Show clipping rectangles when hovering a ImDrawCmd", &show_clip_rects);

	push	OFFSET ?show_clip_rects@?4??ShowMetricsWindow@ImGui@@YAXPA_N@Z@4_NA
	push	OFFSET $SG122791
	call	?Checkbox@ImGui@@YA_NPBDPA_N@Z		; ImGui::Checkbox
	add	esp, 64					; 00000040H

; 10822:         ImGui::Separator();

	call	?Separator@ImGui@@YAXXZ			; ImGui::Separator

; 10823: 
; 10824:         struct Funcs
; 10825:         {
; 10826:             static void NodeDrawList(ImDrawList* draw_list, const char* label)
; 10827:             {
; 10828:                 bool node_open = ImGui::TreeNode(draw_list, "%s: '%s' %d vtx, %d indices, %d cmds", label, draw_list->_OwnerName ? draw_list->_OwnerName : "", draw_list->VtxBuffer.Size, draw_list->IdxBuffer.Size, draw_list->CmdBuffer.Size);
; 10829:                 if (draw_list == ImGui::GetWindowDrawList())
; 10830:                 {
; 10831:                     ImGui::SameLine();
; 10832:                     ImGui::TextColored(ImColor(255,100,100), "CURRENTLY APPENDING"); // Can't display stats for active draw list! (we don't have the data double-buffered)
; 10833:                     if (node_open) ImGui::TreePop();
; 10834:                     return;
; 10835:                 }
; 10836:                 if (!node_open)
; 10837:                     return;
; 10838: 
; 10839:                 ImDrawList* overlay_draw_list = &GImGui->OverlayDrawList;   // Render additional visuals into the top-most draw list
; 10840:                 overlay_draw_list->PushClipRectFullScreen();
; 10841:                 int elem_offset = 0;
; 10842:                 for (const ImDrawCmd* pcmd = draw_list->CmdBuffer.begin(); pcmd < draw_list->CmdBuffer.end(); elem_offset += pcmd->ElemCount, pcmd++)
; 10843:                 {
; 10844:                     if (pcmd->UserCallback)
; 10845:                     {
; 10846:                         ImGui::BulletText("Callback %p, user_data %p", pcmd->UserCallback, pcmd->UserCallbackData);
; 10847:                         continue;
; 10848:                     }
; 10849:                     ImDrawIdx* idx_buffer = (draw_list->IdxBuffer.Size > 0) ? draw_list->IdxBuffer.Data : NULL;
; 10850:                     bool pcmd_node_open = ImGui::TreeNode((void*)(pcmd - draw_list->CmdBuffer.begin()), "Draw %-4d %s vtx, tex = %p, clip_rect = (%.0f,%.0f)..(%.0f,%.0f)", pcmd->ElemCount, draw_list->IdxBuffer.Size > 0 ? "indexed" : "non-indexed", pcmd->TextureId, pcmd->ClipRect.x, pcmd->ClipRect.y, pcmd->ClipRect.z, pcmd->ClipRect.w);
; 10851:                     if (show_clip_rects && ImGui::IsItemHovered())
; 10852:                     {
; 10853:                         ImRect clip_rect = pcmd->ClipRect;
; 10854:                         ImRect vtxs_rect;
; 10855:                         for (int i = elem_offset; i < elem_offset + (int)pcmd->ElemCount; i++)
; 10856:                             vtxs_rect.Add(draw_list->VtxBuffer[idx_buffer ? idx_buffer[i] : i].pos);
; 10857:                         clip_rect.Floor(); overlay_draw_list->AddRect(clip_rect.Min, clip_rect.Max, IM_COL32(255,255,0,255));
; 10858:                         vtxs_rect.Floor(); overlay_draw_list->AddRect(vtxs_rect.Min, vtxs_rect.Max, IM_COL32(255,0,255,255));
; 10859:                     }
; 10860:                     if (!pcmd_node_open)
; 10861:                         continue;
; 10862:                     ImGuiListClipper clipper(pcmd->ElemCount/3); // Manually coarse clip our print out of individual vertices to save CPU, only items that may be visible.
; 10863:                     while (clipper.Step())
; 10864:                         for (int prim = clipper.DisplayStart, vtx_i = elem_offset + clipper.DisplayStart*3; prim < clipper.DisplayEnd; prim++)
; 10865:                         {
; 10866:                             char buf[300], *buf_p = buf;
; 10867:                             ImVec2 triangles_pos[3];
; 10868:                             for (int n = 0; n < 3; n++, vtx_i++)
; 10869:                             {
; 10870:                                 ImDrawVert& v = draw_list->VtxBuffer[idx_buffer ? idx_buffer[vtx_i] : vtx_i];
; 10871:                                 triangles_pos[n] = v.pos;
; 10872:                                 buf_p += sprintf(buf_p, "%s %04d { pos = (%8.2f,%8.2f), uv = (%.6f,%.6f), col = %08X }\n", (n == 0) ? "vtx" : "   ", vtx_i, v.pos.x, v.pos.y, v.uv.x, v.uv.y, v.col);
; 10873:                             }
; 10874:                             ImGui::Selectable(buf, false);
; 10875:                             if (ImGui::IsItemHovered())
; 10876:                                 overlay_draw_list->AddPolyline(triangles_pos, 3, IM_COL32(255,255,0,255), true, 1.0f, false);  // Add triangle without AA, more readable for large-thin triangle
; 10877:                         }
; 10878:                     ImGui::TreePop();
; 10879:                 }
; 10880:                 overlay_draw_list->PopClipRect();
; 10881:                 ImGui::TreePop();
; 10882:             }
; 10883: 
; 10884:             static void NodeWindows(ImVector<ImGuiWindow*>& windows, const char* label)
; 10885:             {
; 10886:                 if (!ImGui::TreeNode(label, "%s (%d)", label, windows.Size))
; 10887:                     return;
; 10888:                 for (int i = 0; i < windows.Size; i++)
; 10889:                     Funcs::NodeWindow(windows[i], "Window");
; 10890:                 ImGui::TreePop();
; 10891:             }
; 10892: 
; 10893:             static void NodeWindow(ImGuiWindow* window, const char* label)
; 10894:             {
; 10895:                 if (!ImGui::TreeNode(window, "%s '%s', %d @ 0x%p", label, window->Name, window->Active || window->WasActive, window))
; 10896:                     return;
; 10897:                 NodeDrawList(window->DrawList, "DrawList");
; 10898:                 ImGui::BulletText("Pos: (%.1f,%.1f)", window->Pos.x, window->Pos.y);
; 10899:                 ImGui::BulletText("Size: (%.1f,%.1f), SizeContents (%.1f,%.1f)", window->Size.x, window->Size.y, window->SizeContents.x, window->SizeContents.y);
; 10900:                 ImGui::BulletText("Scroll: (%.2f,%.2f)", window->Scroll.x, window->Scroll.y);
; 10901:                 ImGui::BulletText("NavLastId: 0x%08x, NavLayerActiveFlags: %02X", window->NavLastId, window->DC.NavLayerActiveFlags);
; 10902:                 if (window->RootWindow != window) NodeWindow(window->RootWindow, "RootWindow");
; 10903:                 if (window->DC.ChildWindows.Size > 0) NodeWindows(window->DC.ChildWindows, "ChildWindows");
; 10904:                 ImGui::BulletText("Storage: %d bytes", window->StateStorage.Data.Size * (int)sizeof(ImGuiStorage::Pair));
; 10905:                 ImGui::TreePop();
; 10906:             }
; 10907:         };
; 10908: 
; 10909:         ImGuiContext& g = *GImGui;                // Access private state

	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui

; 10910:         Funcs::NodeWindows(g.Windows, "Windows");

	push	OFFSET $SG122792
	lea	eax, DWORD PTR [esi+6204]
	push	eax
	call	?NodeWindows@Funcs@?4??ShowMetricsWindow@ImGui@@YAXPA_N@Z@SAXAAV?$ImVector@PAUImGuiWindow@@@@PBD@Z ; `ImGui::ShowMetricsWindow'::`5'::Funcs::NodeWindows

; 10911:         if (ImGui::TreeNode("DrawList", "Active DrawLists (%d)", g.RenderDrawLists[0].Size))

	push	DWORD PTR [esi+6616]
	push	OFFSET $SG122794
	push	OFFSET $SG122795
	call	?TreeNode@ImGui@@YA_NPBD0ZZ		; ImGui::TreeNode
	add	esp, 20					; 00000014H
	test	al, al
	je	SHORT $LN9@ShowMetric

; 10912:         {
; 10913:             for (int i = 0; i < g.RenderDrawLists[0].Size; i++)

	xor	edi, edi
	cmp	DWORD PTR [esi+6616], edi
	jle	SHORT $LN3@ShowMetric
	npad	11
$LL4@ShowMetric:

; 10914:                 Funcs::NodeDrawList(g.RenderDrawLists[0][i], "DrawList");

	mov	eax, DWORD PTR [esi+6624]
	push	OFFSET $SG122796
	push	DWORD PTR [eax+edi*4]
	call	?NodeDrawList@Funcs@?4??ShowMetricsWindow@ImGui@@YAXPA_N@Z@SAXPAUImDrawList@@PBD@Z ; `ImGui::ShowMetricsWindow'::`5'::Funcs::NodeDrawList
	inc	edi
	add	esp, 8
	cmp	edi, DWORD PTR [esi+6616]
	jl	SHORT $LL4@ShowMetric
$LN3@ShowMetric:

; 10915:             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN9@ShowMetric:

; 10916:         }
; 10917:         if (ImGui::TreeNode("Popups", "Open Popups Stack (%d)", g.OpenPopupStack.Size))

	push	DWORD PTR [esi+6356]
	push	OFFSET $SG122798
	push	OFFSET $SG122799
	call	?TreeNode@ImGui@@YA_NPBD0ZZ		; ImGui::TreeNode
	add	esp, 12					; 0000000cH
	test	al, al
	je	$LN10@ShowMetric

; 10918:         {
; 10919:             for (int i = 0; i < g.OpenPopupStack.Size; i++)

	push	ebx
	xor	ebx, ebx
	cmp	DWORD PTR [esi+6356], ebx
	jle	SHORT $LN6@ShowMetric
	xor	edi, edi
$LL7@ShowMetric:

; 10920:             {
; 10921:                 ImGuiWindow* window = g.OpenPopupStack[i].Window;

	mov	eax, DWORD PTR [esi+6364]
	mov	eax, DWORD PTR [edi+eax+4]

; 10922:                 ImGui::BulletText("PopupID: %08x, Window: '%s'%s%s", g.OpenPopupStack[i].PopupId, window ? window->Name : "NULL", window && (window->Flags & ImGuiWindowFlags_ChildWindow) ? " ChildWindow" : "", window && (window->Flags & ImGuiWindowFlags_ChildMenu) ? " ChildMenu" : "");

	test	eax, eax
	je	SHORT $LN13@ShowMetric
	test	DWORD PTR [eax+8], 134217728		; 08000000H
	mov	edx, OFFSET $SG122800
	jne	SHORT $LN14@ShowMetric
$LN13@ShowMetric:
	mov	edx, OFFSET $SG122801
$LN14@ShowMetric:
	test	eax, eax
	je	SHORT $LN15@ShowMetric
	test	DWORD PTR [eax+8], 4194304		; 00400000H
	mov	ecx, OFFSET $SG122802
	jne	SHORT $LN16@ShowMetric
$LN15@ShowMetric:
	mov	ecx, OFFSET $SG122803
$LN16@ShowMetric:
	test	eax, eax
	je	SHORT $LN17@ShowMetric
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN18@ShowMetric
$LN17@ShowMetric:
	mov	eax, OFFSET $SG122804
$LN18@ShowMetric:
	push	edx
	push	ecx
	push	eax
	mov	eax, DWORD PTR [esi+6364]
	push	DWORD PTR [edi+eax]
	push	OFFSET $SG122805
	call	?BulletText@ImGui@@YAXPBDZZ		; ImGui::BulletText
	inc	ebx
	add	esp, 20					; 00000014H
	add	edi, 32					; 00000020H
	cmp	ebx, DWORD PTR [esi+6356]
	jl	SHORT $LL7@ShowMetric
$LN6@ShowMetric:

; 10923:             }
; 10924:             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
	pop	ebx
$LN10@ShowMetric:

; 10925:         }
; 10926:         if (ImGui::TreeNode("Basic state"))

	push	OFFSET $SG122807
	call	?TreeNode@ImGui@@YA_NPBD@Z		; ImGui::TreeNode
	add	esp, 4
	test	al, al
	je	$LN41@ShowMetric

; 10927:         {
; 10928:             const char* input_source_names[] = { "None", "Mouse", "Nav" }; IM_ASSERT(IM_ARRAYSIZE(input_source_names) == ImGuiInputSource_Count_);
; 10929:             ImGui::Text("HoveredWindow: '%s'", g.HoveredWindow ? g.HoveredWindow->Name : "NULL");

	mov	eax, DWORD PTR [esi+6244]
	mov	DWORD PTR _input_source_names$1[ebp], OFFSET $SG122808
	mov	DWORD PTR _input_source_names$1[ebp+4], OFFSET $SG122809
	mov	DWORD PTR _input_source_names$1[ebp+8], OFFSET $SG122810
	test	eax, eax
	je	SHORT $LN19@ShowMetric
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN20@ShowMetric
$LN19@ShowMetric:
	mov	eax, OFFSET $SG122811
$LN20@ShowMetric:
	push	eax
	push	OFFSET $SG122812
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 10930:             ImGui::Text("HoveredRootWindow: '%s'", g.HoveredRootWindow ? g.HoveredRootWindow->Name : "NULL");

	mov	eax, DWORD PTR [esi+6248]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN21@ShowMetric
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN22@ShowMetric
$LN21@ShowMetric:
	mov	eax, OFFSET $SG122813
$LN22@ShowMetric:
	push	eax
	push	OFFSET $SG122814
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 10931:             ImGui::Text("HoveredId: 0x%08X/0x%08X", g.HoveredId, g.HoveredIdPreviousFrame); // Data is "in-flight" so depending on when the Metrics window is called we may see current frame information or not

	push	DWORD PTR [esi+6260]
	push	DWORD PTR [esi+6252]
	push	OFFSET $SG122815
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 10932:             ImGui::Text("ActiveId: 0x%08X/0x%08X, ActiveIdSource: %s", g.ActiveId, g.ActiveIdPreviousFrame, input_source_names[g.ActiveIdSource]);

	mov	eax, DWORD PTR [esi+6292]
	push	DWORD PTR _input_source_names$1[ebp+eax*4]
	push	DWORD PTR [esi+6268]
	push	DWORD PTR [esi+6264]
	push	OFFSET $SG122816
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 10933:             ImGui::Text("ActiveIdWindow: '%s", g.ActiveIdWindow ? g.ActiveIdWindow->Name : "NULL");

	mov	eax, DWORD PTR [esi+6288]
	add	esp, 36					; 00000024H
	test	eax, eax
	je	SHORT $LN23@ShowMetric
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN24@ShowMetric
$LN23@ShowMetric:
	mov	eax, OFFSET $SG122817
$LN24@ShowMetric:
	push	eax
	push	OFFSET $SG122818
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 10934:             ImGui::Text("NavWindow: '%s', NavId: 0x%08X, NavLayer: %d", g.NavWindow ? g.NavWindow->Name : "NULL", g.NavId, g.NavLayer);

	mov	eax, DWORD PTR [esi+6380]
	add	esp, 8
	test	eax, eax
	je	SHORT $LN25@ShowMetric
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN26@ShowMetric
$LN25@ShowMetric:
	mov	eax, OFFSET $SG122819
$LN26@ShowMetric:
	push	DWORD PTR [esi+6444]
	push	DWORD PTR [esi+6384]
	push	eax
	push	OFFSET $SG122820
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	movss	xmm0, DWORD PTR [esi+6412]

; 10935:             ImGui::Text("NavRefRectRel: (%.1f,%.1f)(%.1f,%.1f)", g.NavRefRectRel.Min.x, g.NavRefRectRel.Min.y, g.NavRefRectRel.Max.x, g.NavRefRectRel.Max.y);

	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR [esi+6408]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 16					; 00000010H
	movss	xmm0, DWORD PTR [esi+6404]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp+8], xmm0
	movss	xmm0, DWORD PTR [esi+6400]
	cvtps2pd xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG122821
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 10936:             ImGui::Text("NavUsable: %d, NavActive: %d", g.IO.NavUsable, g.IO.NavActive);

	movzx	eax, BYTE PTR [esi+849]
	push	eax
	movzx	eax, BYTE PTR [esi+848]
	push	eax
	push	OFFSET $SG122822
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text

; 10937:             ImGui::Text("NavDisableHighlight: %d, NavDisableMouseHover: %d", g.NavDisableHighlight, g.NavDisableMouseHover);

	movzx	eax, BYTE PTR [esi+6455]
	push	eax
	movzx	eax, BYTE PTR [esi+6454]
	push	eax
	push	OFFSET $SG122823
	call	?Text@ImGui@@YAXPBDZZ			; ImGui::Text
	add	esp, 60					; 0000003cH

; 10938:             ImGui::TreePop();

	call	?TreePop@ImGui@@YAXXZ			; ImGui::TreePop
$LN41@ShowMetric:
	pop	edi
	pop	esi
$LN11@ShowMetric:

; 10939:         }
; 10940:     }
; 10941:     ImGui::End();

	call	?End@ImGui@@YAXXZ			; ImGui::End

; 10942: }

	mov	esp, ebp
	pop	ebp
	ret	0
?ShowMetricsWindow@ImGui@@YAXPA_N@Z ENDP		; ImGui::ShowMetricsWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?Shutdown@ImGui@@YAXXZ PROC				; ImGui::Shutdown

; 3125 : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?Shutdown@ImGui@@YAXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	esi

; 3126 :     ImGuiContext& g = *GImGui;

	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	push	edi

; 3127 : 
; 3128 :     // The fonts atlas can be used prior to calling NewFrame(), so we clear it even if g.Initialized is FALSE (which would happen if we never called NewFrame)
; 3129 :     if (g.IO.Fonts) // Testing for NULL to allow user to NULLify in case of running Shutdown() on multiple contexts. Bit hacky.

	mov	ecx, DWORD PTR [esi+132]
	test	ecx, ecx
	je	SHORT $LN11@Shutdown

; 3130 :         g.IO.Fonts->Clear();

	call	?Clear@ImFontAtlas@@QAEXXZ		; ImFontAtlas::Clear
$LN11@Shutdown:

; 3131 : 
; 3132 :     // Cleanup of other data are conditional on actually having used ImGui.
; 3133 :     if (!g.Initialized)

	cmp	BYTE PTR [esi], 0
	je	$LN1@Shutdown

; 3134 :         return;
; 3135 : 
; 3136 :     //SaveIniSettingsToDisk(g.IO.IniFilename);
; 3137 : 
; 3138 :     for (int i = 0; i < g.Windows.Size; i++)

	xor	edi, edi
	cmp	DWORD PTR [esi+6204], edi
	jle	SHORT $LN3@Shutdown
	npad	11
$LL4@Shutdown:

; 3139 :     {
; 3140 :         g.Windows[i]->~ImGuiWindow();

	mov	eax, DWORD PTR [esi+6212]
	mov	ecx, DWORD PTR [eax+edi*4]
	call	??1ImGuiWindow@@QAE@XZ			; ImGuiWindow::~ImGuiWindow

; 3141 :         ImGui::MemFree(g.Windows[i]);

	mov	eax, DWORD PTR [esi+6212]
	push	DWORD PTR [eax+edi*4]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	inc	edi
	add	esp, 4
	cmp	edi, DWORD PTR [esi+6204]
	jl	SHORT $LL4@Shutdown
$LN3@Shutdown:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	mov	eax, DWORD PTR [esi+6212]
	test	eax, eax
	je	SHORT $LN25@Shutdown
	push	eax
	mov	DWORD PTR [esi+6208], 0
	mov	DWORD PTR [esi+6204], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+6212], 0
$LN25@Shutdown:
	mov	eax, DWORD PTR [esi+6224]
	test	eax, eax
	je	SHORT $LN28@Shutdown
	push	eax
	mov	DWORD PTR [esi+6220], 0
	mov	DWORD PTR [esi+6216], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+6224], 0
$LN28@Shutdown:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3145 :     g.CurrentWindow = NULL;

	mov	DWORD PTR [esi+6240], 0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	mov	eax, DWORD PTR [esi+6236]
	test	eax, eax
	je	SHORT $LN31@Shutdown
	push	eax
	mov	DWORD PTR [esi+6232], 0
	mov	DWORD PTR [esi+6228], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+6236], 0
$LN31@Shutdown:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3152 :     for (int i = 0; i < g.Settings.Size; i++)

	xor	edi, edi
	mov	DWORD PTR [esi+6380], 0
	mov	DWORD PTR [esi+6244], 0
	mov	DWORD PTR [esi+6248], 0
	mov	DWORD PTR [esi+6288], 0
	mov	DWORD PTR [esi+6296], 0
	cmp	DWORD PTR [esi+6304], edi
	jle	SHORT $LN6@Shutdown

; 3146 :     g.CurrentWindowStack.clear();
; 3147 :     g.NavWindow = NULL;

	xor	ebx, ebx
	npad	13
$LL7@Shutdown:

; 3153 :         ImGui::MemFree(g.Settings[i].Name);

	mov	eax, DWORD PTR [esi+6312]
	push	DWORD PTR [ebx+eax]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	inc	edi
	lea	ebx, DWORD PTR [ebx+28]
	add	esp, 4
	cmp	edi, DWORD PTR [esi+6304]
	jl	SHORT $LL7@Shutdown
$LN6@Shutdown:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	mov	eax, DWORD PTR [esi+6312]
	test	eax, eax
	je	SHORT $LN36@Shutdown
	push	eax
	mov	DWORD PTR [esi+6308], 0
	mov	DWORD PTR [esi+6304], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+6312], 0
$LN36@Shutdown:
	mov	eax, DWORD PTR [esi+6328]
	test	eax, eax
	je	SHORT $LN39@Shutdown
	push	eax
	mov	DWORD PTR [esi+6324], 0
	mov	DWORD PTR [esi+6320], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+6328], 0
$LN39@Shutdown:
	mov	eax, DWORD PTR [esi+6340]
	test	eax, eax
	je	SHORT $LN42@Shutdown
	push	eax
	mov	DWORD PTR [esi+6336], 0
	mov	DWORD PTR [esi+6332], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+6340], 0
$LN42@Shutdown:
	mov	eax, DWORD PTR [esi+6352]
	test	eax, eax
	je	SHORT $LN45@Shutdown
	push	eax
	mov	DWORD PTR [esi+6348], 0
	mov	DWORD PTR [esi+6344], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+6352], 0
$LN45@Shutdown:
	mov	eax, DWORD PTR [esi+6364]
	test	eax, eax
	je	SHORT $LN48@Shutdown
	push	eax
	mov	DWORD PTR [esi+6360], 0
	mov	DWORD PTR [esi+6356], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+6364], 0
$LN48@Shutdown:
	mov	eax, DWORD PTR [esi+6376]
	test	eax, eax
	je	SHORT $LN51@Shutdown
	push	eax
	mov	DWORD PTR [esi+6372], 0
	mov	DWORD PTR [esi+6368], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+6376], 0
$LN51@Shutdown:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3160 :     g.SetNextWindowSizeConstraintCallback = NULL;

	mov	DWORD PTR [esi+6580], 0
	lea	edi, DWORD PTR [esi+6624]

; 3161 :     g.SetNextWindowSizeConstraintCallbackUserData = NULL;

	mov	DWORD PTR [esi+6584], 0
	mov	ebx, 3
$LL10@Shutdown:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN8@Shutdown
	push	eax
	mov	DWORD PTR [edi-4], 0
	mov	DWORD PTR [edi-8], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [edi], 0
$LN8@Shutdown:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3162 :     for (int i = 0; i < IM_ARRAYSIZE(g.RenderDrawLists); i++)

	add	edi, 12					; 0000000cH
	sub	ebx, 1
	jne	SHORT $LL10@Shutdown

; 3163 :         g.RenderDrawLists[i].clear();
; 3164 :     g.OverlayDrawList.ClearFreeMemory();

	lea	ecx, DWORD PTR [esi+6656]
	call	?ClearFreeMemory@ImDrawList@@QAEXXZ	; ImDrawList::ClearFreeMemory

; 3165 :     g.ColorEditModeStorage.Clear();

	lea	ecx, DWORD PTR [esi+10504]
	call	?Clear@ImGuiStorage@@QAEXXZ		; ImGuiStorage::Clear
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 915  :     inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }

	mov	eax, DWORD PTR [esi+11580]
	test	eax, eax
	je	SHORT $LN57@Shutdown
	push	eax
	mov	DWORD PTR [esi+11576], ebx
	mov	DWORD PTR [esi+11572], ebx
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+11580], ebx
$LN57@Shutdown:
	mov	eax, DWORD PTR [esi+7144]
	test	eax, eax
	je	SHORT $LN60@Shutdown
	push	eax
	mov	DWORD PTR [esi+7140], 0
	mov	DWORD PTR [esi+7136], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+7144], 0
$LN60@Shutdown:
	mov	eax, DWORD PTR [esi+7156]
	test	eax, eax
	je	SHORT $LN63@Shutdown
	push	eax
	mov	DWORD PTR [esi+7152], 0
	mov	DWORD PTR [esi+7148], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+7156], 0
$LN63@Shutdown:
	mov	eax, DWORD PTR [esi+7168]
	test	eax, eax
	je	SHORT $LN66@Shutdown
	push	eax
	mov	DWORD PTR [esi+7164], 0
	mov	DWORD PTR [esi+7160], 0
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
	mov	DWORD PTR [esi+7168], 0
$LN66@Shutdown:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3171 :     if (g.LogFile && g.LogFile != stdout)

	cmp	DWORD PTR [esi+11604], 0
	je	SHORT $LN13@Shutdown
	mov	edi, DWORD PTR [esi+11604]
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	edi, eax
	je	SHORT $LN13@Shutdown

; 3172 :     {
; 3173 :         fclose(g.LogFile);

	push	edi
	call	DWORD PTR __imp__fclose
	add	esp, 4

; 3174 :         g.LogFile = NULL;

	mov	DWORD PTR [esi+11604], 0
$LN13@Shutdown:

; 3175 :     }
; 3176 :     if (g.LogClipboard)

	mov	eax, DWORD PTR [esi+11608]
	test	eax, eax
	je	SHORT $LN14@Shutdown
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN76@Shutdown
	push	eax
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN76@Shutdown:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3179 :         ImGui::MemFree(g.LogClipboard);

	push	DWORD PTR [esi+11608]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 906  :     ~ImVector()                 { if (Data) ImGui::MemFree(Data); }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3179 :         ImGui::MemFree(g.LogClipboard);

	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree
	add	esp, 4
$LN14@Shutdown:

; 3180 :     }
; 3181 : 
; 3182 :     g.Initialized = false;

	mov	BYTE PTR [esi], 0
$LN1@Shutdown:

; 3183 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__ehhandler$?Shutdown@ImGui@@YAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?Shutdown@ImGui@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Shutdown@ImGui@@YAXXZ ENDP				; ImGui::Shutdown
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T3 = -44						; size = 8
$T4 = -44						; size = 8
$T5 = -44						; size = 8
$T6 = -44						; size = 8
$T7 = -36						; size = 8
$T8 = -36						; size = 8
_flattened_size$1$ = -28				; size = 4
tv821 = -28						; size = 4
_pos$9 = -24						; size = 8
_new_data$1$ = -20					; size = 4
_size$10 = -16						; size = 8
tv887 = -12						; size = 4
_g$1$ = -8						; size = 4
_new_capacity$1$ = -4					; size = 4
tv901 = -4						; size = 4
tv889 = -4						; size = 4
_tex_id$11 = -4						; size = 4
?Render@ImGui@@YAXXZ PROC				; ImGui::Render

; 3487 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	esi

; 3488 :     ImGuiContext& g = *GImGui;

	mov	esi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	DWORD PTR _g$1$[ebp], esi

; 3489 :     IM_ASSERT(g.Initialized);   // Forgot to call ImGui::NewFrame()
; 3490 : 
; 3491 :     if (g.FrameCountEnded != g.FrameCount)

	mov	eax, DWORD PTR [esi+6196]
	cmp	eax, DWORD PTR [esi+6192]
	je	SHORT $LN14@Render

; 3492 :         ImGui::EndFrame();

	call	?EndFrame@ImGui@@YAXXZ			; ImGui::EndFrame
$LN14@Render:

; 3493 :     g.FrameCountRendered = g.FrameCount;
; 3494 : 
; 3495 :     // Skip render altogether if alpha is 0.0
; 3496 :     // Note that vertex buffers have been created and are wasted, so it is best practice that you don't create windows in the first place, or consistently respond to Begin() returning false.
; 3497 :     if (g.Style.Alpha > 0.0f)

	movss	xmm0, DWORD PTR [esi+5320]
	comiss	xmm0, DWORD PTR __real@00000000
	mov	eax, DWORD PTR [esi+6192]
	mov	DWORD PTR [esi+6200], eax
	jbe	$LN21@Render

; 3498 :     {
; 3499 :         // Gather windows to render
; 3500 :         g.IO.MetricsRenderVertices = g.IO.MetricsRenderIndices = g.IO.MetricsActiveWindows = 0;

	push	ebx
	push	edi
	mov	DWORD PTR [esi+868], 0
	lea	edi, DWORD PTR [esi+6616]
	mov	DWORD PTR [esi+864], 0
	mov	ebx, 3
	mov	DWORD PTR [esi+860], 0
$LL4@Render:

; 3501 :         for (int i = 0; i < IM_ARRAYSIZE(g.RenderDrawLists); i++)
; 3502 :             g.RenderDrawLists[i].resize(0);

	push	0
	mov	ecx, edi
	call	?resize@?$ImVector@PAUImDrawList@@@@QAEXH@Z ; ImVector<ImDrawList *>::resize
	add	edi, 12					; 0000000cH
	sub	ebx, 1
	jne	SHORT $LL4@Render

; 3503 :         for (int i = 0; i != g.Windows.Size; i++)

	xor	edi, edi
	cmp	DWORD PTR [esi+6204], edi
	je	SHORT $LN6@Render
	npad	4
$LL7@Render:

; 3504 :         {
; 3505 :             ImGuiWindow* window = g.Windows[i];

	mov	eax, DWORD PTR [esi+6212]
	mov	eax, DWORD PTR [eax+edi*4]

; 3506 :             if (window->Active && window->HiddenFrames <= 0 && (window->Flags & (ImGuiWindowFlags_ChildWindow)) == 0 && window != g.NavWindowingTarget)

	cmp	BYTE PTR [eax+132], 0
	je	SHORT $LN5@Render
	cmp	DWORD PTR [eax+172], 0
	jg	SHORT $LN5@Render
	test	DWORD PTR [eax+8], 4194304		; 00400000H
	jne	SHORT $LN5@Render
	cmp	eax, DWORD PTR [esi+6432]
	je	SHORT $LN5@Render

; 3507 :                 AddWindowToRenderListSelectLayer(window);

	push	eax
	call	?AddWindowToRenderListSelectLayer@@YAXPAUImGuiWindow@@@Z ; AddWindowToRenderListSelectLayer
	add	esp, 4
$LN5@Render:

; 3503 :         for (int i = 0; i != g.Windows.Size; i++)

	inc	edi
	cmp	edi, DWORD PTR [esi+6204]
	jne	SHORT $LL7@Render
$LN6@Render:

; 3508 :         }
; 3509 :         if (g.NavWindowingTarget && g.NavWindowingTarget->Active && g.NavWindowingTarget->HiddenFrames <= 0) // NavWindowing target is always displayed front-most

	mov	eax, DWORD PTR [esi+6432]
	test	eax, eax
	je	SHORT $LN17@Render
	cmp	BYTE PTR [eax+132], 0
	je	SHORT $LN17@Render
	cmp	DWORD PTR [eax+172], 0
	jg	SHORT $LN17@Render

; 3510 :             AddWindowToRenderListSelectLayer(g.NavWindowingTarget);

	push	eax
	call	?AddWindowToRenderListSelectLayer@@YAXPAUImGuiWindow@@@Z ; AddWindowToRenderListSelectLayer
	add	esp, 4
$LN17@Render:

; 3516 :             flattened_size += g.RenderDrawLists[i].Size;

	mov	ecx, DWORD PTR [esi+6640]
	lea	eax, DWORD PTR [esi+6616]
	mov	ebx, DWORD PTR [eax]
	lea	edi, DWORD PTR [esi+6628]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	edx, DWORD PTR [eax+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3516 :             flattened_size += g.RenderDrawLists[i].Size;

	add	ecx, ebx
	add	ecx, DWORD PTR [edi]
	mov	DWORD PTR _flattened_size$1$[ebp], ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR tv889[ebp], edx
	cmp	ecx, edx
	jle	$LN34@Render

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	test	edx, edx
	je	SHORT $LN32@Render
	mov	eax, edx
	cdq
	sub	eax, edx
	mov	edx, eax
	lea	eax, DWORD PTR [esi+6616]
	sar	edx, 1
	add	edx, DWORD PTR tv889[ebp]
	jmp	SHORT $LN33@Render
$LN32@Render:
	mov	edx, 8
$LN33@Render:
	cmp	edx, ecx
	mov	esi, ecx
	cmovg	esi, edx

; 931  :         if (new_capacity <= Capacity) return;

	mov	edx, esi

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	mov	DWORD PTR _new_capacity$1$[ebp], esi

; 931  :         if (new_capacity <= Capacity) return;

	mov	esi, DWORD PTR _g$1$[ebp]
	cmp	edx, DWORD PTR [eax+4]
	jle	SHORT $LN34@Render

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edx*4]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	ecx, DWORD PTR [esi+6624]
	mov	edx, eax
	lea	eax, DWORD PTR [esi+6616]
	mov	DWORD PTR _new_data$1$[ebp], edx
	add	esp, 4
	mov	DWORD PTR tv887[ebp], ecx
	test	ecx, ecx
	je	SHORT $LN36@Render

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [eax]
	shl	ecx, 2
	push	ecx
	push	DWORD PTR tv887[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	lea	eax, DWORD PTR [esi+6616]
$LN36@Render:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [eax+8]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	ecx, DWORD PTR _new_data$1$[ebp]
	lea	eax, DWORD PTR [esi+6616]
	mov	DWORD PTR [eax+8], ecx
	add	esp, 4

; 937  :         Capacity = new_capacity;

	mov	ecx, DWORD PTR _new_capacity$1$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR _flattened_size$1$[ebp]
$LN34@Render:

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [eax], ecx
	mov	ecx, 2
	mov	DWORD PTR tv901[ebp], ecx
$LL13@Render:

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	mov	eax, DWORD PTR [edi]
	test	eax, eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3521 :             if (layer.empty())

	je	SHORT $LN11@Render

; 3523 :             memcpy(&g.RenderDrawLists[0][n], &layer[0], layer.Size * sizeof(ImDrawList*));

	shl	eax, 2
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	mov	eax, DWORD PTR [esi+6624]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3523 :             memcpy(&g.RenderDrawLists[0][n], &layer[0], layer.Size * sizeof(ImDrawList*));

	push	DWORD PTR [edi+8]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	lea	eax, DWORD PTR [eax+ebx*4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3523 :             memcpy(&g.RenderDrawLists[0][n], &layer[0], layer.Size * sizeof(ImDrawList*));

	push	eax
	call	_memcpy
	mov	ecx, DWORD PTR tv901[ebp]
	add	esp, 12					; 0000000cH

; 3524 :             n += layer.Size;

	add	ebx, DWORD PTR [edi]
$LN11@Render:

; 3517 :         g.RenderDrawLists[0].resize(flattened_size);
; 3518 :         for (int i = 1; i < IM_ARRAYSIZE(g.RenderDrawLists); i++)

	add	edi, 12					; 0000000cH
	sub	ecx, 1
	mov	DWORD PTR tv901[ebp], ecx
	jne	SHORT $LL13@Render

; 3525 :         }
; 3526 : 
; 3527 :         // Draw software mouse cursor if requested
; 3528 :         if (g.IO.MouseDrawCursor)

	cmp	BYTE PTR [esi+228], 0
	je	$LN19@Render

; 3530 :             const ImGuiMouseCursorData& cursor_data = g.MouseCursorData[g.MouseCursor];

	imul	edi, DWORD PTR [esi+6764], 52

; 3534 :             g.OverlayDrawList.PushTextureID(tex_id);

	lea	ebx, DWORD PTR [esi+6656]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm1, DWORD PTR [esi+212]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3534 :             g.OverlayDrawList.PushTextureID(tex_id);

	mov	ecx, ebx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [esi+208]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3530 :             const ImGuiMouseCursorData& cursor_data = g.MouseCursorData[g.MouseCursor];

	mov	DWORD PTR tv821[ebp], edi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm1, DWORD PTR [edi+esi+6776]
	subss	xmm0, DWORD PTR [edi+esi+6772]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR _pos$9[ebp+4], xmm1
	movss	DWORD PTR _pos$9[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3532 :             const ImVec2 size = cursor_data.Size;

	mov	eax, DWORD PTR [edi+esi+6780]
	mov	DWORD PTR _size$10[ebp], eax
	mov	eax, DWORD PTR [edi+esi+6784]
	mov	DWORD PTR _size$10[ebp+4], eax

; 3533 :             const ImTextureID tex_id = g.IO.Fonts->TexID;

	mov	eax, DWORD PTR [esi+132]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _tex_id$11[ebp], eax

; 3534 :             g.OverlayDrawList.PushTextureID(tex_id);

	lea	eax, DWORD PTR _tex_id$11[ebp]
	push	eax
	call	?PushTextureID@ImDrawList@@QAEXABQAX@Z	; ImDrawList::PushTextureID
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm2, DWORD PTR _pos$9[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3535 :             g.OverlayDrawList.AddImage(tex_id, pos+ImVec2(1,0), pos+ImVec2(1,0) + size, cursor_data.TexUvMin[1], cursor_data.TexUvMax[1], IM_COL32(0,0,0,48));        // Shadow

	add	esi, 6812				; 00001a9cH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm2, DWORD PTR __real@3f800000
	movss	xmm0, DWORD PTR _size$10[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3535 :             g.OverlayDrawList.AddImage(tex_id, pos+ImVec2(1,0), pos+ImVec2(1,0) + size, cursor_data.TexUvMin[1], cursor_data.TexUvMax[1], IM_COL32(0,0,0,48));        // Shadow

	add	esi, edi
	mov	eax, DWORD PTR _g$1$[ebp]
	mov	ecx, ebx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm1, DWORD PTR _pos$9[ebp+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3535 :             g.OverlayDrawList.AddImage(tex_id, pos+ImVec2(1,0), pos+ImVec2(1,0) + size, cursor_data.TexUvMin[1], cursor_data.TexUvMax[1], IM_COL32(0,0,0,48));        // Shadow

	add	eax, 6796				; 00001a8cH
	push	805306368				; 30000000H
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T6[ebp], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3535 :             g.OverlayDrawList.AddImage(tex_id, pos+ImVec2(1,0), pos+ImVec2(1,0) + size, cursor_data.TexUvMin[1], cursor_data.TexUvMax[1], IM_COL32(0,0,0,48));        // Shadow

	push	esi
	add	edi, eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T6[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3535 :             g.OverlayDrawList.AddImage(tex_id, pos+ImVec2(1,0), pos+ImVec2(1,0) + size, cursor_data.TexUvMin[1], cursor_data.TexUvMax[1], IM_COL32(0,0,0,48));        // Shadow

	push	edi
	lea	eax, DWORD PTR $T8[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T8[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR _size$10[ebp+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3535 :             g.OverlayDrawList.AddImage(tex_id, pos+ImVec2(1,0), pos+ImVec2(1,0) + size, cursor_data.TexUvMin[1], cursor_data.TexUvMax[1], IM_COL32(0,0,0,48));        // Shadow

	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3535 :             g.OverlayDrawList.AddImage(tex_id, pos+ImVec2(1,0), pos+ImVec2(1,0) + size, cursor_data.TexUvMin[1], cursor_data.TexUvMax[1], IM_COL32(0,0,0,48));        // Shadow

	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	push	DWORD PTR _tex_id$11[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T8[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3535 :             g.OverlayDrawList.AddImage(tex_id, pos+ImVec2(1,0), pos+ImVec2(1,0) + size, cursor_data.TexUvMin[1], cursor_data.TexUvMax[1], IM_COL32(0,0,0,48));        // Shadow

	call	?AddImage@ImDrawList@@QAEXPAXABUImVec2@@111I@Z ; ImDrawList::AddImage
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm2, DWORD PTR _pos$9[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3536 :             g.OverlayDrawList.AddImage(tex_id, pos+ImVec2(2,0), pos+ImVec2(2,0) + size, cursor_data.TexUvMin[1], cursor_data.TexUvMax[1], IM_COL32(0,0,0,48));        // Shadow

	lea	eax, DWORD PTR $T5[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm2, DWORD PTR __real@40000000
	movss	xmm0, DWORD PTR _size$10[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3536 :             g.OverlayDrawList.AddImage(tex_id, pos+ImVec2(2,0), pos+ImVec2(2,0) + size, cursor_data.TexUvMin[1], cursor_data.TexUvMax[1], IM_COL32(0,0,0,48));        // Shadow

	mov	ecx, ebx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm1, DWORD PTR _pos$9[ebp+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3536 :             g.OverlayDrawList.AddImage(tex_id, pos+ImVec2(2,0), pos+ImVec2(2,0) + size, cursor_data.TexUvMin[1], cursor_data.TexUvMax[1], IM_COL32(0,0,0,48));        // Shadow

	push	805306368				; 30000000H
	push	esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T7[ebp], xmm2
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3536 :             g.OverlayDrawList.AddImage(tex_id, pos+ImVec2(2,0), pos+ImVec2(2,0) + size, cursor_data.TexUvMin[1], cursor_data.TexUvMax[1], IM_COL32(0,0,0,48));        // Shadow

	push	edi
	push	eax
	lea	eax, DWORD PTR $T7[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T7[ebp+4], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3536 :             g.OverlayDrawList.AddImage(tex_id, pos+ImVec2(2,0), pos+ImVec2(2,0) + size, cursor_data.TexUvMin[1], cursor_data.TexUvMax[1], IM_COL32(0,0,0,48));        // Shadow

	push	eax
	push	DWORD PTR _tex_id$11[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T5[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR _size$10[ebp+4]
	addss	xmm0, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T5[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3536 :             g.OverlayDrawList.AddImage(tex_id, pos+ImVec2(2,0), pos+ImVec2(2,0) + size, cursor_data.TexUvMin[1], cursor_data.TexUvMax[1], IM_COL32(0,0,0,48));        // Shadow

	call	?AddImage@ImDrawList@@QAEXPAXABUImVec2@@111I@Z ; ImDrawList::AddImage
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR _size$10[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3537 :             g.OverlayDrawList.AddImage(tex_id, pos,             pos + size,             cursor_data.TexUvMin[1], cursor_data.TexUvMax[1], IM_COL32(0,0,0,255));       // Black border

	lea	eax, DWORD PTR $T4[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, DWORD PTR _pos$9[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3537 :             g.OverlayDrawList.AddImage(tex_id, pos,             pos + size,             cursor_data.TexUvMin[1], cursor_data.TexUvMax[1], IM_COL32(0,0,0,255));       // Black border

	push	-16777216				; ff000000H
	push	esi
	push	edi
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3537 :             g.OverlayDrawList.AddImage(tex_id, pos,             pos + size,             cursor_data.TexUvMin[1], cursor_data.TexUvMax[1], IM_COL32(0,0,0,255));       // Black border

	lea	eax, DWORD PTR _pos$9[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR _size$10[ebp+4]
	addss	xmm0, DWORD PTR _pos$9[ebp+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3537 :             g.OverlayDrawList.AddImage(tex_id, pos,             pos + size,             cursor_data.TexUvMin[1], cursor_data.TexUvMax[1], IM_COL32(0,0,0,255));       // Black border

	push	eax
	push	DWORD PTR _tex_id$11[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3537 :             g.OverlayDrawList.AddImage(tex_id, pos,             pos + size,             cursor_data.TexUvMin[1], cursor_data.TexUvMax[1], IM_COL32(0,0,0,255));       // Black border

	mov	ecx, ebx
	call	?AddImage@ImDrawList@@QAEXPAXABUImVec2@@111I@Z ; ImDrawList::AddImage

; 3538 :             g.OverlayDrawList.AddImage(tex_id, pos,             pos + size,             cursor_data.TexUvMin[0], cursor_data.TexUvMax[0], IM_COL32(255,255,255,255)); // White fill

	mov	esi, DWORD PTR _g$1$[ebp]
	mov	ecx, DWORD PTR tv821[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR _size$10[ebp]
	addss	xmm0, DWORD PTR _pos$9[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3538 :             g.OverlayDrawList.AddImage(tex_id, pos,             pos + size,             cursor_data.TexUvMin[0], cursor_data.TexUvMax[0], IM_COL32(255,255,255,255)); // White fill

	push	-1
	lea	eax, DWORD PTR [esi+6804]
	add	eax, ecx
	push	eax
	lea	eax, DWORD PTR [ecx+6788]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	movss	xmm0, DWORD PTR _size$10[ebp+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3538 :             g.OverlayDrawList.AddImage(tex_id, pos,             pos + size,             cursor_data.TexUvMin[0], cursor_data.TexUvMax[0], IM_COL32(255,255,255,255)); // White fill

	add	eax, esi
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 114  : static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }

	addss	xmm0, DWORD PTR _pos$9[ebp+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3538 :             g.OverlayDrawList.AddImage(tex_id, pos,             pos + size,             cursor_data.TexUvMin[0], cursor_data.TexUvMax[0], IM_COL32(255,255,255,255)); // White fill

	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	mov	ecx, ebx
	push	eax
	lea	eax, DWORD PTR _pos$9[ebp]
	push	eax
	push	DWORD PTR _tex_id$11[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3538 :             g.OverlayDrawList.AddImage(tex_id, pos,             pos + size,             cursor_data.TexUvMin[0], cursor_data.TexUvMax[0], IM_COL32(255,255,255,255)); // White fill

	call	?AddImage@ImDrawList@@QAEXPAXABUImVec2@@111I@Z ; ImDrawList::AddImage

; 3539 :             g.OverlayDrawList.PopTextureID();

	mov	ecx, ebx
	call	?PopTextureID@ImDrawList@@QAEXXZ	; ImDrawList::PopTextureID
$LN19@Render:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	cmp	DWORD PTR [esi+6680], 0
	pop	edi
	pop	ebx
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3541 :         if (!g.OverlayDrawList.VtxBuffer.empty())

	je	SHORT $LN20@Render

; 3542 :             AddDrawListToRenderList(g.RenderDrawLists[0], &g.OverlayDrawList);

	lea	eax, DWORD PTR [esi+6656]
	push	eax
	lea	eax, DWORD PTR [esi+6616]
	push	eax
	call	?AddDrawListToRenderList@@YAXAAV?$ImVector@PAUImDrawList@@@@PAUImDrawList@@@Z ; AddDrawListToRenderList
	add	esp, 8
$LN20@Render:

; 3543 : 
; 3544 :         // Setup draw data
; 3545 :         g.RenderDrawData.Valid = true;

	lea	edx, DWORD PTR [esi+6596]
	mov	BYTE PTR [edx], 1

; 3546 :         g.RenderDrawData.CmdLists = (g.RenderDrawLists[0].Size > 0) ? &g.RenderDrawLists[0][0] : NULL;

	cmp	DWORD PTR [esi+6616], 0
	jle	SHORT $LN23@Render
	mov	ecx, DWORD PTR [esi+6624]
	jmp	SHORT $LN24@Render
$LN23@Render:
	xor	ecx, ecx
$LN24@Render:

; 3547 :         g.RenderDrawData.CmdListsCount = g.RenderDrawLists[0].Size;
; 3548 :         g.RenderDrawData.TotalVtxCount = g.IO.MetricsRenderVertices;

	mov	eax, DWORD PTR [esi+860]
	mov	DWORD PTR [esi+6600], ecx
	mov	ecx, DWORD PTR [esi+6616]
	mov	DWORD PTR [esi+6608], eax

; 3549 :         g.RenderDrawData.TotalIdxCount = g.IO.MetricsRenderIndices;

	mov	eax, DWORD PTR [esi+864]
	mov	DWORD PTR [esi+6604], ecx
	mov	DWORD PTR [esi+6612], eax

; 3550 : 
; 3551 :         // Render. If user hasn't set a callback then they may retrieve the draw data via GetDrawData()
; 3552 :         if (g.RenderDrawData.CmdListsCount > 0 && g.IO.RenderDrawListsFn != NULL)

	test	ecx, ecx
	jle	SHORT $LN21@Render
	mov	eax, DWORD PTR [esi+176]
	test	eax, eax
	je	SHORT $LN21@Render

; 3553 :             g.IO.RenderDrawListsFn(&g.RenderDrawData);

	push	edx
	call	eax
	add	esp, 4
$LN21@Render:
	pop	esi

; 3554 :     }
; 3555 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Render@ImGui@@YAXXZ ENDP				; ImGui::Render
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
$T7 = -36						; size = 8
$T8 = -36						; size = 8
$T9 = -36						; size = 8
$T10 = -36						; size = 8
$T11 = -36						; size = 8
$T12 = -32						; size = 4
$T13 = -28						; size = 4
_g$ = -24						; size = 4
_new_data$1$ = -20					; size = 4
_new_data$1$ = -20					; size = 4
_g$1$ = -20						; size = 4
tv2769 = -20						; size = 4
$T14 = -14						; size = 1
_mouse_any_down$1$ = -13				; size = 1
_was_idle$1$ = -13					; size = 1
tv2689 = -13						; size = 1
$T15 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?NewFrame@ImGui@@YAXXZ PROC				; ImGui::NewFrame

; 2816 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?NewFrame@ImGui@@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 24					; 00000018H
	push	esi
	push	edi

; 2817 :     ImGuiContext& g = *GImGui;

	mov	edi, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	mov	DWORD PTR _g$[ebp], edi
	mov	DWORD PTR _g$1$[ebp], edi

; 2818 : 
; 2819 :     // Check user data
; 2820 :     IM_ASSERT(g.IO.DeltaTime >= 0.0f);               // Need a positive DeltaTime (zero is tolerated but will cause some timing issues)
; 2821 :     IM_ASSERT(g.IO.DisplaySize.x >= 0.0f && g.IO.DisplaySize.y >= 0.0f);
; 2822 :     IM_ASSERT(g.IO.Fonts->Fonts.Size > 0);           // Font Atlas not created. Did you call io.Fonts->GetTexDataAsRGBA32 / GetTexDataAsAlpha8 ?
; 2823 :     IM_ASSERT(g.IO.Fonts->Fonts[0]->IsLoaded());     // Font Atlas not created. Did you call io.Fonts->GetTexDataAsRGBA32 / GetTexDataAsAlpha8 ?
; 2824 :     IM_ASSERT(g.Style.CurveTessellationTol > 0.0f);  // Invalid style setting
; 2825 : 
; 2826 :     if (!g.Initialized)

	cmp	BYTE PTR [edi], 0
	jne	SHORT $LN22@NewFrame

; 2827 :     {
; 2828 :         // Initialize on first frame
; 2829 :         g.LogClipboard = (ImGuiTextBuffer*)ImGui::MemAlloc(sizeof(ImGuiTextBuffer));

	push	12					; 0000000cH
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 2830 :         IM_PLACEMENT_NEW(g.LogClipboard) ImGuiTextBuffer();

	lea	ecx, DWORD PTR $T14[ebp]
	mov	DWORD PTR [edi+11608], eax
	add	esp, 4
	mov	DWORD PTR $T13[ebp], ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 147  : inline void* operator new(size_t, ImPlacementNewDummy, void* ptr) { return ptr; }

	mov	DWORD PTR $T12[ebp], eax
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2830 :         IM_PLACEMENT_NEW(g.LogClipboard) ImGuiTextBuffer();

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN77@NewFrame
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 905  :     ImVector()                  { Size = Capacity = 0; Data = NULL; }

	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+8], 0

; 1000 :     ImGuiTextBuffer()   { Buf.push_back(0); }

	lea	ecx, DWORD PTR $T15[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	push	ecx
	mov	ecx, eax
	mov	BYTE PTR $T15[ebp], 0
	call	?push_back@?$ImVector@D@@QAEXABD@Z	; ImVector<char>::push_back
$LN77@NewFrame:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2830 :         IM_PLACEMENT_NEW(g.LogClipboard) ImGuiTextBuffer();

	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 2831 : 
; 2832 :         IM_ASSERT(g.Settings.empty());
; 2833 :         //LoadIniSettingsFromDisk(g.IO.IniFilename);
; 2834 :         g.Initialized = true;

	mov	BYTE PTR [edi], 1
$LN22@NewFrame:

; 2835 :     }
; 2836 : 
; 2837 : 
; 2838 :     //
; 2839 :     // STUPID HACK: This should be in response to window messages, but there has been
; 2840 :     //                 a bit of trouble reliably receciving those messages in some games.
; 2841 :     if (GetForegroundWindow () != game_window.hWnd) {

	call	DWORD PTR __imp__GetForegroundWindow@0
	cmp	eax, DWORD PTR ?game_window@@3Usk_window_s@@A+4
	je	SHORT $LN23@NewFrame

; 2842 :         g.IO.WantTextInput                 = false;
; 2843 :         g.IO.WantCaptureKeyboard           = false;
; 2844 :         g.IO.WantCaptureMouse              = false;
; 2845 :         g.IO.WantMoveMouse                 = false;
; 2846 :         FocusWindow                        (nullptr);

	push	0
	mov	WORD PTR [edi+845], 0
	mov	BYTE PTR [edi+844], 0
	mov	BYTE PTR [edi+847], 0
	call	?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusWindow
	add	esp, 4

; 2847 :         SK_Console::getInstance()->visible = false;

	call	?getInstance@SK_Console@@SAPAV1@XZ	; SK_Console::getInstance
	mov	BYTE PTR [eax+4356], 0
$LN23@NewFrame:

; 2848 :     }
; 2849 :           
; 2850 :     if (g.IO.WantCaptureKeyboard) {

	cmp	BYTE PTR [edi+845], 0
	je	SHORT $LN24@NewFrame

; 2851 :         SK_Console::getInstance ()->visible = false;

	call	?getInstance@SK_Console@@SAPAV1@XZ	; SK_Console::getInstance
	mov	BYTE PTR [eax+4356], 0
$LN24@NewFrame:

; 2852 :     }
; 2853 : 
; 2854 :     //if (g.IO.NavInputsDownDuration [ImGuiNavInput_PadInput] > 0.1f) {
; 2855 :       //g.IO.MouseClicked [1] = true;
; 2856 :       //g.IO.WantMoveMouse    = true;
; 2857 :     //}
; 2858 : 
; 2859 :   //
; 2860 :   // Idle Cursor Detection  (when UI is visible, but mouse does not require capture)
; 2861 :   //
; 2862 :   //          Remove the cursor after a brief timeout period (500 ms), it will come back if moved ;)
; 2863 :   //
; 2864 :   static int last_x, last_y;
; 2865 : 
; 2866 :   if (last_x != SK_ImGui_Cursor.pos.x || last_y != SK_ImGui_Cursor.pos.y || SK_ImGui_WantMouseCapture ())

	mov	eax, DWORD PTR ?last_x@?1??NewFrame@ImGui@@YAXXZ@4HA
	mov	esi, DWORD PTR __imp__timeGetTime@0
	cmp	eax, DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+20
	jne	SHORT $LN26@NewFrame
	mov	eax, DWORD PTR ?last_y@?1??NewFrame@ImGui@@YAXXZ@4HA
	cmp	eax, DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+24
	jne	SHORT $LN26@NewFrame
	call	?SK_ImGui_WantMouseCapture@@YA_NXZ	; SK_ImGui_WantMouseCapture
	test	al, al
	je	SHORT $LN25@NewFrame
$LN26@NewFrame:

; 2867 :     SK_ImGui_Cursor.last_move = timeGetTime ();

	call	esi
	mov	DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+32, eax
$LN25@NewFrame:

; 2868 : 
; 2869 :   last_x = SK_ImGui_Cursor.pos.x; last_y = SK_ImGui_Cursor.pos.y;

	mov	eax, DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+20
	mov	DWORD PTR ?last_x@?1??NewFrame@ImGui@@YAXXZ@4HA, eax
	mov	eax, DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+24
	mov	DWORD PTR ?last_y@?1??NewFrame@ImGui@@YAXXZ@4HA, eax

; 2870 : 
; 2871 :   bool was_idle = SK_ImGui_Cursor.idle;

	mov	al, BYTE PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+29
	mov	BYTE PTR _was_idle$1$[ebp], al

; 2872 : 
; 2873 :   if (SK_ImGui_IsMouseRelevant () && SK_ImGui_Cursor.last_move < timeGetTime () - 500)

	call	?SK_ImGui_IsMouseRelevant@@YA_NXZ	; SK_ImGui_IsMouseRelevant
	test	al, al
	je	SHORT $LN27@NewFrame
	call	esi
	sub	eax, 500				; 000001f4H
	cmp	DWORD PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+32, eax
	jae	SHORT $LN27@NewFrame

; 2874 :     SK_ImGui_Cursor.idle = true;

	mov	al, 1

; 2875 : 
; 2876 :   else

	jmp	SHORT $LN250@NewFrame
$LN27@NewFrame:

; 2877 :     SK_ImGui_Cursor.idle = false;

	xor	al, al
$LN250@NewFrame:
	mov	BYTE PTR ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A+29, al

; 2878 : 
; 2879 :   if (was_idle != SK_ImGui_Cursor.idle)

	cmp	BYTE PTR _was_idle$1$[ebp], al
	je	SHORT $LN29@NewFrame

; 2880 :     SK_ImGui_Cursor.update ();

	mov	ecx, OFFSET ?SK_ImGui_Cursor@@3Usk_imgui_cursor_s@@A ; SK_ImGui_Cursor
	call	?update@sk_imgui_cursor_s@@QAEXXZ	; sk_imgui_cursor_s::update
$LN29@NewFrame:

; 2881 : 
; 2882 : 
; 2883 : 
; 2884 :     SetCurrentFont(GetDefaultFont());

	call	?GetDefaultFont@@YAPAUImFont@@XZ	; GetDefaultFont
	push	eax
	call	?SetCurrentFont@@YAXPAUImFont@@@Z	; SetCurrentFont

; 2885 :     IM_ASSERT(g.Font->IsLoaded());
; 2886 : 
; 2887 :     g.Time += g.IO.DeltaTime;

	movss	xmm0, DWORD PTR [edi+12]

; 2888 :     g.FrameCount += 1;
; 2889 :     g.Tooltip[0] = '\0';
; 2890 :     g.OverlayDrawList.Clear();

	lea	ecx, DWORD PTR [edi+6656]
	addss	xmm0, DWORD PTR [edi+6188]
	inc	DWORD PTR [edi+6192]
	add	esp, 4
	movss	DWORD PTR [edi+6188], xmm0
	mov	BYTE PTR [edi+10548], 0
	call	?Clear@ImDrawList@@QAEXXZ		; ImDrawList::Clear

; 2891 :     g.OverlayDrawList.PushTextureID(g.IO.Fonts->TexID);

	push	DWORD PTR [edi+132]
	lea	ecx, DWORD PTR [edi+6656]
	call	?PushTextureID@ImDrawList@@QAEXABQAX@Z	; ImDrawList::PushTextureID

; 2892 :     g.OverlayDrawList.PushClipRectFullScreen();

	lea	ecx, DWORD PTR [edi+6656]
	call	?PushClipRectFullScreen@ImDrawList@@QAEXXZ ; ImDrawList::PushClipRectFullScreen

; 2893 : 
; 2894 :     // Mark rendering data as invalid to prevent user who may have a handle on it to use it
; 2895 :     g.RenderDrawData.Valid = false;
; 2896 :     g.RenderDrawData.CmdLists = NULL;
; 2897 :     g.RenderDrawData.CmdListsCount = g.RenderDrawData.TotalVtxCount = g.RenderDrawData.TotalIdxCount = 0;
; 2898 : 
; 2899 :     // Clear reference to active widget if the widget isn't alive anymore
; 2900 :     g.HoveredIdPreviousFrame = g.HoveredId;
; 2901 :     g.HoveredId = 0;
; 2902 :     g.HoveredIdAllowOverlap = false;
; 2903 :     if (!g.ActiveIdIsAlive && g.ActiveIdPreviousFrame == g.ActiveId && g.ActiveId != 0)

	cmp	BYTE PTR [edi+6272], 0
	mov	eax, DWORD PTR [edi+6252]
	mov	BYTE PTR [edi+6596], 0
	mov	DWORD PTR [edi+6600], 0
	mov	DWORD PTR [edi+6612], 0
	mov	DWORD PTR [edi+6608], 0
	mov	DWORD PTR [edi+6604], 0
	mov	DWORD PTR [edi+6260], eax
	mov	DWORD PTR [edi+6252], 0
	mov	BYTE PTR [edi+6256], 0
	jne	SHORT $LN30@NewFrame
	mov	eax, DWORD PTR [edi+6264]
	cmp	DWORD PTR [edi+6268], eax
	jne	SHORT $LN30@NewFrame
	test	eax, eax
	je	SHORT $LN30@NewFrame

; 2904 :         ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
$LN30@NewFrame:

; 2905 :     g.ActiveIdPreviousFrame = g.ActiveId;
; 2906 :     g.ActiveIdIsAlive = false;
; 2907 :     g.ActiveIdIsJustActivated = false;
; 2908 :     if (g.ScalarAsInputTextId && g.ActiveId != g.ScalarAsInputTextId)

	mov	ecx, DWORD PTR [edi+10500]
	mov	eax, DWORD PTR [edi+6264]
	mov	DWORD PTR [edi+6268], eax
	mov	WORD PTR [edi+6272], 0
	test	ecx, ecx
	je	SHORT $LN31@NewFrame
	cmp	eax, ecx
	je	SHORT $LN31@NewFrame

; 2909 :         g.ScalarAsInputTextId = 0;

	mov	DWORD PTR [edi+10500], 0
$LN31@NewFrame:

; 2910 : 
; 2911 :     // Update keyboard input state
; 2912 :     memcpy(g.IO.KeysDownDurationPrev, g.IO.KeysDownDuration, sizeof(g.IO.KeysDownDuration));
; 2913 :     for (int i = 0; i < IM_ARRAYSIZE(g.IO.KeysDown); i++)

	movss	xmm2, DWORD PTR __real@bf800000
	lea	eax, DWORD PTR [edi+1032]
	add	edi, 3080				; 00000c08H
	mov	ecx, 512				; 00000200H
	mov	esi, eax
	rep movsd
	mov	esi, DWORD PTR _g$1$[ebp]
	xor	ecx, ecx
	npad	11
$LL4@NewFrame:

; 2914 :         g.IO.KeysDownDuration[i] = g.IO.KeysDown[i] ? (g.IO.KeysDownDuration[i] < 0.0f ? 0.0f : g.IO.KeysDownDuration[i] + g.IO.DeltaTime) : -1.0f;

	cmp	BYTE PTR [esi+ecx+233], 0
	xorps	xmm1, xmm1
	je	SHORT $LN81@NewFrame
	movss	xmm2, DWORD PTR [eax]
	comiss	xmm1, xmm2
	jbe	SHORT $LN79@NewFrame
	movss	xmm2, DWORD PTR __real@bf800000
	xorps	xmm0, xmm0
	jmp	SHORT $LN82@NewFrame
$LN79@NewFrame:
	movss	xmm0, DWORD PTR [esi+12]
	addss	xmm0, xmm2
	movss	xmm2, DWORD PTR __real@bf800000
	jmp	SHORT $LN82@NewFrame
$LN81@NewFrame:
	movaps	xmm0, xmm2
$LN82@NewFrame:
	movss	DWORD PTR [eax], xmm0
	inc	ecx
	add	eax, 4
	cmp	ecx, 512				; 00000200H
	jl	SHORT $LL4@NewFrame

; 2915 :     memcpy(g.IO.NavInputsPrev, g.IO.NavInputs, sizeof(g.IO.NavInputs));

	movups	xmm0, XMMWORD PTR [esi+780]

; 2916 :     memcpy(g.IO.NavInputsDownDurationPrev, g.IO.NavInputsDownDuration, sizeof(g.IO.NavInputsDownDuration));

	lea	eax, DWORD PTR [esi+5128]
	mov	ecx, 16					; 00000010H
	movups	XMMWORD PTR [esi+5256], xmm0
	movups	xmm0, XMMWORD PTR [esi+796]
	movups	XMMWORD PTR [esi+5272], xmm0
	movups	xmm0, XMMWORD PTR [esi+812]
	movups	XMMWORD PTR [esi+5288], xmm0
	movups	xmm0, XMMWORD PTR [esi+828]
	movups	XMMWORD PTR [esi+5304], xmm0
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [esi+5192], xmm0
	movups	xmm0, XMMWORD PTR [eax+16]
	movups	XMMWORD PTR [esi+5208], xmm0
	movups	xmm0, XMMWORD PTR [eax+32]
	movups	XMMWORD PTR [esi+5224], xmm0
	movups	xmm0, XMMWORD PTR [eax+48]
	movups	XMMWORD PTR [esi+5240], xmm0
	npad	9
$LL7@NewFrame:

; 2917 :     for (int i = 0; i < IM_ARRAYSIZE(g.IO.NavInputs); i++)
; 2918 :         g.IO.NavInputsDownDuration[i] = (g.IO.NavInputs[i] > 0.0f) ? (g.IO.NavInputsDownDuration[i] < 0.0f ? 0.0f : g.IO.NavInputsDownDuration[i] + g.IO.DeltaTime) : -1.0f;

	movss	xmm0, DWORD PTR [eax-4348]
	comiss	xmm0, xmm1
	jbe	SHORT $LN85@NewFrame
	movss	xmm2, DWORD PTR [eax]
	comiss	xmm1, xmm2
	jbe	SHORT $LN83@NewFrame
	movss	xmm2, DWORD PTR __real@bf800000
	movaps	xmm0, xmm1
	jmp	SHORT $LN86@NewFrame
$LN83@NewFrame:
	movss	xmm0, DWORD PTR [esi+12]
	addss	xmm0, xmm2
	movss	xmm2, DWORD PTR __real@bf800000
	jmp	SHORT $LN86@NewFrame
$LN85@NewFrame:
	movaps	xmm0, xmm2
$LN86@NewFrame:
	movss	DWORD PTR [eax], xmm0
	add	eax, 4
	sub	ecx, 1
	jne	SHORT $LL7@NewFrame

; 2919 : 
; 2920 :     // Update directional navigation which may override MousePos if 'NavMovesMouse=true'
; 2921 :     NavUpdate();

	call	?NavUpdate@@YAXXZ			; NavUpdate
	xorps	xmm1, xmm1

; 2922 : 
; 2923 :     // Update mouse input state
; 2924 :     if (g.IO.MousePos.x < 0 && g.IO.MousePos.y < 0)

	comiss	xmm1, DWORD PTR [esi+208]
	jbe	SHORT $LN36@NewFrame
	comiss	xmm1, DWORD PTR [esi+212]
	jbe	SHORT $LN32@NewFrame
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T11[ebp], -971228160		; c61c3c00H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2925 :         g.IO.MousePos = ImVec2(-9999.0f, -9999.0f);

	mov	eax, DWORD PTR $T11[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T11[ebp+4], -971228160	; c61c3c00H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2925 :         g.IO.MousePos = ImVec2(-9999.0f, -9999.0f);

	mov	DWORD PTR [esi+208], eax
	mov	eax, DWORD PTR $T11[ebp+4]
	mov	DWORD PTR [esi+212], eax
$LN32@NewFrame:

; 2926 :     if ((g.IO.MousePos.x < 0 && g.IO.MousePos.y < 0) || (g.IO.MousePosPrev.x < 0 && g.IO.MousePosPrev.y < 0))   // if mouse just appeared or disappeared (negative coordinate) we cancel out movement in MouseDelta

	comiss	xmm1, DWORD PTR [esi+208]
	jbe	SHORT $LN36@NewFrame
	comiss	xmm1, DWORD PTR [esi+212]
	ja	SHORT $LN35@NewFrame
$LN36@NewFrame:
	comiss	xmm1, DWORD PTR [esi+880]
	jbe	SHORT $LN33@NewFrame
	comiss	xmm1, DWORD PTR [esi+884]
	jbe	SHORT $LN33@NewFrame
$LN35@NewFrame:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T10[ebp], 0
	mov	DWORD PTR $T10[ebp+4], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2928 :     else

	jmp	SHORT $LN252@NewFrame
$LN33@NewFrame:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [esi+208]
	subss	xmm0, DWORD PTR [esi+880]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T9[ebp], xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm0, DWORD PTR [esi+212]
	subss	xmm0, DWORD PTR [esi+884]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T9[ebp+4], xmm0
$LN252@NewFrame:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2929 :         g.IO.MouseDelta = g.IO.MousePos - g.IO.MousePosPrev;

	mov	eax, DWORD PTR $T9[ebp]
	mov	DWORD PTR [esi+872], eax

; 2930 :     if (g.IO.MouseDelta.x != 0.0f || g.IO.MouseDelta.y != 0.0f)

	movss	xmm0, DWORD PTR [esi+872]
	mov	eax, DWORD PTR $T9[ebp+4]
	ucomiss	xmm0, xmm1
	mov	DWORD PTR [esi+876], eax
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN38@NewFrame
	movss	xmm0, DWORD PTR [esi+876]
	ucomiss	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN37@NewFrame
$LN38@NewFrame:

; 2931 :         g.NavDisableMouseHover = false;

	mov	BYTE PTR [esi+6455], 0
$LN37@NewFrame:

; 2932 :     g.IO.MousePosPrev = g.IO.MousePos;

	mov	eax, DWORD PTR [esi+208]
	lea	edx, DWORD PTR [esi+216]
	movss	xmm3, DWORD PTR __real@bf800000
	lea	edi, DWORD PTR [esi+896]
	mov	DWORD PTR [esi+880], eax
	lea	ecx, DWORD PTR [esi+972]
	mov	eax, DWORD PTR [esi+212]
	mov	DWORD PTR [esi+884], eax
	mov	DWORD PTR tv2769[ebp], 5
$LL10@NewFrame:

; 2934 :     {
; 2935 :         g.IO.MouseClicked[i] = g.IO.MouseDown[i] && g.IO.MouseDownDuration[i] < 0.0f;

	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv2689[ebp], al
	test	al, al
	je	SHORT $LN87@NewFrame
	comiss	xmm1, DWORD PTR [ecx]
	jbe	SHORT $LN87@NewFrame
	mov	eax, 1
	jmp	SHORT $LN88@NewFrame
$LN87@NewFrame:
	xor	eax, eax
$LN88@NewFrame:

; 2936 :         g.IO.MouseReleased[i] = !g.IO.MouseDown[i] && g.IO.MouseDownDuration[i] >= 0.0f;

	cmp	BYTE PTR tv2689[ebp], 0
	mov	BYTE PTR [edx+672], al
	jne	SHORT $LN89@NewFrame
	movss	xmm0, DWORD PTR [ecx]
	comiss	xmm0, xmm1
	jb	SHORT $LN89@NewFrame
	mov	eax, 1
	jmp	SHORT $LN90@NewFrame
$LN89@NewFrame:
	xor	eax, eax
$LN90@NewFrame:
	mov	BYTE PTR [edx+745], al

; 2937 :         g.IO.MouseDownDurationPrev[i] = g.IO.MouseDownDuration[i];

	movss	xmm0, DWORD PTR [ecx]
	movss	DWORD PTR [ecx+20], xmm0

; 2938 :         g.IO.MouseDownDuration[i] = g.IO.MouseDown[i] ? (g.IO.MouseDownDuration[i] < 0.0f ? 0.0f : g.IO.MouseDownDuration[i] + g.IO.DeltaTime) : -1.0f;

	cmp	BYTE PTR [edx], 0
	je	SHORT $LN93@NewFrame
	comiss	xmm1, xmm0
	jbe	SHORT $LN91@NewFrame
	movaps	xmm0, xmm1
	jmp	SHORT $LN94@NewFrame
$LN91@NewFrame:
	addss	xmm0, DWORD PTR [esi+12]
	jmp	SHORT $LN94@NewFrame
$LN93@NewFrame:
	movaps	xmm0, xmm3
$LN94@NewFrame:
	movss	DWORD PTR [ecx], xmm0

; 2939 :         g.IO.MouseDoubleClicked[i] = false;
; 2940 :         if (g.IO.MouseClicked[i])

	cmp	BYTE PTR [edx+672], 0
	mov	BYTE PTR [edx+740], 0
	je	SHORT $LN39@NewFrame

; 2941 :         {
; 2942 :             if (g.Time - g.IO.MouseClickedTime[i] < g.IO.MouseDoubleClickTime)

	movss	xmm2, DWORD PTR [esi+6188]
	movss	xmm0, DWORD PTR [esi+28]
	movaps	xmm1, xmm2
	subss	xmm1, DWORD PTR [ecx-36]
	comiss	xmm0, xmm1
	jbe	SHORT $LN41@NewFrame
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm2, DWORD PTR [esi+208]
	movss	xmm0, DWORD PTR [esi+212]
	subss	xmm2, DWORD PTR [edi]
	subss	xmm0, DWORD PTR [edi+4]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2944 :                 if (ImLengthSqr(g.IO.MousePos - g.IO.MouseClickedPos[i]) < g.IO.MouseDoubleClickMaxDist * g.IO.MouseDoubleClickMaxDist)

	movss	xmm1, DWORD PTR [esi+32]
	mulss	xmm1, xmm1
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 137  : static inline float  ImLengthSqr(const ImVec2& lhs)                             { return lhs.x*lhs.x + lhs.y*lhs.y; }

	mulss	xmm2, xmm2
	mulss	xmm0, xmm0
	addss	xmm2, xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2944 :                 if (ImLengthSqr(g.IO.MousePos - g.IO.MouseClickedPos[i]) < g.IO.MouseDoubleClickMaxDist * g.IO.MouseDoubleClickMaxDist)

	comiss	xmm1, xmm2
	jbe	SHORT $LN43@NewFrame

; 2945 :                     g.IO.MouseDoubleClicked[i] = true;

	mov	BYTE PTR [edx+740], 1
$LN43@NewFrame:

; 2946 :                 g.IO.MouseClickedTime[i] = -FLT_MAX;    // so the third click isn't turned into a double-click

	mov	DWORD PTR [ecx-36], -8388609		; ff7fffffH

; 2947 :             }
; 2948 :             else

	jmp	SHORT $LN42@NewFrame
$LN41@NewFrame:

; 2949 :             {
; 2950 :                 g.IO.MouseClickedTime[i] = g.Time;

	movss	DWORD PTR [ecx-36], xmm2
$LN42@NewFrame:

; 2951 :             }
; 2952 :             g.IO.MouseClickedPos[i] = g.IO.MousePos;

	mov	eax, DWORD PTR [esi+208]
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR [esi+212]
	mov	DWORD PTR [edi+4], eax

; 2953 :             g.IO.MouseDragMaxDistanceSqr[i] = 0.0f;

	mov	DWORD PTR [ecx+40], 0
	jmp	SHORT $LN253@NewFrame
$LN39@NewFrame:

; 2954 :         }
; 2955 :         else if (g.IO.MouseDown[i])

	cmp	BYTE PTR [edx], 0
	je	SHORT $LN44@NewFrame
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm1, DWORD PTR [esi+208]
	subss	xmm1, DWORD PTR [edi]
	movss	xmm0, DWORD PTR [esi+212]
	subss	xmm0, DWORD PTR [edi+4]

; 137  : static inline float  ImLengthSqr(const ImVec2& lhs)                             { return lhs.x*lhs.x + lhs.y*lhs.y; }

	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm1, xmm0
	maxss	xmm1, DWORD PTR [ecx+40]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2957 :             g.IO.MouseDragMaxDistanceSqr[i] = ImMax(g.IO.MouseDragMaxDistanceSqr[i], ImLengthSqr(g.IO.MousePos - g.IO.MouseClickedPos[i]));

	movss	DWORD PTR [ecx+40], xmm1
$LN253@NewFrame:
	xorps	xmm1, xmm1
$LN44@NewFrame:

; 2958 :         }
; 2959 :         if (g.IO.MouseClicked[i]) // Clicking any mouse button reactivate mouse hovering which may have been deactivated by gamepad/keyboard navigation

	cmp	BYTE PTR [edx+672], 0
	je	SHORT $LN8@NewFrame

; 2960 :             g.NavDisableMouseHover = false;

	mov	BYTE PTR [esi+6455], 0
$LN8@NewFrame:

; 2933 :     for (int i = 0; i < IM_ARRAYSIZE(g.IO.MouseDown); i++)

	add	edi, 8
	add	ecx, 4
	inc	edx
	sub	DWORD PTR tv2769[ebp], 1
	jne	$LL10@NewFrame

; 2961 :     }
; 2962 : 
; 2963 :     // Calculate frame-rate for the user, as a purely luxurious feature
; 2964 :     g.FramerateSecPerFrameAccum += g.IO.DeltaTime - g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx];

	mov	eax, DWORD PTR [esi+12100]

; 2965 :     g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx] = g.IO.DeltaTime;
; 2966 :     g.FramerateSecPerFrameIdx = (g.FramerateSecPerFrameIdx + 1) % IM_ARRAYSIZE(g.FramerateSecPerFrame);

	mov	ecx, 120				; 00000078H
	movss	xmm1, DWORD PTR [esi+12]
	movaps	xmm0, xmm1
	subss	xmm0, DWORD PTR [esi+eax*4+11620]
	addss	xmm0, DWORD PTR [esi+12104]
	movss	DWORD PTR [esi+12104], xmm0
	movss	DWORD PTR [esi+eax*4+11620], xmm1
	mov	eax, DWORD PTR [esi+12100]

; 2967 :     g.IO.Framerate = 1.0f / (g.FramerateSecPerFrameAccum / (float)IM_ARRAYSIZE(g.FramerateSecPerFrame));

	movss	xmm0, DWORD PTR __real@42f00000
	inc	eax
	divss	xmm0, DWORD PTR [esi+12104]
	cdq
	idiv	ecx

; 2968 : 
; 2969 :     // Handle user moving window with mouse (at the beginning of the frame to avoid input lag or sheering). Only valid for root windows.
; 2970 :     if (g.MovedWindowMoveId && g.MovedWindowMoveId == g.ActiveId && g.ActiveIdSource == ImGuiInputSource_Mouse)

	mov	eax, DWORD PTR [esi+6300]
	mov	DWORD PTR [esi+12100], edx
	movss	DWORD PTR [esi+852], xmm0
	test	eax, eax
	je	$LN46@NewFrame
	cmp	eax, DWORD PTR [esi+6264]
	jne	$LN46@NewFrame
	cmp	DWORD PTR [esi+6292], 1
	jne	$LN46@NewFrame

; 2971 :     {
; 2972 :         KeepAliveID(g.MovedWindowMoveId);

	push	eax
	call	?KeepAliveID@ImGui@@YAXI@Z		; ImGui::KeepAliveID
	add	esp, 4

; 2973 :         IM_ASSERT(g.MovedWindow && g.MovedWindow->RootWindow);
; 2974 :         IM_ASSERT(g.MovedWindow->RootWindow->MoveId == g.MovedWindowMoveId);
; 2975 :         if (g.IO.MouseDown[0])

	cmp	BYTE PTR [esi+216], 0
	je	SHORT $LN48@NewFrame

; 2976 :         {
; 2977 :             if (!(g.MovedWindow->Flags & ImGuiWindowFlags_NoMove))

	mov	eax, DWORD PTR [esi+6296]
	test	BYTE PTR [eax+8], 4
	jne	SHORT $LN51@NewFrame
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 118  : static inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }

	movss	xmm0, DWORD PTR [eax+16]
	xorps	xmm1, xmm1
	addss	xmm0, DWORD PTR [esi+872]
	movss	DWORD PTR [eax+16], xmm0
	movss	xmm0, DWORD PTR [esi+876]
	addss	xmm0, DWORD PTR [eax+20]
	movss	DWORD PTR [eax+20], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 2980 :                 if (g.IO.MouseDelta.x != 0.0f || g.IO.MouseDelta.y != 0.0f)

	movss	xmm0, DWORD PTR [esi+872]
	ucomiss	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN52@NewFrame
	movss	xmm0, DWORD PTR [esi+876]
	ucomiss	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN51@NewFrame
$LN52@NewFrame:

; 2981 :                     MarkIniSettingsDirty(g.MovedWindow);

	push	DWORD PTR [esi+6296]
	call	?MarkIniSettingsDirty@@YAXPAUImGuiWindow@@@Z ; MarkIniSettingsDirty
	add	esp, 4
$LN51@NewFrame:

; 2982 :             }
; 2983 :             FocusWindow(g.MovedWindow);

	push	DWORD PTR [esi+6296]
	call	?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusWindow
	add	esp, 4

; 2984 :         }
; 2985 :         else

	jmp	SHORT $LN47@NewFrame
$LN48@NewFrame:

; 2986 :         {
; 2987 :             ClearActiveID();

	call	?ClearActiveID@ImGui@@YAXXZ		; ImGui::ClearActiveID
$LN46@NewFrame:

; 2988 :             g.MovedWindow = NULL;
; 2989 :             g.MovedWindowMoveId = 0;
; 2990 :         }
; 2991 :     }
; 2992 :     else
; 2993 :     {
; 2994 :         g.MovedWindow = NULL;
; 2995 :         g.MovedWindowMoveId = 0;

	mov	DWORD PTR [esi+6300], 0
	mov	DWORD PTR [esi+6296], 0
$LN47@NewFrame:

; 2996 :     }
; 2997 : 
; 2998 :     // Delay saving settings so we don't spam disk too much
; 2999 :     if (g.SettingsDirtyTimer > 0.0f)

	movss	xmm0, DWORD PTR [esi+6316]
	xorps	xmm6, xmm6
	comiss	xmm0, xmm6
	jbe	SHORT $LN53@NewFrame

; 3000 :     {
; 3001 :         g.SettingsDirtyTimer -= g.IO.DeltaTime;

	subss	xmm0, DWORD PTR [esi+12]
	movss	DWORD PTR [esi+6316], xmm0
$LN53@NewFrame:

; 3002 :         //if (g.SettingsDirtyTimer <= 0.0f)
; 3003 :             //SaveIniSettingsToDisk(g.IO.IniFilename);
; 3004 :     }
; 3005 : 
; 3006 :     // Find the window we are hovering. Child windows can extend beyond the limit of their parent so we need to derive HoveredRootWindow from HoveredWindow
; 3007 :     g.HoveredWindow = g.MovedWindow ? g.MovedWindow : FindHoveredWindow(g.IO.MousePos, false);

	mov	edi, DWORD PTR [esi+6296]
	test	edi, edi
	je	SHORT $LN95@NewFrame
	mov	eax, edi
	jmp	SHORT $LN96@NewFrame
$LN95@NewFrame:
	push	0
	push	DWORD PTR [esi+212]
	push	DWORD PTR [esi+208]
	call	?FindHoveredWindow@@YAPAUImGuiWindow@@UImVec2@@_N@Z ; FindHoveredWindow
	add	esp, 12					; 0000000cH
$LN96@NewFrame:

; 3008 :     if (g.HoveredWindow && (g.HoveredWindow->Flags & ImGuiWindowFlags_ChildWindow))

	mov	DWORD PTR [esi+6244], eax
	test	eax, eax
	je	SHORT $LN54@NewFrame
	test	DWORD PTR [eax+8], 4194304		; 00400000H
	je	SHORT $LN54@NewFrame

; 3009 :         g.HoveredRootWindow = g.HoveredWindow->RootWindow;

	mov	eax, DWORD PTR [eax+632]

; 3010 :     else

	jmp	SHORT $LN98@NewFrame
$LN54@NewFrame:

; 3011 :         g.HoveredRootWindow = g.MovedWindow ? g.MovedWindow->RootWindow : FindHoveredWindow(g.IO.MousePos, true);

	test	edi, edi
	je	SHORT $LN97@NewFrame
	mov	eax, DWORD PTR [edi+632]
	jmp	SHORT $LN98@NewFrame
$LN97@NewFrame:
	push	1
	push	DWORD PTR [esi+212]
	push	DWORD PTR [esi+208]
	call	?FindHoveredWindow@@YAPAUImGuiWindow@@UImVec2@@_N@Z ; FindHoveredWindow
	add	esp, 12					; 0000000cH
$LN98@NewFrame:
	mov	DWORD PTR [esi+6248], eax

; 3012 : 
; 3013 :     if (ImGuiWindow* modal_window = GetFrontMostModalRootWindow())

	call	?GetFrontMostModalRootWindow@@YAPAUImGuiWindow@@XZ ; GetFrontMostModalRootWindow
	movss	xmm5, DWORD PTR __real@3f800000
	mov	ecx, eax
	test	ecx, ecx
	je	SHORT $LN56@NewFrame

; 3014 :     {
; 3015 :         g.ModalWindowDarkeningRatio = ImMin(g.ModalWindowDarkeningRatio + g.IO.DeltaTime * 6.0f, 1.0f);

	movss	xmm0, DWORD PTR [esi+12]
	mulss	xmm0, DWORD PTR __real@40c00000

; 3016 :         ImGuiWindow* window = g.HoveredRootWindow;

	mov	eax, DWORD PTR [esi+6248]
	addss	xmm0, DWORD PTR [esi+6652]
	minss	xmm0, xmm5
	movss	DWORD PTR [esi+6652], xmm0

; 3017 :         while (window && window != modal_window)

	test	eax, eax
	je	SHORT $LN247@NewFrame
	npad	6
$LL11@NewFrame:
	cmp	eax, ecx
	je	SHORT $LN12@NewFrame

; 3018 :             window = window->ParentWindow;

	mov	eax, DWORD PTR [eax+628]
	test	eax, eax
	jne	SHORT $LL11@NewFrame

; 3019 :         if (!window)

	jmp	SHORT $LN247@NewFrame
$LN12@NewFrame:
	test	eax, eax
	jne	SHORT $LN57@NewFrame
$LN247@NewFrame:

; 3020 :             g.HoveredRootWindow = g.HoveredWindow = NULL;

	mov	DWORD PTR [esi+6244], 0
	mov	DWORD PTR [esi+6248], 0

; 3021 :     }
; 3022 :     else

	jmp	SHORT $LN57@NewFrame
$LN56@NewFrame:

; 3023 :     {
; 3024 :         g.ModalWindowDarkeningRatio = 0.0f;

	mov	DWORD PTR [esi+6652], 0
$LN57@NewFrame:

; 3025 :     }
; 3026 : 
; 3027 :     // Are we using inputs? Tell user so they can capture/discard the inputs away from the rest of their application.
; 3028 :     // When clicking outside of a window we assume the click is owned by the application and won't request capture. We need to track click ownership.
; 3029 :     int mouse_earliest_button_down = -1;
; 3030 :     bool mouse_any_down = false;

	xor	ah, ah
	or	edx, -1
	mov	BYTE PTR _mouse_any_down$1$[ebp], ah

; 3031 :     for (int i = 0; i < IM_ARRAYSIZE(g.IO.MouseDown); i++)

	xor	ecx, ecx
	npad	2
$LL15@NewFrame:

; 3032 :     {
; 3033 :         if (g.IO.MouseClicked[i])

	cmp	BYTE PTR [esi+ecx+888], 0
	je	SHORT $LN59@NewFrame

; 3034 :             g.IO.MouseDownOwned[i] = (g.HoveredWindow != NULL) || (!g.OpenPopupStack.empty());

	cmp	DWORD PTR [esi+6244], 0
	jne	SHORT $LN99@NewFrame
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	cmp	DWORD PTR [esi+6356], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3034 :             g.IO.MouseDownOwned[i] = (g.HoveredWindow != NULL) || (!g.OpenPopupStack.empty());

	jne	SHORT $LN99@NewFrame
	xor	eax, eax
	jmp	SHORT $LN100@NewFrame
$LN99@NewFrame:
	mov	eax, 1
$LN100@NewFrame:
	mov	ah, BYTE PTR _mouse_any_down$1$[ebp]
	mov	BYTE PTR [ecx+esi+966], al
$LN59@NewFrame:

; 3035 :         mouse_any_down |= g.IO.MouseDown[i];

	mov	al, BYTE PTR [esi+ecx+216]
	or	ah, al
	mov	BYTE PTR _mouse_any_down$1$[ebp], ah

; 3036 :         if (g.IO.MouseDown[i])

	test	al, al
	je	SHORT $LN13@NewFrame

; 3037 :             if (mouse_earliest_button_down == -1 || g.IO.MouseClickedTime[mouse_earliest_button_down] > g.IO.MouseClickedTime[i])

	cmp	edx, -1
	je	SHORT $LN62@NewFrame
	movss	xmm0, DWORD PTR [esi+edx*4+936]
	comiss	xmm0, DWORD PTR [esi+ecx*4+936]
	jbe	SHORT $LN13@NewFrame
$LN62@NewFrame:

; 3038 :                 mouse_earliest_button_down = i;

	mov	edx, ecx
$LN13@NewFrame:

; 3031 :     for (int i = 0; i < IM_ARRAYSIZE(g.IO.MouseDown); i++)

	inc	ecx
	cmp	ecx, 5
	jl	SHORT $LL15@NewFrame

; 3039 :     }
; 3040 :     bool mouse_avail_to_imgui = (mouse_earliest_button_down == -1) || g.IO.MouseDownOwned[mouse_earliest_button_down];

	cmp	edx, -1
	je	SHORT $LN101@NewFrame
	cmp	BYTE PTR [edx+esi+966], 0
	jne	SHORT $LN101@NewFrame
	xor	cl, cl
	jmp	SHORT $LN102@NewFrame
$LN101@NewFrame:
	mov	cl, 1
$LN102@NewFrame:

; 3041 :     if (g.CaptureMouseNextFrame != -1)

	mov	edx, DWORD PTR [esi+12108]
	cmp	edx, -1
	je	SHORT $LN63@NewFrame

; 3042 :         g.IO.WantCaptureMouse = (g.CaptureMouseNextFrame != 0);

	test	edx, edx
	setne	al

; 3043 :     else

	jmp	SHORT $LN105@NewFrame
$LN63@NewFrame:

; 3044 :         g.IO.WantCaptureMouse = (mouse_avail_to_imgui && (g.HoveredWindow != NULL || mouse_any_down)) || (g.ActiveId != 0) || (!g.OpenPopupStack.empty());

	test	cl, cl
	je	SHORT $LN104@NewFrame
	cmp	DWORD PTR [esi+6244], 0
	jne	SHORT $LN103@NewFrame
	test	ah, ah
	jne	SHORT $LN103@NewFrame
$LN104@NewFrame:
	cmp	DWORD PTR [esi+6264], 0
	jne	SHORT $LN103@NewFrame
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 908  :     inline bool                 empty() const                   { return Size == 0; }

	cmp	DWORD PTR [esi+6356], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3044 :         g.IO.WantCaptureMouse = (mouse_avail_to_imgui && (g.HoveredWindow != NULL || mouse_any_down)) || (g.ActiveId != 0) || (!g.OpenPopupStack.empty());

	jne	SHORT $LN103@NewFrame
	xor	eax, eax
	jmp	SHORT $LN105@NewFrame
$LN103@NewFrame:
	mov	eax, 1
$LN105@NewFrame:

; 3045 :     g.IO.WantCaptureKeyboard = (g.CaptureKeyboardNextFrame != -1) ? (g.CaptureKeyboardNextFrame != 0) : (g.ActiveId != 0);

	mov	edx, DWORD PTR [esi+12112]
	mov	BYTE PTR [esi+844], al
	xor	eax, eax
	cmp	edx, -1
	je	SHORT $LN106@NewFrame
	test	edx, edx
	jmp	SHORT $LN254@NewFrame
$LN106@NewFrame:
	cmp	DWORD PTR [esi+6264], eax
$LN254@NewFrame:
	setne	al
	mov	BYTE PTR [esi+845], al

; 3046 :     g.IO.WantTextInput = (g.ActiveId != 0 && g.InputTextState.Id == g.ActiveId);

	mov	eax, DWORD PTR [esi+6264]
	test	eax, eax
	je	SHORT $LN108@NewFrame
	cmp	DWORD PTR [esi+7132], eax
	jne	SHORT $LN108@NewFrame
	mov	eax, 1
	jmp	SHORT $LN109@NewFrame
$LN108@NewFrame:
	xor	eax, eax
$LN109@NewFrame:
	mov	BYTE PTR [esi+846], al
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T8[ebp], 1065353216		; 3f800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3049 :     g.OsImePosRequest = ImVec2(1.0f, 1.0f); // OS Input Method Editor showing on top-left of our window by default

	mov	eax, DWORD PTR $T8[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T8[ebp+4], 1065353216	; 3f800000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3049 :     g.OsImePosRequest = ImVec2(1.0f, 1.0f); // OS Input Method Editor showing on top-left of our window by default

	mov	DWORD PTR [esi+11584], eax
	mov	eax, DWORD PTR $T8[ebp+4]
	mov	DWORD PTR [esi+6764], 0
	mov	DWORD PTR [esi+12112], -1
	mov	DWORD PTR [esi+12108], -1
	mov	DWORD PTR [esi+11588], eax

; 3050 : 
; 3051 :     // If mouse was first clicked outside of ImGui bounds we also cancel out hovering.
; 3052 :     if (!mouse_avail_to_imgui)

	test	cl, cl
	jne	SHORT $LN65@NewFrame

; 3053 :         g.HoveredWindow = g.HoveredRootWindow = NULL;

	mov	DWORD PTR [esi+6248], 0
	mov	DWORD PTR [esi+6244], 0
$LN65@NewFrame:

; 3054 : 
; 3055 :     // Scale & Scrolling
; 3056 :     if (g.HoveredWindow && g.IO.MouseWheel != 0.0f && !g.HoveredWindow->Collapsed)

	mov	edx, DWORD PTR [esi+6244]
	test	edx, edx
	je	$LN69@NewFrame
	movss	xmm0, DWORD PTR [esi+224]
	ucomiss	xmm0, xmm6
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN69@NewFrame
	cmp	BYTE PTR [edx+135], 0
	jne	$LN69@NewFrame

; 3057 :     {
; 3058 :         ImGuiWindow* window = g.HoveredWindow;
; 3059 :         if (g.IO.KeyCtrl && g.IO.FontAllowUserScaling)

	mov	al, BYTE PTR [esi+229]
	test	al, al
	je	$LN256@NewFrame
	cmp	BYTE PTR [esi+140], 0
	je	$LN67@NewFrame

; 3062 :             const float new_font_scale = ImClamp(window->FontWindowScale + g.IO.MouseWheel * 0.10f, 0.50f, 2.50f);

	mulss	xmm0, DWORD PTR __real@3dcccccd
	movss	xmm2, DWORD PTR [edx+620]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	movss	xmm1, DWORD PTR __real@3f000000
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3062 :             const float new_font_scale = ImClamp(window->FontWindowScale + g.IO.MouseWheel * 0.10f, 0.50f, 2.50f);

	addss	xmm0, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 132  : static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }

	comiss	xmm1, xmm0
	ja	SHORT $LN157@NewFrame
	movaps	xmm1, xmm0
	minss	xmm1, DWORD PTR __real@40200000
$LN157@NewFrame:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3063 :             const float scale = new_font_scale / window->FontWindowScale;

	movaps	xmm4, xmm1

; 3064 :             window->FontWindowScale = new_font_scale;

	movss	DWORD PTR [edx+620], xmm1
	divss	xmm4, xmm2
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	movss	xmm3, DWORD PTR [esi+208]
	subss	xmm3, DWORD PTR [edx+24]
	movss	xmm1, DWORD PTR [esi+212]

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	movss	xmm2, DWORD PTR [edx+36]

; 115  : static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }

	subss	xmm1, DWORD PTR [edx+28]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3063 :             const float scale = new_font_scale / window->FontWindowScale;

	shufps	xmm4, xmm4, 0

; 3065 : 
; 3066 :             const ImVec2 offset = window->Size * (1.0f - scale) * (g.IO.MousePos - window->Pos) / window->Size;

	subss	xmm5, xmm4
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 112  : static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }

	movaps	xmm0, xmm5
	mulss	xmm2, xmm5
	mulss	xmm0, DWORD PTR [edx+32]

; 116  : static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }

	mulss	xmm2, xmm1
	mulss	xmm3, xmm0

; 117  : static inline ImVec2 operator/(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x/rhs.x, lhs.y/rhs.y); }

	divss	xmm2, DWORD PTR [edx+36]
	divss	xmm3, DWORD PTR [edx+32]

; 118  : static inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }

	movaps	xmm0, xmm3
	addss	xmm0, DWORD PTR [edx+24]
	movss	DWORD PTR [edx+24], xmm0
	movaps	xmm0, xmm2
	addss	xmm0, DWORD PTR [edx+28]
	movss	DWORD PTR [edx+28], xmm0
	addss	xmm3, DWORD PTR [edx+16]
	addss	xmm2, DWORD PTR [edx+20]
	movss	DWORD PTR [edx+16], xmm3
	movss	DWORD PTR [edx+20], xmm2

; 120  : static inline ImVec2& operator*=(ImVec2& lhs, const float rhs)                  { lhs.x *= rhs; lhs.y *= rhs; return lhs; }

	movups	xmm0, XMMWORD PTR [edx+32]
	mulps	xmm0, xmm4
	movups	XMMWORD PTR [edx+32], xmm0
	jmp	SHORT $LN69@NewFrame
$LN67@NewFrame:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3072 :         else if (!g.IO.KeyCtrl && !(window->Flags & ImGuiWindowFlags_NoScrollWithMouse))

	test	al, al
	jne	SHORT $LN69@NewFrame
$LN256@NewFrame:
	mov	ecx, DWORD PTR [edx+8]
	test	cl, 16					; 00000010H
	jne	SHORT $LN69@NewFrame
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3075 :             const int scroll_lines = (window->Flags & ImGuiWindowFlags_ComboBox) ? 3 : 5;

	and	ecx, 8388608				; 00800000H
	neg	ecx
	sbb	ecx, ecx
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	movss	xmm1, DWORD PTR [eax+6176]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3075 :             const int scroll_lines = (window->Flags & ImGuiWindowFlags_ComboBox) ? 3 : 5;

	and	ecx, -2					; fffffffeH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui_internal.h

; 774  :     float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }

	mulss	xmm1, DWORD PTR [edx+620]
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3075 :             const int scroll_lines = (window->Flags & ImGuiWindowFlags_ComboBox) ? 3 : 5;

	add	ecx, 5

; 3076 :             SetWindowScrollY(window, window->Scroll.y - g.IO.MouseWheel * window->CalcFontSize() * scroll_lines);

	push	ecx
	mulss	xmm1, xmm0
	movd	xmm0, ecx
	cvtdq2ps xmm0, xmm0
	mulss	xmm1, xmm0
	movss	xmm0, DWORD PTR [edx+96]
	subss	xmm0, xmm1
	movss	DWORD PTR [esp], xmm0
	push	edx
	call	?SetWindowScrollY@@YAXPAUImGuiWindow@@M@Z ; SetWindowScrollY
	add	esp, 8
$LN69@NewFrame:

; 3077 :         }
; 3078 :     }
; 3079 : 
; 3080 :     // Pressing TAB activate widget focus
; 3081 :     //// NB: Don't discard FocusedWindow if it isn't active, so that a window that go on/off programatically won't lose its keyboard focus. // [2016/07/17] That comment was made invalid by 19d02becef94e8e0f1d432a8bd55cd783876583c
; 3082 :     if (g.ActiveId == 0 && g.NavWindow != NULL && g.NavWindow->Active && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_Tab, false))

	cmp	DWORD PTR [esi+6264], 0
	jne	SHORT $LN72@NewFrame
	mov	edi, DWORD PTR [esi+6380]
	test	edi, edi
	je	SHORT $LN72@NewFrame
	cmp	BYTE PTR [edi+132], 0
	je	SHORT $LN72@NewFrame
	test	DWORD PTR [edi+8], 262144		; 00040000H
	jne	SHORT $LN72@NewFrame
	cmp	BYTE PTR [esi+229], 0
	jne	SHORT $LN72@NewFrame
	push	0
	push	0
	call	?IsKeyPressedMap@@YA_NH_N@Z		; IsKeyPressedMap
	add	esp, 8
	test	al, al
	je	SHORT $LN72@NewFrame

; 3083 :     {
; 3084 :         if (g.NavId != 0 && g.NavIdTabCounter != INT_MAX)

	cmp	DWORD PTR [esi+6384], 0
	je	SHORT $LN71@NewFrame
	mov	ecx, DWORD PTR [esi+6448]
	cmp	ecx, 2147483647				; 7fffffffH
	je	SHORT $LN71@NewFrame

; 3085 :             g.NavWindow->FocusIdxTabRequestNext = g.NavIdTabCounter + 1 + (g.IO.KeyShift ? -1 : 1);
; 3086 :         else

	xor	edx, edx
	mov	eax, 2
	cmp	BYTE PTR [esi+230], dl
	cmovne	eax, edx
	add	eax, ecx
	jmp	SHORT $LN257@NewFrame
$LN71@NewFrame:

; 3087 :             g.NavWindow->FocusIdxTabRequestNext = g.IO.KeyShift ? -1 : 0;

	movzx	eax, BYTE PTR [esi+230]
	neg	eax
	sbb	eax, eax
$LN257@NewFrame:
	mov	DWORD PTR [edi+664], eax
$LN72@NewFrame:

; 3088 :     }
; 3089 :     g.NavIdTabCounter = INT_MAX;
; 3090 : 
; 3091 :     // Mark all windows as not visible
; 3092 :     for (int i = 0; i != g.Windows.Size; i++)

	xor	edx, edx
	mov	DWORD PTR [esi+6448], 2147483647	; 7fffffffH
	cmp	DWORD PTR [esi+6204], edx
	je	SHORT $LN17@NewFrame
	npad	5
$LL18@NewFrame:

; 3093 :     {
; 3094 :         ImGuiWindow* window = g.Windows[i];

	mov	eax, DWORD PTR [esi+6212]
	mov	ecx, DWORD PTR [eax+edx*4]
	inc	edx

; 3095 :         window->WasActive = window->Active;

	mov	al, BYTE PTR [ecx+132]
	mov	BYTE PTR [ecx+133], al

; 3096 :         window->Active = false;

	mov	BYTE PTR [ecx+132], 0

; 3097 :         window->Accessed = false;

	mov	BYTE PTR [ecx+134], 0
	cmp	edx, DWORD PTR [esi+6204]
	jne	SHORT $LL18@NewFrame
$LN17@NewFrame:

; 3098 :     }
; 3099 : 
; 3100 :     // Closing the focused window restore focus to the first active root window in descending z-order
; 3101 :     if (g.NavWindow && !g.NavWindow->WasActive)

	mov	eax, DWORD PTR [esi+6380]
	test	eax, eax
	je	SHORT $LN248@NewFrame
	cmp	BYTE PTR [eax+133], 0
	jne	SHORT $LN248@NewFrame

; 3102 :         for (int i = g.Windows.Size-1; i >= 0; i--)

	mov	ecx, DWORD PTR [esi+6204]
	sub	ecx, 1
	js	SHORT $LN248@NewFrame
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 912  :     inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }

	mov	edx, DWORD PTR [esi+6212]
$LL21@NewFrame:
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3103 :             if (g.Windows[i]->WasActive && !(g.Windows[i]->Flags & ImGuiWindowFlags_ChildWindow))

	mov	eax, DWORD PTR [edx+ecx*4]
	cmp	BYTE PTR [eax+133], 0
	je	SHORT $LN19@NewFrame
	test	DWORD PTR [eax+8], 4194304		; 00400000H
	je	SHORT $LN225@NewFrame
$LN19@NewFrame:

; 3102 :         for (int i = g.Windows.Size-1; i >= 0; i--)

	sub	ecx, 1
	jns	SHORT $LL21@NewFrame
	jmp	SHORT $LN248@NewFrame
$LN225@NewFrame:

; 3104 :             {
; 3105 :                 FocusWindow(g.Windows[i]);

	mov	eax, DWORD PTR [esi+6212]
	push	DWORD PTR [eax+ecx*4]
	call	?FocusWindow@ImGui@@YAXPAUImGuiWindow@@@Z ; ImGui::FocusWindow
	add	esp, 4
$LN248@NewFrame:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	ecx, DWORD PTR [esi+6232]
	test	ecx, ecx
	jns	SHORT $LN201@NewFrame

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	je	SHORT $LN199@NewFrame
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN200@NewFrame
$LN199@NewFrame:
	mov	eax, 8
$LN200@NewFrame:
	xor	edi, edi
	test	eax, eax
	cmovg	edi, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	edi, ecx
	jle	SHORT $LN201@NewFrame

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	lea	eax, DWORD PTR [edi*4]
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [esi+6236]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN203@NewFrame

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi+6228]
	shl	ecx, 2
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN203@NewFrame:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+6236]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+6236], eax

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+6232], edi
$LN201@NewFrame:

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [esi+6228], 0
	mov	ecx, DWORD PTR [esi+6372]
	test	ecx, ecx
	jns	SHORT $LN212@NewFrame

; 926  :     inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }

	je	SHORT $LN210@NewFrame
	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	jmp	SHORT $LN211@NewFrame
$LN210@NewFrame:
	mov	eax, 8
$LN211@NewFrame:
	xor	edi, edi
	test	eax, eax
	cmovg	edi, eax

; 931  :         if (new_capacity <= Capacity) return;

	cmp	edi, ecx
	jle	SHORT $LN212@NewFrame

; 932  :         T* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));

	mov	eax, edi
	shl	eax, 5
	push	eax
	call	?MemAlloc@ImGui@@YAPAXI@Z		; ImGui::MemAlloc

; 933  :         if (Data)

	mov	edx, DWORD PTR [esi+6376]
	add	esp, 4
	mov	DWORD PTR _new_data$1$[ebp], eax
	test	edx, edx
	je	SHORT $LN214@NewFrame

; 934  :             memcpy(new_data, Data, (size_t)Size * sizeof(value_type));

	mov	ecx, DWORD PTR [esi+6368]
	shl	ecx, 5
	push	ecx
	push	edx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN214@NewFrame:

; 935  :         ImGui::MemFree(Data);

	push	DWORD PTR [esi+6376]
	call	?MemFree@ImGui@@YAXPAX@Z		; ImGui::MemFree

; 936  :         Data = new_data;

	mov	eax, DWORD PTR _new_data$1$[ebp]
	add	esp, 4
	mov	DWORD PTR [esi+6376], eax

; 937  :         Capacity = new_capacity;

	mov	DWORD PTR [esi+6372], edi
$LN212@NewFrame:

; 928  :     inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

	mov	DWORD PTR [esi+6368], 0
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3113 :     CloseInactivePopups();

	call	?CloseInactivePopups@@YAXXZ		; CloseInactivePopups

; 3116 :     ImGui::SetNextWindowSize(ImVec2(400,400), ImGuiSetCond_FirstUseEver);

	lea	eax, DWORD PTR $T7[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T7[ebp], 1137180672		; 43c80000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3116 :     ImGui::SetNextWindowSize(ImVec2(400,400), ImGuiSetCond_FirstUseEver);

	push	4
	push	eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	mov	DWORD PTR $T7[ebp+4], 1137180672	; 43c80000H
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp

; 3116 :     ImGui::SetNextWindowSize(ImVec2(400,400), ImGuiSetCond_FirstUseEver);

	call	?SetNextWindowSize@ImGui@@YAXABUImVec2@@H@Z ; ImGui::SetNextWindowSize

; 3117 :     ImGui::Begin("Debug");

	push	0
	push	0
	push	OFFSET $SG116823
	call	?Begin@ImGui@@YA_NPBDPA_NH@Z		; ImGui::Begin
	add	esp, 20					; 00000014H

; 3118 : 
; 3119 :   if (eula.show)

	cmp	BYTE PTR ?eula@@3Ushow_eula_s@@A, 0
	pop	edi
	pop	esi
	je	SHORT $LN75@NewFrame

; 3120 :     SK_ImGui_DrawEULA (&eula);

	push	OFFSET ?eula@@3Ushow_eula_s@@A		; eula
	call	?SK_ImGui_DrawEULA@@YGXPAX@Z		; SK_ImGui_DrawEULA
$LN75@NewFrame:

; 3121 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?NewFrame@ImGui@@YAXXZ$0:
	mov	eax, DWORD PTR _g$[ebp]
	mov	eax, DWORD PTR [eax+11608]
	push	eax
	mov	eax, DWORD PTR $T13[ebp]
	movzx	eax, BYTE PTR [eax]
	push	eax
	mov	eax, DWORD PTR $T12[ebp]
	push	eax
	call	??3@YAXPAXUImPlacementNewDummy@@0@Z	; operator delete
	add	esp, 12					; 0000000cH
	ret	0
__unwindfunclet$?NewFrame@ImGui@@YAXXZ$1:
	mov	ecx, DWORD PTR $T12[ebp]
	jmp	??1?$ImVector@D@@QAE@XZ			; ImVector<char>::~ImVector<char>
__ehhandler$?NewFrame@ImGui@@YAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?NewFrame@ImGui@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?NewFrame@ImGui@@YAXXZ ENDP				; ImGui::NewFrame
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?GetDrawData@ImGui@@YAPAUImDrawData@@XZ PROC		; ImGui::GetDrawData

; 2392 :     return GImGui->RenderDrawData.Valid ? &GImGui->RenderDrawData : NULL;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	xor	ecx, ecx
	add	eax, 6596				; 000019c4H
	cmp	BYTE PTR [eax], cl
	cmovne	ecx, eax
	mov	eax, ecx

; 2393 : }

	ret	0
?GetDrawData@ImGui@@YAPAUImDrawData@@XZ ENDP		; ImGui::GetDrawData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?GetStyle@ImGui@@YAAAUImGuiStyle@@XZ PROC		; ImGui::GetStyle

; 2386 :     return GImGui->Style;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	add	eax, 5320				; 000014c8H

; 2387 : }

	ret	0
?GetStyle@ImGui@@YAAAUImGuiStyle@@XZ ENDP		; ImGui::GetStyle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\imgui.cpp
_TEXT	SEGMENT
?GetIO@ImGui@@YAAAUImGuiIO@@XZ PROC			; ImGui::GetIO

; 2381 :     return GImGui->IO;

	mov	eax, DWORD PTR ?GImGui@@3PAUImGuiContext@@A ; GImGui
	add	eax, 4

; 2382 : }

	ret	0
?GetIO@ImGui@@YAAAUImGuiIO@@XZ ENDP			; ImGui::GetIO
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0ImVec4@@QAE@MMMM@Z
_TEXT	SEGMENT
__x$ = 8						; size = 4
__y$ = 12						; size = 4
__z$ = 16						; size = 4
__w$ = 20						; size = 4
??0ImVec4@@QAE@MMMM@Z PROC				; ImVec4::ImVec4, COMDAT
; _this$ = ecx

; 109  :     ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }

	npad	2
	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR __x$[ebp]
	mov	eax, ecx
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR __y$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	movss	xmm0, DWORD PTR __z$[ebp]
	movss	DWORD PTR [ecx+8], xmm0
	movss	xmm0, DWORD PTR __w$[ebp]
	movss	DWORD PTR [ecx+12], xmm0
	pop	ebp
	ret	16					; 00000010H
??0ImVec4@@QAE@MMMM@Z ENDP				; ImVec4::ImVec4
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0ImVec4@@QAE@XZ
_TEXT	SEGMENT
??0ImVec4@@QAE@XZ PROC					; ImVec4::ImVec4, COMDAT
; _this$ = ecx

; 108  :     ImVec4() { x = y = z = w = 0.0f; }

	mov	DWORD PTR [ecx+12], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx], 0
	ret	0
??0ImVec4@@QAE@XZ ENDP					; ImVec4::ImVec4
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0ImVec2@@QAE@MM@Z
_TEXT	SEGMENT
__x$ = 8						; size = 4
__y$ = 12						; size = 4
??0ImVec2@@QAE@MM@Z PROC				; ImVec2::ImVec2, COMDAT
; _this$ = ecx

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	npad	2
	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR __x$[ebp]
	mov	eax, ecx
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR __y$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	pop	ebp
	ret	8
??0ImVec2@@QAE@MM@Z ENDP				; ImVec2::ImVec2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0ImVec2@@QAE@XZ
_TEXT	SEGMENT
??0ImVec2@@QAE@XZ PROC					; ImVec2::ImVec2, COMDAT
; _this$ = ecx

; 97   :     ImVec2() { x = y = 0.0f; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	ret	0
??0ImVec2@@QAE@XZ ENDP					; ImVec2::ImVec2
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___n$[ebp]
	test	esi, esi
	je	SHORT $LN6@vector
	push	ebx
	mov	ebx, DWORD PTR ___f$[ebp]
	push	edi
	mov	edi, DWORD PTR ___t$[ebp]
$LL2@vector:
	mov	ecx, edi
	call	ebx
	add	edi, DWORD PTR ___s$[ebp]
	sub	esi, 1
	jne	SHORT $LL2@vector
	pop	edi
	pop	ebx
$LN6@vector:
	pop	esi
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
