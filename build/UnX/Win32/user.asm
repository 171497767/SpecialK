; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	C:\Users\andon\Source\Repos\SpecialK\src\steam\user.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?__SK_SteamUser_BLoggedOn@@3HA			; __SK_SteamUser_BLoggedOn
PUBLIC	?SteamAPI_ISteamClient_GetISteamUser_Original@@3P6APAVISteamUser@@PAVISteamClient@@HHPBD@ZA ; SteamAPI_ISteamClient_GetISteamUser_Original
_BSS	SEGMENT
?SteamAPI_ISteamClient_GetISteamUser_Original@@3P6APAVISteamUser@@PAVISteamClient@@HHPBD@ZA DD 01H DUP (?) ; SteamAPI_ISteamClient_GetISteamUser_Original
_BSS	ENDS
CONST	SEGMENT
$SG166349 DB	'SteamAPI_ISteamClient_GetISteamUser_Detour', 00H
	ORG $+1
$SG166350 DB	'[', 00H, '!', 00H, ']', 00H, ' ', 00H, '%', 00H, 'h', 00H
	DB	's', 00H, ' ', 00H, '(', 00H, '.', 00H, '.', 00H, '.', 00H, ','
	DB	00H, ' ', 00H, '%', 00H, 'h', 00H, 's', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG166355 DB	'SteamUser018', 00H
	ORG $+3
$SG166356 DB	'SteamUser019', 00H
	ORG $+3
$SG166357 DB	'SteamUser017', 00H
	ORG $+7
$SG166362 DB	'G', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ' ', 00H, 'r', 00H
	DB	'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, 's', 00H, 't', 00H, 'e'
	DB	00H, 'd', 00H, ' ', 00H, 'u', 00H, 'n', 00H, 'e', 00H, 'x', 00H
	DB	'p', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'e', 00H, 'd', 00H, ' '
	DB	00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'f', 00H
	DB	'a', 00H, 'c', 00H, 'e', 00H, ' ', 00H, 'v', 00H, 'e', 00H, 'r'
	DB	00H, 's', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H, '(', 00H
	DB	'%', 00H, 'h', 00H, 's', 00H, ')', 00H, '!', 00H, 00H, 00H
	ORG $+2
$SG166379 DB	'SK_SteamWrapper_WrappedClient_GetISteamUser', 00H
$SG166380 DB	'[', 00H, '!', 00H, ']', 00H, ' ', 00H, '%', 00H, 'h', 00H
	DB	's', 00H, ' ', 00H, '(', 00H, '.', 00H, '.', 00H, '.', 00H, ','
	DB	00H, ' ', 00H, '%', 00H, 'h', 00H, 's', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG166385 DB	'SteamUser018', 00H
	ORG $+3
$SG166386 DB	'SteamUser019', 00H
	ORG $+3
$SG166387 DB	'SteamUser017', 00H
	ORG $+7
$SG166392 DB	'G', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ' ', 00H, 'r', 00H
	DB	'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, 's', 00H, 't', 00H, 'e'
	DB	00H, 'd', 00H, ' ', 00H, 'u', 00H, 'n', 00H, 'e', 00H, 'x', 00H
	DB	'p', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'e', 00H, 'd', 00H, ' '
	DB	00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'f', 00H
	DB	'a', 00H, 'c', 00H, 'e', 00H, ' ', 00H, 'v', 00H, 'e', 00H, 'r'
	DB	00H, 's', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H, '(', 00H
	DB	'%', 00H, 'h', 00H, 's', 00H, ')', 00H, '!', 00H, 00H, 00H
CONST	ENDS
_DATA	SEGMENT
?__SK_SteamUser_BLoggedOn@@3HA DD 0ffffffffH		; __SK_SteamUser_BLoggedOn
_DATA	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??0ISteamUser@@QAE@XZ				; ISteamUser::ISteamUser
PUBLIC	?_Hash_seq@std@@YAIPBEI@Z			; std::_Hash_seq
PUBLIC	??0exception@std@@QAE@QBD@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	?_Allocate@std@@YAPAXII_N@Z			; std::_Allocate
PUBLIC	?_Deallocate@std@@YAXPAXII@Z			; std::_Deallocate
PUBLIC	??0logic_error@std@@QAE@PBD@Z			; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
PUBLIC	??0out_of_range@std@@QAE@PBD@Z			; std::out_of_range::out_of_range
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
PUBLIC	??_Gout_of_range@std@@UAEPAXI@Z			; std::out_of_range::`scalar deleting destructor'
PUBLIC	?_Reverse_byte@details@Concurrency@@YAEE@Z	; Concurrency::details::_Reverse_byte
PUBLIC	?_Get_msb@details@Concurrency@@YAEI@Z		; Concurrency::details::_Get_msb
PUBLIC	??0?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >
PUBLIC	??0?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >
PUBLIC	??0?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@QAE@ABV?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@12@@Z ; Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0>::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0>
PUBLIC	??0?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@QAE@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@@Z ; Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >
PUBLIC	??R?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@QBEIABQAVISteamUser@@@Z ; Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >::operator()
PUBLIC	??R?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@QBE_NABQAVISteamUser@@0@Z ; Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >::operator()
PUBLIC	??R?$_Bitwise_hash@PAVISteamUser@@@std@@QBEIABQAVISteamUser@@@Z ; std::_Bitwise_hash<ISteamUser *>::operator()
PUBLIC	??R?$equal_to@PAVISteamUser@@@std@@QBE_NABQAVISteamUser@@0@Z ; std::equal_to<ISteamUser *>::operator()
PUBLIC	??0?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@Z ; Concurrency::details::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >
PUBLIC	?deallocate@?$allocator@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAEXPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@I@Z ; std::allocator<Concurrency::details::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Node>::deallocate
PUBLIC	?allocate@?$allocator@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@I@Z ; std::allocator<Concurrency::details::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Node>::allocate
PUBLIC	??0?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@Z ; Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >
PUBLIC	??1?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE@XZ ; Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::~_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >
PUBLIC	?_Buynode@?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@23@I@Z ; Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Buynode
PUBLIC	?_Nextnode@?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@SAAAPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@23@PAU4523@@Z ; Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Nextnode
PUBLIC	?_Myval@?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@SAAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@23@@Z ; Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Myval
PUBLIC	??0?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@Z ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >
PUBLIC	??1?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE@XZ ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::~_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >
PUBLIC	?clear@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAEXXZ ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::clear
PUBLIC	?end@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@XZ ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::end
PUBLIC	?end@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QBE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@XZ ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::end
PUBLIC	?_Begin@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@XZ ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Begin
PUBLIC	?_End@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@XZ ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_End
PUBLIC	?_End@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QBE?AV?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@XZ ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_End
PUBLIC	?_Get_key@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@SAIABV?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@Z ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Get_key
PUBLIC	?_Get_iterator@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@Z ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Get_iterator
PUBLIC	?_Get_iterator@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QBE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@V?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@Z ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Get_iterator
PUBLIC	?_Erase@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAEXPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@23@@Z ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Erase
PUBLIC	?_Insert@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@23@PAU4523@00@Z ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Insert
PUBLIC	?_Insert@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE?AU?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@5@0PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@23@PAJ@Z ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Insert
PUBLIC	?_Insert_dummy@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@V45@I@Z ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Insert_dummy
PUBLIC	?_Check_range@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@AAEXXZ ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Check_range
PUBLIC	??0?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@IABV?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@12@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >
PUBLIC	??1?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@XZ ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::~_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >
PUBLIC	?_Segment_index_of@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@SAII@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Segment_index_of
PUBLIC	?_Segment_base@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@SAII@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Segment_base
PUBLIC	?_Segment_size@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@SAII@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Segment_size
PUBLIC	?end@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@XZ ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::end
PUBLIC	?end@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QBE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@XZ ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::end
PUBLIC	?find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamUser@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::find
PUBLIC	?count@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QBEIABQAVISteamUser@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::count
PUBLIC	?unsafe_max_bucket_count@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QBEIXZ ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::unsafe_max_bucket_count
PUBLIC	?rehash@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAEXI@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::rehash
PUBLIC	?_Init@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXXZ ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Init
PUBLIC	?_Find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamUser@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Find
PUBLIC	?_Find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamUser@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Find
PUBLIC	?_Initialize_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXI@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Initialize_bucket
PUBLIC	?_Adjust_table_size@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXII@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Adjust_table_size
PUBLIC	?_Get_parent@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABEII@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Get_parent
PUBLIC	?_Get_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@I@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Get_bucket
PUBLIC	?_Set_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXIV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Set_bucket
PUBLIC	?_Is_initialized@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABE_NI@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Is_initialized
PUBLIC	?_Reverse@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABEII@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Reverse
PUBLIC	?_Split_order_regular_key@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABEII@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Split_order_regular_key
PUBLIC	?_Split_order_dummy_key@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABEII@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Split_order_dummy_key
PUBLIC	??0?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
PUBLIC	?deallocate@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@2@I@Z ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::deallocate
PUBLIC	?allocate@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@2@I@Z ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::allocate
PUBLIC	??0?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@QAE@IABU?$hash@PAVISteamUser@@@std@@ABU?$equal_to@PAVISteamUser@@@3@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@3@@Z ; Concurrency::concurrent_unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::concurrent_unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >
PUBLIC	??A?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@QAEAAPAVIWrapSteamUser@@ABQAVISteamUser@@@Z ; Concurrency::concurrent_unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::operator[]
PUBLIC	??1?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@QAE@XZ ; Concurrency::concurrent_unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::~concurrent_unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >
PUBLIC	??0IWrapSteamUser@@QAE@PAVISteamUser@@@Z	; IWrapSteamUser::IWrapSteamUser
PUBLIC	?GetHSteamUser@IWrapSteamUser@@UAEHXZ		; IWrapSteamUser::GetHSteamUser
PUBLIC	?BLoggedOn@IWrapSteamUser@@UAE_NXZ		; IWrapSteamUser::BLoggedOn
PUBLIC	?GetSteamID@IWrapSteamUser@@UAE?AVCSteamID@@XZ	; IWrapSteamUser::GetSteamID
PUBLIC	?InitiateGameConnection@IWrapSteamUser@@UAEHPAXHVCSteamID@@IG_N@Z ; IWrapSteamUser::InitiateGameConnection
PUBLIC	?TerminateGameConnection@IWrapSteamUser@@UAEXIG@Z ; IWrapSteamUser::TerminateGameConnection
PUBLIC	?TrackAppUsageEvent@IWrapSteamUser@@UAEXVCGameID@@HPBD@Z ; IWrapSteamUser::TrackAppUsageEvent
PUBLIC	?GetUserDataFolder@IWrapSteamUser@@UAE_NPADH@Z	; IWrapSteamUser::GetUserDataFolder
PUBLIC	?StartVoiceRecording@IWrapSteamUser@@UAEXXZ	; IWrapSteamUser::StartVoiceRecording
PUBLIC	?StopVoiceRecording@IWrapSteamUser@@UAEXXZ	; IWrapSteamUser::StopVoiceRecording
PUBLIC	?GetAvailableVoice@IWrapSteamUser@@UAE?AW4EVoiceResult@@PAI0I@Z ; IWrapSteamUser::GetAvailableVoice
PUBLIC	?GetVoice@IWrapSteamUser@@UAE?AW4EVoiceResult@@_NPAXIPAI01I2I@Z ; IWrapSteamUser::GetVoice
PUBLIC	?DecompressVoice@IWrapSteamUser@@UAE?AW4EVoiceResult@@PBXIPAXIPAII@Z ; IWrapSteamUser::DecompressVoice
PUBLIC	?GetVoiceOptimalSampleRate@IWrapSteamUser@@UAEIXZ ; IWrapSteamUser::GetVoiceOptimalSampleRate
PUBLIC	?GetAuthSessionTicket@IWrapSteamUser@@UAEIPAXHPAI@Z ; IWrapSteamUser::GetAuthSessionTicket
PUBLIC	?BeginAuthSession@IWrapSteamUser@@UAE?AW4EBeginAuthSessionResult@@PBXHVCSteamID@@@Z ; IWrapSteamUser::BeginAuthSession
PUBLIC	?EndAuthSession@IWrapSteamUser@@UAEXVCSteamID@@@Z ; IWrapSteamUser::EndAuthSession
PUBLIC	?CancelAuthTicket@IWrapSteamUser@@UAEXI@Z	; IWrapSteamUser::CancelAuthTicket
PUBLIC	?UserHasLicenseForApp@IWrapSteamUser@@UAE?AW4EUserHasLicenseForAppResult@@VCSteamID@@I@Z ; IWrapSteamUser::UserHasLicenseForApp
PUBLIC	?BIsBehindNAT@IWrapSteamUser@@UAE_NXZ		; IWrapSteamUser::BIsBehindNAT
PUBLIC	?AdvertiseGame@IWrapSteamUser@@UAEXVCSteamID@@IG@Z ; IWrapSteamUser::AdvertiseGame
PUBLIC	?RequestEncryptedAppTicket@IWrapSteamUser@@UAE_KPAXH@Z ; IWrapSteamUser::RequestEncryptedAppTicket
PUBLIC	?GetEncryptedAppTicket@IWrapSteamUser@@UAE_NPAXHPAI@Z ; IWrapSteamUser::GetEncryptedAppTicket
PUBLIC	?GetGameBadgeLevel@IWrapSteamUser@@UAEHH_N@Z	; IWrapSteamUser::GetGameBadgeLevel
PUBLIC	?GetPlayerSteamLevel@IWrapSteamUser@@UAEHXZ	; IWrapSteamUser::GetPlayerSteamLevel
PUBLIC	?RequestStoreAuthURL@IWrapSteamUser@@UAE_KPBD@Z	; IWrapSteamUser::RequestStoreAuthURL
PUBLIC	?BIsPhoneVerified@IWrapSteamUser@@UAE_NXZ	; IWrapSteamUser::BIsPhoneVerified
PUBLIC	?BIsTwoFactorEnabled@IWrapSteamUser@@UAE_NXZ	; IWrapSteamUser::BIsTwoFactorEnabled
PUBLIC	?BIsPhoneIdentifying@IWrapSteamUser@@UAE_NXZ	; IWrapSteamUser::BIsPhoneIdentifying
PUBLIC	?BIsPhoneRequiringVerification@IWrapSteamUser@@UAE_NXZ ; IWrapSteamUser::BIsPhoneRequiringVerification
PUBLIC	?SteamAPI_ISteamClient_GetISteamUser_Detour@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z ; SteamAPI_ISteamClient_GetISteamUser_Detour
PUBLIC	?SK_SteamWrapper_WrappedClient_GetISteamUser@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z ; SK_SteamWrapper_WrappedClient_GetISteamUser
PUBLIC	??0?$_Flist_unchecked_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@U_Iterator_base0@std@@@std@@QAE@XZ ; std::_Flist_unchecked_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>::_Flist_unchecked_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>
PUBLIC	??0?$_Flist_unchecked_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@U_Iterator_base0@std@@@std@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@PBV?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@45@@Z ; std::_Flist_unchecked_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>::_Flist_unchecked_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>
PUBLIC	?_Mynode@?$_Flist_unchecked_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@U_Iterator_base0@std@@@std@@QBEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@XZ ; std::_Flist_unchecked_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>::_Mynode
PUBLIC	??0?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAE@XZ ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >
PUBLIC	??0?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@PBV?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@45@@Z ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >
PUBLIC	??D?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QBEABU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@XZ ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator*
PUBLIC	??E?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAEAAV01@XZ ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator++
PUBLIC	??E?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAE?AV01@H@Z ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator++
PUBLIC	??8?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QBE_NABV01@@Z ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator==
PUBLIC	??9?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QBE_NABV01@@Z ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator!=
PUBLIC	??0?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@12@PBV?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@12@@Z ; Concurrency::details::_Solist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Solist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >
PUBLIC	??D?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QBEABU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@XZ ; Concurrency::details::_Solist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator*
PUBLIC	??E?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QAEAAV012@XZ ; Concurrency::details::_Solist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator++
PUBLIC	??E?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QAE?AV012@H@Z ; Concurrency::details::_Solist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator++
PUBLIC	??$_Key_function@QAVISteamUser@@PAVIWrapSteamUser@@@?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@SAABQAVISteamUser@@ABU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@Z ; Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0>::_Key_function<ISteamUser * const,IWrapSteamUser *>
PUBLIC	??0?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAE@XZ ; std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >
PUBLIC	??0?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@PBV?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@45@@Z ; std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >
PUBLIC	??D?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QBEAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@XZ ; std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator*
PUBLIC	??E?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAEAAV01@XZ ; std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator++
PUBLIC	??E?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAE?AV01@H@Z ; std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator++
PUBLIC	??$destroy@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@1@@Z ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::destroy<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
PUBLIC	??0?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@12@PBV?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@12@@Z ; Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >
PUBLIC	??D?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QBEAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@XZ ; Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator*
PUBLIC	??$make_pair@ABQAVISteamUser@@PAVIWrapSteamUser@@@std@@YA?AU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@0@ABQAVISteamUser@@$$QAPAVIWrapSteamUser@@@Z ; std::make_pair<ISteamUser * const &,IWrapSteamUser *>
PUBLIC	??$_Insert@U?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@IAE?AU?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@$$QAU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@4@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Insert<std::pair<ISteamUser *,IWrapSteamUser *> >
PUBLIC	?_Init@_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAEXI@Z ; Concurrency::details::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Node::_Init
PUBLIC	?_Get_order_key@_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QBEIXZ ; Concurrency::details::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Node::_Get_order_key
PUBLIC	?_Atomic_set_next@_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAEPAU1234@PAU1234@0@Z ; Concurrency::details::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Node::_Atomic_set_next
PUBLIC	?_Is_dummy@_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QBE_NXZ ; Concurrency::details::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Node::_Is_dummy
PUBLIC	??$?0U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > ><std::pair<ISteamUser * const,IWrapSteamUser *> >
PUBLIC	??$destroy@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@?$allocator@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAEXPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@Z ; std::allocator<Concurrency::details::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Node>::destroy<Concurrency::details::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Node>
PUBLIC	??$?0AAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@std@@QAE@AAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >::_Wrap_alloc<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > ><std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > &>
PUBLIC	??$_Uninitialized_default_fill_n@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@IV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@2@@std@@YAPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@0@PAV10@IAAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,unsigned int,std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >
PUBLIC	??$?0U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$allocator@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z ; std::allocator<Concurrency::details::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Node>::allocator<Concurrency::details::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Node><std::pair<ISteamUser * const,IWrapSteamUser *> >
PUBLIC	??$forward@ABQAVISteamUser@@@std@@YAABQAVISteamUser@@ABQAV1@@Z ; std::forward<ISteamUser * const &>
PUBLIC	??$forward@PAVIWrapSteamUser@@@std@@YA$$QAPAVIWrapSteamUser@@AAPAV1@@Z ; std::forward<IWrapSteamUser *>
PUBLIC	??$?0ABQAVISteamUser@@PAVIWrapSteamUser@@X$0A@@?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@std@@QAE@ABQAVISteamUser@@$$QAPAVIWrapSteamUser@@@Z ; std::pair<ISteamUser *,IWrapSteamUser *>::pair<ISteamUser *,IWrapSteamUser *><ISteamUser * const &,IWrapSteamUser *,void,0>
PUBLIC	??$_Key_function@PAVISteamUser@@PAVIWrapSteamUser@@@?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@SAABQAVISteamUser@@ABU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@std@@@Z ; Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0>::_Key_function<ISteamUser *,IWrapSteamUser *>
PUBLIC	??$forward@U?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@YA$$QAU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@0@AAU10@@Z ; std::forward<std::pair<ISteamUser *,IWrapSteamUser *> >
PUBLIC	??$_Buynode@U?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@12@I$$QAU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@std@@@Z ; Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Buynode<std::pair<ISteamUser *,IWrapSteamUser *> >
PUBLIC	??$?0V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_NX$0A@@?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@QAE@$$QAV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@$$QA_N@Z ; std::pair<Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,bool>::pair<Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,bool><Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,bool,void,0>
PUBLIC	??$forward@AAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@std@@YAAAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@0@AAV10@@Z ; std::forward<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > &>
PUBLIC	??$_Unfancy@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@YAPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@0@PAV10@@Z ; std::_Unfancy<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
PUBLIC	??$_Uninitialized_default_fill_n1@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@IV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@2@@std@@YAPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@0@PAV10@IAAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,unsigned int,std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >
PUBLIC	??$addressof@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@YAPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@0@AAU10@@Z ; std::addressof<std::pair<ISteamUser * const,IWrapSteamUser *> >
PUBLIC	??$construct@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@U?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@2@@?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@QAEXPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@$$QAU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@1@@Z ; std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >::construct<std::pair<ISteamUser * const,IWrapSteamUser *>,std::pair<ISteamUser *,IWrapSteamUser *> >
PUBLIC	??$forward@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@@std@@YA$$QAV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@AAV123@@Z ; std::forward<Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
PUBLIC	??$forward@_N@std@@YA$$QA_NAA_N@Z		; std::forward<bool>
PUBLIC	??$construct@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@$$V@?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@std@@QAEXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >::construct<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
PUBLIC	??$_Destroy_range@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@2@@std@@YAXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >,std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *>
PUBLIC	??$?0PAVISteamUser@@PAVIWrapSteamUser@@X$0A@@?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@QAE@$$QAU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@1@@Z ; std::pair<ISteamUser * const,IWrapSteamUser *>::pair<ISteamUser * const,IWrapSteamUser *><ISteamUser *,IWrapSteamUser *,void,0>
PUBLIC	??$construct@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@$$V@?$allocator_traits@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@std@@SAXAAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@1@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@1@@Z ; std::allocator_traits<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >::construct<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
PUBLIC	??$_Destroy_range1@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@2@@std@@YAXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >,std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *>
PUBLIC	??$forward@PAVISteamUser@@@std@@YA$$QAPAVISteamUser@@AAPAV1@@Z ; std::forward<ISteamUser *>
PUBLIC	??$construct@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@$$V@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@1@@Z ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::construct<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
PUBLIC	??_7ISteamUser@@6B@				; ISteamUser::`vftable'
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception?$AA@	; `string'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	?SK_SteamWrapper_remap_user@@3V?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@A ; SK_SteamWrapper_remap_user
PUBLIC	??_7IWrapSteamUser@@6B@				; IWrapSteamUser::`vftable'
PUBLIC	__TI3?AVout_of_range@std@@
PUBLIC	__CTA3?AVout_of_range@std@@
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BK@KDCGEAPC@invalid?5number?5of?5buckets?$AA@ ; `string'
PUBLIC	??_R4ISteamUser@@6B@				; ISteamUser::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVISteamUser@@@8				; ISteamUser `RTTI Type Descriptor'
PUBLIC	??_R3ISteamUser@@8				; ISteamUser::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ISteamUser@@8				; ISteamUser::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ISteamUser@@8			; ISteamUser::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4out_of_range@std@@6B@			; std::out_of_range::`RTTI Complete Object Locator'
PUBLIC	??_R3out_of_range@std@@8			; std::out_of_range::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2out_of_range@std@@8			; std::out_of_range::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@out_of_range@std@@8		; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4IWrapSteamUser@@6B@			; IWrapSteamUser::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVIWrapSteamUser@@@8			; IWrapSteamUser `RTTI Type Descriptor'
PUBLIC	??_R3IWrapSteamUser@@8				; IWrapSteamUser::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IWrapSteamUser@@8				; IWrapSteamUser::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IWrapSteamUser@@8			; IWrapSteamUser::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__imp___invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp__lstrcmpA@8:PROC
EXTRN	__imp____std_exception_copy:PROC
EXTRN	__imp____std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:PROC		; std::out_of_range::`vector deleting destructor'
EXTRN	?Log@iSK_Logger@@UAAXQB_WZZ:PROC		; iSK_Logger::Log
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?steam_log@@3UiSK_Logger@@A:BYTE		; steam_log
EXTRN	?config@@3Usk_config_t@@A:BYTE			; config
EXTRN	__imp_?_Byte_reverse_table@details@Concurrency@@3QBEB:BYTE
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?SK_SteamWrapper_remap_user@@3V?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@A DB 09cH DUP (?) ; SK_SteamWrapper_remap_user
_BSS	ENDS
CRT$XCU	SEGMENT
?SK_SteamWrapper_remap_user$initializer$@@3P6AXXZA DD FLAT:??__ESK_SteamWrapper_remap_user@@YAXXZ ; SK_SteamWrapper_remap_user$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@IWrapSteamUser@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IWrapSteamUser@@8 DD FLAT:??_R0?AVIWrapSteamUser@@@8 ; IWrapSteamUser::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IWrapSteamUser@@8
rdata$r	ENDS
;	COMDAT ??_R2IWrapSteamUser@@8
rdata$r	SEGMENT
??_R2IWrapSteamUser@@8 DD FLAT:??_R1A@?0A@EA@IWrapSteamUser@@8 ; IWrapSteamUser::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ISteamUser@@8
rdata$r	ENDS
;	COMDAT ??_R3IWrapSteamUser@@8
rdata$r	SEGMENT
??_R3IWrapSteamUser@@8 DD 00H				; IWrapSteamUser::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2IWrapSteamUser@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVIWrapSteamUser@@@8
data$r	SEGMENT
??_R0?AVIWrapSteamUser@@@8 DD FLAT:??_7type_info@@6B@	; IWrapSteamUser `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIWrapSteamUser@@', 00H
data$r	ENDS
;	COMDAT ??_R4IWrapSteamUser@@6B@
rdata$r	SEGMENT
??_R4IWrapSteamUser@@6B@ DD 00H				; IWrapSteamUser::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVIWrapSteamUser@@@8
	DD	FLAT:??_R3IWrapSteamUser@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@out_of_range@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@out_of_range@std@@8 DD FLAT:??_R0?AVout_of_range@std@@@8 ; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT
??_R2out_of_range@std@@8 DD FLAT:??_R1A@?0A@EA@out_of_range@std@@8 ; std::out_of_range::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT
??_R3out_of_range@std@@8 DD 00H				; std::out_of_range::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT
??_R4out_of_range@std@@6B@ DD 00H			; std::out_of_range::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ISteamUser@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ISteamUser@@8 DD FLAT:??_R0?AVISteamUser@@@8 ; ISteamUser::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ISteamUser@@8
rdata$r	ENDS
;	COMDAT ??_R2ISteamUser@@8
rdata$r	SEGMENT
??_R2ISteamUser@@8 DD FLAT:??_R1A@?0A@EA@ISteamUser@@8	; ISteamUser::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3ISteamUser@@8
rdata$r	SEGMENT
??_R3ISteamUser@@8 DD 00H				; ISteamUser::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ISteamUser@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVISteamUser@@@8
data$r	SEGMENT
??_R0?AVISteamUser@@@8 DD FLAT:??_7type_info@@6B@	; ISteamUser `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVISteamUser@@', 00H
data$r	ENDS
;	COMDAT ??_R4ISteamUser@@6B@
rdata$r	SEGMENT
??_R4ISteamUser@@6B@ DD 00H				; ISteamUser::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVISteamUser@@@8
	DD	FLAT:??_R3ISteamUser@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BK@KDCGEAPC@invalid?5number?5of?5buckets?$AA@
CONST	SEGMENT
??_C@_0BK@KDCGEAPC@invalid?5number?5of?5buckets?$AA@ DB 'invalid number o'
	DB	'f buckets', 00H				; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
data$r	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
data$r	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT
__CTA3?AVout_of_range@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT
__TI3?AVout_of_range@std@@ DD 00H
	DD	FLAT:??1out_of_range@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVout_of_range@std@@
xdata$x	ENDS
;	COMDAT ?first@?BD@??SK_SteamWrapper_WrappedClient_GetISteamUser@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z@4_NA
_DATA	SEGMENT
?first@?BD@??SK_SteamWrapper_WrappedClient_GetISteamUser@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z@4_NA DB 01H ; `SK_SteamWrapper_WrappedClient_GetISteamUser'::`19'::first
_DATA	ENDS
;	COMDAT ?first@?2??SK_SteamWrapper_WrappedClient_GetISteamUser@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z@4_NA
_DATA	SEGMENT
?first@?2??SK_SteamWrapper_WrappedClient_GetISteamUser@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z@4_NA DB 01H ; `SK_SteamWrapper_WrappedClient_GetISteamUser'::`3'::first
_DATA	ENDS
;	COMDAT ?first@?BD@??SteamAPI_ISteamClient_GetISteamUser_Detour@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z@4_NA
_DATA	SEGMENT
?first@?BD@??SteamAPI_ISteamClient_GetISteamUser_Detour@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z@4_NA DB 01H ; `SteamAPI_ISteamClient_GetISteamUser_Detour'::`19'::first
_DATA	ENDS
;	COMDAT ?first@?2??SteamAPI_ISteamClient_GetISteamUser_Detour@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z@4_NA
_DATA	SEGMENT
?first@?2??SteamAPI_ISteamClient_GetISteamUser_Detour@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z@4_NA DB 01H ; `SteamAPI_ISteamClient_GetISteamUser_Detour'::`3'::first
_DATA	ENDS
;	COMDAT ??_7IWrapSteamUser@@6B@
CONST	SEGMENT
??_7IWrapSteamUser@@6B@ DD FLAT:??_R4IWrapSteamUser@@6B@ ; IWrapSteamUser::`vftable'
	DD	FLAT:?GetHSteamUser@IWrapSteamUser@@UAEHXZ
	DD	FLAT:?BLoggedOn@IWrapSteamUser@@UAE_NXZ
	DD	FLAT:?GetSteamID@IWrapSteamUser@@UAE?AVCSteamID@@XZ
	DD	FLAT:?InitiateGameConnection@IWrapSteamUser@@UAEHPAXHVCSteamID@@IG_N@Z
	DD	FLAT:?TerminateGameConnection@IWrapSteamUser@@UAEXIG@Z
	DD	FLAT:?TrackAppUsageEvent@IWrapSteamUser@@UAEXVCGameID@@HPBD@Z
	DD	FLAT:?GetUserDataFolder@IWrapSteamUser@@UAE_NPADH@Z
	DD	FLAT:?StartVoiceRecording@IWrapSteamUser@@UAEXXZ
	DD	FLAT:?StopVoiceRecording@IWrapSteamUser@@UAEXXZ
	DD	FLAT:?GetAvailableVoice@IWrapSteamUser@@UAE?AW4EVoiceResult@@PAI0I@Z
	DD	FLAT:?GetVoice@IWrapSteamUser@@UAE?AW4EVoiceResult@@_NPAXIPAI01I2I@Z
	DD	FLAT:?DecompressVoice@IWrapSteamUser@@UAE?AW4EVoiceResult@@PBXIPAXIPAII@Z
	DD	FLAT:?GetVoiceOptimalSampleRate@IWrapSteamUser@@UAEIXZ
	DD	FLAT:?GetAuthSessionTicket@IWrapSteamUser@@UAEIPAXHPAI@Z
	DD	FLAT:?BeginAuthSession@IWrapSteamUser@@UAE?AW4EBeginAuthSessionResult@@PBXHVCSteamID@@@Z
	DD	FLAT:?EndAuthSession@IWrapSteamUser@@UAEXVCSteamID@@@Z
	DD	FLAT:?CancelAuthTicket@IWrapSteamUser@@UAEXI@Z
	DD	FLAT:?UserHasLicenseForApp@IWrapSteamUser@@UAE?AW4EUserHasLicenseForAppResult@@VCSteamID@@I@Z
	DD	FLAT:?BIsBehindNAT@IWrapSteamUser@@UAE_NXZ
	DD	FLAT:?AdvertiseGame@IWrapSteamUser@@UAEXVCSteamID@@IG@Z
	DD	FLAT:?RequestEncryptedAppTicket@IWrapSteamUser@@UAE_KPAXH@Z
	DD	FLAT:?GetEncryptedAppTicket@IWrapSteamUser@@UAE_NPAXHPAI@Z
	DD	FLAT:?GetGameBadgeLevel@IWrapSteamUser@@UAEHH_N@Z
	DD	FLAT:?GetPlayerSteamLevel@IWrapSteamUser@@UAEHXZ
	DD	FLAT:?RequestStoreAuthURL@IWrapSteamUser@@UAE_KPBD@Z
	DD	FLAT:?BIsPhoneVerified@IWrapSteamUser@@UAE_NXZ
	DD	FLAT:?BIsTwoFactorEnabled@IWrapSteamUser@@UAE_NXZ
	DD	FLAT:?BIsPhoneIdentifying@IWrapSteamUser@@UAE_NXZ
	DD	FLAT:?BIsPhoneRequiringVerification@IWrapSteamUser@@UAE_NXZ
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_R4out_of_range@std@@6B@ ; std::out_of_range::`vftable'
	DD	FLAT:??_Eout_of_range@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception?$AA@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception?$AA@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7ISteamUser@@6B@
CONST	SEGMENT
??_7ISteamUser@@6B@ DD FLAT:??_R4ISteamUser@@6B@	; ISteamUser::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??__ESK_SteamWrapper_remap_user@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??__ESK_SteamWrapper_remap_user@@YAXXZ$1
__ehfuncinfo$??__ESK_SteamWrapper_remap_user@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??__ESK_SteamWrapper_remap_user@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@QAE@IABU?$hash@PAVISteamUser@@@std@@ABU?$equal_to@PAVISteamUser@@@3@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@QAE@IABU?$hash@PAVISteamUser@@@std@@ABU?$equal_to@PAVISteamUser@@@3@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@3@@Z$0
__ehfuncinfo$??0?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@QAE@IABU?$hash@PAVISteamUser@@@std@@ABU?$equal_to@PAVISteamUser@@@3@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@QAE@IABU?$hash@PAVISteamUser@@@std@@ABU?$equal_to@PAVISteamUser@@@3@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@IABV?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@12@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@IABV?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@12@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@Z$0
__ehfuncinfo$??0?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@IABV?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@12@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@IABV?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@12@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@$$V@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$construct@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@$$V@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@1@@Z PROC ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::construct<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >, COMDAT
; _this$ = ecx

; 839  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	eax, eax
	je	SHORT $LN3@construct
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 38   : 		: _Ptr()

	mov	DWORD PTR [eax], 0
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 841  : 		}

	pop	ebp
	ret	4
??$construct@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@$$V@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@1@@Z ENDP ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::construct<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@PAVISteamUser@@@std@@YA$$QAPAVISteamUser@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PAVISteamUser@@@std@@YA$$QAPAVISteamUser@@AAPAV1@@Z PROC ; std::forward<ISteamUser *>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@PAVISteamUser@@@std@@YA$$QAPAVISteamUser@@AAPAV1@@Z ENDP ; std::forward<ISteamUser *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@2@@std@@YAXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range1@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@2@@std@@YAXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >,std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *>, COMDAT

; 1208 : 		// nothing to do
; 1209 : 	}

	ret	0
??$_Destroy_range1@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@2@@std@@YAXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >,std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@$$V@?$allocator_traits@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@std@@SAXAAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@1@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$construct@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@$$V@?$allocator_traits@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@std@@SAXAAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@1@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >::construct<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >, COMDAT

; 958  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	eax, eax
	je	SHORT $LN5@construct
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 38   : 		: _Ptr()

	mov	DWORD PTR [eax], 0
$LN5@construct:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 960  : 		}

	pop	ebp
	ret	0
??$construct@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@$$V@?$allocator_traits@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@std@@SAXAAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@1@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >::construct<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
;	COMDAT ??$?0PAVISteamUser@@PAVIWrapSteamUser@@X$0A@@?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@QAE@$$QAU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0PAVISteamUser@@PAVIWrapSteamUser@@X$0A@@?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@QAE@$$QAU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@1@@Z PROC ; std::pair<ISteamUser * const,IWrapSteamUser *>::pair<ISteamUser * const,IWrapSteamUser *><ISteamUser *,IWrapSteamUser *,void,0>, COMDAT
; _this$ = ecx

; 217  : 		{	// construct from moved compatible pair

	npad	2
	push	ebp
	mov	ebp, esp

; 215  : 		: first(_STD forward<_Other1>(_Right.first)),

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 216  : 			second(_STD forward<_Other2>(_Right.second))

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 218  : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??$?0PAVISteamUser@@PAVIWrapSteamUser@@X$0A@@?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@QAE@$$QAU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@1@@Z ENDP ; std::pair<ISteamUser * const,IWrapSteamUser *>::pair<ISteamUser * const,IWrapSteamUser *><ISteamUser *,IWrapSteamUser *,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@2@@std@@YAXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@2@@std@@YAXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >,std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *>, COMDAT

; 1215 : 		// note that this is an optimization for debug mode codegen;
; 1216 : 		// in release mode the BE removes all of this
; 1217 : 	typedef typename _Alloc::value_type _Val;
; 1218 : 	_Destroy_range1(_First, _Last, _Al, _Conjunction_t<
; 1219 : 		is_trivially_destructible<_Val>,
; 1220 : 		_Uses_default_destroy<_Alloc, _Val *>>());
; 1221 : 	}

	ret	0
??$_Destroy_range@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@2@@std@@YAXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >,std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@$$V@?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@std@@QAEXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$construct@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@$$V@?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@std@@QAEXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >::construct<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >, COMDAT
; _this$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	eax, eax
	je	SHORT $LN7@construct
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 38   : 		: _Ptr()

	mov	DWORD PTR [eax], 0
$LN7@construct:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1098 : 		}

	pop	ebp
	ret	4
??$construct@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@$$V@?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@std@@QAEXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >::construct<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@_N@std@@YA$$QA_NAA_N@Z PROC			; std::forward<bool>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@_N@std@@YA$$QA_NAA_N@Z ENDP			; std::forward<bool>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@@std@@YA$$QAV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@AAV123@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@@std@@YA$$QAV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@AAV123@@Z PROC ; std::forward<Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@@std@@YA$$QAV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@AAV123@@Z ENDP ; std::forward<Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@U?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@2@@?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@QAEXPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@$$QAU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@U?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@2@@?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@QAEXPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@$$QAU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@1@@Z PROC ; std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >::construct<std::pair<ISteamUser * const,IWrapSteamUser *>,std::pair<ISteamUser *,IWrapSteamUser *> >, COMDAT
; _this$ = ecx

; 839  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	edx, DWORD PTR __Ptr$[ebp]
	test	edx, edx
	je	SHORT $LN3@construct
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 215  : 		: first(_STD forward<_Other1>(_Right.first)),

	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 216  : 			second(_STD forward<_Other2>(_Right.second))

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 841  : 		}

	pop	ebp
	ret	8
??$construct@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@U?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@2@@?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@QAEXPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@$$QAU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@1@@Z ENDP ; std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >::construct<std::pair<ISteamUser * const,IWrapSteamUser *>,std::pair<ISteamUser *,IWrapSteamUser *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@YAPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@YAPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@0@AAU10@@Z PROC ; std::addressof<std::pair<ISteamUser * const,IWrapSteamUser *> >, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@YAPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<ISteamUser * const,IWrapSteamUser *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n1@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@IV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@2@@std@@YAPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@0@PAV10@IAAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Uninitialized_default_fill_n1@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@IV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@2@@std@@YAPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@0@PAV10@IAAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Uninitialized_default_fill_n1<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,unsigned int,std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >, COMDAT

; 228  : 	{	// value-initialize _Count objects to raw _First, using _Al, no special optimization

	npad	2
	push	ebp
	mov	ebp, esp

; 232  : 	for (; 0 < _Count; --_Count, (void)++_First)

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@Uninitiali
	npad	1
$LL4@Uninitiali:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN19@Uninitiali
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 38   : 		: _Ptr()

	mov	DWORD PTR [eax], 0
$LN19@Uninitiali:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 232  : 	for (; 0 < _Count; --_Count, (void)++_First)

	add	eax, 4
	sub	ecx, 1
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 233  : 		{
; 234  : 		_Al.construct(_Unfancy(_First));
; 235  : 		}
; 236  : 
; 237  : 	_CATCH_ALL
; 238  : 	_Destroy_range(_Next, _First, _Al);
; 239  : 	_RERAISE;
; 240  : 	_CATCH_END
; 241  : 
; 242  : 	return (_First);
; 243  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_default_fill_n1@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@IV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@2@@std@@YAPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@0@PAV10@IAAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Uninitialized_default_fill_n1<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,unsigned int,std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$_Unfancy@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@YAPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@0@PAV10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@YAPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@0@PAV10@@Z PROC ; std::_Unfancy<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >, COMDAT

; 642  : 	{	// do nothing for plain pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 644  : 	}

	pop	ebp
	ret	0
??$_Unfancy@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@YAPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@0@PAV10@@Z ENDP ; std::_Unfancy<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@AAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@std@@YAAAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@std@@YAAAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@0@AAV10@@Z PROC ; std::forward<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@AAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@std@@YAAAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
;	COMDAT ??$?0V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_NX$0A@@?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@QAE@$$QAV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_NX$0A@@?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@QAE@$$QAV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@$$QA_N@Z PROC ; std::pair<Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,bool>::pair<Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,bool><Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,bool,void,0>, COMDAT
; _this$ = ecx

; 189  : 		{	// construct from moved values

	npad	2
	push	ebp
	mov	ebp, esp

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[ebp]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+4], al

; 190  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??$?0V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_NX$0A@@?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@QAE@$$QAV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@$$QA_N@Z ENDP ; std::pair<Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,bool>::pair<Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,bool><Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,bool,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ??$_Buynode@U?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@12@I$$QAU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@std@@@Z
_TEXT	SEGMENT
__Order_key$ = 8					; size = 4
__Value$ = 12						; size = 4
??$_Buynode@U?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@12@I$$QAU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@std@@@Z PROC ; Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Buynode<std::pair<ISteamUser *,IWrapSteamUser *> >, COMDAT
; _this$ = ecx

; 323  :     {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	edx, edx
	jne	SHORT $LN17@Buynode
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN51@Buynode:
$LN17@Buynode:
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 358  :         return ((reference)(*_Pnode)._M_element);

	lea	esi, DWORD PTR [edx+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	esi, esi
	je	SHORT $LN31@Buynode
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 215  : 		: first(_STD forward<_Other1>(_Right.first)),

	mov	ecx, DWORD PTR __Value$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [esi], eax

; 216  : 			second(_STD forward<_Other2>(_Right.second))

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], eax
$LN31@Buynode:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 215  :             _M_order_key = _Order_key;

	mov	eax, DWORD PTR __Order_key$[ebp]
	mov	DWORD PTR [edx+12], eax

; 324  :         _Nodeptr _Pnode = this->_M_node_allocator.allocate(1);
; 325  : 
; 326  :         try
; 327  :         {
; 328  :             this->_M_value_allocator.construct(std::addressof(_Myval(_Pnode)), std::forward<_ValTy>(_Value));
; 329  :             _Pnode->_Init(_Order_key);
; 330  :         }
; 331  :         catch(...)
; 332  :         {
; 333  :             this->_M_node_allocator.deallocate(_Pnode, 1);
; 334  :             throw;
; 335  :         }
; 336  : 
; 337  :         return (_Pnode);

	mov	eax, edx

; 216  :             _M_next = NULL;

	mov	DWORD PTR [edx], 0
	pop	esi

; 338  :     }

	pop	ebp
	ret	8
$LN50@Buynode:
??$_Buynode@U?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@12@I$$QAU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@std@@@Z ENDP ; Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Buynode<std::pair<ISteamUser *,IWrapSteamUser *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@U?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@YA$$QAU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@YA$$QAU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@0@AAU10@@Z PROC ; std::forward<std::pair<ISteamUser *,IWrapSteamUser *> >, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@U?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@YA$$QAU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@0@AAU10@@Z ENDP ; std::forward<std::pair<ISteamUser *,IWrapSteamUser *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
;	COMDAT ??$_Key_function@PAVISteamUser@@PAVIWrapSteamUser@@@?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@SAABQAVISteamUser@@ABU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@std@@@Z
_TEXT	SEGMENT
__Value$ = 8						; size = 4
??$_Key_function@PAVISteamUser@@PAVIWrapSteamUser@@@?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@SAABQAVISteamUser@@ABU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@std@@@Z PROC ; Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0>::_Key_function<ISteamUser *,IWrapSteamUser *>, COMDAT

; 84   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 85   :         return (_Value.first);

	mov	eax, DWORD PTR __Value$[ebp]

; 86   :     }

	pop	ebp
	ret	0
??$_Key_function@PAVISteamUser@@PAVIWrapSteamUser@@@?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@SAABQAVISteamUser@@ABU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@std@@@Z ENDP ; Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0>::_Key_function<ISteamUser *,IWrapSteamUser *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
;	COMDAT ??$?0ABQAVISteamUser@@PAVIWrapSteamUser@@X$0A@@?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@std@@QAE@ABQAVISteamUser@@$$QAPAVIWrapSteamUser@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0ABQAVISteamUser@@PAVIWrapSteamUser@@X$0A@@?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@std@@QAE@ABQAVISteamUser@@$$QAPAVIWrapSteamUser@@@Z PROC ; std::pair<ISteamUser *,IWrapSteamUser *>::pair<ISteamUser *,IWrapSteamUser *><ISteamUser * const &,IWrapSteamUser *,void,0>, COMDAT
; _this$ = ecx

; 189  : 		{	// construct from moved values

	npad	2
	push	ebp
	mov	ebp, esp

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax

; 190  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??$?0ABQAVISteamUser@@PAVIWrapSteamUser@@X$0A@@?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@std@@QAE@ABQAVISteamUser@@$$QAPAVIWrapSteamUser@@@Z ENDP ; std::pair<ISteamUser *,IWrapSteamUser *>::pair<ISteamUser *,IWrapSteamUser *><ISteamUser * const &,IWrapSteamUser *,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@PAVIWrapSteamUser@@@std@@YA$$QAPAVIWrapSteamUser@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PAVIWrapSteamUser@@@std@@YA$$QAPAVIWrapSteamUser@@AAPAV1@@Z PROC ; std::forward<IWrapSteamUser *>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@PAVIWrapSteamUser@@@std@@YA$$QAPAVIWrapSteamUser@@AAPAV1@@Z ENDP ; std::forward<IWrapSteamUser *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@ABQAVISteamUser@@@std@@YAABQAVISteamUser@@ABQAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAVISteamUser@@@std@@YAABQAVISteamUser@@ABQAV1@@Z PROC ; std::forward<ISteamUser * const &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@ABQAVISteamUser@@@std@@YAABQAVISteamUser@@ABQAV1@@Z ENDP ; std::forward<ISteamUser * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$?0U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$allocator@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$allocator@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z PROC ; std::allocator<Concurrency::details::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Node>::allocator<Concurrency::details::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Node><std::pair<ISteamUser * const,IWrapSteamUser *> >, COMDAT
; _this$ = ecx

; 813  : 		}

	mov	eax, ecx
	ret	4
??$?0U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$allocator@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z ENDP ; std::allocator<Concurrency::details::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Node>::allocator<Concurrency::details::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Node><std::pair<ISteamUser * const,IWrapSteamUser *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@IV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@2@@std@@YAPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@0@PAV10@IAAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_default_fill_n@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@IV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@2@@std@@YAPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@0@PAV10@IAAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,unsigned int,std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >, COMDAT

; 260  : 	{	// value-initialize _Count objects to raw _First, using _Al

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 261  : 	typedef _Iter_value_t<_FwdIt> _Ty;
; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Al$[ebp]
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __First$[ebp]
	call	??$_Uninitialized_default_fill_n1@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@IV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@2@@std@@YAPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@0@PAV10@IAAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,unsigned int,std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >
	add	esp, 16					; 00000010H

; 263  : 		_Conjunction_t<
; 264  : 			is_pointer<_FwdIt>,
; 265  : 			is_scalar<_Ty>,
; 266  : 			negation<is_volatile<_Ty>>,
; 267  : 			negation<is_member_pointer<_Ty>>,
; 268  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>()));
; 269  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_default_fill_n@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@IV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@2@@std@@YAPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@0@PAV10@IAAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,unsigned int,std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$?0AAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@std@@QAE@AAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0AAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@std@@QAE@AAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >::_Wrap_alloc<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > ><std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > &>, COMDAT
; _this$ = ecx

; 1054 : 		}

	mov	eax, ecx
	ret	4
??$?0AAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@std@@QAE@AAV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >::_Wrap_alloc<std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > ><std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@?$allocator@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAEXPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@?$allocator@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAEXPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@Z PROC ; std::allocator<Concurrency::details::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Node>::destroy<Concurrency::details::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Node>, COMDAT
; _this$ = ecx

; 846  : 		_Ptr->~_Uty();
; 847  : 		}

	ret	4
??$destroy@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@?$allocator@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAEXPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@Z ENDP ; std::allocator<Concurrency::details::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Node>::destroy<Concurrency::details::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Node>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$?0U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z PROC ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > ><std::pair<ISteamUser * const,IWrapSteamUser *> >, COMDAT
; _this$ = ecx

; 813  : 		}

	mov	eax, ecx
	ret	4
??$?0U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z ENDP ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > ><std::pair<ISteamUser * const,IWrapSteamUser *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_Is_dummy@_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QBE_NXZ
_TEXT	SEGMENT
?_Is_dummy@_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QBE_NXZ PROC ; Concurrency::details::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Node::_Is_dummy, COMDAT
; _this$ = ecx

; 247  :             return (_M_order_key & 0x1) == 0;

	mov	eax, DWORD PTR [ecx+12]
	not	eax
	and	eax, 1

; 248  :         }

	ret	0
?_Is_dummy@_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QBE_NXZ ENDP ; Concurrency::details::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Node::_Is_dummy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_Atomic_set_next@_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAEPAU1234@PAU1234@0@Z
_TEXT	SEGMENT
__New_node$ = 8						; size = 4
__Current_node$ = 12					; size = 4
?_Atomic_set_next@_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAEPAU1234@PAU1234@0@Z PROC ; Concurrency::details::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Node::_Atomic_set_next, COMDAT
; _this$ = ecx

; 227  :         {

	npad	2
	push	ebp
	mov	ebp, esp

; 228  :             // Try to change the next pointer on the current element to a new element, only if it still points to the cached next
; 229  :             _Nodeptr _Exchange_node = (_Nodeptr) _InterlockedCompareExchangePointer((void * volatile *) &_M_next, _New_node, _Current_node);

	mov	edx, DWORD PTR __New_node$[ebp]
	mov	eax, DWORD PTR __Current_node$[ebp]
	lock	 cmpxchg DWORD PTR [ecx], edx

; 230  : 
; 231  :             if (_Exchange_node == _Current_node)

	cmp	eax, DWORD PTR __Current_node$[ebp]
	cmove	eax, DWORD PTR __New_node$[ebp]

; 232  :             {
; 233  :                 // Operation succeeded, return the new node
; 234  :                 return _New_node;
; 235  :             }
; 236  :             else
; 237  :             {
; 238  :                 // Operation failed, return the "interfering" node
; 239  :                 return _Exchange_node;
; 240  :             }
; 241  :         }

	pop	ebp
	ret	8
?_Atomic_set_next@_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAEPAU1234@PAU1234@0@Z ENDP ; Concurrency::details::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Node::_Atomic_set_next
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_Get_order_key@_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QBEIXZ
_TEXT	SEGMENT
?_Get_order_key@_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QBEIXZ PROC ; Concurrency::details::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Node::_Get_order_key, COMDAT
; _this$ = ecx

; 222  :             return _M_order_key;

	mov	eax, DWORD PTR [ecx+12]

; 223  :         }

	ret	0
?_Get_order_key@_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QBEIXZ ENDP ; Concurrency::details::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Node::_Get_order_key
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_Init@_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAEXI@Z
_TEXT	SEGMENT
__Order_key$ = 8					; size = 4
?_Init@_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAEXI@Z PROC ; Concurrency::details::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Node::_Init, COMDAT
; _this$ = ecx

; 214  :         {

	npad	2
	push	ebp
	mov	ebp, esp

; 215  :             _M_order_key = _Order_key;

	mov	eax, DWORD PTR __Order_key$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 216  :             _M_next = NULL;

	mov	DWORD PTR [ecx], 0

; 217  :         }

	pop	ebp
	ret	4
?_Init@_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAEXI@Z ENDP ; Concurrency::details::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Node::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ??$_Insert@U?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@IAE?AU?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@$$QAU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@4@@Z
_TEXT	SEGMENT
__Result$1 = -24					; size = 8
tv811 = -20						; size = 4
_this$1$ = -16						; size = 4
__Reversed_order_key$2 = -12				; size = 4
tv813 = -8						; size = 4
__Index$3 = -8						; size = 4
__Index$4 = -8						; size = 4
__Val$5 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Value$ = 12						; size = 4
??$_Insert@U?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@IAE?AU?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@$$QAU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@4@@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Insert<std::pair<ISteamUser *,IWrapSteamUser *> >, COMDAT
; _this$ = ecx

; 862  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	mov	esi, DWORD PTR __Value$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 862  :     {

	mov	ebx, ecx

; 73   :     unsigned long _Index = 0;

	mov	DWORD PTR __Index$4[ebp], 0
	push	edi

; 862  :     {

	mov	DWORD PTR _this$1$[ebp], ebx

; 1267 :         if (_M_buckets[_Segment] == NULL)

	mov	edi, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	movzx	eax, BYTE PTR [esi]
	xor	eax, -2128831035			; 811c9dc5H

; 347  : 		_Val *= _FNV_prime;

	imul	edx, eax, 16777619
	movzx	eax, BYTE PTR [esi+1]
	xor	edx, eax
	movzx	eax, BYTE PTR [esi+2]
	imul	edx, edx, 16777619
	xor	edx, eax
	movzx	eax, BYTE PTR [esi+3]
	imul	ecx, edx, 16777619
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 864  :         size_type _Bucket = _Order_key % _M_number_of_buckets;

	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	xor	ecx, eax

; 347  : 		_Val *= _FNV_prime;

	imul	eax, ecx, 16777619
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 864  :         size_type _Bucket = _Order_key % _M_number_of_buckets;

	lea	ecx, DWORD PTR [ebx+148]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 347  : 		_Val *= _FNV_prime;

	mov	DWORD PTR __Val$5[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 864  :         size_type _Bucket = _Order_key % _M_number_of_buckets;

	div	DWORD PTR [ecx]
	mov	esi, edx

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	mov	eax, esi
	or	eax, 1
	mov	DWORD PTR tv811[ebp], eax

; 76   :     _BitScanReverse(&_Index, _Mask);

	bsr	eax, eax

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	movzx	ecx, al

; 76   :     _BitScanReverse(&_Index, _Mask);

	mov	DWORD PTR __Index$4[ebp], eax

; 1267 :         if (_M_buckets[_Segment] == NULL)

	mov	eax, DWORD PTR [ebx+ecx*4+4]
	test	eax, eax
	je	SHORT $LN232@Insert

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	mov	edx, edi

; 1273 :         return (_Iterator._Mynode() != NULL);

	mov	eax, esi

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	shl	edx, cl

; 1273 :         return (_Iterator._Mynode() != NULL);

	mov	ecx, DWORD PTR [ebx+ecx*4+4]

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	and	edx, -2					; fffffffeH

; 1273 :         return (_Iterator._Mynode() != NULL);

	sub	eax, edx
	cmp	DWORD PTR [ecx+eax*4], 0
	setne	al

; 865  : 
; 866  :         // If bucket is empty, initialize it first
; 867  :         if (!_Is_initialized(_Bucket))

	test	al, al
	jne	SHORT $LN5@Insert
$LN232@Insert:

; 868  :         {
; 869  :             _Initialize_bucket(_Bucket);

	push	esi
	mov	ecx, ebx
	call	?_Initialize_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXI@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Initialize_bucket
$LN5@Insert:

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	mov	ecx, DWORD PTR __imp_?_Byte_reverse_table@details@Concurrency@@3QBEB

; 67   :     return _Byte_reverse_table[_Original_byte];

	mov	edx, DWORD PTR __Val$5[ebp]
	movzx	eax, dl

; 870  :         }
; 871  : 
; 872  :         long _New_count;
; 873  :         _Order_key = _Split_order_regular_key(_Order_key);
; 874  :         _Full_iterator _Iterator = _Get_bucket(_Bucket);
; 875  :         _Full_iterator _Last = _M_split_ordered_list._End();
; 876  :         _Full_iterator _Where = _Iterator;
; 877  :         _Nodeptr _New_node = _M_split_ordered_list._Buynode(_Order_key, std::forward<_ValTy>(_Value));

	push	DWORD PTR __Value$[ebp]

; 73   :     unsigned long _Index = 0;

	mov	DWORD PTR __Index$3[ebp], 0

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+ecx]
	mov	BYTE PTR __Reversed_order_key$2[ebp+3], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, dh

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+ecx]
	mov	BYTE PTR __Reversed_order_key$2[ebp+2], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, BYTE PTR __Val$5[ebp+2]

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+ecx]
	mov	BYTE PTR __Reversed_order_key$2[ebp+1], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, BYTE PTR __Val$5[ebp+3]

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+ecx]
	mov	BYTE PTR __Reversed_order_key$2[ebp], al

; 76   :     _BitScanReverse(&_Index, _Mask);

	mov	eax, DWORD PTR tv811[ebp]

; 1296 :         return _Reverse(_Order_key) | 0x1;

	mov	ebx, DWORD PTR __Reversed_order_key$2[ebp]

; 76   :     _BitScanReverse(&_Index, _Mask);

	bsr	eax, eax

; 1296 :         return _Reverse(_Order_key) | 0x1;

	or	ebx, edi

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	movzx	ecx, al

; 76   :     _BitScanReverse(&_Index, _Mask);

	mov	DWORD PTR __Index$3[ebp], eax

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	mov	eax, edi
	shl	eax, cl
	and	eax, -2					; fffffffeH

; 1240 :         return _M_buckets[_Segment][_Bucket];

	sub	esi, eax
	mov	eax, DWORD PTR _this$1$[ebp]

; 870  :         }
; 871  : 
; 872  :         long _New_count;
; 873  :         _Order_key = _Split_order_regular_key(_Order_key);
; 874  :         _Full_iterator _Iterator = _Get_bucket(_Bucket);
; 875  :         _Full_iterator _Last = _M_split_ordered_list._End();
; 876  :         _Full_iterator _Where = _Iterator;
; 877  :         _Nodeptr _New_node = _M_split_ordered_list._Buynode(_Order_key, std::forward<_ValTy>(_Value));

	push	ebx

; 1240 :         return _M_buckets[_Segment][_Bucket];

	mov	edi, DWORD PTR [eax+ecx*4+4]

; 870  :         }
; 871  : 
; 872  :         long _New_count;
; 873  :         _Order_key = _Split_order_regular_key(_Order_key);
; 874  :         _Full_iterator _Iterator = _Get_bucket(_Bucket);
; 875  :         _Full_iterator _Last = _M_split_ordered_list._End();
; 876  :         _Full_iterator _Where = _Iterator;
; 877  :         _Nodeptr _New_node = _M_split_ordered_list._Buynode(_Order_key, std::forward<_ValTy>(_Value));

	lea	ecx, DWORD PTR [eax+132]

; 1240 :         return _M_buckets[_Segment][_Bucket];

	mov	edi, DWORD PTR [edi+esi*4]

; 870  :         }
; 871  : 
; 872  :         long _New_count;
; 873  :         _Order_key = _Split_order_regular_key(_Order_key);
; 874  :         _Full_iterator _Iterator = _Get_bucket(_Bucket);
; 875  :         _Full_iterator _Last = _M_split_ordered_list._End();
; 876  :         _Full_iterator _Where = _Iterator;
; 877  :         _Nodeptr _New_node = _M_split_ordered_list._Buynode(_Order_key, std::forward<_ValTy>(_Value));

	call	??$_Buynode@U?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@12@I$$QAU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@std@@@Z ; Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Buynode<std::pair<ISteamUser *,IWrapSteamUser *> >
	mov	ecx, eax
$LN236@Insert:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 210  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	esi, DWORD PTR [edi]
	npad	4
$LL2@Insert:

; 233  : 		return (this->_Ptr == _Right._Ptr);

	test	esi, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 886  :             if (_Where == _Last || _Mylist::_Get_key(_Where) > _Order_key)

	je	SHORT $LN8@Insert
	mov	eax, DWORD PTR [esi+12]
	cmp	eax, ebx
	ja	SHORT $LN8@Insert

; 909  :             else if (!this->_M_allow_multimapping && _Mylist::_Get_key(_Where) == _Order_key &&

	jne	SHORT $LN11@Insert
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 220  : 		return (_Left == _Right);

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, DWORD PTR [ecx+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 909  :             else if (!this->_M_allow_multimapping && _Mylist::_Get_key(_Where) == _Order_key &&

	je	SHORT $LN212@Insert
$LN11@Insert:

; 910  :                 this->_M_comparator(this->_Key_function(*_Where), this->_Key_function(_New_node->_M_element)) == 0)
; 911  :             {
; 912  :                 // If the insert failed (element already there), then delete the new one
; 913  :                 _M_split_ordered_list._Erase(_New_node);
; 914  : 
; 915  :                 // Element already in the list, return it
; 916  :                 return std::pair<iterator, bool>(_M_split_ordered_list._Get_iterator(_Where), false);
; 917  :             }
; 918  : 
; 919  :             // Move the iterator forward
; 920  :             _Iterator = _Where;

	mov	edi, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 210  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 922  :         }

	jmp	SHORT $LL2@Insert
$LN8@Insert:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 610  :         _New_node->_M_next = _Current_node;

	mov	DWORD PTR [ecx], esi

; 229  :             _Nodeptr _Exchange_node = (_Nodeptr) _InterlockedCompareExchangePointer((void * volatile *) &_M_next, _New_node, _Current_node);

	mov	edx, ecx
	mov	eax, esi
	lock	 cmpxchg DWORD PTR [edi], edx

; 230  : 
; 231  :             if (_Exchange_node == _Current_node)

	cmp	eax, esi
	je	SHORT $LN235@Insert

; 619  :         if (_Inserted_node == _List_node)

	cmp	eax, ecx
	je	SHORT $LN235@Insert
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	DWORD PTR __Result$1[ebp], 0

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR __Result$1[ebp+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 906  :                     continue;

	jmp	SHORT $LN236@Insert
$LN212@Insert:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	16					; 00000010H
	push	1
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	DWORD PTR [eax], esi
	pop	esi

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 0
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 923  :     }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN235@Insert:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 623  :             *_New_count = _InterlockedIncrement(&_M_element_count);

	mov	edx, DWORD PTR _this$1$[ebp]
	mov	eax, 1
	lock	 xadd	 DWORD PTR [edx+140], eax
	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 894  :                     _Adjust_table_size(_New_count, _M_number_of_buckets);

	mov	esi, DWORD PTR [edx+148]
	lea	edi, DWORD PTR [edx+148]
	movd	xmm0, eax

; 1221 :         if (((float) _Total_elements / (float) _Current_size) > _M_maximum_bucket_size)

	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR __Result$1[ebp+4], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1221 :         if (((float) _Total_elements / (float) _Current_size) > _M_maximum_bucket_size)

	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	eax, esi
	shr	eax, 31					; 0000001fH
	cvtpd2ps xmm1, xmm0
	movd	xmm0, esi
	cvtdq2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	divss	xmm1, xmm0
	comiss	xmm1, DWORD PTR [edx+152]
	jbe	SHORT $LN138@Insert

; 1222 :         {
; 1223 :              // Double the size of the hash only if size has not changed inbetween loads
; 1224 :             _InterlockedCompareExchangeSizeT(&_M_number_of_buckets, 2 * _Current_size, _Current_size);

	lea	edx, DWORD PTR [esi+esi]
	mov	eax, esi
	lock	 cmpxchg DWORD PTR [edi], edx
$LN138@Insert:

; 895  :                     return _Result;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Result$1[ebp+4]
	mov	DWORD PTR [eax+4], ecx

; 923  :     }

	mov	esp, ebp
	pop	ebp
	ret	8
??$_Insert@U?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@IAE?AU?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@$$QAU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@4@@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Insert<std::pair<ISteamUser *,IWrapSteamUser *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
;	COMDAT ??$make_pair@ABQAVISteamUser@@PAVIWrapSteamUser@@@std@@YA?AU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@0@ABQAVISteamUser@@$$QAPAVIWrapSteamUser@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Val1$ = 12						; size = 4
__Val2$ = 16						; size = 4
??$make_pair@ABQAVISteamUser@@PAVIWrapSteamUser@@@std@@YA?AU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@0@ABQAVISteamUser@@$$QAPAVIWrapSteamUser@@@Z PROC ; std::make_pair<ISteamUser * const &,IWrapSteamUser *>, COMDAT

; 341  : 	{	// return pair composed from arguments

	npad	2
	push	ebp
	mov	ebp, esp

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	ecx, DWORD PTR __Val2$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], ecx

; 342  : 	typedef pair<typename _Unrefwrap<_Ty1>::type,
; 343  : 		typename _Unrefwrap<_Ty2>::type> _Mypair;
; 344  : 	return (_Mypair(_STD forward<_Ty1>(_Val1),
; 345  : 		_STD forward<_Ty2>(_Val2)));
; 346  : 	}

	pop	ebp
	ret	0
??$make_pair@ABQAVISteamUser@@PAVIWrapSteamUser@@@std@@YA?AU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@0@ABQAVISteamUser@@$$QAPAVIWrapSteamUser@@@Z ENDP ; std::make_pair<ISteamUser * const &,IWrapSteamUser *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ??D?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QBEAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@XZ
_TEXT	SEGMENT
??D?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QBEAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@XZ PROC ; Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator*, COMDAT
; _this$ = ecx

; 358  :         return ((reference)(*_Pnode)._M_element);

	mov	eax, DWORD PTR [ecx]
	add	eax, 4

; 148  :         return ((reference)**(_Mybase *)this);
; 149  :     }

	ret	0
??D?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QBEAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@XZ ENDP ; Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ??0?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@12@PBV?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@12@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@12@PBV?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@12@@Z PROC ; Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >, COMDAT
; _this$ = ecx

; 130  :     {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 131  :     }

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@12@PBV?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@12@@Z ENDP ; Concurrency::details::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Solist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@1@@Z PROC ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::destroy<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >, COMDAT
; _this$ = ecx

; 846  : 		_Ptr->~_Uty();
; 847  : 		}

	ret	4
??$destroy@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@1@@Z ENDP ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::destroy<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
;	COMDAT ??E?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAE?AV01@H@Z PROC ; std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator++, COMDAT
; _this$ = ecx

; 313  : 		{	// postincrement

	npad	2
	push	ebp
	mov	ebp, esp

; 314  : 		_Myiter _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx

; 210  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], edx

; 315  : 		++*this;
; 316  : 		return (_Tmp);
; 317  : 		}

	pop	ebp
	ret	8
??E?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAE?AV01@H@Z ENDP ; std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
;	COMDAT ??E?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAEAAV01@XZ PROC ; std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator++, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 352  :         return ((_Nodepref)(*_Pnode)._M_next);

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 210  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 308  : 		++(*(_Mybase *)this);
; 309  : 		return (*this);

	mov	eax, ecx

; 310  : 		}

	ret	0
??E?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAEAAV01@XZ ENDP ; std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
;	COMDAT ??D?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QBEAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@XZ
_TEXT	SEGMENT
??D?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QBEAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@XZ PROC ; std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator*, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 358  :         return ((reference)(*_Pnode)._M_element);

	mov	eax, DWORD PTR [ecx]
	add	eax, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 299  : 		}

	ret	0
??D?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QBEAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@XZ ENDP ; std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
;	COMDAT ??0?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@PBV?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@45@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@PBV?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@45@@Z PROC ; std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >, COMDAT
; _this$ = ecx

; 280  : 		{	// construct with node pointer _Pnode

	npad	2
	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], eax

; 281  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@PBV?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@45@@Z ENDP ; std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
;	COMDAT ??0?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAE@XZ PROC ; std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >, COMDAT
; _this$ = ecx

; 38   : 		: _Ptr()

	mov	DWORD PTR [ecx], 0

; 275  : 		{	// construct with null node
; 276  : 		}

	mov	eax, ecx
	ret	0
??0?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAE@XZ ENDP ; std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
;	COMDAT ??$_Key_function@QAVISteamUser@@PAVIWrapSteamUser@@@?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@SAABQAVISteamUser@@ABU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@Z
_TEXT	SEGMENT
__Value$ = 8						; size = 4
??$_Key_function@QAVISteamUser@@PAVIWrapSteamUser@@@?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@SAABQAVISteamUser@@ABU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@Z PROC ; Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0>::_Key_function<ISteamUser * const,IWrapSteamUser *>, COMDAT

; 84   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 85   :         return (_Value.first);

	mov	eax, DWORD PTR __Value$[ebp]

; 86   :     }

	pop	ebp
	ret	0
??$_Key_function@QAVISteamUser@@PAVIWrapSteamUser@@@?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@SAABQAVISteamUser@@ABU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@Z ENDP ; Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0>::_Key_function<ISteamUser * const,IWrapSteamUser *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ??E?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QAE?AV012@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QAE?AV012@H@Z PROC ; Concurrency::details::_Solist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator++, COMDAT
; _this$ = ecx

; 86   :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 87   :         _Myiter _Tmp = *this;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, ecx
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [esi], eax
	npad	1
$LL10@operator:

; 352  :         return ((_Nodepref)(*_Pnode)._M_next);

	mov	ecx, DWORD PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 210  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 80   :         while (this->_Mynode() != NULL && this->_Mynode()->_Is_dummy());

	test	ecx, ecx
	je	SHORT $LN36@operator
	mov	al, BYTE PTR [ecx+12]
	not	al
	test	al, 1
	jne	SHORT $LL10@operator

; 88   :         do
; 89   :         {
; 90   :             ++*this;
; 91   :         }
; 92   :         while (this->_Mynode() != NULL && this->_Mynode()->_Is_dummy());

	test	ecx, ecx
	je	SHORT $LN36@operator
	mov	cl, BYTE PTR [ecx+12]
	not	cl
	test	cl, 1
	jne	SHORT $LL10@operator
$LN36@operator:

; 93   : 
; 94   :         return (_Tmp);

	mov	eax, esi
	pop	esi

; 95   :     }

	pop	ebp
	ret	8
??E?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QAE?AV012@H@Z ENDP ; Concurrency::details::_Solist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ??E?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QAEAAV012@XZ
_TEXT	SEGMENT
??E?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QAEAAV012@XZ PROC ; Concurrency::details::_Solist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator++, COMDAT
; _this$ = ecx

; 75   :     {

	npad	2
$LL4@operator:

; 352  :         return ((_Nodepref)(*_Pnode)._M_next);

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 210  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 80   :         while (this->_Mynode() != NULL && this->_Mynode()->_Is_dummy());

	test	eax, eax
	je	SHORT $LN20@operator
	mov	al, BYTE PTR [eax+12]
	not	al
	test	al, 1
	jne	SHORT $LL4@operator
$LN20@operator:

; 81   : 
; 82   :         return (*this);

	mov	eax, ecx

; 83   :     }

	ret	0
??E?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QAEAAV012@XZ ENDP ; Concurrency::details::_Solist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ??D?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QBEABU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@XZ
_TEXT	SEGMENT
??D?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QBEABU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@XZ PROC ; Concurrency::details::_Solist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator*, COMDAT
; _this$ = ecx

; 358  :         return ((reference)(*_Pnode)._M_element);

	mov	eax, DWORD PTR [ecx]
	add	eax, 4

; 66   :         return ((reference)**(_Mybase *)this);
; 67   :     }

	ret	0
??D?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QBEABU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@XZ ENDP ; Concurrency::details::_Solist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ??0?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@12@PBV?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@12@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@12@PBV?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@12@@Z PROC ; Concurrency::details::_Solist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Solist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >, COMDAT
; _this$ = ecx

; 48   :     {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 49   :     }

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@12@PBV?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@12@@Z ENDP ; Concurrency::details::_Solist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Solist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
;	COMDAT ??9?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QBE_NABV01@@Z PROC ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator!=, COMDAT
; _this$ = ecx

; 237  : 		{	// test for iterator inequality

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 238  : 		return (!(*this == _Right));
; 239  : 		}

	pop	ebp
	ret	4
??9?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QBE_NABV01@@Z ENDP ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
;	COMDAT ??8?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QBE_NABV01@@Z PROC ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator==, COMDAT
; _this$ = ecx

; 222  : 		{	// test for iterator equality

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 223  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 224  : 		if (this->_Getcont() != _Right._Getcont())
; 225  : 			{	// report error
; 226  : 			_DEBUG_ERROR("forward_list iterators incompatible");
; 227  : 			}
; 228  : 
; 229  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 230  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 231  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 232  : 
; 233  : 		return (this->_Ptr == _Right._Ptr);
; 234  : 		}

	pop	ebp
	ret	4
??8?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QBE_NABV01@@Z ENDP ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
;	COMDAT ??E?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAE?AV01@H@Z PROC ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator++, COMDAT
; _this$ = ecx

; 215  : 		{	// postincrement

	npad	2
	push	ebp
	mov	ebp, esp

; 216  : 		_Myiter _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx

; 210  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], edx

; 217  : 		++*this;
; 218  : 		return (_Tmp);
; 219  : 		}

	pop	ebp
	ret	8
??E?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAE?AV01@H@Z ENDP ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
;	COMDAT ??E?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAEAAV01@XZ PROC ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator++, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 352  :         return ((_Nodepref)(*_Pnode)._M_next);

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 210  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 211  : 		return (*this);

	mov	eax, ecx

; 212  : 		}

	ret	0
??E?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAEAAV01@XZ ENDP ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
;	COMDAT ??D?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QBEABU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@XZ
_TEXT	SEGMENT
??D?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QBEABU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@XZ PROC ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator*, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 358  :         return ((reference)(*_Pnode)._M_element);

	mov	eax, DWORD PTR [ecx]
	add	eax, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 195  : 		}

	ret	0
??D?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QBEABU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@XZ ENDP ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
;	COMDAT ??0?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@PBV?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@45@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@PBV?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@45@@Z PROC ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >, COMDAT
; _this$ = ecx

; 161  : 		{	// construct with node pointer _Pnode

	npad	2
	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], eax

; 162  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@PBV?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@45@@Z ENDP ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
;	COMDAT ??0?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAE@XZ PROC ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >, COMDAT
; _this$ = ecx

; 38   : 		: _Ptr()

	mov	DWORD PTR [ecx], 0

; 157  : 		}

	mov	eax, ecx
	ret	0
??0?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAE@XZ ENDP ; std::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Flist_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
;	COMDAT ?_Mynode@?$_Flist_unchecked_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@U_Iterator_base0@std@@@std@@QBEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@XZ
_TEXT	SEGMENT
?_Mynode@?$_Flist_unchecked_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@U_Iterator_base0@std@@@std@@QBEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@XZ PROC ; std::_Flist_unchecked_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 83   : 		return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 84   : 		}

	ret	0
?_Mynode@?$_Flist_unchecked_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@U_Iterator_base0@std@@@std@@QBEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@XZ ENDP ; std::_Flist_unchecked_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
;	COMDAT ??0?$_Flist_unchecked_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@U_Iterator_base0@std@@@std@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@PBV?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@45@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Flist_unchecked_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@U_Iterator_base0@std@@@std@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@PBV?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@45@@Z PROC ; std::_Flist_unchecked_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>::_Flist_unchecked_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 44   : 		{	// construct with node pointer _Pnode

	npad	2
	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Flist_unchecked_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@U_Iterator_base0@std@@@std@@QAE@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@PBV?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@45@@Z ENDP ; std::_Flist_unchecked_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>::_Flist_unchecked_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
;	COMDAT ??0?$_Flist_unchecked_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@U_Iterator_base0@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Flist_unchecked_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@U_Iterator_base0@std@@@std@@QAE@XZ PROC ; std::_Flist_unchecked_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>::_Flist_unchecked_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 38   : 		: _Ptr()

	mov	DWORD PTR [ecx], 0

; 40   : 		}

	mov	eax, ecx
	ret	0
??0?$_Flist_unchecked_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@U_Iterator_base0@std@@@std@@QAE@XZ ENDP ; std::_Flist_unchecked_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>::_Flist_unchecked_const_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
_TEXT	SEGMENT
$T1 = -16						; size = 8
$T2 = -16						; size = 8
$T3 = -8						; size = 8
$T4 = -8						; size = 8
__Where$5 = -4						; size = 4
__Where$6 = -4						; size = 4
$T7 = -4						; size = 4
_pUser$ = 8						; size = 4
_This$ = 8						; size = 4
_hSteamUser$ = 12					; size = 4
_hSteamPipe$ = 16					; size = 4
_pchVersion$ = 20					; size = 4
?SK_SteamWrapper_WrappedClient_GetISteamUser@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z PROC ; SK_SteamWrapper_WrappedClient_GetISteamUser

; 292  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 293  :   SK_RunOnce (

	cmp	BYTE PTR ?first@?2??SK_SteamWrapper_WrappedClient_GetISteamUser@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z@4_NA, 0
	push	esi
	mov	esi, DWORD PTR _pchVersion$[ebp]
	push	edi
	je	SHORT $LN2@SK_SteamWr
	push	esi
	push	OFFSET $SG166379
	push	OFFSET $SG166380
	push	OFFSET ?steam_log@@3UiSK_Logger@@A	; steam_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H
	mov	BYTE PTR ?first@?2??SK_SteamWrapper_WrappedClient_GetISteamUser@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z@4_NA, 0
$LN2@SK_SteamWr:

; 294  :     steam_log.Log ( L"[!] %hs (..., %hs)",
; 295  :                       __FUNCTION__, pchVersion )
; 296  :   );
; 297  : 
; 298  :   ISteamUser* pUser =
; 299  :     This->GetISteamUser ( hSteamUser,

	mov	ecx, DWORD PTR _This$[ebp]
	push	esi
	push	DWORD PTR _hSteamPipe$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR _hSteamUser$[ebp]
	call	DWORD PTR [eax+20]
	mov	edi, eax
	mov	DWORD PTR _pUser$[ebp], edi

; 300  :                             hSteamPipe,
; 301  :                               pchVersion );
; 302  : 
; 303  :   if (pUser != nullptr)

	test	edi, edi
	je	$LN5@SK_SteamWr

; 304  :   {
; 305  :     if ((! lstrcmpA (pchVersion, STEAMUSER_INTERFACE_VERSION_018)) ||
; 306  :         (! lstrcmpA (pchVersion, STEAMUSER_INTERFACE_VERSION_019)) ||

	push	ebx
	mov	ebx, DWORD PTR __imp__lstrcmpA@8
	push	OFFSET $SG166385
	push	esi
	call	ebx
	test	eax, eax
	je	SHORT $LN6@SK_SteamWr
	push	OFFSET $SG166386
	push	esi
	call	ebx
	test	eax, eax
	je	SHORT $LN6@SK_SteamWr
	push	OFFSET $SG166387
	push	esi
	call	ebx
	test	eax, eax
	je	SHORT $LN6@SK_SteamWr

; 318  :       }
; 319  :     }
; 320  : 
; 321  :     else
; 322  :     {
; 323  :       SK_RunOnce (

	cmp	BYTE PTR ?first@?BD@??SK_SteamWrapper_WrappedClient_GetISteamUser@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z@4_NA, 0
	je	SHORT $LN9@SK_SteamWr
	push	esi
	push	OFFSET $SG166392
	push	OFFSET ?steam_log@@3UiSK_Logger@@A	; steam_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
	mov	BYTE PTR ?first@?BD@??SK_SteamWrapper_WrappedClient_GetISteamUser@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z@4_NA, 0
$LN9@SK_SteamWr:

; 324  :         steam_log.Log ( L"Game requested unexpected interface version (%hs)!",
; 325  :                           pchVersion )
; 326  :       );
; 327  : 
; 328  :       return pUser;

	pop	ebx
	mov	eax, edi
	pop	edi
	pop	esi

; 333  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@SK_SteamWr:

; 307  :         (! lstrcmpA (pchVersion, STEAMUSER_INTERFACE_VERSION_017)))
; 308  :     {
; 309  :       if (SK_SteamWrapper_remap_user.count (pUser))

	lea	eax, DWORD PTR _pUser$[ebp]
	mov	ecx, OFFSET ?SK_SteamWrapper_remap_user@@3V?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@A ; SK_SteamWrapper_remap_user
	push	eax
	call	?count@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QBEIABQAVISteamUser@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::count
	test	eax, eax
	jne	SHORT $LN158@SK_SteamWr

; 314  :         SK_SteamWrapper_remap_user [pUser] =

	push	8
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T7[ebp], esi
	test	esi, esi
	je	SHORT $LN11@SK_SteamWr

; 26   :                    pRealUser (pUser) {

	mov	DWORD PTR [esi], OFFSET ??_7IWrapSteamUser@@6B@
	mov	DWORD PTR [esi+4], edi

; 314  :         SK_SteamWrapper_remap_user [pUser] =

	jmp	SHORT $LN12@SK_SteamWr
$LN11@SK_SteamWr:
	xor	esi, esi
$LN12@SK_SteamWr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 476  :         return _Find(_Keyval);

	lea	eax, DWORD PTR _pUser$[ebp]
	mov	ecx, OFFSET ?SK_SteamWrapper_remap_user@@3V?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@A ; SK_SteamWrapper_remap_user
	push	eax
	lea	eax, DWORD PTR __Where$6[ebp]
	push	eax
	call	?_Find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamUser@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Find
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 233  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __Where$6[ebp]
	test	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 716  :         if (_Where == this->end())

	jne	SHORT $LN66@SK_SteamWr
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	DWORD PTR $T4[ebp+4], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 718  :             _Where = this->_Insert(std::make_pair(_Keyval, mapped_type())).first;

	mov	ecx, OFFSET ?SK_SteamWrapper_remap_user@@3V?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@A ; SK_SteamWrapper_remap_user
	lea	eax, DWORD PTR $T4[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	DWORD PTR $T4[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 718  :             _Where = this->_Insert(std::make_pair(_Keyval, mapped_type())).first;

	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??$_Insert@U?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@IAE?AU?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@$$QAU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@4@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Insert<std::pair<ISteamUser *,IWrapSteamUser *> >
	mov	eax, DWORD PTR [eax]
$LN66@SK_SteamWr:
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp

; 314  :         SK_SteamWrapper_remap_user [pUser] =

	mov	DWORD PTR [eax+8], esi
$LN158@SK_SteamWr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 476  :         return _Find(_Keyval);

	lea	eax, DWORD PTR _pUser$[ebp]
	mov	ecx, OFFSET ?SK_SteamWrapper_remap_user@@3V?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@A ; SK_SteamWrapper_remap_user
	push	eax
	lea	eax, DWORD PTR __Where$5[ebp]
	push	eax
	call	?_Find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamUser@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Find
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 233  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __Where$5[ebp]
	test	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 716  :         if (_Where == this->end())

	jne	SHORT $LN112@SK_SteamWr
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	DWORD PTR $T3[ebp+4], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 718  :             _Where = this->_Insert(std::make_pair(_Keyval, mapped_type())).first;

	mov	ecx, OFFSET ?SK_SteamWrapper_remap_user@@3V?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@A ; SK_SteamWrapper_remap_user
	lea	eax, DWORD PTR $T3[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	DWORD PTR $T3[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 718  :             _Where = this->_Insert(std::make_pair(_Keyval, mapped_type())).first;

	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??$_Insert@U?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@IAE?AU?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@$$QAU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@4@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Insert<std::pair<ISteamUser *,IWrapSteamUser *> >
	mov	eax, DWORD PTR [eax]
$LN112@SK_SteamWr:
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp

; 317  :         return SK_SteamWrapper_remap_user [pUser];

	mov	eax, DWORD PTR [eax+8]
	pop	ebx
	pop	edi
	pop	esi

; 333  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@SK_SteamWr:
	pop	edi

; 329  :     }
; 330  :   }
; 331  : 
; 332  :   return nullptr;

	xor	eax, eax
	pop	esi

; 333  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SK_SteamWrapper_WrappedClient_GetISteamUser@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z ENDP ; SK_SteamWrapper_WrappedClient_GetISteamUser
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
_TEXT	SEGMENT
$T1 = -24						; size = 8
$T2 = -24						; size = 8
$T3 = -16						; size = 8
$T4 = -16						; size = 8
$T5 = -16						; size = 8
__Where$6 = -12						; size = 4
__Where$7 = -12						; size = 4
__Where$8 = -12						; size = 4
$T9 = -12						; size = 4
$T10 = -8						; size = 8
_pUser$ = -4						; size = 4
_This$ = 8						; size = 4
_hSteamUser$ = 12					; size = 4
_hSteamPipe$ = 16					; size = 4
_pchVersion$ = 20					; size = 4
?SteamAPI_ISteamClient_GetISteamUser_Detour@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z PROC ; SteamAPI_ISteamClient_GetISteamUser_Detour

; 242  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 243  :   SK_RunOnce (

	cmp	BYTE PTR ?first@?2??SteamAPI_ISteamClient_GetISteamUser_Detour@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z@4_NA, 0
	push	esi
	mov	esi, DWORD PTR _pchVersion$[ebp]
	push	edi
	je	SHORT $LN2@SteamAPI_I
	push	esi
	push	OFFSET $SG166349
	push	OFFSET $SG166350
	push	OFFSET ?steam_log@@3UiSK_Logger@@A	; steam_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H
	mov	BYTE PTR ?first@?2??SteamAPI_ISteamClient_GetISteamUser_Detour@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z@4_NA, 0
$LN2@SteamAPI_I:

; 244  :     steam_log.Log ( L"[!] %hs (..., %hs)",
; 245  :                       __FUNCTION__, pchVersion )
; 246  :   );
; 247  : 
; 248  :   ISteamUser* pUser =
; 249  :     SteamAPI_ISteamClient_GetISteamUser_Original ( This,

	push	esi
	push	DWORD PTR _hSteamPipe$[ebp]
	push	DWORD PTR _hSteamUser$[ebp]
	push	DWORD PTR _This$[ebp]
	call	DWORD PTR ?SteamAPI_ISteamClient_GetISteamUser_Original@@3P6APAVISteamUser@@PAVISteamClient@@HHPBD@ZA ; SteamAPI_ISteamClient_GetISteamUser_Original
	mov	edi, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pUser$[ebp], edi

; 250  :                                                      hSteamUser,
; 251  :                                                        hSteamPipe,
; 252  :                                                          pchVersion );
; 253  : 
; 254  :   if (pUser != nullptr)

	test	edi, edi
	je	$LN5@SteamAPI_I

; 255  :   {
; 256  :     if ((! lstrcmpA (pchVersion, STEAMUSER_INTERFACE_VERSION_018)) ||
; 257  :         (! lstrcmpA (pchVersion, STEAMUSER_INTERFACE_VERSION_019)) ||

	push	ebx
	mov	ebx, DWORD PTR __imp__lstrcmpA@8
	push	OFFSET $SG166355
	push	esi
	call	ebx
	test	eax, eax
	je	SHORT $LN6@SteamAPI_I
	push	OFFSET $SG166356
	push	esi
	call	ebx
	test	eax, eax
	je	SHORT $LN6@SteamAPI_I
	push	OFFSET $SG166357
	push	esi
	call	ebx
	test	eax, eax
	je	SHORT $LN6@SteamAPI_I

; 269  :       }
; 270  :     }
; 271  : 
; 272  :     else
; 273  :     {
; 274  :       SK_RunOnce (

	cmp	BYTE PTR ?first@?BD@??SteamAPI_ISteamClient_GetISteamUser_Detour@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z@4_NA, 0
	je	SHORT $LN9@SteamAPI_I
	push	esi
	push	OFFSET $SG166362
	push	OFFSET ?steam_log@@3UiSK_Logger@@A	; steam_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
	mov	BYTE PTR ?first@?BD@??SteamAPI_ISteamClient_GetISteamUser_Detour@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z@4_NA, 0
$LN9@SteamAPI_I:

; 275  :         steam_log.Log ( L"Game requested unexpected interface version (%hs)!",
; 276  :                           pchVersion )
; 277  :       );
; 278  : 
; 279  :       return pUser;

	pop	ebx
	mov	eax, edi
	pop	edi
	pop	esi

; 284  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@SteamAPI_I:

; 258  :         (! lstrcmpA (pchVersion, STEAMUSER_INTERFACE_VERSION_017)))
; 259  :     {
; 260  :       if (SK_SteamWrapper_remap_user.count (pUser))

	lea	eax, DWORD PTR _pUser$[ebp]
	mov	ecx, OFFSET ?SK_SteamWrapper_remap_user@@3V?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@A ; SK_SteamWrapper_remap_user
	push	eax
	call	?count@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QBEIABQAVISteamUser@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::count
	test	eax, eax
	je	SHORT $LN7@SteamAPI_I
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 476  :         return _Find(_Keyval);

	lea	eax, DWORD PTR _pUser$[ebp]
	mov	ecx, OFFSET ?SK_SteamWrapper_remap_user@@3V?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@A ; SK_SteamWrapper_remap_user
	push	eax
	lea	eax, DWORD PTR __Where$8[ebp]
	push	eax
	call	?_Find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamUser@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Find
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 233  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __Where$8[ebp]
	test	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 716  :         if (_Where == this->end())

	jne	$LN112@SteamAPI_I

; 718  :             _Where = this->_Insert(std::make_pair(_Keyval, mapped_type())).first;

	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	lea	eax, DWORD PTR $T10[ebp]
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp

; 261  :          return SK_SteamWrapper_remap_user [pUser];

	jmp	SHORT $LN159@SteamAPI_I
$LN7@SteamAPI_I:

; 265  :         SK_SteamWrapper_remap_user [pUser] =

	push	8
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T9[ebp], esi
	test	esi, esi
	je	SHORT $LN11@SteamAPI_I

; 26   :                    pRealUser (pUser) {

	mov	DWORD PTR [esi], OFFSET ??_7IWrapSteamUser@@6B@
	mov	DWORD PTR [esi+4], edi

; 265  :         SK_SteamWrapper_remap_user [pUser] =

	jmp	SHORT $LN12@SteamAPI_I
$LN11@SteamAPI_I:
	xor	esi, esi
$LN12@SteamAPI_I:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 476  :         return _Find(_Keyval);

	lea	eax, DWORD PTR _pUser$[ebp]
	mov	ecx, OFFSET ?SK_SteamWrapper_remap_user@@3V?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@A ; SK_SteamWrapper_remap_user
	push	eax
	lea	eax, DWORD PTR __Where$7[ebp]
	push	eax
	call	?_Find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamUser@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Find
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 233  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __Where$7[ebp]
	test	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 716  :         if (_Where == this->end())

	jne	SHORT $LN66@SteamAPI_I
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	DWORD PTR $T4[ebp+4], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 718  :             _Where = this->_Insert(std::make_pair(_Keyval, mapped_type())).first;

	mov	ecx, OFFSET ?SK_SteamWrapper_remap_user@@3V?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@A ; SK_SteamWrapper_remap_user
	lea	eax, DWORD PTR $T4[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	DWORD PTR $T4[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 718  :             _Where = this->_Insert(std::make_pair(_Keyval, mapped_type())).first;

	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??$_Insert@U?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@IAE?AU?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@$$QAU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@4@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Insert<std::pair<ISteamUser *,IWrapSteamUser *> >
	mov	eax, DWORD PTR [eax]
$LN66@SteamAPI_I:
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp

; 265  :         SK_SteamWrapper_remap_user [pUser] =

	mov	DWORD PTR [eax+8], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 476  :         return _Find(_Keyval);

	mov	ecx, OFFSET ?SK_SteamWrapper_remap_user@@3V?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@A ; SK_SteamWrapper_remap_user
	lea	eax, DWORD PTR _pUser$[ebp]
	push	eax
	lea	eax, DWORD PTR __Where$6[ebp]
	push	eax
	call	?_Find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamUser@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Find
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 233  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __Where$6[ebp]
	test	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 716  :         if (_Where == this->end())

	jne	SHORT $LN112@SteamAPI_I

; 718  :             _Where = this->_Insert(std::make_pair(_Keyval, mapped_type())).first;

	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
$LN159@SteamAPI_I:
	push	eax
	mov	ecx, OFFSET ?SK_SteamWrapper_remap_user@@3V?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@A ; SK_SteamWrapper_remap_user
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	DWORD PTR $T3[ebp+4], 0
	mov	DWORD PTR $T3[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 718  :             _Where = this->_Insert(std::make_pair(_Keyval, mapped_type())).first;

	call	??$_Insert@U?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@IAE?AU?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@$$QAU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@4@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Insert<std::pair<ISteamUser *,IWrapSteamUser *> >
	mov	eax, DWORD PTR [eax]
$LN112@SteamAPI_I:
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp

; 268  :         return SK_SteamWrapper_remap_user [pUser];

	mov	eax, DWORD PTR [eax+8]
	pop	ebx
	pop	edi
	pop	esi

; 284  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@SteamAPI_I:
	pop	edi

; 280  :     }
; 281  :   }
; 282  : 
; 283  :   return nullptr;

	xor	eax, eax
	pop	esi

; 284  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SteamAPI_ISteamClient_GetISteamUser_Detour@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z ENDP ; SteamAPI_ISteamClient_GetISteamUser_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?BIsPhoneRequiringVerification@IWrapSteamUser@@UAE_NXZ
_TEXT	SEGMENT
?BIsPhoneRequiringVerification@IWrapSteamUser@@UAE_NXZ PROC ; IWrapSteamUser::BIsPhoneRequiringVerification, COMDAT
; _this$ = ecx

; 219  :     return pRealUser->BIsPhoneRequiringVerification ();

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+112]
	jmp	eax
?BIsPhoneRequiringVerification@IWrapSteamUser@@UAE_NXZ ENDP ; IWrapSteamUser::BIsPhoneRequiringVerification
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?BIsPhoneIdentifying@IWrapSteamUser@@UAE_NXZ
_TEXT	SEGMENT
?BIsPhoneIdentifying@IWrapSteamUser@@UAE_NXZ PROC	; IWrapSteamUser::BIsPhoneIdentifying, COMDAT
; _this$ = ecx

; 215  :     return pRealUser->BIsPhoneIdentifying           ();

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+108]
	jmp	eax
?BIsPhoneIdentifying@IWrapSteamUser@@UAE_NXZ ENDP	; IWrapSteamUser::BIsPhoneIdentifying
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?BIsTwoFactorEnabled@IWrapSteamUser@@UAE_NXZ
_TEXT	SEGMENT
?BIsTwoFactorEnabled@IWrapSteamUser@@UAE_NXZ PROC	; IWrapSteamUser::BIsTwoFactorEnabled, COMDAT
; _this$ = ecx

; 211  :     return pRealUser->BIsTwoFactorEnabled           ();

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+104]
	jmp	eax
?BIsTwoFactorEnabled@IWrapSteamUser@@UAE_NXZ ENDP	; IWrapSteamUser::BIsTwoFactorEnabled
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?BIsPhoneVerified@IWrapSteamUser@@UAE_NXZ
_TEXT	SEGMENT
?BIsPhoneVerified@IWrapSteamUser@@UAE_NXZ PROC		; IWrapSteamUser::BIsPhoneVerified, COMDAT
; _this$ = ecx

; 207  :     return pRealUser->BIsPhoneVerified              ();

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+100]
	jmp	eax
?BIsPhoneVerified@IWrapSteamUser@@UAE_NXZ ENDP		; IWrapSteamUser::BIsPhoneVerified
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?RequestStoreAuthURL@IWrapSteamUser@@UAE_KPBD@Z
_TEXT	SEGMENT
_pchRedirectURL$ = 8					; size = 4
?RequestStoreAuthURL@IWrapSteamUser@@UAE_KPBD@Z PROC	; IWrapSteamUser::RequestStoreAuthURL, COMDAT
; _this$ = ecx

; 198  :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 199  :     return pRealUser->RequestStoreAuthURL   (pchRedirectURL);

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+96]

; 200  :   };

	pop	ebp

; 199  :     return pRealUser->RequestStoreAuthURL   (pchRedirectURL);

	jmp	eax
?RequestStoreAuthURL@IWrapSteamUser@@UAE_KPBD@Z ENDP	; IWrapSteamUser::RequestStoreAuthURL
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?GetPlayerSteamLevel@IWrapSteamUser@@UAEHXZ
_TEXT	SEGMENT
?GetPlayerSteamLevel@IWrapSteamUser@@UAEHXZ PROC	; IWrapSteamUser::GetPlayerSteamLevel, COMDAT
; _this$ = ecx

; 195  :     return pRealUser->GetPlayerSteamLevel   ();

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+92]
?GetPlayerSteamLevel@IWrapSteamUser@@UAEHXZ ENDP	; IWrapSteamUser::GetPlayerSteamLevel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?GetGameBadgeLevel@IWrapSteamUser@@UAEHH_N@Z
_TEXT	SEGMENT
_nSeries$ = 8						; size = 4
_bFoil$ = 12						; size = 1
?GetGameBadgeLevel@IWrapSteamUser@@UAEHH_N@Z PROC	; IWrapSteamUser::GetGameBadgeLevel, COMDAT
; _this$ = ecx

; 189  :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 190  :     return pRealUser->GetGameBadgeLevel     ( nSeries,

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]

; 191  :                                                 bFoil );
; 192  :   }

	pop	ebp

; 190  :     return pRealUser->GetGameBadgeLevel     ( nSeries,

	jmp	DWORD PTR [eax+88]
?GetGameBadgeLevel@IWrapSteamUser@@UAEHH_N@Z ENDP	; IWrapSteamUser::GetGameBadgeLevel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?GetEncryptedAppTicket@IWrapSteamUser@@UAE_NPAXHPAI@Z
_TEXT	SEGMENT
_pTicket$ = 8						; size = 4
_cbMaxTicket$ = 12					; size = 4
_pcbTicket$ = 16					; size = 4
?GetEncryptedAppTicket@IWrapSteamUser@@UAE_NPAXHPAI@Z PROC ; IWrapSteamUser::GetEncryptedAppTicket, COMDAT
; _this$ = ecx

; 182  :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 183  :     return pRealUser->GetEncryptedAppTicket ( pTicket,

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+84]

; 184  :                                                 cbMaxTicket,
; 185  :                                                   pcbTicket );
; 186  :   }

	pop	ebp

; 183  :     return pRealUser->GetEncryptedAppTicket ( pTicket,

	jmp	eax
?GetEncryptedAppTicket@IWrapSteamUser@@UAE_NPAXHPAI@Z ENDP ; IWrapSteamUser::GetEncryptedAppTicket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?RequestEncryptedAppTicket@IWrapSteamUser@@UAE_KPAXH@Z
_TEXT	SEGMENT
_pDataToInclude$ = 8					; size = 4
_cbDataToInclude$ = 12					; size = 4
?RequestEncryptedAppTicket@IWrapSteamUser@@UAE_KPAXH@Z PROC ; IWrapSteamUser::RequestEncryptedAppTicket, COMDAT
; _this$ = ecx

; 175  :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 176  :     return pRealUser->RequestEncryptedAppTicket ( pDataToInclude,

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+80]

; 177  :                                                     cbDataToInclude );
; 178  :   }

	pop	ebp

; 176  :     return pRealUser->RequestEncryptedAppTicket ( pDataToInclude,

	jmp	eax
?RequestEncryptedAppTicket@IWrapSteamUser@@UAE_KPAXH@Z ENDP ; IWrapSteamUser::RequestEncryptedAppTicket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?AdvertiseGame@IWrapSteamUser@@UAEXVCSteamID@@IG@Z
_TEXT	SEGMENT
_steamIDGameServer$ = 8					; size = 8
_unIPServer$ = 16					; size = 4
_usPortServer$ = 20					; size = 2
?AdvertiseGame@IWrapSteamUser@@UAEXVCSteamID@@IG@Z PROC	; IWrapSteamUser::AdvertiseGame, COMDAT
; _this$ = ecx

; 168  :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 169  :     return pRealUser->AdvertiseGame         ( steamIDGameServer,

	push	DWORD PTR _usPortServer$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	push	DWORD PTR _unIPServer$[ebp]
	push	DWORD PTR _steamIDGameServer$[ebp+4]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR _steamIDGameServer$[ebp]
	call	DWORD PTR [eax+76]

; 170  :                                                 unIPServer,
; 171  :                                                   usPortServer );
; 172  :   }

	pop	ebp
	ret	16					; 00000010H
?AdvertiseGame@IWrapSteamUser@@UAEXVCSteamID@@IG@Z ENDP	; IWrapSteamUser::AdvertiseGame
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?BIsBehindNAT@IWrapSteamUser@@UAE_NXZ
_TEXT	SEGMENT
?BIsBehindNAT@IWrapSteamUser@@UAE_NXZ PROC		; IWrapSteamUser::BIsBehindNAT, COMDAT
; _this$ = ecx

; 163  :   virtual bool                        BIsBehindNAT         (void) override { return pRealUser->BIsBehindNAT (); }

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+72]
	jmp	eax
?BIsBehindNAT@IWrapSteamUser@@UAE_NXZ ENDP		; IWrapSteamUser::BIsBehindNAT
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?UserHasLicenseForApp@IWrapSteamUser@@UAE?AW4EUserHasLicenseForAppResult@@VCSteamID@@I@Z
_TEXT	SEGMENT
_steamID$ = 8						; size = 8
_appID$ = 16						; size = 4
?UserHasLicenseForApp@IWrapSteamUser@@UAE?AW4EUserHasLicenseForAppResult@@VCSteamID@@I@Z PROC ; IWrapSteamUser::UserHasLicenseForApp, COMDAT
; _this$ = ecx

; 159  :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 160  :     return pRealUser->UserHasLicenseForApp  ( steamID,

	mov	ecx, DWORD PTR [ecx+4]
	push	DWORD PTR _appID$[ebp]
	push	DWORD PTR _steamID$[ebp+4]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR _steamID$[ebp]
	call	DWORD PTR [eax+68]

; 161  :                                                 appID );
; 162  :   }

	pop	ebp
	ret	12					; 0000000cH
?UserHasLicenseForApp@IWrapSteamUser@@UAE?AW4EUserHasLicenseForAppResult@@VCSteamID@@I@Z ENDP ; IWrapSteamUser::UserHasLicenseForApp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?CancelAuthTicket@IWrapSteamUser@@UAEXI@Z
_TEXT	SEGMENT
_hAuthTicket$ = 8					; size = 4
?CancelAuthTicket@IWrapSteamUser@@UAEXI@Z PROC		; IWrapSteamUser::CancelAuthTicket, COMDAT
; _this$ = ecx

; 154  :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 155  :     return pRealUser->CancelAuthTicket      (hAuthTicket);

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]

; 156  :   }

	pop	ebp

; 155  :     return pRealUser->CancelAuthTicket      (hAuthTicket);

	jmp	DWORD PTR [eax+64]
?CancelAuthTicket@IWrapSteamUser@@UAEXI@Z ENDP		; IWrapSteamUser::CancelAuthTicket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?EndAuthSession@IWrapSteamUser@@UAEXVCSteamID@@@Z
_TEXT	SEGMENT
_steamID$ = 8						; size = 8
?EndAuthSession@IWrapSteamUser@@UAEXVCSteamID@@@Z PROC	; IWrapSteamUser::EndAuthSession, COMDAT
; _this$ = ecx

; 150  :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 151  :     return pRealUser->EndAuthSession        (steamID);

	mov	ecx, DWORD PTR [ecx+4]
	push	DWORD PTR _steamID$[ebp+4]
	push	DWORD PTR _steamID$[ebp]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+60]

; 152  :   }

	pop	ebp
	ret	8
?EndAuthSession@IWrapSteamUser@@UAEXVCSteamID@@@Z ENDP	; IWrapSteamUser::EndAuthSession
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?BeginAuthSession@IWrapSteamUser@@UAE?AW4EBeginAuthSessionResult@@PBXHVCSteamID@@@Z
_TEXT	SEGMENT
_pAuthTicket$ = 8					; size = 4
_cbAuthTicket$ = 12					; size = 4
_steamID$ = 16						; size = 8
?BeginAuthSession@IWrapSteamUser@@UAE?AW4EBeginAuthSessionResult@@PBXHVCSteamID@@@Z PROC ; IWrapSteamUser::BeginAuthSession, COMDAT
; _this$ = ecx

; 144  :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 145  :     return pRealUser->BeginAuthSession      ( pAuthTicket,

	push	DWORD PTR _steamID$[ebp+4]
	mov	ecx, DWORD PTR [ecx+4]
	push	DWORD PTR _steamID$[ebp]
	push	DWORD PTR _cbAuthTicket$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR _pAuthTicket$[ebp]
	call	DWORD PTR [eax+56]

; 146  :                                                 cbAuthTicket,
; 147  :                                                   steamID );
; 148  :   }

	pop	ebp
	ret	16					; 00000010H
?BeginAuthSession@IWrapSteamUser@@UAE?AW4EBeginAuthSessionResult@@PBXHVCSteamID@@@Z ENDP ; IWrapSteamUser::BeginAuthSession
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?GetAuthSessionTicket@IWrapSteamUser@@UAEIPAXHPAI@Z
_TEXT	SEGMENT
_pTicket$ = 8						; size = 4
_cbMaxTicket$ = 12					; size = 4
_pcbTicket$ = 16					; size = 4
?GetAuthSessionTicket@IWrapSteamUser@@UAEIPAXHPAI@Z PROC ; IWrapSteamUser::GetAuthSessionTicket, COMDAT
; _this$ = ecx

; 136  :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 137  :     return pRealUser->GetAuthSessionTicket  ( pTicket,

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]

; 138  :                                                 cbMaxTicket,
; 139  :                                                   pcbTicket );
; 140  :   }

	pop	ebp

; 137  :     return pRealUser->GetAuthSessionTicket  ( pTicket,

	jmp	DWORD PTR [eax+52]
?GetAuthSessionTicket@IWrapSteamUser@@UAEIPAXHPAI@Z ENDP ; IWrapSteamUser::GetAuthSessionTicket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?GetVoiceOptimalSampleRate@IWrapSteamUser@@UAEIXZ
_TEXT	SEGMENT
?GetVoiceOptimalSampleRate@IWrapSteamUser@@UAEIXZ PROC	; IWrapSteamUser::GetVoiceOptimalSampleRate, COMDAT
; _this$ = ecx

; 131  :   virtual uint32       GetVoiceOptimalSampleRate (void) override { return pRealUser->GetVoiceOptimalSampleRate (); }

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+48]
?GetVoiceOptimalSampleRate@IWrapSteamUser@@UAEIXZ ENDP	; IWrapSteamUser::GetVoiceOptimalSampleRate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?DecompressVoice@IWrapSteamUser@@UAE?AW4EVoiceResult@@PBXIPAXIPAII@Z
_TEXT	SEGMENT
_pCompressed$ = 8					; size = 4
_cbCompressed$ = 12					; size = 4
_pDestBuffer$ = 16					; size = 4
_cbDestBufferSize$ = 20					; size = 4
_nBytesWritten$ = 24					; size = 4
_nDesiredSampleRate$ = 28				; size = 4
?DecompressVoice@IWrapSteamUser@@UAE?AW4EVoiceResult@@PBXIPAXIPAII@Z PROC ; IWrapSteamUser::DecompressVoice, COMDAT
; _this$ = ecx

; 123  :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 124  :     return pRealUser->DecompressVoice       ( pCompressed,

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]

; 125  :                                                 cbCompressed,
; 126  :                                                   pDestBuffer,
; 127  :                                                     cbDestBufferSize,
; 128  :                                                       nBytesWritten,
; 129  :                                                         nDesiredSampleRate );
; 130  :   }

	pop	ebp

; 124  :     return pRealUser->DecompressVoice       ( pCompressed,

	jmp	DWORD PTR [eax+44]
?DecompressVoice@IWrapSteamUser@@UAE?AW4EVoiceResult@@PBXIPAXIPAII@Z ENDP ; IWrapSteamUser::DecompressVoice
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?GetVoice@IWrapSteamUser@@UAE?AW4EVoiceResult@@_NPAXIPAI01I2I@Z
_TEXT	SEGMENT
_bWantCompressed$ = 8					; size = 1
_pDestBuffer$ = 12					; size = 4
_cbDestBufferSize$ = 16					; size = 4
_nBytesWritten$ = 20					; size = 4
_bWantUncompressed$ = 24				; size = 1
_pUncompressedDestBuffer$ = 28				; size = 4
_cbUncompressedDestBufferSize$ = 32			; size = 4
_nUncompressBytesWritten$ = 36				; size = 4
_nUncompressedVoiceDesiredSampleRate$ = 40		; size = 4
?GetVoice@IWrapSteamUser@@UAE?AW4EVoiceResult@@_NPAXIPAI01I2I@Z PROC ; IWrapSteamUser::GetVoice, COMDAT
; _this$ = ecx

; 106  :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 107  :     return pRealUser->GetVoice              ( bWantCompressed,

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]

; 108  :                                                 pDestBuffer,
; 109  :                                                   cbDestBufferSize,
; 110  :                                                     nBytesWritten,
; 111  :                                                       bWantUncompressed,
; 112  :                                                         pUncompressedDestBuffer,
; 113  :                                                           cbUncompressedDestBufferSize,
; 114  :                                                             nUncompressBytesWritten,
; 115  :                                                               nUncompressedVoiceDesiredSampleRate );
; 116  :   }

	pop	ebp

; 107  :     return pRealUser->GetVoice              ( bWantCompressed,

	jmp	DWORD PTR [eax+40]
?GetVoice@IWrapSteamUser@@UAE?AW4EVoiceResult@@_NPAXIPAI01I2I@Z ENDP ; IWrapSteamUser::GetVoice
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?GetAvailableVoice@IWrapSteamUser@@UAE?AW4EVoiceResult@@PAI0I@Z
_TEXT	SEGMENT
_pcbCompressed$ = 8					; size = 4
_pcbUncompressed$ = 12					; size = 4
_nUncompressedVoiceDesiredSampleRate$ = 16		; size = 4
?GetAvailableVoice@IWrapSteamUser@@UAE?AW4EVoiceResult@@PAI0I@Z PROC ; IWrapSteamUser::GetAvailableVoice, COMDAT
; _this$ = ecx

; 92   :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 93   :     return pRealUser->GetAvailableVoice     ( pcbCompressed,

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]

; 94   :                                                 pcbUncompressed,
; 95   :                                                   nUncompressedVoiceDesiredSampleRate );
; 96   :   }

	pop	ebp

; 93   :     return pRealUser->GetAvailableVoice     ( pcbCompressed,

	jmp	DWORD PTR [eax+36]
?GetAvailableVoice@IWrapSteamUser@@UAE?AW4EVoiceResult@@PAI0I@Z ENDP ; IWrapSteamUser::GetAvailableVoice
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?StopVoiceRecording@IWrapSteamUser@@UAEXXZ
_TEXT	SEGMENT
?StopVoiceRecording@IWrapSteamUser@@UAEXXZ PROC		; IWrapSteamUser::StopVoiceRecording, COMDAT
; _this$ = ecx

; 87   :   virtual void         StopVoiceRecording    (void) override { return pRealUser->StopVoiceRecording  (); };

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+32]
?StopVoiceRecording@IWrapSteamUser@@UAEXXZ ENDP		; IWrapSteamUser::StopVoiceRecording
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?StartVoiceRecording@IWrapSteamUser@@UAEXXZ
_TEXT	SEGMENT
?StartVoiceRecording@IWrapSteamUser@@UAEXXZ PROC	; IWrapSteamUser::StartVoiceRecording, COMDAT
; _this$ = ecx

; 86   :   virtual void         StartVoiceRecording   (void) override { return pRealUser->StartVoiceRecording (); };

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+28]
?StartVoiceRecording@IWrapSteamUser@@UAEXXZ ENDP	; IWrapSteamUser::StartVoiceRecording
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?GetUserDataFolder@IWrapSteamUser@@UAE_NPADH@Z
_TEXT	SEGMENT
_pchBuffer$ = 8						; size = 4
_cubBuffer$ = 12					; size = 4
?GetUserDataFolder@IWrapSteamUser@@UAE_NPADH@Z PROC	; IWrapSteamUser::GetUserDataFolder, COMDAT
; _this$ = ecx

; 81   :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 82   :     return pRealUser->GetUserDataFolder     ( pchBuffer,

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+24]

; 83   :                                                 cubBuffer );
; 84   :   };

	pop	ebp

; 82   :     return pRealUser->GetUserDataFolder     ( pchBuffer,

	jmp	eax
?GetUserDataFolder@IWrapSteamUser@@UAE_NPADH@Z ENDP	; IWrapSteamUser::GetUserDataFolder
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?TrackAppUsageEvent@IWrapSteamUser@@UAEXVCGameID@@HPBD@Z
_TEXT	SEGMENT
_gameID$ = 8						; size = 8
_eAppUsageEvent$ = 16					; size = 4
_pchExtraInfo$ = 20					; size = 4
?TrackAppUsageEvent@IWrapSteamUser@@UAEXVCGameID@@HPBD@Z PROC ; IWrapSteamUser::TrackAppUsageEvent, COMDAT
; _this$ = ecx

; 74   :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 75   :     return pRealUser->TrackAppUsageEvent    ( gameID,

	push	DWORD PTR _pchExtraInfo$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	push	DWORD PTR _eAppUsageEvent$[ebp]
	push	DWORD PTR _gameID$[ebp+4]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR _gameID$[ebp]
	call	DWORD PTR [eax+20]

; 76   :                                                 eAppUsageEvent,
; 77   :                                                   pchExtraInfo );
; 78   :   };

	pop	ebp
	ret	16					; 00000010H
?TrackAppUsageEvent@IWrapSteamUser@@UAEXVCGameID@@HPBD@Z ENDP ; IWrapSteamUser::TrackAppUsageEvent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?TerminateGameConnection@IWrapSteamUser@@UAEXIG@Z
_TEXT	SEGMENT
_unIPServer$ = 8					; size = 4
_usPortServer$ = 12					; size = 2
?TerminateGameConnection@IWrapSteamUser@@UAEXIG@Z PROC	; IWrapSteamUser::TerminateGameConnection, COMDAT
; _this$ = ecx

; 67   :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 68   :     return pRealUser->TerminateGameConnection ( unIPServer,

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]

; 69   :                                                   usPortServer );
; 70   :   };

	pop	ebp

; 68   :     return pRealUser->TerminateGameConnection ( unIPServer,

	jmp	DWORD PTR [eax+16]
?TerminateGameConnection@IWrapSteamUser@@UAEXIG@Z ENDP	; IWrapSteamUser::TerminateGameConnection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?InitiateGameConnection@IWrapSteamUser@@UAEHPAXHVCSteamID@@IG_N@Z
_TEXT	SEGMENT
_pAuthBlob$ = 8						; size = 4
_cbMaxAuthBlob$ = 12					; size = 4
_steamIDGameServer$ = 16				; size = 8
_unIPServer$ = 24					; size = 4
_usPortServer$ = 28					; size = 2
_bSecure$ = 32						; size = 1
?InitiateGameConnection@IWrapSteamUser@@UAEHPAXHVCSteamID@@IG_N@Z PROC ; IWrapSteamUser::InitiateGameConnection, COMDAT
; _this$ = ecx

; 58   :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 59   :     return pRealUser->InitiateGameConnection ( pAuthBlob,

	push	DWORD PTR _bSecure$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	push	DWORD PTR _usPortServer$[ebp]
	push	DWORD PTR _unIPServer$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR _steamIDGameServer$[ebp+4]
	push	DWORD PTR _steamIDGameServer$[ebp]
	push	DWORD PTR _cbMaxAuthBlob$[ebp]
	push	DWORD PTR _pAuthBlob$[ebp]
	call	DWORD PTR [eax+12]

; 60   :                                                  cbMaxAuthBlob, 
; 61   :                                                    steamIDGameServer, 
; 62   :                                                      unIPServer, 
; 63   :                                                        usPortServer, 
; 64   :                                                          bSecure );
; 65   :   };

	pop	ebp
	ret	28					; 0000001cH
?InitiateGameConnection@IWrapSteamUser@@UAEHPAXHVCSteamID@@IG_N@Z ENDP ; IWrapSteamUser::InitiateGameConnection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?GetSteamID@IWrapSteamUser@@UAE?AVCSteamID@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetSteamID@IWrapSteamUser@@UAE?AVCSteamID@@XZ PROC	; IWrapSteamUser::GetSteamID, COMDAT
; _this$ = ecx

; 50   :   virtual CSteamID   GetSteamID             ( void ) override { return pRealUser->GetSteamID    (); };

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+4]
	push	DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	ebp
	ret	4
?GetSteamID@IWrapSteamUser@@UAE?AVCSteamID@@XZ ENDP	; IWrapSteamUser::GetSteamID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?BLoggedOn@IWrapSteamUser@@UAE_NXZ
_TEXT	SEGMENT
?BLoggedOn@IWrapSteamUser@@UAE_NXZ PROC			; IWrapSteamUser::BLoggedOn, COMDAT
; _this$ = ecx

; 34   :     __SK_SteamUser_BLoggedOn =

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	call	eax
	xor	ecx, ecx
	test	al, al
	setne	cl

; 35   :       static_cast <int> ( pRealUser->BLoggedOn () ? SK_SteamUser_LoggedOn_e::Online :
; 36   :                                                     SK_SteamUser_LoggedOn_e::Offline );
; 37   : 
; 38   :     if (config.steam.spoof_BLoggedOn)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+392, 0
	mov	DWORD PTR ?__SK_SteamUser_BLoggedOn@@3HA, ecx ; __SK_SteamUser_BLoggedOn
	je	SHORT $LN2@BLoggedOn

; 39   :     {
; 40   :       if (__SK_SteamUser_BLoggedOn != static_cast <int> (SK_SteamUser_LoggedOn_e::Online))

	cmp	ecx, 1
	je	SHORT $LN3@BLoggedOn

; 41   :         __SK_SteamUser_BLoggedOn   |= static_cast <int> (SK_SteamUser_LoggedOn_e::Spoofing);

	or	ecx, 2
	mov	DWORD PTR ?__SK_SteamUser_BLoggedOn@@3HA, ecx ; __SK_SteamUser_BLoggedOn
$LN3@BLoggedOn:

; 42   : 
; 43   :       return true;

	mov	al, 1

; 47   :   };

	ret	0
$LN2@BLoggedOn:

; 44   :     }
; 45   : 
; 46   :     return (__SK_SteamUser_BLoggedOn & static_cast <int> (SK_SteamUser_LoggedOn_e::Online)) != 0;

	and	ecx, 1
	mov	al, cl

; 47   :   };

	ret	0
?BLoggedOn@IWrapSteamUser@@UAE_NXZ ENDP			; IWrapSteamUser::BLoggedOn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?GetHSteamUser@IWrapSteamUser@@UAEHXZ
_TEXT	SEGMENT
?GetHSteamUser@IWrapSteamUser@@UAEHXZ PROC		; IWrapSteamUser::GetHSteamUser, COMDAT
; _this$ = ecx

; 29   :   virtual HSteamUser GetHSteamUser          ( void ) override { return pRealUser->GetHSteamUser (); };

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax]
?GetHSteamUser@IWrapSteamUser@@UAEHXZ ENDP		; IWrapSteamUser::GetHSteamUser
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ??0IWrapSteamUser@@QAE@PAVISteamUser@@@Z
_TEXT	SEGMENT
_pUser$ = 8						; size = 4
??0IWrapSteamUser@@QAE@PAVISteamUser@@@Z PROC		; IWrapSteamUser::IWrapSteamUser, COMDAT
; _this$ = ecx

; 26   :                    pRealUser (pUser) {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _pUser$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 27   :   };

	mov	eax, ecx
	mov	DWORD PTR [ecx], OFFSET ??_7IWrapSteamUser@@6B@
	pop	ebp
	ret	4
??0IWrapSteamUser@@QAE@PAVISteamUser@@@Z ENDP		; IWrapSteamUser::IWrapSteamUser
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__FSK_SteamWrapper_remap_user@@YAXXZ
text$yd	SEGMENT
??__FSK_SteamWrapper_remap_user@@YAXXZ PROC		; `dynamic atexit destructor for 'SK_SteamWrapper_remap_user'', COMDAT
	mov	ecx, OFFSET ?SK_SteamWrapper_remap_user@@3V?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@A ; SK_SteamWrapper_remap_user
	jmp	??1?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@XZ ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::~_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >
??__FSK_SteamWrapper_remap_user@@YAXXZ ENDP		; `dynamic atexit destructor for 'SK_SteamWrapper_remap_user''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ??__ESK_SteamWrapper_remap_user@@YAXXZ
text$di	SEGMENT
__Index$2 = -20						; size = 4
$T3 = -18						; size = 2
$T4 = -13						; size = 1
__$EHRec$ = -12						; size = 12
??__ESK_SteamWrapper_remap_user@@YAXXZ PROC		; `dynamic initializer for 'SK_SteamWrapper_remap_user'', COMDAT

; 17   : concurrency::concurrent_unordered_map <ISteamUser*, IWrapSteamUser*>   SK_SteamWrapper_remap_user;

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 252  :         : _Mybase(_Number_of_buckets, _Key_compare(_Hasher, _Key_equality), _Allocator)

	mov	ecx, OFFSET ?SK_SteamWrapper_remap_user@@3V?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@A ; SK_SteamWrapper_remap_user
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp

; 17   : concurrency::concurrent_unordered_map <ISteamUser*, IWrapSteamUser*>   SK_SteamWrapper_remap_user;

	push	-1
	push	__ehhandler$??__ESK_SteamWrapper_remap_user@@YAXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 252  :         : _Mybase(_Number_of_buckets, _Key_compare(_Hasher, _Key_equality), _Allocator)

	lea	eax, DWORD PTR $T4[ebp]
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp

; 17   : concurrency::concurrent_unordered_map <ISteamUser*, IWrapSteamUser*>   SK_SteamWrapper_remap_user;

	sub	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 252  :         : _Mybase(_Number_of_buckets, _Key_compare(_Hasher, _Key_equality), _Allocator)

	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	push	8
	call	??0?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@IABV?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@12@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 846  :         if (_Current_buckets > _Buckets)

	cmp	DWORD PTR ?SK_SteamWrapper_remap_user@@3V?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@A+148, 8
	ja	SHORT $LN11@dynamic

; 76   :     _BitScanReverse(&_Index, _Mask);

	mov	eax, 15					; 0000000fH
	mov	DWORD PTR __Index$2[ebp], 0
	bsr	eax, eax
	mov	DWORD PTR __Index$2[ebp], eax

; 855  :         _M_number_of_buckets = ((size_type) 1) << _Get_msb(_Buckets*2-1);

	mov	eax, 1
	mov	cl, BYTE PTR __Index$2[ebp]
	shl	eax, cl
	mov	DWORD PTR ?SK_SteamWrapper_remap_user@@3V?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@A+148, eax
$LN11@dynamic:
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp

; 17   : concurrency::concurrent_unordered_map <ISteamUser*, IWrapSteamUser*>   SK_SteamWrapper_remap_user;

	push	OFFSET ??__FSK_SteamWrapper_remap_user@@YAXXZ ; `dynamic atexit destructor for 'SK_SteamWrapper_remap_user''
	call	_atexit
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	add	esp, 4
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
text$di	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??__ESK_SteamWrapper_remap_user@@YAXXZ$1:
	mov	ecx, OFFSET ?SK_SteamWrapper_remap_user@@3V?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@A ; SK_SteamWrapper_remap_user
	jmp	??1?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@XZ ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::~_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >
__ehhandler$??__ESK_SteamWrapper_remap_user@@YAXXZ:
	mov	eax, OFFSET __ehfuncinfo$??__ESK_SteamWrapper_remap_user@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??__ESK_SteamWrapper_remap_user@@YAXXZ ENDP		; `dynamic initializer for 'SK_SteamWrapper_remap_user''
; Function compile flags: /Ogtp
;	COMDAT ??1?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@QAE@XZ
_TEXT	SEGMENT
??1?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@QAE@XZ PROC ; Concurrency::concurrent_unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::~concurrent_unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >, COMDAT
; _this$ = ecx
	jmp	??1?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@XZ ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::~_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >
??1?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@QAE@XZ ENDP ; Concurrency::concurrent_unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::~concurrent_unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
;	COMDAT ??A?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@QAEAAPAVIWrapSteamUser@@ABQAVISteamUser@@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 8
$T2 = -8						; size = 8
__Where$ = 8						; size = 4
__Keyval$ = 8						; size = 4
??A?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@QAEAAPAVIWrapSteamUser@@ABQAVISteamUser@@@Z PROC ; Concurrency::concurrent_unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::operator[], COMDAT
; _this$ = ecx

; 713  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 476  :         return _Find(_Keyval);

	mov	edi, DWORD PTR __Keyval$[ebp]
	lea	eax, DWORD PTR __Where$[ebp]
	push	edi
	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 713  :     {

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 476  :         return _Find(_Keyval);

	call	?_Find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamUser@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Find
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 233  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __Where$[ebp]
	test	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 716  :         if (_Where == this->end())

	jne	SHORT $LN47@operator
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 718  :             _Where = this->_Insert(std::make_pair(_Keyval, mapped_type())).first;

	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 718  :             _Where = this->_Insert(std::make_pair(_Keyval, mapped_type())).first;

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	DWORD PTR $T2[ebp+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 718  :             _Where = this->_Insert(std::make_pair(_Keyval, mapped_type())).first;

	push	eax
	call	??$_Insert@U?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@IAE?AU?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@$$QAU?$pair@PAVISteamUser@@PAVIWrapSteamUser@@@4@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Insert<std::pair<ISteamUser *,IWrapSteamUser *> >
	mov	eax, DWORD PTR [eax]
$LN47@operator:

; 719  :         }
; 720  : 
; 721  :         return ((*_Where).second);

	pop	edi
	add	eax, 8
	pop	esi

; 722  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@QAEAAPAVIWrapSteamUser@@ABQAVISteamUser@@@Z ENDP ; Concurrency::concurrent_unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
;	COMDAT ??0?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@QAE@IABU?$hash@PAVISteamUser@@@std@@ABU?$equal_to@PAVISteamUser@@@3@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@3@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Number_of_buckets$ = 8				; size = 4
__Hasher$ = 12						; size = 4
__Key_equality$ = 16					; size = 4
__Allocator$ = 20					; size = 4
$T2 = 22						; size = 2
??0?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@QAE@IABU?$hash@PAVISteamUser@@@std@@ABU?$equal_to@PAVISteamUser@@@3@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@3@@Z PROC ; Concurrency::concurrent_unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::concurrent_unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >, COMDAT
; _this$ = ecx

; 253  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@QAE@IABU?$hash@PAVISteamUser@@@std@@ABU?$equal_to@PAVISteamUser@@@3@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@3@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	edi
	mov	edi, ecx
	lea	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _this$[ebp], edi
	push	DWORD PTR __Allocator$[ebp]
	push	eax
	push	DWORD PTR __Number_of_buckets$[ebp]
	call	??0?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@IABV?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@12@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >

; 254  :         this->rehash(_Number_of_buckets);

	push	DWORD PTR __Number_of_buckets$[ebp]
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?rehash@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAEXI@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::rehash

; 255  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, edi
	pop	edi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@QAE@IABU?$hash@PAVISteamUser@@@std@@ABU?$equal_to@PAVISteamUser@@@3@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@3@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@XZ ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::~_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >
__ehhandler$??0?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@QAE@IABU?$hash@PAVISteamUser@@@std@@ABU?$equal_to@PAVISteamUser@@@3@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@3@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@QAE@IABU?$hash@PAVISteamUser@@@std@@ABU?$equal_to@PAVISteamUser@@@3@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@3@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$concurrent_unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@Concurrency@@QAE@IABU?$hash@PAVISteamUser@@@std@@ABU?$equal_to@PAVISteamUser@@@3@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@3@@Z ENDP ; Concurrency::concurrent_unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::concurrent_unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@2@I@Z PROC ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::allocate, COMDAT
; _this$ = ecx

; 827  : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 53   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN5@allocate

; 58   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 2

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 69   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN9@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@allocate:
$LN9@allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 87   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@allocate:
$LN14@allocate:
	int	3
?allocate@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@2@I@Z ENDP ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@2@I@Z PROC ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::deallocate, COMDAT
; _this$ = ecx

; 822  : 		{	// deallocate object at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 824  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEXPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@2@I@Z ENDP ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >, COMDAT
; _this$ = ecx

; 807  : 		{	// construct by copying (do nothing)
; 808  : 		}

	mov	eax, ecx
	ret	4
??0?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Split_order_dummy_key@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABEII@Z
_TEXT	SEGMENT
__Reversed_order_key$1 = -8				; size = 4
__Order_key$ = 8					; size = 4
?_Split_order_dummy_key@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABEII@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Split_order_dummy_key, COMDAT
; _this$ = ecx

; 1301 :     {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	mov	edx, DWORD PTR __imp_?_Byte_reverse_table@details@Concurrency@@3QBEB

; 67   :     return _Byte_reverse_table[_Original_byte];

	mov	ecx, DWORD PTR __Order_key$[ebp]
	movzx	eax, cl

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+edx]
	mov	BYTE PTR __Reversed_order_key$1[ebp+3], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, ch

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+edx]
	mov	BYTE PTR __Reversed_order_key$1[ebp+2], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, BYTE PTR __Order_key$[ebp+2]

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+edx]
	mov	BYTE PTR __Reversed_order_key$1[ebp+1], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, BYTE PTR __Order_key$[ebp+3]

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+edx]
	mov	BYTE PTR __Reversed_order_key$1[ebp], al

; 1302 :         return _Reverse(_Order_key) & ~(0x1);

	mov	eax, DWORD PTR __Reversed_order_key$1[ebp]
	and	eax, -2					; fffffffeH

; 1303 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?_Split_order_dummy_key@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABEII@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Split_order_dummy_key
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Split_order_regular_key@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABEII@Z
_TEXT	SEGMENT
__Reversed_order_key$1 = -8				; size = 4
__Order_key$ = 8					; size = 4
?_Split_order_regular_key@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABEII@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Split_order_regular_key, COMDAT
; _this$ = ecx

; 1295 :     {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	mov	edx, DWORD PTR __imp_?_Byte_reverse_table@details@Concurrency@@3QBEB

; 67   :     return _Byte_reverse_table[_Original_byte];

	mov	ecx, DWORD PTR __Order_key$[ebp]
	movzx	eax, cl

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+edx]
	mov	BYTE PTR __Reversed_order_key$1[ebp+3], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, ch

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+edx]
	mov	BYTE PTR __Reversed_order_key$1[ebp+2], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, BYTE PTR __Order_key$[ebp+2]

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+edx]
	mov	BYTE PTR __Reversed_order_key$1[ebp+1], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, BYTE PTR __Order_key$[ebp+3]

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+edx]
	mov	BYTE PTR __Reversed_order_key$1[ebp], al

; 1296 :         return _Reverse(_Order_key) | 0x1;

	mov	eax, DWORD PTR __Reversed_order_key$1[ebp]
	or	eax, 1

; 1297 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?_Split_order_regular_key@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABEII@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Split_order_regular_key
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Reverse@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABEII@Z
_TEXT	SEGMENT
__Reversed_order_key$ = -8				; size = 4
__Order_key$ = 8					; size = 4
?_Reverse@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABEII@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Reverse, COMDAT
; _this$ = ecx

; 1278 :     {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1279 :         _Split_order_key _Reversed_order_key;
; 1280 : 
; 1281 :         unsigned char * _Original = (unsigned char *) &_Order_key;
; 1282 :         unsigned char * _Reversed = (unsigned char *) &_Reversed_order_key;
; 1283 : 
; 1284 :         int _Size = sizeof(_Map_key);
; 1285 :         for (int _Index = 0; _Index < _Size; _Index++)
; 1286 :         {
; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	mov	edx, DWORD PTR __imp_?_Byte_reverse_table@details@Concurrency@@3QBEB

; 67   :     return _Byte_reverse_table[_Original_byte];

	mov	ecx, DWORD PTR __Order_key$[ebp]
	movzx	eax, cl

; 1279 :         _Split_order_key _Reversed_order_key;
; 1280 : 
; 1281 :         unsigned char * _Original = (unsigned char *) &_Order_key;
; 1282 :         unsigned char * _Reversed = (unsigned char *) &_Reversed_order_key;
; 1283 : 
; 1284 :         int _Size = sizeof(_Map_key);
; 1285 :         for (int _Index = 0; _Index < _Size; _Index++)
; 1286 :         {
; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+edx]
	mov	BYTE PTR __Reversed_order_key$[ebp+3], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, ch

; 1279 :         _Split_order_key _Reversed_order_key;
; 1280 : 
; 1281 :         unsigned char * _Original = (unsigned char *) &_Order_key;
; 1282 :         unsigned char * _Reversed = (unsigned char *) &_Reversed_order_key;
; 1283 : 
; 1284 :         int _Size = sizeof(_Map_key);
; 1285 :         for (int _Index = 0; _Index < _Size; _Index++)
; 1286 :         {
; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+edx]
	mov	BYTE PTR __Reversed_order_key$[ebp+2], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, BYTE PTR __Order_key$[ebp+2]

; 1279 :         _Split_order_key _Reversed_order_key;
; 1280 : 
; 1281 :         unsigned char * _Original = (unsigned char *) &_Order_key;
; 1282 :         unsigned char * _Reversed = (unsigned char *) &_Reversed_order_key;
; 1283 : 
; 1284 :         int _Size = sizeof(_Map_key);
; 1285 :         for (int _Index = 0; _Index < _Size; _Index++)
; 1286 :         {
; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+edx]
	mov	BYTE PTR __Reversed_order_key$[ebp+1], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, BYTE PTR __Order_key$[ebp+3]

; 1279 :         _Split_order_key _Reversed_order_key;
; 1280 : 
; 1281 :         unsigned char * _Original = (unsigned char *) &_Order_key;
; 1282 :         unsigned char * _Reversed = (unsigned char *) &_Reversed_order_key;
; 1283 : 
; 1284 :         int _Size = sizeof(_Map_key);
; 1285 :         for (int _Index = 0; _Index < _Size; _Index++)
; 1286 :         {
; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+edx]
	mov	BYTE PTR __Reversed_order_key$[ebp], al

; 1288 :         }
; 1289 : 
; 1290 :         return _Reversed_order_key;

	mov	eax, DWORD PTR __Reversed_order_key$[ebp]

; 1291 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?_Reverse@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABEII@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Reverse
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Is_initialized@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABE_NI@Z
_TEXT	SEGMENT
__Index$1 = -4						; size = 4
__Bucket$ = 8						; size = 4
?_Is_initialized@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABE_NI@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Is_initialized, COMDAT
; _this$ = ecx

; 1263 :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	mov	edx, DWORD PTR __Bucket$[ebp]
	mov	eax, edx
	or	eax, 1

; 73   :     unsigned long _Index = 0;

	mov	DWORD PTR __Index$1[ebp], 0

; 74   : 
; 75   : #if (defined (_M_IX86) || defined (_M_ARM))
; 76   :     _BitScanReverse(&_Index, _Mask);

	bsr	eax, eax
	push	esi

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	movzx	esi, al
	push	edi

; 76   :     _BitScanReverse(&_Index, _Mask);

	mov	DWORD PTR __Index$1[ebp], eax

; 1264 :         size_type _Segment = _Segment_index_of(_Bucket);
; 1265 :         _Bucket -= _Segment_base(_Segment);
; 1266 : 
; 1267 :         if (_M_buckets[_Segment] == NULL)

	mov	edi, DWORD PTR [ecx+esi*4+4]
	test	edi, edi
	jne	SHORT $LN2@Is_initial

; 1268 :         {
; 1269 :             return false;

	pop	edi
	xor	al, al
	pop	esi

; 1274 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@Is_initial:

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	mov	ecx, esi
	mov	eax, 1
	shl	eax, cl
	and	eax, -2					; fffffffeH

; 1270 :         }
; 1271 : 
; 1272 :         _Full_iterator _Iterator = _M_buckets[_Segment][_Bucket];
; 1273 :         return (_Iterator._Mynode() != NULL);

	sub	edx, eax
	cmp	DWORD PTR [edi+edx*4], 0
	pop	edi
	setne	al
	pop	esi

; 1274 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?_Is_initialized@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABE_NI@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Is_initialized
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Set_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXIV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@Z
_TEXT	SEGMENT
__New_segment$1$ = -8					; size = 4
_this$1$ = -8						; size = 4
__Index$1 = -4						; size = 4
__Bucket$ = 8						; size = 4
__Wrapped_allocator$2 = 11				; size = 1
$T3 = 12						; size = 1
__Dummy_head$ = 12					; size = 4
?_Set_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXIV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Set_bucket, COMDAT
; _this$ = ecx

; 1244 :     {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	mov	esi, DWORD PTR __Bucket$[ebp]

; 1244 :     {

	mov	ebx, ecx

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	mov	eax, esi

; 73   :     unsigned long _Index = 0;

	mov	DWORD PTR __Index$1[ebp], 0

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	or	eax, 1

; 1244 :     {

	mov	DWORD PTR _this$1$[ebp], ebx

; 76   :     _BitScanReverse(&_Index, _Mask);

	bsr	eax, eax

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	mov	edx, 1

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	movzx	ecx, al

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	shl	edx, cl

; 76   :     _BitScanReverse(&_Index, _Mask);

	mov	DWORD PTR __Index$1[ebp], eax

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	mov	eax, edx
	push	edi
	and	eax, -2					; fffffffeH

; 1245 :         size_type _Segment = _Segment_index_of(_Bucket);
; 1246 :         _Bucket -= _Segment_base(_Segment);
; 1247 : 
; 1248 :         if (_M_buckets[_Segment] == NULL)

	lea	edi, DWORD PTR [ecx+1]
	lea	edi, DWORD PTR [ebx+edi*4]
	sub	esi, eax
	cmp	DWORD PTR [edi], 0
	jne	SHORT $LN20@Set_bucket

; 198  :         return _K ? size_type(1)<<_K : 2;

	test	ecx, ecx
	mov	ebx, 2

; 1251 :             _Full_iterator * _New_segment = _M_allocator.allocate(_Seg_size);

	mov	ecx, DWORD PTR _this$1$[ebp]

; 198  :         return _K ? size_type(1)<<_K : 2;

	cmovne	ebx, edx

; 1251 :             _Full_iterator * _New_segment = _M_allocator.allocate(_Seg_size);

	add	ecx, 144				; 00000090H
	push	ebx
	call	?allocate@?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@QAEPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@2@I@Z ; std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::allocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	DWORD PTR $T3[ebp]
	lea	ecx, DWORD PTR __Wrapped_allocator$2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1251 :             _Full_iterator * _New_segment = _M_allocator.allocate(_Seg_size);

	mov	DWORD PTR __New_segment$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	push	ecx
	push	ebx
	push	eax
	call	??$_Uninitialized_default_fill_n1@PAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@IV?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@2@@std@@YAPAV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@0@PAV10@IAAU?$_Wrap_alloc@V?$allocator@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninitialized_default_fill_n1<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,unsigned int,std::allocator<std::_Flist_iterator<Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1254 :             if (_InterlockedCompareExchangePointer((void * volatile *) &_M_buckets[_Segment], _New_segment, NULL) != NULL)

	mov	edx, DWORD PTR __New_segment$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 262  : 	return (_Uninitialized_default_fill_n1(_First, _Count, _Al,

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1254 :             if (_InterlockedCompareExchangePointer((void * volatile *) &_M_buckets[_Segment], _New_segment, NULL) != NULL)

	mov	ecx, edx
	xor	eax, eax
	lock	 cmpxchg DWORD PTR [edi], ecx
	test	eax, eax
	je	SHORT $LN20@Set_bucket
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	ebx
	push	edx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN20@Set_bucket:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1259 :         _M_buckets[_Segment][_Bucket] = _Dummy_head;

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR __Dummy_head$[ebp]
	pop	edi
	mov	DWORD PTR [ecx+esi*4], eax
	pop	esi
	pop	ebx

; 1260 :     }

	mov	esp, ebp
	pop	ebp
	ret	8
?_Set_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXIV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Set_bucket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Get_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@I@Z
_TEXT	SEGMENT
__Index$1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Bucket$ = 12						; size = 4
?_Get_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@I@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Get_bucket, COMDAT
; _this$ = ecx

; 1237 :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	mov	edx, DWORD PTR __Bucket$[ebp]
	mov	eax, edx
	or	eax, 1

; 73   :     unsigned long _Index = 0;

	mov	DWORD PTR __Index$1[ebp], 0

; 74   : 
; 75   : #if (defined (_M_IX86) || defined (_M_ARM))
; 76   :     _BitScanReverse(&_Index, _Mask);

	bsr	eax, eax
	push	esi

; 1237 :     {

	mov	esi, ecx

; 76   :     _BitScanReverse(&_Index, _Mask);

	mov	DWORD PTR __Index$1[ebp], eax

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	movzx	ecx, al

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	mov	eax, 1
	shl	eax, cl
	and	eax, -2					; fffffffeH

; 1238 :         size_type _Segment = _Segment_index_of(_Bucket);
; 1239 :         _Bucket -= _Segment_base(_Segment);
; 1240 :         return _M_buckets[_Segment][_Bucket];

	sub	edx, eax
	mov	eax, DWORD PTR [esi+ecx*4+4]
	pop	esi
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 1241 :     }

	mov	esp, ebp
	pop	ebp
	ret	8
?_Get_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@I@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Get_bucket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Get_parent@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABEII@Z
_TEXT	SEGMENT
__Index$1 = -4						; size = 4
__Bucket$ = 8						; size = 4
?_Get_parent@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABEII@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Get_parent, COMDAT
; _this$ = ecx

; 1229 :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 76   :     _BitScanReverse(&_Index, _Mask);

	mov	eax, DWORD PTR __Bucket$[ebp]
	bsr	ecx, eax
	mov	DWORD PTR __Index$1[ebp], 0
	mov	DWORD PTR __Index$1[ebp], ecx

; 1230 :         // Unsets bucket's most significant turned-on bit
; 1231 :         unsigned char _Msb = _Get_msb(_Bucket);
; 1232 :         return _Bucket & ~(1 << _Msb);

	movzx	ecx, cl
	btr	eax, ecx

; 1233 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?_Get_parent@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABEII@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Get_parent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Adjust_table_size@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXII@Z
_TEXT	SEGMENT
__Total_elements$ = 8					; size = 4
__Current_size$ = 12					; size = 4
?_Adjust_table_size@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXII@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Adjust_table_size, COMDAT
; _this$ = ecx

; 1219 :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 1220 :         // Grow the table by a factor of 2 if possible and needed
; 1221 :         if (((float) _Total_elements / (float) _Current_size) > _M_maximum_bucket_size)

	mov	eax, DWORD PTR __Total_elements$[ebp]
	push	esi
	mov	esi, DWORD PTR __Current_size$[ebp]
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	eax, esi
	shr	eax, 31					; 0000001fH
	cvtpd2ps xmm1, xmm0
	movd	xmm0, esi
	cvtdq2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	divss	xmm1, xmm0
	comiss	xmm1, DWORD PTR [ecx+152]
	jbe	SHORT $LN2@Adjust_tab

; 1222 :         {
; 1223 :              // Double the size of the hash only if size has not changed inbetween loads
; 1224 :             _InterlockedCompareExchangeSizeT(&_M_number_of_buckets, 2 * _Current_size, _Current_size);

	lea	edx, DWORD PTR [esi+esi]
	add	ecx, 148				; 00000094H
	mov	eax, esi
	lock	 cmpxchg DWORD PTR [ecx], edx
$LN2@Adjust_tab:
	pop	esi

; 1225 :         }
; 1226 :     }

	pop	ebp
	ret	8
?_Adjust_table_size@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXII@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Adjust_table_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Initialize_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXI@Z
_TEXT	SEGMENT
__Reversed_order_key$1 = -12				; size = 4
tv569 = -8						; size = 4
tv570 = -4						; size = 4
__Index$2 = -4						; size = 4
__Index$3 = -4						; size = 4
__Index$4 = -4						; size = 4
__Dummy_node$ = 8					; size = 4
__Bucket$ = 8						; size = 4
?_Initialize_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXI@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Initialize_bucket, COMDAT
; _this$ = ecx

; 1195 :     {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx

; 1196 :         // Bucket 0 has no parent. Initialize it and return.
; 1197 :         if (_Bucket == 0)

	mov	ebx, DWORD PTR __Bucket$[ebp]
	push	esi
	mov	esi, ecx
	test	ebx, ebx
	jne	SHORT $LN2@Initialize

; 940  :         memset(_M_buckets, 0, _Pointers_per_table * sizeof(void *));

	push	128					; 00000080H
	lea	eax, DWORD PTR [esi+4]
	push	ebx
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 941  : 
; 942  :         // Insert the first element in the split-ordered list
; 943  :         _Full_iterator _Dummy_node = _M_split_ordered_list._Begin();
; 944  :         _Set_bucket(0, _Dummy_node);

	mov	ecx, esi
	push	DWORD PTR [esi+132]
	push	ebx
	call	?_Set_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXIV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Set_bucket
	pop	esi
	pop	ebx

; 1216 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@Initialize:

; 76   :     _BitScanReverse(&_Index, _Mask);

	bsr	eax, ebx
	mov	DWORD PTR __Index$4[ebp], 0
	mov	DWORD PTR __Index$4[ebp], eax

; 1198 :         {
; 1199 :             _Init();
; 1200 :             return;
; 1201 :         }
; 1202 : 
; 1203 :         size_type _Parent_bucket = _Get_parent(_Bucket);

	movzx	eax, al
	push	edi

; 1232 :         return _Bucket & ~(1 << _Msb);

	mov	edi, ebx

; 73   :     unsigned long _Index = 0;

	mov	DWORD PTR __Index$3[ebp], 0

; 1232 :         return _Bucket & ~(1 << _Msb);

	btr	edi, eax

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	mov	eax, edi
	or	eax, 1
	mov	DWORD PTR tv569[ebp], eax

; 76   :     _BitScanReverse(&_Index, _Mask);

	bsr	eax, eax

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	movzx	ecx, al

; 76   :     _BitScanReverse(&_Index, _Mask);

	mov	DWORD PTR __Index$3[ebp], eax

; 1267 :         if (_M_buckets[_Segment] == NULL)

	mov	eax, DWORD PTR [esi+ecx*4+4]
	test	eax, eax
	je	SHORT $LN57@Initialize

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	mov	edx, 1

; 1273 :         return (_Iterator._Mynode() != NULL);

	mov	eax, edi

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	shl	edx, cl

; 1273 :         return (_Iterator._Mynode() != NULL);

	mov	ecx, DWORD PTR [esi+ecx*4+4]

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	and	edx, -2					; fffffffeH

; 1273 :         return (_Iterator._Mynode() != NULL);

	sub	eax, edx
	cmp	DWORD PTR [ecx+eax*4], 0
	setne	al

; 1204 : 
; 1205 :         // All _Parent_bucket buckets have to be initialized before this bucket is
; 1206 :         if (!_Is_initialized(_Parent_bucket))

	test	al, al
	jne	SHORT $LN3@Initialize
$LN57@Initialize:

; 1207 :         {
; 1208 :             _Initialize_bucket(_Parent_bucket);

	push	edi
	mov	ecx, esi
	call	?_Initialize_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXI@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Initialize_bucket
$LN3@Initialize:

; 76   :     _BitScanReverse(&_Index, _Mask);

	mov	eax, DWORD PTR tv569[ebp]

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	mov	edx, DWORD PTR __imp_?_Byte_reverse_table@details@Concurrency@@3QBEB

; 76   :     _BitScanReverse(&_Index, _Mask);

	bsr	eax, eax
	mov	DWORD PTR __Index$2[ebp], 0

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	movzx	ecx, al

; 76   :     _BitScanReverse(&_Index, _Mask);

	mov	DWORD PTR __Index$2[ebp], eax

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	mov	eax, 1
	shl	eax, cl
	and	eax, -2					; fffffffeH

; 1240 :         return _M_buckets[_Segment][_Bucket];

	sub	edi, eax
	mov	eax, DWORD PTR [esi+ecx*4+4]

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	ecx, bl

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	ecx, BYTE PTR [ecx+edx]
	mov	BYTE PTR __Reversed_order_key$1[ebp+3], cl

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	ecx, bh

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	ecx, BYTE PTR [ecx+edx]
	mov	BYTE PTR __Reversed_order_key$1[ebp+2], cl

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	ecx, BYTE PTR __Bucket$[ebp+2]

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	ecx, BYTE PTR [ecx+edx]
	mov	BYTE PTR __Reversed_order_key$1[ebp+1], cl

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	ecx, BYTE PTR __Bucket$[ebp+3]

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	ecx, BYTE PTR [ecx+edx]
	mov	BYTE PTR __Reversed_order_key$1[ebp], cl

; 1302 :         return _Reverse(_Order_key) & ~(0x1);

	mov	ecx, DWORD PTR __Reversed_order_key$1[ebp]
	and	ecx, -2					; fffffffeH

; 1209 :         }
; 1210 : 
; 1211 :         _Full_iterator _Parent = _Get_bucket(_Parent_bucket);
; 1212 : 
; 1213 :         // Create a dummy first node in this bucket
; 1214 :         _Full_iterator _Dummy_node = _M_split_ordered_list._Insert_dummy(_Parent, _Split_order_dummy_key(_Bucket));

	push	ecx
	push	DWORD PTR [eax+edi*4]
	lea	eax, DWORD PTR __Dummy_node$[ebp]
	push	eax
	lea	ecx, DWORD PTR [esi+132]
	call	?_Insert_dummy@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@V45@I@Z ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Insert_dummy

; 1215 :         _Set_bucket(_Bucket, _Dummy_node);

	push	DWORD PTR __Dummy_node$[ebp]
	mov	ecx, esi
	push	ebx
	call	?_Set_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXIV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Set_bucket
	pop	edi
	pop	esi
	pop	ebx

; 1216 :     }

	mov	esp, ebp
	pop	ebp
	ret	4
?_Initialize_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXI@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Initialize_bucket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamUser@@@Z
_TEXT	SEGMENT
_this$1$ = -16						; size = 4
__Reversed_order_key$1 = -12				; size = 4
__Index$2 = -8						; size = 4
__Index$3 = -8						; size = 4
__Index$4 = -8						; size = 4
__Val$5 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?_Find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamUser@@@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Find, COMDAT
; _this$ = ecx

; 1037 :     {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	mov	ebx, DWORD PTR __Keyval$[ebp]
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1037 :     {

	mov	esi, ecx
	mov	DWORD PTR _this$1$[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	movzx	eax, BYTE PTR [ebx]
	xor	eax, -2128831035			; 811c9dc5H

; 347  : 		_Val *= _FNV_prime;

	imul	edx, eax, 16777619
	movzx	eax, BYTE PTR [ebx+1]
	push	edi

; 346  : 		_Val ^= (size_t)_First[_Next];

	xor	edx, eax
	movzx	eax, BYTE PTR [ebx+2]

; 347  : 		_Val *= _FNV_prime;

	imul	edx, edx, 16777619
	xor	edx, eax
	movzx	eax, BYTE PTR [ebx+3]
	imul	ecx, edx, 16777619
	mov	ebx, 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1039 :         size_type _Bucket = _Order_key % _M_number_of_buckets;

	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	xor	ecx, eax

; 347  : 		_Val *= _FNV_prime;

	imul	eax, ecx, 16777619
	mov	DWORD PTR __Val$5[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1039 :         size_type _Bucket = _Order_key % _M_number_of_buckets;

	div	DWORD PTR [esi+148]
	npad	11
$LL2@Find:

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	mov	eax, edx

; 73   :     unsigned long _Index = 0;

	mov	DWORD PTR __Index$4[ebp], 0

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	or	eax, 1

; 76   :     _BitScanReverse(&_Index, _Mask);

	bsr	eax, eax

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	movzx	ecx, al

; 76   :     _BitScanReverse(&_Index, _Mask);

	mov	DWORD PTR __Index$4[ebp], eax

; 1267 :         if (_M_buckets[_Segment] == NULL)

	mov	edi, DWORD PTR [esi+ecx*4+4]
	test	edi, edi
	je	SHORT $LN156@Find

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	mov	esi, ebx

; 1273 :         return (_Iterator._Mynode() != NULL);

	mov	eax, edx

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	shl	esi, cl
	and	esi, -2					; fffffffeH

; 1273 :         return (_Iterator._Mynode() != NULL);

	sub	eax, esi
	cmp	DWORD PTR [edi+eax*4], 0
	setne	al

; 1040 : 
; 1041 :         // If _Bucket has not been initialized, keep searching up for a parent bucket
; 1042 :         // that has been initialized.  Worst case is the entire map will be read.
; 1043 :         while (!_Is_initialized(_Bucket))

	test	al, al
	jne	SHORT $LN3@Find
	mov	esi, DWORD PTR _this$1$[ebp]
$LN156@Find:

; 76   :     _BitScanReverse(&_Index, _Mask);

	bsr	eax, edx
	mov	DWORD PTR __Index$3[ebp], 0
	mov	DWORD PTR __Index$3[ebp], eax

; 1044 :         {
; 1045 :             _Bucket = _Get_parent(_Bucket);

	movzx	eax, al

; 1232 :         return _Bucket & ~(1 << _Msb);

	btr	edx, eax

; 1046 :         }

	jmp	SHORT $LL2@Find
$LN3@Find:

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	mov	ecx, DWORD PTR __imp_?_Byte_reverse_table@details@Concurrency@@3QBEB

; 67   :     return _Byte_reverse_table[_Original_byte];

	mov	ebx, DWORD PTR __Val$5[ebp]
	movzx	eax, bl

; 73   :     unsigned long _Index = 0;

	mov	DWORD PTR __Index$2[ebp], 0
	pop	edi

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+ecx]
	mov	BYTE PTR __Reversed_order_key$1[ebp+3], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, bh

; 1051 :         for (_Full_const_iterator _Iterator = _Get_bucket(_Bucket); _Iterator != _Last; _Iterator++)

	mov	ebx, DWORD PTR __Keyval$[ebp]

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+ecx]
	mov	BYTE PTR __Reversed_order_key$1[ebp+2], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, BYTE PTR __Val$5[ebp+2]

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+ecx]
	mov	BYTE PTR __Reversed_order_key$1[ebp+1], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, BYTE PTR __Val$5[ebp+3]

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+ecx]
	mov	BYTE PTR __Reversed_order_key$1[ebp], al

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	mov	eax, edx

; 1296 :         return _Reverse(_Order_key) | 0x1;

	mov	esi, DWORD PTR __Reversed_order_key$1[ebp]

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	or	eax, 1

; 76   :     _BitScanReverse(&_Index, _Mask);

	bsr	eax, eax

; 1296 :         return _Reverse(_Order_key) | 0x1;

	or	esi, 1

; 76   :     _BitScanReverse(&_Index, _Mask);

	mov	DWORD PTR __Index$2[ebp], eax

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	movzx	ecx, al

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	mov	eax, 1
	shl	eax, cl
	and	eax, -2					; fffffffeH

; 1051 :         for (_Full_const_iterator _Iterator = _Get_bucket(_Bucket); _Iterator != _Last; _Iterator++)

	sub	edx, eax
	mov	eax, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4+4]
	mov	eax, DWORD PTR [eax+edx*4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 233  : 		return (this->_Ptr == _Right._Ptr);

	test	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1051 :         for (_Full_const_iterator _Iterator = _Get_bucket(_Bucket); _Iterator != _Last; _Iterator++)

	je	SHORT $LN5@Find
$LL6@Find:

; 1052 :         {
; 1053 :             if (_Mylist::_Get_key(_Iterator) > _Order_key)

	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, esi
	ja	SHORT $LN5@Find

; 1054 :             {
; 1055 :                 // If the order key is smaller than the current order key, the element
; 1056 :                 // is not in the hash.
; 1057 :                 return end();
; 1058 :             }
; 1059 :             else if (_Mylist::_Get_key(_Iterator) == _Order_key)

	jne	SHORT $LN4@Find
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 220  : 		return (_Left == _Right);

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1064 :                 if (!this->_M_comparator(this->_Key_function(*_Iterator), _Keyval))

	je	SHORT $LN134@Find
$LN4@Find:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 210  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	eax, DWORD PTR [eax]

; 233  : 		return (this->_Ptr == _Right._Ptr);

	test	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1051 :         for (_Full_const_iterator _Iterator = _Get_bucket(_Bucket); _Iterator != _Last; _Iterator++)

	jne	SHORT $LL6@Find
$LN5@Find:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	esi
	pop	ebx
	mov	DWORD PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1072 :     }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN134@Find:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	pop	esi
	pop	ebx
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1066 :                     return _M_split_ordered_list._Get_iterator(_Iterator);

	mov	eax, ecx

; 1072 :     }

	mov	esp, ebp
	pop	ebp
	ret	8
?_Find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamUser@@@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamUser@@@Z
_TEXT	SEGMENT
tv686 = -12						; size = 4
__Reversed_order_key$1 = -8				; size = 4
tv688 = -4						; size = 4
__Index$2 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Index$3 = 12						; size = 4
__Val$4 = 12						; size = 4
__Keyval$ = 12						; size = 4
?_Find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamUser@@@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Find, COMDAT
; _this$ = ecx

; 999  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	mov	esi, DWORD PTR __Keyval$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 999  :     {

	mov	ebx, ecx
	push	edi

; 73   :     unsigned long _Index = 0;

	mov	DWORD PTR __Index$2[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	movzx	eax, BYTE PTR [esi]
	xor	eax, -2128831035			; 811c9dc5H

; 347  : 		_Val *= _FNV_prime;

	imul	edx, eax, 16777619
	movzx	eax, BYTE PTR [esi+1]
	xor	edx, eax
	movzx	eax, BYTE PTR [esi+2]
	imul	edx, edx, 16777619
	xor	edx, eax
	movzx	eax, BYTE PTR [esi+3]
	imul	ecx, edx, 16777619
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1001 :         size_type _Bucket = _Order_key % _M_number_of_buckets;

	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	xor	ecx, eax

; 347  : 		_Val *= _FNV_prime;

	imul	eax, ecx, 16777619
	mov	DWORD PTR __Val$4[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1001 :         size_type _Bucket = _Order_key % _M_number_of_buckets;

	div	DWORD PTR [ebx+148]
	mov	edi, edx

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	mov	eax, edi
	or	eax, 1
	mov	DWORD PTR tv686[ebp], eax

; 76   :     _BitScanReverse(&_Index, _Mask);

	bsr	eax, eax

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	movzx	ecx, al

; 76   :     _BitScanReverse(&_Index, _Mask);

	mov	DWORD PTR __Index$2[ebp], eax

; 1267 :         if (_M_buckets[_Segment] == NULL)

	mov	eax, DWORD PTR [ebx+ecx*4+4]
	test	eax, eax
	je	SHORT $LN160@Find

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	mov	edx, 1

; 1273 :         return (_Iterator._Mynode() != NULL);

	mov	eax, edi

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	shl	edx, cl

; 1273 :         return (_Iterator._Mynode() != NULL);

	mov	ecx, DWORD PTR [ebx+ecx*4+4]

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	and	edx, -2					; fffffffeH

; 1273 :         return (_Iterator._Mynode() != NULL);

	sub	eax, edx
	cmp	DWORD PTR [ecx+eax*4], 0
	setne	al

; 1002 : 
; 1003 :         // If _Bucket is empty, initialize it first
; 1004 :         if (!_Is_initialized(_Bucket))

	test	al, al
	jne	SHORT $LN5@Find
$LN160@Find:

; 1005 :         {
; 1006 :             _Initialize_bucket(_Bucket);

	push	edi
	mov	ecx, ebx
	call	?_Initialize_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXI@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Initialize_bucket
$LN5@Find:

; 67   :     return _Byte_reverse_table[_Original_byte];

	mov	edx, DWORD PTR __Val$4[ebp]

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	mov	ecx, DWORD PTR __imp_?_Byte_reverse_table@details@Concurrency@@3QBEB

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, dl

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+ecx]
	mov	BYTE PTR __Reversed_order_key$1[ebp+3], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, dh

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+ecx]
	mov	BYTE PTR __Reversed_order_key$1[ebp+2], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, BYTE PTR __Val$4[ebp+2]

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+ecx]
	mov	BYTE PTR __Reversed_order_key$1[ebp+1], al

; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	eax, BYTE PTR __Val$4[ebp+3]

; 73   :     unsigned long _Index = 0;

	mov	DWORD PTR __Index$3[ebp], 0

; 1287 :             _Reversed[_Size - _Index - 1] = _Reverse_byte(_Original[_Index]);

	movzx	eax, BYTE PTR [eax+ecx]
	mov	BYTE PTR __Reversed_order_key$1[ebp], al

; 76   :     _BitScanReverse(&_Index, _Mask);

	mov	eax, DWORD PTR tv686[ebp]
	bsr	eax, eax

; 1296 :         return _Reverse(_Order_key) | 0x1;

	mov	edx, DWORD PTR __Reversed_order_key$1[ebp]

; 76   :     _BitScanReverse(&_Index, _Mask);

	mov	DWORD PTR __Index$3[ebp], eax

; 1296 :         return _Reverse(_Order_key) | 0x1;

	or	edx, 1

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	movzx	ecx, al

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	mov	eax, 1
	shl	eax, cl
	and	eax, -2					; fffffffeH

; 1240 :         return _M_buckets[_Segment][_Bucket];

	sub	edi, eax
	mov	eax, DWORD PTR [ebx+ecx*4+4]
	mov	eax, DWORD PTR [eax+edi*4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 233  : 		return (this->_Ptr == _Right._Ptr);

	test	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1012 :         for (_Full_iterator _Iterator = _Get_bucket(_Bucket); _Iterator != _Last; _Iterator++)

	je	SHORT $LN3@Find
$LL4@Find:

; 1013 :         {
; 1014 :             if (_Mylist::_Get_key(_Iterator) > _Order_key)

	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, edx
	ja	SHORT $LN3@Find

; 1015 :             {
; 1016 :                 // If the order key is smaller than the current order key, the element
; 1017 :                 // is not in the hash.
; 1018 :                 return end();
; 1019 :             }
; 1020 :             else if (_Mylist::_Get_key(_Iterator) == _Order_key)

	jne	SHORT $LN2@Find
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 220  : 		return (_Left == _Right);

	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1025 :                 if (!this->_M_comparator(this->_Key_function(*_Iterator), _Keyval))

	je	SHORT $LN140@Find
$LN2@Find:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 210  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	eax, DWORD PTR [eax]

; 233  : 		return (this->_Ptr == _Right._Ptr);

	test	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1012 :         for (_Full_iterator _Iterator = _Get_bucket(_Bucket); _Iterator != _Last; _Iterator++)

	jne	SHORT $LL4@Find
$LN3@Find:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1033 :     }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN140@Find:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 1027 :                     return _M_split_ordered_list._Get_iterator(_Iterator);

	mov	eax, ecx

; 1033 :     }

	mov	esp, ebp
	pop	ebp
	ret	8
?_Find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamUser@@@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Init@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXXZ
_TEXT	SEGMENT
?_Init@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXXZ PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Init, COMDAT
; _this$ = ecx

; 938  :     {

	npad	2
	push	esi
	mov	esi, ecx

; 939  :         // Allocate an array of segment pointers
; 940  :         memset(_M_buckets, 0, _Pointers_per_table * sizeof(void *));

	push	128					; 00000080H
	push	0
	lea	eax, DWORD PTR [esi+4]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 941  : 
; 942  :         // Insert the first element in the split-ordered list
; 943  :         _Full_iterator _Dummy_node = _M_split_ordered_list._Begin();
; 944  :         _Set_bucket(0, _Dummy_node);

	mov	ecx, esi
	push	DWORD PTR [esi+132]
	push	0
	call	?_Set_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXIV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Set_bucket
	pop	esi

; 945  :     }

	ret	0
?_Init@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXXZ ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?rehash@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAEXI@Z
_TEXT	SEGMENT
$T1 = -12						; size = 12
__Index$2 = 8						; size = 4
__Buckets$ = 8						; size = 4
?rehash@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAEXI@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::rehash, COMDAT
; _this$ = ecx

; 843  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 844  :         size_type _Current_buckets = _M_number_of_buckets;
; 845  : 
; 846  :         if (_Current_buckets > _Buckets)

	mov	edx, DWORD PTR __Buckets$[ebp]
	sub	esp, 12					; 0000000cH
	push	esi
	mov	esi, ecx
	cmp	DWORD PTR [esi+148], edx
	ja	SHORT $LN1@rehash

; 847  :         {
; 848  :             return;
; 849  :         }
; 850  :         else if (_Buckets <= 0 || _Buckets > unsafe_max_bucket_count())

	lea	eax, DWORD PTR [edx-1]
	cmp	eax, 2147483647				; 7fffffffH
	ja	SHORT $LN16@rehash

; 853  :         }
; 854  :         // Round up the number of buckets to the next largest power of 2
; 855  :         _M_number_of_buckets = ((size_type) 1) << _Get_msb(_Buckets*2-1);

	lea	eax, DWORD PTR [edx*2-1]

; 73   :     unsigned long _Index = 0;

	mov	DWORD PTR __Index$2[ebp], 0

; 74   : 
; 75   : #if (defined (_M_IX86) || defined (_M_ARM))
; 76   :     _BitScanReverse(&_Index, _Mask);

	bsr	eax, eax
	mov	DWORD PTR __Index$2[ebp], eax

; 853  :         }
; 854  :         // Round up the number of buckets to the next largest power of 2
; 855  :         _M_number_of_buckets = ((size_type) 1) << _Get_msb(_Buckets*2-1);

	mov	eax, 1
	mov	cl, BYTE PTR __Index$2[ebp]
	shl	eax, cl
	mov	DWORD PTR [esi+148], eax
$LN1@rehash:
	pop	esi

; 856  :     }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN16@rehash:

; 851  :         {
; 852  :             throw std::out_of_range("invalid number of buckets");

	push	OFFSET ??_C@_0BK@KDCGEAPC@invalid?5number?5of?5buckets?$AA@
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0out_of_range@std@@QAE@PBD@Z		; std::out_of_range::out_of_range
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	__CxxThrowException@8
$LN17@rehash:
$LN15@rehash:
	int	3
?rehash@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAEXI@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::rehash
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?unsafe_max_bucket_count@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QBEIXZ
_TEXT	SEGMENT
?unsafe_max_bucket_count@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QBEIXZ PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::unsafe_max_bucket_count, COMDAT
; _this$ = ecx

; 577  :         return _Segment_size(_Pointers_per_table-1);

	mov	eax, -2147483648			; 80000000H

; 578  :     }

	ret	0
?unsafe_max_bucket_count@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QBEIXZ ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::unsafe_max_bucket_count
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?count@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QBEIABQAVISteamUser@@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
__Keyval$ = 8						; size = 4
?count@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QBEIABQAVISteamUser@@@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::count, COMDAT
; _this$ = ecx

; 506  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 507  :         size_type _Count = 0;
; 508  :         const_iterator _It = _Find(_Keyval);

	mov	esi, DWORD PTR __Keyval$[ebp]
	lea	eax, DWORD PTR __It$[ebp]
	push	edi
	push	esi
	push	eax
	xor	edi, edi
	call	?_Find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@ABE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamUser@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Find
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 233  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __It$[ebp]
	test	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 509  :         for (;_It != end() && !this->_M_comparator(this->_Key_function(*_It), _Keyval); _It++)

	je	SHORT $LN72@count
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 220  : 		return (_Left == _Right);

	mov	edx, DWORD PTR [esi]
	npad	1
$LL8@count:
	cmp	DWORD PTR [eax+4], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 509  :         for (;_It != end() && !this->_M_comparator(this->_Key_function(*_It), _Keyval); _It++)

	jne	SHORT $LN72@count

; 510  :         {
; 511  :             _Count++;

	inc	edi
$LL15@count:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 210  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 80   :         while (this->_Mynode() != NULL && this->_Mynode()->_Is_dummy());

	test	eax, eax
	je	SHORT $LN72@count
	mov	cl, BYTE PTR [eax+12]
	not	cl
	test	cl, 1
	jne	SHORT $LL15@count
	mov	cl, BYTE PTR [eax+12]
	not	cl

; 92   :         while (this->_Mynode() != NULL && this->_Mynode()->_Is_dummy());

	test	cl, 1
	jne	SHORT $LL15@count
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 509  :         for (;_It != end() && !this->_M_comparator(this->_Key_function(*_It), _Keyval); _It++)

	jmp	SHORT $LL8@count
$LN72@count:

; 512  :         }
; 513  :         return _Count;

	mov	eax, edi
	pop	edi
	pop	esi

; 514  :     }

	pop	ebp
	ret	4
?count@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QBEIABQAVISteamUser@@@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::count
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamUser@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamUser@@@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::find, COMDAT
; _this$ = ecx

; 475  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 476  :         return _Find(_Keyval);

	push	DWORD PTR __Keyval$[ebp]
	push	DWORD PTR ___$ReturnUdt$[ebp]
	call	?_Find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamUser@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Find
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 477  :     }

	pop	ebp
	ret	8
?find@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@ABQAVISteamUser@@@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?end@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QBE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QBE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@XZ PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::end, COMDAT
; _this$ = ecx

; 306  :     {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 308  :     }

	pop	ebp
	ret	4
?end@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QBE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@XZ ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?end@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@XZ PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::end, COMDAT
; _this$ = ecx

; 293  :     {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 295  :     }

	pop	ebp
	ret	4
?end@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@XZ ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Segment_size@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@SAII@Z
_TEXT	SEGMENT
__K$ = 8						; size = 4
?_Segment_size@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@SAII@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Segment_size, COMDAT

; 197  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 198  :         return _K ? size_type(1)<<_K : 2;

	mov	ecx, DWORD PTR __K$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@Segment_si
	mov	eax, 1
	shl	eax, cl

; 199  :     }

	pop	ebp
	ret	0
$LN3@Segment_si:

; 198  :         return _K ? size_type(1)<<_K : 2;

	mov	eax, 2

; 199  :     }

	pop	ebp
	ret	0
?_Segment_size@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@SAII@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Segment_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Segment_base@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@SAII@Z
_TEXT	SEGMENT
__K$ = 8						; size = 4
?_Segment_base@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@SAII@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Segment_base, COMDAT

; 192  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 193  :         return (size_type(1)<<_K & ~size_type(1));

	mov	ecx, DWORD PTR __K$[ebp]
	mov	eax, 1
	shl	eax, cl
	and	eax, -2					; fffffffeH

; 194  :     }

	pop	ebp
	ret	0
?_Segment_base@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@SAII@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Segment_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Segment_index_of@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@SAII@Z
_TEXT	SEGMENT
__Index$1 = -4						; size = 4
__Index$ = 8						; size = 4
?_Segment_index_of@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@SAII@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Segment_index_of, COMDAT

; 187  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	mov	eax, DWORD PTR __Index$[ebp]
	or	eax, 1

; 73   :     unsigned long _Index = 0;

	mov	DWORD PTR __Index$1[ebp], 0

; 74   : 
; 75   : #if (defined (_M_IX86) || defined (_M_ARM))
; 76   :     _BitScanReverse(&_Index, _Mask);

	bsr	eax, eax
	mov	DWORD PTR __Index$1[ebp], eax

; 188  :         return size_type( _Get_msb( _Index|1 ) );

	movzx	eax, al

; 189  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?_Segment_index_of@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@SAII@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Segment_index_of
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ??1?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@XZ
_TEXT	SEGMENT
??1?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@XZ PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::~_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >, COMDAT
; _this$ = ecx

; 170  :     {

	npad	2
	push	esi
	push	edi
	mov	edi, ecx

; 172  :         for (size_type _Index = 0; _Index < _Pointers_per_table; _Index++)

	xor	esi, esi
$LL4@Concurrent:

; 173  :         {
; 174  :             if (_M_buckets[_Index] != NULL)

	mov	eax, DWORD PTR [edi+esi*4+4]
	test	eax, eax
	je	SHORT $LN2@Concurrent

; 198  :         return _K ? size_type(1)<<_K : 2;

	test	esi, esi
	je	SHORT $LN12@Concurrent
	mov	edx, 1
	mov	ecx, esi
	shl	edx, cl
	jmp	SHORT $LN13@Concurrent
$LN12@Concurrent:
	mov	edx, 2
$LN13@Concurrent:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	edx, 1073741823				; 3fffffffH
	ja	$LN89@Concurrent

; 99   : 	const size_t _User_size = _Count * _Sz;

	lea	ecx, DWORD PTR [edx*4]

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN20@Concurrent

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	al, 31					; 0000001fH
	jne	SHORT $LN89@Concurrent

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	ecx, DWORD PTR [eax-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	ecx, eax
	jae	SHORT $LN89@Concurrent

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	eax, ecx
	cmp	eax, 4
	jb	SHORT $LN89@Concurrent

; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	eax, 35					; 00000023H
	ja	SHORT $LN89@Concurrent

; 130  : 			<= _NON_USER_SIZE);
; 131  : 
; 132  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	eax, ecx
$LN20@Concurrent:

; 140  : 	::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN2@Concurrent:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 172  :         for (size_type _Index = 0; _Index < _Pointers_per_table; _Index++)

	inc	esi
	cmp	esi, 32					; 00000020H
	jb	SHORT $LL4@Concurrent
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 419  :         _Nodeptr _Pnode = this->_Myhead;

	mov	eax, DWORD PTR [edi+132]

; 420  : 
; 421  :         _ASSERT_EXPR(this->_Myhead != NULL, L"Invalid head list node");
; 422  :         _Pnext = this->_Nextnode(_Pnode);

	mov	esi, DWORD PTR [eax]

; 423  :         _Pnode->_M_next = NULL;

	mov	DWORD PTR [eax], 0

; 424  :         _Pnode = _Pnext;

	mov	eax, esi

; 425  : 
; 426  :         while (_Pnode != NULL)

	test	esi, esi
	je	SHORT $LN33@Concurrent
	npad	5
$LL32@Concurrent:

; 427  :         {
; 428  :             _Pnext = this->_Nextnode(_Pnode);

	mov	esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 430  :             _Pnode = _Pnext;

	mov	eax, esi
	test	esi, esi
	jne	SHORT $LL32@Concurrent
$LN33@Concurrent:

; 397  :         _Nodeptr _Pnode = this->_Myhead;

	mov	eax, DWORD PTR [edi+132]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 433  :         _M_element_count = 0;

	mov	DWORD PTR [edi+140], 0

; 398  :         this->_Myhead = NULL;

	mov	DWORD PTR [edi+132], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 184  :     }

	ret	0
$LN89@Concurrent:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN107@Concurrent:
$LN106@Concurrent:
	int	3
??1?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@XZ ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::~_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ??0?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@IABV?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@12@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Number_of_buckets$ = 8				; size = 4
__Parg$ = 12						; size = 4
__Allocator$ = 16					; size = 4
??0?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@IABV?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@12@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@Z PROC ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >, COMDAT
; _this$ = ecx

; 126  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@IABV?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@12@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 56   :     _Concurrent_unordered_map_traits(const _Key_compare& _Traits) : _M_comparator(_Traits)

	mov	eax, DWORD PTR __Parg$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 126  :     {

	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 56   :     _Concurrent_unordered_map_traits(const _Key_compare& _Traits) : _M_comparator(_Traits)

	mov	ax, WORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	push	16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h

; 56   :     _Concurrent_unordered_map_traits(const _Key_compare& _Traits) : _M_comparator(_Traits)

	mov	WORD PTR [esi], ax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN38@Concurrent
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN64@Concurrent:
$LN38@Concurrent:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 215  :             _M_order_key = _Order_key;

	mov	DWORD PTR [eax+12], 0

; 216  :             _M_next = NULL;

	mov	DWORD PTR [eax], 0

; 313  :         this->_Myhead = _Buynode(0);

	mov	DWORD PTR [esi+132], eax

; 387  :     _Split_ordered_list(_Allocator_type _Allocator = allocator_type()) : _Mybase(_Allocator), _M_element_count(0)

	mov	DWORD PTR [esi+140], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 125  :         : _Traits(_Parg), _M_number_of_buckets(_Number_of_buckets), _M_split_ordered_list(_Allocator), _M_allocator(_Allocator), _M_maximum_bucket_size((float) _Initial_bucket_load)

	mov	eax, DWORD PTR __Number_of_buckets$[ebp]

; 940  :         memset(_M_buckets, 0, _Pointers_per_table * sizeof(void *));

	push	128					; 00000080H

; 125  :         : _Traits(_Parg), _M_number_of_buckets(_Number_of_buckets), _M_split_ordered_list(_Allocator), _M_allocator(_Allocator), _M_maximum_bucket_size((float) _Initial_bucket_load)

	mov	DWORD PTR [esi+148], eax

; 940  :         memset(_M_buckets, 0, _Pointers_per_table * sizeof(void *));

	lea	eax, DWORD PTR [esi+4]
	push	0
	push	eax

; 125  :         : _Traits(_Parg), _M_number_of_buckets(_Number_of_buckets), _M_split_ordered_list(_Allocator), _M_allocator(_Allocator), _M_maximum_bucket_size((float) _Initial_bucket_load)

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR [esi+152], 1082130432		; 40800000H

; 940  :         memset(_M_buckets, 0, _Pointers_per_table * sizeof(void *));

	call	_memset
	add	esp, 12					; 0000000cH

; 941  : 
; 942  :         // Insert the first element in the split-ordered list
; 943  :         _Full_iterator _Dummy_node = _M_split_ordered_list._Begin();
; 944  :         _Set_bucket(0, _Dummy_node);

	mov	ecx, esi
	push	DWORD PTR [esi+132]
	push	0
	call	?_Set_bucket@?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@AAEXIV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@Z ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Set_bucket

; 127  :         _Init();
; 128  :     }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN63@Concurrent:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@IABV?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@12@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	jmp	??1?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE@XZ ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::~_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >
__ehhandler$??0?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@IABV?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@12@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@IABV?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@12@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Concurrent_hash@V?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@@details@Concurrency@@QAE@IABV?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@12@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@Z ENDP ; Concurrency::details::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Concurrent_hash<Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_Check_range@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@AAEXXZ
_TEXT	SEGMENT
?_Check_range@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@AAEXXZ PROC ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Check_range, COMDAT
; _this$ = ecx

; 753  : #if defined (_DEBUG)
; 754  :         for (_Full_iterator _Iterator = _Begin(); _Iterator != _End(); _Iterator++)
; 755  :         {
; 756  :             _Full_iterator _Next_iterator = _Iterator;
; 757  :             _Next_iterator++;
; 758  : 
; 759  :             _ASSERT_EXPR(_Next_iterator == end() || _Next_iterator._Mynode()->_Get_order_key() >= _Iterator._Mynode()->_Get_order_key(), L"!!! List order inconsistency !!!");
; 760  :         }
; 761  : #endif  /* defined (_DEBUG) */
; 762  :     }

	ret	0
?_Check_range@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@AAEXXZ ENDP ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Check_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_Insert_dummy@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@V45@I@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Iterator$ = 12					; size = 4
__Order_key$ = 16					; size = 4
?_Insert_dummy@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@V45@I@Z PROC ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Insert_dummy, COMDAT
; _this$ = ecx

; 634  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 210  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	esi, DWORD PTR __Iterator$[ebp]
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	push	16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 210  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	edi, edi
	jne	SHORT $LN41@Insert_dum
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN126@Insert_dum:
$LN41@Insert_dum:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 215  :             _M_order_key = _Order_key;

	mov	ebx, DWORD PTR __Order_key$[ebp]
	mov	DWORD PTR [edi+12], ebx

; 216  :             _M_next = NULL;

	mov	DWORD PTR [edi], 0
	mov	ecx, DWORD PTR __Iterator$[ebp]
$LL2@Insert_dum:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 233  : 		return (this->_Ptr == _Right._Ptr);

	test	esi, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 651  :             if (_Where == _Last || _Get_key(_Where) > _Order_key)

	je	SHORT $LN7@Insert_dum
	mov	eax, DWORD PTR [esi+12]
	cmp	eax, ebx
	ja	SHORT $LN7@Insert_dum

; 674  :                 }
; 675  :             }
; 676  :             else if (_Get_key(_Where) == _Order_key)

	je	SHORT $LN119@Insert_dum

; 681  :             }
; 682  : 
; 683  :             // Move the iterator forward
; 684  :             _Iterator = _Where;

	mov	ecx, esi
	mov	DWORD PTR __Iterator$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 210  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 686  :         }

	jmp	SHORT $LL2@Insert_dum
$LN7@Insert_dum:

; 610  :         _New_node->_M_next = _Current_node;

	mov	DWORD PTR [edi], esi

; 229  :             _Nodeptr _Exchange_node = (_Nodeptr) _InterlockedCompareExchangePointer((void * volatile *) &_M_next, _New_node, _Current_node);

	mov	edx, edi
	mov	eax, esi
	lock	 cmpxchg DWORD PTR [ecx], edx

; 230  : 
; 231  :             if (_Exchange_node == _Current_node)

	cmp	eax, esi
	je	SHORT $LN120@Insert_dum

; 652  :             {
; 653  :                 _ASSERT_EXPR(_Get_key(_Iterator) < _Order_key, L"Invalid node order in the list");
; 654  : 
; 655  :                 // Try to insert it in the right place
; 656  :                 _Nodeptr _Inserted_node = _Insert(_Iterator._Mynode(), _Dummy_node, _Where._Mynode());
; 657  : 
; 658  :                 if (_Inserted_node == _Dummy_node)

	cmp	eax, edi
	je	SHORT $LN120@Insert_dum
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 210  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	ecx, DWORD PTR __Iterator$[ebp]
	mov	esi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 673  :                     continue;

	jmp	SHORT $LL2@Insert_dum
$LN119@Insert_dum:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 680  :                 return _Where;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	add	esp, 4
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 680  :                 return _Where;

	mov	DWORD PTR [eax], esi
	pop	esi
	pop	ebx

; 688  :     }

	pop	ebp
	ret	12					; 0000000cH
$LN120@Insert_dum:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 688  :     }

	pop	ebp
	ret	12					; 0000000cH
$LN125@Insert_dum:
?_Insert_dummy@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@V45@I@Z ENDP ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Insert_dummy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_Insert@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE?AU?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@5@0PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@23@PAJ@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Iterator$ = 12					; size = 4
__Next$ = 16						; size = 4
__List_node$ = 20					; size = 4
__New_count$ = 24					; size = 4
?_Insert@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE?AU?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@5@0PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@23@PAJ@Z PROC ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Insert, COMDAT
; _this$ = ecx

; 616  :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 229  :             _Nodeptr _Exchange_node = (_Nodeptr) _InterlockedCompareExchangePointer((void * volatile *) &_M_next, _New_node, _Current_node);

	mov	edx, DWORD PTR __Iterator$[ebp]
	push	ebx

; 610  :         _New_node->_M_next = _Current_node;

	mov	ebx, DWORD PTR __List_node$[ebp]
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 83   : 		return (_Ptr);

	mov	edi, DWORD PTR __Next$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 229  :             _Nodeptr _Exchange_node = (_Nodeptr) _InterlockedCompareExchangePointer((void * volatile *) &_M_next, _New_node, _Current_node);

	mov	esi, ebx

; 616  :     {

	mov	DWORD PTR _this$1$[ebp], ecx

; 229  :             _Nodeptr _Exchange_node = (_Nodeptr) _InterlockedCompareExchangePointer((void * volatile *) &_M_next, _New_node, _Current_node);

	mov	eax, edi

; 610  :         _New_node->_M_next = _Current_node;

	mov	DWORD PTR [ebx], edi

; 229  :             _Nodeptr _Exchange_node = (_Nodeptr) _InterlockedCompareExchangePointer((void * volatile *) &_M_next, _New_node, _Current_node);

	lock	 cmpxchg DWORD PTR [edx], esi

; 230  : 
; 231  :             if (_Exchange_node == _Current_node)

	cmp	eax, edi
	je	SHORT $LN57@Insert

; 617  :         _Nodeptr _Inserted_node = _Insert(_Iterator._Mynode(), _List_node, _Next._Mynode());
; 618  : 
; 619  :         if (_Inserted_node == _List_node)

	cmp	eax, ebx
	je	SHORT $LN57@Insert
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR [eax], 0

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 630  :     }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN57@Insert:

; 620  :         {
; 621  :             // If the insert succeeded, check that the order is correct and increment the element count
; 622  :             _Check_range();
; 623  :             *_New_count = _InterlockedIncrement(&_M_element_count);

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	ecx, 1
	lock	 xadd	 DWORD PTR [eax+8], ecx
	inc	ecx
	mov	eax, DWORD PTR __New_count$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ebx

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 1
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 630  :     }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?_Insert@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE?AU?$pair@V?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@details@Concurrency@@_N@std@@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@5@0PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@23@PAJ@Z ENDP ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_Insert@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@23@PAU4523@00@Z
_TEXT	SEGMENT
__Previous$ = 8						; size = 4
__New_node$ = 12					; size = 4
__Current_node$ = 16					; size = 4
?_Insert@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@23@PAU4523@00@Z PROC ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Insert, COMDAT
; _this$ = ecx

; 609  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 229  :             _Nodeptr _Exchange_node = (_Nodeptr) _InterlockedCompareExchangePointer((void * volatile *) &_M_next, _New_node, _Current_node);

	mov	ecx, DWORD PTR __Previous$[ebp]
	push	esi

; 610  :         _New_node->_M_next = _Current_node;

	mov	esi, DWORD PTR __Current_node$[ebp]

; 229  :             _Nodeptr _Exchange_node = (_Nodeptr) _InterlockedCompareExchangePointer((void * volatile *) &_M_next, _New_node, _Current_node);

	mov	eax, esi
	push	edi

; 610  :         _New_node->_M_next = _Current_node;

	mov	edi, DWORD PTR __New_node$[ebp]

; 229  :             _Nodeptr _Exchange_node = (_Nodeptr) _InterlockedCompareExchangePointer((void * volatile *) &_M_next, _New_node, _Current_node);

	mov	edx, edi

; 610  :         _New_node->_M_next = _Current_node;

	mov	DWORD PTR [edi], esi

; 229  :             _Nodeptr _Exchange_node = (_Nodeptr) _InterlockedCompareExchangePointer((void * volatile *) &_M_next, _New_node, _Current_node);

	lock	 cmpxchg DWORD PTR [ecx], edx

; 230  : 
; 231  :             if (_Exchange_node == _Current_node)

	cmp	eax, esi
	cmove	eax, edi
	pop	edi
	pop	esi

; 611  :         return _Previous->_Atomic_set_next(_New_node, _Current_node);
; 612  :     }

	pop	ebp
	ret	12					; 0000000cH
?_Insert@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@23@PAU4523@00@Z ENDP ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_Erase@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAEXPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@23@@Z
_TEXT	SEGMENT
__Delete_node$ = 8					; size = 4
?_Erase@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAEXPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@23@@Z PROC ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Erase, COMDAT
; _this$ = ecx

; 597  :     {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	16					; 00000010H
	push	1
	push	DWORD PTR __Delete_node$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 604  :     }

	pop	ebp
	ret	4
?_Erase@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAEXPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@23@@Z ENDP ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_Get_iterator@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QBE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@V?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Iterator$ = 12					; size = 4
?_Get_iterator@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QBE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@V?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@Z PROC ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Get_iterator, COMDAT
; _this$ = ecx

; 552  :     {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Iterator$[ebp]
	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 555  :     }

	pop	ebp
	ret	8
?_Get_iterator@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QBE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@V?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@Z ENDP ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Get_iterator
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_Get_iterator@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Iterator$ = 12					; size = 4
?_Get_iterator@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@Z PROC ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Get_iterator, COMDAT
; _this$ = ecx

; 544  :     {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Iterator$[ebp]
	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 547  :     }

	pop	ebp
	ret	8
?_Get_iterator@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@V?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@Z ENDP ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Get_iterator
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_Get_key@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@SAIABV?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@Z
_TEXT	SEGMENT
__Iterator$ = 8						; size = 4
?_Get_key@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@SAIABV?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@Z PROC ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Get_key, COMDAT

; 537  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 538  :         return _Iterator._Mynode()->_Get_order_key();

	mov	eax, DWORD PTR __Iterator$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+12]

; 539  :     }

	pop	ebp
	ret	0
?_Get_key@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@SAIABV?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@@Z ENDP ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Get_key
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_End@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QBE?AV?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_End@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QBE?AV?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@XZ PROC ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_End, COMDAT
; _this$ = ecx

; 532  :     {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 534  :     }

	pop	ebp
	ret	4
?_End@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QBE?AV?$_Flist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@XZ ENDP ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_End
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_End@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_End@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@XZ PROC ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_End, COMDAT
; _this$ = ecx

; 527  :     {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 529  :     }

	pop	ebp
	ret	4
?_End@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@XZ ENDP ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_End
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_Begin@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Begin@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@XZ PROC ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Begin, COMDAT
; _this$ = ecx

; 516  :     {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 518  :     }

	pop	ebp
	ret	4
?_Begin@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE?AV?$_Flist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@XZ ENDP ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?end@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QBE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QBE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@XZ PROC ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::end, COMDAT
; _this$ = ecx

; 456  :     {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 458  :     }

	pop	ebp
	ret	4
?end@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QBE?AV?$_Solist_const_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@XZ ENDP ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?end@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@XZ PROC ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::end, COMDAT
; _this$ = ecx

; 451  :     {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\forward_list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 453  :     }

	pop	ebp
	ret	4
?end@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE?AV?$_Solist_iterator@V?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@23@XZ ENDP ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?clear@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAEXXZ PROC ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::clear, COMDAT
; _this$ = ecx

; 413  :     {

	npad	2
	push	esi
	push	edi
	mov	edi, ecx

; 414  : #if _ITERATOR_DEBUG_LEVEL == 2
; 415  :         _Orphan_ptr(*this, 0);
; 416  : #endif  /* _ITERATOR_DEBUG_LEVEL == 2 */
; 417  : 
; 418  :         _Nodeptr _Pnext;
; 419  :         _Nodeptr _Pnode = this->_Myhead;

	mov	eax, DWORD PTR [edi]

; 420  : 
; 421  :         _ASSERT_EXPR(this->_Myhead != NULL, L"Invalid head list node");
; 422  :         _Pnext = this->_Nextnode(_Pnode);

	mov	esi, DWORD PTR [eax]

; 423  :         _Pnode->_M_next = NULL;

	mov	DWORD PTR [eax], 0

; 424  :         _Pnode = _Pnext;

	mov	eax, esi

; 425  : 
; 426  :         while (_Pnode != NULL)

	test	esi, esi
	je	SHORT $LN38@clear
$LL2@clear:

; 427  :         {
; 428  :             _Pnext = this->_Nextnode(_Pnode);

	mov	esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 430  :             _Pnode = _Pnext;

	mov	eax, esi
	test	esi, esi
	jne	SHORT $LL2@clear
$LN38@clear:

; 431  :         }
; 432  : 
; 433  :         _M_element_count = 0;

	mov	DWORD PTR [edi+8], 0
	pop	edi
	pop	esi

; 434  :     }

	ret	0
?clear@?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAEXXZ ENDP ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ??1?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE@XZ
_TEXT	SEGMENT
??1?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE@XZ PROC ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::~_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >, COMDAT
; _this$ = ecx

; 392  :     {

	npad	2
	push	esi
	push	edi
	mov	edi, ecx

; 419  :         _Nodeptr _Pnode = this->_Myhead;

	mov	eax, DWORD PTR [edi]

; 420  : 
; 421  :         _ASSERT_EXPR(this->_Myhead != NULL, L"Invalid head list node");
; 422  :         _Pnext = this->_Nextnode(_Pnode);

	mov	esi, DWORD PTR [eax]

; 423  :         _Pnode->_M_next = NULL;

	mov	DWORD PTR [eax], 0

; 424  :         _Pnode = _Pnext;

	mov	eax, esi

; 425  : 
; 426  :         while (_Pnode != NULL)

	test	esi, esi
	je	SHORT $LN5@Split_orde
$LL4@Split_orde:

; 427  :         {
; 428  :             _Pnext = this->_Nextnode(_Pnode);

	mov	esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 430  :             _Pnode = _Pnext;

	mov	eax, esi
	test	esi, esi
	jne	SHORT $LL4@Split_orde
$LN5@Split_orde:

; 393  :         // Clear the list
; 394  :         clear();
; 395  : 
; 396  :         // Remove the head element which is not cleared by clear()
; 397  :         _Nodeptr _Pnode = this->_Myhead;

	mov	eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	16					; 00000010H
	push	1
	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 433  :         _M_element_count = 0;

	mov	DWORD PTR [edi+8], 0

; 398  :         this->_Myhead = NULL;

	mov	DWORD PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 403  :     }

	ret	0
??1?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE@XZ ENDP ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::~_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ??0?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@Z
_TEXT	SEGMENT
__Allocator$ = 8					; size = 1
??0?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@Z PROC ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >, COMDAT
; _this$ = ecx

; 388  :     {

	npad	2
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	push	16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 388  :     {

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN30@Split_orde
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN40@Split_orde:
$LN30@Split_orde:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 215  :             _M_order_key = _Order_key;

	mov	DWORD PTR [eax+12], 0

; 216  :             _M_next = NULL;

	mov	DWORD PTR [eax], 0

; 313  :         this->_Myhead = _Buynode(0);

	mov	DWORD PTR [esi], eax

; 389  :     }

	mov	eax, esi
	mov	DWORD PTR [esi+8], 0
	pop	esi
	ret	4
$LN39@Split_orde:
??0?$_Split_ordered_list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@Z ENDP ; Concurrency::details::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Split_ordered_list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_Myval@?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@SAAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@23@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@SAAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@23@@Z PROC ; Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Myval, COMDAT

; 357  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 358  :         return ((reference)(*_Pnode)._M_element);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 359  :     }

	pop	ebp
	ret	0
?_Myval@?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@SAAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@23@@Z ENDP ; Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_Nextnode@?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@SAAAPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@23@PAU4523@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@SAAAPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@23@PAU4523@@Z PROC ; Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Nextnode, COMDAT

; 351  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 352  :         return ((_Nodepref)(*_Pnode)._M_next);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 353  :     }

	pop	ebp
	ret	0
?_Nextnode@?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@SAAAPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@23@PAU4523@@Z ENDP ; Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Nextnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ?_Buynode@?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@23@I@Z
_TEXT	SEGMENT
__Order_key$ = 8					; size = 4
?_Buynode@?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@23@I@Z PROC ; Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Buynode, COMDAT
; _this$ = ecx

; 342  :     {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	ecx, ecx
	jne	SHORT $LN12@Buynode
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN20@Buynode:
$LN12@Buynode:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 215  :             _M_order_key = _Order_key;

	mov	eax, DWORD PTR __Order_key$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 343  :         _Nodeptr _Pnode = this->_M_node_allocator.allocate(1);
; 344  :         _Pnode->_Init(_Order_key);
; 345  : 
; 346  :         return (_Pnode);

	mov	eax, ecx

; 216  :             _M_next = NULL;

	mov	DWORD PTR [ecx], 0

; 347  :     }

	pop	ebp
	ret	4
$LN19@Buynode:
?_Buynode@?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@23@I@Z ENDP ; Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Buynode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ??1?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE@XZ
_TEXT	SEGMENT
??1?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE@XZ PROC ; Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::~_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >, COMDAT
; _this$ = ecx

; 318  :     }

	ret	0
??1?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE@XZ ENDP ; Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::~_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ??0?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@Z
_TEXT	SEGMENT
__Allocator$ = 8					; size = 1
??0?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@Z PROC ; Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >, COMDAT
; _this$ = ecx

; 310  :     {

	npad	2
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	push	16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 310  :     {

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN25@Split_orde
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN34@Split_orde:
$LN25@Split_orde:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h

; 215  :             _M_order_key = _Order_key;

	mov	DWORD PTR [eax+12], 0

; 216  :             _M_next = NULL;

	mov	DWORD PTR [eax], 0

; 311  :         // Immediately allocate a dummy node with order key of 0. This node
; 312  :         // will always be the head of the list.
; 313  :         this->_Myhead = _Buynode(0);

	mov	DWORD PTR [esi], eax

; 314  :     }

	mov	eax, esi
	pop	esi
	ret	4
$LN33@Split_orde:
??0?$_Split_order_list_value@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@Z ENDP ; Concurrency::details::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Split_order_list_value<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$allocator@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@I@Z PROC ; std::allocator<Concurrency::details::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Node>::allocate, COMDAT
; _this$ = ecx

; 827  : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 53   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 268435455				; 0fffffffH
	jbe	SHORT $LN5@allocate

; 58   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 4

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 69   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN9@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@allocate:
$LN9@allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 87   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@allocate:
$LN14@allocate:
	int	3
?allocate@?$allocator@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAEPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@I@Z ENDP ; std::allocator<Concurrency::details::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Node>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAEXPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAEXPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@I@Z PROC ; std::allocator<Concurrency::details::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 822  : 		{	// deallocate object at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	16					; 00000010H
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 824  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@U_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@@std@@QAEXPAU_Node@?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@I@Z ENDP ; std::allocator<Concurrency::details::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Node>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_split_ordered_list.h
;	COMDAT ??0?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@Z
_TEXT	SEGMENT
__Allocator$ = 8					; size = 1
??0?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@Z PROC ; Concurrency::details::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >, COMDAT
; _this$ = ecx

; 261  :     }

	mov	eax, ecx
	ret	4
??0?$_Split_order_list_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@details@Concurrency@@QAE@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@Z ENDP ; Concurrency::details::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Split_order_list_node<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??R?$equal_to@PAVISteamUser@@@std@@QBE_NABQAVISteamUser@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$equal_to@PAVISteamUser@@@std@@QBE_NABQAVISteamUser@@0@Z PROC ; std::equal_to<ISteamUser *>::operator(), COMDAT
; _this$ = ecx

; 219  : 		{	// apply operator== to operands

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Right$[ebp]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 220  : 		return (_Left == _Right);
; 221  : 		}

	pop	ebp
	ret	8
??R?$equal_to@PAVISteamUser@@@std@@QBE_NABQAVISteamUser@@0@Z ENDP ; std::equal_to<ISteamUser *>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??R?$_Bitwise_hash@PAVISteamUser@@@std@@QBEIABQAVISteamUser@@@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
??R?$_Bitwise_hash@PAVISteamUser@@@std@@QBEIABQAVISteamUser@@@Z PROC ; std::_Bitwise_hash<ISteamUser *>::operator(), COMDAT
; _this$ = ecx

; 360  : 		{	// hash _Keyval to size_t value by pseudorandomizing transform

	npad	2
	push	ebp
	mov	ebp, esp

; 346  : 		_Val ^= (size_t)_First[_Next];

	mov	edx, DWORD PTR __Keyval$[ebp]
	movzx	eax, BYTE PTR [edx]
	xor	eax, -2128831035			; 811c9dc5H

; 347  : 		_Val *= _FNV_prime;

	imul	ecx, eax, 16777619
	movzx	eax, BYTE PTR [edx+1]
	xor	ecx, eax
	movzx	eax, BYTE PTR [edx+2]
	imul	ecx, ecx, 16777619
	xor	ecx, eax
	movzx	eax, BYTE PTR [edx+3]
	imul	ecx, ecx, 16777619
	xor	ecx, eax
	imul	eax, ecx, 16777619

; 361  : 		return (_Hash_seq((const unsigned char *)&_Keyval, sizeof (_Kty)));
; 362  : 		}

	pop	ebp
	ret	4
??R?$_Bitwise_hash@PAVISteamUser@@@std@@QBEIABQAVISteamUser@@@Z ENDP ; std::_Bitwise_hash<ISteamUser *>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ??R?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@QBE_NABQAVISteamUser@@0@Z
_TEXT	SEGMENT
__Keyval1$ = 8						; size = 4
__Keyval2$ = 12						; size = 4
??R?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@QBE_NABQAVISteamUser@@0@Z PROC ; Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >::operator(), COMDAT
; _this$ = ecx

; 50   :     {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Keyval1$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Keyval2$[ebp]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 51   :         return (!_M_key_compare_object(_Keyval1, _Keyval2));
; 52   :     }

	pop	ebp
	ret	8
??R?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@QBE_NABQAVISteamUser@@0@Z ENDP ; Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ??R?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@QBEIABQAVISteamUser@@@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
??R?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@QBEIABQAVISteamUser@@@Z PROC ; Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >::operator(), COMDAT
; _this$ = ecx

; 45   :     {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	mov	edx, DWORD PTR __Keyval$[ebp]
	movzx	eax, BYTE PTR [edx]
	xor	eax, -2128831035			; 811c9dc5H

; 347  : 		_Val *= _FNV_prime;

	imul	ecx, eax, 16777619
	movzx	eax, BYTE PTR [edx+1]
	xor	ecx, eax
	movzx	eax, BYTE PTR [edx+2]
	imul	ecx, ecx, 16777619
	xor	ecx, eax
	movzx	eax, BYTE PTR [edx+3]
	imul	ecx, ecx, 16777619
	xor	ecx, eax
	imul	eax, ecx, 16777619
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h

; 47   :     }

	pop	ebp
	ret	4
??R?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@QBEIABQAVISteamUser@@@Z ENDP ; Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ??0?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@QAE@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@@Z
_TEXT	SEGMENT
__Hasharg$ = 8						; size = 1
__Keyeqarg$ = 12					; size = 1
??0?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@QAE@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@@Z PROC ; Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >, COMDAT
; _this$ = ecx

; 42   :     }

	mov	eax, ecx
	ret	8
??0?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@QAE@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@@Z ENDP ; Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\concurrent_unordered_map.h
;	COMDAT ??0?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@QAE@ABV?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@12@@Z
_TEXT	SEGMENT
__Traits$ = 8						; size = 4
??0?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@QAE@ABV?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@12@@Z PROC ; Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0>::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0>, COMDAT
; _this$ = ecx

; 57   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 56   :     _Concurrent_unordered_map_traits(const _Key_compare& _Traits) : _M_comparator(_Traits)

	mov	eax, DWORD PTR __Traits$[ebp]
	mov	ax, WORD PTR [eax]
	mov	WORD PTR [ecx], ax

; 58   :     }

	mov	eax, ecx
	pop	ebp
	ret	4
??0?$_Concurrent_unordered_map_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@details@Concurrency@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$0A@@details@Concurrency@@QAE@ABV?$_Hash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@12@@Z ENDP ; Concurrency::details::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0>::_Concurrent_unordered_map_traits<ISteamUser *,IWrapSteamUser *,Concurrency::details::_Hash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >, COMDAT
; _this$ = ecx

; 807  : 		{	// construct by copying (do nothing)
; 808  : 		}

	mov	eax, ecx
	ret	4
??0?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >, COMDAT
; _this$ = ecx

; 803  : 		{	// construct default allocator (do nothing)
; 804  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Get_msb@details@Concurrency@@YAEI@Z
_TEXT	SEGMENT
__Index$ = -4						; size = 4
__Mask$ = 8						; size = 4
?_Get_msb@details@Concurrency@@YAEI@Z PROC		; Concurrency::details::_Get_msb, COMDAT

; 72   : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 73   :     unsigned long _Index = 0;
; 74   : 
; 75   : #if (defined (_M_IX86) || defined (_M_ARM))
; 76   :     _BitScanReverse(&_Index, _Mask);

	bsr	eax, DWORD PTR __Mask$[ebp]
	mov	DWORD PTR __Index$[ebp], 0
	mov	DWORD PTR __Index$[ebp], eax

; 77   : #else  /* (defined (_M_IX86) || defined (_M_ARM)) */
; 78   :     _BitScanReverse64(&_Index, _Mask);
; 79   : #endif  /* (defined (_M_IX86) || defined (_M_ARM)) */
; 80   : 
; 81   :     return (unsigned char) _Index;
; 82   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_msb@details@Concurrency@@YAEI@Z ENDP		; Concurrency::details::_Get_msb
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\internal_concurrent_hash.h
;	COMDAT ?_Reverse_byte@details@Concurrency@@YAEE@Z
_TEXT	SEGMENT
__Original_byte$ = 8					; size = 1
?_Reverse_byte@details@Concurrency@@YAEE@Z PROC		; Concurrency::details::_Reverse_byte, COMDAT

; 65   : {

	npad	2
	push	ebp
	mov	ebp, esp

; 66   :     // return ((_Original_byte * 0x80200802ULL) & 0x0884422110ULL) * 0x0101010101ULL >> 32;
; 67   :     return _Byte_reverse_table[_Original_byte];

	movzx	ecx, BYTE PTR __Original_byte$[ebp]
	mov	eax, DWORD PTR __imp_?_Byte_reverse_table@details@Concurrency@@3QBEB
	mov	al, BYTE PTR [ecx+eax]

; 68   : }

	pop	ebp
	ret	0
?_Reverse_byte@details@Concurrency@@YAEE@Z ENDP		; Concurrency::details::_Reverse_byte
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC			; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 84   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN12@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN12@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC			; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0

; 65   :         : _Data()

	lea	eax, DWORD PTR [esi+4]

; 66   :     {
; 67   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	push	eax
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8
	mov	DWORD PTR [esi], OFFSET ??_7out_of_range@std@@6B@
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
??1out_of_range@std@@UAE@XZ PROC			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx

; 84   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	pop	ecx
	ret	0
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\stdexcept
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\stdexcept
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\stdexcept
;	COMDAT ??0out_of_range@std@@QAE@PBD@Z
_TEXT	SEGMENT
__InitData$1 = -8					; size = 8
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0out_of_range@std@@QAE@PBD@Z PROC			; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx

; 141  : 		{	// construct from message string

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h

; 54   :         __std_exception_data _InitData = { _Message, true };

	mov	eax, DWORD PTR __Message$[ebp]
	xorps	xmm0, xmm0
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\stdexcept

; 141  : 		{	// construct from message string

	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h

; 52   :         : _Data()

	lea	edx, DWORD PTR [esi+4]

; 54   :         __std_exception_data _InitData = { _Message, true };

	mov	DWORD PTR __InitData$1[ebp], eax

; 55   :         __std_exception_copy(&_InitData, &_Data);

	lea	eax, DWORD PTR __InitData$1[ebp]
	push	edx
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	movq	QWORD PTR [edx], xmm0
	mov	BYTE PTR __InitData$1[ebp+4], 1
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\stdexcept

; 141  : 		{	// construct from message string

	mov	DWORD PTR [esi], OFFSET ??_7out_of_range@std@@6B@

; 142  : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??0out_of_range@std@@QAE@PBD@Z ENDP			; std::out_of_range::out_of_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 84   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN9@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN9@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0

; 65   :         : _Data()

	lea	eax, DWORD PTR [esi+4]

; 66   :     {
; 67   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	push	eax
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 84   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	pop	ecx
	ret	0
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\stdexcept
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\stdexcept
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\stdexcept
;	COMDAT ??0logic_error@std@@QAE@PBD@Z
_TEXT	SEGMENT
__InitData$1 = -8					; size = 8
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@PBD@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 29   : 		{	// construct from message string

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h

; 54   :         __std_exception_data _InitData = { _Message, true };

	mov	eax, DWORD PTR __Message$[ebp]
	xorps	xmm0, xmm0
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\stdexcept

; 29   : 		{	// construct from message string

	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h

; 52   :         : _Data()

	lea	edx, DWORD PTR [esi+4]

; 54   :         __std_exception_data _InitData = { _Message, true };

	mov	DWORD PTR __InitData$1[ebp], eax

; 55   :         __std_exception_copy(&_InitData, &_Data);

	lea	eax, DWORD PTR __InitData$1[ebp]
	push	edx
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	movq	QWORD PTR [edx], xmm0
	mov	BYTE PTR __InitData$1[ebp+4], 1
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\stdexcept

; 29   : 		{	// construct from message string

	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@

; 30   : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??0logic_error@std@@QAE@PBD@Z ENDP			; std::logic_error::logic_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 96   : 	{	// deallocate storage for _Count elements of size _Sz

	npad	2
	push	ebp
	mov	ebp, esp

; 97   :  #if defined(_M_IX86) || defined(_M_X64)
; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	or	eax, -1
	mov	ecx, DWORD PTR __Count$[ebp]
	xor	edx, edx
	div	DWORD PTR __Sz$[ebp]
	cmp	ecx, eax
	jbe	SHORT $LN2@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2@Deallocate:

; 99   : 	const size_t _User_size = _Count * _Sz;

	imul	ecx, DWORD PTR __Sz$[ebp]

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN9@Deallocate

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	al, 31					; 0000001fH
	je	SHORT $LN4@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4@Deallocate:

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	ecx, DWORD PTR [eax-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	ecx, eax
	jb	SHORT $LN5@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN5@Deallocate:

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	eax, ecx
	cmp	eax, 4
	jae	SHORT $LN6@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN6@Deallocate:

; 126  : 			<= _Ptr_user - _Ptr_container);
; 127  :  #endif /* _DEBUG */
; 128  : 
; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	eax, 35					; 00000023H
	jbe	SHORT $LN3@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 130  : 			<= _NON_USER_SIZE);
; 131  : 
; 132  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 133  : 		}
; 134  : 
; 135  :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 136  : 	static_cast<void>(_Count);
; 137  : 	static_cast<void>(_Sz);
; 138  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 139  : 
; 140  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 	}

	pop	ebp
	ret	0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 50   : 	{	// allocate storage for _Count elements of size _Sz

	npad	2
	push	ebp
	mov	ebp, esp

; 51   : 	void *_Ptr = 0;
; 52   : 
; 53   : 	if (_Count == 0)

	mov	ecx, DWORD PTR __Count$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@Allocate

; 54   : 		return (_Ptr);

	xor	eax, eax
$LN1@Allocate:

; 89   : 		}
; 90   : 	return (_Ptr);
; 91   : 	}

	pop	ebp
	ret	0
$LN2@Allocate:

; 55   : 
; 56   : 	// check overflow of multiply
; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Sz$[ebp]
	cmp	eax, ecx
	jae	SHORT $LN3@Allocate

; 58   : 		_Xbad_alloc();	// report no memory

	jmp	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN3@Allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	imul	ecx, DWORD PTR __Sz$[ebp]

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	BYTE PTR __Try_aligned_allocation$[ebp], 0
	je	SHORT $LN4@Allocate
	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN4@Allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	eax, DWORD PTR [ecx+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	eax, ecx
	ja	SHORT $LN6@Allocate

; 69   : 			_Xbad_alloc();	// report no memory

	jmp	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN6@Allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	eax
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN7@Allocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN7@Allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 89   : 		}
; 90   : 	return (_Ptr);
; 91   : 	}

	pop	ebp
	ret	0
$LN4@Allocate:

; 76   : 
; 77   :  #ifdef _DEBUG
; 78   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 79   :  #endif /* _DEBUG */
; 80   : 		}
; 81   : 	else
; 82   :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 83   : 	static_cast<void>(_Try_aligned_allocation);
; 84   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 85   : 
; 86   : 		{	// allocate normal block
; 87   : 		_Ptr = ::operator new(_User_size);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN1@Allocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 75   : 		}

	ret	4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_new.h
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 98   :         return;
; 99   :     }

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 91   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 92   :         (void)_Size;
; 93   :         return _Where;

	mov	eax, DWORD PTR __Where$[ebp]

; 94   :     }

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 84   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN6@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN6@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 89   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception?$AA@
	test	ecx, ecx
	cmovne	eax, ecx

; 90   :     }

	ret	0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 84   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	pop	ecx

; 85   :     }

	ret	0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 66   :     {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0
	lea	eax, DWORD PTR [esi+4]

; 67   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR __Other$[ebp]
	add	eax, 4
	push	eax
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8

; 68   :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBD@Z
_TEXT	SEGMENT
__InitData$ = -8					; size = 8
__Message$ = 8						; size = 4
??0exception@std@@QAE@QBD@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 53   :     {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 54   :         __std_exception_data _InitData = { _Message, true };

	mov	eax, DWORD PTR __Message$[ebp]
	xorps	xmm0, xmm0
	push	esi
	mov	esi, ecx
	mov	DWORD PTR __InitData$[ebp], eax
	lea	edx, DWORD PTR [esi+4]
	mov	BYTE PTR __InitData$[ebp+4], 1

; 55   :         __std_exception_copy(&_InitData, &_Data);

	push	edx
	lea	eax, DWORD PTR __InitData$[ebp]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	movq	QWORD PTR [edx], xmm0
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8

; 56   :     }

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??0exception@std@@QAE@QBD@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ?_Hash_seq@std@@YAIPBEI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
?_Hash_seq@std@@YAIPBEI@Z PROC				; std::_Hash_seq, COMDAT

; 331  : 	{	// FNV-1a hash function for bytes in [_First, _First + _Count)

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 332  :  #if defined(_WIN64)
; 333  : 	static_assert(sizeof(size_t) == 8, "This code is for 64-bit size_t.");
; 334  : 	const size_t _FNV_offset_basis = 14695981039346656037ULL;
; 335  : 	const size_t _FNV_prime = 1099511628211ULL;
; 336  : 
; 337  :  #else /* defined(_WIN64) */
; 338  : 	static_assert(sizeof(size_t) == 4, "This code is for 32-bit size_t.");
; 339  : 	const size_t _FNV_offset_basis = 2166136261U;
; 340  : 	const size_t _FNV_prime = 16777619U;
; 341  :  #endif /* defined(_WIN64) */
; 342  : 
; 343  : 	size_t _Val = _FNV_offset_basis;
; 344  : 	for (size_t _Next = 0; _Next < _Count; ++_Next)

	mov	esi, DWORD PTR __Count$[ebp]
	xor	ecx, ecx
	mov	edx, -2128831035			; 811c9dc5H
	test	esi, esi
	je	SHORT $LN12@Hash_seq
	push	edi
	mov	edi, DWORD PTR __First$[ebp]
$LL8@Hash_seq:

; 345  : 		{	// fold in another byte
; 346  : 		_Val ^= (size_t)_First[_Next];

	movzx	eax, BYTE PTR [ecx+edi]
	inc	ecx
	xor	eax, edx

; 347  : 		_Val *= _FNV_prime;

	imul	edx, eax, 16777619
	cmp	ecx, esi
	jb	SHORT $LL8@Hash_seq
	pop	edi
$LN12@Hash_seq:

; 348  : 		}
; 349  : 	return (_Val);

	mov	eax, edx
	pop	esi

; 350  : 	}

	pop	ebp
	ret	0
?_Hash_seq@std@@YAIPBEI@Z ENDP				; std::_Hash_seq
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0ISteamUser@@QAE@XZ
_TEXT	SEGMENT
??0ISteamUser@@QAE@XZ PROC				; ISteamUser::ISteamUser, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7ISteamUser@@6B@
	mov	eax, ecx
	ret	0
??0ISteamUser@@QAE@XZ ENDP				; ISteamUser::ISteamUser
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

; 334  : }

	ret	0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

; 334  : }

	ret	0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
