; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	C:\Users\andon\Source\Repos\SpecialK\src\steam\user.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?__SK_SteamUser_BLoggedOn@@3HA			; __SK_SteamUser_BLoggedOn
PUBLIC	?SteamAPI_ISteamClient_GetISteamUser_Original@@3P6APAVISteamUser@@PAVISteamClient@@HHPBD@ZA ; SteamAPI_ISteamClient_GetISteamUser_Original
_BSS	SEGMENT
?SteamAPI_ISteamClient_GetISteamUser_Original@@3P6APAVISteamUser@@PAVISteamClient@@HHPBD@ZA DD 01H DUP (?) ; SteamAPI_ISteamClient_GetISteamUser_Original
_BSS	ENDS
_DATA	SEGMENT
?__SK_SteamUser_BLoggedOn@@3HA DD 0ffffffffH		; __SK_SteamUser_BLoggedOn
_DATA	ENDS
CONST	SEGMENT
?piecewise_construct@std@@3Upiecewise_construct_t@1@B	ORG $+1 ; std::piecewise_construct
	ORG $+3
$SG147848 DB	'SteamAPI_ISteamClient_GetISteamUser_Detour', 00H
	ORG $+1
$SG147849 DB	'[', 00H, '!', 00H, ']', 00H, ' ', 00H, '%', 00H, 'h', 00H
	DB	's', 00H, ' ', 00H, '(', 00H, '.', 00H, '.', 00H, '.', 00H, ','
	DB	00H, ' ', 00H, '%', 00H, 'h', 00H, 's', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG147854 DB	'SteamUser018', 00H
	ORG $+3
$SG147855 DB	'SteamUser019', 00H
	ORG $+3
$SG147856 DB	'SteamUser017', 00H
	ORG $+3
$SG147861 DB	'G', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ' ', 00H, 'r', 00H
	DB	'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, 's', 00H, 't', 00H, 'e'
	DB	00H, 'd', 00H, ' ', 00H, 'u', 00H, 'n', 00H, 'e', 00H, 'x', 00H
	DB	'p', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'e', 00H, 'd', 00H, ' '
	DB	00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'f', 00H
	DB	'a', 00H, 'c', 00H, 'e', 00H, ' ', 00H, 'v', 00H, 'e', 00H, 'r'
	DB	00H, 's', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H, '(', 00H
	DB	'%', 00H, 'h', 00H, 's', 00H, ')', 00H, '!', 00H, 00H, 00H
	ORG $+2
$SG147878 DB	'SK_SteamWrapper_WrappedClient_GetISteamUser', 00H
$SG147879 DB	'[', 00H, '!', 00H, ']', 00H, ' ', 00H, '%', 00H, 'h', 00H
	DB	's', 00H, ' ', 00H, '(', 00H, '.', 00H, '.', 00H, '.', 00H, ','
	DB	00H, ' ', 00H, '%', 00H, 'h', 00H, 's', 00H, ')', 00H, 00H, 00H
	ORG $+2
$SG147884 DB	'SteamUser018', 00H
	ORG $+3
$SG147885 DB	'SteamUser019', 00H
	ORG $+3
$SG147886 DB	'SteamUser017', 00H
	ORG $+7
$SG147891 DB	'G', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ' ', 00H, 'r', 00H
	DB	'e', 00H, 'q', 00H, 'u', 00H, 'e', 00H, 's', 00H, 't', 00H, 'e'
	DB	00H, 'd', 00H, ' ', 00H, 'u', 00H, 'n', 00H, 'e', 00H, 'x', 00H
	DB	'p', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'e', 00H, 'd', 00H, ' '
	DB	00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'f', 00H
	DB	'a', 00H, 'c', 00H, 'e', 00H, ' ', 00H, 'v', 00H, 'e', 00H, 'r'
	DB	00H, 's', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H, '(', 00H
	DB	'%', 00H, 'h', 00H, 's', 00H, ')', 00H, '!', 00H, 00H, 00H
CONST	ENDS
PUBLIC	??0ISteamUser@@QAE@XZ				; ISteamUser::ISteamUser
PUBLIC	?_Hash_seq@std@@YAIPBEI@Z			; std::_Hash_seq
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ ; std::_Iterator_base0::_Getcont
PUBLIC	?_Allocate@std@@YAPAXII_N@Z			; std::_Allocate
PUBLIC	?_Deallocate@std@@YAXPAXII@Z			; std::_Deallocate
PUBLIC	??0?$tuple@$$V@std@@QAE@XZ			; std::tuple<>::tuple<>
PUBLIC	??0?$tuple@$$V@std@@QAE@ABV01@@Z		; std::tuple<>::tuple<>
PUBLIC	??0?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@QAE@U?$hash@PAVISteamUser@@@1@U?$equal_to@PAVISteamUser@@@1@@Z ; std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >
PUBLIC	??R?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@QBEIABQAVISteamUser@@@Z ; std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >::operator()
PUBLIC	??R?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@QBE_NABQAVISteamUser@@0@Z ; std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >::operator()
PUBLIC	?_Gethash@?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@QBEABU?$hash@PAVISteamUser@@@2@XZ ; std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >::_Gethash
PUBLIC	?_Getkeyeq@?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@QBEABU?$equal_to@PAVISteamUser@@@2@XZ ; std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >::_Getkeyeq
PUBLIC	?_Get_max_bucket_size@?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@QAEAAMXZ ; std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >::_Get_max_bucket_size
PUBLIC	?_Get_max_bucket_size@?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@QBEABMXZ ; std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >::_Get_max_bucket_size
PUBLIC	??R?$equal_to@PAVISteamUser@@@std@@QBE_NABQAVISteamUser@@0@Z ; std::equal_to<ISteamUser *>::operator()
PUBLIC	??R?$_Bitwise_hash@PAVISteamUser@@@std@@QBEIABQAVISteamUser@@@Z ; std::_Bitwise_hash<ISteamUser *>::operator()
PUBLIC	?_Get_first@?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@std@@QBEABU?$equal_to@PAVISteamUser@@@2@XZ ; std::_Compressed_pair<std::equal_to<ISteamUser *>,float,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@std@@QAEAAMXZ ; std::_Compressed_pair<std::equal_to<ISteamUser *>,float,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@std@@QBEABMXZ ; std::_Compressed_pair<std::equal_to<ISteamUser *>,float,1>::_Get_second
PUBLIC	?_Get_first@?$_Compressed_pair@U?$hash@PAVISteamUser@@@std@@V?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@2@$00@std@@QBEABU?$hash@PAVISteamUser@@@2@XZ ; std::_Compressed_pair<std::hash<ISteamUser *>,std::_Compressed_pair<std::equal_to<ISteamUser *>,float,1>,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$hash@PAVISteamUser@@@std@@V?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@2@XZ ; std::_Compressed_pair<std::hash<ISteamUser *>,std::_Compressed_pair<std::equal_to<ISteamUser *>,float,1>,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$hash@PAVISteamUser@@@std@@V?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@2@XZ ; std::_Compressed_pair<std::hash<ISteamUser *>,std::_Compressed_pair<std::equal_to<ISteamUser *>,float,1>,1>::_Get_second
PUBLIC	??0?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@QAE@ABV?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@1@@Z ; std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0>::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0>
PUBLIC	??0?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >
PUBLIC	?deallocate@?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@QAEXPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@I@Z ; std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> >::deallocate
PUBLIC	?allocate@?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@I@Z ; std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> >::allocate
PUBLIC	?max_size@?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@QBEIXZ ; std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@2@@Z ; std::allocator_traits<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::max_size
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::max_size
PUBLIC	?_Nextnode@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@PAU32@@Z ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Nextnode
PUBLIC	?_Prevnode@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@PAU32@@Z ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Prevnode
PUBLIC	?_Myval@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@SAAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@2@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@@Z ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Myval
PUBLIC	??1?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAE@XZ ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::~_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >
PUBLIC	?_Buyheadnode@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@XZ ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Buyheadnode
PUBLIC	?_Freeheadnode@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEXPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@@Z ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Freeheadnode
PUBLIC	?_Buynode0@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Buynode0
PUBLIC	?_Getal@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Getal
PUBLIC	?_Getal@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@2@XZ ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Getal
PUBLIC	?_Get_data@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEAAV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@XZ ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Get_data
PUBLIC	?_Get_data@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QBEABV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@XZ ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Get_data
PUBLIC	?_Myhead@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEAAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@XZ ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Myhead
PUBLIC	?_Myhead@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QBEABQAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@XZ ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Myhead
PUBLIC	?_Mysize@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEAAIXZ ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Mysize
PUBLIC	?_Mysize@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QBEABIXZ ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Mysize
PUBLIC	??0?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@QAE@XZ ; std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >
PUBLIC	?_Nextnode@?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Nextnode
PUBLIC	?_Prevnode@?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@PAU32@@Z ; std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Prevnode
PUBLIC	?_Myval@?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@SAAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@2@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@@Z ; std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Myval
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >,std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >,std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@$00@std@@QAEAAV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >,std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@$00@std@@QBEABV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >,std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,1>::_Get_second
PUBLIC	?_Freenode@?$_List_buy@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEXPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@@Z ; std::_List_buy<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Freenode
PUBLIC	??1?$_List_buy@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE@XZ ; std::_List_buy<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::~_List_buy<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >
PUBLIC	??0?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >
PUBLIC	??1?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE@XZ ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::~list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >
PUBLIC	?begin@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::begin
PUBLIC	?end@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::end
PUBLIC	?end@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::end
PUBLIC	?_Unchecked_begin@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Unchecked_end
PUBLIC	?_Unchecked_end@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Unchecked_end
PUBLIC	?_Make_iter@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@Z ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Make_iter
PUBLIC	?_Make_iter@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Make_iter
PUBLIC	?size@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QBEIXZ ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::size
PUBLIC	?max_size@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QBEIXZ ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::max_size
PUBLIC	?front@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@2@XZ ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::front
PUBLIC	?_Unlinknode@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@Z ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Unlinknode
PUBLIC	?erase@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@Z ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::erase
PUBLIC	?clear@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEXXZ ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::clear
PUBLIC	?_Unchecked_splice@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@00@Z ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Unchecked_splice
PUBLIC	?_Tidy@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEXXZ ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Tidy
PUBLIC	?_Incsize@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEXI@Z ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Incsize
PUBLIC	??0?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@1@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >
PUBLIC	??1?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::~_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >
PUBLIC	?end@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::end
PUBLIC	?end@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::end
PUBLIC	?_Unchecked_begin@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Unchecked_end
PUBLIC	?_Unchecked_end@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Unchecked_end
PUBLIC	?_Make_iter@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Make_iter
PUBLIC	?_Make_iter@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Make_iter
PUBLIC	?size@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBEIXZ ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::size
PUBLIC	?bucket_count@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBEIXZ ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::bucket_count
PUBLIC	?load_factor@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBEMXZ ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::load_factor
PUBLIC	?max_load_factor@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBEMXZ ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::max_load_factor
PUBLIC	?erase@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::erase
PUBLIC	?find@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@ABQAVISteamUser@@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::find
PUBLIC	?count@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBEIABQAVISteamUser@@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::count
PUBLIC	?lower_bound@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@ABQAVISteamUser@@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::lower_bound
PUBLIC	?equal_range@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@2@ABQAVISteamUser@@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::equal_range
PUBLIC	?_Destroy_if_not_nil@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Destroy_if_not_nil
PUBLIC	?_Vec_lo@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEAAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Vec_lo
PUBLIC	?_Vec_lo@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IBEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Vec_lo
PUBLIC	?_Vec_hi@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEAAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Vec_hi
PUBLIC	?_Vec_hi@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IBEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Vec_hi
PUBLIC	?_Begin@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Begin
PUBLIC	?_Begin@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Begin
PUBLIC	?_End@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_End
PUBLIC	?_End@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@I@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_End
PUBLIC	?_Erase_bucket@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Erase_bucket
PUBLIC	?_Insert_bucket@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@0I@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Insert_bucket
PUBLIC	?_Hashval@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IBEIABQAVISteamUser@@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Hashval
PUBLIC	?_Init@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEXI@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Init
PUBLIC	?_Check_size@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Check_size
PUBLIC	?_Reinsert@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Reinsert
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEAAMXZ ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Max_bucket_size
PUBLIC	?_Max_bucket_size@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IBEABMXZ ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Max_bucket_size
PUBLIC	??0?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
PUBLIC	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::deallocate
PUBLIC	?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::allocate
PUBLIC	?max_size@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@QBEIXZ ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@2@@Z ; std::allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABU01@@Z ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >::max_size
PUBLIC	?max_size@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAIABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@Z ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::max_size
PUBLIC	?allocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::max_size
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Orphan_all
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Getal
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBEABU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Getal
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Get_data
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEAAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBEABQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEAAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBEABQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Mylast
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEAAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Myend
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBEABQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Myend
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >,1>::_Get_second
PUBLIC	??0?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >
PUBLIC	??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::~vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >
PUBLIC	?assign@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEXIABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::assign
PUBLIC	?_Reallocate_exactly@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXI@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Reallocate_exactly
PUBLIC	?reserve@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEXI@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::reserve
PUBLIC	?size@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::size
PUBLIC	?max_size@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::max_size
PUBLIC	?capacity@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::capacity
PUBLIC	??A?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEAAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@I@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::operator[]
PUBLIC	??A?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@I@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::operator[]
PUBLIC	?_Ufill@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@PAV32@IABV32@@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Ufill
PUBLIC	?_Umove_if_noexcept1@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@00U?$integral_constant@_N$00@2@@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Umove_if_noexcept1
PUBLIC	?_Umove_if_noexcept@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@00@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Umove_if_noexcept
PUBLIC	?_Destroy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@0@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@ABEII@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Calculate_growth
PUBLIC	?_Buy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAE_NI@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Buy
PUBLIC	?_Change_array@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@II@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Change_array
PUBLIC	?_Tidy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXXZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Tidy
PUBLIC	?_Xlength@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Xlength
PUBLIC	??0?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@QAE@XZ ; std::unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >
PUBLIC	??A?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@QAEAAPAVIWrapSteamUser@@ABQAVISteamUser@@@Z ; std::unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::operator[]
PUBLIC	??1?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@QAE@XZ ; std::unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::~unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >
PUBLIC	??0IWrapSteamUser@@QAE@PAVISteamUser@@@Z	; IWrapSteamUser::IWrapSteamUser
PUBLIC	?GetHSteamUser@IWrapSteamUser@@UAEHXZ		; IWrapSteamUser::GetHSteamUser
PUBLIC	?BLoggedOn@IWrapSteamUser@@UAE_NXZ		; IWrapSteamUser::BLoggedOn
PUBLIC	?GetSteamID@IWrapSteamUser@@UAE?AVCSteamID@@XZ	; IWrapSteamUser::GetSteamID
PUBLIC	?InitiateGameConnection@IWrapSteamUser@@UAEHPAXHVCSteamID@@IG_N@Z ; IWrapSteamUser::InitiateGameConnection
PUBLIC	?TerminateGameConnection@IWrapSteamUser@@UAEXIG@Z ; IWrapSteamUser::TerminateGameConnection
PUBLIC	?TrackAppUsageEvent@IWrapSteamUser@@UAEXVCGameID@@HPBD@Z ; IWrapSteamUser::TrackAppUsageEvent
PUBLIC	?GetUserDataFolder@IWrapSteamUser@@UAE_NPADH@Z	; IWrapSteamUser::GetUserDataFolder
PUBLIC	?StartVoiceRecording@IWrapSteamUser@@UAEXXZ	; IWrapSteamUser::StartVoiceRecording
PUBLIC	?StopVoiceRecording@IWrapSteamUser@@UAEXXZ	; IWrapSteamUser::StopVoiceRecording
PUBLIC	?GetAvailableVoice@IWrapSteamUser@@UAE?AW4EVoiceResult@@PAI0I@Z ; IWrapSteamUser::GetAvailableVoice
PUBLIC	?GetVoice@IWrapSteamUser@@UAE?AW4EVoiceResult@@_NPAXIPAI01I2I@Z ; IWrapSteamUser::GetVoice
PUBLIC	?DecompressVoice@IWrapSteamUser@@UAE?AW4EVoiceResult@@PBXIPAXIPAII@Z ; IWrapSteamUser::DecompressVoice
PUBLIC	?GetVoiceOptimalSampleRate@IWrapSteamUser@@UAEIXZ ; IWrapSteamUser::GetVoiceOptimalSampleRate
PUBLIC	?GetAuthSessionTicket@IWrapSteamUser@@UAEIPAXHPAI@Z ; IWrapSteamUser::GetAuthSessionTicket
PUBLIC	?BeginAuthSession@IWrapSteamUser@@UAE?AW4EBeginAuthSessionResult@@PBXHVCSteamID@@@Z ; IWrapSteamUser::BeginAuthSession
PUBLIC	?EndAuthSession@IWrapSteamUser@@UAEXVCSteamID@@@Z ; IWrapSteamUser::EndAuthSession
PUBLIC	?CancelAuthTicket@IWrapSteamUser@@UAEXI@Z	; IWrapSteamUser::CancelAuthTicket
PUBLIC	?UserHasLicenseForApp@IWrapSteamUser@@UAE?AW4EUserHasLicenseForAppResult@@VCSteamID@@I@Z ; IWrapSteamUser::UserHasLicenseForApp
PUBLIC	?BIsBehindNAT@IWrapSteamUser@@UAE_NXZ		; IWrapSteamUser::BIsBehindNAT
PUBLIC	?AdvertiseGame@IWrapSteamUser@@UAEXVCSteamID@@IG@Z ; IWrapSteamUser::AdvertiseGame
PUBLIC	?RequestEncryptedAppTicket@IWrapSteamUser@@UAE_KPAXH@Z ; IWrapSteamUser::RequestEncryptedAppTicket
PUBLIC	?GetEncryptedAppTicket@IWrapSteamUser@@UAE_NPAXHPAI@Z ; IWrapSteamUser::GetEncryptedAppTicket
PUBLIC	?GetGameBadgeLevel@IWrapSteamUser@@UAEHH_N@Z	; IWrapSteamUser::GetGameBadgeLevel
PUBLIC	?GetPlayerSteamLevel@IWrapSteamUser@@UAEHXZ	; IWrapSteamUser::GetPlayerSteamLevel
PUBLIC	?RequestStoreAuthURL@IWrapSteamUser@@UAE_KPBD@Z	; IWrapSteamUser::RequestStoreAuthURL
PUBLIC	?BIsPhoneVerified@IWrapSteamUser@@UAE_NXZ	; IWrapSteamUser::BIsPhoneVerified
PUBLIC	?BIsTwoFactorEnabled@IWrapSteamUser@@UAE_NXZ	; IWrapSteamUser::BIsTwoFactorEnabled
PUBLIC	?BIsPhoneIdentifying@IWrapSteamUser@@UAE_NXZ	; IWrapSteamUser::BIsPhoneIdentifying
PUBLIC	?BIsPhoneRequiringVerification@IWrapSteamUser@@UAE_NXZ ; IWrapSteamUser::BIsPhoneRequiringVerification
PUBLIC	?SteamAPI_ISteamClient_GetISteamUser_Detour@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z ; SteamAPI_ISteamClient_GetISteamUser_Detour
PUBLIC	?SK_SteamWrapper_WrappedClient_GetISteamUser@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z ; SK_SteamWrapper_WrappedClient_GetISteamUser
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>
PUBLIC	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>::operator*
PUBLIC	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>::operator++
PUBLIC	??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>::operator--
PUBLIC	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>::operator==
PUBLIC	??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>::operator!=
PUBLIC	?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>::_Mynode
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >
PUBLIC	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QBEABU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator*
PUBLIC	??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator++
PUBLIC	??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator++
PUBLIC	??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator==
PUBLIC	??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator!=
PUBLIC	??$distance@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YAHV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@0@Z ; std::distance<std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
PUBLIC	??$try_emplace@$$V@?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@ABQAVISteamUser@@@Z ; std::unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::try_emplace<>
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >
PUBLIC	?_Unchecked@?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QBE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Unchecked
PUBLIC	??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QBEAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator*
PUBLIC	??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QBEPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator->
PUBLIC	?pointer_to@?$pointer_traits@PAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@SAPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@2@AAU32@@Z ; std::pointer_traits<std::pair<ISteamUser * const,IWrapSteamUser *> *>::pointer_to
PUBLIC	??$_Kfn@QAVISteamUser@@PAVIWrapSteamUser@@@?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@SAABQAVISteamUser@@ABU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@@Z ; std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0>::_Kfn<ISteamUser * const,IWrapSteamUser *>
PUBLIC	??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V01@X$0A@@?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@std@@QAE@$$QAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@0@Z ; std::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > ><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,void,0>
PUBLIC	??$?0V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V01@X$0A@@?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@std@@QAE@$$QAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@0@Z ; std::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > ><std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,void,0>
PUBLIC	??$?0ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > ><std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > const &>
PUBLIC	??$?0AAU?$hash@PAVISteamUser@@@std@@U_One_then_variadic_args_t@1@AAU?$equal_to@PAVISteamUser@@@1@M@?$_Compressed_pair@U?$hash@PAVISteamUser@@@std@@V?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@AAU?$hash@PAVISteamUser@@@1@$$QAU21@AAU?$equal_to@PAVISteamUser@@@1@$$QAM@Z ; std::_Compressed_pair<std::hash<ISteamUser *>,std::_Compressed_pair<std::equal_to<ISteamUser *>,float,1>,1>::_Compressed_pair<std::hash<ISteamUser *>,std::_Compressed_pair<std::equal_to<ISteamUser *>,float,1>,1><std::hash<ISteamUser *> &,std::_One_then_variadic_args_t,std::equal_to<ISteamUser *> &,float>
PUBLIC	??$addressof@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@YAPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@0@AAU10@@Z ; std::addressof<std::pair<ISteamUser * const,IWrapSteamUser *> >
PUBLIC	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >
PUBLIC	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@1@@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >
PUBLIC	??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QBEAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator*
PUBLIC	??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator++
PUBLIC	??F?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator--
PUBLIC	??$?0ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@@Z ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > ><std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > const &,void>
PUBLIC	??$?0ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@X@?$_List_buy@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z ; std::_List_buy<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_List_buy<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > ><std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > const &,void>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@0AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *>
PUBLIC	??$_Fill_unchecked@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@0ABV10@@Z ; std::_Fill_unchecked<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
PUBLIC	??$addressof@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@0@AAPAU10@@Z ; std::addressof<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> *>
PUBLIC	??$destroy@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::destroy<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> *>
PUBLIC	??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@YAPBV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@0@ABV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > const >
PUBLIC	??$_Uninitialized_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@IU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@PAV10@IABV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z ; std::_Uninitialized_fill_n<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,unsigned int,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >
PUBLIC	??$destroy@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::destroy<std::pair<ISteamUser * const,IWrapSteamUser *> >
PUBLIC	??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@0@AAV10@@Z ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >
PUBLIC	??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@_Alloc_max_size@std@@SAIHABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@@Z ; std::_Alloc_max_size::_Fn<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >
PUBLIC	??$_Uninitialized_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >
PUBLIC	??$_Distance1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YAHV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@0Uinput_iterator_tag@0@@Z ; std::_Distance1<std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
PUBLIC	??$_Try_emplace@ABQAVISteamUser@@$$V@?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@ABQAVISteamUser@@@Z ; std::unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Try_emplace<ISteamUser * const &>
PUBLIC	??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
PUBLIC	??$forward@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
PUBLIC	??$forward@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@YAABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@0@ABV10@@Z ; std::forward<std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > const &>
PUBLIC	??$?0U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > ><std::pair<ISteamUser * const,IWrapSteamUser *> >
PUBLIC	??$forward@AAU?$hash@PAVISteamUser@@@std@@@std@@YAAAU?$hash@PAVISteamUser@@@0@AAU10@@Z ; std::forward<std::hash<ISteamUser *> &>
PUBLIC	??$forward@U_One_then_variadic_args_t@std@@@std@@YA$$QAU_One_then_variadic_args_t@0@AAU10@@Z ; std::forward<std::_One_then_variadic_args_t>
PUBLIC	??$forward@AAU?$equal_to@PAVISteamUser@@@std@@@std@@YAAAU?$equal_to@PAVISteamUser@@@0@AAU10@@Z ; std::forward<std::equal_to<ISteamUser *> &>
PUBLIC	??$forward@M@std@@YA$$QAMAAM@Z			; std::forward<float>
PUBLIC	??$?0AAU?$equal_to@PAVISteamUser@@@std@@M@?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@std@@QAE@U_One_then_variadic_args_t@1@AAU?$equal_to@PAVISteamUser@@@1@$$QAM@Z ; std::_Compressed_pair<std::equal_to<ISteamUser *>,float,1>::_Compressed_pair<std::equal_to<ISteamUser *>,float,1><std::equal_to<ISteamUser *> &,float>
PUBLIC	??$forward@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@0@ABU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > const &>
PUBLIC	??$?0ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >,1>::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >,1><std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > const &>
PUBLIC	??$?0ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@X@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > ><std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > const &,void>
PUBLIC	??$_Destroy_range1@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@0AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *>
PUBLIC	??$_Fill_memset_is_safe@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@std@@YA?AU?$integral_constant@_N$0A@@0@ABQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@ABV20@@Z ; std::_Fill_memset_is_safe<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
PUBLIC	??$_Fill_unchecked1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@0ABV10@U?$integral_constant@_N$0A@@0@@Z ; std::_Fill_unchecked1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
PUBLIC	??$destroy@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@1@PAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@@Z ; std::allocator_traits<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::destroy<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> *>
PUBLIC	??$_Unfancy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@PAV10@@Z ; std::_Unfancy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
PUBLIC	??$_Uninit_alloc_fill_n1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@IU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@PAV10@IABV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninit_alloc_fill_n1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,unsigned int,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >
PUBLIC	??$destroy@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@1@PAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@@Z ; std::allocator_traits<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::destroy<std::pair<ISteamUser * const,IWrapSteamUser *> >
PUBLIC	??$_Unchecked@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@PAV10@@Z ; std::_Unchecked<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *>
PUBLIC	??$_Ptr_move_cat@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@std@@YA?AU_Trivially_copyable_ptr_iterator_tag@0@ABQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@0@Z ; std::_Ptr_move_cat<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
PUBLIC	??$move@AAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@AAV10@@Z ; std::move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > &>
PUBLIC	??$_Uninitialized_move_al_unchecked@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >
PUBLIC	??$?0U?$integral_constant@_N$0A@@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$0A@@1@@Z ; std::_Any_tag::_Any_tag<std::integral_constant<bool,0> >
PUBLIC	??$_Rechecked@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@PAV12@@std@@YAAAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@AAPAV10@PAV10@@Z ; std::_Rechecked<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *>
PUBLIC	??$forward@ABQAVISteamUser@@@std@@YAABQAVISteamUser@@ABQAV1@@Z ; std::forward<ISteamUser * const &>
PUBLIC	??$forward_as_tuple@ABQAVISteamUser@@@std@@YA?AV?$tuple@ABQAVISteamUser@@@0@ABQAVISteamUser@@@Z ; std::forward_as_tuple<ISteamUser * const &>
PUBLIC	??0?$tuple@ABQAVISteamUser@@@std@@QAE@$$QAV01@@Z ; std::tuple<ISteamUser * const &>::tuple<ISteamUser * const &>
PUBLIC	??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ ; std::forward_as_tuple<>
PUBLIC	??$emplace@ABUpiecewise_construct_t@std@@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::emplace<std::piecewise_construct_t const &,std::tuple<ISteamUser * const &>,std::tuple<> >
PUBLIC	??$?0AAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > &,bool,void,0>
PUBLIC	??$?0ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > ><std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > const &>
PUBLIC	??$?0ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >,std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >,std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,1><std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > const &>
PUBLIC	??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
PUBLIC	??$destroy@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@@Z ; std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> >::destroy<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> *>
PUBLIC	??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@ABV12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@ABV21@@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > const &>
PUBLIC	??$destroy@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@QAEXPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@@Z ; std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> >::destroy<std::pair<ISteamUser * const,IWrapSteamUser *> >
PUBLIC	??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@$$QAV21@@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
PUBLIC	??$construct@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@AAPAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::construct<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> *,std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> * &>
PUBLIC	??$?0ABQAVISteamUser@@$0A@@?$tuple@ABQAVISteamUser@@@std@@QAE@ABQAVISteamUser@@@Z ; std::tuple<ISteamUser * const &>::tuple<ISteamUser * const &><ISteamUser * const &,0>
PUBLIC	??$forward@ABUpiecewise_construct_t@std@@@std@@YAABUpiecewise_construct_t@0@ABU10@@Z ; std::forward<std::piecewise_construct_t const &>
PUBLIC	??$forward@V?$tuple@ABQAVISteamUser@@@std@@@std@@YA$$QAV?$tuple@ABQAVISteamUser@@@0@AAV10@@Z ; std::forward<std::tuple<ISteamUser * const &> >
PUBLIC	??$forward@V?$tuple@$$V@std@@@std@@YA$$QAV?$tuple@$$V@0@AAV10@@Z ; std::forward<std::tuple<> >
PUBLIC	??$emplace_front@ABUpiecewise_construct_t@std@@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEXABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::emplace_front<std::piecewise_construct_t const &,std::tuple<ISteamUser * const &>,std::tuple<> >
PUBLIC	??$_Insert@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Insert<std::pair<ISteamUser * const,IWrapSteamUser *> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
PUBLIC	??$forward@AAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YAAAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > &>
PUBLIC	??$forward@_N@std@@YA$$QA_NAA_N@Z		; std::forward<bool>
PUBLIC	??$?0ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > ><std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > const &>
PUBLIC	??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@@Z ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
PUBLIC	??$forward@ABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YAABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@ABV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > const &>
PUBLIC	??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@ABV12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@ABV31@@Z ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > const &>
PUBLIC	??$forward@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
PUBLIC	??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@$$QAV31@@Z ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
PUBLIC	??$forward@AAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@YAAAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@0@AAPAU10@@Z ; std::forward<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> * &>
PUBLIC	??$construct@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@1@PAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@AAPAU31@@Z ; std::allocator_traits<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::construct<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> *,std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> * &>
PUBLIC	??$?0U_Exact_args_t@std@@ABQAVISteamUser@@$$V$0A@@?$tuple@ABQAVISteamUser@@@std@@QAE@U_Exact_args_t@1@ABQAVISteamUser@@@Z ; std::tuple<ISteamUser * const &>::tuple<ISteamUser * const &><std::_Exact_args_t,ISteamUser * const &,0>
PUBLIC	??$_Insert@ABUpiecewise_construct_t@std@@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Insert<std::piecewise_construct_t const &,std::tuple<ISteamUser * const &>,std::tuple<> >
PUBLIC	??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,bool,void,0>
PUBLIC	??$forward@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@YAAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@0@AAU10@@Z ; std::forward<std::pair<ISteamUser * const,IWrapSteamUser *> &>
PUBLIC	??$_Buynode_if_nil@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@V21@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Buynode_if_nil<std::pair<ISteamUser * const,IWrapSteamUser *> &>
PUBLIC	??$?0U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z ; std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> >::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> ><std::pair<ISteamUser * const,IWrapSteamUser *> >
PUBLIC	??$_Destroy1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@U?$integral_constant@_N$00@1@@Z ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Destroy1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
PUBLIC	??$_Construct1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@ABV12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXU?$integral_constant@_N$00@1@AAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@ABV41@@Z ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Construct1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > const &>
PUBLIC	??$_Construct1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXU?$integral_constant@_N$00@1@AAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@$$QAV41@@Z ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Construct1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
PUBLIC	??$construct@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@AAPAU21@@Z ; std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> >::construct<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> *,std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> * &>
PUBLIC	??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z ; std::tuple<>::tuple<><std::_Exact_args_t,0>
PUBLIC	??$?0ABQAVISteamUser@@@?$_Tuple_val@ABQAVISteamUser@@@std@@QAE@ABQAVISteamUser@@@Z ; std::_Tuple_val<ISteamUser * const &>::_Tuple_val<ISteamUser * const &><ISteamUser * const &>
PUBLIC	??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$_List_buy@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@PAU21@0ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_List_buy<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Buynode<std::piecewise_construct_t const &,std::tuple<ISteamUser * const &>,std::tuple<> >
PUBLIC	??$construct@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::construct<std::pair<ISteamUser * const,IWrapSteamUser *>,std::piecewise_construct_t const &,std::tuple<ISteamUser * const &>,std::tuple<> >
PUBLIC	??$construct@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@1@PAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z ; std::allocator_traits<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::construct<std::pair<ISteamUser * const,IWrapSteamUser *>,std::piecewise_construct_t const &,std::tuple<ISteamUser * const &>,std::tuple<> >
PUBLIC	??$construct@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@QAEXPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z ; std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> >::construct<std::pair<ISteamUser * const,IWrapSteamUser *>,std::piecewise_construct_t const &,std::tuple<ISteamUser * const &>,std::tuple<> >
PUBLIC	??$?0ABQAVISteamUser@@$$Z$$V@?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@QAE@Upiecewise_construct_t@1@V?$tuple@ABQAVISteamUser@@@1@V?$tuple@$$V@1@@Z ; std::pair<ISteamUser * const,IWrapSteamUser *>::pair<ISteamUser * const,IWrapSteamUser *><ISteamUser * const &>
PUBLIC	??$?0V?$tuple@ABQAVISteamUser@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@QAE@AAV?$tuple@ABQAVISteamUser@@@1@AAV?$tuple@$$V@1@U?$integer_sequence@I$0A@@1@U?$integer_sequence@I$S@1@@Z ; std::pair<ISteamUser * const,IWrapSteamUser *>::pair<ISteamUser * const,IWrapSteamUser *><std::tuple<ISteamUser * const &>,std::tuple<>,0>
PUBLIC	??$move@AAV?$tuple@ABQAVISteamUser@@@std@@@std@@YA$$QAV?$tuple@ABQAVISteamUser@@@0@AAV10@@Z ; std::move<std::tuple<ISteamUser * const &> &>
PUBLIC	??$get@$0A@ABQAVISteamUser@@@std@@YAABQAVISteamUser@@$$QAV?$tuple@ABQAVISteamUser@@@0@@Z ; std::get<0,ISteamUser * const &>
PUBLIC	??_7ISteamUser@@6B@				; ISteamUser::`vftable'
PUBLIC	?SK_SteamWrapper_remap_user@@3V?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@A ; SK_SteamWrapper_remap_user
PUBLIC	??_7IWrapSteamUser@@6B@				; IWrapSteamUser::`vftable'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R4ISteamUser@@6B@				; ISteamUser::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVISteamUser@@@8				; ISteamUser `RTTI Type Descriptor'
PUBLIC	??_R3ISteamUser@@8				; ISteamUser::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ISteamUser@@8				; ISteamUser::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ISteamUser@@8			; ISteamUser::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4IWrapSteamUser@@6B@			; IWrapSteamUser::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVIWrapSteamUser@@@8			; IWrapSteamUser `RTTI Type Descriptor'
PUBLIC	??_R3IWrapSteamUser@@8				; IWrapSteamUser::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IWrapSteamUser@@8				; IWrapSteamUser::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IWrapSteamUser@@8			; IWrapSteamUser::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__imp___invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp__lstrcmpA@8:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	?Log@iSK_Logger@@UAAXQB_WZZ:PROC		; iSK_Logger::Log
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?steam_log@@3UiSK_Logger@@A:BYTE		; steam_log
EXTRN	?config@@3Usk_config_t@@A:BYTE			; config
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?SK_SteamWrapper_remap_user@@3V?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@A DB 020H DUP (?) ; SK_SteamWrapper_remap_user
_BSS	ENDS
CRT$XCU	SEGMENT
?SK_SteamWrapper_remap_user$initializer$@@3P6AXXZA DD FLAT:??__ESK_SteamWrapper_remap_user@@YAXXZ ; SK_SteamWrapper_remap_user$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@IWrapSteamUser@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IWrapSteamUser@@8 DD FLAT:??_R0?AVIWrapSteamUser@@@8 ; IWrapSteamUser::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IWrapSteamUser@@8
rdata$r	ENDS
;	COMDAT ??_R2IWrapSteamUser@@8
rdata$r	SEGMENT
??_R2IWrapSteamUser@@8 DD FLAT:??_R1A@?0A@EA@IWrapSteamUser@@8 ; IWrapSteamUser::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ISteamUser@@8
rdata$r	ENDS
;	COMDAT ??_R3IWrapSteamUser@@8
rdata$r	SEGMENT
??_R3IWrapSteamUser@@8 DD 00H				; IWrapSteamUser::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2IWrapSteamUser@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVIWrapSteamUser@@@8
data$r	SEGMENT
??_R0?AVIWrapSteamUser@@@8 DD FLAT:??_7type_info@@6B@	; IWrapSteamUser `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIWrapSteamUser@@', 00H
data$r	ENDS
;	COMDAT ??_R4IWrapSteamUser@@6B@
rdata$r	SEGMENT
??_R4IWrapSteamUser@@6B@ DD 00H				; IWrapSteamUser::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVIWrapSteamUser@@@8
	DD	FLAT:??_R3IWrapSteamUser@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ISteamUser@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ISteamUser@@8 DD FLAT:??_R0?AVISteamUser@@@8 ; ISteamUser::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ISteamUser@@8
rdata$r	ENDS
;	COMDAT ??_R2ISteamUser@@8
rdata$r	SEGMENT
??_R2ISteamUser@@8 DD FLAT:??_R1A@?0A@EA@ISteamUser@@8	; ISteamUser::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3ISteamUser@@8
rdata$r	SEGMENT
??_R3ISteamUser@@8 DD 00H				; ISteamUser::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ISteamUser@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVISteamUser@@@8
data$r	SEGMENT
??_R0?AVISteamUser@@@8 DD FLAT:??_7type_info@@6B@	; ISteamUser `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVISteamUser@@', 00H
data$r	ENDS
;	COMDAT ??_R4ISteamUser@@6B@
rdata$r	SEGMENT
??_R4ISteamUser@@6B@ DD 00H				; ISteamUser::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVISteamUser@@@8
	DD	FLAT:??_R3ISteamUser@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ DB 'list<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?first@?BD@??SK_SteamWrapper_WrappedClient_GetISteamUser@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z@4_NA
_DATA	SEGMENT
?first@?BD@??SK_SteamWrapper_WrappedClient_GetISteamUser@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z@4_NA DB 01H ; `SK_SteamWrapper_WrappedClient_GetISteamUser'::`19'::first
_DATA	ENDS
;	COMDAT ?first@?2??SK_SteamWrapper_WrappedClient_GetISteamUser@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z@4_NA
_DATA	SEGMENT
?first@?2??SK_SteamWrapper_WrappedClient_GetISteamUser@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z@4_NA DB 01H ; `SK_SteamWrapper_WrappedClient_GetISteamUser'::`3'::first
_DATA	ENDS
;	COMDAT ?first@?BD@??SteamAPI_ISteamClient_GetISteamUser_Detour@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z@4_NA
_DATA	SEGMENT
?first@?BD@??SteamAPI_ISteamClient_GetISteamUser_Detour@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z@4_NA DB 01H ; `SteamAPI_ISteamClient_GetISteamUser_Detour'::`19'::first
_DATA	ENDS
;	COMDAT ?first@?2??SteamAPI_ISteamClient_GetISteamUser_Detour@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z@4_NA
_DATA	SEGMENT
?first@?2??SteamAPI_ISteamClient_GetISteamUser_Detour@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z@4_NA DB 01H ; `SteamAPI_ISteamClient_GetISteamUser_Detour'::`3'::first
_DATA	ENDS
;	COMDAT ??_7IWrapSteamUser@@6B@
CONST	SEGMENT
??_7IWrapSteamUser@@6B@ DD FLAT:??_R4IWrapSteamUser@@6B@ ; IWrapSteamUser::`vftable'
	DD	FLAT:?GetHSteamUser@IWrapSteamUser@@UAEHXZ
	DD	FLAT:?BLoggedOn@IWrapSteamUser@@UAE_NXZ
	DD	FLAT:?GetSteamID@IWrapSteamUser@@UAE?AVCSteamID@@XZ
	DD	FLAT:?InitiateGameConnection@IWrapSteamUser@@UAEHPAXHVCSteamID@@IG_N@Z
	DD	FLAT:?TerminateGameConnection@IWrapSteamUser@@UAEXIG@Z
	DD	FLAT:?TrackAppUsageEvent@IWrapSteamUser@@UAEXVCGameID@@HPBD@Z
	DD	FLAT:?GetUserDataFolder@IWrapSteamUser@@UAE_NPADH@Z
	DD	FLAT:?StartVoiceRecording@IWrapSteamUser@@UAEXXZ
	DD	FLAT:?StopVoiceRecording@IWrapSteamUser@@UAEXXZ
	DD	FLAT:?GetAvailableVoice@IWrapSteamUser@@UAE?AW4EVoiceResult@@PAI0I@Z
	DD	FLAT:?GetVoice@IWrapSteamUser@@UAE?AW4EVoiceResult@@_NPAXIPAI01I2I@Z
	DD	FLAT:?DecompressVoice@IWrapSteamUser@@UAE?AW4EVoiceResult@@PBXIPAXIPAII@Z
	DD	FLAT:?GetVoiceOptimalSampleRate@IWrapSteamUser@@UAEIXZ
	DD	FLAT:?GetAuthSessionTicket@IWrapSteamUser@@UAEIPAXHPAI@Z
	DD	FLAT:?BeginAuthSession@IWrapSteamUser@@UAE?AW4EBeginAuthSessionResult@@PBXHVCSteamID@@@Z
	DD	FLAT:?EndAuthSession@IWrapSteamUser@@UAEXVCSteamID@@@Z
	DD	FLAT:?CancelAuthTicket@IWrapSteamUser@@UAEXI@Z
	DD	FLAT:?UserHasLicenseForApp@IWrapSteamUser@@UAE?AW4EUserHasLicenseForAppResult@@VCSteamID@@I@Z
	DD	FLAT:?BIsBehindNAT@IWrapSteamUser@@UAE_NXZ
	DD	FLAT:?AdvertiseGame@IWrapSteamUser@@UAEXVCSteamID@@IG@Z
	DD	FLAT:?RequestEncryptedAppTicket@IWrapSteamUser@@UAE_KPAXH@Z
	DD	FLAT:?GetEncryptedAppTicket@IWrapSteamUser@@UAE_NPAXHPAI@Z
	DD	FLAT:?GetGameBadgeLevel@IWrapSteamUser@@UAEHH_N@Z
	DD	FLAT:?GetPlayerSteamLevel@IWrapSteamUser@@UAEHXZ
	DD	FLAT:?RequestStoreAuthURL@IWrapSteamUser@@UAE_KPBD@Z
	DD	FLAT:?BIsPhoneVerified@IWrapSteamUser@@UAE_NXZ
	DD	FLAT:?BIsTwoFactorEnabled@IWrapSteamUser@@UAE_NXZ
	DD	FLAT:?BIsPhoneIdentifying@IWrapSteamUser@@UAE_NXZ
	DD	FLAT:?BIsPhoneRequiringVerification@IWrapSteamUser@@UAE_NXZ
CONST	ENDS
;	COMDAT ??_7ISteamUser@@6B@
CONST	SEGMENT
??_7ISteamUser@@6B@ DD FLAT:??_R4ISteamUser@@6B@	; ISteamUser::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Insert@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@@Z$91 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@@Z$2
__tryblocktable$??$_Insert@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@@Z$91
__unwindtable$??$_Insert@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Insert@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$_Insert@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate_exactly@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXI@Z$49 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate_exactly@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXI@Z$0
__unwindtable$?_Reallocate_exactly@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate_exactly@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate_exactly@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXI@Z$49
__ehfuncinfo$?_Reallocate_exactly@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate_exactly@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate_exactly@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@1@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@1@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@1@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z$1
__ehfuncinfo$??0?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@1@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@1@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple
;	COMDAT ??$get@$0A@ABQAVISteamUser@@@std@@YAABQAVISteamUser@@$$QAV?$tuple@ABQAVISteamUser@@@0@@Z
_TEXT	SEGMENT
__Tuple$ = 8						; size = 4
??$get@$0A@ABQAVISteamUser@@@std@@YAABQAVISteamUser@@$$QAV?$tuple@ABQAVISteamUser@@@0@@Z PROC ; std::get<0,ISteamUser * const &>, COMDAT

; 810  : 	{	// get rvalue reference to _Index element of tuple

	npad	2
	push	ebp
	mov	ebp, esp

; 811  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 812  : 		_Ttype;
; 813  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::type&&
; 814  : 		_RRtype;
; 815  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));

	mov	eax, DWORD PTR __Tuple$[ebp]
	mov	eax, DWORD PTR [eax]

; 816  : 	}

	pop	ebp
	ret	0
??$get@$0A@ABQAVISteamUser@@@std@@YAABQAVISteamUser@@$$QAV?$tuple@ABQAVISteamUser@@@0@@Z ENDP ; std::get<0,ISteamUser * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$move@AAV?$tuple@ABQAVISteamUser@@@std@@@std@@YA$$QAV?$tuple@ABQAVISteamUser@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$tuple@ABQAVISteamUser@@@std@@@std@@YA$$QAV?$tuple@ABQAVISteamUser@@@0@AAV10@@Z PROC ; std::move<std::tuple<ISteamUser * const &> &>, COMDAT

; 1350 : 	{	// forward _Arg as movable

	npad	2
	push	ebp
	mov	ebp, esp

; 1351 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1352 : 	}

	pop	ebp
	ret	0
??$move@AAV?$tuple@ABQAVISteamUser@@@std@@@std@@YA$$QAV?$tuple@ABQAVISteamUser@@@0@AAV10@@Z ENDP ; std::move<std::tuple<ISteamUser * const &> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple
;	COMDAT ??$?0V?$tuple@ABQAVISteamUser@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@QAE@AAV?$tuple@ABQAVISteamUser@@@1@AAV?$tuple@$$V@1@U?$integer_sequence@I$0A@@1@U?$integer_sequence@I$S@1@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$?0V?$tuple@ABQAVISteamUser@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@QAE@AAV?$tuple@ABQAVISteamUser@@@1@AAV?$tuple@$$V@1@U?$integer_sequence@I$0A@@1@U?$integer_sequence@I$S@1@@Z PROC ; std::pair<ISteamUser * const,IWrapSteamUser *>::pair<ISteamUser * const,IWrapSteamUser *><std::tuple<ISteamUser * const &>,std::tuple<>,0>, COMDAT
; _this$ = ecx

; 1140 : 		{	// construct from pair of tuples

	npad	2
	push	ebp
	mov	ebp, esp

; 815  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));

	mov	eax, DWORD PTR __Val1$[ebp]
	mov	eax, DWORD PTR [eax]

; 816  : 	}
; 817  : 
; 818  : template<size_t _Index,
; 819  : 	class... _Types> inline
; 820  : 	constexpr const typename tuple_element<_Index, tuple<_Types...> >::type&&
; 821  : 		get(const tuple<_Types...>&& _Tuple) _NOEXCEPT
; 822  : 	{	// get const rvalue reference to _Index element of tuple
; 823  : 	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
; 824  : 		_Ttype;
; 825  : 	typedef const typename tuple_element<_Index, tuple<_Types...> >::type&&
; 826  : 		_RRtype;
; 827  : 	return (_STD forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));
; 828  : 	}
; 829  : 
; 830  : 	// TEMPLATE FUNCTION get (by type)
; 831  : template<class _Ty,
; 832  : 	class... _Types> inline
; 833  : 	constexpr _Ty& get(tuple<_Types...>& _Tuple) _NOEXCEPT
; 834  : 	{	// get reference to _Ty element of tuple
; 835  : 	typedef typename _Tuple_element<_Ty, tuple<_Types...> >::_Ttype _Ttype;
; 836  : 	return (((_Ttype&)_Tuple)._Myfirst._Val);
; 837  : 	}
; 838  : 
; 839  : template<class _Ty,
; 840  : 	class... _Types> inline
; 841  : 	constexpr const _Ty& get(const tuple<_Types...>& _Tuple) _NOEXCEPT
; 842  : 	{	// get const reference to _Ty element of tuple
; 843  : 	typedef typename _Tuple_element<_Ty, tuple<_Types...> >::_Ttype _Ttype;
; 844  : 	return (((_Ttype&)_Tuple)._Myfirst._Val);
; 845  : 	}
; 846  : 
; 847  : template<class _Ty,
; 848  : 	class... _Types> inline
; 849  : 	constexpr _Ty&& get(tuple<_Types...>&& _Tuple) _NOEXCEPT
; 850  : 	{	// get rvalue reference to _Ty element of tuple
; 851  : 	typedef typename _Tuple_element<_Ty, tuple<_Types...> >::_Ttype _Ttype;
; 852  : 	return (_STD forward<_Ty&&>(((_Ttype&)_Tuple)._Myfirst._Val));
; 853  : 	}
; 854  : 
; 855  : template<class _Ty,
; 856  : 	class... _Types> inline
; 857  : 	constexpr const _Ty&& get(const tuple<_Types...>&& _Tuple) _NOEXCEPT
; 858  : 	{	// get const rvalue reference to _Ty element of tuple
; 859  : 	typedef typename _Tuple_element<_Ty, tuple<_Types...> >::_Ttype _Ttype;
; 860  : 	return (_STD forward<const _Ty&&>(((_Ttype&)_Tuple)._Myfirst._Val));
; 861  : 	}
; 862  : 
; 863  : 	// CONSTRUCTOR TEMPLATES FOR tuple
; 864  : template<class _This,
; 865  : 	class... _Rest>
; 866  : 	template<class _Tag,
; 867  : 		class _Tpl,
; 868  : 		size_t... _Indices,
; 869  : 		enable_if_t<is_same<_Tag, _Unpack_tuple_t>::value, int>> inline
; 870  : 		constexpr tuple<_This, _Rest...>::tuple(_Tag, _Tpl&& _Right, index_sequence<_Indices...>)
; 871  : 		: tuple(_Exact_args_t{}, _STD get<_Indices>(_STD forward<_Tpl>(_Right))...)
; 872  : 		{	// construct from unpacking a tuple/pair, using get<I>()
; 873  : 		}
; 874  : 
; 875  : template<class _This,
; 876  : 	class... _Rest>
; 877  : 	template<class _Tag,
; 878  : 		class _Alloc,
; 879  : 		class _Tpl,
; 880  : 		size_t... _Indices,
; 881  : 		enable_if_t<is_same<_Tag, _Alloc_unpack_tuple_t>::value, int>> inline
; 882  : 		tuple<_This, _Rest...>::tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right, index_sequence<_Indices...>)
; 883  : 		: tuple(_Alloc_exact_args_t{}, _Al, _STD get<_Indices>(_STD forward<_Tpl>(_Right))...)
; 884  : 		{	// construct from an allocator and unpacking a tuple/pair, using get<I>()
; 885  : 		}
; 886  : 
; 887  : 	// TEMPLATE FUNCTION make_tuple
; 888  : template<class... _Types> inline
; 889  : 	constexpr tuple<typename _Unrefwrap<_Types>::type...>
; 890  : 		make_tuple(_Types&&... _Args)
; 891  : 	{	// make tuple from elements
; 892  : 	typedef tuple<typename _Unrefwrap<_Types>::type...> _Ttype;
; 893  : 	return (_Ttype(_STD forward<_Types>(_Args)...));
; 894  : 	}
; 895  : 
; 896  : 	// TEMPLATE FUNCTION tie
; 897  : template<class... _Types> inline
; 898  : 	constexpr tuple<_Types&...>
; 899  : 		tie(_Types&... _Args) _NOEXCEPT
; 900  : 	{	// make tuple from elements
; 901  : 	typedef tuple<_Types&...> _Ttype;
; 902  : 	return (_Ttype(_Args...));
; 903  : 	}
; 904  : 
; 905  : 
; 906  : 	// TEMPLATE FUNCTION forward_as_tuple
; 907  : 
; 908  : template<class... _Types> inline
; 909  : 	constexpr tuple<_Types&&...>
; 910  : 		forward_as_tuple(_Types&&... _Args) _NOEXCEPT
; 911  : 	{	// forward arguments in a tuple
; 912  : 	return (tuple<_Types&&...>(_STD forward<_Types>(_Args)...));
; 913  : 	}
; 914  : 
; 915  : 
; 916  : 	// TEMPLATE STRUCT _Cat_sequences
; 917  : template<class _Seq_type1,
; 918  : 	class _Seq_type2>
; 919  : 	struct _Cat_sequences;
; 920  : 
; 921  : template<size_t... _Indexes1,
; 922  : 	size_t... _Indexes2>
; 923  : 	struct _Cat_sequences<index_sequence<_Indexes1...>,
; 924  : 		index_sequence<_Indexes2...> >
; 925  : 	{	// concatenates two index_sequence types
; 926  : 	typedef index_sequence<_Indexes1..., _Indexes2...> type;
; 927  : 	};
; 928  : 
; 929  : 	// FORWARD DECLARATIONS
; 930  : template<class _Ty,
; 931  : 	size_t _Size>
; 932  : 	class array;
; 933  : 
; 934  : template<size_t _Idx,
; 935  : 	class _Ty,
; 936  : 	size_t _Size>
; 937  : 	constexpr _Ty& get(array<_Ty, _Size>& _Arr) _NOEXCEPT;
; 938  : 
; 939  : template<size_t _Idx,
; 940  : 	class _Ty,
; 941  : 	size_t _Size>
; 942  : 	constexpr const _Ty& get(const array<_Ty, _Size>& _Arr) _NOEXCEPT;
; 943  : 
; 944  : template<size_t _Idx,
; 945  : 	class _Ty,
; 946  : 	size_t _Size>
; 947  : 	constexpr _Ty&& get(array<_Ty, _Size>&& _Arr) _NOEXCEPT;
; 948  : 
; 949  : 	// TEMPLATE STRUCT _View_as_tuple
; 950  : template<class _Ty,
; 951  : 	class... _For_array>
; 952  : 	struct _View_as_tuple
; 953  : 	{	// tuple_cat() supports only tuples, pairs, and arrays
; 954  : 	static_assert(_Always_false<_Ty>::value,
; 955  : 		"Unsupported tuple_cat arguments.");
; 956  : 	};
; 957  : 
; 958  : template<class... _Types>
; 959  : 	struct _View_as_tuple<tuple<_Types...> >
; 960  : 	{	// view a tuple as a tuple
; 961  : 	typedef tuple<_Types...> type;
; 962  : 	};
; 963  : 
; 964  : template<class _Ty1,
; 965  : 	class _Ty2>
; 966  : 	struct _View_as_tuple<pair<_Ty1, _Ty2> >
; 967  : 	{	// view a pair as a tuple
; 968  : 	typedef tuple<_Ty1, _Ty2> type;
; 969  : 	};
; 970  : 
; 971  : template<class _Ty,
; 972  : 	class... _Types>
; 973  : 	struct _View_as_tuple<array<_Ty, 0>, _Types...>
; 974  : 	{	// view an array as a tuple; ends recursion at 0
; 975  : 	typedef tuple<_Types...> type;
; 976  : 	};
; 977  : 
; 978  : template<class _Ty,
; 979  : 	size_t _Size,
; 980  : 	class... _Types>
; 981  : 	struct _View_as_tuple<array<_Ty, _Size>, _Types...>
; 982  : 		: _View_as_tuple<array<_Ty, _Size - 1>, _Ty, _Types...>
; 983  : 	{	// view an array as a tuple; counts down to 0
; 984  : 	};
; 985  : 
; 986  : 	// TEMPLATE STRUCT _Repeat_for
; 987  : template<size_t _Nx,
; 988  : 	class _Ty>
; 989  : 	struct _Repeat_for
; 990  : 		: integral_constant<size_t, _Nx>
; 991  : 	{	// repeats _Nx for each _Ty in a parameter pack
; 992  : 	};
; 993  : 
; 994  : 	// TEMPLATE FUNCTION tuple_cat
; 995  : template<class _Ret,
; 996  : 	class _Kx_arg,
; 997  : 	class _Ix_arg,
; 998  : 	size_t _Ix_next,
; 999  : 	class... _Tuples>
; 1000 : 	struct _Tuple_cat2
; 1001 : 	{	// determine tuple_cat's return type and _Kx/_Ix indices
; 1002 : 	static_assert(sizeof...(_Tuples) == 0,
; 1003 : 		"Unsupported tuple_cat arguments.");
; 1004 : 	typedef _Ret type;
; 1005 : 	typedef _Kx_arg _Kx_arg_seq;
; 1006 : 	typedef _Ix_arg _Ix_arg_seq;
; 1007 : 	};
; 1008 : 
; 1009 : template<class... _Types1,
; 1010 : 	class _Kx_arg,
; 1011 : 	size_t... _Ix,
; 1012 : 	size_t _Ix_next,
; 1013 : 	class... _Types2,
; 1014 : 	class... _Rest>
; 1015 : 	struct _Tuple_cat2<tuple<_Types1...>, _Kx_arg,
; 1016 : 		index_sequence<_Ix...>, _Ix_next,
; 1017 : 		tuple<_Types2...>, _Rest...>
; 1018 : 		: _Tuple_cat2<
; 1019 : 			tuple<_Types1..., _Types2...>,
; 1020 : 			typename _Cat_sequences<_Kx_arg, index_sequence_for<_Types2...>>::type,
; 1021 : 			index_sequence<_Ix..., _Repeat_for<_Ix_next, _Types2>::value...>,
; 1022 : 			_Ix_next + 1,
; 1023 : 			_Rest...>
; 1024 : 	{	// determine tuple_cat's return type and _Kx/_Ix indices
; 1025 : 	};
; 1026 : 
; 1027 : template<class... _Tuples>
; 1028 : 	struct _Tuple_cat1
; 1029 : 		: _Tuple_cat2<tuple<>, index_sequence<>,
; 1030 : 				index_sequence<>, 0,
; 1031 : 			typename _View_as_tuple<typename decay<_Tuples>::type>::type...>
; 1032 : 	{	// prepare to determine tuple_cat's return type and _Kx/_Ix indices
; 1033 : 	};
; 1034 : 
; 1035 : #pragma warning(push)
; 1036 : #pragma warning(disable: 4100)	// TRANSITION, VSO#181496, unreferenced formal parameter
; 1037 : template<class _Ret,
; 1038 : 	size_t... _Kx,
; 1039 : 	size_t... _Ix,
; 1040 : 	class _Ty> inline
; 1041 : 	constexpr _Ret _Tuple_cat(index_sequence<_Kx...>,
; 1042 : 		index_sequence<_Ix...>, _Ty&& _Arg)
; 1043 : 	{	// concatenate tuples
; 1044 : 	return (_Ret(_STD get<_Kx>(_STD get<_Ix>(_STD forward<_Ty>(_Arg)))...));
; 1045 : 	}
; 1046 : #pragma warning(pop)
; 1047 : 
; 1048 : template<class... _Tuples> inline
; 1049 : 	constexpr typename _Tuple_cat1<_Tuples...>::type
; 1050 : 		tuple_cat(_Tuples&&... _Tpls)
; 1051 : 	{	// concatenate tuples
; 1052 : 	typedef _Tuple_cat1<_Tuples...> _Cat1;
; 1053 : 	return (_Tuple_cat<typename _Cat1::type>(
; 1054 : 		typename _Cat1::_Kx_arg_seq(), typename _Cat1::_Ix_arg_seq(),
; 1055 : 		_STD forward_as_tuple(_STD forward<_Tuples>(_Tpls)...)));
; 1056 : 	}
; 1057 : 
; 1058 : #if _HAS_CXX17
; 1059 : 	// FUNCTION TEMPLATE apply
; 1060 : #pragma warning(push)
; 1061 : #pragma warning(disable: 4100)	// TRANSITION, VSO#181496, unreferenced formal parameter
; 1062 : template<class _Callable,
; 1063 : 	class _Tuple,
; 1064 : 	size_t... _Indices>
; 1065 : 	constexpr decltype(auto) _Apply_impl(_Callable&& _Obj, _Tuple&& _Tpl, index_sequence<_Indices...>)
; 1066 : 	{	// invoke _Obj with the elements of _Tpl
; 1067 : 	return (_C_invoke(_STD forward<_Callable>(_Obj), _STD get<_Indices>(_STD forward<_Tuple>(_Tpl))...));
; 1068 : 	}
; 1069 : #pragma warning(pop)
; 1070 : 
; 1071 : template<class _Callable,
; 1072 : 	class _Tuple>
; 1073 : 	constexpr decltype(auto) apply(_Callable&& _Obj, _Tuple&& _Tpl)
; 1074 : 	{	// invoke _Obj with the elements of _Tpl
; 1075 : 	return (_Apply_impl(_STD forward<_Callable>(_Obj), _STD forward<_Tuple>(_Tpl),
; 1076 : 		make_index_sequence<tuple_size_v<decay_t<_Tuple>>>{}));
; 1077 : 	}
; 1078 : 
; 1079 : 	// FUNCTION TEMPLATE make_from_tuple
; 1080 : #pragma warning(push)
; 1081 : #pragma warning(disable: 4100)	// TRANSITION, VSO#181496, unreferenced formal parameter
; 1082 : template<class _Ty,
; 1083 : 	class _Tuple,
; 1084 : 	size_t... _Indices>
; 1085 : 	constexpr _Ty _Make_from_tuple_impl(_Tuple&& _Tpl, index_sequence<_Indices...>)
; 1086 : 	{	// construct _Ty from the elements of _Tpl
; 1087 : 	return (_Ty(_STD get<_Indices>(_STD forward<_Tuple>(_Tpl))...));
; 1088 : 	}
; 1089 : #pragma warning(pop)
; 1090 : 
; 1091 : template<class _Ty,
; 1092 : 	class _Tuple>
; 1093 : 	constexpr _Ty make_from_tuple(_Tuple&& _Tpl)
; 1094 : 	{	// construct _Ty from the elements of _Tpl
; 1095 : 	return (_Make_from_tuple_impl<_Ty>(_STD forward<_Tuple>(_Tpl),
; 1096 : 		make_index_sequence<tuple_size_v<decay_t<_Tuple>>>{}));
; 1097 : 	}
; 1098 : #endif /* _HAS_CXX17 */
; 1099 : 
; 1100 : 	// FUNCTION TEMPLATE _For_each_tuple_element
; 1101 : template<class _Tpl,
; 1102 : 	class _Fx,
; 1103 : 	size_t... _Indices> inline
; 1104 : 	void _For_each_tuple_element_impl(_Tpl&& _Tuple,
; 1105 : 		_Fx _Func, index_sequence<_Indices...>)
; 1106 : 	{	// call _Func() on the _Indices elements of _Tuple
; 1107 : 	int _Ignored[] = { (static_cast<void>(_Func(
; 1108 : 		_STD get<_Indices>(_STD forward<_Tpl>(_Tuple))
; 1109 : 		)), 0)... };
; 1110 : 	(void)_Ignored;
; 1111 : 	}
; 1112 : 
; 1113 : template<class _Tpl,
; 1114 : 	class _Fx> inline
; 1115 : 	void _For_each_tuple_element(_Tpl&& _Tuple, _Fx _Func)
; 1116 : 	{	// call _Func() on each element in _Tuple
; 1117 : 	_For_each_tuple_element_impl(
; 1118 : 		_STD forward<_Tpl>(_Tuple),
; 1119 : 		_Func,
; 1120 : 		make_index_sequence<tuple_size<remove_reference_t<_Tpl>>::value>()
; 1121 : 		);
; 1122 : 	}
; 1123 : 
; 1124 : 
; 1125 : #pragma warning(push)
; 1126 : #pragma warning(disable: 4100)	// TRANSITION, VSO#181496, unreferenced formal parameter
; 1127 : 	// TEMPLATE CONSTRUCTOR pair::pair(tuple, tuple, sequence, sequence)
; 1128 : template<class _Ty1,
; 1129 : 	class _Ty2>
; 1130 : 	template<class _Tuple1,
; 1131 : 		class _Tuple2,
; 1132 : 		size_t... _Indexes1,
; 1133 : 		size_t... _Indexes2> inline
; 1134 : 		pair<_Ty1, _Ty2>::pair(_Tuple1& _Val1,
; 1135 : 			_Tuple2& _Val2,
; 1136 : 			index_sequence<_Indexes1...>,
; 1137 : 			index_sequence<_Indexes2...>)
; 1138 : 		: first(_STD get<_Indexes1>(_STD move(_Val1))...),

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 1141 : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	pop	ebp
	ret	16					; 00000010H
??$?0V?$tuple@ABQAVISteamUser@@@std@@V?$tuple@$$V@1@$0A@$$Z$S@?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@QAE@AAV?$tuple@ABQAVISteamUser@@@1@AAV?$tuple@$$V@1@U?$integer_sequence@I$0A@@1@U?$integer_sequence@I$S@1@@Z ENDP ; std::pair<ISteamUser * const,IWrapSteamUser *>::pair<ISteamUser * const,IWrapSteamUser *><std::tuple<ISteamUser * const &>,std::tuple<>,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple
;	COMDAT ??$?0ABQAVISteamUser@@$$Z$$V@?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@QAE@Upiecewise_construct_t@1@V?$tuple@ABQAVISteamUser@@@1@V?$tuple@$$V@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
__Val2$ = 16						; size = 1
??$?0ABQAVISteamUser@@$$Z$$V@?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@QAE@Upiecewise_construct_t@1@V?$tuple@ABQAVISteamUser@@@1@V?$tuple@$$V@1@@Z PROC ; std::pair<ISteamUser * const,IWrapSteamUser *>::pair<ISteamUser * const,IWrapSteamUser *><ISteamUser * const &>, COMDAT
; _this$ = ecx

; 1155 : 		{	// construct from pair of tuples

	npad	2
	push	ebp
	mov	ebp, esp

; 1138 : 		: first(_STD get<_Indexes1>(_STD move(_Val1))...),

	mov	eax, DWORD PTR __Val1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 1156 : 		}

	mov	eax, ecx

; 1139 : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)

	mov	DWORD PTR [ecx+4], 0

; 1156 : 		}

	pop	ebp
	ret	12					; 0000000cH
??$?0ABQAVISteamUser@@$$Z$$V@?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@QAE@Upiecewise_construct_t@1@V?$tuple@ABQAVISteamUser@@@1@V?$tuple@$$V@1@@Z ENDP ; std::pair<ISteamUser * const,IWrapSteamUser *>::pair<ISteamUser * const,IWrapSteamUser *><ISteamUser * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@QAEXPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
_<_Args_2>$ = 20					; size = 4
??$construct@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@QAEXPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> >::construct<std::pair<ISteamUser * const,IWrapSteamUser *>,std::piecewise_construct_t const &,std::tuple<ISteamUser * const &>,std::tuple<> >, COMDAT
; _this$ = ecx

; 839  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp

; 333  : }

	mov	eax, DWORD PTR _<_Args_1>$[ebp]
	mov	eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple

; 1138 : 		: first(_STD get<_Indexes1>(_STD move(_Val1))...),

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 1139 : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)

	mov	DWORD PTR [ecx+4], 0
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 841  : 		}

	pop	ebp
	ret	16					; 00000010H
??$construct@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@QAEXPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> >::construct<std::pair<ISteamUser * const,IWrapSteamUser *>,std::piecewise_construct_t const &,std::tuple<ISteamUser * const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@1@PAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
_<_Args_2>$ = 24					; size = 4
??$construct@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@1@PAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::construct<std::pair<ISteamUser * const,IWrapSteamUser *>,std::piecewise_construct_t const &,std::tuple<ISteamUser * const &>,std::tuple<> >, COMDAT

; 958  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN14@construct
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp

; 333  : }

	mov	eax, DWORD PTR _<_Args_1>$[ebp]
	mov	eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple

; 1138 : 		: first(_STD get<_Indexes1>(_STD move(_Val1))...),

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 1139 : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)

	mov	DWORD PTR [ecx+4], 0
$LN14@construct:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 960  : 		}

	pop	ebp
	ret	0
??$construct@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@1@PAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::construct<std::pair<ISteamUser * const,IWrapSteamUser *>,std::piecewise_construct_t const &,std::tuple<ISteamUser * const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
_<_Args_2>$ = 20					; size = 4
??$construct@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::construct<std::pair<ISteamUser * const,IWrapSteamUser *>,std::piecewise_construct_t const &,std::tuple<ISteamUser * const &>,std::tuple<> >, COMDAT
; _this$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN25@construct
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp

	mov	eax, DWORD PTR _<_Args_1>$[ebp]
	mov	eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple

; 1138 : 		: first(_STD get<_Indexes1>(_STD move(_Val1))...),

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 1139 : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)

	mov	DWORD PTR [ecx+4], 0
$LN25@construct:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1098 : 		}

	pop	ebp
	ret	16					; 00000010H
??$construct@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@ABUpiecewise_construct_t@2@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::construct<std::pair<ISteamUser * const,IWrapSteamUser *>,std::piecewise_construct_t const &,std::tuple<ISteamUser * const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$_List_buy@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@PAU21@0ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
_<_Val_0>$ = 16						; size = 4
_<_Val_1>$ = 20						; size = 4
_<_Val_2>$ = 24						; size = 4
??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$_List_buy@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@PAU21@0ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::_List_buy<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Buynode<std::piecewise_construct_t const &,std::tuple<ISteamUser * const &>,std::tuple<> >, COMDAT
; _this$ = ecx

; 847  : 		{	// allocate a node and set links and value

	npad	2
	push	ebp
	mov	ebp, esp

; 848  : 		_Nodeptr _Pnode = this->_Buynode0(_Next, _Prev);

	push	DWORD PTR __Prev$[ebp]
	push	DWORD PTR __Next$[ebp]
	call	?_Buynode0@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Buynode0

; 540  : 		return ((reference)_Pnode->_Myval);

	lea	edx, DWORD PTR [eax+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edx, edx
	je	SHORT $LN54@Buynode
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp

	mov	ecx, DWORD PTR _<_Val_1>$[ebp]
	mov	ecx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple

; 1138 : 		: first(_STD get<_Indexes1>(_STD move(_Val1))...),

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], ecx

; 1139 : 			second(_STD get<_Indexes2>(_STD move(_Val2))...)

	mov	DWORD PTR [edx+4], 0
$LN54@Buynode:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 860  : 		}

	pop	ebp
	ret	20					; 00000014H
??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$_List_buy@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@PAU21@0ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::_List_buy<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Buynode<std::piecewise_construct_t const &,std::tuple<ISteamUser * const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple
;	COMDAT ??$?0ABQAVISteamUser@@@?$_Tuple_val@ABQAVISteamUser@@@std@@QAE@ABQAVISteamUser@@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$?0ABQAVISteamUser@@@?$_Tuple_val@ABQAVISteamUser@@@std@@QAE@ABQAVISteamUser@@@Z PROC ; std::_Tuple_val<ISteamUser * const &>::_Tuple_val<ISteamUser * const &><ISteamUser * const &>, COMDAT
; _this$ = ecx

; 165  : 		{	// construct with argument

	npad	2
	push	ebp
	mov	ebp, esp

; 164  : 		: _Val(_STD forward<_Other>(_Arg))

	mov	eax, DWORD PTR __Arg$[ebp]
	mov	DWORD PTR [ecx], eax

; 166  : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??$?0ABQAVISteamUser@@@?$_Tuple_val@ABQAVISteamUser@@@std@@QAE@ABQAVISteamUser@@@Z ENDP ; std::_Tuple_val<ISteamUser * const &>::_Tuple_val<ISteamUser * const &><ISteamUser * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z PROC ; std::tuple<>::tuple<><std::_Exact_args_t,0>, COMDAT
; _this$ = ecx

; 250  : 		}

	mov	eax, ecx
	ret	4
??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z ENDP ; std::tuple<>::tuple<><std::_Exact_args_t,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@AAPAU21@@Z PROC ; std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> >::construct<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> *,std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> * &>, COMDAT
; _this$ = ecx

; 839  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 841  : 		}

	pop	ebp
	ret	8
??$construct@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@AAPAU21@@Z ENDP ; std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> >::construct<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> *,std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Construct1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXU?$integral_constant@_N$00@1@AAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@$$QAV41@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 4
__Ptr$ = 16						; size = 4
_<_Args_0>$ = 20					; size = 4
??$_Construct1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXU?$integral_constant@_N$00@1@AAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@$$QAV41@@Z PROC ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Construct1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >, COMDAT

; 709  : 		{	// construct _Ty(_Types...) at _Ptr, default version

	npad	2
	push	ebp
	mov	ebp, esp

; 710  : 		::new (static_cast<void *>(_Ptr))

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@Construct1
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@Construct1:

; 711  : 			_Ty(_STD forward<_Types>(_Args)...);
; 712  : 		}

	pop	ebp
	ret	0
??$_Construct1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXU?$integral_constant@_N$00@1@AAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@$$QAV41@@Z ENDP ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Construct1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Construct1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@ABV12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXU?$integral_constant@_N$00@1@AAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@ABV41@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 4
__Ptr$ = 16						; size = 4
_<_Args_0>$ = 20					; size = 4
??$_Construct1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@ABV12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXU?$integral_constant@_N$00@1@AAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@ABV41@@Z PROC ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Construct1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > const &>, COMDAT

; 709  : 		{	// construct _Ty(_Types...) at _Ptr, default version

	npad	2
	push	ebp
	mov	ebp, esp

; 710  : 		::new (static_cast<void *>(_Ptr))

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@Construct1
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@Construct1:

; 711  : 			_Ty(_STD forward<_Types>(_Args)...);
; 712  : 		}

	pop	ebp
	ret	0
??$_Construct1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@ABV12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXU?$integral_constant@_N$00@1@AAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@ABV41@@Z ENDP ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Construct1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Destroy1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@U?$integral_constant@_N$00@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Destroy1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@U?$integral_constant@_N$00@1@@Z PROC ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Destroy1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >, COMDAT

; 734  : 		_Ptr->~_Ty();
; 735  : 		}

	ret	0
??$_Destroy1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@U?$integral_constant@_N$00@1@@Z ENDP ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Destroy1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$?0U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z PROC ; std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> >::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> ><std::pair<ISteamUser * const,IWrapSteamUser *> >, COMDAT
; _this$ = ecx

; 813  : 		}

	mov	eax, ecx
	ret	4
??$?0U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z ENDP ; std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> >::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> ><std::pair<ISteamUser * const,IWrapSteamUser *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ??$_Buynode_if_nil@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@V21@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
__Plist$ = 16						; size = 4
??$_Buynode_if_nil@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@V21@@Z PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Buynode_if_nil<std::pair<ISteamUser * const,IWrapSteamUser *> &>, COMDAT
; _this$ = ecx

; 738  : 		{	// node exists, just return it

	npad	2
	push	ebp
	mov	ebp, esp

; 739  : 		return (_Plist);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Plist$[ebp]
	mov	DWORD PTR [eax], ecx

; 740  : 		}

	pop	ebp
	ret	12					; 0000000cH
??$_Buynode_if_nil@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@V21@@Z ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Buynode_if_nil<std::pair<ISteamUser * const,IWrapSteamUser *> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@YAAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@YAAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@0@AAU10@@Z PROC ; std::forward<std::pair<ISteamUser * const,IWrapSteamUser *> &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@YAAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@0@AAU10@@Z ENDP ; std::forward<std::pair<ISteamUser * const,IWrapSteamUser *> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
;	COMDAT ??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,bool,void,0>, COMDAT
; _this$ = ecx

; 189  : 		{	// construct from moved values

	npad	2
	push	ebp
	mov	ebp, esp

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[ebp]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+4], al

; 190  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,bool,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??$_Insert@ABUpiecewise_construct_t@std@@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
_<_Val_1>$ = 16						; size = 4
_<_Val_2>$ = 20						; size = 4
??$_Insert@ABUpiecewise_construct_t@std@@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Insert<std::piecewise_construct_t const &,std::tuple<ISteamUser * const &>,std::tuple<> >, COMDAT
; _this$ = ecx

; 1082 : 		{	// insert element at _Where

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 535  : 		return ((_Nodepref)_Pnode->_Prev);

	mov	esi, DWORD PTR __Where$[ebp]
	push	edi

; 1083 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1084 : 		_Nodeptr _Newnode =
; 1085 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),

	push	DWORD PTR _<_Val_2>$[ebp]
	mov	edi, ecx
	push	DWORD PTR _<_Val_1>$[ebp]
	push	DWORD PTR _<_Val_0>$[ebp]
	push	DWORD PTR [esi+4]
	push	esi
	call	??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$_List_buy@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@PAU21@0ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_List_buy<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Buynode<std::piecewise_construct_t const &,std::tuple<ISteamUser * const &>,std::tuple<> >
	mov	edx, eax

; 1950 : 		if (max_size() - this->_Mysize() - 1 < _Count)

	mov	ecx, 268435454				; 0ffffffeH
	mov	eax, DWORD PTR [edi+4]
	sub	ecx, eax
	cmp	ecx, 1
	jae	SHORT $LN19@Insert

; 1951 : 			_Xlength_error("list<T> too long");

	push	OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN72@Insert:
$LN19@Insert:

; 1952 : 		this->_Mysize() += _Count;

	inc	eax
	mov	DWORD PTR [edi+4], eax

; 1086 : 				_STD forward<_Valty>(_Val)...);
; 1087 : 		_Incsize(1);
; 1088 : 		this->_Prevnode(_Pnode) = _Newnode;

	mov	DWORD PTR [esi+4], edx

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [edx+4]
	pop	edi
	pop	esi

; 1089 : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;

	mov	DWORD PTR [eax], edx

; 1090 : 		}

	pop	ebp
	ret	16					; 00000010H
$LN71@Insert:
??$_Insert@ABUpiecewise_construct_t@std@@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Insert<std::piecewise_construct_t const &,std::tuple<ISteamUser * const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@ABQAVISteamUser@@$$V$0A@@?$tuple@ABQAVISteamUser@@@std@@QAE@U_Exact_args_t@1@ABQAVISteamUser@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__This_arg$ = 12					; size = 4
??$?0U_Exact_args_t@std@@ABQAVISteamUser@@$$V$0A@@?$tuple@ABQAVISteamUser@@@std@@QAE@U_Exact_args_t@1@ABQAVISteamUser@@@Z PROC ; std::tuple<ISteamUser * const &>::tuple<ISteamUser * const &><std::_Exact_args_t,ISteamUser * const &,0>, COMDAT
; _this$ = ecx

; 292  : 		{	// construct from one arg per element

	npad	2
	push	ebp
	mov	ebp, esp

; 164  : 		: _Val(_STD forward<_Other>(_Arg))

	mov	eax, DWORD PTR __This_arg$[ebp]
	mov	DWORD PTR [ecx], eax

; 293  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??$?0U_Exact_args_t@std@@ABQAVISteamUser@@$$V$0A@@?$tuple@ABQAVISteamUser@@@std@@QAE@U_Exact_args_t@1@ABQAVISteamUser@@@Z ENDP ; std::tuple<ISteamUser * const &>::tuple<ISteamUser * const &><std::_Exact_args_t,ISteamUser * const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@1@PAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@AAPAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@1@PAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@AAPAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::construct<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> *,std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> * &>, COMDAT

; 958  : 		{	// construct _Objty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN8@construct:

; 959  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 960  : 		}

	pop	ebp
	ret	0
??$construct@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@1@PAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@AAPAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::construct<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> *,std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@AAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@YAAAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@YAAAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> * &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@AAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@YAAAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@$$QAV31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@$$QAV31@@Z PROC ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >, COMDAT

; 726  : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 710  : 		::new (static_cast<void *>(_Ptr))

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN8@construct:

; 727  : 		_Construct1(_Uses_default_construct_t<_Unwrap_alloc_t<_Alloc>, _Ty *, _Types...>(),
; 728  : 			_Al, _Ptr, _STD forward<_Types>(_Args)...);
; 729  : 		}

	pop	ebp
	ret	0
??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@$$QAV31@@Z ENDP ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@ABV12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@ABV31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@ABV12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@ABV31@@Z PROC ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > const &>, COMDAT

; 726  : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 710  : 		::new (static_cast<void *>(_Ptr))

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN8@construct:

; 727  : 		_Construct1(_Uses_default_construct_t<_Unwrap_alloc_t<_Alloc>, _Ty *, _Types...>(),
; 728  : 			_Al, _Ptr, _STD forward<_Types>(_Args)...);
; 729  : 		}

	pop	ebp
	ret	0
??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@ABV12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@ABV31@@Z ENDP ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@ABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YAABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YAABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@ABV10@@Z PROC ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > const &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@ABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YAABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@ABV10@@Z ENDP ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@@Z PROC ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >, COMDAT

; 746  : 		_Destroy1(_Al, _Ptr, _Uses_default_destroy_t<_Unwrap_alloc_t<_Alloc>, _Ty *>());
; 747  : 		}

	ret	0
??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@@Z ENDP ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$?0ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > ><std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > const &>, COMDAT
; _this$ = ecx

; 1054 : 		}

	mov	eax, ecx
	ret	4
??$?0ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > ><std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@_N@std@@YA$$QA_NAA_N@Z PROC			; std::forward<bool>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@_N@std@@YA$$QA_NAA_N@Z ENDP			; std::forward<bool>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@AAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YAAAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YAAAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@AAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YAAAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ??$_Insert@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Plist$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T2 = 8							; size = 4
___$ReturnUdt$ = 8					; size = 4
tv1596 = 12						; size = 4
$T3 = 12						; size = 4
__Val$ = 12						; size = 4
__Pnode$ = 16						; size = 4
??$_Insert@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@@Z PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Insert<std::pair<ISteamUser * const,IWrapSteamUser *> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >, COMDAT
; _this$ = ecx

; 761  : 		{	// try to insert existing node with value _Val

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	mov	edi, DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 761  : 		{	// try to insert existing node with value _Val

	mov	ebx, ecx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ebx

; 762  : 		size_type _Bucket;
; 763  : 		_Unchecked_iterator _Where;
; 764  : 
; 765  : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	movzx	eax, BYTE PTR [edi]
	xor	eax, -2128831035			; 811c9dc5H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	mov	esi, DWORD PTR [ebx+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 347  : 		_Val *= _FNV_prime;

	imul	edx, eax, 16777619
	movzx	eax, BYTE PTR [edi+1]
	xor	edx, eax
	movzx	eax, BYTE PTR [edi+2]
	imul	ecx, edx, 16777619
	xor	ecx, eax
	movzx	eax, BYTE PTR [edi+3]
	imul	ecx, ecx, 16777619
	xor	ecx, eax
	imul	eax, ecx, 16777619
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 912  : 		return (_Traitsobj(_Keyval) & _Mask);

	mov	ecx, DWORD PTR [ebx+24]
	and	ecx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [esi+ecx*8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1746 : 		return (this->_Myfirst()[_Pos]);

	lea	edx, DWORD PTR [ecx*8]
	mov	DWORD PTR tv1596[ebp], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	eax, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 846  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())

	jne	SHORT $LN45@Insert

; 847  : 			return (_Unchecked_end());

	mov	esi, DWORD PTR [ebx+4]
	jmp	SHORT $LN46@Insert
$LN45@Insert:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	esi, DWORD PTR [esi+edx+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 851  : 			return (++_Ans);

	mov	esi, DWORD PTR [esi]
$LN46@Insert:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	esi, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 768  : 		for (; _Where != _Begin(_Bucket); )

	je	SHORT $LN3@Insert
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 220  : 		return (_Left == _Right);

	mov	ecx, DWORD PTR [edi]
	npad	1
$LL2@Insert:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);

	mov	esi, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 220  : 		return (_Left == _Right);

	cmp	ecx, DWORD PTR [esi+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 772  : 			if (_Traitsobj(_Traits::_Kfn(_Val),

	je	SHORT $LN6@Insert
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	esi, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 768  : 		for (; _Where != _Begin(_Bucket); )

	jne	SHORT $LL2@Insert
$LN3@Insert:

; 739  : 		return (_Plist);

	mov	edi, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Plist$[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);

	mov	eax, DWORD PTR [edi]

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	esi, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 799  : 		if (_Where != ++_Next)	// move element into place

	je	SHORT $LN10@Insert
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	ecx, DWORD PTR [edi+4]

; 1910 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =

	mov	DWORD PTR [ecx], eax

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	ecx, DWORD PTR [eax+4]

; 1912 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =

	mov	DWORD PTR [ecx], esi

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	ecx, DWORD PTR [esi+4]

; 1914 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =

	mov	DWORD PTR [ecx], edi

; 1915 : 			_First._Mynode();
; 1916 : 
; 1917 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());

	mov	edx, DWORD PTR [esi+4]

; 1918 : 		this->_Prevnode(_Where._Mynode()) =

	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], ecx

; 1919 : 			this->_Prevnode(_Last._Mynode());
; 1920 : 		this->_Prevnode(_Last._Mynode()) =

	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+4], ecx

; 1921 : 			this->_Prevnode(_First._Mynode());
; 1922 : 		this->_Prevnode(_First._Mynode()) = _Pnode;

	mov	DWORD PTR [edi+4], edx
	mov	edx, DWORD PTR tv1596[ebp]
$LN10@Insert:

; 86   : 		return (_Ptr == _Right._Ptr);

	mov	ecx, DWORD PTR [ebx+12]
	add	ecx, edx
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 883  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())

	jne	SHORT $LN465@Insert

; 884  : 			{	// make bucket non-empty
; 885  : 			_Vec_lo(_Bucket) = _Plist;

	mov	DWORD PTR [ecx], edi

; 886  : 			_Vec_hi(_Bucket) = _Plist;

	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR [eax+edx+4], edi

; 888  : 		else if (_Vec_lo(_Bucket) == _Where)

	jmp	SHORT $LN469@Insert
$LN6@Insert:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 96   : 		return (_Ptr);

	mov	edx, DWORD PTR __Pnode$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	push	edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	ecx, DWORD PTR [edx+4]

; 1490 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 1491 : 			this->_Nextnode(_Pnode);
; 1492 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =

	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 1493 : 			this->_Prevnode(_Pnode);
; 1494 : 
; 1495 : 		--this->_Mysize();

	dec	DWORD PTR [ebx+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	call	??3@YAXPAX@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	DWORD PTR [eax], esi

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 812  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN465@Insert:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 888  : 		else if (_Vec_lo(_Bucket) == _Where)

	jne	SHORT $LN467@Insert

; 889  : 			_Vec_lo(_Bucket) = _Plist;	// move beginning back one element

	mov	DWORD PTR [ecx], edi

; 890  : 		else if (++_Vec_hi(_Bucket) != _Plist)	// move end up one element

	jmp	SHORT $LN469@Insert
$LN467@Insert:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [ecx+4]

; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 890  : 		else if (++_Vec_hi(_Bucket) != _Plist)	// move end up one element

	je	SHORT $LN469@Insert
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1746 : 		return (this->_Myfirst()[_Pos]);

	mov	ecx, DWORD PTR [ebx+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);

	mov	eax, DWORD PTR [ecx+edx+4]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+edx+4], eax
$LN469@Insert:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 805  : 		_Check_size();

	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Check_size@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Check_size
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 812  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	DWORD PTR [eax], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 812  : 		}

	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 812  : 		}

	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$??$_Insert@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@@Z$2:

; 806  : 		_CATCH_ALL
; 807  : 		erase(_Make_iter(_Plist));

	push	DWORD PTR __Plist$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?_Make_iter@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Make_iter
	mov	ecx, DWORD PTR _this$[ebp]
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?erase@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::erase

; 808  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN655@Insert:
$LN654@Insert:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Insert@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Insert<std::pair<ISteamUser * const,IWrapSteamUser *> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??$emplace_front@ABUpiecewise_construct_t@std@@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEXABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
_<_Val_1>$ = 12						; size = 4
_<_Val_2>$ = 16						; size = 4
??$emplace_front@ABUpiecewise_construct_t@std@@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEXABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::emplace_front<std::piecewise_construct_t const &,std::tuple<ISteamUser * const &>,std::tuple<> >, COMDAT
; _this$ = ecx

; 1055 : 		{	// insert element at beginning

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 1085 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),

	push	DWORD PTR _<_Val_2>$[ebp]

; 1055 : 		{	// insert element at beginning

	mov	esi, ecx

; 1085 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),

	push	DWORD PTR _<_Val_1>$[ebp]
	push	DWORD PTR _<_Val_0>$[ebp]

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [esi]

; 96   : 		return (_Ptr);

	mov	edi, DWORD PTR [eax]

; 1085 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),

	push	DWORD PTR [edi+4]
	push	edi
	call	??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$_List_buy@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@PAU21@0ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_List_buy<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Buynode<std::piecewise_construct_t const &,std::tuple<ISteamUser * const &>,std::tuple<> >
	mov	edx, eax

; 1950 : 		if (max_size() - this->_Mysize() - 1 < _Count)

	mov	ecx, 268435454				; 0ffffffeH
	mov	eax, DWORD PTR [esi+4]
	sub	ecx, eax
	cmp	ecx, 1
	jae	SHORT $LN60@emplace_fr

; 1951 : 			_Xlength_error("list<T> too long");

	push	OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN114@emplace_fr:
$LN60@emplace_fr:

; 1952 : 		this->_Mysize() += _Count;

	inc	eax
	mov	DWORD PTR [esi+4], eax

; 1088 : 		this->_Prevnode(_Pnode) = _Newnode;

	mov	DWORD PTR [edi+4], edx

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [edx+4]
	pop	edi
	pop	esi

; 1089 : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;

	mov	DWORD PTR [eax], edx

; 1056 : 		_Insert(_Unchecked_begin(), _STD forward<_Valty>(_Val)...);
; 1057 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN113@emplace_fr:
??$emplace_front@ABUpiecewise_construct_t@std@@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEXABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::emplace_front<std::piecewise_construct_t const &,std::tuple<ISteamUser * const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@V?$tuple@$$V@std@@@std@@YA$$QAV?$tuple@$$V@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$tuple@$$V@std@@@std@@YA$$QAV?$tuple@$$V@0@AAV10@@Z PROC ; std::forward<std::tuple<> >, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@V?$tuple@$$V@std@@@std@@YA$$QAV?$tuple@$$V@0@AAV10@@Z ENDP ; std::forward<std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@V?$tuple@ABQAVISteamUser@@@std@@@std@@YA$$QAV?$tuple@ABQAVISteamUser@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$tuple@ABQAVISteamUser@@@std@@@std@@YA$$QAV?$tuple@ABQAVISteamUser@@@0@AAV10@@Z PROC ; std::forward<std::tuple<ISteamUser * const &> >, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@V?$tuple@ABQAVISteamUser@@@std@@@std@@YA$$QAV?$tuple@ABQAVISteamUser@@@0@AAV10@@Z ENDP ; std::forward<std::tuple<ISteamUser * const &> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@ABUpiecewise_construct_t@std@@@std@@YAABUpiecewise_construct_t@0@ABU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUpiecewise_construct_t@std@@@std@@YAABUpiecewise_construct_t@0@ABU10@@Z PROC ; std::forward<std::piecewise_construct_t const &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@ABUpiecewise_construct_t@std@@@std@@YAABUpiecewise_construct_t@0@ABU10@@Z ENDP ; std::forward<std::piecewise_construct_t const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple
;	COMDAT ??$?0ABQAVISteamUser@@$0A@@?$tuple@ABQAVISteamUser@@@std@@QAE@ABQAVISteamUser@@@Z
_TEXT	SEGMENT
__This_arg$ = 8						; size = 4
??$?0ABQAVISteamUser@@$0A@@?$tuple@ABQAVISteamUser@@@std@@QAE@ABQAVISteamUser@@@Z PROC ; std::tuple<ISteamUser * const &>::tuple<ISteamUser * const &><ISteamUser * const &,0>, COMDAT
; _this$ = ecx

; 386  : 		{	// construct from one or more copied elements

	npad	2
	push	ebp
	mov	ebp, esp

; 164  : 		: _Val(_STD forward<_Other>(_Arg))

	mov	eax, DWORD PTR __This_arg$[ebp]
	mov	DWORD PTR [ecx], eax

; 387  : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??$?0ABQAVISteamUser@@$0A@@?$tuple@ABQAVISteamUser@@@std@@QAE@ABQAVISteamUser@@@Z ENDP ; std::tuple<ISteamUser * const &>::tuple<ISteamUser * const &><ISteamUser * const &,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@AAPAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::construct<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> *,std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> * &>, COMDAT
; _this$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 1096 : 		_Mytraits::construct(*this, _Ptr,
; 1097 : 			_STD forward<_Types>(_Args)...);
; 1098 : 		}

	pop	ebp
	ret	8
??$construct@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@AAPAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::construct<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> *,std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@$$QAV21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@$$QAV21@@Z PROC ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >, COMDAT
; _this$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 710  : 		::new (static_cast<void *>(_Ptr))

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 1096 : 		_Mytraits::construct(*this, _Ptr,
; 1097 : 			_STD forward<_Types>(_Args)...);
; 1098 : 		}

	pop	ebp
	ret	8
??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@$$QAV21@@Z ENDP ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@QAEXPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@QAEXPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@@Z PROC ; std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> >::destroy<std::pair<ISteamUser * const,IWrapSteamUser *> >, COMDAT
; _this$ = ecx

; 846  : 		_Ptr->~_Uty();
; 847  : 		}

	ret	4
??$destroy@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@QAEXPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@@Z ENDP ; std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> >::destroy<std::pair<ISteamUser * const,IWrapSteamUser *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@ABV12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@ABV21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@ABV12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@ABV21@@Z PROC ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > const &>, COMDAT
; _this$ = ecx

; 1095 : 		{	// construct _Ty(_Types...) at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 710  : 		::new (static_cast<void *>(_Ptr))

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 1096 : 		_Mytraits::construct(*this, _Ptr,
; 1097 : 			_STD forward<_Types>(_Args)...);
; 1098 : 		}

	pop	ebp
	ret	8
??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@ABV12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@ABV21@@Z ENDP ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@@Z PROC ; std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> >::destroy<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> *>, COMDAT
; _this$ = ecx

; 846  : 		_Ptr->~_Uty();
; 847  : 		}

	ret	4
??$destroy@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@@Z ENDP ; std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> >::destroy<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >, COMDAT
; _this$ = ecx

; 1103 : 		_Mytraits::destroy(*this, _Ptr);
; 1104 : 		}

	ret	4
??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >,std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >,std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,1><std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > const &>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 523  : 		: _Myhead(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 524  : 		_Mysize(0)

	mov	DWORD PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	ret	8
??$?0ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >,std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >,std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,1><std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$?0ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > ><std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > const &>, COMDAT
; _this$ = ecx

; 1054 : 		}

	mov	eax, ecx
	ret	4
??$?0ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > ><std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
;	COMDAT ??$?0AAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > &,bool,void,0>, COMDAT
; _this$ = ecx

; 189  : 		{	// construct from moved values

	npad	2
	push	ebp
	mov	ebp, esp

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[ebp]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+4], al

; 190  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??$?0AAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > &,bool,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ??$emplace@ABUpiecewise_construct_t@std@@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_<_Val_0>$ = 12						; size = 4
_<_Val_1>$ = 16						; size = 4
_<_Val_2>$ = 20						; size = 4
??$emplace@ABUpiecewise_construct_t@std@@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::emplace<std::piecewise_construct_t const &,std::tuple<ISteamUser * const &>,std::tuple<> >, COMDAT
; _this$ = ecx

; 294  : 		{	// try to insert value_type(_Val...)

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 1085 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),

	push	DWORD PTR _<_Val_2>$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 294  : 		{	// try to insert value_type(_Val...)

	mov	ebx, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 1085 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),

	push	DWORD PTR _<_Val_1>$[ebp]
	push	DWORD PTR _<_Val_0>$[ebp]

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [ebx+4]

; 1085 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),

	lea	ecx, DWORD PTR [ebx+4]

; 96   : 		return (_Ptr);

	mov	edi, DWORD PTR [eax]

; 1085 : 			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),

	push	DWORD PTR [edi+4]
	push	edi
	call	??$_Buynode@ABUpiecewise_construct_t@std@@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$_List_buy@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@PAU21@0ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_List_buy<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Buynode<std::piecewise_construct_t const &,std::tuple<ISteamUser * const &>,std::tuple<> >
	mov	edx, eax

; 1950 : 		if (max_size() - this->_Mysize() - 1 < _Count)

	mov	ecx, 268435454				; 0ffffffeH
	mov	eax, DWORD PTR [ebx+8]
	sub	ecx, eax
	cmp	ecx, 1
	jae	SHORT $LN71@emplace

; 1951 : 			_Xlength_error("list<T> too long");

	push	OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN199@emplace:
$LN71@emplace:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 296  : 		return (_Insert(_List.front(), _Unchecked_begin()));

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 1952 : 		this->_Mysize() += _Count;

	inc	eax
	mov	DWORD PTR [ebx+8], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 296  : 		return (_Insert(_List.front(), _Unchecked_begin()));

	mov	ecx, ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 1088 : 		this->_Prevnode(_Pnode) = _Newnode;

	mov	DWORD PTR [edi+4], edx

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [edx+4]

; 1089 : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;

	mov	DWORD PTR [eax], edx

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [ebx+4]

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 296  : 		return (_Insert(_List.front(), _Unchecked_begin()));

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 540  : 		return ((reference)_Pnode->_Myval);

	add	eax, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 296  : 		return (_Insert(_List.front(), _Unchecked_begin()));

	push	eax
	push	esi
	call	??$_Insert@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Insert<std::pair<ISteamUser * const,IWrapSteamUser *> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 297  : 		}

	pop	ebp
	ret	16					; 00000010H
$LN198@emplace:
??$emplace@ABUpiecewise_construct_t@std@@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::emplace<std::piecewise_construct_t const &,std::tuple<ISteamUser * const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple
;	COMDAT ??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ PROC	; std::forward_as_tuple<>, COMDAT

; 911  : 	{	// forward arguments in a tuple

	npad	2
	push	ebp
	mov	ebp, esp

; 912  : 	return (tuple<_Types&&...>(_STD forward<_Types>(_Args)...));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 913  : 	}

	pop	ebp
	ret	0
??$forward_as_tuple@$$V@std@@YA?AV?$tuple@$$V@0@XZ ENDP	; std::forward_as_tuple<>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ??0?$tuple@ABQAVISteamUser@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$tuple@ABQAVISteamUser@@@std@@QAE@$$QAV01@@Z PROC	; std::tuple<ISteamUser * const &>::tuple<ISteamUser * const &>, COMDAT
; _this$ = ecx

; 333  : }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??0?$tuple@ABQAVISteamUser@@@std@@QAE@$$QAV01@@Z ENDP	; std::tuple<ISteamUser * const &>::tuple<ISteamUser * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple
;	COMDAT ??$forward_as_tuple@ABQAVISteamUser@@@std@@YA?AV?$tuple@ABQAVISteamUser@@@0@ABQAVISteamUser@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_<_Args_0>$ = 12					; size = 4
??$forward_as_tuple@ABQAVISteamUser@@@std@@YA?AV?$tuple@ABQAVISteamUser@@@0@ABQAVISteamUser@@@Z PROC ; std::forward_as_tuple<ISteamUser * const &>, COMDAT

; 911  : 	{	// forward arguments in a tuple

	npad	2
	push	ebp
	mov	ebp, esp

; 164  : 		: _Val(_STD forward<_Other>(_Arg))

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	mov	DWORD PTR [eax], ecx

; 912  : 	return (tuple<_Types&&...>(_STD forward<_Types>(_Args)...));
; 913  : 	}

	pop	ebp
	ret	0
??$forward_as_tuple@ABQAVISteamUser@@@std@@YA?AV?$tuple@ABQAVISteamUser@@@0@ABQAVISteamUser@@@Z ENDP ; std::forward_as_tuple<ISteamUser * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@ABQAVISteamUser@@@std@@YAABQAVISteamUser@@ABQAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAVISteamUser@@@std@@YAABQAVISteamUser@@ABQAV1@@Z PROC ; std::forward<ISteamUser * const &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@ABQAVISteamUser@@@std@@YAABQAVISteamUser@@ABQAV1@@Z ENDP ; std::forward<ISteamUser * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Rechecked@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@PAV12@@std@@YAAAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@AAPAV10@PAV10@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@PAV12@@std@@YAAAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@AAPAV10@PAV10@@Z PROC ; std::_Rechecked<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *>, COMDAT

; 480  : 	{	// reset checked from unchecked, generic

	npad	2
	push	ebp
	mov	ebp, esp

; 481  : 	_Dest = _Src;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Src$[ebp]
	mov	DWORD PTR [eax], ecx

; 482  : 	return (_Dest);
; 483  : 	}

	pop	ebp
	ret	0
??$_Rechecked@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@PAV12@@std@@YAAAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@AAPAV10@PAV10@@Z ENDP ; std::_Rechecked<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0U?$integral_constant@_N$0A@@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$0A@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$integral_constant@_N$0A@@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$0A@@1@@Z PROC ; std::_Any_tag::_Any_tag<std::integral_constant<bool,0> >, COMDAT
; _this$ = ecx

; 556  : 		constexpr _Any_tag(_Ty&&) _NOEXCEPT {}

	mov	eax, ecx
	ret	4
??$?0U?$integral_constant@_N$0A@@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$0A@@1@@Z ENDP ; std::_Any_tag::_Any_tag<std::integral_constant<bool,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_move_al_unchecked@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >, COMDAT

; 135  : 	{	// move [_First, _Last) to raw _Dest, using _Al, no special optimization

	npad	2
	push	ebp
	mov	ebp, esp

; 139  : 	for (; _First != _Last; ++_Dest, (void)++_First)

	mov	eax, DWORD PTR __Dest$[ebp]
	xor	ecx, ecx
	push	esi
	mov	esi, DWORD PTR __Last$[ebp]
	xor	edx, edx
	push	edi
	mov	edi, DWORD PTR __First$[ebp]
	sub	esi, edi
	add	esi, 3
	shr	esi, 2
	cmp	edi, DWORD PTR __Last$[ebp]
	cmova	esi, ecx
	test	esi, esi
	je	SHORT $LN3@Uninitiali
	sub	edi, eax
$LL4@Uninitiali:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 710  : 		::new (static_cast<void *>(_Ptr))

	test	eax, eax
	je	SHORT $LN2@Uninitiali
	mov	ecx, DWORD PTR [edi+eax]
	mov	DWORD PTR [eax], ecx
$LN2@Uninitiali:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 139  : 	for (; _First != _Last; ++_Dest, (void)++_First)

	inc	edx
	add	eax, 4
	cmp	edx, esi
	jne	SHORT $LL4@Uninitiali
$LN3@Uninitiali:
	pop	edi
	pop	esi

; 140  : 		{
; 141  : 		_Al.construct(_Unfancy(_Dest), _STD move(*_First));
; 142  : 		}
; 143  : 
; 144  : 	_CATCH_ALL
; 145  : 	_Destroy_range(_Next, _Dest, _Al);
; 146  : 	_RERAISE;
; 147  : 	_CATCH_END
; 148  : 
; 149  : 	return (_Dest);
; 150  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_move_al_unchecked@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$move@AAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > &>, COMDAT

; 1350 : 	{	// forward _Arg as movable

	npad	2
	push	ebp
	mov	ebp, esp

; 1351 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1352 : 	}

	pop	ebp
	ret	0
??$move@AAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Ptr_move_cat@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@std@@YA?AU_Trivially_copyable_ptr_iterator_tag@0@ABQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Ptr_move_cat@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@std@@YA?AU_Trivially_copyable_ptr_iterator_tag@0@ABQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@0@Z PROC ; std::_Ptr_move_cat<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >, COMDAT

; 892  : 	{	// return pointer move optimization category for pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 893  : 	return {};

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 894  : 	}

	pop	ebp
	ret	0
??$_Ptr_move_cat@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@std@@YA?AU_Trivially_copyable_ptr_iterator_tag@0@ABQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@0@Z ENDP ; std::_Ptr_move_cat<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Unchecked@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@PAV10@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@PAV10@@Z PROC ; std::_Unchecked<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *>, COMDAT

; 450  : 	{	// construct unchecked from checked, generic

	npad	2
	push	ebp
	mov	ebp, esp

; 451  : 	return (_Src);

	mov	eax, DWORD PTR __Src$[ebp]

; 452  : 	}

	pop	ebp
	ret	0
??$_Unchecked@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@PAV10@@Z ENDP ; std::_Unchecked<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@1@PAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@1@PAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::destroy<std::pair<ISteamUser * const,IWrapSteamUser *> >, COMDAT

; 965  : 		_Al.destroy(_Ptr);
; 966  : 		}

	ret	0
??$destroy@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@1@PAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::destroy<std::pair<ISteamUser * const,IWrapSteamUser *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninit_alloc_fill_n1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@IU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@PAV10@IABV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_alloc_fill_n1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@IU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@PAV10@IABV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Uninit_alloc_fill_n1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,unsigned int,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >, COMDAT

; 184  : 	{	// copy _Count copies of _Val to raw _First, using _Al, no special optimization

	npad	2
	push	ebp
	mov	ebp, esp

; 188  : 	for (; 0 < _Count; --_Count, (void)++_First)

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	test	edx, edx
	je	SHORT $LN3@Uninit_all
	push	esi
	mov	esi, DWORD PTR __Val$[ebp]
$LL4@Uninit_all:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 710  : 		::new (static_cast<void *>(_Ptr))

	test	eax, eax
	je	SHORT $LN2@Uninit_all
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx
$LN2@Uninit_all:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 188  : 	for (; 0 < _Count; --_Count, (void)++_First)

	add	eax, 4
	sub	edx, 1
	jne	SHORT $LL4@Uninit_all
	pop	esi
$LN3@Uninit_all:

; 189  : 		{
; 190  : 		_Al.construct(_Unfancy(_First), _Val);
; 191  : 		}
; 192  : 
; 193  : 	_CATCH_ALL
; 194  : 	_Destroy_range(_Next, _First, _Al);
; 195  : 	_RERAISE;
; 196  : 	_CATCH_END
; 197  : 
; 198  : 	return (_First);
; 199  : 	}

	pop	ebp
	ret	0
??$_Uninit_alloc_fill_n1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@IU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@PAV10@IABV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Uninit_alloc_fill_n1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,unsigned int,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$_Unfancy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@PAV10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@PAV10@@Z PROC ; std::_Unfancy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >, COMDAT

; 642  : 	{	// do nothing for plain pointers

	npad	2
	push	ebp
	mov	ebp, esp

; 643  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 644  : 	}

	pop	ebp
	ret	0
??$_Unfancy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@PAV10@@Z ENDP ; std::_Unfancy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@1@PAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@1@PAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::destroy<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> *>, COMDAT

; 965  : 		_Al.destroy(_Ptr);
; 966  : 		}

	ret	0
??$destroy@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@1@PAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::destroy<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Fill_unchecked1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@0ABV10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
tv278 = 12						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_unchecked1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@0ABV10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Fill_unchecked1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >, COMDAT

; 2688 : 	{	// copy _Val through [_First, _Last), no special optimization

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR __Last$[ebp]
	xor	edx, edx
	push	ebx
	mov	ebx, DWORD PTR __First$[ebp]
	sub	ecx, ebx
	add	ecx, 3
	shr	ecx, 2
	push	esi
	xor	esi, esi
	cmp	ebx, DWORD PTR __Last$[ebp]
	cmova	ecx, esi
	mov	DWORD PTR tv278[ebp], ecx

; 2689 : 	for (; _First != _Last; ++_First)

	test	ecx, ecx
	je	SHORT $LN3@Fill_unche

; 2690 : 		*_First = _Val;

	mov	esi, DWORD PTR __Val$[ebp]
	push	edi
	cmp	ecx, 4
	jb	SHORT $LN9@Fill_unche
	mov	edi, DWORD PTR [esi]
	cmp	ebx, esi
	ja	SHORT $LN10@Fill_unche
	lea	eax, DWORD PTR [ebx-4]
	lea	eax, DWORD PTR [eax+ecx*4]
	cmp	eax, esi
	jae	SHORT $LN9@Fill_unche
$LN10@Fill_unche:
	and	ecx, -4					; fffffffcH
$LL4@Fill_unche:

; 2689 : 	for (; _First != _Last; ++_First)

	add	edx, 4
	cmp	edx, ecx
	jne	SHORT $LL4@Fill_unche

; 2690 : 		*_First = _Val;

	lea	esi, DWORD PTR [ecx+3]
	mov	eax, edi
	and	esi, -4					; fffffffcH
	mov	edi, ebx
	shl	esi, 2
	mov	ecx, esi
	shr	ecx, 2
	add	ebx, esi
	mov	esi, DWORD PTR __Val$[ebp]
	rep stosd
	mov	ecx, DWORD PTR tv278[ebp]
$LN9@Fill_unche:

; 2689 : 	for (; _First != _Last; ++_First)

	pop	edi
	cmp	edx, ecx
	je	SHORT $LN3@Fill_unche
	npad	6
$LL8@Fill_unche:

; 2690 : 		*_First = _Val;

	mov	eax, DWORD PTR [esi]
	lea	ebx, DWORD PTR [ebx+4]
	inc	edx
	mov	DWORD PTR [ebx-4], eax
	cmp	edx, ecx
	jne	SHORT $LL8@Fill_unche
$LN3@Fill_unche:
	pop	esi
	pop	ebx

; 2691 : 	}

	pop	ebp
	ret	0
??$_Fill_unchecked1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@0ABV10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Fill_unchecked1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Fill_memset_is_safe@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@std@@YA?AU?$integral_constant@_N$0A@@0@ABQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@ABV20@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Fill_memset_is_safe@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@std@@YA?AU?$integral_constant@_N$0A@@0@ABQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@ABV20@@Z PROC ; std::_Fill_memset_is_safe<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >, COMDAT

; 2682 : 	return {};

	xor	al, al

; 2683 : 	}

	ret	0
??$_Fill_memset_is_safe@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@std@@YA?AU?$integral_constant@_N$0A@@0@ABQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@ABV20@@Z ENDP ; std::_Fill_memset_is_safe<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Destroy_range1@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@0AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range1@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@0AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Destroy_range1<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *>, COMDAT

; 1200 : 	for (; _First != _Last; ++_First)
; 1201 : 		_Al.destroy(_Unfancy(_First));
; 1202 : 	}

	ret	0
??$_Destroy_range1@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@0AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Destroy_range1<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??$?0ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@X@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@X@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z PROC ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > ><std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > const &,void>, COMDAT
; _this$ = ecx

; 605  : 		{	// construct head node, allocator from _Al

	npad	2
	push	esi
	mov	esi, ecx

; 731  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

	push	0
	push	0

; 523  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 524  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 731  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

	call	?_Buynode0@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Buynode0

; 606  : 		_Myhead() = _Buyheadnode();

	mov	DWORD PTR [esi], eax

; 607  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??$?0ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@X@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z ENDP ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > ><std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > const &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >,1>::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >,1><std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > const &>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 313  : 		}

	ret	8
??$?0ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >,1>::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >,1><std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@0@ABU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@0@ABU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > const &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@0@ABU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0AAU?$equal_to@PAVISteamUser@@@std@@M@?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@std@@QAE@U_One_then_variadic_args_t@1@AAU?$equal_to@PAVISteamUser@@@1@$$QAM@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
_<_Val2_0>$ = 16					; size = 4
??$?0AAU?$equal_to@PAVISteamUser@@@std@@M@?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@std@@QAE@U_One_then_variadic_args_t@1@AAU?$equal_to@PAVISteamUser@@@1@$$QAM@Z PROC ; std::_Compressed_pair<std::equal_to<ISteamUser *>,float,1>::_Compressed_pair<std::equal_to<ISteamUser *>,float,1><std::equal_to<ISteamUser *> &,float>, COMDAT
; _this$ = ecx

; 312  : 		{	// construct from forwarded values

	npad	2
	push	ebp
	mov	ebp, esp

; 311  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

	mov	eax, DWORD PTR _<_Val2_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 313  : 		}

	mov	eax, ecx
	pop	ebp
	ret	12					; 0000000cH
??$?0AAU?$equal_to@PAVISteamUser@@@std@@M@?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@std@@QAE@U_One_then_variadic_args_t@1@AAU?$equal_to@PAVISteamUser@@@1@$$QAM@Z ENDP ; std::_Compressed_pair<std::equal_to<ISteamUser *>,float,1>::_Compressed_pair<std::equal_to<ISteamUser *>,float,1><std::equal_to<ISteamUser *> &,float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@M@std@@YA$$QAMAAM@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@M@std@@YA$$QAMAAM@Z PROC			; std::forward<float>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@M@std@@YA$$QAMAAM@Z ENDP			; std::forward<float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@AAU?$equal_to@PAVISteamUser@@@std@@@std@@YAAAU?$equal_to@PAVISteamUser@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU?$equal_to@PAVISteamUser@@@std@@@std@@YAAAU?$equal_to@PAVISteamUser@@@0@AAU10@@Z PROC ; std::forward<std::equal_to<ISteamUser *> &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@AAU?$equal_to@PAVISteamUser@@@std@@@std@@YAAAU?$equal_to@PAVISteamUser@@@0@AAU10@@Z ENDP ; std::forward<std::equal_to<ISteamUser *> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@U_One_then_variadic_args_t@std@@@std@@YA$$QAU_One_then_variadic_args_t@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_One_then_variadic_args_t@std@@@std@@YA$$QAU_One_then_variadic_args_t@0@AAU10@@Z PROC ; std::forward<std::_One_then_variadic_args_t>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@U_One_then_variadic_args_t@std@@@std@@YA$$QAU_One_then_variadic_args_t@0@AAU10@@Z ENDP ; std::forward<std::_One_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@AAU?$hash@PAVISteamUser@@@std@@@std@@YAAAU?$hash@PAVISteamUser@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU?$hash@PAVISteamUser@@@std@@@std@@YAAAU?$hash@PAVISteamUser@@@0@AAU10@@Z PROC ; std::forward<std::hash<ISteamUser *> &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@AAU?$hash@PAVISteamUser@@@std@@@std@@YAAAU?$hash@PAVISteamUser@@@0@AAU10@@Z ENDP ; std::forward<std::hash<ISteamUser *> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$?0U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > ><std::pair<ISteamUser * const,IWrapSteamUser *> >, COMDAT
; _this$ = ecx

; 813  : 		}

	mov	eax, ecx
	ret	4
??$?0U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > ><std::pair<ISteamUser * const,IWrapSteamUser *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@YAABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@YAABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@0@ABV10@@Z PROC ; std::forward<std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > const &>, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@YAABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@0@ABV10@@Z ENDP ; std::forward<std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\type_traits
;	COMDAT ??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >, COMDAT

; 1334 : 	{	// forward an lvalue as either an lvalue or an rvalue

	npad	2
	push	ebp
	mov	ebp, esp

; 1335 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1336 : 	}

	pop	ebp
	ret	0
??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YA$$QAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
;	COMDAT ??$_Try_emplace@ABQAVISteamUser@@$$V@?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@ABQAVISteamUser@@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Keyval$ = 12						; size = 4
$T2 = 15						; size = 1
??$_Try_emplace@ABQAVISteamUser@@$$V@?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@ABQAVISteamUser@@@Z PROC ; std::unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Try_emplace<ISteamUser * const &>, COMDAT
; _this$ = ecx

; 306  : 		{	// fail if _Keyval present, else emplace

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 625  : 		return (lower_bound(_Keyval));

	mov	esi, DWORD PTR __Keyval$[ebp]
	lea	eax, DWORD PTR __Where$[ebp]
	push	edi
	push	esi
	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map

; 306  : 		{	// fail if _Keyval present, else emplace

	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 625  : 		return (lower_bound(_Keyval));

	call	?lower_bound@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@ABQAVISteamUser@@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::lower_bound
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 297  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __Where$[ebp]
	cmp	eax, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map

; 308  : 		if (_Where == _Mybase::end())

	jne	SHORT $LN2@Try_emplac

; 309  : 			return (_Mybase::emplace(

	lea	eax, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple

; 164  : 		: _Val(_STD forward<_Other>(_Arg))

	mov	DWORD PTR $T1[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map

; 309  : 			return (_Mybase::emplace(

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, edi
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	push	OFFSET ?piecewise_construct@std@@3Upiecewise_construct_t@1@B
	push	esi
	call	??$emplace@ABUpiecewise_construct_t@std@@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::emplace<std::piecewise_construct_t const &,std::tuple<ISteamUser * const &>,std::tuple<> >
	pop	edi
	mov	eax, esi
	pop	esi

; 315  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN2@Try_emplac:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map

; 314  : 			return (_Pairib(_Where, false));

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map

; 315  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$_Try_emplace@ABQAVISteamUser@@$$V@?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@ABQAVISteamUser@@@Z ENDP ; std::unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Try_emplace<ISteamUser * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Distance1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YAHV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@0Uinput_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Distance1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YAHV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@0Uinput_iterator_tag@0@@Z PROC ; std::_Distance1<std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >, COMDAT

; 1094 : 	{	// return distance between iterators; input

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 297  : 		return (this->_Ptr == _Right._Ptr);

	mov	ecx, DWORD PTR __First$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1095 : 	_Iter_diff_t<_InIt> _Off = 0;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 297  : 		return (this->_Ptr == _Right._Ptr);

	mov	edx, DWORD PTR __Last$[ebp]
	cmp	ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1096 : 	for (; _First != _Last; ++_First)

	je	SHORT $LN3@Distance1
$LL4@Distance1:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 242  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	ecx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1097 : 		++_Off;

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 242  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	DWORD PTR __First$[ebp], ecx

; 297  : 		return (this->_Ptr == _Right._Ptr);

	cmp	ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1096 : 	for (; _First != _Last; ++_First)

	jne	SHORT $LL4@Distance1
$LN3@Distance1:

; 1098 : 
; 1099 : 	return (_Off);
; 1100 : 	}

	pop	ebp
	ret	0
??$_Distance1@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YAHV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@0Uinput_iterator_tag@0@@Z ENDP ; std::_Distance1<std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
$T1 = 16						; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >, COMDAT

; 166  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 167  : 		// note: only called internally from elsewhere in the STL, debug checks
; 168  : 		// and deprecation warnings omitted
; 169  : 	const auto _UFirst = _Unchecked(_First);
; 170  : 	const auto _ULast = _Unchecked(_Last);
; 171  : 	const auto _UDest = _Unchecked(_Dest);
; 172  : 	return (_Rechecked(_Dest,

	push	ecx
	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Al$[ebp]
	push	DWORD PTR __Dest$[ebp]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp]
	call	??$_Uninitialized_move_al_unchecked@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >
	add	esp, 24					; 00000018H

; 173  : 		_Uninitialized_move_al_unchecked(_UFirst, _ULast, _UDest, _Al,
; 174  : 			_Ptr_move_cat(_UFirst, _UDest),
; 175  : 			_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_UDest)), decltype(_STD move(*_UFirst))>())));
; 176  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_move@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@_Alloc_max_size@std@@SAIHABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Al$ = 12						; size = 4
??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@_Alloc_max_size@std@@SAIHABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@@Z PROC ; std::_Alloc_max_size::_Fn<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >, COMDAT

; 622  : 		return (_Al.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 623  : 		}

	ret	0
??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@_Alloc_max_size@std@@SAIHABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Alloc_max_size::_Fn<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@YAPAV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::destroy<std::pair<ISteamUser * const,IWrapSteamUser *> >, COMDAT
; _this$ = ecx

; 1103 : 		_Mytraits::destroy(*this, _Ptr);
; 1104 : 		}

	ret	4
??$destroy@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::destroy<std::pair<ISteamUser * const,IWrapSteamUser *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
;	COMDAT ??$_Uninitialized_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@IU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@PAV10@IABV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@IU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@PAV10@IABV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_fill_n<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,unsigned int,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >, COMDAT

; 216  : 	{	// copy _Count copies of _Val to raw _First, using _Al

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 217  : 	return (_Uninit_alloc_fill_n1(_First, _Count, _Val, _Al,

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Al$[ebp]
	push	DWORD PTR __Val$[ebp]
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __First$[ebp]
	call	??$_Uninit_alloc_fill_n1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@IU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@PAV10@IABV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninit_alloc_fill_n1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,unsigned int,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >
	add	esp, 20					; 00000014H

; 218  : 		_Conjunction_t<decltype(_Fill_memset_is_safe(_First, _Val)),
; 219  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First)), decltype(_Val)>>()));
; 220  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_fill_n@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@IU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@PAV10@IABV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_fill_n<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,unsigned int,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@YAPBV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@YAPBV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@0@ABV10@@Z PROC ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > const >, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@$$CBV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@YAPBV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@0@ABV10@@Z ENDP ; std::addressof<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$destroy@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::destroy<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> *>, COMDAT
; _this$ = ecx

; 1103 : 		_Mytraits::destroy(*this, _Ptr);
; 1104 : 		}

	ret	4
??$destroy@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::destroy<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> *>, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@YAPAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$_Fill_unchecked@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@0ABV10@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill_unchecked@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@0ABV10@@Z PROC ; std::_Fill_unchecked<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >, COMDAT

; 2703 : 	{	// copy _Val through [_First, _Last), choose optimization

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 2682 : 	return {};

	mov	BYTE PTR $T1[ebp], 0

; 2704 : 	_Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Val$[ebp]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp]
	call	??$_Fill_unchecked1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@0ABV10@U?$integral_constant@_N$0A@@0@@Z ; std::_Fill_unchecked1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
	add	esp, 16					; 00000010H

; 2705 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Fill_unchecked@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@0ABV10@@Z ENDP ; std::_Fill_unchecked<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@0AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@0AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *>, COMDAT

; 1215 : 		// note that this is an optimization for debug mode codegen;
; 1216 : 		// in release mode the BE removes all of this
; 1217 : 	typedef typename _Alloc::value_type _Val;
; 1218 : 	_Destroy_range1(_First, _Last, _Al, _Conjunction_t<
; 1219 : 		is_trivially_destructible<_Val>,
; 1220 : 		_Uses_default_destroy<_Alloc, _Val *>>());
; 1221 : 	}

	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@0AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??$?0ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@X@?$_List_buy@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 4
??$?0ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@X@?$_List_buy@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z PROC ; std::_List_buy<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_List_buy<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > ><std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > const &,void>, COMDAT
; _this$ = ecx

; 841  : 		{	// construct from allocator

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 731  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

	push	0
	push	0

; 841  : 		{	// construct from allocator

	mov	DWORD PTR _this$[ebp], esi

; 523  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 524  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 731  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

	call	?_Buynode0@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Buynode0

; 606  : 		_Myhead() = _Buyheadnode();

	mov	DWORD PTR [esi], eax

; 842  : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@X@?$_List_buy@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z ENDP ; std::_List_buy<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_List_buy<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > ><std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > const &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??$?0ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > ><std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > const &,void>, COMDAT
; _this$ = ecx

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 517  : 		}

	mov	eax, ecx

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 517  : 		}

	ret	4
??$?0ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > ><std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > const &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??F?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator--, COMDAT
; _this$ = ecx

; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx], eax

; 152  : 		--(*(_Mybase *)this);
; 153  : 		return (*this);

	mov	eax, ecx

; 154  : 		}

	ret	0
??F?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator++, COMDAT
; _this$ = ecx

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [ecx]

; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 139  : 		++(*(_Mybase *)this);
; 140  : 		return (*this);

	mov	eax, ecx

; 141  : 		}

	ret	0
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QBEAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@XZ
_TEXT	SEGMENT
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QBEAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator*, COMDAT
; _this$ = ecx

; 540  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR [ecx]
	add	eax, 8

; 129  : 		return ((reference)**(_Mybase *)this);
; 130  : 		}

	ret	0
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QBEAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >, COMDAT
; _this$ = ecx

; 124  : 		{	// construct with node pointer _Pnode

	npad	2
	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], eax

; 125  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >, COMDAT
; _this$ = ecx

; 38   : 		: _Ptr()

	mov	DWORD PTR [ecx], 0

; 119  : 		{	// construct with null node
; 120  : 		}

	mov	eax, ecx
	ret	0
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??$addressof@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@YAPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@YAPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@0@AAU10@@Z PROC ; std::addressof<std::pair<ISteamUser * const,IWrapSteamUser *> >, COMDAT

; 629  : 	{	// return address of _Val

	npad	2
	push	ebp
	mov	ebp, esp

; 630  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 631  : 	}

	pop	ebp
	ret	0
??$addressof@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@YAPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<ISteamUser * const,IWrapSteamUser *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$?0AAU?$hash@PAVISteamUser@@@std@@U_One_then_variadic_args_t@1@AAU?$equal_to@PAVISteamUser@@@1@M@?$_Compressed_pair@U?$hash@PAVISteamUser@@@std@@V?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@AAU?$hash@PAVISteamUser@@@1@$$QAU21@AAU?$equal_to@PAVISteamUser@@@1@$$QAM@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
_<_Val2_0>$ = 16					; size = 4
_<_Val2_1>$ = 20					; size = 4
_<_Val2_2>$ = 24					; size = 4
??$?0AAU?$hash@PAVISteamUser@@@std@@U_One_then_variadic_args_t@1@AAU?$equal_to@PAVISteamUser@@@1@M@?$_Compressed_pair@U?$hash@PAVISteamUser@@@std@@V?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@AAU?$hash@PAVISteamUser@@@1@$$QAU21@AAU?$equal_to@PAVISteamUser@@@1@$$QAM@Z PROC ; std::_Compressed_pair<std::hash<ISteamUser *>,std::_Compressed_pair<std::equal_to<ISteamUser *>,float,1>,1>::_Compressed_pair<std::hash<ISteamUser *>,std::_Compressed_pair<std::equal_to<ISteamUser *>,float,1>,1><std::hash<ISteamUser *> &,std::_One_then_variadic_args_t,std::equal_to<ISteamUser *> &,float>, COMDAT
; _this$ = ecx

; 312  : 		{	// construct from forwarded values

	npad	2
	push	ebp
	mov	ebp, esp

; 311  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

	mov	eax, DWORD PTR _<_Val2_2>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 313  : 		}

	mov	eax, ecx
	pop	ebp
	ret	20					; 00000014H
??$?0AAU?$hash@PAVISteamUser@@@std@@U_One_then_variadic_args_t@1@AAU?$equal_to@PAVISteamUser@@@1@M@?$_Compressed_pair@U?$hash@PAVISteamUser@@@std@@V?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@AAU?$hash@PAVISteamUser@@@1@$$QAU21@AAU?$equal_to@PAVISteamUser@@@1@$$QAM@Z ENDP ; std::_Compressed_pair<std::hash<ISteamUser *>,std::_Compressed_pair<std::equal_to<ISteamUser *>,float,1>,1>::_Compressed_pair<std::hash<ISteamUser *>,std::_Compressed_pair<std::equal_to<ISteamUser *>,float,1>,1><std::hash<ISteamUser *> &,std::_One_then_variadic_args_t,std::equal_to<ISteamUser *> &,float>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??$?0ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > ><std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > const &>, COMDAT
; _this$ = ecx

; 1054 : 		}

	mov	eax, ecx
	ret	4
??$?0ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > ><std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
;	COMDAT ??$?0V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V01@X$0A@@?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@std@@QAE@$$QAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V01@X$0A@@?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@std@@QAE@$$QAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@0@Z PROC ; std::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > ><std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,void,0>, COMDAT
; _this$ = ecx

; 189  : 		{	// construct from moved values

	npad	2
	push	ebp
	mov	ebp, esp

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax

; 190  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??$?0V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V01@X$0A@@?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@std@@QAE@$$QAV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@0@Z ENDP ; std::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > ><std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
;	COMDAT ??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V01@X$0A@@?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@std@@QAE@$$QAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V01@X$0A@@?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@std@@QAE@$$QAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@0@Z PROC ; std::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > ><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,void,0>, COMDAT
; _this$ = ecx

; 189  : 		{	// construct from moved values

	npad	2
	push	ebp
	mov	ebp, esp

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax

; 190  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V01@X$0A@@?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@std@@QAE@$$QAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@0@Z ENDP ; std::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::pair<std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > ><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
;	COMDAT ??$_Kfn@QAVISteamUser@@PAVIWrapSteamUser@@@?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@SAABQAVISteamUser@@ABU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Kfn@QAVISteamUser@@PAVIWrapSteamUser@@@?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@SAABQAVISteamUser@@ABU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@@Z PROC ; std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0>::_Kfn<ISteamUser * const,IWrapSteamUser *>, COMDAT

; 66   : 		{	// extract key from element value

	npad	2
	push	ebp
	mov	ebp, esp

; 67   : 		return (_Val.first);

	mov	eax, DWORD PTR __Val$[ebp]

; 68   : 		}

	pop	ebp
	ret	0
??$_Kfn@QAVISteamUser@@PAVIWrapSteamUser@@@?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@SAABQAVISteamUser@@ABU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@@Z ENDP ; std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0>::_Kfn<ISteamUser * const,IWrapSteamUser *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@SAPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@2@AAU32@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@SAPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@2@AAU32@@Z PROC ; std::pointer_traits<std::pair<ISteamUser * const,IWrapSteamUser *> *>::pointer_to, COMDAT

; 289  : 		{	// convert raw reference to pointer

	npad	2
	push	ebp
	mov	ebp, esp

; 290  : 		return (_STD addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 291  : 		}

	pop	ebp
	ret	0
?pointer_to@?$pointer_traits@PAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@SAPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@2@AAU32@@Z ENDP ; std::pointer_traits<std::pair<ISteamUser * const,IWrapSteamUser *> *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QBEPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@XZ
_TEXT	SEGMENT
??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QBEPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator->, COMDAT
; _this$ = ecx

; 540  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR [ecx]
	add	eax, 8

; 367  : 		return (pointer_traits<pointer>::pointer_to(**this));
; 368  : 		}

	ret	0
??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QBEPAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QBEAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@XZ
_TEXT	SEGMENT
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QBEAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator*, COMDAT
; _this$ = ecx

; 540  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR [ecx]
	add	eax, 8

; 362  : 		return ((reference)**(_Mybase *)this);
; 363  : 		}

	ret	0
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QBEAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Unchecked@?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QBE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked@?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QBE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Unchecked, COMDAT
; _this$ = ecx

; 356  : 		{	// make an unchecked iterator

	npad	2
	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 357  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 358  : 		}

	pop	ebp
	ret	4
?_Unchecked@?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QBE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >, COMDAT
; _this$ = ecx

; 344  : 		{	// construct with node pointer _Pnode

	npad	2
	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], eax

; 345  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
;	COMDAT ??$try_emplace@$$V@?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@ABQAVISteamUser@@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$2 = 12						; size = 4
__Keyval$ = 12						; size = 4
$T3 = 15						; size = 1
??$try_emplace@$$V@?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@ABQAVISteamUser@@@Z PROC ; std::unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::try_emplace<>, COMDAT
; _this$ = ecx

; 320  : 		{	// fail if _Keyval present, else emplace

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 625  : 		return (lower_bound(_Keyval));

	mov	esi, DWORD PTR __Keyval$[ebp]
	lea	eax, DWORD PTR __Where$2[ebp]
	push	edi
	push	esi
	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map

; 320  : 		{	// fail if _Keyval present, else emplace

	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 625  : 		return (lower_bound(_Keyval));

	call	?lower_bound@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@ABQAVISteamUser@@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::lower_bound
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 297  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __Where$2[ebp]
	cmp	eax, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map

; 308  : 		if (_Where == _Mybase::end())

	jne	SHORT $LN4@try_emplac

; 309  : 			return (_Mybase::emplace(

	lea	eax, DWORD PTR $T3[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple

; 164  : 		: _Val(_STD forward<_Other>(_Arg))

	mov	DWORD PTR $T1[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map

; 309  : 			return (_Mybase::emplace(

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, edi
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	push	OFFSET ?piecewise_construct@std@@3Upiecewise_construct_t@1@B
	push	esi
	call	??$emplace@ABUpiecewise_construct_t@std@@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::emplace<std::piecewise_construct_t const &,std::tuple<ISteamUser * const &>,std::tuple<> >
	pop	edi

; 321  : 		return (_Try_emplace(_Keyval, _STD forward<_Mappedty>(_Mapval)...));

	mov	eax, esi
	pop	esi

; 322  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN4@try_emplac:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map

; 321  : 		return (_Try_emplace(_Keyval, _STD forward<_Mappedty>(_Mapval)...));

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map

; 322  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$try_emplace@$$V@?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@ABQAVISteamUser@@@Z ENDP ; std::unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::try_emplace<>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ??$distance@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YAHV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$distance@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YAHV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@0@Z PROC ; std::distance<std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >, COMDAT

; 1112 : 	{	// return distance between iterators

	npad	2
	push	ebp
	mov	ebp, esp

; 1113 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));

	mov	ecx, DWORD PTR __First$[ebp]

; 1095 : 	_Iter_diff_t<_InIt> _Off = 0;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 297  : 		return (this->_Ptr == _Right._Ptr);

	mov	edx, DWORD PTR __Last$[ebp]
	cmp	ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1096 : 	for (; _First != _Last; ++_First)

	je	SHORT $LN5@distance
$LL6@distance:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 242  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	ecx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1097 : 		++_Off;

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 297  : 		return (this->_Ptr == _Right._Ptr);

	cmp	ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1096 : 	for (; _First != _Last; ++_First)

	jne	SHORT $LL6@distance
$LN5@distance:

; 1114 : 	}

	pop	ebp
	ret	0
??$distance@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@YAHV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@0@Z ENDP ; std::distance<std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator!=, COMDAT
; _this$ = ecx

; 301  : 		{	// test for iterator inequality

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 302  : 		return (!(*this == _Right));
; 303  : 		}

	pop	ebp
	ret	4
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator==, COMDAT
; _this$ = ecx

; 286  : 		{	// test for iterator equality

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 287  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 288  : 		if (this->_Getcont() != _Right._Getcont())
; 289  : 			{	// report error
; 290  : 			_DEBUG_ERROR("list iterators incompatible");
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 295  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 296  : 
; 297  : 		return (this->_Ptr == _Right._Ptr);
; 298  : 		}

	pop	ebp
	ret	4
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator++, COMDAT
; _this$ = ecx

; 247  : 		{	// postincrement

	npad	2
	push	ebp
	mov	ebp, esp

; 248  : 		_Myiter _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx

; 242  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], edx

; 249  : 		++*this;
; 250  : 		return (_Tmp);
; 251  : 		}

	pop	ebp
	ret	8
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator++, COMDAT
; _this$ = ecx

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [ecx]

; 226  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 227  : 		const auto _Mycont = static_cast<const _Mylist *>(this->_Getcont());
; 228  : 		if (_Mycont == 0
; 229  : 			|| this->_Ptr == nullptr_t{}
; 230  : 			|| this->_Ptr == _Mycont->_Myhead)
; 231  : 			{	// report error
; 232  : 			_DEBUG_ERROR("list iterator not incrementable");
; 233  : 			}
; 234  : 
; 235  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 236  : 		_SCL_SECURE_VALIDATE(this->_Ptr != nullptr_t{});
; 237  : 		const auto _Mycont = static_cast<const _Mylist *>(this->_Getcont());
; 238  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 239  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr != _Mycont->_Myhead);
; 240  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 241  : 
; 242  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 243  : 		return (*this);

	mov	eax, ecx

; 244  : 		}

	ret	0
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QBEABU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@XZ
_TEXT	SEGMENT
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QBEABU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator*, COMDAT
; _this$ = ecx

; 540  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR [ecx]
	add	eax, 8

; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		const auto _Mycont = static_cast<const _Mylist *>(this->_Getcont());
; 207  : 		if (_Mycont == 0
; 208  : 			|| this->_Ptr == nullptr_t{}
; 209  : 			|| this->_Ptr == _Mycont->_Myhead)
; 210  : 			{	// report error
; 211  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Ptr != nullptr_t{});
; 216  : 		const auto _Mycont = static_cast<const _Mylist *>(this->_Getcont());
; 217  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 218  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr != _Mycont->_Myhead);
; 219  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 220  : 
; 221  : 		return (_Mylist::_Myval(this->_Ptr));
; 222  : 		}

	ret	0
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QBEABU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >, COMDAT
; _this$ = ecx

; 187  : 		{	// construct with node pointer _Pnode

	npad	2
	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], eax

; 188  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@QAE@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 96   : 		return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 97   : 		}

	ret	0
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>::operator!=, COMDAT
; _this$ = ecx

; 90   : 		{	// test for iterator inequality

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 91   : 		return (!(*this == _Right));
; 92   : 		}

	pop	ebp
	ret	4
??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>::operator==, COMDAT
; _this$ = ecx

; 85   : 		{	// test for iterator equality

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 86   : 		return (_Ptr == _Right._Ptr);
; 87   : 		}

	pop	ebp
	ret	4
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBE_NABV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx], eax

; 74   : 		return (*this);

	mov	eax, ecx

; 75   : 		}

	ret	0
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [ecx]

; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 61   : 		return (*this);

	mov	eax, ecx

; 62   : 		}

	ret	0
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@XZ
_TEXT	SEGMENT
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>::operator*, COMDAT
; _this$ = ecx

; 540  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR [ecx]
	add	eax, 8

; 50   : 		return (_Mylist::_Myval(_Ptr));
; 51   : 		}

	ret	0
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEABU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 44   : 		{	// construct with node pointer _Pnode

	npad	2
	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@1@PBV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 38   : 		: _Ptr()

	mov	DWORD PTR [ecx], 0

; 40   : 		}

	mov	eax, ecx
	ret	0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
_TEXT	SEGMENT
$T1 = -20						; size = 8
$T2 = -20						; size = 8
__Ans$3 = -12						; size = 8
$T4 = -8						; size = 4
$T5 = -8						; size = 4
_pUser$ = -4						; size = 4
__Where$6 = 8						; size = 4
__Where$7 = 8						; size = 4
$T8 = 8							; size = 4
_This$ = 8						; size = 4
$T9 = 11						; size = 1
$T10 = 11						; size = 1
_hSteamUser$ = 12					; size = 4
_hSteamPipe$ = 16					; size = 4
_pchVersion$ = 20					; size = 4
?SK_SteamWrapper_WrappedClient_GetISteamUser@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z PROC ; SK_SteamWrapper_WrappedClient_GetISteamUser

; 291  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 292  :   SK_RunOnce (

	cmp	BYTE PTR ?first@?2??SK_SteamWrapper_WrappedClient_GetISteamUser@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z@4_NA, 0
	push	esi
	mov	esi, DWORD PTR _pchVersion$[ebp]
	je	SHORT $LN2@SK_SteamWr
	push	esi
	push	OFFSET $SG147878
	push	OFFSET $SG147879
	push	OFFSET ?steam_log@@3UiSK_Logger@@A	; steam_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H
	mov	BYTE PTR ?first@?2??SK_SteamWrapper_WrappedClient_GetISteamUser@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z@4_NA, 0
$LN2@SK_SteamWr:

; 293  :     steam_log.Log ( L"[!] %hs (..., %hs)",
; 294  :                       __FUNCTION__, pchVersion )
; 295  :   );
; 296  : 
; 297  :   ISteamUser* pUser =
; 298  :     This->GetISteamUser ( hSteamUser,

	mov	ecx, DWORD PTR _This$[ebp]
	push	esi
	push	DWORD PTR _hSteamPipe$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR _hSteamUser$[ebp]
	call	DWORD PTR [eax+20]
	mov	DWORD PTR _pUser$[ebp], eax

; 299  :                             hSteamPipe,
; 300  :                               pchVersion );
; 301  : 
; 302  :   if (pUser != nullptr)

	test	eax, eax
	je	$LN5@SK_SteamWr

; 303  :   {
; 304  :     if ((! lstrcmpA (pchVersion, STEAMUSER_INTERFACE_VERSION_018)) ||
; 305  :         (! lstrcmpA (pchVersion, STEAMUSER_INTERFACE_VERSION_019)) ||

	push	edi
	mov	edi, DWORD PTR __imp__lstrcmpA@8
	push	OFFSET $SG147884
	push	esi
	call	edi
	test	eax, eax
	je	SHORT $LN6@SK_SteamWr
	push	OFFSET $SG147885
	push	esi
	call	edi
	test	eax, eax
	je	SHORT $LN6@SK_SteamWr
	push	OFFSET $SG147886
	push	esi
	call	edi
	test	eax, eax
	je	SHORT $LN6@SK_SteamWr

; 317  :       }
; 318  :     }
; 319  : 
; 320  :     else
; 321  :     {
; 322  :       SK_RunOnce (

	cmp	BYTE PTR ?first@?BD@??SK_SteamWrapper_WrappedClient_GetISteamUser@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z@4_NA, 0
	je	SHORT $LN9@SK_SteamWr
	push	esi
	push	OFFSET $SG147891
	push	OFFSET ?steam_log@@3UiSK_Logger@@A	; steam_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
	mov	BYTE PTR ?first@?BD@??SK_SteamWrapper_WrappedClient_GetISteamUser@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z@4_NA, 0
$LN9@SK_SteamWr:

; 323  :         steam_log.Log ( L"Game requested unexpected interface version (%hs)!",
; 324  :                           pchVersion )
; 325  :       );
; 326  : 
; 327  :       return pUser;

	mov	eax, DWORD PTR _pUser$[ebp]
	pop	edi
	pop	esi

; 332  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@SK_SteamWr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 635  : 		_Paircc _Ans = equal_range(_Keyval);

	lea	eax, DWORD PTR _pUser$[ebp]
	mov	ecx, OFFSET ?SK_SteamWrapper_remap_user@@3V?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@A ; SK_SteamWrapper_remap_user
	push	eax
	lea	eax, DWORD PTR __Ans$3[ebp]
	push	eax
	call	?equal_range@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@2@ABQAVISteamUser@@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::equal_range
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1113 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));

	mov	eax, DWORD PTR __Ans$3[ebp]

; 1095 : 	_Iter_diff_t<_InIt> _Off = 0;

	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 297  : 		return (this->_Ptr == _Right._Ptr);

	mov	ecx, DWORD PTR __Ans$3[ebp+4]
	cmp	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1096 : 	for (; _First != _Last; ++_First)

	je	SHORT $LN7@SK_SteamWr
$LL21@SK_SteamWr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 242  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1097 : 		++_Off;

	inc	edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 297  : 		return (this->_Ptr == _Right._Ptr);

	cmp	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1096 : 	for (; _First != _Last; ++_First)

	jne	SHORT $LL21@SK_SteamWr
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp

; 308  :       if (SK_SteamWrapper_remap_user.count (pUser))

	test	edx, edx
	jne	SHORT $LN329@SK_SteamWr
$LN7@SK_SteamWr:

; 313  :         SK_SteamWrapper_remap_user [pUser] =

	push	8
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T8[ebp], esi
	test	esi, esi
	je	SHORT $LN11@SK_SteamWr
	mov	ecx, DWORD PTR _pUser$[ebp]

; 25   :                    pRealUser (pUser) {

	mov	DWORD PTR [esi], OFFSET ??_7IWrapSteamUser@@6B@
	mov	DWORD PTR [esi+4], ecx

; 313  :         SK_SteamWrapper_remap_user [pUser] =

	jmp	SHORT $LN12@SK_SteamWr
$LN11@SK_SteamWr:
	xor	esi, esi
$LN12@SK_SteamWr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 625  : 		return (lower_bound(_Keyval));

	lea	eax, DWORD PTR _pUser$[ebp]
	mov	ecx, OFFSET ?SK_SteamWrapper_remap_user@@3V?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@A ; SK_SteamWrapper_remap_user
	push	eax
	lea	eax, DWORD PTR __Where$7[ebp]
	push	eax
	call	?lower_bound@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@ABQAVISteamUser@@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::lower_bound
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 297  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __Where$7[ebp]
	cmp	eax, DWORD PTR ?SK_SteamWrapper_remap_user@@3V?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@A+4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map

; 308  : 		if (_Where == _Mybase::end())

	jne	SHORT $LN137@SK_SteamWr
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple

; 164  : 		: _Val(_STD forward<_Other>(_Arg))

	lea	eax, DWORD PTR _pUser$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map

; 309  : 			return (_Mybase::emplace(

	mov	ecx, OFFSET ?SK_SteamWrapper_remap_user@@3V?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@A ; SK_SteamWrapper_remap_user
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple

; 164  : 		: _Val(_STD forward<_Other>(_Arg))

	mov	DWORD PTR $T5[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map

; 309  : 			return (_Mybase::emplace(

	lea	eax, DWORD PTR $T10[ebp]
	push	eax
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	push	OFFSET ?piecewise_construct@std@@3Upiecewise_construct_t@1@B
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??$emplace@ABUpiecewise_construct_t@std@@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::emplace<std::piecewise_construct_t const &,std::tuple<ISteamUser * const &>,std::tuple<> >
	mov	eax, DWORD PTR $T1[ebp]
$LN137@SK_SteamWr:
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp

; 313  :         SK_SteamWrapper_remap_user [pUser] =

	mov	DWORD PTR [eax+12], esi
$LN329@SK_SteamWr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 625  : 		return (lower_bound(_Keyval));

	lea	eax, DWORD PTR _pUser$[ebp]
	mov	ecx, OFFSET ?SK_SteamWrapper_remap_user@@3V?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@A ; SK_SteamWrapper_remap_user
	push	eax
	lea	eax, DWORD PTR __Where$6[ebp]
	push	eax
	call	?lower_bound@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@ABQAVISteamUser@@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::lower_bound
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 297  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __Where$6[ebp]
	cmp	eax, DWORD PTR ?SK_SteamWrapper_remap_user@@3V?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@A+4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map

; 308  : 		if (_Where == _Mybase::end())

	jne	SHORT $LN233@SK_SteamWr
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple

; 164  : 		: _Val(_STD forward<_Other>(_Arg))

	lea	eax, DWORD PTR _pUser$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map

; 309  : 			return (_Mybase::emplace(

	mov	ecx, OFFSET ?SK_SteamWrapper_remap_user@@3V?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@A ; SK_SteamWrapper_remap_user
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple

; 164  : 		: _Val(_STD forward<_Other>(_Arg))

	mov	DWORD PTR $T4[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map

; 309  : 			return (_Mybase::emplace(

	lea	eax, DWORD PTR $T9[ebp]
	push	eax
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	push	OFFSET ?piecewise_construct@std@@3Upiecewise_construct_t@1@B
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??$emplace@ABUpiecewise_construct_t@std@@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::emplace<std::piecewise_construct_t const &,std::tuple<ISteamUser * const &>,std::tuple<> >
	mov	eax, DWORD PTR $T2[ebp]
$LN233@SK_SteamWr:
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp

; 316  :         return SK_SteamWrapper_remap_user [pUser];

	mov	eax, DWORD PTR [eax+12]
	pop	edi
	pop	esi

; 332  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@SK_SteamWr:

; 328  :     }
; 329  :   }
; 330  : 
; 331  :   return nullptr;

	xor	eax, eax
	pop	esi

; 332  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SK_SteamWrapper_WrappedClient_GetISteamUser@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z ENDP ; SK_SteamWrapper_WrappedClient_GetISteamUser
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
_TEXT	SEGMENT
$T1 = -24						; size = 8
$T2 = -24						; size = 8
__Ans$3 = -16						; size = 8
$T4 = -12						; size = 4
__Where$5 = -12						; size = 4
$T6 = -12						; size = 4
__Where$7 = -12						; size = 4
$T8 = -12						; size = 4
_pUser$ = -8						; size = 4
$T9 = -1						; size = 1
$T10 = -1						; size = 1
_This$ = 8						; size = 4
_hSteamUser$ = 12					; size = 4
_hSteamPipe$ = 16					; size = 4
_pchVersion$ = 20					; size = 4
?SteamAPI_ISteamClient_GetISteamUser_Detour@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z PROC ; SteamAPI_ISteamClient_GetISteamUser_Detour

; 241  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 242  :   SK_RunOnce (

	cmp	BYTE PTR ?first@?2??SteamAPI_ISteamClient_GetISteamUser_Detour@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z@4_NA, 0
	push	esi
	mov	esi, DWORD PTR _pchVersion$[ebp]
	je	SHORT $LN2@SteamAPI_I
	push	esi
	push	OFFSET $SG147848
	push	OFFSET $SG147849
	push	OFFSET ?steam_log@@3UiSK_Logger@@A	; steam_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 16					; 00000010H
	mov	BYTE PTR ?first@?2??SteamAPI_ISteamClient_GetISteamUser_Detour@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z@4_NA, 0
$LN2@SteamAPI_I:

; 243  :     steam_log.Log ( L"[!] %hs (..., %hs)",
; 244  :                       __FUNCTION__, pchVersion )
; 245  :   );
; 246  : 
; 247  :   ISteamUser* pUser =
; 248  :     SteamAPI_ISteamClient_GetISteamUser_Original ( This,

	push	esi
	push	DWORD PTR _hSteamPipe$[ebp]
	push	DWORD PTR _hSteamUser$[ebp]
	push	DWORD PTR _This$[ebp]
	call	DWORD PTR ?SteamAPI_ISteamClient_GetISteamUser_Original@@3P6APAVISteamUser@@PAVISteamClient@@HHPBD@ZA ; SteamAPI_ISteamClient_GetISteamUser_Original
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pUser$[ebp], eax

; 249  :                                                      hSteamUser,
; 250  :                                                        hSteamPipe,
; 251  :                                                          pchVersion );
; 252  : 
; 253  :   if (pUser != nullptr)

	test	eax, eax
	je	$LN5@SteamAPI_I

; 254  :   {
; 255  :     if ((! lstrcmpA (pchVersion, STEAMUSER_INTERFACE_VERSION_018)) ||
; 256  :         (! lstrcmpA (pchVersion, STEAMUSER_INTERFACE_VERSION_019)) ||

	push	edi
	mov	edi, DWORD PTR __imp__lstrcmpA@8
	push	OFFSET $SG147854
	push	esi
	call	edi
	test	eax, eax
	je	SHORT $LN6@SteamAPI_I
	push	OFFSET $SG147855
	push	esi
	call	edi
	test	eax, eax
	je	SHORT $LN6@SteamAPI_I
	push	OFFSET $SG147856
	push	esi
	call	edi
	test	eax, eax
	je	SHORT $LN6@SteamAPI_I

; 268  :       }
; 269  :     }
; 270  : 
; 271  :     else
; 272  :     {
; 273  :       SK_RunOnce (

	cmp	BYTE PTR ?first@?BD@??SteamAPI_ISteamClient_GetISteamUser_Detour@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z@4_NA, 0
	je	SHORT $LN9@SteamAPI_I
	push	esi
	push	OFFSET $SG147861
	push	OFFSET ?steam_log@@3UiSK_Logger@@A	; steam_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
	mov	BYTE PTR ?first@?BD@??SteamAPI_ISteamClient_GetISteamUser_Detour@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z@4_NA, 0
$LN9@SteamAPI_I:

; 274  :         steam_log.Log ( L"Game requested unexpected interface version (%hs)!",
; 275  :                           pchVersion )
; 276  :       );
; 277  : 
; 278  :       return pUser;

	mov	eax, DWORD PTR _pUser$[ebp]
	pop	edi
	pop	esi

; 283  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@SteamAPI_I:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 635  : 		_Paircc _Ans = equal_range(_Keyval);

	lea	eax, DWORD PTR _pUser$[ebp]
	mov	ecx, OFFSET ?SK_SteamWrapper_remap_user@@3V?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@A ; SK_SteamWrapper_remap_user
	push	eax
	lea	eax, DWORD PTR __Ans$3[ebp]
	push	eax
	call	?equal_range@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@2@ABQAVISteamUser@@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::equal_range
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1113 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));

	mov	eax, DWORD PTR __Ans$3[ebp]

; 1095 : 	_Iter_diff_t<_InIt> _Off = 0;

	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 297  : 		return (this->_Ptr == _Right._Ptr);

	mov	ecx, DWORD PTR __Ans$3[ebp+4]
	cmp	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1096 : 	for (; _First != _Last; ++_First)

	je	SHORT $LN7@SteamAPI_I
$LL21@SteamAPI_I:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 242  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1097 : 		++_Off;

	inc	edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 297  : 		return (this->_Ptr == _Right._Ptr);

	cmp	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1096 : 	for (; _First != _Last; ++_First)

	jne	SHORT $LL21@SteamAPI_I
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp

; 259  :       if (SK_SteamWrapper_remap_user.count (pUser))

	test	edx, edx
	jne	SHORT $LN329@SteamAPI_I
$LN7@SteamAPI_I:

; 264  :         SK_SteamWrapper_remap_user [pUser] =

	push	8
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T8[ebp], esi
	test	esi, esi
	je	SHORT $LN11@SteamAPI_I
	mov	ecx, DWORD PTR _pUser$[ebp]

; 25   :                    pRealUser (pUser) {

	mov	DWORD PTR [esi], OFFSET ??_7IWrapSteamUser@@6B@
	mov	DWORD PTR [esi+4], ecx

; 264  :         SK_SteamWrapper_remap_user [pUser] =

	jmp	SHORT $LN12@SteamAPI_I
$LN11@SteamAPI_I:
	xor	esi, esi
$LN12@SteamAPI_I:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 625  : 		return (lower_bound(_Keyval));

	lea	eax, DWORD PTR _pUser$[ebp]
	mov	ecx, OFFSET ?SK_SteamWrapper_remap_user@@3V?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@A ; SK_SteamWrapper_remap_user
	push	eax
	lea	eax, DWORD PTR __Where$7[ebp]
	push	eax
	call	?lower_bound@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@ABQAVISteamUser@@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::lower_bound
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 297  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __Where$7[ebp]
	cmp	eax, DWORD PTR ?SK_SteamWrapper_remap_user@@3V?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@A+4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map

; 308  : 		if (_Where == _Mybase::end())

	jne	SHORT $LN137@SteamAPI_I
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple

; 164  : 		: _Val(_STD forward<_Other>(_Arg))

	lea	eax, DWORD PTR _pUser$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map

; 309  : 			return (_Mybase::emplace(

	mov	ecx, OFFSET ?SK_SteamWrapper_remap_user@@3V?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@A ; SK_SteamWrapper_remap_user
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple

; 164  : 		: _Val(_STD forward<_Other>(_Arg))

	mov	DWORD PTR $T6[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map

; 309  : 			return (_Mybase::emplace(

	lea	eax, DWORD PTR $T10[ebp]
	push	eax
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	push	OFFSET ?piecewise_construct@std@@3Upiecewise_construct_t@1@B
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??$emplace@ABUpiecewise_construct_t@std@@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::emplace<std::piecewise_construct_t const &,std::tuple<ISteamUser * const &>,std::tuple<> >
	mov	eax, DWORD PTR $T1[ebp]
$LN137@SteamAPI_I:
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp

; 264  :         SK_SteamWrapper_remap_user [pUser] =

	mov	DWORD PTR [eax+12], esi
$LN329@SteamAPI_I:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 625  : 		return (lower_bound(_Keyval));

	lea	eax, DWORD PTR _pUser$[ebp]
	mov	ecx, OFFSET ?SK_SteamWrapper_remap_user@@3V?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@A ; SK_SteamWrapper_remap_user
	push	eax
	lea	eax, DWORD PTR __Where$5[ebp]
	push	eax
	call	?lower_bound@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@ABQAVISteamUser@@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::lower_bound
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 297  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __Where$5[ebp]
	cmp	eax, DWORD PTR ?SK_SteamWrapper_remap_user@@3V?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@A+4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map

; 308  : 		if (_Where == _Mybase::end())

	jne	SHORT $LN233@SteamAPI_I
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple

; 164  : 		: _Val(_STD forward<_Other>(_Arg))

	lea	eax, DWORD PTR _pUser$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map

; 309  : 			return (_Mybase::emplace(

	mov	ecx, OFFSET ?SK_SteamWrapper_remap_user@@3V?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@A ; SK_SteamWrapper_remap_user
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple

; 164  : 		: _Val(_STD forward<_Other>(_Arg))

	mov	DWORD PTR $T4[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map

; 309  : 			return (_Mybase::emplace(

	lea	eax, DWORD PTR $T9[ebp]
	push	eax
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	push	OFFSET ?piecewise_construct@std@@3Upiecewise_construct_t@1@B
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??$emplace@ABUpiecewise_construct_t@std@@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::emplace<std::piecewise_construct_t const &,std::tuple<ISteamUser * const &>,std::tuple<> >
	mov	eax, DWORD PTR $T2[ebp]
$LN233@SteamAPI_I:
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp

; 267  :         return SK_SteamWrapper_remap_user [pUser];

	mov	eax, DWORD PTR [eax+12]
	pop	edi
	pop	esi

; 283  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@SteamAPI_I:

; 279  :     }
; 280  :   }
; 281  : 
; 282  :   return nullptr;

	xor	eax, eax
	pop	esi

; 283  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?SteamAPI_ISteamClient_GetISteamUser_Detour@@YAPAVISteamUser@@PAVISteamClient@@HHPBD@Z ENDP ; SteamAPI_ISteamClient_GetISteamUser_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?BIsPhoneRequiringVerification@IWrapSteamUser@@UAE_NXZ
_TEXT	SEGMENT
?BIsPhoneRequiringVerification@IWrapSteamUser@@UAE_NXZ PROC ; IWrapSteamUser::BIsPhoneRequiringVerification, COMDAT
; _this$ = ecx

; 218  :     return pRealUser->BIsPhoneRequiringVerification ();

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+112]
	jmp	eax
?BIsPhoneRequiringVerification@IWrapSteamUser@@UAE_NXZ ENDP ; IWrapSteamUser::BIsPhoneRequiringVerification
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?BIsPhoneIdentifying@IWrapSteamUser@@UAE_NXZ
_TEXT	SEGMENT
?BIsPhoneIdentifying@IWrapSteamUser@@UAE_NXZ PROC	; IWrapSteamUser::BIsPhoneIdentifying, COMDAT
; _this$ = ecx

; 214  :     return pRealUser->BIsPhoneIdentifying           ();

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+108]
	jmp	eax
?BIsPhoneIdentifying@IWrapSteamUser@@UAE_NXZ ENDP	; IWrapSteamUser::BIsPhoneIdentifying
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?BIsTwoFactorEnabled@IWrapSteamUser@@UAE_NXZ
_TEXT	SEGMENT
?BIsTwoFactorEnabled@IWrapSteamUser@@UAE_NXZ PROC	; IWrapSteamUser::BIsTwoFactorEnabled, COMDAT
; _this$ = ecx

; 210  :     return pRealUser->BIsTwoFactorEnabled           ();

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+104]
	jmp	eax
?BIsTwoFactorEnabled@IWrapSteamUser@@UAE_NXZ ENDP	; IWrapSteamUser::BIsTwoFactorEnabled
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?BIsPhoneVerified@IWrapSteamUser@@UAE_NXZ
_TEXT	SEGMENT
?BIsPhoneVerified@IWrapSteamUser@@UAE_NXZ PROC		; IWrapSteamUser::BIsPhoneVerified, COMDAT
; _this$ = ecx

; 206  :     return pRealUser->BIsPhoneVerified              ();

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+100]
	jmp	eax
?BIsPhoneVerified@IWrapSteamUser@@UAE_NXZ ENDP		; IWrapSteamUser::BIsPhoneVerified
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?RequestStoreAuthURL@IWrapSteamUser@@UAE_KPBD@Z
_TEXT	SEGMENT
_pchRedirectURL$ = 8					; size = 4
?RequestStoreAuthURL@IWrapSteamUser@@UAE_KPBD@Z PROC	; IWrapSteamUser::RequestStoreAuthURL, COMDAT
; _this$ = ecx

; 197  :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 198  :     return pRealUser->RequestStoreAuthURL   (pchRedirectURL);

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+96]

; 199  :   };

	pop	ebp

; 198  :     return pRealUser->RequestStoreAuthURL   (pchRedirectURL);

	jmp	eax
?RequestStoreAuthURL@IWrapSteamUser@@UAE_KPBD@Z ENDP	; IWrapSteamUser::RequestStoreAuthURL
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?GetPlayerSteamLevel@IWrapSteamUser@@UAEHXZ
_TEXT	SEGMENT
?GetPlayerSteamLevel@IWrapSteamUser@@UAEHXZ PROC	; IWrapSteamUser::GetPlayerSteamLevel, COMDAT
; _this$ = ecx

; 194  :     return pRealUser->GetPlayerSteamLevel   ();

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+92]
?GetPlayerSteamLevel@IWrapSteamUser@@UAEHXZ ENDP	; IWrapSteamUser::GetPlayerSteamLevel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?GetGameBadgeLevel@IWrapSteamUser@@UAEHH_N@Z
_TEXT	SEGMENT
_nSeries$ = 8						; size = 4
_bFoil$ = 12						; size = 1
?GetGameBadgeLevel@IWrapSteamUser@@UAEHH_N@Z PROC	; IWrapSteamUser::GetGameBadgeLevel, COMDAT
; _this$ = ecx

; 188  :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 189  :     return pRealUser->GetGameBadgeLevel     ( nSeries,

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]

; 190  :                                                 bFoil );
; 191  :   }

	pop	ebp

; 189  :     return pRealUser->GetGameBadgeLevel     ( nSeries,

	jmp	DWORD PTR [eax+88]
?GetGameBadgeLevel@IWrapSteamUser@@UAEHH_N@Z ENDP	; IWrapSteamUser::GetGameBadgeLevel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?GetEncryptedAppTicket@IWrapSteamUser@@UAE_NPAXHPAI@Z
_TEXT	SEGMENT
_pTicket$ = 8						; size = 4
_cbMaxTicket$ = 12					; size = 4
_pcbTicket$ = 16					; size = 4
?GetEncryptedAppTicket@IWrapSteamUser@@UAE_NPAXHPAI@Z PROC ; IWrapSteamUser::GetEncryptedAppTicket, COMDAT
; _this$ = ecx

; 181  :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 182  :     return pRealUser->GetEncryptedAppTicket ( pTicket,

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+84]

; 183  :                                                 cbMaxTicket,
; 184  :                                                   pcbTicket );
; 185  :   }

	pop	ebp

; 182  :     return pRealUser->GetEncryptedAppTicket ( pTicket,

	jmp	eax
?GetEncryptedAppTicket@IWrapSteamUser@@UAE_NPAXHPAI@Z ENDP ; IWrapSteamUser::GetEncryptedAppTicket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?RequestEncryptedAppTicket@IWrapSteamUser@@UAE_KPAXH@Z
_TEXT	SEGMENT
_pDataToInclude$ = 8					; size = 4
_cbDataToInclude$ = 12					; size = 4
?RequestEncryptedAppTicket@IWrapSteamUser@@UAE_KPAXH@Z PROC ; IWrapSteamUser::RequestEncryptedAppTicket, COMDAT
; _this$ = ecx

; 174  :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 175  :     return pRealUser->RequestEncryptedAppTicket ( pDataToInclude,

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+80]

; 176  :                                                     cbDataToInclude );
; 177  :   }

	pop	ebp

; 175  :     return pRealUser->RequestEncryptedAppTicket ( pDataToInclude,

	jmp	eax
?RequestEncryptedAppTicket@IWrapSteamUser@@UAE_KPAXH@Z ENDP ; IWrapSteamUser::RequestEncryptedAppTicket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?AdvertiseGame@IWrapSteamUser@@UAEXVCSteamID@@IG@Z
_TEXT	SEGMENT
_steamIDGameServer$ = 8					; size = 8
_unIPServer$ = 16					; size = 4
_usPortServer$ = 20					; size = 2
?AdvertiseGame@IWrapSteamUser@@UAEXVCSteamID@@IG@Z PROC	; IWrapSteamUser::AdvertiseGame, COMDAT
; _this$ = ecx

; 167  :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 168  :     return pRealUser->AdvertiseGame         ( steamIDGameServer,

	push	DWORD PTR _usPortServer$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	push	DWORD PTR _unIPServer$[ebp]
	push	DWORD PTR _steamIDGameServer$[ebp+4]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR _steamIDGameServer$[ebp]
	call	DWORD PTR [eax+76]

; 169  :                                                 unIPServer,
; 170  :                                                   usPortServer );
; 171  :   }

	pop	ebp
	ret	16					; 00000010H
?AdvertiseGame@IWrapSteamUser@@UAEXVCSteamID@@IG@Z ENDP	; IWrapSteamUser::AdvertiseGame
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?BIsBehindNAT@IWrapSteamUser@@UAE_NXZ
_TEXT	SEGMENT
?BIsBehindNAT@IWrapSteamUser@@UAE_NXZ PROC		; IWrapSteamUser::BIsBehindNAT, COMDAT
; _this$ = ecx

; 162  :   virtual bool                        BIsBehindNAT         (void) override { return pRealUser->BIsBehindNAT (); }

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+72]
	jmp	eax
?BIsBehindNAT@IWrapSteamUser@@UAE_NXZ ENDP		; IWrapSteamUser::BIsBehindNAT
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?UserHasLicenseForApp@IWrapSteamUser@@UAE?AW4EUserHasLicenseForAppResult@@VCSteamID@@I@Z
_TEXT	SEGMENT
_steamID$ = 8						; size = 8
_appID$ = 16						; size = 4
?UserHasLicenseForApp@IWrapSteamUser@@UAE?AW4EUserHasLicenseForAppResult@@VCSteamID@@I@Z PROC ; IWrapSteamUser::UserHasLicenseForApp, COMDAT
; _this$ = ecx

; 158  :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 159  :     return pRealUser->UserHasLicenseForApp  ( steamID,

	mov	ecx, DWORD PTR [ecx+4]
	push	DWORD PTR _appID$[ebp]
	push	DWORD PTR _steamID$[ebp+4]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR _steamID$[ebp]
	call	DWORD PTR [eax+68]

; 160  :                                                 appID );
; 161  :   }

	pop	ebp
	ret	12					; 0000000cH
?UserHasLicenseForApp@IWrapSteamUser@@UAE?AW4EUserHasLicenseForAppResult@@VCSteamID@@I@Z ENDP ; IWrapSteamUser::UserHasLicenseForApp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?CancelAuthTicket@IWrapSteamUser@@UAEXI@Z
_TEXT	SEGMENT
_hAuthTicket$ = 8					; size = 4
?CancelAuthTicket@IWrapSteamUser@@UAEXI@Z PROC		; IWrapSteamUser::CancelAuthTicket, COMDAT
; _this$ = ecx

; 153  :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 154  :     return pRealUser->CancelAuthTicket      (hAuthTicket);

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]

; 155  :   }

	pop	ebp

; 154  :     return pRealUser->CancelAuthTicket      (hAuthTicket);

	jmp	DWORD PTR [eax+64]
?CancelAuthTicket@IWrapSteamUser@@UAEXI@Z ENDP		; IWrapSteamUser::CancelAuthTicket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?EndAuthSession@IWrapSteamUser@@UAEXVCSteamID@@@Z
_TEXT	SEGMENT
_steamID$ = 8						; size = 8
?EndAuthSession@IWrapSteamUser@@UAEXVCSteamID@@@Z PROC	; IWrapSteamUser::EndAuthSession, COMDAT
; _this$ = ecx

; 149  :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 150  :     return pRealUser->EndAuthSession        (steamID);

	mov	ecx, DWORD PTR [ecx+4]
	push	DWORD PTR _steamID$[ebp+4]
	push	DWORD PTR _steamID$[ebp]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+60]

; 151  :   }

	pop	ebp
	ret	8
?EndAuthSession@IWrapSteamUser@@UAEXVCSteamID@@@Z ENDP	; IWrapSteamUser::EndAuthSession
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?BeginAuthSession@IWrapSteamUser@@UAE?AW4EBeginAuthSessionResult@@PBXHVCSteamID@@@Z
_TEXT	SEGMENT
_pAuthTicket$ = 8					; size = 4
_cbAuthTicket$ = 12					; size = 4
_steamID$ = 16						; size = 8
?BeginAuthSession@IWrapSteamUser@@UAE?AW4EBeginAuthSessionResult@@PBXHVCSteamID@@@Z PROC ; IWrapSteamUser::BeginAuthSession, COMDAT
; _this$ = ecx

; 143  :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 144  :     return pRealUser->BeginAuthSession      ( pAuthTicket,

	push	DWORD PTR _steamID$[ebp+4]
	mov	ecx, DWORD PTR [ecx+4]
	push	DWORD PTR _steamID$[ebp]
	push	DWORD PTR _cbAuthTicket$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR _pAuthTicket$[ebp]
	call	DWORD PTR [eax+56]

; 145  :                                                 cbAuthTicket,
; 146  :                                                   steamID );
; 147  :   }

	pop	ebp
	ret	16					; 00000010H
?BeginAuthSession@IWrapSteamUser@@UAE?AW4EBeginAuthSessionResult@@PBXHVCSteamID@@@Z ENDP ; IWrapSteamUser::BeginAuthSession
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?GetAuthSessionTicket@IWrapSteamUser@@UAEIPAXHPAI@Z
_TEXT	SEGMENT
_pTicket$ = 8						; size = 4
_cbMaxTicket$ = 12					; size = 4
_pcbTicket$ = 16					; size = 4
?GetAuthSessionTicket@IWrapSteamUser@@UAEIPAXHPAI@Z PROC ; IWrapSteamUser::GetAuthSessionTicket, COMDAT
; _this$ = ecx

; 135  :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 136  :     return pRealUser->GetAuthSessionTicket  ( pTicket,

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]

; 137  :                                                 cbMaxTicket,
; 138  :                                                   pcbTicket );
; 139  :   }

	pop	ebp

; 136  :     return pRealUser->GetAuthSessionTicket  ( pTicket,

	jmp	DWORD PTR [eax+52]
?GetAuthSessionTicket@IWrapSteamUser@@UAEIPAXHPAI@Z ENDP ; IWrapSteamUser::GetAuthSessionTicket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?GetVoiceOptimalSampleRate@IWrapSteamUser@@UAEIXZ
_TEXT	SEGMENT
?GetVoiceOptimalSampleRate@IWrapSteamUser@@UAEIXZ PROC	; IWrapSteamUser::GetVoiceOptimalSampleRate, COMDAT
; _this$ = ecx

; 130  :   virtual uint32       GetVoiceOptimalSampleRate (void) override { return pRealUser->GetVoiceOptimalSampleRate (); }

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+48]
?GetVoiceOptimalSampleRate@IWrapSteamUser@@UAEIXZ ENDP	; IWrapSteamUser::GetVoiceOptimalSampleRate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?DecompressVoice@IWrapSteamUser@@UAE?AW4EVoiceResult@@PBXIPAXIPAII@Z
_TEXT	SEGMENT
_pCompressed$ = 8					; size = 4
_cbCompressed$ = 12					; size = 4
_pDestBuffer$ = 16					; size = 4
_cbDestBufferSize$ = 20					; size = 4
_nBytesWritten$ = 24					; size = 4
_nDesiredSampleRate$ = 28				; size = 4
?DecompressVoice@IWrapSteamUser@@UAE?AW4EVoiceResult@@PBXIPAXIPAII@Z PROC ; IWrapSteamUser::DecompressVoice, COMDAT
; _this$ = ecx

; 122  :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 123  :     return pRealUser->DecompressVoice       ( pCompressed,

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]

; 124  :                                                 cbCompressed,
; 125  :                                                   pDestBuffer,
; 126  :                                                     cbDestBufferSize,
; 127  :                                                       nBytesWritten,
; 128  :                                                         nDesiredSampleRate );
; 129  :   }

	pop	ebp

; 123  :     return pRealUser->DecompressVoice       ( pCompressed,

	jmp	DWORD PTR [eax+44]
?DecompressVoice@IWrapSteamUser@@UAE?AW4EVoiceResult@@PBXIPAXIPAII@Z ENDP ; IWrapSteamUser::DecompressVoice
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?GetVoice@IWrapSteamUser@@UAE?AW4EVoiceResult@@_NPAXIPAI01I2I@Z
_TEXT	SEGMENT
_bWantCompressed$ = 8					; size = 1
_pDestBuffer$ = 12					; size = 4
_cbDestBufferSize$ = 16					; size = 4
_nBytesWritten$ = 20					; size = 4
_bWantUncompressed$ = 24				; size = 1
_pUncompressedDestBuffer$ = 28				; size = 4
_cbUncompressedDestBufferSize$ = 32			; size = 4
_nUncompressBytesWritten$ = 36				; size = 4
_nUncompressedVoiceDesiredSampleRate$ = 40		; size = 4
?GetVoice@IWrapSteamUser@@UAE?AW4EVoiceResult@@_NPAXIPAI01I2I@Z PROC ; IWrapSteamUser::GetVoice, COMDAT
; _this$ = ecx

; 105  :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 106  :     return pRealUser->GetVoice              ( bWantCompressed,

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]

; 107  :                                                 pDestBuffer,
; 108  :                                                   cbDestBufferSize,
; 109  :                                                     nBytesWritten,
; 110  :                                                       bWantUncompressed,
; 111  :                                                         pUncompressedDestBuffer,
; 112  :                                                           cbUncompressedDestBufferSize,
; 113  :                                                             nUncompressBytesWritten,
; 114  :                                                               nUncompressedVoiceDesiredSampleRate );
; 115  :   }

	pop	ebp

; 106  :     return pRealUser->GetVoice              ( bWantCompressed,

	jmp	DWORD PTR [eax+40]
?GetVoice@IWrapSteamUser@@UAE?AW4EVoiceResult@@_NPAXIPAI01I2I@Z ENDP ; IWrapSteamUser::GetVoice
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?GetAvailableVoice@IWrapSteamUser@@UAE?AW4EVoiceResult@@PAI0I@Z
_TEXT	SEGMENT
_pcbCompressed$ = 8					; size = 4
_pcbUncompressed$ = 12					; size = 4
_nUncompressedVoiceDesiredSampleRate$ = 16		; size = 4
?GetAvailableVoice@IWrapSteamUser@@UAE?AW4EVoiceResult@@PAI0I@Z PROC ; IWrapSteamUser::GetAvailableVoice, COMDAT
; _this$ = ecx

; 91   :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 92   :     return pRealUser->GetAvailableVoice     ( pcbCompressed,

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]

; 93   :                                                 pcbUncompressed,
; 94   :                                                   nUncompressedVoiceDesiredSampleRate );
; 95   :   }

	pop	ebp

; 92   :     return pRealUser->GetAvailableVoice     ( pcbCompressed,

	jmp	DWORD PTR [eax+36]
?GetAvailableVoice@IWrapSteamUser@@UAE?AW4EVoiceResult@@PAI0I@Z ENDP ; IWrapSteamUser::GetAvailableVoice
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?StopVoiceRecording@IWrapSteamUser@@UAEXXZ
_TEXT	SEGMENT
?StopVoiceRecording@IWrapSteamUser@@UAEXXZ PROC		; IWrapSteamUser::StopVoiceRecording, COMDAT
; _this$ = ecx

; 86   :   virtual void         StopVoiceRecording    (void) override { return pRealUser->StopVoiceRecording  (); };

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+32]
?StopVoiceRecording@IWrapSteamUser@@UAEXXZ ENDP		; IWrapSteamUser::StopVoiceRecording
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?StartVoiceRecording@IWrapSteamUser@@UAEXXZ
_TEXT	SEGMENT
?StartVoiceRecording@IWrapSteamUser@@UAEXXZ PROC	; IWrapSteamUser::StartVoiceRecording, COMDAT
; _this$ = ecx

; 85   :   virtual void         StartVoiceRecording   (void) override { return pRealUser->StartVoiceRecording (); };

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+28]
?StartVoiceRecording@IWrapSteamUser@@UAEXXZ ENDP	; IWrapSteamUser::StartVoiceRecording
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?GetUserDataFolder@IWrapSteamUser@@UAE_NPADH@Z
_TEXT	SEGMENT
_pchBuffer$ = 8						; size = 4
_cubBuffer$ = 12					; size = 4
?GetUserDataFolder@IWrapSteamUser@@UAE_NPADH@Z PROC	; IWrapSteamUser::GetUserDataFolder, COMDAT
; _this$ = ecx

; 80   :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 81   :     return pRealUser->GetUserDataFolder     ( pchBuffer,

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+24]

; 82   :                                                 cubBuffer );
; 83   :   };

	pop	ebp

; 81   :     return pRealUser->GetUserDataFolder     ( pchBuffer,

	jmp	eax
?GetUserDataFolder@IWrapSteamUser@@UAE_NPADH@Z ENDP	; IWrapSteamUser::GetUserDataFolder
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?TrackAppUsageEvent@IWrapSteamUser@@UAEXVCGameID@@HPBD@Z
_TEXT	SEGMENT
_gameID$ = 8						; size = 8
_eAppUsageEvent$ = 16					; size = 4
_pchExtraInfo$ = 20					; size = 4
?TrackAppUsageEvent@IWrapSteamUser@@UAEXVCGameID@@HPBD@Z PROC ; IWrapSteamUser::TrackAppUsageEvent, COMDAT
; _this$ = ecx

; 73   :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 74   :     return pRealUser->TrackAppUsageEvent    ( gameID,

	push	DWORD PTR _pchExtraInfo$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	push	DWORD PTR _eAppUsageEvent$[ebp]
	push	DWORD PTR _gameID$[ebp+4]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR _gameID$[ebp]
	call	DWORD PTR [eax+20]

; 75   :                                                 eAppUsageEvent,
; 76   :                                                   pchExtraInfo );
; 77   :   };

	pop	ebp
	ret	16					; 00000010H
?TrackAppUsageEvent@IWrapSteamUser@@UAEXVCGameID@@HPBD@Z ENDP ; IWrapSteamUser::TrackAppUsageEvent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?TerminateGameConnection@IWrapSteamUser@@UAEXIG@Z
_TEXT	SEGMENT
_unIPServer$ = 8					; size = 4
_usPortServer$ = 12					; size = 2
?TerminateGameConnection@IWrapSteamUser@@UAEXIG@Z PROC	; IWrapSteamUser::TerminateGameConnection, COMDAT
; _this$ = ecx

; 66   :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 67   :     return pRealUser->TerminateGameConnection ( unIPServer,

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]

; 68   :                                                   usPortServer );
; 69   :   };

	pop	ebp

; 67   :     return pRealUser->TerminateGameConnection ( unIPServer,

	jmp	DWORD PTR [eax+16]
?TerminateGameConnection@IWrapSteamUser@@UAEXIG@Z ENDP	; IWrapSteamUser::TerminateGameConnection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?InitiateGameConnection@IWrapSteamUser@@UAEHPAXHVCSteamID@@IG_N@Z
_TEXT	SEGMENT
_pAuthBlob$ = 8						; size = 4
_cbMaxAuthBlob$ = 12					; size = 4
_steamIDGameServer$ = 16				; size = 8
_unIPServer$ = 24					; size = 4
_usPortServer$ = 28					; size = 2
_bSecure$ = 32						; size = 1
?InitiateGameConnection@IWrapSteamUser@@UAEHPAXHVCSteamID@@IG_N@Z PROC ; IWrapSteamUser::InitiateGameConnection, COMDAT
; _this$ = ecx

; 57   :   {

	npad	2
	push	ebp
	mov	ebp, esp

; 58   :     return pRealUser->InitiateGameConnection ( pAuthBlob,

	push	DWORD PTR _bSecure$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	push	DWORD PTR _usPortServer$[ebp]
	push	DWORD PTR _unIPServer$[ebp]
	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR _steamIDGameServer$[ebp+4]
	push	DWORD PTR _steamIDGameServer$[ebp]
	push	DWORD PTR _cbMaxAuthBlob$[ebp]
	push	DWORD PTR _pAuthBlob$[ebp]
	call	DWORD PTR [eax+12]

; 59   :                                                  cbMaxAuthBlob, 
; 60   :                                                    steamIDGameServer, 
; 61   :                                                      unIPServer, 
; 62   :                                                        usPortServer, 
; 63   :                                                          bSecure );
; 64   :   };

	pop	ebp
	ret	28					; 0000001cH
?InitiateGameConnection@IWrapSteamUser@@UAEHPAXHVCSteamID@@IG_N@Z ENDP ; IWrapSteamUser::InitiateGameConnection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?GetSteamID@IWrapSteamUser@@UAE?AVCSteamID@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?GetSteamID@IWrapSteamUser@@UAE?AVCSteamID@@XZ PROC	; IWrapSteamUser::GetSteamID, COMDAT
; _this$ = ecx

; 49   :   virtual CSteamID   GetSteamID             ( void ) override { return pRealUser->GetSteamID    (); };

	npad	2
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+4]
	push	DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	ebp
	ret	4
?GetSteamID@IWrapSteamUser@@UAE?AVCSteamID@@XZ ENDP	; IWrapSteamUser::GetSteamID
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?BLoggedOn@IWrapSteamUser@@UAE_NXZ
_TEXT	SEGMENT
?BLoggedOn@IWrapSteamUser@@UAE_NXZ PROC			; IWrapSteamUser::BLoggedOn, COMDAT
; _this$ = ecx

; 33   :     __SK_SteamUser_BLoggedOn =

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	call	eax
	xor	ecx, ecx
	test	al, al
	setne	cl

; 34   :       static_cast <int> ( pRealUser->BLoggedOn () ? SK_SteamUser_LoggedOn_e::Online :
; 35   :                                                     SK_SteamUser_LoggedOn_e::Offline );
; 36   : 
; 37   :     if (config.steam.spoof_BLoggedOn)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+388, 0
	mov	DWORD PTR ?__SK_SteamUser_BLoggedOn@@3HA, ecx ; __SK_SteamUser_BLoggedOn
	je	SHORT $LN2@BLoggedOn

; 38   :     {
; 39   :       if (__SK_SteamUser_BLoggedOn != static_cast <int> (SK_SteamUser_LoggedOn_e::Online))

	cmp	ecx, 1
	je	SHORT $LN3@BLoggedOn

; 40   :         __SK_SteamUser_BLoggedOn   |= static_cast <int> (SK_SteamUser_LoggedOn_e::Spoofing);

	or	ecx, 2
	mov	DWORD PTR ?__SK_SteamUser_BLoggedOn@@3HA, ecx ; __SK_SteamUser_BLoggedOn
$LN3@BLoggedOn:

; 41   : 
; 42   :       return true;

	mov	al, 1

; 46   :   };

	ret	0
$LN2@BLoggedOn:

; 43   :     }
; 44   : 
; 45   :     return (__SK_SteamUser_BLoggedOn & static_cast <int> (SK_SteamUser_LoggedOn_e::Online)) != 0;

	and	ecx, 1
	mov	al, cl

; 46   :   };

	ret	0
?BLoggedOn@IWrapSteamUser@@UAE_NXZ ENDP			; IWrapSteamUser::BLoggedOn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ?GetHSteamUser@IWrapSteamUser@@UAEHXZ
_TEXT	SEGMENT
?GetHSteamUser@IWrapSteamUser@@UAEHXZ PROC		; IWrapSteamUser::GetHSteamUser, COMDAT
; _this$ = ecx

; 28   :   virtual HSteamUser GetHSteamUser          ( void ) override { return pRealUser->GetHSteamUser (); };

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax]
?GetHSteamUser@IWrapSteamUser@@UAEHXZ ENDP		; IWrapSteamUser::GetHSteamUser
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ??0IWrapSteamUser@@QAE@PAVISteamUser@@@Z
_TEXT	SEGMENT
_pUser$ = 8						; size = 4
??0IWrapSteamUser@@QAE@PAVISteamUser@@@Z PROC		; IWrapSteamUser::IWrapSteamUser, COMDAT
; _this$ = ecx

; 25   :                    pRealUser (pUser) {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _pUser$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 26   :   };

	mov	eax, ecx
	mov	DWORD PTR [ecx], OFFSET ??_7IWrapSteamUser@@6B@
	pop	ebp
	ret	4
??0IWrapSteamUser@@QAE@PAVISteamUser@@@Z ENDP		; IWrapSteamUser::IWrapSteamUser
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__FSK_SteamWrapper_remap_user@@YAXXZ
text$yd	SEGMENT
??__FSK_SteamWrapper_remap_user@@YAXXZ PROC		; `dynamic atexit destructor for 'SK_SteamWrapper_remap_user'', COMDAT
	mov	ecx, OFFSET ?SK_SteamWrapper_remap_user@@3V?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@A ; SK_SteamWrapper_remap_user
	jmp	??1?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::~_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >
??__FSK_SteamWrapper_remap_user@@YAXXZ ENDP		; `dynamic atexit destructor for 'SK_SteamWrapper_remap_user''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp
;	COMDAT ??__ESK_SteamWrapper_remap_user@@YAXXZ
text$di	SEGMENT
$T1 = -8						; size = 4
$T2 = -1						; size = 1
??__ESK_SteamWrapper_remap_user@@YAXXZ PROC		; `dynamic initializer for 'SK_SteamWrapper_remap_user'', COMDAT

; 16   : std::unordered_map <ISteamUser*, IWrapSteamUser*>   SK_SteamWrapper_remap_user;

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map

; 118  : 		: _Mybase(key_compare(), allocator_type())

	lea	eax, DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 311  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

	mov	DWORD PTR $T1[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map

; 118  : 		: _Mybase(key_compare(), allocator_type())

	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	mov	ecx, OFFSET ?SK_SteamWrapper_remap_user@@3V?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@A ; SK_SteamWrapper_remap_user
	push	eax
	call	??0?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@1@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >
; File c:\users\andon\source\repos\specialk\src\steam\user.cpp

; 16   : std::unordered_map <ISteamUser*, IWrapSteamUser*>   SK_SteamWrapper_remap_user;

	push	OFFSET ??__FSK_SteamWrapper_remap_user@@YAXXZ ; `dynamic atexit destructor for 'SK_SteamWrapper_remap_user''
	call	_atexit
	add	esp, 4
	mov	esp, ebp
	pop	ebp
	ret	0
??__ESK_SteamWrapper_remap_user@@YAXXZ ENDP		; `dynamic initializer for 'SK_SteamWrapper_remap_user''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@QAE@XZ PROC ; std::unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::~unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >, COMDAT
; _this$ = ecx
	jmp	??1?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::~_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >
??1?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@QAE@XZ ENDP ; std::unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::~unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
;	COMDAT ??A?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@QAEAAPAVIWrapSteamUser@@ABQAVISteamUser@@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
$T2 = -4						; size = 4
__Where$3 = 8						; size = 4
__Keyval$ = 8						; size = 4
$T4 = 11						; size = 1
??A?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@QAEAAPAVIWrapSteamUser@@ABQAVISteamUser@@@Z PROC ; std::unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::operator[], COMDAT
; _this$ = ecx

; 477  : 		{	// find element matching _Keyval or insert with default mapped

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 625  : 		return (lower_bound(_Keyval));

	mov	edi, DWORD PTR __Keyval$[ebp]
	lea	eax, DWORD PTR __Where$3[ebp]
	push	edi
	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map

; 477  : 		{	// find element matching _Keyval or insert with default mapped

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 625  : 		return (lower_bound(_Keyval));

	call	?lower_bound@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@ABQAVISteamUser@@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::lower_bound
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 297  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __Where$3[ebp]
	cmp	eax, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map

; 308  : 		if (_Where == _Mybase::end())

	jne	SHORT $LN6@operator

; 309  : 			return (_Mybase::emplace(

	lea	eax, DWORD PTR $T4[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple

; 164  : 		: _Val(_STD forward<_Other>(_Arg))

	mov	DWORD PTR $T2[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map

; 309  : 			return (_Mybase::emplace(

	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	mov	ecx, esi
	push	eax
	push	OFFSET ?piecewise_construct@std@@3Upiecewise_construct_t@1@B
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??$emplace@ABUpiecewise_construct_t@std@@V?$tuple@ABQAVISteamUser@@@2@V?$tuple@$$V@2@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABQAVISteamUser@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::emplace<std::piecewise_construct_t const &,std::tuple<ISteamUser * const &>,std::tuple<> >

; 478  : 		return (try_emplace(_Keyval).first->second);

	mov	eax, DWORD PTR $T1[ebp]
$LN6@operator:
	pop	edi
	add	eax, 12					; 0000000cH
	pop	esi

; 479  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@QAEAAPAVIWrapSteamUser@@ABQAVISteamUser@@@Z ENDP ; std::unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
;	COMDAT ??0?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -8						; size = 4
$T2 = -1						; size = 1
??0?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@QAE@XZ PROC ; std::unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >, COMDAT
; _this$ = ecx

; 119  : 		{	// construct empty map from defaults

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 118  : 		: _Mybase(key_compare(), allocator_type())

	lea	eax, DWORD PTR $T2[ebp]

; 119  : 		{	// construct empty map from defaults

	mov	esi, ecx
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _this$[ebp], esi
	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 311  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

	mov	DWORD PTR $T1[ebp], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map

; 118  : 		: _Mybase(key_compare(), allocator_type())

	call	??0?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@1@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >

; 120  : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$unordered_map@PAVISteamUser@@PAVIWrapSteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@4@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@@std@@QAE@XZ ENDP ; std::unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::unordered_map<ISteamUser *,IWrapSteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Xlength@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Xlength, COMDAT

; 1962 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlength:
$LN3@Xlength:
	int	3
?_Xlength@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Tidy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXXZ PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Tidy, COMDAT
; _this$ = ecx

; 1946 : 		{	// free all storage

	npad	2
	push	esi
	mov	esi, ecx

; 1947 : 		this->_Orphan_all();
; 1948 : 
; 1949 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:
	pop	esi

; 1957 : 			}
; 1958 : 		}

	ret	0
?_Tidy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXXZ ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Change_array@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@II@Z PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Change_array, COMDAT
; _this$ = ecx

; 1931 : 		{	// orphan all iterators, discard old array, acquire new array

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 1932 : 		this->_Orphan_all();
; 1933 : 
; 1934 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Change_arr

; 1937 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1937 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN2@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1940 : 		this->_Myfirst() = _Newvec;

	mov	ecx, DWORD PTR __Newvec$[ebp]

; 1941 : 		this->_Mylast() = _Newvec + _Newsize;

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [esi], ecx
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+4], eax

; 1942 : 		this->_Myend() = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [esi+8], eax
	pop	esi

; 1943 : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Change_array@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@II@Z ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Buy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAE_NI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?_Buy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAE_NI@Z PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Buy, COMDAT
; _this$ = ecx

; 1908 : 		{	// allocate array with _Newcapacity elements

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 1909 : 		this->_Myfirst() = pointer();
; 1910 : 		this->_Mylast() = pointer();
; 1911 : 		this->_Myend() = pointer();
; 1912 : 
; 1913 : 		if (_Newcapacity == 0)

	mov	edi, DWORD PTR __Newcapacity$[ebp]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	test	edi, edi
	jne	SHORT $LN2@Buy

; 1914 : 			{
; 1915 : 			return (false);

	pop	edi
	xor	al, al
	pop	esi

; 1928 : 		}

	pop	ebp
	ret	4
$LN2@Buy:

; 1916 : 			}
; 1917 : 
; 1918 : 		if (_Newcapacity > max_size())

	cmp	edi, 1073741823				; 3fffffffH
	ja	SHORT $LN115@Buy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1077 : 		return (_Mybase::allocate(_Count));

	push	edi
	call	?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::allocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1923 : 		this->_Myfirst() = this->_Getal().allocate(_Newcapacity);

	mov	DWORD PTR [esi], eax

; 1924 : 		this->_Mylast() = this->_Myfirst();

	mov	DWORD PTR [esi+4], eax

; 1925 : 		this->_Myend() = this->_Myfirst() + _Newcapacity;

	mov	eax, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+8], eax

; 1926 : 
; 1927 : 		return (true);

	mov	al, 1
	pop	edi
	pop	esi

; 1928 : 		}

	pop	ebp
	ret	4
$LN115@Buy:

; 1919 : 			{
; 1920 : 			_Xlength();

	call	?_Xlength@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Xlength
$LN117@Buy:
$LN114@Buy:
	int	3
?_Buy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAE_NI@Z ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Calculate_growth@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@ABEII@Z PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1889 : 		{	// given _Oldcapacity and _Newsize, calculate geometric growth

	npad	2
	push	ebp
	mov	ebp, esp

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	edx, DWORD PTR [ecx+8]

; 1890 : 		const size_type _Oldcapacity = capacity();
; 1891 : 
; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	eax, 1073741823				; 3fffffffH

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sub	edx, DWORD PTR [ecx]
	sar	edx, 2

; 1890 : 		const size_type _Oldcapacity = capacity();
; 1891 : 
; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	ecx, edx
	shr	ecx, 1
	sub	eax, ecx
	cmp	edx, eax
	jbe	SHORT $LN2@Calculate_

; 1893 : 			{
; 1894 : 			return (_Newsize);	// geometric growth would overflow

	mov	eax, DWORD PTR __Newsize$[ebp]

; 1900 : 			{
; 1901 : 			return (_Newsize);	// geometric growth would be insufficient
; 1902 : 			}
; 1903 : 
; 1904 : 		return (_Geometric);	// geometric growth is sufficient
; 1905 : 		}

	pop	ebp
	ret	4
$LN2@Calculate_:

; 1895 : 			}
; 1896 : 
; 1897 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	eax, DWORD PTR [ecx+edx]

; 1898 : 
; 1899 : 		if (_Geometric < _Newsize)

	cmp	eax, DWORD PTR __Newsize$[ebp]
	cmovb	eax, DWORD PTR __Newsize$[ebp]

; 1900 : 			{
; 1901 : 			return (_Newsize);	// geometric growth would be insufficient
; 1902 : 			}
; 1903 : 
; 1904 : 		return (_Geometric);	// geometric growth is sufficient
; 1905 : 		}

	pop	ebp
	ret	4
?_Calculate_growth@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@ABEII@Z ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Destroy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@0@Z PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Destroy, COMDAT
; _this$ = ecx

; 1885 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1886 : 		}

	ret	8
?_Destroy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@0@Z ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
$T1 = 16						; size = 1
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@00@Z PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Umove_if_noexcept, COMDAT
; _this$ = ecx

; 1878 : 		{	// move_if_noexcept [_First, _Last) to raw _Dest, using allocator

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 172  : 	return (_Rechecked(_Dest,

	push	ecx
	push	DWORD PTR $T1[ebp]
	push	ecx
	push	DWORD PTR __Dest$[ebp]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp]
	call	??$_Uninitialized_move_al_unchecked@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >
	add	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1881 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Umove_if_noexcept@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@00@Z ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
$T1 = 16						; size = 1
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Umove_if_noexcept1, COMDAT
; _this$ = ecx

; 1868 : 		{	// move [_First, _Last) to raw _Dest, using allocator

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 172  : 	return (_Rechecked(_Dest,

	push	ecx
	push	DWORD PTR $T1[ebp]
	push	ecx
	push	DWORD PTR __Dest$[ebp]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp]
	call	??$_Uninitialized_move_al_unchecked@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >
	add	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1870 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?_Umove_if_noexcept1@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Ufill@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@PAV32@IABV32@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
$T1 = 16						; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@PAV32@IABV32@@Z PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Ufill, COMDAT
; _this$ = ecx

; 1852 : 		{	// fill raw _Dest with _Count copies of _Val, using allocator

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 217  : 	return (_Uninit_alloc_fill_n1(_First, _Count, _Val, _Al,

	push	DWORD PTR $T1[ebp]
	push	ecx
	push	DWORD PTR __Val$[ebp]
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Dest$[ebp]
	call	??$_Uninit_alloc_fill_n1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@IU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@PAV10@IABV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninit_alloc_fill_n1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,unsigned int,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >
	add	esp, 20					; 00000014H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1854 : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@PAV32@IABV32@@Z ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Ufill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??A?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@I@Z PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::operator[], COMDAT
; _this$ = ecx

; 1750 : 		{	// subscript nonmutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 1751 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1752 : 		if (size() <= _Pos)
; 1753 : 			{	// report error
; 1754 : 			_DEBUG_ERROR("vector subscript out of range");
; 1755 : 			}
; 1756 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1757 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1758 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1759 : 
; 1760 : 		return (this->_Myfirst()[_Pos]);

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]

; 1761 : 		}

	pop	ebp
	ret	4
??A?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@I@Z ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??A?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEAAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEAAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@I@Z PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::operator[], COMDAT
; _this$ = ecx

; 1736 : 		{	// subscript mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 1737 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1738 : 		if (size() <= _Pos)
; 1739 : 			{	// report error
; 1740 : 			_DEBUG_ERROR("vector subscript out of range");
; 1741 : 			}
; 1742 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1743 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1744 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1745 : 
; 1746 : 		return (this->_Myfirst()[_Pos]);

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]

; 1747 : 		}

	pop	ebp
	ret	4
??A?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEAAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@I@Z ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?capacity@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::capacity, COMDAT
; _this$ = ecx

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1721 : 		}

	ret	0
?capacity@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?max_size@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::max_size, COMDAT
; _this$ = ecx

; 1715 : 		return (this->_Getal().max_size());

	mov	eax, 1073741823				; 3fffffffH

; 1716 : 		}

	ret	0
?max_size@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?size@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::size, COMDAT
; _this$ = ecx

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1711 : 		}

	ret	0
?size@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?reserve@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
?reserve@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEXI@Z PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::reserve, COMDAT
; _this$ = ecx

; 1528 : 		{	// increase capacity to _Newcapacity (without geometric growth), provide strong guarantee

	npad	2
	push	ebp
	mov	ebp, esp

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]

; 1529 : 		if (_Newcapacity > capacity())

	mov	edx, DWORD PTR __Newcapacity$[ebp]

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sar	eax, 2

; 1529 : 		if (_Newcapacity > capacity())

	cmp	edx, eax
	jbe	SHORT $LN2@reserve

; 1530 : 			{	// something to do (reserve() never shrinks)
; 1531 : 			if (_Newcapacity > max_size())

	cmp	edx, 1073741823				; 3fffffffH
	ja	SHORT $LN55@reserve

; 1534 : 				}
; 1535 : 
; 1536 : 			_Reallocate_exactly(_Newcapacity);

	mov	DWORD PTR __Newcapacity$[ebp], edx

; 1537 : 			}
; 1538 : 		}

	pop	ebp

; 1534 : 				}
; 1535 : 
; 1536 : 			_Reallocate_exactly(_Newcapacity);

	jmp	?_Reallocate_exactly@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXI@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Reallocate_exactly
$LN2@reserve:

; 1537 : 			}
; 1538 : 		}

	pop	ebp
	ret	4
$LN55@reserve:

; 1532 : 				{
; 1533 : 				_Xlength();

	call	?_Xlength@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Xlength
$LN57@reserve:
$LN54@reserve:
	int	3
?reserve@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEXI@Z ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Reallocate_exactly@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXI@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Newvec$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T2 = 8							; size = 1
__Newcapacity$ = 8					; size = 4
?_Reallocate_exactly@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXI@Z PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Reallocate_exactly, COMDAT
; _this$ = ecx

; 1511 : 		{	// set capacity to _Newcapacity (without geometric growth), provide strong guarantee

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Reallocate_exactly@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1077 : 		return (_Mybase::allocate(_Count));

	push	DWORD PTR __Newcapacity$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ebx, DWORD PTR [esi+4]
	sub	ebx, DWORD PTR [esi]

; 1511 : 		{	// set capacity to _Newcapacity (without geometric growth), provide strong guarantee

	mov	DWORD PTR _this$[ebp], esi

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	sar	ebx, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 1077 : 		return (_Mybase::allocate(_Count));

	call	?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::allocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 172  : 	return (_Rechecked(_Dest,

	push	ecx
	push	DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1514 : 		const pointer _Newvec = this->_Getal().allocate(_Newcapacity);

	mov	edi, eax

; 1515 : 
; 1516 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 172  : 	return (_Rechecked(_Dest,

	push	esi
	push	edi
	push	DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1514 : 		const pointer _Newvec = this->_Getal().allocate(_Newcapacity);

	mov	DWORD PTR __Newvec$[ebp], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 172  : 	return (_Rechecked(_Dest,

	push	DWORD PTR [esi]
	call	??$_Uninitialized_move_al_unchecked@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@PAV10@00AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1934 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 172  : 	return (_Rechecked(_Dest,

	add	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1934 : 		if (this->_Myfirst() != pointer())

	test	ecx, ecx
	je	SHORT $LN83@Reallocate

; 1937 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1937 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN83@Reallocate:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1524 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]

; 1941 : 		this->_Mylast() = _Newvec + _Newsize;

	lea	eax, DWORD PTR [edi+ebx*4]
	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+4], eax

; 1942 : 		this->_Myend() = _Newvec + _Newcapacity;

	mov	eax, DWORD PTR __Newcapacity$[ebp]
	lea	eax, DWORD PTR [edi+eax*4]

; 1524 : 		}

	pop	edi

; 1942 : 		this->_Myend() = _Newvec + _Newcapacity;

	mov	DWORD PTR [esi+8], eax

; 1524 : 		}

	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$?_Reallocate_exactly@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXI@Z$0:

; 1517 : 		_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);
; 1518 : 		_CATCH_ALL
; 1519 : 		this->_Getal().deallocate(_Newvec, _Newcapacity);

	push	DWORD PTR __Newcapacity$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	DWORD PTR __Newvec$[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::deallocate

; 1520 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN180@Reallocate:
$LN179@Reallocate:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate_exactly@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Reallocate_exactly@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Reallocate_exactly@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXI@Z ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Reallocate_exactly
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?assign@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEXIABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__Oldsize$1$ = -4					; size = 4
$T1 = 8							; size = 1
__Newsize$ = 8						; size = 4
$T2 = 12						; size = 1
$T3 = 12						; size = 1
__Val$ = 12						; size = 4
?assign@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEXIABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@Z PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::assign, COMDAT
; _this$ = ecx

; 1287 : 		{	// assign _Newsize * _Val

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	mov	ebx, ecx
	push	esi
	push	edi

; 1288 : 		this->_Orphan_all();
; 1289 : 
; 1290 : 		const size_type _Oldsize = size();
; 1291 : 		const size_type _Oldcapacity = capacity();
; 1292 : 
; 1293 : 		if (_Newsize > _Oldcapacity)

	mov	edi, DWORD PTR __Newsize$[ebp]

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	edx, DWORD PTR [ebx]

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	ecx, DWORD PTR [ebx+8]

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [ebx+4]

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sub	ecx, edx

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	sub	eax, edx

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	sar	ecx, 2

; 1710 : 		return (this->_Mylast() - this->_Myfirst());

	sar	eax, 2
	mov	DWORD PTR __Oldsize$1$[ebp], eax

; 1288 : 		this->_Orphan_all();
; 1289 : 
; 1290 : 		const size_type _Oldsize = size();
; 1291 : 		const size_type _Oldcapacity = capacity();
; 1292 : 
; 1293 : 		if (_Newsize > _Oldcapacity)

	cmp	edi, ecx
	jbe	SHORT $LN2@assign

; 1294 : 			{	// reallocate
; 1295 : 			if (_Newsize > max_size())

	cmp	edi, 1073741823				; 3fffffffH
	ja	$LN297@assign

; 1892 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

	mov	esi, ecx
	mov	eax, 1073741823				; 3fffffffH
	shr	esi, 1
	sub	eax, esi
	cmp	ecx, eax
	jbe	SHORT $LN79@assign

; 1893 : 			{
; 1894 : 			return (_Newsize);	// geometric growth would overflow

	mov	esi, edi
	jmp	SHORT $LN80@assign
$LN79@assign:

; 1895 : 			}
; 1896 : 
; 1897 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	add	esi, ecx

; 1898 : 
; 1899 : 		if (_Geometric < _Newsize)

	cmp	esi, edi
	cmovb	esi, edi
$LN80@assign:

; 1298 : 				}
; 1299 : 
; 1300 : 			const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1301 : 
; 1302 : 			if (this->_Myfirst() != pointer())

	test	edx, edx
	je	SHORT $LN5@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	ecx
	push	edx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
$LN5@assign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1308 : 			_Buy(_Newcapacity);

	push	esi
	mov	ecx, ebx
	call	?_Buy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAE_NI@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Buy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 217  : 	return (_Uninit_alloc_fill_n1(_First, _Count, _Val, _Al,

	push	DWORD PTR $T3[ebp]
	push	ebx
	push	DWORD PTR __Val$[ebp]
	push	edi
	push	DWORD PTR [ebx]
	call	??$_Uninit_alloc_fill_n1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@IU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@PAV10@IABV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninit_alloc_fill_n1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,unsigned int,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >
	add	esp, 20					; 00000014H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1310 : 			this->_Mylast() = _Ufill(this->_Myfirst(), _Newsize, _Val);

	mov	DWORD PTR [ebx+4], eax
	pop	edi
	pop	esi
	pop	ebx

; 1323 : 			}
; 1324 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN2@assign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2682 : 	return {};

	mov	BYTE PTR $T1[ebp], 0

; 2704 : 	_Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));

	push	DWORD PTR $T1[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1312 : 		else if (_Newsize > _Oldsize)

	cmp	edi, eax
	jbe	SHORT $LN6@assign
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2704 : 	_Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));

	mov	esi, DWORD PTR __Val$[ebp]
	push	esi
	push	DWORD PTR [ebx+4]
	push	edx
	call	??$_Fill_unchecked1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@0ABV10@U?$integral_constant@_N$0A@@0@@Z ; std::_Fill_unchecked1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 217  : 	return (_Uninit_alloc_fill_n1(_First, _Count, _Val, _Al,

	push	DWORD PTR $T2[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1315 : 			this->_Mylast() = _Ufill(this->_Mylast(), _Newsize - _Oldsize, _Val);

	sub	edi, DWORD PTR __Oldsize$1$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory

; 217  : 	return (_Uninit_alloc_fill_n1(_First, _Count, _Val, _Al,

	push	ebx
	push	esi
	push	edi
	push	DWORD PTR [ebx+4]
	call	??$_Uninit_alloc_fill_n1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@IU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@PAV10@IABV10@AAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Uninit_alloc_fill_n1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,unsigned int,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >
	add	esp, 36					; 00000024H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1315 : 			this->_Mylast() = _Ufill(this->_Mylast(), _Newsize - _Oldsize, _Val);

	mov	DWORD PTR [ebx+4], eax
	pop	edi
	pop	esi
	pop	ebx

; 1323 : 			}
; 1324 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN6@assign:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2704 : 	_Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));

	push	DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1319 : 			const pointer _Newlast = this->_Myfirst() + _Newsize;

	lea	esi, DWORD PTR [edx+edi*4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 2704 : 	_Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));

	push	esi
	push	edx
	call	??$_Fill_unchecked1@PAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@std@@YAXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@0@0ABV10@U?$integral_constant@_N$0A@@0@@Z ; std::_Fill_unchecked1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > *,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1322 : 			this->_Mylast() = _Newlast;

	mov	DWORD PTR [ebx+4], esi
	pop	edi
	pop	esi
	pop	ebx

; 1323 : 			}
; 1324 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN297@assign:

; 1296 : 				{
; 1297 : 				_Xlength();

	call	?_Xlength@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Xlength
$LN299@assign:
$LN296@assign:
	int	3
?assign@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEXIABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@Z ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::~vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >, COMDAT
; _this$ = ecx

; 891  : 		{	// destroy the object

	npad	2
	push	esi
	mov	esi, ecx

; 1949 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 892  : 		_Tidy();
; 893  : 		}

	ret	0
??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::~vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??0?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@@Z PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >, COMDAT
; _this$ = ecx

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 728  : 		}

	mov	eax, ecx

; 477  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 478  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 728  : 		}

	ret	4
??0?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@ABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@1@@Z ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 343  : 		return (_Myval2);

	mov	eax, ecx

; 344  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 338  : 		return (_Myval2);

	mov	eax, ecx

; 339  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 323  : 		return (*this);

	mov	eax, ecx

; 324  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 318  : 		return (*this);

	mov	eax, ecx

; 319  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >,std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >, COMDAT
; _this$ = ecx

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 480  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBEABQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBEABQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Myend, COMDAT
; _this$ = ecx

; 676  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 677  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBEABQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEAAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEAAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Myend, COMDAT
; _this$ = ecx

; 671  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 672  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEAAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBEABQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBEABQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Mylast, COMDAT
; _this$ = ecx

; 666  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 667  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBEABQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEAAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEAAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Mylast, COMDAT
; _this$ = ecx

; 661  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 662  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEAAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBEABQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBEABQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Myfirst, COMDAT
; _this$ = ecx

; 656  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 657  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBEABQAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEAAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEAAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Myfirst, COMDAT
; _this$ = ecx

; 651  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 652  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEAAPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Get_data, COMDAT
; _this$ = ecx

; 646  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 647  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Get_data, COMDAT
; _this$ = ecx

; 641  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 642  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBEABU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBEABU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Getal, COMDAT
; _this$ = ecx

; 636  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 637  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QBEABU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Getal, COMDAT
; _this$ = ecx

; 631  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 632  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Orphan_all, COMDAT
; _this$ = ecx

; 621  : 		_Get_data()._Orphan_all();
; 622  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::max_size, COMDAT
; _this$ = ecx

; 1108 : 		return (_Mytraits::max_size(*this));

	mov	eax, 1073741823				; 3fffffffH

; 1109 : 		}

	ret	4
?max_size@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z PROC ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::deallocate, COMDAT
; _this$ = ecx

; 1087 : 		{	// deallocate object at _Ptr, ignore size

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 1088 : 		_Mybase::deallocate(_Ptr, _Count);
; 1089 : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z ENDP ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z PROC ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::allocate, COMDAT
; _this$ = ecx

; 1076 : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 1078 : 		}

	pop	ebp

; 1077 : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::allocate
?allocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z ENDP ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAIABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAIABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@Z PROC ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::max_size, COMDAT

; 751  : 		return (_Alloc_max_size::_Fn(0, _Al));

	mov	eax, 1073741823				; 3fffffffH

; 752  : 		}

	ret	0
?max_size@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAIABU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >::max_size, COMDAT
; _this$ = ecx

; 1108 : 		return (_Mytraits::max_size(*this));

	mov	eax, 1073741823				; 3fffffffH

; 1109 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >::deallocate, COMDAT
; _this$ = ecx

; 1087 : 		{	// deallocate object at _Ptr, ignore size

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 1088 : 		_Mybase::deallocate(_Ptr, _Count);
; 1089 : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >::allocate, COMDAT
; _this$ = ecx

; 1076 : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 1078 : 		}

	pop	ebp

; 1077 : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::allocate
?allocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABU01@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >, COMDAT
; _this$ = ecx

; 1043 : 		}

	mov	eax, ecx
	ret	4
??0?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@QAE@ABU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >::max_size, COMDAT

; 970  : 		return (_Al.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 971  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::max_size, COMDAT
; _this$ = ecx

; 851  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 1073741823				; 3fffffffH

; 852  : 		}

	ret	0
?max_size@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::allocate, COMDAT
; _this$ = ecx

; 827  : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 53   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN5@allocate

; 58   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 2

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 69   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN9@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@allocate:
$LN9@allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 87   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@allocate:
$LN14@allocate:
	int	3
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@QAEPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::deallocate, COMDAT
; _this$ = ecx

; 822  : 		{	// deallocate object at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 824  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@QAEXPAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >, COMDAT
; _this$ = ecx

; 807  : 		{	// construct by copying (do nothing)
; 808  : 		}

	mov	eax, ecx
	ret	4
??0?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IBEABMXZ
_TEXT	SEGMENT
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IBEABMXZ PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Max_bucket_size, COMDAT
; _this$ = ecx

; 960  : 		return (_Traitsobj._Get_max_bucket_size());

	mov	eax, ecx

; 961  : 		}

	ret	0
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IBEABMXZ ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Max_bucket_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Max_bucket_size@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEAAMXZ
_TEXT	SEGMENT
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEAAMXZ PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Max_bucket_size, COMDAT
; _this$ = ecx

; 955  : 		return (_Traitsobj._Get_max_bucket_size());

	mov	eax, ecx

; 956  : 		}

	ret	0
?_Max_bucket_size@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEAAMXZ ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Max_bucket_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Reinsert@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -8						; size = 8
?_Reinsert@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEXXZ PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Reinsert, COMDAT
; _this$ = ecx

; 940  : 		{	// insert elements in [begin(), end())

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	mov	ebx, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [ebx+4]

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	DWORD PTR [eax], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 942  : 		if (_Unchecked_begin() != _Last)

	je	SHORT $LN119@Reinsert
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);

	mov	edi, DWORD PTR [eax+4]
$LL2@Reinsert:

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	esi, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 947  : 				_Insert(*_First, _First);

	mov	ecx, ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 43   : 		: _Ptr(_Pnode)

	mov	esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 947  : 				_Insert(*_First, _First);

	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 540  : 		return ((reference)_Pnode->_Myval);

	lea	eax, DWORD PTR [esi+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 947  : 				_Insert(*_First, _First);

	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??$_Insert@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Insert<std::pair<ISteamUser * const,IWrapSteamUser *> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	esi, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 948  : 				if (_Done)

	jne	SHORT $LL2@Reinsert
	pop	edi
	pop	esi
$LN119@Reinsert:
	pop	ebx

; 949  : 					break;
; 950  : 				}
; 951  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Reinsert@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Reinsert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Check_size@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -8						; size = 8
?_Check_size@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEXXZ PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Check_size, COMDAT
; _this$ = ecx

; 924  : 		{	// grow table as needed

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	mov	ebx, ecx

; 494  : 		return ((float)size() / (float)bucket_count());

	mov	eax, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR [ebx+28]
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	eax, ecx
	shr	eax, 31					; 0000001fH
	cvtpd2ps xmm1, xmm0
	movd	xmm0, ecx
	cvtdq2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	divss	xmm1, xmm0

; 925  : 		if (max_load_factor() < load_factor())

	comiss	xmm1, DWORD PTR [ebx]
	jbe	SHORT $LN191@Check_size

; 926  : 
; 927  : 			{	// rehash to bigger table
; 928  : 			size_type _Newsize = bucket_count();
; 929  : 
; 930  : 			if (_Newsize < 512)

	cmp	ecx, 512				; 00000200H
	jae	SHORT $LN3@Check_size

; 931  : 				_Newsize *= 8;	// multiply by 8

	shl	ecx, 3
	jmp	SHORT $LN5@Check_size
$LN3@Check_size:

; 932  : 			else if (_Newsize < _Vec.max_size() / 2)

	cmp	ecx, 536870911				; 1fffffffH
	jae	SHORT $LN5@Check_size

; 933  : 				_Newsize *= 2;	// multiply safely by 2

	add	ecx, ecx
$LN5@Check_size:
	push	edi

; 934  : 			_Init(_Newsize);

	push	ecx
	mov	ecx, ebx
	call	?_Init@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEXI@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Init
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 43   : 		: _Ptr(_Pnode)

	mov	edi, DWORD PTR [ebx+4]

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	DWORD PTR [edi], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 942  : 		if (_Unchecked_begin() != _Last)

	je	SHORT $LN194@Check_size
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);

	mov	edi, DWORD PTR [edi+4]
	push	esi
$LL74@Check_size:

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	esi, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 947  : 				_Insert(*_First, _First);

	mov	ecx, ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 43   : 		: _Ptr(_Pnode)

	mov	esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 947  : 				_Insert(*_First, _First);

	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 540  : 		return ((reference)_Pnode->_Myval);

	lea	eax, DWORD PTR [esi+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 947  : 				_Insert(*_First, _First);

	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??$_Insert@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAE?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@_N@1@AAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Insert<std::pair<ISteamUser * const,IWrapSteamUser *> &,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > >
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	esi, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 948  : 				if (_Done)

	jne	SHORT $LL74@Check_size
	pop	esi
$LN194@Check_size:
	pop	edi
$LN191@Check_size:
	pop	ebx

; 935  : 			_Reinsert();
; 936  : 			}
; 937  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Check_size@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Check_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Init@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Buckets$ = 8						; size = 4
?_Init@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEXI@Z PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Init, COMDAT
; _this$ = ecx

; 916  : 		{	// initialize hash table with _Buckets buckets, leave list alone

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	mov	ebx, ecx
	push	esi

; 917  : 		_Vec.reserve(2 * _Buckets);	// avoid curdling _Vec if exception occurs

	mov	esi, DWORD PTR __Buckets$[ebp]
	add	esi, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [ebx+20]
	sub	eax, DWORD PTR [ebx+12]
	sar	eax, 2
	push	edi

; 1529 : 		if (_Newcapacity > capacity())

	cmp	esi, eax
	jbe	SHORT $LN4@Init

; 1530 : 			{	// something to do (reserve() never shrinks)
; 1531 : 			if (_Newcapacity > max_size())

	cmp	esi, 1073741823				; 3fffffffH
	ja	SHORT $LN85@Init

; 1534 : 				}
; 1535 : 
; 1536 : 			_Reallocate_exactly(_Newcapacity);

	push	esi
	lea	ecx, DWORD PTR [ebx+12]
	call	?_Reallocate_exactly@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXI@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Reallocate_exactly
$LN4@Init:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 918  : 		_Vec.assign(2 * _Buckets, _Unchecked_end());

	lea	ecx, DWORD PTR [ebx+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 43   : 		: _Ptr(_Pnode)

	mov	DWORD PTR $T1[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 918  : 		_Vec.assign(2 * _Buckets, _Unchecked_end());

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	push	esi
	call	?assign@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEXIABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::assign

; 919  : 		_Mask = _Buckets - 1;

	mov	ecx, DWORD PTR __Buckets$[ebp]
	pop	edi
	pop	esi

; 920  : 		_Maxidx = _Buckets;

	mov	DWORD PTR [ebx+28], ecx
	lea	eax, DWORD PTR [ecx-1]
	mov	DWORD PTR [ebx+24], eax
	pop	ebx

; 921  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN85@Init:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1533 : 				_Xlength();

	call	?_Xlength@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Xlength
$LN87@Init:
$LN84@Init:
	int	3
?_Init@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEXI@Z ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Hashval@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IBEIABQAVISteamUser@@@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Hashval@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IBEIABQAVISteamUser@@@Z PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Hashval, COMDAT
; _this$ = ecx

; 911  : 		{	// return hash value, masked to current table size

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	mov	esi, DWORD PTR __Keyval$[ebp]
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 911  : 		{	// return hash value, masked to current table size

	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	movzx	eax, BYTE PTR [esi]
	xor	eax, -2128831035			; 811c9dc5H

; 347  : 		_Val *= _FNV_prime;

	imul	edx, eax, 16777619
	movzx	eax, BYTE PTR [esi+1]
	xor	edx, eax
	movzx	eax, BYTE PTR [esi+2]
	imul	edx, edx, 16777619
	xor	edx, eax
	movzx	eax, BYTE PTR [esi+3]
	imul	ecx, edx, 16777619
	xor	ecx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 912  : 		return (_Traitsobj(_Keyval) & _Mask);

	mov	eax, DWORD PTR [edi+24]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 347  : 		_Val *= _FNV_prime;

	imul	ecx, ecx, 16777619
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 912  : 		return (_Traitsobj(_Keyval) & _Mask);

	and	eax, ecx

; 913  : 		}

	pop	ebp
	ret	4
?_Hashval@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IBEIABQAVISteamUser@@@Z ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Hashval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Insert_bucket@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@0I@Z
_TEXT	SEGMENT
__Plist$ = 8						; size = 4
__Where$ = 12						; size = 4
__Bucket$ = 16						; size = 4
?_Insert_bucket@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@0I@Z PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Insert_bucket, COMDAT
; _this$ = ecx

; 882  : 		{	// fix iterators after inserting _Plist before _Where

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1746 : 		return (this->_Myfirst()[_Pos]);

	mov	eax, DWORD PTR __Bucket$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	mov	edx, DWORD PTR [ecx+12]
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1746 : 		return (this->_Myfirst()[_Pos]);

	lea	esi, DWORD PTR [eax*8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [edx+esi]
	add	edx, esi
	cmp	eax, DWORD PTR [ecx+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 883  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())

	jne	SHORT $LN2@Insert_buc

; 884  : 			{	// make bucket non-empty
; 885  : 			_Vec_lo(_Bucket) = _Plist;

	mov	eax, DWORD PTR __Plist$[ebp]
	mov	DWORD PTR [edx], eax

; 886  : 			_Vec_hi(_Bucket) = _Plist;

	mov	ecx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR __Plist$[ebp]
	mov	DWORD PTR [esi+ecx+4], eax
	pop	esi

; 892  : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN2@Insert_buc:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	eax, DWORD PTR __Where$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 888  : 		else if (_Vec_lo(_Bucket) == _Where)

	jne	SHORT $LN4@Insert_buc

; 889  : 			_Vec_lo(_Bucket) = _Plist;	// move beginning back one element

	mov	eax, DWORD PTR __Plist$[ebp]
	mov	DWORD PTR [edx], eax
	pop	esi

; 892  : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN4@Insert_buc:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [edx+4]

; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx+4], eax

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	eax, DWORD PTR __Plist$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 890  : 		else if (++_Vec_hi(_Bucket) != _Plist)	// move end up one element

	je	SHORT $LN6@Insert_buc
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1746 : 		return (this->_Myfirst()[_Pos]);

	mov	ecx, DWORD PTR [ecx+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);

	mov	eax, DWORD PTR [ecx+esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+esi+4], eax
$LN6@Insert_buc:
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 892  : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Insert_bucket@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@0I@Z ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Insert_bucket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Erase_bucket@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z
_TEXT	SEGMENT
__Plist_arg$ = 8					; size = 4
__Bucket$ = 12						; size = 4
?_Erase_bucket@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Erase_bucket, COMDAT
; _this$ = ecx

; 866  : 		{	// fix iterators before erasing _Plist before _Where

	npad	2
	push	ebp
	mov	ebp, esp

; 868  : 		if (_Vec_hi(_Bucket) == _Plist)

	mov	eax, DWORD PTR __Bucket$[ebp]
	push	esi
	mov	esi, ecx
	push	edi
	lea	edi, DWORD PTR [eax*8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __Plist_arg$[ebp]
	mov	edx, DWORD PTR [esi+12]
	add	edx, edi
	cmp	DWORD PTR [edx+4], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 868  : 		if (_Vec_hi(_Bucket) == _Plist)

	jne	SHORT $LN2@Erase_buck
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	DWORD PTR [edx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 869  : 			if (_Vec_lo(_Bucket) == _Plist)

	jne	SHORT $LN4@Erase_buck

; 870  : 				{	// make bucket empty
; 871  : 				_Vec_lo(_Bucket) = _Unchecked_end();

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edx], eax

; 872  : 				_Vec_hi(_Bucket) = _Unchecked_end();

	mov	ecx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+ecx+4], eax
	pop	edi
	pop	esi

; 878  : 		}

	pop	ebp
	ret	8
$LN4@Erase_buck:

; 873  : 				}
; 874  : 			else
; 875  : 				_Vec_hi(_Bucket) = --_Plist;	// move end back one element

	mov	eax, DWORD PTR [eax+4]
	pop	edi
	mov	DWORD PTR [edx+4], eax
	pop	esi

; 878  : 		}

	pop	ebp
	ret	8
$LN2@Erase_buck:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	DWORD PTR [edx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 876  : 		else if (_Vec_lo(_Bucket) == _Plist)

	jne	SHORT $LN6@Erase_buck

; 877  : 			_Vec_lo(_Bucket) = ++_Plist;	// move beginning up one element

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
$LN6@Erase_buck:
	pop	edi
	pop	esi

; 878  : 		}

	pop	ebp
	ret	8
?_Erase_bucket@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Erase_bucket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_End@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@I@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Bucket$ = 12						; size = 4
?_End@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@I@Z PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_End, COMDAT
; _this$ = ecx

; 855  : 		{	// return end iterator for bucket _Bucket

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR __Bucket$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+eax*8]
	cmp	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 856  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())

	je	SHORT $LN89@End
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 861  : 			return (++_Ans);

	mov	ecx, DWORD PTR [eax]
$LN89@End:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 862  : 			}
; 863  : 		}

	pop	ebp
	ret	8
?_End@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@I@Z ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_End
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_End@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Bucket$ = 12						; size = 4
?_End@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_End, COMDAT
; _this$ = ecx

; 845  : 		{	// return end iterator for bucket _Bucket

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR __Bucket$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+eax*8]
	cmp	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 846  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())

	je	SHORT $LN95@End
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 851  : 			return (++_Ans);

	mov	ecx, DWORD PTR [eax]
$LN95@End:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 852  : 			}
; 853  : 		}

	pop	ebp
	ret	8
?_End@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_End
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Begin@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@I@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Bucket$ = 12						; size = 4
?_Begin@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@I@Z PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Begin, COMDAT
; _this$ = ecx

; 840  : 		{	// return begin iterator for bucket _Bucket

	npad	2
	push	ebp
	mov	ebp, esp

; 841  : 		return (_Vec_lo(_Bucket));

	mov	eax, DWORD PTR __Bucket$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 842  : 		}

	pop	ebp
	ret	8
?_Begin@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@I@Z ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Begin@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Bucket$ = 12						; size = 4
?_Begin@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Begin, COMDAT
; _this$ = ecx

; 835  : 		{	// return begin iterator for bucket _Bucket

	npad	2
	push	ebp
	mov	ebp, esp

; 836  : 		return (_Vec_lo(_Bucket));

	mov	eax, DWORD PTR __Bucket$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 837  : 		}

	pop	ebp
	ret	8
?_Begin@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Vec_hi@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IBEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@I@Z
_TEXT	SEGMENT
__Bucket$ = 8						; size = 4
?_Vec_hi@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IBEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@I@Z PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Vec_hi, COMDAT
; _this$ = ecx

; 830  : 		{	// return reference to end()-1 for _Bucket

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1760 : 		return (this->_Myfirst()[_Pos]);

	mov	eax, DWORD PTR __Bucket$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [eax*8+4]
	add	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 832  : 		}

	pop	ebp
	ret	4
?_Vec_hi@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IBEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@I@Z ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Vec_hi
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Vec_hi@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEAAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z
_TEXT	SEGMENT
__Bucket$ = 8						; size = 4
?_Vec_hi@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEAAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Vec_hi, COMDAT
; _this$ = ecx

; 825  : 		{	// return reference to end()-1 for _Bucket

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1746 : 		return (this->_Myfirst()[_Pos]);

	mov	eax, DWORD PTR __Bucket$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [eax*8+4]
	add	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 827  : 		}

	pop	ebp
	ret	4
?_Vec_hi@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEAAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Vec_hi
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Vec_lo@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IBEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@I@Z
_TEXT	SEGMENT
__Bucket$ = 8						; size = 4
?_Vec_lo@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IBEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@I@Z PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Vec_lo, COMDAT
; _this$ = ecx

; 820  : 		{	// return reference to begin() for _Bucket

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1760 : 		return (this->_Myfirst()[_Pos]);

	mov	ecx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR __Bucket$[ebp]
	lea	eax, DWORD PTR [ecx+eax*8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 822  : 		}

	pop	ebp
	ret	4
?_Vec_lo@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IBEAAV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@I@Z ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Vec_lo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Vec_lo@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEAAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z
_TEXT	SEGMENT
__Bucket$ = 8						; size = 4
?_Vec_lo@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEAAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Vec_lo, COMDAT
; _this$ = ecx

; 815  : 		{	// return reference to begin() for _Bucket

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1746 : 		return (this->_Myfirst()[_Pos]);

	mov	ecx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR __Bucket$[ebp]
	lea	eax, DWORD PTR [ecx+eax*8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 817  : 		}

	pop	ebp
	ret	4
?_Vec_lo@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEAAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@I@Z ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Vec_lo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Destroy_if_not_nil@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__Plist$ = 8						; size = 4
?_Destroy_if_not_nil@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@Z PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Destroy_if_not_nil, COMDAT
; _this$ = ecx

; 750  : 		{	// node exists, destroy it

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 96   : 		return (_Ptr);

	mov	esi, DWORD PTR __Plist$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	16					; 00000010H
	push	1
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	edx, DWORD PTR [esi+4]

; 1490 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edx], eax

; 1491 : 			this->_Nextnode(_Pnode);
; 1492 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [edx+4], eax

; 1493 : 			this->_Prevnode(_Pnode);
; 1494 : 
; 1495 : 		--this->_Mysize();

	dec	DWORD PTR [ecx+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 752  : 		}

	pop	ebp
	ret	4
?_Destroy_if_not_nil@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@IAEXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Destroy_if_not_nil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?equal_range@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@2@ABQAVISteamUser@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
tv929 = 12						; size = 4
__Keyval$ = 12						; size = 4
?equal_range@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@2@ABQAVISteamUser@@@Z PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::equal_range, COMDAT
; _this$ = ecx

; 703  : 		{	// find range equivalent to _Keyval in nonmutable hash table

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	mov	ebx, DWORD PTR __Keyval$[ebp]
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 703  : 		{	// find range equivalent to _Keyval in nonmutable hash table

	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	movzx	eax, BYTE PTR [ebx]
	xor	eax, -2128831035			; 811c9dc5H

; 347  : 		_Val *= _FNV_prime;

	imul	edx, eax, 16777619
	movzx	eax, BYTE PTR [ebx+1]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1760 : 		return (this->_Myfirst()[_Pos]);

	mov	esi, DWORD PTR [edi+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	xor	edx, eax
	movzx	eax, BYTE PTR [ebx+2]

; 347  : 		_Val *= _FNV_prime;

	imul	edx, edx, 16777619
	xor	edx, eax
	movzx	eax, BYTE PTR [ebx+3]
	imul	ecx, edx, 16777619
	xor	ecx, eax
	imul	eax, ecx, 16777619
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 912  : 		return (_Traitsobj(_Keyval) & _Mask);

	mov	ecx, DWORD PTR [edi+24]
	and	ecx, eax

; 841  : 		return (_Vec_lo(_Bucket));

	mov	eax, DWORD PTR [esi+ecx*8]

; 821  : 		return ((_Unchecked_const_iterator&)_Vec[2 * _Bucket]);

	lea	edx, DWORD PTR [ecx+ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 1183 : 		return (_Unchecked_const_iterator(this->_Myhead(),

	mov	ecx, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1760 : 		return (this->_Myfirst()[_Pos]);

	lea	edi, DWORD PTR [esi+edx*4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	mov	ebx, DWORD PTR [esi+edx*4]
	mov	esi, DWORD PTR __Keyval$[ebp]
	npad	7
$LL4@equal_rang:
	cmp	ebx, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 856  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())

	jne	SHORT $LN49@equal_rang

; 857  : 			return (_Unchecked_end());

	mov	edx, ecx
	jmp	SHORT $LN50@equal_rang
$LN49@equal_rang:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	edx, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 861  : 			return (++_Ans);

	mov	edx, DWORD PTR [edx]
$LN50@equal_rang:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 706  : 			_Where != _End(_Bucket); ++_Where)

	je	SHORT $LN3@equal_rang
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 220  : 		return (_Left == _Right);

	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 707  : 			if (!_Traitsobj(_Traits::_Kfn(*_Where), _Keyval))

	je	SHORT $LN399@equal_rang
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LL4@equal_rang
$LN399@equal_rang:
	mov	esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 709  : 				_Unchecked_const_iterator _First = _Where;

	mov	edx, eax
	mov	DWORD PTR tv929[ebp], esi
$LL7@equal_rang:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	ebx, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 856  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())

	jne	SHORT $LN164@equal_rang

; 857  : 			return (_Unchecked_end());

	mov	esi, ecx
	jmp	SHORT $LN165@equal_rang
$LN164@equal_rang:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	esi, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 861  : 			return (++_Ans);

	mov	esi, DWORD PTR [esi]
$LN165@equal_rang:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 710  : 				for (; _Where != _End(_Bucket); ++_Where)

	je	SHORT $LN400@equal_rang
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 220  : 		return (_Left == _Right);

	mov	esi, DWORD PTR tv929[ebp]
	cmp	esi, DWORD PTR [eax+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 711  : 					if (_Traitsobj(_Keyval, _Traits::_Kfn(*_Where)))

	jne	SHORT $LN400@equal_rang
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LL7@equal_rang
$LN400@equal_rang:

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 713  : 				if (_First == _Where)

	je	SHORT $LN3@equal_rang
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	DWORD PTR [ecx+4], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 715  : 				return (_Paircc(_Make_iter(_First),

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	DWORD PTR [ecx], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 719  : 		}

	pop	ebp
	ret	8
$LN3@equal_rang:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\utility

; 187  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR [eax], ecx

; 188  : 				second(_STD forward<_Other2>(_Val2))

	mov	DWORD PTR [eax+4], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 719  : 		}

	pop	ebp
	ret	8
?equal_range@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@2@ABQAVISteamUser@@@Z ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::equal_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?lower_bound@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@ABQAVISteamUser@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@ABQAVISteamUser@@@Z PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 640  : 		{	// find leftmost not less than _Keyval in mutable hash table

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	mov	edi, DWORD PTR __Keyval$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 640  : 		{	// find leftmost not less than _Keyval in mutable hash table

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	movzx	eax, BYTE PTR [edi]
	xor	eax, -2128831035			; 811c9dc5H

; 347  : 		_Val *= _FNV_prime;

	imul	edx, eax, 16777619
	movzx	eax, BYTE PTR [edi+1]
	xor	edx, eax
	movzx	eax, BYTE PTR [edi+2]
	imul	edx, edx, 16777619
	xor	edx, eax
	movzx	eax, BYTE PTR [edi+3]
	imul	ecx, edx, 16777619
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1746 : 		return (this->_Myfirst()[_Pos]);

	mov	edx, DWORD PTR [esi+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	xor	ecx, eax

; 347  : 		_Val *= _FNV_prime;

	imul	eax, ecx, 16777619
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 912  : 		return (_Traitsobj(_Keyval) & _Mask);

	mov	ecx, DWORD PTR [esi+24]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 1178 : 		return (_Unchecked_iterator(this->_Myhead(), _STD addressof(this->_Get_data())));

	mov	esi, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 912  : 		return (_Traitsobj(_Keyval) & _Mask);

	and	ecx, eax

; 836  : 		return (_Vec_lo(_Bucket));

	mov	eax, DWORD PTR [edx+ecx*8]

; 816  : 		return (_Vec[2 * _Bucket]);

	add	ecx, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	mov	ebx, DWORD PTR [edx+ecx*4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1746 : 		return (this->_Myfirst()[_Pos]);

	lea	edx, DWORD PTR [edx+ecx*4]
$LL4@lower_boun:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	ebx, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 846  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())

	jne	SHORT $LN48@lower_boun

; 847  : 			return (_Unchecked_end());

	mov	ecx, esi
	jmp	SHORT $LN49@lower_boun
$LN48@lower_boun:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	ecx, DWORD PTR [edx+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 851  : 			return (++_Ans);

	mov	ecx, DWORD PTR [ecx]
$LN49@lower_boun:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 643  : 			_Where != _End(_Bucket); ++_Where)

	je	SHORT $LN3@lower_boun
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 220  : 		return (_Left == _Right);

	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 644  : 			if (!_Traitsobj(_Traits::_Kfn(*_Where), _Keyval))

	je	SHORT $LN274@lower_boun
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LL4@lower_boun
$LN274@lower_boun:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 220  : 		return (_Left == _Right);

	mov	ecx, DWORD PTR [edi]
	cmp	ecx, DWORD PTR [eax+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 645  : 				return (_Traitsobj(_Keyval,

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	cmovne	eax, esi
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebx

; 648  : 		}

	pop	ebp
	ret	8
$LN3@lower_boun:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 648  : 		}

	pop	ebp
	ret	8
?lower_bound@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@ABQAVISteamUser@@@Z ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::lower_bound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?count@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBEIABQAVISteamUser@@@Z
_TEXT	SEGMENT
__Ans$ = -8						; size = 8
__Keyval$ = 8						; size = 4
?count@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBEIABQAVISteamUser@@@Z PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::count, COMDAT
; _this$ = ecx

; 634  : 		{	// count all elements that match _Keyval

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 635  : 		_Paircc _Ans = equal_range(_Keyval);

	push	DWORD PTR __Keyval$[ebp]
	lea	eax, DWORD PTR __Ans$[ebp]
	push	eax
	call	?equal_range@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBE?AU?$pair@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@V12@@2@ABQAVISteamUser@@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::equal_range
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1113 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));

	mov	ecx, DWORD PTR __Ans$[ebp]

; 1095 : 	_Iter_diff_t<_InIt> _Off = 0;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 297  : 		return (this->_Ptr == _Right._Ptr);

	mov	edx, DWORD PTR __Ans$[ebp+4]
	cmp	ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1096 : 	for (; _First != _Last; ++_First)

	je	SHORT $LN7@count
$LL8@count:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 242  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	ecx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1097 : 		++_Off;

	inc	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 297  : 		return (this->_Ptr == _Right._Ptr);

	cmp	ecx, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 1096 : 	for (; _First != _Last; ++_First)

	jne	SHORT $LL8@count
$LN7@count:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 637  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?count@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBEIABQAVISteamUser@@@Z ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::count
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?find@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@ABQAVISteamUser@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@ABQAVISteamUser@@@Z PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::find, COMDAT
; _this$ = ecx

; 624  : 		{	// find an element in mutable hash table that matches _Keyval

	npad	2
	push	ebp
	mov	ebp, esp

; 625  : 		return (lower_bound(_Keyval));

	push	DWORD PTR __Keyval$[ebp]
	push	DWORD PTR ___$ReturnUdt$[ebp]
	call	?lower_bound@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@ABQAVISteamUser@@@Z ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::lower_bound
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 626  : 		}

	pop	ebp
	ret	8
?find@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@ABQAVISteamUser@@@Z ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?erase@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Plist$ = 12						; size = 4
?erase@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@Z PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::erase, COMDAT
; _this$ = ecx

; 586  : 		{	// erase element at _Plist

	npad	2
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map

; 67   : 		return (_Val.first);

	mov	edi, DWORD PTR __Plist$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 586  : 		{	// erase element at _Plist

	mov	ebx, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	movzx	eax, BYTE PTR [edi+8]
	xor	eax, -2128831035			; 811c9dc5H

; 347  : 		_Val *= _FNV_prime;

	imul	edx, eax, 16777619
	movzx	eax, BYTE PTR [edi+9]
	xor	edx, eax
	movzx	eax, BYTE PTR [edi+10]
	imul	edx, edx, 16777619
	xor	edx, eax
	movzx	eax, BYTE PTR [edi+11]
	imul	ecx, edx, 16777619
	xor	ecx, eax
	imul	eax, ecx, 16777619
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 912  : 		return (_Traitsobj(_Keyval) & _Mask);

	mov	ecx, DWORD PTR [ebx+24]
	and	ecx, eax

; 868  : 		if (_Vec_hi(_Bucket) == _Plist)

	lea	edx, DWORD PTR [ecx*8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	mov	ecx, DWORD PTR [ebx+12]
	add	ecx, edx
	cmp	DWORD PTR [ecx+4], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 868  : 		if (_Vec_hi(_Bucket) == _Plist)

	jne	SHORT $LN49@erase
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	DWORD PTR [ecx], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 869  : 			if (_Vec_lo(_Bucket) == _Plist)

	jne	SHORT $LN51@erase

; 870  : 				{	// make bucket empty
; 871  : 				_Vec_lo(_Bucket) = _Unchecked_end();

	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [ecx], eax

; 872  : 				_Vec_hi(_Bucket) = _Unchecked_end();

	mov	ecx, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [edx+ecx+4], eax

; 873  : 				}
; 874  : 			else

	jmp	SHORT $LN356@erase
$LN51@erase:

; 875  : 				_Vec_hi(_Bucket) = --_Plist;	// move end back one element

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx+4], eax

; 876  : 		else if (_Vec_lo(_Bucket) == _Plist)

	jmp	SHORT $LN356@erase
$LN49@erase:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

	cmp	DWORD PTR [ecx], edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 876  : 		else if (_Vec_lo(_Bucket) == _Plist)

	jne	SHORT $LN53@erase

; 877  : 			_Vec_lo(_Bucket) = ++_Plist;	// move beginning up one element

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ecx], eax
$LN356@erase:
	mov	edi, DWORD PTR __Plist$[ebp]
$LN53@erase:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [edi+4]

; 242  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	esi, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	16					; 00000010H
	push	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 1490 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =

	mov	DWORD PTR [eax], esi

; 1492 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 1492 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =

	mov	DWORD PTR [ecx+4], eax

; 1493 : 			this->_Prevnode(_Pnode);
; 1494 : 
; 1495 : 		--this->_Mysize();

	dec	DWORD PTR [ebx+8]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 43   : 		: _Ptr(_Pnode)

	mov	DWORD PTR [eax], esi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 591  : 		}

	pop	ebp
	ret	8
?erase@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?max_load_factor@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBEMXZ
_TEXT	SEGMENT
?max_load_factor@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBEMXZ PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::max_load_factor, COMDAT
; _this$ = ecx

; 499  : 		return (_Max_bucket_size());

	fld	DWORD PTR [ecx]

; 500  : 		}

	ret	0
?max_load_factor@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBEMXZ ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::max_load_factor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?load_factor@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBEMXZ
_TEXT	SEGMENT
tv72 = -4						; size = 4
?load_factor@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBEMXZ PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::load_factor, COMDAT
; _this$ = ecx

; 493  : 		{	// return elements per bucket

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 494  : 		return ((float)size() / (float)bucket_count());

	mov	eax, DWORD PTR [ecx+8]
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	eax, DWORD PTR [ecx+28]
	cvtpd2ps xmm1, xmm0
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	divss	xmm1, xmm0
	movss	DWORD PTR tv72[ebp], xmm1
	fld	DWORD PTR tv72[ebp]

; 495  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?load_factor@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBEMXZ ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::load_factor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?bucket_count@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?bucket_count@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBEIXZ PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::bucket_count, COMDAT
; _this$ = ecx

; 421  : 		return (_Maxidx);

	mov	eax, DWORD PTR [ecx+28]

; 422  : 		}

	ret	0
?bucket_count@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::bucket_count
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?size@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBEIXZ PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::size, COMDAT
; _this$ = ecx

; 387  : 		return (_List.size());

	mov	eax, DWORD PTR [ecx+8]

; 388  : 		}

	ret	0
?size@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Make_iter@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@Z PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Make_iter, COMDAT
; _this$ = ecx

; 371  : 		{	// make iterator from const_iterator

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 373  : 		}

	pop	ebp
	ret	8
?_Make_iter@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Make_iter@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Make_iter, COMDAT
; _this$ = ecx

; 366  : 		{	// make iterator from _Unchecked_const_iterator

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 368  : 		}

	pop	ebp
	ret	8
?_Make_iter@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Unchecked_end@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_end@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Unchecked_end, COMDAT
; _this$ = ecx

; 361  : 		{	// return iterator for end of nonmutable sequence

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 363  : 		}

	pop	ebp
	ret	4
?_Unchecked_end@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Unchecked_end@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_end@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Unchecked_end, COMDAT
; _this$ = ecx

; 356  : 		{	// return iterator for end of mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 358  : 		}

	pop	ebp
	ret	4
?_Unchecked_end@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Unchecked_begin@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_begin@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Unchecked_begin, COMDAT
; _this$ = ecx

; 346  : 		{	// return iterator for beginning of mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [ecx+4]

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 348  : 		}

	pop	ebp
	ret	4
?_Unchecked_begin@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?end@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::end, COMDAT
; _this$ = ecx

; 341  : 		{	// return iterator for end of nonmutable sequence

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 343  : 		}

	pop	ebp
	ret	4
?end@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?end@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::end, COMDAT
; _this$ = ecx

; 336  : 		{	// return iterator for end of mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 338  : 		}

	pop	ebp
	ret	4
?end@?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ??1?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::~_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >, COMDAT
; _this$ = ecx

; 307  : 		{	// destroy hash table

	npad	2
	push	edi
	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1949 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [edi+12]
	test	ecx, ecx
	je	SHORT $LN7@Hash

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [edi+20]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1952 : 			this->_Getal().deallocate(this->_Myfirst(), this->_Myend() - this->_Myfirst());

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1954 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [edi+12], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1955 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [edi+16], 0

; 1956 : 			this->_Myend() = pointer();

	mov	DWORD PTR [edi+20], 0
$LN7@Hash:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [edi+4]

; 1539 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead());

	mov	ecx, DWORD PTR [eax]

; 1540 : 		this->_Nextnode(this->_Myhead()) = this->_Myhead();

	mov	DWORD PTR [eax], eax

; 535  : 		return ((_Nodepref)_Pnode->_Prev);

	mov	eax, DWORD PTR [edi+4]

; 1541 : 		this->_Prevnode(this->_Myhead()) = this->_Myhead();

	mov	DWORD PTR [eax+4], eax

; 1542 : 		this->_Mysize() = 0;

	mov	DWORD PTR [edi+8], 0

; 1544 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead(); _Pnode = _Pnext)

	cmp	ecx, DWORD PTR [edi+4]
	je	SHORT $LN109@Hash
	push	esi
	npad	1
$LL110@Hash:

; 1545 : 			{	// delete an element
; 1546 : 			_Pnext = this->_Nextnode(_Pnode);

	mov	esi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 1544 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead(); _Pnode = _Pnext)

	mov	ecx, esi
	cmp	esi, DWORD PTR [edi+4]
	jne	SHORT $LL110@Hash
	pop	esi
$LN109@Hash:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	16					; 00000010H
	push	1
	push	DWORD PTR [edi+4]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 309  : 		}

	ret	0
??1?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::~_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ??0?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@1@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T2 = 8							; size = 4
_this$ = 8						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@1@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z PROC ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >, COMDAT
; _this$ = ecx

; 197  : 		{	// construct empty hash table

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@1@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	lea	ebx, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map

; 38   : 		: _Tr(_Traits)

	mov	eax, DWORD PTR __Parg$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 731  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

	mov	ecx, ebx
	push	edi
	push	0
	push	0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map

; 38   : 		: _Tr(_Traits)

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 195  : 			_List(_Al),

	mov	DWORD PTR _this$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 523  : 		: _Myhead(),

	mov	DWORD PTR [ebx], 0

; 524  : 		_Mysize(0)

	mov	DWORD PTR [ebx+4], 0

; 731  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

	call	?_Buynode0@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Buynode0

; 606  : 		_Myhead() = _Buyheadnode();

	mov	DWORD PTR [ebx], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 195  : 			_List(_Al),

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 476  : 		: _Myfirst(),

	mov	DWORD PTR [esi+12], 0

; 477  : 		_Mylast(),

	mov	DWORD PTR [esi+16], 0

; 478  : 		_Myend()

	mov	DWORD PTR [esi+20], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 198  : 		_Max_bucket_size() = _Bucket_size;

	mov	DWORD PTR [esi], 1065353216		; 3f800000H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1720 : 		return (this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+20]
	sub	eax, DWORD PTR [esi+12]
	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 196  : 			_Vec(_Al)

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vector

; 1529 : 		if (_Newcapacity > capacity())

	cmp	eax, 16					; 00000010H
	jae	SHORT $LN69@Hash

; 1530 : 			{	// something to do (reserve() never shrinks)
; 1531 : 			if (_Newcapacity > max_size())
; 1532 : 				{
; 1533 : 				_Xlength();
; 1534 : 				}
; 1535 : 
; 1536 : 			_Reallocate_exactly(_Newcapacity);

	push	16					; 00000010H
	lea	ecx, DWORD PTR [esi+12]
	call	?_Reallocate_exactly@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@AAEXI@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::_Reallocate_exactly
$LN69@Hash:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 918  : 		_Vec.assign(2 * _Buckets, _Unchecked_end());

	lea	ecx, DWORD PTR [esi+12]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 43   : 		: _Ptr(_Pnode)

	mov	DWORD PTR $T2[ebp], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 918  : 		_Vec.assign(2 * _Buckets, _Unchecked_end());

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	push	16					; 00000010H
	call	?assign@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAEXIABV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::assign

; 199  : 		_Init();
; 200  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	eax, esi
	pop	edi

; 919  : 		_Mask = _Buckets - 1;

	mov	DWORD PTR [esi+24], 7

; 920  : 		_Maxidx = _Buckets;

	mov	DWORD PTR [esi+28], 8
	pop	esi
	pop	ebx

; 199  : 		_Init();
; 200  : 		}

	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@1@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE@XZ ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::~list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >
__unwindfunclet$??0?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@1@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QAE@XZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >::~vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > > > > > >
__ehhandler$??0?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@1@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@1@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Hash@V?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@@std@@QAE@ABV?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@1@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z ENDP ; std::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >::_Hash<std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Incsize@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Incsize@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEXI@Z PROC ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Incsize, COMDAT
; _this$ = ecx

; 1949 : 		{	// alter element count, with checking

	npad	2
	push	ebp
	mov	ebp, esp

; 1950 : 		if (max_size() - this->_Mysize() - 1 < _Count)

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, 268435454				; 0ffffffeH
	push	esi
	mov	esi, DWORD PTR __Count$[ebp]
	sub	eax, edx
	cmp	eax, esi
	jae	SHORT $LN2@Incsize

; 1951 : 			_Xlength_error("list<T> too long");

	push	OFFSET ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN42@Incsize:
$LN2@Incsize:

; 1952 : 		this->_Mysize() += _Count;

	lea	eax, DWORD PTR [edx+esi]
	mov	DWORD PTR [ecx+4], eax
	pop	esi

; 1953 : 		}

	pop	ebp
	ret	4
$LN41@Incsize:
?_Incsize@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEXI@Z ENDP ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Incsize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Tidy@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
?_Tidy@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEXXZ PROC ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Tidy, COMDAT
; _this$ = ecx

; 1926 : 		{	// free all storage

	npad	2
	push	edi
	mov	edi, ecx

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	edx, DWORD PTR [edi]

; 1539 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead());

	mov	eax, DWORD PTR [edx]

; 1540 : 		this->_Nextnode(this->_Myhead()) = this->_Myhead();

	mov	DWORD PTR [edx], edx

; 535  : 		return ((_Nodepref)_Pnode->_Prev);

	mov	edx, DWORD PTR [edi]

; 1541 : 		this->_Prevnode(this->_Myhead()) = this->_Myhead();

	mov	DWORD PTR [edx+4], edx

; 1542 : 		this->_Mysize() = 0;

	mov	DWORD PTR [edi+4], 0

; 1544 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead(); _Pnode = _Pnext)

	cmp	eax, DWORD PTR [edi]
	je	SHORT $LN5@Tidy
	push	esi
	npad	4
$LL6@Tidy:

; 1545 : 			{	// delete an element
; 1546 : 			_Pnext = this->_Nextnode(_Pnode);

	mov	esi, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 1544 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead(); _Pnode = _Pnext)

	mov	eax, esi
	cmp	esi, DWORD PTR [edi]
	jne	SHORT $LL6@Tidy
	pop	esi
$LN5@Tidy:
	pop	edi

; 1927 : 		clear();
; 1928 : 		}

	ret	0
?_Tidy@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEXXZ ENDP ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Unchecked_splice@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@00@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?_Unchecked_splice@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@00@Z PROC ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Unchecked_splice, COMDAT
; _this$ = ecx

; 1909 : 		{	// splice [_First, _Last) before _Where

	npad	2
	push	ebp
	mov	ebp, esp

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+4]

; 1910 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =

	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR [ecx], eax

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR [eax+4]

; 1911 : 			_Last._Mynode();
; 1912 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =

	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [ecx], eax

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, DWORD PTR [eax+4]

; 1913 : 			_Where._Mynode();
; 1914 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], eax

; 535  : 		return ((_Nodepref)_Pnode->_Prev);

	mov	ecx, DWORD PTR __Where$[ebp]

; 1915 : 			_First._Mynode();
; 1916 : 
; 1917 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1918 : 		this->_Prevnode(_Where._Mynode()) =

	mov	eax, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], eax

; 1919 : 			this->_Prevnode(_Last._Mynode());
; 1920 : 		this->_Prevnode(_Last._Mynode()) =

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1921 : 			this->_Prevnode(_First._Mynode());
; 1922 : 		this->_Prevnode(_First._Mynode()) = _Pnode;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [eax+4], edx

; 1923 : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Unchecked_splice@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@00@Z ENDP ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Unchecked_splice
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?clear@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEXXZ PROC ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::clear, COMDAT
; _this$ = ecx

; 1534 : 		{	// erase all

	npad	2
	push	edi
	mov	edi, ecx

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	edx, DWORD PTR [edi]

; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 
; 1537 : 		this->_Orphan_ptr(nullptr);
; 1538 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead());

	mov	eax, DWORD PTR [edx]

; 1540 : 		this->_Nextnode(this->_Myhead()) = this->_Myhead();

	mov	DWORD PTR [edx], edx

; 535  : 		return ((_Nodepref)_Pnode->_Prev);

	mov	edx, DWORD PTR [edi]

; 1541 : 		this->_Prevnode(this->_Myhead()) = this->_Myhead();

	mov	DWORD PTR [edx+4], edx

; 1542 : 		this->_Mysize() = 0;

	mov	DWORD PTR [edi+4], 0

; 1544 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead(); _Pnode = _Pnext)

	cmp	eax, DWORD PTR [edi]
	je	SHORT $LN3@clear
	push	esi
	npad	4
$LL4@clear:

; 1545 : 			{	// delete an element
; 1546 : 			_Pnext = this->_Nextnode(_Pnode);

	mov	esi, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 1544 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead(); _Pnode = _Pnext)

	mov	eax, esi
	cmp	esi, DWORD PTR [edi]
	jne	SHORT $LL4@clear
	pop	esi
$LN3@clear:
	pop	edi

; 1547 : 			this->_Freenode(_Pnode);
; 1548 : 			}
; 1549 : 		}

	ret	0
?clear@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEXXZ ENDP ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?erase@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@Z PROC ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::erase, COMDAT
; _this$ = ecx

; 1500 : 		{	// erase element at _Where

	npad	2
	push	ebp
	mov	ebp, esp

; 248  : 		_Myiter _Tmp = *this;

	mov	eax, DWORD PTR __Where$[ebp]
	push	esi
	push	edi

; 1500 : 		{	// erase element at _Where

	mov	edi, ecx

; 242  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Where$[ebp], edx

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	esi, DWORD PTR [eax+4]

; 1490 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =

	mov	edx, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	16					; 00000010H
	push	1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 1490 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =

	mov	DWORD PTR [esi], edx

; 1492 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 1492 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =

	mov	DWORD PTR [edx+4], ecx

; 1493 : 			this->_Prevnode(_Pnode);
; 1494 : 
; 1495 : 		--this->_Mysize();

	dec	DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR __Where$[ebp]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 1501 : 		_Nodeptr _Pnode = _Unlinknode(_Where++);
; 1502 : 		this->_Freenode(_Pnode);
; 1503 : 		return (_Make_iter(_Where));
; 1504 : 		}

	pop	ebp
	ret	8
?erase@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@Z ENDP ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Unlinknode@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
?_Unlinknode@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@Z PROC ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Unlinknode, COMDAT
; _this$ = ecx

; 1475 : 		{	// unlink node at _Where from the list

	npad	2
	push	ebp
	mov	ebp, esp

; 96   : 		return (_Ptr);

	mov	eax, DWORD PTR __Where$[ebp]
	push	esi

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	esi, DWORD PTR [eax+4]

; 1476 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1477 : 		if (_Where._Getcont() != _STD addressof(this->_Get_data())
; 1478 : 			|| _Where._Ptr == this->_Myhead())
; 1479 : 			{
; 1480 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1481 : 			}
; 1482 : 
; 1483 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1484 : 		_Orphan_ptr(_Pnode);
; 1485 : 
; 1486 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1487 : 		_Nodeptr _Pnode = (_Where)._Mynode();
; 1488 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1489 : 
; 1490 : 		this->_Nextnode(this->_Prevnode(_Pnode)) =

	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [esi], edx

; 1491 : 			this->_Nextnode(_Pnode);
; 1492 : 		this->_Prevnode(this->_Nextnode(_Pnode)) =

	mov	esi, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], edx

; 1493 : 			this->_Prevnode(_Pnode);
; 1494 : 
; 1495 : 		--this->_Mysize();

	dec	DWORD PTR [ecx+4]
	pop	esi

; 1496 : 		return (_Pnode);
; 1497 : 		}

	pop	ebp
	ret	4
?_Unlinknode@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@Z ENDP ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Unlinknode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?front@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@2@XZ
_TEXT	SEGMENT
?front@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@2@XZ PROC ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::front, COMDAT
; _this$ = ecx

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [ecx]

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [eax]

; 540  : 		return ((reference)_Pnode->_Myval);

	add	eax, 8

; 1288 : 		return (*begin());
; 1289 : 		}

	ret	0
?front@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@2@XZ ENDP ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::front
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?max_size@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QBEIXZ PROC ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::max_size, COMDAT
; _this$ = ecx

; 1272 : 		return (this->_Getal().max_size());

	mov	eax, 268435455				; 0fffffffH

; 1273 : 		}

	ret	0
?max_size@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QBEIXZ ENDP ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?size@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QBEIXZ PROC ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::size, COMDAT
; _this$ = ecx

; 1267 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [ecx+4]

; 1268 : 		}

	ret	0
?size@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QBEIXZ ENDP ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Make_iter@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z PROC ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Make_iter, COMDAT
; _this$ = ecx

; 1193 : 		{	// make iterator from _Unchecked_const_iterator

	npad	2
	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [eax], ecx

; 1194 : 		return (iterator(_Where._Ptr, _STD addressof(this->_Get_data())));
; 1195 : 		}

	pop	ebp
	ret	8
?_Make_iter@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ENDP ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Make_iter@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@Z PROC ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Make_iter, COMDAT
; _this$ = ecx

; 1188 : 		{	// make iterator from const_iterator

	npad	2
	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [eax], ecx

; 1189 : 		return (iterator(_Where._Ptr, _STD addressof(this->_Get_data())));
; 1190 : 		}

	pop	ebp
	ret	8
?_Make_iter@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QBE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@@Z ENDP ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Unchecked_end@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_end@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ PROC ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Unchecked_end, COMDAT
; _this$ = ecx

; 1182 : 		{	// return unchecked iterator for end of nonmutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1183 : 		return (_Unchecked_const_iterator(this->_Myhead(),
; 1184 : 			_STD addressof(this->_Get_data())));
; 1185 : 		}

	pop	ebp
	ret	4
?_Unchecked_end@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QBE?AV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@U_Iterator_base0@2@@2@XZ ENDP ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Unchecked_end@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_end@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Unchecked_end, COMDAT
; _this$ = ecx

; 1177 : 		{	// return unchecked iterator for end of mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1178 : 		return (_Unchecked_iterator(this->_Myhead(), _STD addressof(this->_Get_data())));
; 1179 : 		}

	pop	ebp
	ret	4
?_Unchecked_end@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Unchecked_begin@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_begin@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Unchecked_begin, COMDAT
; _this$ = ecx

; 1165 : 		{	// return iterator for beginning of mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [ecx]

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 1166 : 		return (_Unchecked_iterator(this->_Nextnode(this->_Myhead()),
; 1167 : 			_STD addressof(this->_Get_data())));
; 1168 : 		}

	pop	ebp
	ret	4
?_Unchecked_begin@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?end@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::end, COMDAT
; _this$ = ecx

; 1160 : 		{	// return iterator for end of nonmutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1161 : 		return (const_iterator(this->_Myhead(), _STD addressof(this->_Get_data())));
; 1162 : 		}

	pop	ebp
	ret	4
?end@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?end@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::end, COMDAT
; _this$ = ecx

; 1155 : 		{	// return iterator for end of mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1156 : 		return (iterator(this->_Myhead(), _STD addressof(this->_Get_data())));
; 1157 : 		}

	pop	ebp
	ret	4
?end@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?begin@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::begin, COMDAT
; _this$ = ecx

; 1143 : 		{	// return iterator for beginning of mutable sequence

	npad	2
	push	ebp
	mov	ebp, esp

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [ecx]

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 1144 : 		return (iterator(this->_Nextnode(this->_Myhead()),
; 1145 : 			_STD addressof(this->_Get_data())));
; 1146 : 		}

	pop	ebp
	ret	4
?begin@?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??1?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE@XZ PROC ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::~list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy the object

	npad	2
	push	edi
	mov	edi, ecx

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR [edi]

; 1539 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead());

	mov	edx, DWORD PTR [eax]

; 1540 : 		this->_Nextnode(this->_Myhead()) = this->_Myhead();

	mov	DWORD PTR [eax], eax

; 535  : 		return ((_Nodepref)_Pnode->_Prev);

	mov	eax, DWORD PTR [edi]

; 1541 : 		this->_Prevnode(this->_Myhead()) = this->_Myhead();

	mov	DWORD PTR [eax+4], eax

; 1542 : 		this->_Mysize() = 0;

	mov	DWORD PTR [edi+4], 0

; 1544 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead(); _Pnode = _Pnext)

	cmp	edx, DWORD PTR [edi]
	je	SHORT $LN7@list
	push	esi
	npad	4
$LL8@list:

; 1545 : 			{	// delete an element
; 1546 : 			_Pnext = this->_Nextnode(_Pnode);

	mov	esi, DWORD PTR [edx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 140  : 	::operator delete(_Ptr);

	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 1544 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead(); _Pnode = _Pnext)

	mov	edx, esi
	cmp	esi, DWORD PTR [edi]
	jne	SHORT $LL8@list
	pop	esi
$LN7@list:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	16					; 00000010H
	push	1
	push	DWORD PTR [edi]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
	pop	edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 1120 : 		}

	ret	0
??1?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE@XZ ENDP ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::~list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??0?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 4
??0?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z PROC ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >, COMDAT
; _this$ = ecx

; 914  : 		{	// construct empty list, allocator

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 731  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

	push	0
	push	0

; 914  : 		{	// construct empty list, allocator

	mov	DWORD PTR _this$[ebp], esi

; 523  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 524  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 731  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

	call	?_Buynode0@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Buynode0

; 606  : 		_Myhead() = _Buyheadnode();

	mov	DWORD PTR [esi], eax

; 915  : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$list@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE@ABV?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@1@@Z ENDP ; std::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::list<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??1?$_List_buy@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_buy@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE@XZ PROC ; std::_List_buy<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::~_List_buy<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >, COMDAT
; _this$ = ecx

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	16					; 00000010H
	push	1
	push	DWORD PTR [ecx]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
	ret	0
??1?$_List_buy@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAE@XZ ENDP ; std::_List_buy<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::~_List_buy<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Freenode@?$_List_buy@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEXPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freenode@?$_List_buy@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEXPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@@Z PROC ; std::_List_buy<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Freenode, COMDAT
; _this$ = ecx

; 864  : 		{	// give node back

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	16					; 00000010H
	push	1
	push	DWORD PTR __Pnode$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 872  : 		}

	pop	ebp
	ret	4
?_Freenode@?$_List_buy@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@QAEXPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@@Z ENDP ; std::_List_buy<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Freenode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@$00@std@@QBEABV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@$00@std@@QBEABV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >,std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 343  : 		return (_Myval2);

	mov	eax, ecx

; 344  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@$00@std@@QBEABV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >,std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@$00@std@@QAEAAV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@$00@std@@QAEAAV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >,std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 338  : 		return (_Myval2);

	mov	eax, ecx

; 339  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@$00@std@@QAEAAV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >,std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >,std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 323  : 		return (*this);

	mov	eax, ecx

; 324  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >,std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >,std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 318  : 		return (*this);

	mov	eax, ecx

; 319  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@V?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >,std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Myval@?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@SAAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@2@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@SAAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@2@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@@Z PROC ; std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Myval, COMDAT

; 539  : 		{	// return reference to value in node

	npad	2
	push	ebp
	mov	ebp, esp

; 540  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 8

; 541  : 		}

	pop	ebp
	ret	0
?_Myval@?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@SAAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@2@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@@Z ENDP ; std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Prevnode@?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@PAU32@@Z PROC ; std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Prevnode, COMDAT

; 534  : 		{	// return reference to predecessor pointer in node

	npad	2
	push	ebp
	mov	ebp, esp

; 535  : 		return ((_Nodepref)_Pnode->_Prev);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 536  : 		}

	pop	ebp
	ret	0
?_Prevnode@?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@PAU32@@Z ENDP ; std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Prevnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Nextnode@?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@PAU32@@Z PROC ; std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Nextnode, COMDAT

; 529  : 		{	// return reference to successor pointer in node

	npad	2
	push	ebp
	mov	ebp, esp

; 530  : 		return ((_Nodepref)_Pnode->_Next);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 531  : 		}

	pop	ebp
	ret	0
?_Nextnode@?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@PAU32@@Z ENDP ; std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_Nextnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@QAE@XZ PROC ; std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >, COMDAT
; _this$ = ecx

; 523  : 		: _Myhead(),

	mov	DWORD PTR [ecx], 0

; 526  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >::_List_val<std::_List_simple_types<std::pair<ISteamUser * const,IWrapSteamUser *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Mysize@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QBEABIXZ PROC ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Mysize, COMDAT
; _this$ = ecx

; 813  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+4]

; 814  : 		}

	ret	0
?_Mysize@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QBEABIXZ ENDP ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Mysize@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEAAIXZ PROC ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Mysize, COMDAT
; _this$ = ecx

; 808  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+4]

; 809  : 		}

	ret	0
?_Mysize@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEAAIXZ ENDP ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Myhead@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QBEABQAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QBEABQAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@XZ PROC ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Myhead, COMDAT
; _this$ = ecx

; 803  : 		return (_Get_data()._Myhead);

	mov	eax, ecx

; 804  : 		}

	ret	0
?_Myhead@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QBEABQAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Myhead@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEAAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEAAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@XZ PROC ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Myhead, COMDAT
; _this$ = ecx

; 798  : 		return (_Get_data()._Myhead);

	mov	eax, ecx

; 799  : 		}

	ret	0
?_Myhead@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEAAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Get_data@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QBEABV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QBEABV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@XZ PROC ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Get_data, COMDAT
; _this$ = ecx

; 793  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 794  : 		}

	ret	0
?_Get_data@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QBEABV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Get_data@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEAAV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEAAV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@XZ PROC ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Get_data, COMDAT
; _this$ = ecx

; 788  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 789  : 		}

	ret	0
?_Get_data@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEAAV?$_List_val@U?$_List_simple_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Getal@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@2@XZ PROC ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Getal, COMDAT
; _this$ = ecx

; 783  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 784  : 		}

	ret	0
?_Getal@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Getal@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@2@XZ PROC ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Getal, COMDAT
; _this$ = ecx

; 778  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 779  : 		}

	ret	0
?_Getal@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Buynode0@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@PAU32@0@Z
_TEXT	SEGMENT
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
?_Buynode0@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@PAU32@0@Z PROC ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Buynode0, COMDAT
; _this$ = ecx

; 745  : 		{	// allocate a node and set links

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 87   : 		_Ptr = ::operator new(_User_size);

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN26@Buynode0
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN98@Buynode0:
$LN26@Buynode0:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 748  : 		if (_Next == _Nodeptr())

	mov	ecx, DWORD PTR __Next$[ebp]
	test	ecx, ecx
	jne	SHORT $LN95@Buynode0

; 749  : 			{	// point at self
; 750  : 			_Next = _Pnode;

	mov	ecx, eax

; 751  : 			_Prev = _Pnode;

	mov	edx, eax
	jmp	SHORT $LN2@Buynode0
$LN95@Buynode0:
	mov	edx, DWORD PTR __Prev$[ebp]
$LN2@Buynode0:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 535  : 		return ((_Nodepref)_Pnode->_Prev);

	lea	ecx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 840  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN4@Buynode0
	mov	DWORD PTR [ecx], edx
$LN4@Buynode0:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 764  : 		}

	pop	ebp
	ret	8
$LN97@Buynode0:
?_Buynode0@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@PAU32@0@Z ENDP ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Buynode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Freeheadnode@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEXPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freeheadnode@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEXPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@@Z PROC ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Freeheadnode, COMDAT
; _this$ = ecx

; 735  : 		{	// free head node using current allocator

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	16					; 00000010H
	push	1
	push	DWORD PTR __Pnode$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 741  : 		}

	pop	ebp
	ret	4
?_Freeheadnode@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEXPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@@Z ENDP ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Buyheadnode@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Buyheadnode@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@XZ PROC ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Buyheadnode, COMDAT
; _this$ = ecx

; 731  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

	push	0
	push	0
	call	?_Buynode0@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@PAU32@0@Z ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Buynode0

; 732  : 		}

	ret	0
?_Buyheadnode@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@XZ ENDP ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Buyheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ??1?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAE@XZ PROC ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::~_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	16					; 00000010H
	push	1
	push	DWORD PTR [ecx]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list

; 612  : 		}

	ret	0
??1?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@QAE@XZ ENDP ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::~_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Myval@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@SAAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@2@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@SAAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@2@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@@Z PROC ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Myval, COMDAT

; 589  : 		{	// return reference to value in node

	npad	2
	push	ebp
	mov	ebp, esp

; 540  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 8

; 590  : 		return (_List_val<_Val_types>::_Myval(_Pnode));
; 591  : 		}

	pop	ebp
	ret	0
?_Myval@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@SAAAU?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@2@PAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@@Z ENDP ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Prevnode@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@PAU32@@Z PROC ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Prevnode, COMDAT

; 584  : 		{	// return reference to predecessor pointer in node

	npad	2
	push	ebp
	mov	ebp, esp

; 535  : 		return ((_Nodepref)_Pnode->_Prev);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 585  : 		return (_List_val<_Val_types>::_Prevnode(_Pnode));
; 586  : 		}

	pop	ebp
	ret	0
?_Prevnode@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@PAU32@@Z ENDP ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Prevnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\list
;	COMDAT ?_Nextnode@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@PAU32@@Z PROC ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Nextnode, COMDAT

; 579  : 		{	// return reference to successor pointer in node

	npad	2
	push	ebp
	mov	ebp, esp

; 580  : 		return (_List_val<_Val_types>::_Nextnode(_Pnode));

	mov	eax, DWORD PTR __Pnode$[ebp]

; 581  : 		}

	pop	ebp
	ret	0
?_Nextnode@?$_List_alloc@U?$_List_base_types@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@2@@std@@@std@@SAAAPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@PAU32@@Z ENDP ; std::_List_alloc<std::_List_base_types<std::pair<ISteamUser * const,IWrapSteamUser *>,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> > > >::_Nextnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::max_size, COMDAT
; _this$ = ecx

; 1108 : 		return (_Mytraits::max_size(*this));

	mov	eax, 268435455				; 0fffffffH

; 1109 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::deallocate, COMDAT
; _this$ = ecx

; 1087 : 		{	// deallocate object at _Ptr, ignore size

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	16					; 00000010H
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 1088 : 		_Mybase::deallocate(_Ptr, _Count);
; 1089 : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::allocate, COMDAT
; _this$ = ecx

; 1076 : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 1078 : 		}

	pop	ebp

; 1077 : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@I@Z ; std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> >::allocate
?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::max_size, COMDAT

; 970  : 		return (_Al.max_size());

	mov	eax, 268435455				; 0fffffffH

; 971  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@@std@@SAIABV?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?max_size@?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@QBEIXZ PROC ; std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> >::max_size, COMDAT
; _this$ = ecx

; 851  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 268435455				; 0fffffffH

; 852  : 		}

	ret	0
?max_size@?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@I@Z PROC ; std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> >::allocate, COMDAT
; _this$ = ecx

; 827  : 		{	// allocate array of _Count elements

	npad	2
	push	ebp
	mov	ebp, esp

; 53   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 268435455				; 0fffffffH
	jbe	SHORT $LN5@allocate

; 58   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 4

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 69   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN9@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@allocate:
$LN9@allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 828  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 829  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 87   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@allocate:
$LN14@allocate:
	int	3
?allocate@?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@QAEPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@I@Z ENDP ; std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@QAEXPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@QAEXPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@I@Z PROC ; std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> >::deallocate, COMDAT
; _this$ = ecx

; 822  : 		{	// deallocate object at _Ptr

	npad	2
	push	ebp
	mov	ebp, esp

; 823  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	16					; 00000010H
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 824  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@U?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@std@@@std@@QAEXPAU?$_List_node@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@PAX@2@I@Z ENDP ; std::allocator<std::_List_node<std::pair<ISteamUser * const,IWrapSteamUser *>,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ??0?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >, COMDAT
; _this$ = ecx

; 803  : 		{	// construct default allocator (do nothing)
; 804  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\unordered_map
;	COMDAT ??0?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@QAE@ABV?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@1@@Z
_TEXT	SEGMENT
__Traits$ = 8						; size = 4
??0?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@QAE@ABV?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@1@@Z PROC ; std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0>::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with specified comparator

	npad	2
	push	ebp
	mov	ebp, esp

; 38   : 		: _Tr(_Traits)

	mov	eax, DWORD PTR __Traits$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 40   : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??0?$_Umap_traits@PAVISteamUser@@PAVIWrapSteamUser@@V?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@V?$allocator@U?$pair@QAVISteamUser@@PAVIWrapSteamUser@@@std@@@4@$0A@@std@@QAE@ABV?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@1@@Z ENDP ; std::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0>::_Umap_traits<ISteamUser *,IWrapSteamUser *,std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >,std::allocator<std::pair<ISteamUser * const,IWrapSteamUser *> >,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$hash@PAVISteamUser@@@std@@V?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$hash@PAVISteamUser@@@std@@V?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@2@XZ PROC ; std::_Compressed_pair<std::hash<ISteamUser *>,std::_Compressed_pair<std::equal_to<ISteamUser *>,float,1>,1>::_Get_second, COMDAT
; _this$ = ecx

; 343  : 		return (_Myval2);

	mov	eax, ecx

; 344  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$hash@PAVISteamUser@@@std@@V?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@2@XZ ENDP ; std::_Compressed_pair<std::hash<ISteamUser *>,std::_Compressed_pair<std::equal_to<ISteamUser *>,float,1>,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$hash@PAVISteamUser@@@std@@V?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$hash@PAVISteamUser@@@std@@V?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@2@XZ PROC ; std::_Compressed_pair<std::hash<ISteamUser *>,std::_Compressed_pair<std::equal_to<ISteamUser *>,float,1>,1>::_Get_second, COMDAT
; _this$ = ecx

; 338  : 		return (_Myval2);

	mov	eax, ecx

; 339  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$hash@PAVISteamUser@@@std@@V?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@2@XZ ENDP ; std::_Compressed_pair<std::hash<ISteamUser *>,std::_Compressed_pair<std::equal_to<ISteamUser *>,float,1>,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$hash@PAVISteamUser@@@std@@V?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@2@$00@std@@QBEABU?$hash@PAVISteamUser@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$hash@PAVISteamUser@@@std@@V?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@2@$00@std@@QBEABU?$hash@PAVISteamUser@@@2@XZ PROC ; std::_Compressed_pair<std::hash<ISteamUser *>,std::_Compressed_pair<std::equal_to<ISteamUser *>,float,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 323  : 		return (*this);

	mov	eax, ecx

; 324  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$hash@PAVISteamUser@@@std@@V?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@2@$00@std@@QBEABU?$hash@PAVISteamUser@@@2@XZ ENDP ; std::_Compressed_pair<std::hash<ISteamUser *>,std::_Compressed_pair<std::equal_to<ISteamUser *>,float,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@std@@QBEABMXZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@std@@QBEABMXZ PROC ; std::_Compressed_pair<std::equal_to<ISteamUser *>,float,1>::_Get_second, COMDAT
; _this$ = ecx

; 343  : 		return (_Myval2);

	mov	eax, ecx

; 344  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@std@@QBEABMXZ ENDP ; std::_Compressed_pair<std::equal_to<ISteamUser *>,float,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@std@@QAEAAMXZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@std@@QAEAAMXZ PROC ; std::_Compressed_pair<std::equal_to<ISteamUser *>,float,1>::_Get_second, COMDAT
; _this$ = ecx

; 338  : 		return (_Myval2);

	mov	eax, ecx

; 339  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@std@@QAEAAMXZ ENDP ; std::_Compressed_pair<std::equal_to<ISteamUser *>,float,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@std@@QBEABU?$equal_to@PAVISteamUser@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@std@@QBEABU?$equal_to@PAVISteamUser@@@2@XZ PROC ; std::_Compressed_pair<std::equal_to<ISteamUser *>,float,1>::_Get_first, COMDAT
; _this$ = ecx

; 323  : 		return (*this);

	mov	eax, ecx

; 324  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$equal_to@PAVISteamUser@@@std@@M$00@std@@QBEABU?$equal_to@PAVISteamUser@@@2@XZ ENDP ; std::_Compressed_pair<std::equal_to<ISteamUser *>,float,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??R?$_Bitwise_hash@PAVISteamUser@@@std@@QBEIABQAVISteamUser@@@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
??R?$_Bitwise_hash@PAVISteamUser@@@std@@QBEIABQAVISteamUser@@@Z PROC ; std::_Bitwise_hash<ISteamUser *>::operator(), COMDAT
; _this$ = ecx

; 360  : 		{	// hash _Keyval to size_t value by pseudorandomizing transform

	npad	2
	push	ebp
	mov	ebp, esp

; 346  : 		_Val ^= (size_t)_First[_Next];

	mov	edx, DWORD PTR __Keyval$[ebp]
	movzx	eax, BYTE PTR [edx]
	xor	eax, -2128831035			; 811c9dc5H

; 347  : 		_Val *= _FNV_prime;

	imul	ecx, eax, 16777619
	movzx	eax, BYTE PTR [edx+1]
	xor	ecx, eax
	movzx	eax, BYTE PTR [edx+2]
	imul	ecx, ecx, 16777619
	xor	ecx, eax
	movzx	eax, BYTE PTR [edx+3]
	imul	ecx, ecx, 16777619
	xor	ecx, eax
	imul	eax, ecx, 16777619

; 361  : 		return (_Hash_seq((const unsigned char *)&_Keyval, sizeof (_Kty)));
; 362  : 		}

	pop	ebp
	ret	4
??R?$_Bitwise_hash@PAVISteamUser@@@std@@QBEIABQAVISteamUser@@@Z ENDP ; std::_Bitwise_hash<ISteamUser *>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ??R?$equal_to@PAVISteamUser@@@std@@QBE_NABQAVISteamUser@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$equal_to@PAVISteamUser@@@std@@QBE_NABQAVISteamUser@@0@Z PROC ; std::equal_to<ISteamUser *>::operator(), COMDAT
; _this$ = ecx

; 219  : 		{	// apply operator== to operands

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Right$[ebp]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 220  : 		return (_Left == _Right);
; 221  : 		}

	pop	ebp
	ret	8
??R?$equal_to@PAVISteamUser@@@std@@QBE_NABQAVISteamUser@@0@Z ENDP ; std::equal_to<ISteamUser *>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Get_max_bucket_size@?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@QBEABMXZ
_TEXT	SEGMENT
?_Get_max_bucket_size@?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@QBEABMXZ PROC ; std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >::_Get_max_bucket_size, COMDAT
; _this$ = ecx

; 138  : 		return (_Mypair._Get_second()._Get_second());

	mov	eax, ecx

; 139  : 		}

	ret	0
?_Get_max_bucket_size@?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@QBEABMXZ ENDP ; std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >::_Get_max_bucket_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Get_max_bucket_size@?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@QAEAAMXZ
_TEXT	SEGMENT
?_Get_max_bucket_size@?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@QAEAAMXZ PROC ; std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >::_Get_max_bucket_size, COMDAT
; _this$ = ecx

; 133  : 		return (_Mypair._Get_second()._Get_second());

	mov	eax, ecx

; 134  : 		}

	ret	0
?_Get_max_bucket_size@?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@QAEAAMXZ ENDP ; std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >::_Get_max_bucket_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Getkeyeq@?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@QBEABU?$equal_to@PAVISteamUser@@@2@XZ
_TEXT	SEGMENT
?_Getkeyeq@?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@QBEABU?$equal_to@PAVISteamUser@@@2@XZ PROC ; std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >::_Getkeyeq, COMDAT
; _this$ = ecx

; 128  : 		return (_Mypair._Get_second()._Get_first());

	mov	eax, ecx

; 129  : 		}

	ret	0
?_Getkeyeq@?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@QBEABU?$equal_to@PAVISteamUser@@@2@XZ ENDP ; std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >::_Getkeyeq
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ?_Gethash@?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@QBEABU?$hash@PAVISteamUser@@@2@XZ
_TEXT	SEGMENT
?_Gethash@?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@QBEABU?$hash@PAVISteamUser@@@2@XZ PROC ; std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >::_Gethash, COMDAT
; _this$ = ecx

; 123  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 124  : 		}

	ret	0
?_Gethash@?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@QBEABU?$hash@PAVISteamUser@@@2@XZ ENDP ; std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >::_Gethash
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ??R?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@QBE_NABQAVISteamUser@@0@Z
_TEXT	SEGMENT
__Keyval1$ = 8						; size = 4
__Keyval2$ = 12						; size = 4
??R?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@QBE_NABQAVISteamUser@@0@Z PROC ; std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >::operator(), COMDAT
; _this$ = ecx

; 117  : 		{	// test if _Keyval1 NOT equal to _Keyval2

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Keyval1$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Keyval2$[ebp]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 118  : 		return (!_Getkeyeq()(_Keyval1, _Keyval2));
; 119  : 		}

	pop	ebp
	ret	8
??R?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@QBE_NABQAVISteamUser@@0@Z ENDP ; std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ??R?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@QBEIABQAVISteamUser@@@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
??R?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@QBEIABQAVISteamUser@@@Z PROC ; std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >::operator(), COMDAT
; _this$ = ecx

; 112  : 		{	// hash _Keyval to size_t value

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef

; 346  : 		_Val ^= (size_t)_First[_Next];

	mov	edx, DWORD PTR __Keyval$[ebp]
	movzx	eax, BYTE PTR [edx]
	xor	eax, -2128831035			; 811c9dc5H

; 347  : 		_Val *= _FNV_prime;

	imul	ecx, eax, 16777619
	movzx	eax, BYTE PTR [edx+1]
	xor	ecx, eax
	movzx	eax, BYTE PTR [edx+2]
	imul	ecx, ecx, 16777619
	xor	ecx, eax
	movzx	eax, BYTE PTR [edx+3]
	imul	ecx, ecx, 16777619
	xor	ecx, eax
	imul	eax, ecx, 16777619
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 114  : 		}

	pop	ebp
	ret	4
??R?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@QBEIABQAVISteamUser@@@Z ENDP ; std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash
;	COMDAT ??0?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@QAE@U?$hash@PAVISteamUser@@@1@U?$equal_to@PAVISteamUser@@@1@@Z
_TEXT	SEGMENT
__Hasharg$ = 8						; size = 1
__Keyeqarg$ = 12					; size = 1
??0?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@QAE@U?$hash@PAVISteamUser@@@1@U?$equal_to@PAVISteamUser@@@1@@Z PROC ; std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility

; 311  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xhash

; 109  : 		}

	mov	eax, ecx
	ret	8
??0?$_Uhash_compare@PAVISteamUser@@U?$hash@PAVISteamUser@@@std@@U?$equal_to@PAVISteamUser@@@3@@std@@QAE@U?$hash@PAVISteamUser@@@1@U?$equal_to@PAVISteamUser@@@1@@Z ENDP ; std::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >::_Uhash_compare<ISteamUser *,std::hash<ISteamUser *>,std::equal_to<ISteamUser *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple
;	COMDAT ??0?$tuple@$$V@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$tuple@$$V@std@@QAE@ABV01@@Z PROC			; std::tuple<>::tuple<>, COMDAT
; _this$ = ecx

; 238  : 		{	// copy construct
; 239  : 		}

	mov	eax, ecx
	ret	4
??0?$tuple@$$V@std@@QAE@ABV01@@Z ENDP			; std::tuple<>::tuple<>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\tuple
;	COMDAT ??0?$tuple@$$V@std@@QAE@XZ
_TEXT	SEGMENT
??0?$tuple@$$V@std@@QAE@XZ PROC				; std::tuple<>::tuple<>, COMDAT
; _this$ = ecx

; 229  : 		{	// default construct
; 230  : 		}

	mov	eax, ecx
	ret	0
??0?$tuple@$$V@std@@QAE@XZ ENDP				; std::tuple<>::tuple<>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 96   : 	{	// deallocate storage for _Count elements of size _Sz

	npad	2
	push	ebp
	mov	ebp, esp

; 97   :  #if defined(_M_IX86) || defined(_M_X64)
; 98   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	or	eax, -1
	mov	ecx, DWORD PTR __Count$[ebp]
	xor	edx, edx
	div	DWORD PTR __Sz$[ebp]
	cmp	ecx, eax
	jbe	SHORT $LN2@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN2@Deallocate:

; 99   : 	const size_t _User_size = _Count * _Sz;

	imul	ecx, DWORD PTR __Sz$[ebp]

; 100  : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN9@Deallocate

; 101  : 		{	// deallocate large block
; 102  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 103  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	al, 31					; 0000001fH
	je	SHORT $LN4@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN4@Deallocate:

; 104  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 105  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 106  : 		const uintptr_t _Ptr_container =
; 107  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	ecx, DWORD PTR [eax-4]

; 108  : 
; 109  :  #ifdef _DEBUG
; 110  : 		// If the following asserts, it likely means that we are performing
; 111  : 		// an aligned delete on memory coming from an unaligned allocation.
; 112  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 113  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 114  : 				_BIG_ALLOCATION_SENTINEL);
; 115  :  #endif /* _DEBUG */
; 116  : 
; 117  : 		// Extra paranoia on aligned allocation/deallocation
; 118  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	ecx, eax
	jb	SHORT $LN5@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN5@Deallocate:

; 119  : 
; 120  :  #ifdef _DEBUG
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  : 
; 124  :  #else /* _DEBUG */
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	eax, ecx
	cmp	eax, 4
	jae	SHORT $LN6@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN6@Deallocate:

; 126  : 			<= _Ptr_user - _Ptr_container);
; 127  :  #endif /* _DEBUG */
; 128  : 
; 129  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	eax, 35					; 00000023H
	jbe	SHORT $LN3@Deallocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN9@Deallocate:

; 130  : 			<= _NON_USER_SIZE);
; 131  : 
; 132  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 133  : 		}
; 134  : 
; 135  :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 136  : 	static_cast<void>(_Count);
; 137  : 	static_cast<void>(_Sz);
; 138  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 139  : 
; 140  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 	}

	pop	ebp
	ret	0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 50   : 	{	// allocate storage for _Count elements of size _Sz

	npad	2
	push	ebp
	mov	ebp, esp

; 51   : 	void *_Ptr = 0;
; 52   : 
; 53   : 	if (_Count == 0)

	mov	ecx, DWORD PTR __Count$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@Allocate

; 54   : 		return (_Ptr);

	xor	eax, eax
$LN1@Allocate:

; 89   : 		}
; 90   : 	return (_Ptr);
; 91   : 	}

	pop	ebp
	ret	0
$LN2@Allocate:

; 55   : 
; 56   : 	// check overflow of multiply
; 57   : 	if ((size_t)(-1) / _Sz < _Count)

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Sz$[ebp]
	cmp	eax, ecx
	jae	SHORT $LN3@Allocate

; 58   : 		_Xbad_alloc();	// report no memory

	jmp	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN3@Allocate:

; 59   : 	const size_t _User_size = _Count * _Sz;

	imul	ecx, DWORD PTR __Sz$[ebp]

; 60   : 
; 61   :  #if defined(_M_IX86) || defined(_M_X64)
; 62   : 	if (_Try_aligned_allocation
; 63   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	BYTE PTR __Try_aligned_allocation$[ebp], 0
	je	SHORT $LN4@Allocate
	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN4@Allocate

; 64   : 		{	// allocate large block
; 65   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 66   : 			"Big allocations should at least match vector register size");
; 67   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	eax, DWORD PTR [ecx+35]

; 68   : 		if (_Block_size <= _User_size)

	cmp	eax, ecx
	ja	SHORT $LN6@Allocate

; 69   : 			_Xbad_alloc();	// report no memory

	jmp	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN6@Allocate:

; 70   : 		const uintptr_t _Ptr_container =
; 71   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	eax
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 72   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	jne	SHORT $LN7@Allocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN7@Allocate:

; 73   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 74   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 75   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 89   : 		}
; 90   : 	return (_Ptr);
; 91   : 	}

	pop	ebp
	ret	0
$LN4@Allocate:

; 76   : 
; 77   :  #ifdef _DEBUG
; 78   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 79   :  #endif /* _DEBUG */
; 80   : 		}
; 81   : 	else
; 82   :  #else /* defined(_M_IX86) || defined(_M_X64) */
; 83   : 	static_cast<void>(_Try_aligned_allocation);
; 84   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 85   : 
; 86   : 		{	// allocate normal block
; 87   : 		_Ptr = ::operator new(_User_size);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 88   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN1@Allocate
	jmp	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ
_TEXT	SEGMENT
?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ PROC ; std::_Iterator_base0::_Getcont, COMDAT
; _this$ = ecx

; 79   : 		return (0);

	xor	eax, eax

; 80   : 		}

	ret	0
?_Getcont@_Iterator_base0@std@@QBEPBU_Container_base0@2@XZ ENDP ; std::_Iterator_base0::_Getcont
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 75   : 		}

	ret	4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 64   : 		}

	ret	0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_new.h
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 98   :         return;
; 99   :     }

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 91   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 92   :         (void)_Size;
; 93   :         return _Where;

	mov	eax, DWORD PTR __Where$[ebp]

; 94   :     }

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\xstddef
;	COMDAT ?_Hash_seq@std@@YAIPBEI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
?_Hash_seq@std@@YAIPBEI@Z PROC				; std::_Hash_seq, COMDAT

; 331  : 	{	// FNV-1a hash function for bytes in [_First, _First + _Count)

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 332  :  #if defined(_WIN64)
; 333  : 	static_assert(sizeof(size_t) == 8, "This code is for 64-bit size_t.");
; 334  : 	const size_t _FNV_offset_basis = 14695981039346656037ULL;
; 335  : 	const size_t _FNV_prime = 1099511628211ULL;
; 336  : 
; 337  :  #else /* defined(_WIN64) */
; 338  : 	static_assert(sizeof(size_t) == 4, "This code is for 32-bit size_t.");
; 339  : 	const size_t _FNV_offset_basis = 2166136261U;
; 340  : 	const size_t _FNV_prime = 16777619U;
; 341  :  #endif /* defined(_WIN64) */
; 342  : 
; 343  : 	size_t _Val = _FNV_offset_basis;
; 344  : 	for (size_t _Next = 0; _Next < _Count; ++_Next)

	mov	esi, DWORD PTR __Count$[ebp]
	xor	ecx, ecx
	mov	edx, -2128831035			; 811c9dc5H
	test	esi, esi
	je	SHORT $LN12@Hash_seq
	push	edi
	mov	edi, DWORD PTR __First$[ebp]
$LL8@Hash_seq:

; 345  : 		{	// fold in another byte
; 346  : 		_Val ^= (size_t)_First[_Next];

	movzx	eax, BYTE PTR [ecx+edi]
	inc	ecx
	xor	eax, edx

; 347  : 		_Val *= _FNV_prime;

	imul	edx, eax, 16777619
	cmp	ecx, esi
	jb	SHORT $LL8@Hash_seq
	pop	edi
$LN12@Hash_seq:

; 348  : 		}
; 349  : 	return (_Val);

	mov	eax, edx
	pop	esi

; 350  : 	}

	pop	ebp
	ret	0
?_Hash_seq@std@@YAIPBEI@Z ENDP				; std::_Hash_seq
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0ISteamUser@@QAE@XZ
_TEXT	SEGMENT
??0ISteamUser@@QAE@XZ PROC				; ISteamUser::ISteamUser, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7ISteamUser@@6B@
	mov	eax, ecx
	ret	0
??0ISteamUser@@QAE@XZ ENDP				; ISteamUser::ISteamUser
_TEXT	ENDS
END
