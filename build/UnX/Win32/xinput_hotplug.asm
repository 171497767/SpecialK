; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	C:\Users\andon\Source\Repos\SpecialK\src\input\xinput_hotplug.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?RegisterDeviceNotificationA_Original@@3P6GPAXPAX0K@ZA ; RegisterDeviceNotificationA_Original
PUBLIC	?RegisterDeviceNotificationW_Original@@3P6GPAXPAX0K@ZA ; RegisterDeviceNotificationW_Original
_BSS	SEGMENT
?RegisterDeviceNotificationA_Original@@3P6GPAXPAX0K@ZA DD 01H DUP (?) ; RegisterDeviceNotificationA_Original
?RegisterDeviceNotificationW_Original@@3P6GPAXPAX0K@ZA DD 01H DUP (?) ; RegisterDeviceNotificationW_Original
_BSS	ENDS
CONST	SEGMENT
$SG118788 DB	'RegisterDeviceNotificationW_Detour', 00H
	ORG $+5
$SG118789 DB	'[', 00H, 'X', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H
	DB	't', 00H, '_', 00H, 'H', 00H, 'o', 00H, 't', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'F', 00H, 'i', 00H, 'r', 00H, 's', 00H, 't', 00H, ' ', 00H, 'C'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	'3', 00H, '4', 00H, 'h', 00H, 's', 00H, 00H, 00H
	ORG $+6
$SG118793 DB	'[', 00H, 'X', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H
	DB	't', 00H, '_', 00H, 'H', 00H, 'o', 00H, 't', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, '>', 00H, '>', 00H, ' ', 00H, 'F', 00H, 'i', 00H
	DB	'x', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'Z', 00H, 'e'
	DB	00H, 'r', 00H, 'o', 00H, ' ', 00H, 'G', 00H, 'U', 00H, 'I', 00H
	DB	'D', 00H, ' ', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'd', 00H, ' '
	DB	00H, 'i', 00H, 'n', 00H, ' ', 00H, 'c', 00H, 'a', 00H, 'l', 00H
	DB	'l', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'R', 00H, 'e'
	DB	00H, 'g', 00H, 'i', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 'N'
	DB	00H, 'o', 00H, 't', 00H, 'i', 00H, 'f', 00H, 'i', 00H, 'c', 00H
	DB	'a', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'W', 00H, ' '
	DB	00H, '(', 00H, '.', 00H, '.', 00H, '.', 00H, ')', 00H, 00H, 00H
$SG118806 DB	'RegisterDeviceNotificationA_Detour', 00H
	ORG $+5
$SG118807 DB	'[', 00H, 'X', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H
	DB	't', 00H, '_', 00H, 'H', 00H, 'o', 00H, 't', 00H, ']', 00H, ' '
	DB	00H, '[', 00H, '!', 00H, ']', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'F', 00H, 'i', 00H, 'r', 00H, 's', 00H, 't', 00H, ' ', 00H, 'C'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	'3', 00H, '4', 00H, 'h', 00H, 's', 00H, 00H, 00H
	ORG $+6
$SG118811 DB	'[', 00H, 'X', 00H, 'I', 00H, 'n', 00H, 'p', 00H, 'u', 00H
	DB	't', 00H, '_', 00H, 'H', 00H, 'o', 00H, 't', 00H, ']', 00H, ' '
	DB	00H, ' ', 00H, '>', 00H, '>', 00H, ' ', 00H, 'F', 00H, 'i', 00H
	DB	'x', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'Z', 00H, 'e'
	DB	00H, 'r', 00H, 'o', 00H, ' ', 00H, 'G', 00H, 'U', 00H, 'I', 00H
	DB	'D', 00H, ' ', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'd', 00H, ' '
	DB	00H, 'i', 00H, 'n', 00H, ' ', 00H, 'c', 00H, 'a', 00H, 'l', 00H
	DB	'l', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'R', 00H, 'e'
	DB	00H, 'g', 00H, 'i', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 'N'
	DB	00H, 'o', 00H, 't', 00H, 'i', 00H, 'f', 00H, 'i', 00H, 'c', 00H
	DB	'a', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 'A', 00H, ' '
	DB	00H, '(', 00H, '.', 00H, '.', 00H, '.', 00H, ')', 00H, 00H, 00H
$SG127972 DB	'{', 00H, '0', 00H, '0', 00H, '0', 00H, '0', 00H, '0', 00H
	DB	'0', 00H, '0', 00H, '0', 00H, '-', 00H, '0', 00H, '0', 00H, '0'
	DB	00H, '0', 00H, '-', 00H, '0', 00H, '0', 00H, '0', 00H, '0', 00H
	DB	'-', 00H, '0', 00H, '0', 00H, '0', 00H, '0', 00H, '-', 00H, '0'
	DB	00H, '0', 00H, '0', 00H, '0', 00H, '0', 00H, '0', 00H, '0', 00H
	DB	'0', 00H, '0', 00H, '0', 00H, '0', 00H, '0', 00H, '}', 00H, 00H
	DB	00H
	ORG $+2
$SG127973 DB	'RegisterDeviceNotificationW', 00H
$SG127974 DB	'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, '3', 00H, '2', 00H
	DB	'.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG127975 DB	'RegisterDeviceNotificationA', 00H
$SG127976 DB	'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, '3', 00H, '2', 00H
	DB	'.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	_IsEqualGUID
PUBLIC	??0<unnamed-type-packet_count>@_SK_XInput_PacketJournal@@QAE@XZ ; _SK_XInput_PacketJournal::<unnamed-type-packet_count>::<unnamed-type-packet_count>
PUBLIC	??0<unnamed-type-sequence>@_SK_XInput_PacketJournal@@QAE@XZ ; _SK_XInput_PacketJournal::<unnamed-type-sequence>::<unnamed-type-sequence>
PUBLIC	??0_SK_XInput_PacketJournal@@QAE@XZ		; _SK_XInput_PacketJournal::_SK_XInput_PacketJournal
PUBLIC	?SK_XInput_GetPacketJournal@@YA?AU_SK_XInput_PacketJournal@@K@Z ; SK_XInput_GetPacketJournal
PUBLIC	?SK_XInput_Holding@@YA_NK@Z			; SK_XInput_Holding
PUBLIC	?SK_XInput_PlaceHold@@YAKKKPAU_XINPUT_STATE@@@Z	; SK_XInput_PlaceHold
PUBLIC	?SK_XInput_PlaceHoldEx@@YAKKKPAU_XINPUT_STATE_EX@@@Z ; SK_XInput_PlaceHoldEx
PUBLIC	?SK_XInput_PlaceHoldCaps@@YAKKKKPAU_XINPUT_CAPABILITIES@@@Z ; SK_XInput_PlaceHoldCaps
PUBLIC	?SK_XInput_PlaceHoldBattery@@YAKKKEPAU_XINPUT_BATTERY_INFORMATION@@@Z ; SK_XInput_PlaceHoldBattery
PUBLIC	?SK_XInput_PlaceHoldSet@@YAKKKPAU_XINPUT_VIBRATION@@@Z ; SK_XInput_PlaceHoldSet
PUBLIC	?SK_XInput_PacketJournalize@@YAXKKPAU_XINPUT_STATE@@@Z ; SK_XInput_PacketJournalize
PUBLIC	?SK_XInput_InitHotPlugHooks@@YAXXZ		; SK_XInput_InitHotPlugHooks
PUBLIC	??0<unnamed-type-placeholders>@@QAE@XZ		; <unnamed-type-placeholders>::<unnamed-type-placeholders>
PUBLIC	??$min@K@std@@YAABKABK0@Z			; std::min<unsigned long>
PUBLIC	??$max@K@std@@YAABKABK0@Z			; std::max<unsigned long>
PUBLIC	?RegisterDeviceNotificationW_Detour@@YGPAXPAX0K@Z ; RegisterDeviceNotificationW_Detour
PUBLIC	?RegisterDeviceNotificationA_Detour@@YGPAXPAX0K@Z ; RegisterDeviceNotificationA_Detour
PUBLIC	??$static_cast_p2p@X$$A6GPAXPAX0K@Z@@YAPAPAXPAP6GPAXPAX0K@Z@Z ; static_cast_p2p<void,void * __stdcall(void *,void *,unsigned long)>
EXTRN	__imp__timeGetTime@0:PROC
EXTRN	__imp__CLSIDFromString@8:PROC
EXTRN	?Log@iSK_Logger@@UAAXQB_WZZ:PROC		; iSK_Logger::Log
EXTRN	?SK_CreateDLLHook3@@YG?AW4MH_STATUS@@PB_WPBDPAXPAPAX3@Z:PROC ; SK_CreateDLLHook3
EXTRN	?config@@3Usk_config_t@@A:BYTE			; config
EXTRN	?dll_log@@3UiSK_Logger@@A:BYTE			; dll_log
_BSS	SEGMENT
?placeholders@@3PAU<unnamed-type-placeholders>@@A DQ 05H DUP (?) ; placeholders
?packets@@3PAU_SK_XInput_PacketJournal@@A DB 050H DUP (?) ; packets
?GUID_Zero@@3U_GUID@@A DB 010H DUP (?)			; GUID_Zero
_BSS	ENDS
;	COMDAT ?called@?2??RegisterDeviceNotificationW_Detour@@YGPAXPAX0K@Z@4_NA
_BSS	SEGMENT
?called@?2??RegisterDeviceNotificationW_Detour@@YGPAXPAX0K@Z@4_NA DB 01H DUP (?) ; `RegisterDeviceNotificationW_Detour'::`3'::called
_BSS	ENDS
;	COMDAT ?called@?2??RegisterDeviceNotificationA_Detour@@YGPAXPAX0K@Z@4_NA
_BSS	SEGMENT
?called@?2??RegisterDeviceNotificationA_Detour@@YGPAXPAX0K@Z@4_NA DB 01H DUP (?) ; `RegisterDeviceNotificationA_Detour'::`3'::called
_BSS	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\specialk\utility.h
;	COMDAT ??$static_cast_p2p@X$$A6GPAXPAX0K@Z@@YAPAPAXPAP6GPAXPAX0K@Z@Z
_TEXT	SEGMENT
_p2p$ = 8						; size = 4
??$static_cast_p2p@X$$A6GPAXPAX0K@Z@@YAPAPAXPAP6GPAXPAX0K@Z@Z PROC ; static_cast_p2p<void,void * __stdcall(void *,void *,unsigned long)>, COMDAT

; 53   :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 54   :       return static_cast <T **> (

	mov	eax, DWORD PTR _p2p$[ebp]

; 55   :                static_cast <T*>   ( p2p )
; 56   :                                 );
; 57   :     };

	pop	ebp
	ret	0
??$static_cast_p2p@X$$A6GPAXPAX0K@Z@@YAPAPAXPAP6GPAXPAX0K@Z@Z ENDP ; static_cast_p2p<void,void * __stdcall(void *,void *,unsigned long)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\xinput_hotplug.cpp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File c:\users\andon\source\repos\specialk\src\input\xinput_hotplug.cpp
_TEXT	SEGMENT
_hRecipient$ = 8					; size = 4
_NotificationFilter$ = 12				; size = 4
_Flags$ = 16						; size = 4
?RegisterDeviceNotificationA_Detour@@YGPAXPAX0K@Z PROC	; RegisterDeviceNotificationA_Detour

; 347  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 348  :   SK_LOG_FIRST_CALL

	cmp	BYTE PTR ?called@?2??RegisterDeviceNotificationA_Detour@@YGPAXPAX0K@Z@4_NA, 0
	jne	SHORT $LN12@RegisterDe
	cmp	DWORD PTR ?config@@3Usk_config_t@@A+804, 0
	jl	SHORT $LN3@RegisterDe
	push	OFFSET $SG118806
	push	OFFSET $SG118807
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
$LN3@RegisterDe:
	mov	BYTE PTR ?called@?2??RegisterDeviceNotificationA_Detour@@YGPAXPAX0K@Z@4_NA, 1
$LN12@RegisterDe:
	push	ebx

; 349  : 
; 350  :   auto* pNotifyFilter = 
; 351  :     static_cast <DEV_BROADCAST_DEVICEINTERFACE_A *> (NotificationFilter);
; 352  : 
; 353  :   if (pNotifyFilter->dbcc_devicetype == DBT_DEVTYP_DEVICEINTERFACE && (! (Flags & DEVICE_NOTIFY_SERVICE_HANDLE)))

	mov	ebx, DWORD PTR _Flags$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _NotificationFilter$[ebp]
	cmp	DWORD PTR [edi+4], 5
	jne	SHORT $LN6@RegisterDe
	test	bl, 1
	jne	SHORT $LN6@RegisterDe

; 354  :   {
; 355  : #if 0
; 356  :     OLECHAR wszGUID [128] = { };
; 357  : 
; 358  :     HRESULT hr =
; 359  :       StringFromGUID2 (pNotifyFilter->dbcc_classguid, wszGUID, 127);
; 360  : 
; 361  :     SK_LOG0 ( ( L"@ Game registered device notification for GUID: '%s'", wszGUID ),
; 362  :                 L"Input Mgr." );
; 363  : #endif
; 364  : 
; 365  :     // Fix for Watch_Dogs 2 and possibly other games
; 366  :     if (IsEqualGUID (pNotifyFilter->dbcc_classguid, GUID_Zero))

	lea	ecx, DWORD PTR [edi+12]
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	edx, OFFSET ?GUID_Zero@@3U_GUID@@A
	mov	esi, 12					; 0000000cH
$LL11@RegisterDe:
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN6@RegisterDe
	add	ecx, 4
	add	edx, 4
	sub	esi, 4
	jae	SHORT $LL11@RegisterDe
; File c:\users\andon\source\repos\specialk\src\input\xinput_hotplug.cpp

; 370  :       SK_LOG1 ( (L" >> Fixing Zero GUID used in call to RegisterDeviceNotificationA (...)"),

	or	ebx, 4
	cmp	DWORD PTR ?config@@3Usk_config_t@@A+804, 1
	jl	SHORT $LN6@RegisterDe
	push	OFFSET $SG118811
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8
$LN6@RegisterDe:

; 371  :                  L"XInput_Hot" );
; 372  :     }
; 373  :   }
; 374  : 
; 375  :   return RegisterDeviceNotificationA_Original (hRecipient, NotificationFilter, Flags);

	push	ebx
	push	edi
	push	DWORD PTR _hRecipient$[ebp]
	call	DWORD PTR ?RegisterDeviceNotificationA_Original@@3P6GPAXPAX0K@ZA ; RegisterDeviceNotificationA_Original
	pop	edi
	pop	esi
	pop	ebx

; 376  : }

	pop	ebp
	ret	12					; 0000000cH
?RegisterDeviceNotificationA_Detour@@YGPAXPAX0K@Z ENDP	; RegisterDeviceNotificationA_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\xinput_hotplug.cpp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File c:\users\andon\source\repos\specialk\src\input\xinput_hotplug.cpp
_TEXT	SEGMENT
_hRecipient$ = 8					; size = 4
_NotificationFilter$ = 12				; size = 4
_Flags$ = 16						; size = 4
?RegisterDeviceNotificationW_Detour@@YGPAXPAX0K@Z PROC	; RegisterDeviceNotificationW_Detour

; 308  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 309  :   SK_LOG_FIRST_CALL

	cmp	BYTE PTR ?called@?2??RegisterDeviceNotificationW_Detour@@YGPAXPAX0K@Z@4_NA, 0
	jne	SHORT $LN12@RegisterDe
	cmp	DWORD PTR ?config@@3Usk_config_t@@A+804, 0
	jl	SHORT $LN3@RegisterDe
	push	OFFSET $SG118788
	push	OFFSET $SG118789
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 12					; 0000000cH
$LN3@RegisterDe:
	mov	BYTE PTR ?called@?2??RegisterDeviceNotificationW_Detour@@YGPAXPAX0K@Z@4_NA, 1
$LN12@RegisterDe:
	push	ebx

; 310  : 
; 311  :   auto* pNotifyFilter = 
; 312  :     static_cast <DEV_BROADCAST_DEVICEINTERFACE_W *> (NotificationFilter);
; 313  : 
; 314  :   if (pNotifyFilter->dbcc_devicetype == DBT_DEVTYP_DEVICEINTERFACE && (! (Flags & DEVICE_NOTIFY_SERVICE_HANDLE)))

	mov	ebx, DWORD PTR _Flags$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _NotificationFilter$[ebp]
	cmp	DWORD PTR [edi+4], 5
	jne	SHORT $LN6@RegisterDe
	test	bl, 1
	jne	SHORT $LN6@RegisterDe

; 315  :   {
; 316  : #if 0
; 317  :     OLECHAR wszGUID [128] = { };
; 318  : 
; 319  :     HRESULT hr =
; 320  :       StringFromGUID2 (pNotifyFilter->dbcc_classguid, wszGUID, 127);
; 321  : 
; 322  :     SK_LOG0 ( ( L"@ Game registered device notification for GUID: '%s'", wszGUID ),
; 323  :                 L"Input Mgr." );
; 324  : #endif
; 325  : 
; 326  :     // Fix for Watch_Dogs 2 and possibly other games
; 327  :     if (IsEqualGUID (pNotifyFilter->dbcc_classguid, GUID_Zero))

	lea	ecx, DWORD PTR [edi+12]
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	edx, OFFSET ?GUID_Zero@@3U_GUID@@A
	mov	esi, 12					; 0000000cH
$LL11@RegisterDe:
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN6@RegisterDe
	add	ecx, 4
	add	edx, 4
	sub	esi, 4
	jae	SHORT $LL11@RegisterDe
; File c:\users\andon\source\repos\specialk\src\input\xinput_hotplug.cpp

; 331  :       SK_LOG1 ( (L" >> Fixing Zero GUID used in call to RegisterDeviceNotificationW (...)"),

	or	ebx, 4
	cmp	DWORD PTR ?config@@3Usk_config_t@@A+804, 1
	jl	SHORT $LN6@RegisterDe
	push	OFFSET $SG118793
	push	OFFSET ?dll_log@@3UiSK_Logger@@A	; dll_log
	call	?Log@iSK_Logger@@UAAXQB_WZZ		; iSK_Logger::Log
	add	esp, 8
$LN6@RegisterDe:

; 332  :                  L"XInput_Hot" );
; 333  :     }
; 334  :   }
; 335  : 
; 336  :   return RegisterDeviceNotificationW_Original (hRecipient, NotificationFilter, Flags);

	push	ebx
	push	edi
	push	DWORD PTR _hRecipient$[ebp]
	call	DWORD PTR ?RegisterDeviceNotificationW_Original@@3P6GPAXPAX0K@ZA ; RegisterDeviceNotificationW_Original
	pop	edi
	pop	esi
	pop	ebx

; 337  : }

	pop	ebp
	ret	12					; 0000000cH
?RegisterDeviceNotificationW_Detour@@YGPAXPAX0K@Z ENDP	; RegisterDeviceNotificationW_Detour
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
;	COMDAT ??$max@K@std@@YAABKABK0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@K@std@@YAABKABK0@Z PROC				; std::max<unsigned long>, COMDAT

; 3742 : 	{	// return larger of _Left and _Right

	npad	2
	push	ebp
	mov	ebp, esp

; 3743 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	cmovb	eax, ecx

; 3744 : 	}

	pop	ebp
	ret	0
??$max@K@std@@YAABKABK0@Z ENDP				; std::max<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
;	COMDAT ??$min@K@std@@YAABKABK0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@K@std@@YAABKABK0@Z PROC				; std::min<unsigned long>, COMDAT

; 3778 : 	{	// return smaller of _Left and _Right

	npad	2
	push	ebp
	mov	ebp, esp

; 3779 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	cmovb	eax, edx

; 3780 : 	}

	pop	ebp
	ret	0
??$min@K@std@@YAABKABK0@Z ENDP				; std::min<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0<unnamed-type-placeholders>@@QAE@XZ
_TEXT	SEGMENT
??0<unnamed-type-placeholders>@@QAE@XZ PROC		; <unnamed-type-placeholders>::<unnamed-type-placeholders>, COMDAT
; _this$ = ecx
	mov	BYTE PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0<unnamed-type-placeholders>@@QAE@XZ ENDP		; <unnamed-type-placeholders>::<unnamed-type-placeholders>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\xinput_hotplug.cpp
_TEXT	SEGMENT
?SK_XInput_InitHotPlugHooks@@YAXXZ PROC			; SK_XInput_InitHotPlugHooks

; 384  :   CLSIDFromString (L"{00000000-0000-0000-0000-000000000000}", &GUID_Zero);

	push	OFFSET ?GUID_Zero@@3U_GUID@@A
	push	OFFSET $SG127972
	call	DWORD PTR __imp__CLSIDFromString@8

; 385  : 
; 386  : // According to the DLL Export Table, ...A and ...W are the same freaking function :)
; 387  :   SK_CreateDLLHook3 (       L"user32.dll",

	push	0
	push	OFFSET ?RegisterDeviceNotificationW_Original@@3P6GPAXPAX0K@ZA ; RegisterDeviceNotificationW_Original
	push	OFFSET ?RegisterDeviceNotificationW_Detour@@YGPAXPAX0K@Z ; RegisterDeviceNotificationW_Detour
	push	OFFSET $SG127973
	push	OFFSET $SG127974
	call	?SK_CreateDLLHook3@@YG?AW4MH_STATUS@@PB_WPBDPAXPAPAX3@Z ; SK_CreateDLLHook3

; 388  :                              "RegisterDeviceNotificationW",
; 389  :                               RegisterDeviceNotificationW_Detour,
; 390  :      static_cast_p2p <void> (&RegisterDeviceNotificationW_Original) );
; 391  : 
; 392  :   SK_CreateDLLHook3 (       L"user32.dll",

	push	0
	push	OFFSET ?RegisterDeviceNotificationA_Original@@3P6GPAXPAX0K@ZA ; RegisterDeviceNotificationA_Original
	push	OFFSET ?RegisterDeviceNotificationA_Detour@@YGPAXPAX0K@Z ; RegisterDeviceNotificationA_Detour
	push	OFFSET $SG127975
	push	OFFSET $SG127976
	call	?SK_CreateDLLHook3@@YG?AW4MH_STATUS@@PB_WPBDPAXPAPAX3@Z ; SK_CreateDLLHook3

; 393  :                              "RegisterDeviceNotificationA",
; 394  :                               RegisterDeviceNotificationA_Detour,
; 395  :      static_cast_p2p <void> (&RegisterDeviceNotificationA_Original) );
; 396  : }

	ret	0
?SK_XInput_InitHotPlugHooks@@YAXXZ ENDP			; SK_XInput_InitHotPlugHooks
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\xinput_hotplug.cpp
_TEXT	SEGMENT
_dwRet$ = 8						; size = 4
_dwUserIndex$ = 12					; size = 4
_pState$ = 16						; size = 4
?SK_XInput_PacketJournalize@@YAXKKPAU_XINPUT_STATE@@@Z PROC ; SK_XInput_PacketJournalize

; 262  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 263  :   if (dwUserIndex >= XUSER_MAX_COUNT) return;

	mov	esi, DWORD PTR _dwUserIndex$[ebp]
	cmp	esi, 4
	jae	SHORT $LN5@SK_XInput_

; 264  :   if (pState      == nullptr)         return;

	push	edi
	mov	edi, DWORD PTR _pState$[ebp]
	test	edi, edi
	je	SHORT $LN13@SK_XInput_

; 265  : 
; 266  :   if (dwRet == ERROR_SUCCESS)

	cmp	DWORD PTR _dwRet$[ebp], 0
	jne	SHORT $LN13@SK_XInput_

; 267  :   {
; 268  :     if ( packets [dwUserIndex].sequence.last !=

	mov	eax, DWORD PTR [edi]
	shl	esi, 4
	cmp	DWORD PTR ?packets@@3PAU_SK_XInput_PacketJournal@@A[esi+8], eax
	je	SHORT $LN13@SK_XInput_

; 269  :          pState->dwPacketNumber )
; 270  :     {
; 271  :       packets [dwUserIndex].sequence.last =
; 272  :         pState->dwPacketNumber;
; 273  :       packets [dwUserIndex].packet_count.real++;

	inc	DWORD PTR ?packets@@3PAU_SK_XInput_PacketJournal@@A[esi+4]
	mov	edx, OFFSET ?packets@@3PAU_SK_XInput_PacketJournal@@A+8

; 274  :       packets [dwUserIndex].sequence.current++;

	inc	DWORD PTR ?packets@@3PAU_SK_XInput_PacketJournal@@A[esi+12]
	mov	ecx, DWORD PTR ?packets@@3PAU_SK_XInput_PacketJournal@@A[esi+12]
	mov	DWORD PTR ?packets@@3PAU_SK_XInput_PacketJournal@@A[esi+8], eax
	mov	eax, DWORD PTR ?packets@@3PAU_SK_XInput_PacketJournal@@A[esi+4]
	cmp	eax, DWORD PTR ?packets@@3PAU_SK_XInput_PacketJournal@@A[esi+8]
	mov	eax, OFFSET ?packets@@3PAU_SK_XInput_PacketJournal@@A+12
	push	ebx
	mov	ebx, OFFSET ?packets@@3PAU_SK_XInput_PacketJournal@@A+4
	cmovae	edx, ebx
	pop	ebx
	cmp	ecx, DWORD PTR [edx+esi]
	cmovb	eax, edx

; 275  : 
; 276  :       packets [dwUserIndex].sequence.current =

	mov	eax, DWORD PTR [eax+esi]
	mov	DWORD PTR ?packets@@3PAU_SK_XInput_PacketJournal@@A[esi+12], eax

; 277  :         std::max   ( packets [dwUserIndex].sequence.current,
; 278  :           std::max ( packets [dwUserIndex].packet_count.real,
; 279  :                      packets [dwUserIndex].sequence.last ) );
; 280  : 
; 281  :       pState->dwPacketNumber = packets [dwUserIndex].sequence.current;

	mov	DWORD PTR [edi], eax
$LN13@SK_XInput_:
	pop	edi
$LN5@SK_XInput_:
	pop	esi

; 282  :     }
; 283  :   }
; 284  : 
; 285  :   // Failure will be handled by placeholders if need be.
; 286  : }

	pop	ebp
	ret	0
?SK_XInput_PacketJournalize@@YAXKKPAU_XINPUT_STATE@@@Z ENDP ; SK_XInput_PacketJournalize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\xinput_hotplug.cpp
_TEXT	SEGMENT
_dwRet$ = 8						; size = 4
_dwUserIndex$ = 12					; size = 4
_pVibration$ = 16					; size = 4
?SK_XInput_PlaceHoldSet@@YAKKKPAU_XINPUT_VIBRATION@@@Z PROC ; SK_XInput_PlaceHoldSet

; 224  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 225  :   if (dwUserIndex >= XUSER_MAX_COUNT) return (DWORD)ERROR_DEVICE_NOT_CONNECTED;

	mov	esi, DWORD PTR _dwUserIndex$[ebp]
	cmp	esi, 4
	jb	SHORT $LN2@SK_XInput_
	mov	eax, 1167				; 0000048fH
	pop	esi

; 249  : 
; 250  :     // Leave these whatever the game thinks/wants, it doesn't matter ;)
; 251  :     //pVibration->wLeftMotorSpeed  = 0;
; 252  :     //pVibration->wRightMotorSpeed = 0;
; 253  :   }
; 254  : 
; 255  :   return dwRet;
; 256  : }

	pop	ebp
	ret	0
$LN2@SK_XInput_:

; 226  :   if (pVibration  == nullptr)         return (DWORD)E_POINTER;

	cmp	DWORD PTR _pVibration$[ebp], 0
	jne	SHORT $LN3@SK_XInput_
	mov	eax, -2147467261			; 80004003H
	pop	esi

; 249  : 
; 250  :     // Leave these whatever the game thinks/wants, it doesn't matter ;)
; 251  :     //pVibration->wLeftMotorSpeed  = 0;
; 252  :     //pVibration->wRightMotorSpeed = 0;
; 253  :   }
; 254  : 
; 255  :   return dwRet;
; 256  : }

	pop	ebp
	ret	0
$LN3@SK_XInput_:

; 227  : 
; 228  :   if ( dwRet != ERROR_SUCCESS &&

	mov	eax, DWORD PTR _dwRet$[ebp]
	test	eax, eax
	je	SHORT $LN1@SK_XInput_
	cmp	BYTE PTR ?config@@3Usk_config_t@@A[esi+684], 0
	je	SHORT $LN1@SK_XInput_

; 229  :        config.input.gamepad.xinput.placehold [dwUserIndex] )
; 230  :   {
; 231  :     if (! placeholders [dwUserIndex].holding)

	cmp	BYTE PTR ?placeholders@@3PAU<unnamed-type-placeholders>@@A[esi*8], 0
	jne	SHORT $LN5@SK_XInput_

; 232  :     {
; 233  :       placeholders [dwUserIndex].last_polled = timeGetTime ();

	call	DWORD PTR __imp__timeGetTime@0
	mov	DWORD PTR ?placeholders@@3PAU<unnamed-type-placeholders>@@A[esi*8+4], eax

; 245  :       }
; 246  :     }
; 247  : 
; 248  :     dwRet = ERROR_SUCCESS;

	xor	eax, eax
	mov	BYTE PTR ?placeholders@@3PAU<unnamed-type-placeholders>@@A[esi*8], 1
	pop	esi

; 249  : 
; 250  :     // Leave these whatever the game thinks/wants, it doesn't matter ;)
; 251  :     //pVibration->wLeftMotorSpeed  = 0;
; 252  :     //pVibration->wRightMotorSpeed = 0;
; 253  :   }
; 254  : 
; 255  :   return dwRet;
; 256  : }

	pop	ebp
	ret	0
$LN5@SK_XInput_:

; 234  : 
; 235  :       placeholders [dwUserIndex].holding = true;
; 236  :         //(! SK_XInput_PollController (dwUserIndex));
; 237  :     }
; 238  : 
; 239  :     else
; 240  :     {
; 241  :       if ( placeholders [dwUserIndex].last_polled <

	call	DWORD PTR __imp__timeGetTime@0
	add	eax, -1000				; fffffc18H
	cmp	DWORD PTR ?placeholders@@3PAU<unnamed-type-placeholders>@@A[esi*8+4], eax
	jae	SHORT $LN7@SK_XInput_

; 242  :            timeGetTime () - placeholders [dwUserIndex].RecheckInterval )
; 243  :       {
; 244  :         placeholders [dwUserIndex].holding = false;

	mov	BYTE PTR ?placeholders@@3PAU<unnamed-type-placeholders>@@A[esi*8], 0
$LN7@SK_XInput_:

; 245  :       }
; 246  :     }
; 247  : 
; 248  :     dwRet = ERROR_SUCCESS;

	xor	eax, eax
$LN1@SK_XInput_:
	pop	esi

; 249  : 
; 250  :     // Leave these whatever the game thinks/wants, it doesn't matter ;)
; 251  :     //pVibration->wLeftMotorSpeed  = 0;
; 252  :     //pVibration->wRightMotorSpeed = 0;
; 253  :   }
; 254  : 
; 255  :   return dwRet;
; 256  : }

	pop	ebp
	ret	0
?SK_XInput_PlaceHoldSet@@YAKKKPAU_XINPUT_VIBRATION@@@Z ENDP ; SK_XInput_PlaceHoldSet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\xinput_hotplug.cpp
_TEXT	SEGMENT
_dwRet$ = 8						; size = 4
_dwUserIndex$ = 12					; size = 4
_devType$ = 16						; size = 1
_pBatteryInformation$ = 20				; size = 4
?SK_XInput_PlaceHoldBattery@@YAKKKEPAU_XINPUT_BATTERY_INFORMATION@@@Z PROC ; SK_XInput_PlaceHoldBattery

; 185  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 186  :   UNREFERENCED_PARAMETER (devType);
; 187  : 
; 188  :   if (dwUserIndex         >= XUSER_MAX_COUNT) return (DWORD)ERROR_DEVICE_NOT_CONNECTED;

	mov	esi, DWORD PTR _dwUserIndex$[ebp]
	cmp	esi, 4
	jb	SHORT $LN2@SK_XInput_
	mov	eax, 1167				; 0000048fH
	pop	esi

; 214  :     pBatteryInformation->BatteryLevel = BATTERY_LEVEL_FULL;
; 215  :   }
; 216  : 
; 217  :   return dwRet;
; 218  : }

	pop	ebp
	ret	0
$LN2@SK_XInput_:
	push	edi

; 189  :   if (pBatteryInformation == nullptr)         return (DWORD)E_POINTER;

	mov	edi, DWORD PTR _pBatteryInformation$[ebp]
	test	edi, edi
	jne	SHORT $LN3@SK_XInput_
	pop	edi
	mov	eax, -2147467261			; 80004003H
	pop	esi

; 214  :     pBatteryInformation->BatteryLevel = BATTERY_LEVEL_FULL;
; 215  :   }
; 216  : 
; 217  :   return dwRet;
; 218  : }

	pop	ebp
	ret	0
$LN3@SK_XInput_:

; 190  : 
; 191  :   if ( dwRet != ERROR_SUCCESS &&

	mov	eax, DWORD PTR _dwRet$[ebp]
	test	eax, eax
	je	SHORT $LN9@SK_XInput_
	cmp	BYTE PTR ?config@@3Usk_config_t@@A[esi+684], 0
	je	SHORT $LN9@SK_XInput_

; 192  :        config.input.gamepad.xinput.placehold [dwUserIndex] )
; 193  :   {
; 194  :     if (! placeholders [dwUserIndex].holding) {

	cmp	BYTE PTR ?placeholders@@3PAU<unnamed-type-placeholders>@@A[esi*8], 0
	jne	SHORT $LN5@SK_XInput_

; 195  :       placeholders [dwUserIndex].last_polled = timeGetTime ();

	call	DWORD PTR __imp__timeGetTime@0
	mov	DWORD PTR ?placeholders@@3PAU<unnamed-type-placeholders>@@A[esi*8+4], eax

; 208  :       }
; 209  :     }
; 210  : 
; 211  :     dwRet = ERROR_SUCCESS;

	xor	eax, eax
	mov	BYTE PTR ?placeholders@@3PAU<unnamed-type-placeholders>@@A[esi*8], 1

; 212  : 
; 213  :     pBatteryInformation->BatteryType  = BATTERY_TYPE_WIRED;

	mov	WORD PTR [edi], 769			; 00000301H
	pop	edi
	pop	esi

; 214  :     pBatteryInformation->BatteryLevel = BATTERY_LEVEL_FULL;
; 215  :   }
; 216  : 
; 217  :   return dwRet;
; 218  : }

	pop	ebp
	ret	0
$LN5@SK_XInput_:

; 196  : 
; 197  :       placeholders [dwUserIndex].holding =
; 198  :         true;//(! SK_XInput_PollController (dwUserIndex));
; 199  :     }
; 200  : 
; 201  :     else
; 202  :     {
; 203  :       if ( placeholders [dwUserIndex].last_polled <

	call	DWORD PTR __imp__timeGetTime@0
	add	eax, -1000				; fffffc18H
	cmp	DWORD PTR ?placeholders@@3PAU<unnamed-type-placeholders>@@A[esi*8+4], eax
	jae	SHORT $LN7@SK_XInput_

; 204  :            timeGetTime () - placeholders [dwUserIndex].RecheckInterval )
; 205  :       {
; 206  :         // Re-check the next time this controller is polled
; 207  :         placeholders [dwUserIndex].holding = false;

	mov	BYTE PTR ?placeholders@@3PAU<unnamed-type-placeholders>@@A[esi*8], 0
$LN7@SK_XInput_:

; 208  :       }
; 209  :     }
; 210  : 
; 211  :     dwRet = ERROR_SUCCESS;

	xor	eax, eax

; 212  : 
; 213  :     pBatteryInformation->BatteryType  = BATTERY_TYPE_WIRED;

	mov	WORD PTR [edi], 769			; 00000301H
$LN9@SK_XInput_:
	pop	edi
	pop	esi

; 214  :     pBatteryInformation->BatteryLevel = BATTERY_LEVEL_FULL;
; 215  :   }
; 216  : 
; 217  :   return dwRet;
; 218  : }

	pop	ebp
	ret	0
?SK_XInput_PlaceHoldBattery@@YAKKKEPAU_XINPUT_BATTERY_INFORMATION@@@Z ENDP ; SK_XInput_PlaceHoldBattery
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\xinput_hotplug.cpp
_TEXT	SEGMENT
_dwRet$ = 8						; size = 4
_dwUserIndex$ = 12					; size = 4
_dwFlags$ = 16						; size = 4
_pCapabilities$ = 20					; size = 4
?SK_XInput_PlaceHoldCaps@@YAKKKKPAU_XINPUT_CAPABILITIES@@@Z PROC ; SK_XInput_PlaceHoldCaps

; 141  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 142  :   UNREFERENCED_PARAMETER (dwFlags);
; 143  : 
; 144  :   if (dwUserIndex   >= XUSER_MAX_COUNT) return (DWORD)ERROR_DEVICE_NOT_CONNECTED;

	mov	esi, DWORD PTR _dwUserIndex$[ebp]
	cmp	esi, 4
	jb	SHORT $LN2@SK_XInput_
	mov	eax, 1167				; 0000048fH
	pop	esi

; 173  :     pCapabilities->SubType = XINPUT_DEVSUBTYPE_GAMEPAD;
; 174  :     pCapabilities->Flags   = XINPUT_CAPS_FFB_SUPPORTED;
; 175  :   }
; 176  : 
; 177  :   return dwRet;
; 178  : }

	pop	ebp
	ret	0
$LN2@SK_XInput_:
	push	edi

; 145  :   if (pCapabilities == nullptr)         return (DWORD)E_POINTER;

	mov	edi, DWORD PTR _pCapabilities$[ebp]
	test	edi, edi
	jne	SHORT $LN3@SK_XInput_
	pop	edi
	mov	eax, -2147467261			; 80004003H
	pop	esi

; 173  :     pCapabilities->SubType = XINPUT_DEVSUBTYPE_GAMEPAD;
; 174  :     pCapabilities->Flags   = XINPUT_CAPS_FFB_SUPPORTED;
; 175  :   }
; 176  : 
; 177  :   return dwRet;
; 178  : }

	pop	ebp
	ret	0
$LN3@SK_XInput_:

; 146  : 
; 147  :   if ( dwRet != ERROR_SUCCESS &&

	mov	eax, DWORD PTR _dwRet$[ebp]
	test	eax, eax
	je	SHORT $LN9@SK_XInput_
	cmp	BYTE PTR ?config@@3Usk_config_t@@A[esi+684], 0
	je	SHORT $LN9@SK_XInput_

; 148  :        config.input.gamepad.xinput.placehold [dwUserIndex] )
; 149  :   {
; 150  :     if (! placeholders [dwUserIndex].holding)

	cmp	BYTE PTR ?placeholders@@3PAU<unnamed-type-placeholders>@@A[esi*8], 0
	jne	SHORT $LN5@SK_XInput_

; 151  :     {
; 152  :       placeholders [dwUserIndex].last_polled = timeGetTime ();

	call	DWORD PTR __imp__timeGetTime@0
	mov	DWORD PTR ?placeholders@@3PAU<unnamed-type-placeholders>@@A[esi*8+4], eax

; 153  : 
; 154  :       placeholders [dwUserIndex].holding =

	mov	BYTE PTR ?placeholders@@3PAU<unnamed-type-placeholders>@@A[esi*8], 1

; 155  :         true;//(! SK_XInput_PollController (dwUserIndex));
; 156  :     }
; 157  : 
; 158  :     else

	jmp	SHORT $LN7@SK_XInput_
$LN5@SK_XInput_:

; 159  :     {
; 160  :       if ( placeholders [dwUserIndex].last_polled <

	call	DWORD PTR __imp__timeGetTime@0
	add	eax, -1000				; fffffc18H
	cmp	DWORD PTR ?placeholders@@3PAU<unnamed-type-placeholders>@@A[esi*8+4], eax
	jae	SHORT $LN7@SK_XInput_

; 161  :            timeGetTime () - placeholders [dwUserIndex].RecheckInterval )
; 162  :       {
; 163  :         // Re-check the next time this controller is polled
; 164  :         placeholders [dwUserIndex].holding = false;

	mov	BYTE PTR ?placeholders@@3PAU<unnamed-type-placeholders>@@A[esi*8], 0
$LN7@SK_XInput_:
	xorps	xmm0, xmm0

; 165  :       }
; 166  :     }
; 167  : 
; 168  :     dwRet = ERROR_SUCCESS;

	xor	eax, eax

; 169  : 
; 170  :     ZeroMemory (pCapabilities, sizeof XINPUT_CAPABILITIES);

	movups	XMMWORD PTR [edi], xmm0
	mov	DWORD PTR [edi+16], eax

; 171  : 
; 172  :     pCapabilities->Type    = XINPUT_DEVTYPE_GAMEPAD;

	mov	DWORD PTR [edi], 65793			; 00010101H
$LN9@SK_XInput_:
	pop	edi
	pop	esi

; 173  :     pCapabilities->SubType = XINPUT_DEVSUBTYPE_GAMEPAD;
; 174  :     pCapabilities->Flags   = XINPUT_CAPS_FFB_SUPPORTED;
; 175  :   }
; 176  : 
; 177  :   return dwRet;
; 178  : }

	pop	ebp
	ret	0
?SK_XInput_PlaceHoldCaps@@YAKKKKPAU_XINPUT_CAPABILITIES@@@Z ENDP ; SK_XInput_PlaceHoldCaps
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\xinput_hotplug.cpp
_TEXT	SEGMENT
_dwRet$ = 8						; size = 4
_dwUserIndex$ = 12					; size = 4
_pState$ = 16						; size = 4
?SK_XInput_PlaceHoldEx@@YAKKKPAU_XINPUT_STATE_EX@@@Z PROC ; SK_XInput_PlaceHoldEx

; 132  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 134  : }

	pop	ebp

; 133  :   return SK_XInput_PlaceHold ( dwRet, dwUserIndex, (XINPUT_STATE *)pState );

	jmp	?SK_XInput_PlaceHold@@YAKKKPAU_XINPUT_STATE@@@Z ; SK_XInput_PlaceHold
?SK_XInput_PlaceHoldEx@@YAKKKPAU_XINPUT_STATE_EX@@@Z ENDP ; SK_XInput_PlaceHoldEx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\xinput_hotplug.cpp
_TEXT	SEGMENT
_dwRet$ = 8						; size = 4
_dwUserIndex$ = 12					; size = 4
_was_holding$1$ = 15					; size = 1
_pState$ = 16						; size = 4
?SK_XInput_PlaceHold@@YAKKKPAU_XINPUT_STATE@@@Z PROC	; SK_XInput_PlaceHold

; 76   : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	edi

; 77   :   if (dwUserIndex >= XUSER_MAX_COUNT) return (DWORD)ERROR_DEVICE_NOT_CONNECTED;

	mov	edi, DWORD PTR _dwUserIndex$[ebp]
	cmp	edi, 4
	jb	SHORT $LN2@SK_XInput_
	mov	eax, 1167				; 0000048fH
	pop	edi

; 123  :   }
; 124  : 
; 125  :   return dwRet;
; 126  : }

	pop	ebp
	ret	0
$LN2@SK_XInput_:
	push	ebx

; 78   :   if (pState      == nullptr)         return (DWORD)E_POINTER;

	mov	ebx, DWORD PTR _pState$[ebp]
	test	ebx, ebx
	jne	SHORT $LN3@SK_XInput_
	pop	ebx
	mov	eax, -2147467261			; 80004003H
	pop	edi

; 123  :   }
; 124  : 
; 125  :   return dwRet;
; 126  : }

	pop	ebp
	ret	0
$LN3@SK_XInput_:

; 79   : 
; 80   :   bool was_holding = placeholders [dwUserIndex].holding;

	mov	cl, BYTE PTR ?placeholders@@3PAU<unnamed-type-placeholders>@@A[edi*8]

; 81   : 
; 82   :   if ( dwRet != ERROR_SUCCESS &&

	mov	eax, DWORD PTR _dwRet$[ebp]
	mov	BYTE PTR _was_holding$1$[ebp], cl
	test	eax, eax
	je	$LN17@SK_XInput_
	cmp	BYTE PTR ?config@@3Usk_config_t@@A[edi+684], 0
	je	$LN17@SK_XInput_

; 83   :        config.input.gamepad.xinput.placehold [dwUserIndex] )
; 84   :   {
; 85   :     if (! placeholders [dwUserIndex].holding)

	test	cl, cl
	jne	SHORT $LN5@SK_XInput_

; 86   :     {
; 87   :       placeholders [dwUserIndex].last_polled = timeGetTime ();

	call	DWORD PTR __imp__timeGetTime@0
	mov	DWORD PTR ?placeholders@@3PAU<unnamed-type-placeholders>@@A[edi*8+4], eax

; 88   : 
; 89   :       placeholders [dwUserIndex].holding =

	mov	BYTE PTR ?placeholders@@3PAU<unnamed-type-placeholders>@@A[edi*8], 1

; 90   :         true;//(! SK_XInput_PollController (dwUserIndex, pState));
; 91   :     }
; 92   : 
; 93   :     else

	jmp	SHORT $LN7@SK_XInput_
$LN5@SK_XInput_:

; 94   :     {
; 95   :       if ( placeholders [dwUserIndex].last_polled <

	call	DWORD PTR __imp__timeGetTime@0
	add	eax, -1000				; fffffc18H
	cmp	DWORD PTR ?placeholders@@3PAU<unnamed-type-placeholders>@@A[edi*8+4], eax
	jae	SHORT $LN7@SK_XInput_

; 96   :            timeGetTime () - placeholders [dwUserIndex].RecheckInterval )
; 97   :       {
; 98   :         // Re-check the next time this controller is polled
; 99   :         placeholders [dwUserIndex].holding = false;

	mov	BYTE PTR ?placeholders@@3PAU<unnamed-type-placeholders>@@A[edi*8], 0
$LN7@SK_XInput_:

; 100  :       }
; 101  :     }
; 102  : 
; 103  :     dwRet = ERROR_SUCCESS;
; 104  : 
; 105  :     if (! was_holding)

	mov	cl, BYTE PTR _was_holding$1$[ebp]
	mov	DWORD PTR _dwRet$[ebp], 0
	test	cl, cl
	jne	SHORT $LN8@SK_XInput_

; 106  :     {
; 107  :       packets [dwUserIndex].packet_count.virt++;

	mov	eax, edi
	shl	eax, 4
	inc	DWORD PTR ?packets@@3PAU_SK_XInput_PacketJournal@@A[eax]

; 108  :       packets [dwUserIndex].sequence.current++;

	inc	DWORD PTR ?packets@@3PAU_SK_XInput_PacketJournal@@A[eax+12]
$LN8@SK_XInput_:

; 109  :     }
; 110  : 
; 111  :     ZeroMemory (&pState->Gamepad, sizeof XINPUT_GAMEPAD);

	xorps	xmm0, xmm0
	movq	QWORD PTR [ebx+4], xmm0
	mov	DWORD PTR [ebx+12], 0

; 112  : 
; 113  :     if (! was_holding)

	test	cl, cl
	jne	SHORT $LN9@SK_XInput_

; 114  :     {
; 115  :       packets [dwUserIndex].sequence.current =

	push	esi
	mov	esi, edi
	mov	ecx, OFFSET ?packets@@3PAU_SK_XInput_PacketJournal@@A+4
	shl	esi, 4
	mov	edx, OFFSET ?packets@@3PAU_SK_XInput_PacketJournal@@A+8
	mov	eax, DWORD PTR ?packets@@3PAU_SK_XInput_PacketJournal@@A[esi+4]
	cmp	eax, DWORD PTR ?packets@@3PAU_SK_XInput_PacketJournal@@A[esi+8]
	mov	eax, DWORD PTR ?packets@@3PAU_SK_XInput_PacketJournal@@A[esi+12]
	cmovae	edx, ecx
	mov	ecx, OFFSET ?packets@@3PAU_SK_XInput_PacketJournal@@A+12
	cmp	eax, DWORD PTR [edx+esi]
	cmovb	ecx, edx
	mov	eax, DWORD PTR [ecx+esi]
	mov	DWORD PTR ?packets@@3PAU_SK_XInput_PacketJournal@@A[esi+12], eax
	pop	esi
$LN9@SK_XInput_:

; 116  :         std::max   ( packets [dwUserIndex].sequence.current,
; 117  :           std::max ( packets [dwUserIndex].packet_count.real,
; 118  :                      packets [dwUserIndex].sequence.last ) );
; 119  :     }
; 120  : 
; 121  :     pState->dwPacketNumber = packets [dwUserIndex].sequence.current;

	mov	eax, DWORD PTR _dwRet$[ebp]
	shl	edi, 4
	mov	ecx, DWORD PTR ?packets@@3PAU_SK_XInput_PacketJournal@@A[edi+12]
	mov	DWORD PTR [ebx], ecx

; 122  :                              packets [dwUserIndex].sequence.last = 0;

	mov	DWORD PTR ?packets@@3PAU_SK_XInput_PacketJournal@@A[edi+8], 0
$LN17@SK_XInput_:
	pop	ebx
	pop	edi

; 123  :   }
; 124  : 
; 125  :   return dwRet;
; 126  : }

	pop	ebp
	ret	0
?SK_XInput_PlaceHold@@YAKKKPAU_XINPUT_STATE@@@Z ENDP	; SK_XInput_PlaceHold
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\xinput_hotplug.cpp
_TEXT	SEGMENT
_dwUserIndex$ = 8					; size = 4
?SK_XInput_Holding@@YA_NK@Z PROC			; SK_XInput_Holding

; 62   : {

	npad	2
	push	ebp
	mov	ebp, esp

; 63   :   if (dwUserIndex >= XUSER_MAX_COUNT)

	mov	eax, DWORD PTR _dwUserIndex$[ebp]
	cmp	eax, 4
	jb	SHORT $LN2@SK_XInput_

; 64   :     return false;

	xor	al, al

; 67   : }

	pop	ebp
	ret	0
$LN2@SK_XInput_:

; 65   : 
; 66   :   return placeholders [dwUserIndex].holding;

	mov	al, BYTE PTR ?placeholders@@3PAU<unnamed-type-placeholders>@@A[eax*8]

; 67   : }

	pop	ebp
	ret	0
?SK_XInput_Holding@@YA_NK@Z ENDP			; SK_XInput_Holding
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\input\xinput_hotplug.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm
; File c:\users\andon\source\repos\specialk\src\input\xinput_hotplug.cpp
_TEXT	SEGMENT
$T1 = 8							; size = 4
_dwUserIndex$ = 12					; size = 4
?SK_XInput_GetPacketJournal@@YA?AU_SK_XInput_PacketJournal@@K@Z PROC ; SK_XInput_GetPacketJournal

; 49   : {

	npad	2
	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\include\algorithm

; 3779 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR _dwUserIndex$[ebp]
	mov	ecx, 3
	cmp	eax, ecx
	cmova	eax, ecx
; File c:\users\andon\source\repos\specialk\src\input\xinput_hotplug.cpp

; 50   :   dwUserIndex =

	mov	eax, DWORD PTR ?config@@3Usk_config_t@@A[eax*4+688]

; 51   :     config.input.gamepad.xinput.assignment [std::min (dwUserIndex, 3UL)];
; 52   : 
; 53   :   if (dwUserIndex >= XUSER_MAX_COUNT)

	cmp	eax, 4
	jb	SHORT $LN2@SK_XInput_

; 54   :     return packets [XUSER_MAX_COUNT];
; 55   : 
; 56   :   return packets [dwUserIndex];

	mov	eax, DWORD PTR $T1[ebp]
	movups	xmm0, XMMWORD PTR ?packets@@3PAU_SK_XInput_PacketJournal@@A+64
	movups	XMMWORD PTR [eax], xmm0

; 57   : }

	pop	ebp
	ret	0
$LN2@SK_XInput_:

; 54   :     return packets [XUSER_MAX_COUNT];
; 55   : 
; 56   :   return packets [dwUserIndex];

	shl	eax, 4
	add	eax, OFFSET ?packets@@3PAU_SK_XInput_PacketJournal@@A
	movups	xmm0, XMMWORD PTR [eax]
	mov	eax, DWORD PTR $T1[ebp]
	movups	XMMWORD PTR [eax], xmm0

; 57   : }

	pop	ebp
	ret	0
?SK_XInput_GetPacketJournal@@YA?AU_SK_XInput_PacketJournal@@K@Z ENDP ; SK_XInput_GetPacketJournal
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0_SK_XInput_PacketJournal@@QAE@XZ
_TEXT	SEGMENT
??0_SK_XInput_PacketJournal@@QAE@XZ PROC		; _SK_XInput_PacketJournal::_SK_XInput_PacketJournal, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	ret	0
??0_SK_XInput_PacketJournal@@QAE@XZ ENDP		; _SK_XInput_PacketJournal::_SK_XInput_PacketJournal
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0<unnamed-type-sequence>@_SK_XInput_PacketJournal@@QAE@XZ
_TEXT	SEGMENT
??0<unnamed-type-sequence>@_SK_XInput_PacketJournal@@QAE@XZ PROC ; _SK_XInput_PacketJournal::<unnamed-type-sequence>::<unnamed-type-sequence>, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0<unnamed-type-sequence>@_SK_XInput_PacketJournal@@QAE@XZ ENDP ; _SK_XInput_PacketJournal::<unnamed-type-sequence>::<unnamed-type-sequence>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0<unnamed-type-packet_count>@_SK_XInput_PacketJournal@@QAE@XZ
_TEXT	SEGMENT
??0<unnamed-type-packet_count>@_SK_XInput_PacketJournal@@QAE@XZ PROC ; _SK_XInput_PacketJournal::<unnamed-type-packet_count>::<unnamed-type-packet_count>, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0<unnamed-type-packet_count>@_SK_XInput_PacketJournal@@QAE@XZ ENDP ; _SK_XInput_PacketJournal::<unnamed-type-packet_count>::<unnamed-type-packet_count>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT
_rguid1$ = 8						; size = 4
_rguid2$ = 12						; size = 4
_IsEqualGUID PROC					; COMDAT

; 160  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	edx, DWORD PTR _rguid1$[ebp]
	mov	eax, DWORD PTR _rguid2$[ebp]
	push	esi
	mov	esi, 12					; 0000000cH
$LL5@IsEqualGUI:
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN4@IsEqualGUI
	add	edx, 4
	add	eax, 4
	sub	esi, 4
	jae	SHORT $LL5@IsEqualGUI
	mov	eax, 1
	pop	esi

; 162  : }

	pop	ebp
	ret	0
$LN4@IsEqualGUI:

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	xor	eax, eax
	pop	esi

; 162  : }

	pop	ebp
	ret	0
_IsEqualGUID ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___n$[ebp]
	test	esi, esi
	je	SHORT $LN6@vector
	push	ebx
	mov	ebx, DWORD PTR ___f$[ebp]
	push	edi
	mov	edi, DWORD PTR ___t$[ebp]
$LL2@vector:
	mov	ecx, edi
	call	ebx
	add	edi, DWORD PTR ___s$[ebp]
	sub	esi, 1
	jne	SHORT $LL2@vector
	pop	edi
	pop	ebx
$LN6@vector:
	pop	esi
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
