; Listing generated by Microsoft (R) Optimizing Compiler Version 19.10.25019.0 

	TITLE	C:\Users\andon\Source\Repos\SpecialK\src\imgui\backends\imgui_d3d9.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_IID_IAxWinAmbientDispatch
PUBLIC	?_pAtlModule@ATL@@3PAVCAtlModule@1@A		; ATL::_pAtlModule
PUBLIC	_LIBID_ATLLib
PUBLIC	?g_pd3dDevice@@3PAUIDirect3DDevice9@@A		; g_pd3dDevice
PUBLIC	_IID_IAxWinAmbientDispatchEx
PUBLIC	_IID_IInternalConnection
PUBLIC	___pobjMapEntryFirst
PUBLIC	___pobjMapEntryLast
PUBLIC	?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA	; ATL::_pPerfRegFunc
PUBLIC	?_pPerfUnRegFunc@ATL@@3P6AJXZA			; ATL::_pPerfUnRegFunc
PUBLIC	?_AtlRegisterPerUser@ATL@@3_NA			; ATL::_AtlRegisterPerUser
PUBLIC	?_pModule@ATL@@3PAVCComModule@1@A		; ATL::_pModule
PUBLIC	_CLSID_Registrar
PUBLIC	_IID_IRegistrar
PUBLIC	?chDirSep@ATL@@3_WB				; ATL::chDirSep
PUBLIC	?chRightBracket@ATL@@3_WB			; ATL::chRightBracket
PUBLIC	?chLeftBracket@ATL@@3_WB			; ATL::chLeftBracket
PUBLIC	?chQuote@ATL@@3_WB				; ATL::chQuote
PUBLIC	?chEquals@ATL@@3_WB				; ATL::chEquals
PUBLIC	?szStringVal@ATL@@3QB_WB			; ATL::szStringVal
PUBLIC	?multiszStringVal@ATL@@3QB_WB			; ATL::multiszStringVal
PUBLIC	?szDwordVal@ATL@@3QB_WB				; ATL::szDwordVal
PUBLIC	?szBinaryVal@ATL@@3QB_WB			; ATL::szBinaryVal
PUBLIC	?szValToken@ATL@@3QB_WB				; ATL::szValToken
PUBLIC	?szForceRemove@ATL@@3QB_WB			; ATL::szForceRemove
PUBLIC	?szNoRemove@ATL@@3QB_WB				; ATL::szNoRemove
PUBLIC	?szDelete@ATL@@3QB_WB				; ATL::szDelete
PUBLIC	_IID_IDocHostUIHandlerDispatch
PUBLIC	?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A ; ATL::_pAtlAutoThreadModule
PUBLIC	_IID_IAxWinHostWindow
PUBLIC	_IID_IAxWinHostWindowLic
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_BSS	SEGMENT
?_pAtlModule@ATL@@3PAVCAtlModule@1@A DD 01H DUP (?)	; ATL::_pAtlModule
_BSS	ENDS
_BSS	SEGMENT
?g_hWnd@@3PAUHWND__@@A DD 01H DUP (?)			; g_hWnd
	ALIGN	8

?g_Time@@3_JA DQ 01H DUP (?)				; g_Time
?g_TicksPerSecond@@3_JA DQ 01H DUP (?)			; g_TicksPerSecond
?g_pd3dDevice@@3PAUIDirect3DDevice9@@A DD 01H DUP (?)	; g_pd3dDevice
?g_pVB@@3PAUIDirect3DVertexBuffer9@@A DD 01H DUP (?)	; g_pVB
?g_pIB@@3PAUIDirect3DIndexBuffer9@@A DD 01H DUP (?)	; g_pIB
?g_FontTexture@@3PAUIDirect3DTexture9@@A DD 01H DUP (?)	; g_FontTexture
_BSS	ENDS
;	COMDAT ?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA
_BSS	SEGMENT
?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA DD 01H DUP (?) ; ATL::_pPerfRegFunc
_BSS	ENDS
;	COMDAT ?_pPerfUnRegFunc@ATL@@3P6AJXZA
_BSS	SEGMENT
?_pPerfUnRegFunc@ATL@@3P6AJXZA DD 01H DUP (?)		; ATL::_pPerfUnRegFunc
_BSS	ENDS
;	COMDAT ?_AtlRegisterPerUser@ATL@@3_NA
_BSS	SEGMENT
?_AtlRegisterPerUser@ATL@@3_NA DB 01H DUP (?)		; ATL::_AtlRegisterPerUser
_BSS	ENDS
;	COMDAT ?_pModule@ATL@@3PAVCComModule@1@A
_BSS	SEGMENT
?_pModule@ATL@@3PAVCComModule@1@A DD 01H DUP (?)	; ATL::_pModule
_BSS	ENDS
;	COMDAT ?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A
_BSS	SEGMENT
?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A DD 01H DUP (?) ; ATL::_pAtlAutoThreadModule
_BSS	ENDS
;	COMDAT _IID_IAxWinHostWindowLic
CONST	SEGMENT
_IID_IAxWinHostWindowLic DD 03935bda8H
	DW	04ed9H
	DW	0495cH
	DB	086H
	DB	050H
	DB	0e0H
	DB	01fH
	DB	0c1H
	DB	0e3H
	DB	08aH
	DB	04bH
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindow
CONST	SEGMENT
_IID_IAxWinHostWindow DD 0b6ea2050H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT _IID_IDocHostUIHandlerDispatch
CONST	SEGMENT
_IID_IDocHostUIHandlerDispatch DD 0425b5af0H
	DW	065f1H
	DW	011d1H
	DB	096H
	DB	011H
	DB	00H
	DB	00H
	DB	0f8H
	DB	01eH
	DB	0dH
	DB	0dH
CONST	ENDS
;	COMDAT ?szDelete@ATL@@3QB_WB
CONST	SEGMENT
?szDelete@ATL@@3QB_WB DD FLAT:$SG167574			; ATL::szDelete
CONST	ENDS
;	COMDAT ?szNoRemove@ATL@@3QB_WB
CONST	SEGMENT
?szNoRemove@ATL@@3QB_WB DD FLAT:$SG167572		; ATL::szNoRemove
CONST	ENDS
;	COMDAT ?szForceRemove@ATL@@3QB_WB
CONST	SEGMENT
?szForceRemove@ATL@@3QB_WB DD FLAT:$SG167570		; ATL::szForceRemove
CONST	ENDS
;	COMDAT ?szValToken@ATL@@3QB_WB
CONST	SEGMENT
?szValToken@ATL@@3QB_WB DD FLAT:$SG167568		; ATL::szValToken
CONST	ENDS
;	COMDAT ?szBinaryVal@ATL@@3QB_WB
CONST	SEGMENT
?szBinaryVal@ATL@@3QB_WB DD FLAT:$SG167566		; ATL::szBinaryVal
CONST	ENDS
;	COMDAT ?szDwordVal@ATL@@3QB_WB
CONST	SEGMENT
?szDwordVal@ATL@@3QB_WB DD FLAT:$SG167564		; ATL::szDwordVal
CONST	ENDS
;	COMDAT ?multiszStringVal@ATL@@3QB_WB
CONST	SEGMENT
?multiszStringVal@ATL@@3QB_WB DD FLAT:$SG167562		; ATL::multiszStringVal
CONST	ENDS
;	COMDAT ?szStringVal@ATL@@3QB_WB
CONST	SEGMENT
?szStringVal@ATL@@3QB_WB DD FLAT:$SG167560		; ATL::szStringVal
CONST	ENDS
;	COMDAT ?chEquals@ATL@@3_WB
CONST	SEGMENT
?chEquals@ATL@@3_WB DW 03dH				; ATL::chEquals
CONST	ENDS
;	COMDAT ?chQuote@ATL@@3_WB
CONST	SEGMENT
?chQuote@ATL@@3_WB DW 027H				; ATL::chQuote
CONST	ENDS
;	COMDAT ?chLeftBracket@ATL@@3_WB
CONST	SEGMENT
?chLeftBracket@ATL@@3_WB DW 07bH			; ATL::chLeftBracket
CONST	ENDS
;	COMDAT ?chRightBracket@ATL@@3_WB
CONST	SEGMENT
?chRightBracket@ATL@@3_WB DW 07dH			; ATL::chRightBracket
CONST	ENDS
;	COMDAT ?chDirSep@ATL@@3_WB
CONST	SEGMENT
?chDirSep@ATL@@3_WB DW 05cH				; ATL::chDirSep
CONST	ENDS
;	COMDAT _IID_IRegistrar
CONST	SEGMENT
_IID_IRegistrar DD 044ec053bH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT _CLSID_Registrar
CONST	SEGMENT
_CLSID_Registrar DD 044ec053aH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT ___pobjMapEntryLast
ATL$__z	SEGMENT
___pobjMapEntryLast DD 00H
ATL$__z	ENDS
;	COMDAT ___pobjMapEntryFirst
ATL$__a	SEGMENT
___pobjMapEntryFirst DD 00H
ATL$__a	ENDS
;	COMDAT _IID_IInternalConnection
CONST	SEGMENT
_IID_IInternalConnection DD 072ad0770H
	DW	06a9fH
	DW	011d1H
	DB	0bcH
	DB	0ecH
	DB	00H
	DB	060H
	DB	08H
	DB	08fH
	DB	044H
	DB	04eH
CONST	ENDS
;	COMDAT _IID_IAxWinAmbientDispatchEx
CONST	SEGMENT
_IID_IAxWinAmbientDispatchEx DD 0b2d0778bH
	DW	0ac99H
	DW	04c58H
	DB	0a5H
	DB	0c8H
	DB	0e7H
	DB	072H
	DB	04eH
	DB	053H
	DB	016H
	DB	0b5H
CONST	ENDS
_DATA	SEGMENT
?g_VertexBufferSize@@3HA DD 01388H			; g_VertexBufferSize
?g_IndexBufferSize@@3HA DD 02710H			; g_IndexBufferSize
_DATA	ENDS
;	COMDAT _LIBID_ATLLib
CONST	SEGMENT
_LIBID_ATLLib DD 044ec0535H
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT _IID_IAxWinAmbientDispatch
CONST	SEGMENT
_IID_IAxWinAmbientDispatch DD 0b6ea2051H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
CONST	SEGMENT
$SG154627 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'S', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H
	ORG $+2
$SG154674 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'M', 00H, 'a', 00H, 'p', 00H, 00H, 00H
$SG154679 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'U', 00H, 't', 00H, 'i', 00H, 'l', 00H, 00H
	DB	00H
	ORG $+2
$SG154726 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'S', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 'r'
	DB	00H, 'i', 00H, 't', 00H, 'y', 00H, 00H, 00H
	ORG $+2
$SG154773 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'S', 00H, 'y', 00H, 'n', 00H, 'c', 00H, 00H
	DB	00H
	ORG $+2
$SG154820 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'I', 00H, 'S', 00H, 'A', 00H, 'P', 00H, 'I'
	DB	00H, 00H, 00H
$SG153804 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r'
	DB	00H, 'a', 00H, 'l', 00H, 00H, 00H
$SG153875 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'C', 00H, 'O', 00H, 'M', 00H, 00H, 00H
$SG168250 DB	'A', 00H, 'p', 00H, 'p', 00H, 'I', 00H, 'D', 00H, 00H, 00H
$SG168251 DB	'C', 00H, 'L', 00H, 'S', 00H, 'I', 00H, 'D', 00H, 00H, 00H
$SG168252 DB	'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'o', 00H, 'n', 00H
	DB	'e', 00H, 'n', 00H, 't', 00H, ' ', 00H, 'C', 00H, 'a', 00H, 't'
	DB	00H, 'e', 00H, 'g', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'e', 00H
	DB	's', 00H, 00H, 00H
	ORG $+2
$SG168253 DB	'F', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'T', 00H, 'y', 00H
	DB	'p', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG168254 DB	'I', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'f', 00H
	DB	'a', 00H, 'c', 00H, 'e', 00H, 00H, 00H
$SG168255 DB	'H', 00H, 'a', 00H, 'r', 00H, 'd', 00H, 'w', 00H, 'a', 00H
	DB	'r', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG168256 DB	'M', 00H, 'i', 00H, 'm', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG168257 DB	'S', 00H, 'A', 00H, 'M', 00H, 00H, 00H
$SG168258 DB	'S', 00H, 'E', 00H, 'C', 00H, 'U', 00H, 'R', 00H, 'I', 00H
	DB	'T', 00H, 'Y', 00H, 00H, 00H
	ORG $+2
$SG153922 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'Q', 00H, 'I', 00H, 00H, 00H
	ORG $+2
$SG168259 DB	'S', 00H, 'Y', 00H, 'S', 00H, 'T', 00H, 'E', 00H, 'M', 00H
	DB	00H, 00H
	ORG $+2
$SG168260 DB	'S', 00H, 'o', 00H, 'f', 00H, 't', 00H, 'w', 00H, 'a', 00H
	DB	'r', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG168261 DB	'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H, 'L', 00H, 'i', 00H
	DB	'b', 00H, 00H, 00H
$SG153969 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'R', 00H, 'e', 00H, 'g', 00H, 'i', 00H, 's'
	DB	00H, 't', 00H, 'r', 00H, 'a', 00H, 'r', 00H, 00H, 00H
$SG154016 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'R', 00H, 'e', 00H, 'f', 00H, 'c', 00H, 'o'
	DB	00H, 'u', 00H, 'n', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG154063 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o'
	DB	00H, 'w', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H
$SG154110 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'r'
	DB	00H, 'o', 00H, 'l', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG154157 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'H', 00H, 'o', 00H, 's', 00H, 't', 00H, 'i'
	DB	00H, 'n', 00H, 'g', 00H, 00H, 00H
$SG154204 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'D', 00H, 'B', 00H, 'C', 00H, 'l', 00H, 'i'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, 00H, 00H
	ORG $+2
$SG167560 DB	'S', 00H, 00H, 00H
$SG167562 DB	'M', 00H, 00H, 00H
$SG154251 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'D', 00H, 'B', 00H, 'P', 00H, 'r', 00H, 'o'
	DB	00H, 'v', 00H, 'i', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 00H, 00H
	ORG $+2
$SG167564 DB	'D', 00H, 00H, 00H
$SG167566 DB	'B', 00H, 00H, 00H
$SG167568 DB	'V', 00H, 'a', 00H, 'l', 00H, 00H, 00H
$SG167570 DB	'F', 00H, 'o', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'R', 00H
	DB	'e', 00H, 'm', 00H, 'o', 00H, 'v', 00H, 'e', 00H, 00H, 00H
$SG167572 DB	'N', 00H, 'o', 00H, 'R', 00H, 'e', 00H, 'm', 00H, 'o', 00H
	DB	'v', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG167574 DB	'D', 00H, 'e', 00H, 'l', 00H, 'e', 00H, 't', 00H, 'e', 00H
	DB	00H, 00H
	ORG $+2
$SG154298 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'S', 00H, 'n', 00H, 'a', 00H, 'p', 00H, 'i'
	DB	00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG174822 DB	't', 00H, 'b', 00H, 'f', 00H, 'i', 00H, 'x', 00H, '.', 00H
	DB	'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
$SG154345 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'N', 00H, 'o', 00H, 't', 00H, 'I', 00H, 'm'
	DB	00H, 'p', 00H, 'l', 00H, 00H, 00H
$SG154392 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c'
	DB	00H, 'a', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H
	ORG $+2
$SG154439 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'E', 00H, 'x', 00H, 'c', 00H, 'e', 00H, 'p'
	DB	00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H
$SG154486 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'T', 00H, 'i', 00H, 'm', 00H, 'e', 00H, 00H
	DB	00H
	ORG $+2
$SG154533 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'C', 00H, 'a', 00H, 'c', 00H, 'h', 00H, 'e'
	DB	00H, 00H, 00H
$SG154580 DB	'a', 00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'S', 00H, 't', 00H, 'e', 00H, 'n', 00H, 'c'
	DB	00H, 'i', 00H, 'l', 00H, 00H, 00H
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0ImVec2@@QAE@MM@Z				; ImVec2::ImVec2
PUBLIC	??A?$ImVector@UImDrawCmd@@@@QBEABUImDrawCmd@@H@Z ; ImVector<ImDrawCmd>::operator[]
PUBLIC	_HRESULT_FROM_WIN32
PUBLIC	?ImGui_ImplDX9_Init@@YA_NPAXPAUIDirect3DDevice9@@PAU_D3DPRESENT_PARAMETERS_@@@Z ; ImGui_ImplDX9_Init
PUBLIC	?ImGui_ImplDX9_Shutdown@@YAXXZ			; ImGui_ImplDX9_Shutdown
PUBLIC	?ImGui_ImplDX9_NewFrame@@YAXXZ			; ImGui_ImplDX9_NewFrame
PUBLIC	?ImGui_ImplDX9_InvalidateDeviceObjects@@YAXPAU_D3DPRESENT_PARAMETERS_@@@Z ; ImGui_ImplDX9_InvalidateDeviceObjects
PUBLIC	?ImGui_ImplDX9_CreateDeviceObjects@@YA_NXZ	; ImGui_ImplDX9_CreateDeviceObjects
PUBLIC	??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>
PUBLIC	??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>
PUBLIC	??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>
PUBLIC	??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>
PUBLIC	??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>
PUBLIC	??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>
PUBLIC	??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>
PUBLIC	??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>
PUBLIC	??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>
PUBLIC	??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>
PUBLIC	??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>
PUBLIC	??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>
PUBLIC	??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>
PUBLIC	??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>
PUBLIC	?_AtlRaiseException@ATL@@YAXKK@Z		; ATL::_AtlRaiseException
PUBLIC	?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ; ATL::_AtlInitializeCriticalSectionEx
PUBLIC	??0CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::CComCriticalSection
PUBLIC	??1CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::~CComCriticalSection
PUBLIC	?Init@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Init
PUBLIC	?Term@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Term
PUBLIC	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
PUBLIC	??0_ATL_COM_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70
PUBLIC	??1_ATL_COM_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70
PUBLIC	??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
PUBLIC	??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
PUBLIC	?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
PUBLIC	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
PUBLIC	??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
PUBLIC	??0_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
PUBLIC	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
PUBLIC	?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ; ATL::AtlWinModuleInit
PUBLIC	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm
PUBLIC	??0CAtlComModule@ATL@@QAE@XZ			; ATL::CAtlComModule::CAtlComModule
PUBLIC	??1CAtlComModule@ATL@@QAE@XZ			; ATL::CAtlComModule::~CAtlComModule
PUBLIC	?Term@CAtlComModule@ATL@@QAEXXZ			; ATL::CAtlComModule::Term
PUBLIC	??0CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::CAtlWinModule
PUBLIC	??1CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::~CAtlWinModule
PUBLIC	?Term@CAtlWinModule@ATL@@QAEXXZ			; ATL::CAtlWinModule::Term
PUBLIC	?ImGui_ImplDX9_RenderDrawLists@@YAXPAUImDrawData@@@Z ; ImGui_ImplDX9_RenderDrawLists
PUBLIC	??0?$CComPtrBase@UIDirect3DSurface9@@@ATL@@IAE@XZ ; ATL::CComPtrBase<IDirect3DSurface9>::CComPtrBase<IDirect3DSurface9>
PUBLIC	??0?$CComPtrBase@UIDirect3DSurface9@@@ATL@@IAE@PAUIDirect3DSurface9@@@Z ; ATL::CComPtrBase<IDirect3DSurface9>::CComPtrBase<IDirect3DSurface9>
PUBLIC	??1?$CComPtrBase@UIDirect3DSurface9@@@ATL@@QAE@XZ ; ATL::CComPtrBase<IDirect3DSurface9>::~CComPtrBase<IDirect3DSurface9>
PUBLIC	??B?$CComPtrBase@UIDirect3DSurface9@@@ATL@@QBEPAUIDirect3DSurface9@@XZ ; ATL::CComPtrBase<IDirect3DSurface9>::operator IDirect3DSurface9 *
PUBLIC	??I?$CComPtrBase@UIDirect3DSurface9@@@ATL@@QAEPAPAUIDirect3DSurface9@@XZ ; ATL::CComPtrBase<IDirect3DSurface9>::operator&
PUBLIC	??0?$CComPtr@UIDirect3DSurface9@@@ATL@@QAE@XZ	; ATL::CComPtr<IDirect3DSurface9>::CComPtr<IDirect3DSurface9>
PUBLIC	??0?$CComPtr@UIDirect3DSurface9@@@ATL@@QAE@PAUIDirect3DSurface9@@@Z ; ATL::CComPtr<IDirect3DSurface9>::CComPtr<IDirect3DSurface9>
PUBLIC	??1?$CComPtr@UIDirect3DSurface9@@@ATL@@QAE@XZ	; ATL::CComPtr<IDirect3DSurface9>::~CComPtr<IDirect3DSurface9>
PUBLIC	?ImGui_ImplDX9_CreateFontsTexture@@YA_NXZ	; ImGui_ImplDX9_CreateFontsTexture
PUBLIC	??0?$CComPtrBase@UIDirect3DSwapChain9@@@ATL@@IAE@PAUIDirect3DSwapChain9@@@Z ; ATL::CComPtrBase<IDirect3DSwapChain9>::CComPtrBase<IDirect3DSwapChain9>
PUBLIC	??1?$CComPtrBase@UIDirect3DSwapChain9@@@ATL@@QAE@XZ ; ATL::CComPtrBase<IDirect3DSwapChain9>::~CComPtrBase<IDirect3DSwapChain9>
PUBLIC	??I?$CComPtrBase@UIDirect3DSwapChain9@@@ATL@@QAEPAPAUIDirect3DSwapChain9@@XZ ; ATL::CComPtrBase<IDirect3DSwapChain9>::operator&
PUBLIC	??C?$CComPtrBase@UIDirect3DSwapChain9@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIDirect3DSwapChain9@@@1@XZ ; ATL::CComPtrBase<IDirect3DSwapChain9>::operator->
PUBLIC	??0?$CComPtr@UIDirect3DSwapChain9@@@ATL@@QAE@PAUIDirect3DSwapChain9@@@Z ; ATL::CComPtr<IDirect3DSwapChain9>::CComPtr<IDirect3DSwapChain9>
PUBLIC	??1?$CComPtr@UIDirect3DSwapChain9@@@ATL@@QAE@XZ	; ATL::CComPtr<IDirect3DSwapChain9>::~CComPtr<IDirect3DSwapChain9>
PUBLIC	?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A ; ATL::atlTraceGeneral
PUBLIC	?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A ; ATL::atlTraceCOM
PUBLIC	?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A ; ATL::atlTraceQI
PUBLIC	?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A ; ATL::atlTraceRegistrar
PUBLIC	?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A ; ATL::atlTraceRefcount
PUBLIC	?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A ; ATL::atlTraceWindowing
PUBLIC	?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A ; ATL::atlTraceControls
PUBLIC	?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A ; ATL::atlTraceHosting
PUBLIC	?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A ; ATL::atlTraceDBClient
PUBLIC	?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A ; ATL::atlTraceDBProvider
PUBLIC	?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A ; ATL::atlTraceSnapin
PUBLIC	?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A ; ATL::atlTraceNotImpl
PUBLIC	?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A ; ATL::atlTraceAllocation
PUBLIC	?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
PUBLIC	?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A ; ATL::atlTraceTime
PUBLIC	?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A ; ATL::atlTraceCache
PUBLIC	?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A ; ATL::atlTraceStencil
PUBLIC	?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A ; ATL::atlTraceString
PUBLIC	?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A ; ATL::atlTraceMap
PUBLIC	?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A ; ATL::atlTraceUtil
PUBLIC	?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A ; ATL::atlTraceSecurity
PUBLIC	?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A ; ATL::atlTraceSync
PUBLIC	?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A ; ATL::atlTraceISAPI
PUBLIC	?m_bInitFailed@CAtlBaseModule@ATL@@2_NA		; ATL::CAtlBaseModule::m_bInitFailed
PUBLIC	?_AtlComModule@ATL@@3VCAtlComModule@1@A		; ATL::_AtlComModule
PUBLIC	?_AtlWinModule@ATL@@3VCAtlWinModule@1@A		; ATL::_AtlWinModule
PUBLIC	__real@3b808081
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__xmm@0000000000000000000000003f800000
PUBLIC	__xmm@00000000000000003f80000000000000
PUBLIC	__xmm@000000003f8000000000000000000000
PUBLIC	__xmm@3f800000000000000000000000000000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	_atexit:PROC
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	___std_terminate:PROC
EXTRN	?GetIO@ImGui@@YAAAUImGuiIO@@XZ:PROC		; ImGui::GetIO
EXTRN	?NewFrame@ImGui@@YAXXZ:PROC			; ImGui::NewFrame
EXTRN	?Shutdown@ImGui@@YAXXZ:PROC			; ImGui::Shutdown
EXTRN	?GetTexDataAsRGBA32@ImFontAtlas@@QAEXPAPAEPAH11@Z:PROC ; ImFontAtlas::GetTexDataAsRGBA32
EXTRN	__imp__free:PROC
EXTRN	__imp__DecodePointer@4:PROC
EXTRN	__imp__RaiseException@16:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__QueryPerformanceFrequency@4:PROC
EXTRN	__imp__InitializeCriticalSectionEx@12:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__GetModuleHandleW@4:PROC
EXTRN	__imp__UnregisterClassW@8:PROC
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	?SK_TLS_Bottom@@YGPAUSK_TLS@@XZ:PROC		; SK_TLS_Bottom
EXTRN	?SK_ImGui_LoadFonts@@YAXXZ:PROC			; SK_ImGui_LoadFonts
EXTRN	?SK_ImGui_ResetExternal@@YAXXZ:PROC		; SK_ImGui_ResetExternal
EXTRN	?SK_ImGui_PollGamepad@@YAXXZ:PROC		; SK_ImGui_PollGamepad
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__ftoui3:PROC
EXTRN	__ltod3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	?QueryPerformanceCounter_Original@@3P6GHPAT_LARGE_INTEGER@@@ZA:DWORD ; QueryPerformanceCounter_Original
EXTRN	?config@@3Usk_config_t@@A:BYTE			; config
EXTRN	?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A:BYTE	; ATL::_AtlBaseModule
EXTRN	___ImageBase:BYTE
EXTRN	__fltused:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
;	COMDAT ?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A
_BSS	SEGMENT
?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceGeneral
_BSS	ENDS
;	COMDAT ?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A
_BSS	SEGMENT
?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceCOM
_BSS	ENDS
;	COMDAT ?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A
_BSS	SEGMENT
?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceQI
_BSS	ENDS
;	COMDAT ?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A
_BSS	SEGMENT
?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceRegistrar
_BSS	ENDS
;	COMDAT ?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A
_BSS	SEGMENT
?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceRefcount
_BSS	ENDS
;	COMDAT ?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A
_BSS	SEGMENT
?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceWindowing
_BSS	ENDS
;	COMDAT ?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A
_BSS	SEGMENT
?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceControls
_BSS	ENDS
;	COMDAT ?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A
_BSS	SEGMENT
?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceHosting
_BSS	ENDS
;	COMDAT ?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceDBClient
_BSS	ENDS
;	COMDAT ?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceDBProvider
_BSS	ENDS
;	COMDAT ?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSnapin
_BSS	ENDS
;	COMDAT ?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceNotImpl
_BSS	ENDS
;	COMDAT ?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceAllocation
_BSS	ENDS
;	COMDAT ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceException
_BSS	ENDS
;	COMDAT ?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceTime
_BSS	ENDS
;	COMDAT ?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceCache
_BSS	ENDS
;	COMDAT ?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceStencil
_BSS	ENDS
;	COMDAT ?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceString
_BSS	ENDS
;	COMDAT ?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceMap
_BSS	ENDS
;	COMDAT ?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceUtil
_BSS	ENDS
;	COMDAT ?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSecurity
_BSS	ENDS
;	COMDAT ?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSync
_BSS	ENDS
;	COMDAT ?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceISAPI
_BSS	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_BSS	SEGMENT
?m_bInitFailed@CAtlBaseModule@ATL@@2_NA DB 01H DUP (?)	; ATL::CAtlBaseModule::m_bInitFailed
_BSS	ENDS
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT
?_AtlWinModule@ATL@@3VCAtlWinModule@1@A DB 02cH DUP (?)	; ATL::_AtlWinModule
_BSS	ENDS
;	COMDAT ?hModTBFix@?1??ImGui_ImplDX9_NewFrame@@YAXXZ@4PAUHINSTANCE__@@A
_BSS	SEGMENT
?hModTBFix@?1??ImGui_ImplDX9_NewFrame@@YAXXZ@4PAUHINSTANCE__@@A DD 01H DUP (?) ; `ImGui_ImplDX9_NewFrame'::`2'::hModTBFix
_BSS	ENDS
;	COMDAT ?$TSS0@?1??ImGui_ImplDX9_NewFrame@@YAXXZ@4HA
_BSS	SEGMENT
?$TSS0@?1??ImGui_ImplDX9_NewFrame@@YAXXZ@4HA DD 01H DUP (?) ; TSS0<`template-parameter-2',Gui_ImplDX9_NewFrame,int, ?? &>
_BSS	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_AtlComModule$initializer$@ATL@@3P6AXXZA DD FLAT:??__E_AtlComModule@ATL@@YAXXZ ; ATL::_AtlComModule$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __xmm@3f800000000000000000000000000000
CONST	SEGMENT
__xmm@3f800000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@000000003f8000000000000000000000
CONST	SEGMENT
__xmm@000000003f8000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 080H, '?', 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000000000000003f80000000000000
CONST	SEGMENT
__xmm@00000000000000003f80000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 080H
	DB	'?', 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@0000000000000000000000003f800000
CONST	SEGMENT
__xmm@0000000000000000000000003f800000 DB 00H, 00H, 080H, '?', 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3b808081
CONST	SEGMENT
__real@3b808081 DD 03b808081r			; 0.00392157
CONST	ENDS
;	COMDAT ?_AtlComModule@ATL@@3VCAtlComModule@1@A
_DATA	SEGMENT
?_AtlComModule@ATL@@3VCAtlComModule@1@A DB 04H DUP (?)
	DD	FLAT:___ImageBase			; ATL::_AtlComModule
	DD	FLAT:___pobjMapEntryFirst+4
	DD	FLAT:___pobjMapEntryLast
_DATA	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComPtr@UIDirect3DSwapChain9@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CComPtr@UIDirect3DSurface9@@@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??__F_AtlComModule@ATL@@YAXXZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??__F_AtlComModule@ATL@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??__F_AtlComModule@ATL@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CAtlComModule@ATL@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
xdata$x	SEGMENT
__unwindtable$?ImGui_ImplDX9_NewFrame@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ImGui_ImplDX9_NewFrame@@YAXXZ$0
__unwindtable$?ImGui_ImplDX9_RenderDrawLists@@YAXPAUImDrawData@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ImGui_ImplDX9_RenderDrawLists@@YAXPAUImDrawData@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ImGui_ImplDX9_RenderDrawLists@@YAXPAUImDrawData@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ImGui_ImplDX9_RenderDrawLists@@YAXPAUImDrawData@@@Z$2
__ehfuncinfo$?ImGui_ImplDX9_RenderDrawLists@@YAXPAUImDrawData@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?ImGui_ImplDX9_RenderDrawLists@@YAXPAUImDrawData@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?ImGui_ImplDX9_NewFrame@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ImGui_ImplDX9_NewFrame@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_AtlWinModule$initializer$@ATL@@3P6AXXZA DD FLAT:??__E_AtlWinModule@ATL@@YAXXZ ; ATL::_AtlWinModule$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtr@UIDirect3DSwapChain9@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComPtr@UIDirect3DSwapChain9@@@ATL@@QAE@XZ PROC	; ATL::CComPtr<IDirect3DSwapChain9>::~CComPtr<IDirect3DSwapChain9>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComPtr@UIDirect3DSwapChain9@@@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@CComPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN4@CComPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComPtr@UIDirect3DSwapChain9@@@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComPtr@UIDirect3DSwapChain9@@@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComPtr@UIDirect3DSwapChain9@@@ATL@@QAE@XZ ENDP	; ATL::CComPtr<IDirect3DSwapChain9>::~CComPtr<IDirect3DSwapChain9>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UIDirect3DSwapChain9@@@ATL@@QAE@PAUIDirect3DSwapChain9@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtr@UIDirect3DSwapChain9@@@ATL@@QAE@PAUIDirect3DSwapChain9@@@Z PROC ; ATL::CComPtr<IDirect3DSwapChain9>::CComPtr<IDirect3DSwapChain9>, COMDAT
; _this$ = ecx

; 312  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi

; 312  :     {

	mov	esi, ecx

; 162  :         p = lp;

	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN6@CComPtr

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN6@CComPtr:

; 313  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtr@UIDirect3DSwapChain9@@@ATL@@QAE@PAUIDirect3DSwapChain9@@@Z ENDP ; ATL::CComPtr<IDirect3DSwapChain9>::CComPtr<IDirect3DSwapChain9>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??C?$CComPtrBase@UIDirect3DSwapChain9@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIDirect3DSwapChain9@@@1@XZ
_TEXT	SEGMENT
??C?$CComPtrBase@UIDirect3DSwapChain9@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIDirect3DSwapChain9@@@1@XZ PROC ; ATL::CComPtrBase<IDirect3DSwapChain9>::operator->, COMDAT
; _this$ = ecx

; 197  :         ATLASSERT(p!=NULL);
; 198  :         return (_NoAddRefReleaseOnCComPtr<T>*)p;

	mov	eax, DWORD PTR [ecx]

; 199  :     }

	ret	0
??C?$CComPtrBase@UIDirect3DSwapChain9@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIDirect3DSwapChain9@@@1@XZ ENDP ; ATL::CComPtrBase<IDirect3DSwapChain9>::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??I?$CComPtrBase@UIDirect3DSwapChain9@@@ATL@@QAEPAPAUIDirect3DSwapChain9@@XZ
_TEXT	SEGMENT
??I?$CComPtrBase@UIDirect3DSwapChain9@@@ATL@@QAEPAPAUIDirect3DSwapChain9@@XZ PROC ; ATL::CComPtrBase<IDirect3DSwapChain9>::operator&, COMDAT
; _this$ = ecx

; 192  :         ATLASSERT(p==NULL);
; 193  :         return &p;

	mov	eax, ecx

; 194  :     }

	ret	0
??I?$CComPtrBase@UIDirect3DSwapChain9@@@ATL@@QAEPAPAUIDirect3DSwapChain9@@XZ ENDP ; ATL::CComPtrBase<IDirect3DSwapChain9>::operator&
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UIDirect3DSwapChain9@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UIDirect3DSwapChain9@@@ATL@@QAE@XZ PROC ; ATL::CComPtrBase<IDirect3DSwapChain9>::~CComPtrBase<IDirect3DSwapChain9>, COMDAT
; _this$ = ecx

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN2@CComPtrBas

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@CComPtrBas:

; 178  :     }

	ret	0
??1?$CComPtrBase@UIDirect3DSwapChain9@@@ATL@@QAE@XZ ENDP ; ATL::CComPtrBase<IDirect3DSwapChain9>::~CComPtrBase<IDirect3DSwapChain9>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UIDirect3DSwapChain9@@@ATL@@IAE@PAUIDirect3DSwapChain9@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtrBase@UIDirect3DSwapChain9@@@ATL@@IAE@PAUIDirect3DSwapChain9@@@Z PROC ; ATL::CComPtrBase<IDirect3DSwapChain9>::CComPtrBase<IDirect3DSwapChain9>, COMDAT
; _this$ = ecx

; 160  :     CComPtrBase(_Inout_opt_ T* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp

; 161  :     {
; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN4@CComPtrBas

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN4@CComPtrBas:

; 165  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtrBase@UIDirect3DSwapChain9@@@ATL@@IAE@PAUIDirect3DSwapChain9@@@Z ENDP ; ATL::CComPtrBase<IDirect3DSwapChain9>::CComPtrBase<IDirect3DSwapChain9>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp
_TEXT	SEGMENT
_tex_locked_rect$ = -24					; size = 8
_pixels$ = -16						; size = 4
_bytes_per_pixel$ = -12					; size = 4
_width$ = -8						; size = 4
_height$ = -4						; size = 4
?ImGui_ImplDX9_CreateFontsTexture@@YA_NXZ PROC		; ImGui_ImplDX9_CreateFontsTexture

; 405  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	edi

; 406  :   SK_TLS_Bottom ()->texture_management.injection_thread = TRUE;

	call	?SK_TLS_Bottom@@YGPAUSK_TLS@@XZ		; SK_TLS_Bottom
	mov	DWORD PTR [eax+16], 1

; 407  : 
; 408  :   // Build texture atlas
; 409  :   ImGuiIO& io (ImGui::GetIO ());

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	edi, eax

; 410  : 
; 411  :   extern void
; 412  :   SK_ImGui_LoadFonts (void);
; 413  : 
; 414  :   SK_ImGui_LoadFonts ();

	call	?SK_ImGui_LoadFonts@@YAXXZ		; SK_ImGui_LoadFonts

; 415  : 
; 416  :   unsigned char* pixels;
; 417  :   int            width,
; 418  :                  height,
; 419  :                  bytes_per_pixel;
; 420  : 
; 421  :   io.Fonts->GetTexDataAsRGBA32 ( &pixels,

	mov	ecx, DWORD PTR [edi+128]
	lea	eax, DWORD PTR _bytes_per_pixel$[ebp]
	push	eax
	lea	eax, DWORD PTR _height$[ebp]
	push	eax
	lea	eax, DWORD PTR _width$[ebp]
	push	eax
	lea	eax, DWORD PTR _pixels$[ebp]
	push	eax
	call	?GetTexDataAsRGBA32@ImFontAtlas@@QAEXPAPAEPAH11@Z ; ImFontAtlas::GetTexDataAsRGBA32

; 422  :                                    &width, &height,
; 423  :                                      &bytes_per_pixel );
; 424  : 
; 425  :   // Upload texture to graphics system
; 426  :   g_FontTexture = nullptr;
; 427  : 
; 428  :   if ( g_pd3dDevice->CreateTexture ( width, height,
; 429  :                                        1, D3DUSAGE_DYNAMIC,
; 430  :                                           D3DFMT_A8R8G8B8,
; 431  :                                           D3DPOOL_DEFAULT,
; 432  :                                             &g_FontTexture,
; 433  :                                               nullptr ) < 0 )

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	0
	push	OFFSET ?g_FontTexture@@3PAUIDirect3DTexture9@@A
	push	0
	push	21					; 00000015H
	push	512					; 00000200H
	push	1
	push	DWORD PTR _height$[ebp]
	mov	DWORD PTR ?g_FontTexture@@3PAUIDirect3DTexture9@@A, 0
	push	DWORD PTR _width$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+92]
	test	eax, eax
	jns	SHORT $LN5@ImGui_Impl
$LN12@ImGui_Impl:

; 434  :   {
; 435  :     SK_TLS_Bottom ()->texture_management.injection_thread = FALSE;

	call	?SK_TLS_Bottom@@YGPAUSK_TLS@@XZ		; SK_TLS_Bottom
	pop	edi
	mov	DWORD PTR [eax+16], 0

; 436  :     return false;

	xor	al, al

; 464  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@ImGui_Impl:

; 437  :   }
; 438  : 
; 439  :   D3DLOCKED_RECT tex_locked_rect;
; 440  : 
; 441  :   if ( g_FontTexture->LockRect ( 0,       &tex_locked_rect,
; 442  :                                  nullptr, 0 ) != D3D_OK )

	mov	eax, DWORD PTR ?g_FontTexture@@3PAUIDirect3DTexture9@@A
	lea	edx, DWORD PTR _tex_locked_rect$[ebp]
	push	0
	push	0
	push	edx
	mov	ecx, DWORD PTR [eax]
	push	0
	push	eax
	call	DWORD PTR [ecx+76]
	test	eax, eax
	jne	SHORT $LN12@ImGui_Impl

; 443  :   {
; 444  :     SK_TLS_Bottom ()->texture_management.injection_thread = FALSE;
; 445  :     return false;
; 446  :   }
; 447  : 
; 448  :   for (int y = 0; y < height; y++)

	push	esi
	xor	esi, esi
	cmp	DWORD PTR _height$[ebp], esi
	jle	SHORT $LN3@ImGui_Impl
$LL4@ImGui_Impl:

; 449  :   {
; 450  :       memcpy ( (unsigned char *)tex_locked_rect.pBits + tex_locked_rect.Pitch * y,

	mov	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _bytes_per_pixel$[ebp]
	push	eax
	mov	eax, esi
	imul	eax, DWORD PTR _width$[ebp]
	imul	eax, DWORD PTR _bytes_per_pixel$[ebp]
	add	eax, DWORD PTR _pixels$[ebp]
	push	eax
	mov	eax, DWORD PTR _tex_locked_rect$[ebp]
	imul	eax, esi
	add	eax, DWORD PTR _tex_locked_rect$[ebp+4]
	push	eax
	call	_memcpy
	inc	esi
	add	esp, 12					; 0000000cH
	cmp	esi, DWORD PTR _height$[ebp]
	jl	SHORT $LL4@ImGui_Impl
$LN3@ImGui_Impl:

; 451  :                  pixels + (width * bytes_per_pixel) * y,
; 452  :                    (width * bytes_per_pixel) );
; 453  :   }
; 454  : 
; 455  :   g_FontTexture->UnlockRect (0);

	mov	eax, DWORD PTR ?g_FontTexture@@3PAUIDirect3DTexture9@@A
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+80]

; 456  : 
; 457  :   // Store our identifier
; 458  :   io.Fonts->TexID =

	mov	ecx, DWORD PTR [edi+128]
	mov	eax, DWORD PTR ?g_FontTexture@@3PAUIDirect3DTexture9@@A
	mov	DWORD PTR [ecx], eax

; 459  :     static_cast <void *> (g_FontTexture);
; 460  : 
; 461  :   SK_TLS_Bottom ()->texture_management.injection_thread = FALSE;

	call	?SK_TLS_Bottom@@YGPAUSK_TLS@@XZ		; SK_TLS_Bottom
	pop	esi
	pop	edi
	mov	DWORD PTR [eax+16], 0

; 462  : 
; 463  :   return true;

	mov	al, 1

; 464  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ImGui_ImplDX9_CreateFontsTexture@@YA_NXZ ENDP		; ImGui_ImplDX9_CreateFontsTexture
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtr@UIDirect3DSurface9@@@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CComPtr@UIDirect3DSurface9@@@ATL@@QAE@XZ PROC	; ATL::CComPtr<IDirect3DSurface9>::~CComPtr<IDirect3DSurface9>, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$CComPtr@UIDirect3DSurface9@@@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@CComPtr

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN4@CComPtr:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CComPtr@UIDirect3DSurface9@@@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$CComPtr@UIDirect3DSurface9@@@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$CComPtr@UIDirect3DSurface9@@@ATL@@QAE@XZ ENDP	; ATL::CComPtr<IDirect3DSurface9>::~CComPtr<IDirect3DSurface9>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UIDirect3DSurface9@@@ATL@@QAE@PAUIDirect3DSurface9@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtr@UIDirect3DSurface9@@@ATL@@QAE@PAUIDirect3DSurface9@@@Z PROC ; ATL::CComPtr<IDirect3DSurface9>::CComPtr<IDirect3DSurface9>, COMDAT
; _this$ = ecx

; 312  :     {

	npad	2
	push	ebp
	mov	ebp, esp

; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi

; 312  :     {

	mov	esi, ecx

; 162  :         p = lp;

	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN6@CComPtr

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN6@CComPtr:

; 313  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtr@UIDirect3DSurface9@@@ATL@@QAE@PAUIDirect3DSurface9@@@Z ENDP ; ATL::CComPtr<IDirect3DSurface9>::CComPtr<IDirect3DSurface9>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UIDirect3DSurface9@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CComPtr@UIDirect3DSurface9@@@ATL@@QAE@XZ PROC	; ATL::CComPtr<IDirect3DSurface9>::CComPtr<IDirect3DSurface9>, COMDAT
; _this$ = ecx

; 158  :         p = NULL;

	mov	DWORD PTR [ecx], 0

; 308  :     {
; 309  :     }

	mov	eax, ecx
	ret	0
??0?$CComPtr@UIDirect3DSurface9@@@ATL@@QAE@XZ ENDP	; ATL::CComPtr<IDirect3DSurface9>::CComPtr<IDirect3DSurface9>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??I?$CComPtrBase@UIDirect3DSurface9@@@ATL@@QAEPAPAUIDirect3DSurface9@@XZ
_TEXT	SEGMENT
??I?$CComPtrBase@UIDirect3DSurface9@@@ATL@@QAEPAPAUIDirect3DSurface9@@XZ PROC ; ATL::CComPtrBase<IDirect3DSurface9>::operator&, COMDAT
; _this$ = ecx

; 192  :         ATLASSERT(p==NULL);
; 193  :         return &p;

	mov	eax, ecx

; 194  :     }

	ret	0
??I?$CComPtrBase@UIDirect3DSurface9@@@ATL@@QAEPAPAUIDirect3DSurface9@@XZ ENDP ; ATL::CComPtrBase<IDirect3DSurface9>::operator&
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??B?$CComPtrBase@UIDirect3DSurface9@@@ATL@@QBEPAUIDirect3DSurface9@@XZ
_TEXT	SEGMENT
??B?$CComPtrBase@UIDirect3DSurface9@@@ATL@@QBEPAUIDirect3DSurface9@@XZ PROC ; ATL::CComPtrBase<IDirect3DSurface9>::operator IDirect3DSurface9 *, COMDAT
; _this$ = ecx

; 181  :         return p;

	mov	eax, DWORD PTR [ecx]

; 182  :     }

	ret	0
??B?$CComPtrBase@UIDirect3DSurface9@@@ATL@@QBEPAUIDirect3DSurface9@@XZ ENDP ; ATL::CComPtrBase<IDirect3DSurface9>::operator IDirect3DSurface9 *
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??1?$CComPtrBase@UIDirect3DSurface9@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComPtrBase@UIDirect3DSurface9@@@ATL@@QAE@XZ PROC	; ATL::CComPtrBase<IDirect3DSurface9>::~CComPtrBase<IDirect3DSurface9>, COMDAT
; _this$ = ecx

; 176  :         if (p)

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN2@CComPtrBas

; 177  :             p->Release();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
$LN2@CComPtrBas:

; 178  :     }

	ret	0
??1?$CComPtrBase@UIDirect3DSurface9@@@ATL@@QAE@XZ ENDP	; ATL::CComPtrBase<IDirect3DSurface9>::~CComPtrBase<IDirect3DSurface9>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UIDirect3DSurface9@@@ATL@@IAE@PAUIDirect3DSurface9@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComPtrBase@UIDirect3DSurface9@@@ATL@@IAE@PAUIDirect3DSurface9@@@Z PROC ; ATL::CComPtrBase<IDirect3DSurface9>::CComPtrBase<IDirect3DSurface9>, COMDAT
; _this$ = ecx

; 160  :     CComPtrBase(_Inout_opt_ T* lp) throw()

	npad	2
	push	ebp
	mov	ebp, esp

; 161  :     {
; 162  :         p = lp;

	mov	edx, DWORD PTR _lp$[ebp]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 163  :         if (p != NULL)

	test	edx, edx
	je	SHORT $LN4@CComPtrBas

; 164  :             p->AddRef();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+4]
$LN4@CComPtrBas:

; 165  :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$CComPtrBase@UIDirect3DSurface9@@@ATL@@IAE@PAUIDirect3DSurface9@@@Z ENDP ; ATL::CComPtrBase<IDirect3DSurface9>::CComPtrBase<IDirect3DSurface9>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtrBase@UIDirect3DSurface9@@@ATL@@IAE@XZ
_TEXT	SEGMENT
??0?$CComPtrBase@UIDirect3DSurface9@@@ATL@@IAE@XZ PROC	; ATL::CComPtrBase<IDirect3DSurface9>::CComPtrBase<IDirect3DSurface9>, COMDAT
; _this$ = ecx

; 157  :     {
; 158  :         p = NULL;

	mov	DWORD PTR [ecx], 0

; 159  :     }

	mov	eax, ecx
	ret	0
??0?$CComPtrBase@UIDirect3DSurface9@@@ATL@@IAE@XZ ENDP	; ATL::CComPtrBase<IDirect3DSurface9>::CComPtrBase<IDirect3DSurface9>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp
_TEXT	SEGMENT
_caps$ = -652						; size = 304
_rts$ = -348						; size = 128
_mat_identity$2 = -220					; size = 64
_r$3 = -156						; size = 16
_mat_projection$4 = -140				; size = 64
_vp$ = -76						; size = 24
_cmd_list$1$ = -52					; size = 4
_pBackBuffer$ = -48					; size = 4
_pDS$ = -44						; size = 4
_n$1$ = -40						; size = 4
tv1657 = -40						; size = 4
_idx_dst$ = -36						; size = 4
_cmd_i$1$ = -32						; size = 4
_io$1$ = -32						; size = 4
_n$1$ = -28						; size = 4
tv1826 = -28						; size = 4
_a$1$ = -24						; size = 4
_vtx_offset$1$ = -24					; size = 4
_idx_offset$1$ = -20					; size = 4
_i$1$ = -20						; size = 4
_vtx_dst$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_draw_data$ = 8						; size = 4
?ImGui_ImplDX9_RenderDrawLists@@YAXPAUImDrawData@@@Z PROC ; ImGui_ImplDX9_RenderDrawLists

; 52   : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ImGui_ImplDX9_RenderDrawLists@@YAXPAUImDrawData@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 640				; 00000280H
	push	edi

; 53   :   // Avoid rendering when minimized
; 54   :   ImGuiIO& io (ImGui::GetIO ());

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO
	mov	edi, eax
	xorps	xmm0, xmm0
	mov	DWORD PTR _io$1$[ebp], edi

; 55   : 
; 56   :   if ( io.DisplaySize.x <= 0.0f || io.DisplaySize.y <= 0.0f )

	comiss	xmm0, DWORD PTR [edi]
	jae	$LN27@ImGui_Impl
	comiss	xmm0, DWORD PTR [edi+4]
	jae	$LN27@ImGui_Impl

; 57   :     return;
; 58   : 
; 59   :   // Create and grow buffers if needed
; 60   :   if ((! g_pVB) || g_VertexBufferSize < draw_data->TotalVtxCount )

	mov	edx, DWORD PTR ?g_pVB@@3PAUIDirect3DVertexBuffer9@@A
	push	ebx
	mov	ebx, DWORD PTR _draw_data$[ebp]
	test	edx, edx
	je	SHORT $LN30@ImGui_Impl
	mov	eax, DWORD PTR ?g_VertexBufferSize@@3HA
	cmp	eax, DWORD PTR [ebx+12]
	jge	SHORT $LN31@ImGui_Impl

; 61   :   {
; 62   :     if (g_pVB) {
; 63   :       g_pVB->Release ();

	mov	eax, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [eax+8]

; 64   :       g_pVB = nullptr;

	mov	DWORD PTR ?g_pVB@@3PAUIDirect3DVertexBuffer9@@A, 0
$LN30@ImGui_Impl:

; 65   :     }
; 66   : 
; 67   :     g_VertexBufferSize =

	mov	edx, DWORD PTR [ebx+12]

; 68   :       draw_data->TotalVtxCount + 5000;
; 69   : 
; 70   :     if ( g_pd3dDevice->CreateVertexBuffer ( g_VertexBufferSize * sizeof CUSTOMVERTEX,
; 71   :                                               D3DUSAGE_DYNAMIC | D3DUSAGE_WRITEONLY,
; 72   :                                                 D3DFVF_CUSTOMVERTEX,
; 73   :                                                   D3DPOOL_DEFAULT,
; 74   :                                                     &g_pVB,
; 75   :                                                       nullptr ) < 0 ) {

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	add	edx, 5000				; 00001388H
	push	0
	push	OFFSET ?g_pVB@@3PAUIDirect3DVertexBuffer9@@A
	push	0
	mov	ecx, DWORD PTR [eax]
	push	578					; 00000242H
	mov	DWORD PTR ?g_VertexBufferSize@@3HA, edx
	push	520					; 00000208H
	shl	edx, 5
	push	edx
	push	eax
	call	DWORD PTR [ecx+104]
	test	eax, eax
	js	$LN185@ImGui_Impl
	mov	edx, DWORD PTR ?g_pVB@@3PAUIDirect3DVertexBuffer9@@A
$LN31@ImGui_Impl:

; 76   :       return;
; 77   :     }
; 78   :   }
; 79   : 
; 80   :   if ((! g_pIB) || g_IndexBufferSize < draw_data->TotalIdxCount)

	mov	ecx, DWORD PTR ?g_pIB@@3PAUIDirect3DIndexBuffer9@@A
	test	ecx, ecx
	je	SHORT $LN34@ImGui_Impl
	mov	eax, DWORD PTR ?g_IndexBufferSize@@3HA
	cmp	eax, DWORD PTR [ebx+16]
	jge	SHORT $LN35@ImGui_Impl

; 81   :   {
; 82   :     if (g_pIB) {
; 83   :       g_pIB->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 84   :       g_pIB = NULL;

	mov	DWORD PTR ?g_pIB@@3PAUIDirect3DIndexBuffer9@@A, 0
$LN34@ImGui_Impl:

; 85   :     }
; 86   : 
; 87   :     g_IndexBufferSize = draw_data->TotalIdxCount + 10000;

	mov	eax, DWORD PTR [ebx+16]

; 88   : 
; 89   :     if ( g_pd3dDevice->CreateIndexBuffer ( g_IndexBufferSize * sizeof ImDrawIdx,
; 90   :                                              D3DUSAGE_DYNAMIC | D3DUSAGE_WRITEONLY,
; 91   :                                                sizeof (ImDrawIdx) == 2 ?
; 92   :                                                   D3DFMT_INDEX16 :
; 93   :                                                   D3DFMT_INDEX32,
; 94   :                                                 D3DPOOL_DEFAULT,
; 95   :                                                   &g_pIB,
; 96   :                                                     nullptr ) < 0 ) {

	mov	ecx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	add	eax, 10000				; 00002710H
	push	0
	push	OFFSET ?g_pIB@@3PAUIDirect3DIndexBuffer9@@A
	push	0
	mov	edx, DWORD PTR [ecx]
	push	101					; 00000065H
	mov	DWORD PTR ?g_IndexBufferSize@@3HA, eax
	add	eax, eax
	push	520					; 00000208H
	push	eax
	push	ecx
	call	DWORD PTR [edx+108]
	test	eax, eax
	js	$LN185@ImGui_Impl
	mov	edx, DWORD PTR ?g_pVB@@3PAUIDirect3DVertexBuffer9@@A
$LN35@ImGui_Impl:

; 97   :       return;
; 98   :     }
; 99   :   }
; 100  : 
; 101  :   //// Backup the DX9 state
; 102  : //  IDirect3DStateBlock9* d3d9_state_block = nullptr;
; 103  : //
; 104  : //  if (g_pd3dDevice->CreateStateBlock ( D3DSBT_ALL, &d3d9_state_block ) < 0 )
; 105  : //    return;
; 106  : 
; 107  :   // Copy and convert all vertices into a single contiguous buffer
; 108  :   CUSTOMVERTEX* vtx_dst = 0;
; 109  :   ImDrawIdx*    idx_dst = 0;
; 110  : 
; 111  :   if ( g_pVB->Lock ( 0,
; 112  :     static_cast <UINT> (draw_data->TotalVtxCount * sizeof CUSTOMVERTEX),
; 113  :                          (void **)&vtx_dst,
; 114  :                            D3DLOCK_DISCARD ) < 0 )

	push	8192					; 00002000H
	lea	eax, DWORD PTR _vtx_dst$[ebp]
	mov	DWORD PTR _vtx_dst$[ebp], 0
	push	eax
	mov	eax, DWORD PTR [ebx+12]
	shl	eax, 5
	push	eax
	mov	DWORD PTR _idx_dst$[ebp], 0
	mov	ecx, DWORD PTR [edx]
	push	0
	push	edx
	call	DWORD PTR [ecx+44]
	test	eax, eax
	js	$LN185@ImGui_Impl

; 115  :     return;
; 116  : 
; 117  :   if ( g_pIB->Lock ( 0,
; 118  :     static_cast <UINT> (draw_data->TotalIdxCount * sizeof ImDrawIdx),
; 119  :                          (void **)&idx_dst,
; 120  :                            D3DLOCK_DISCARD ) < 0 )

	mov	ecx, DWORD PTR ?g_pIB@@3PAUIDirect3DIndexBuffer9@@A
	lea	eax, DWORD PTR _idx_dst$[ebp]
	push	8192					; 00002000H
	push	eax
	mov	eax, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [ecx]
	add	eax, eax
	push	eax
	push	0
	push	ecx
	call	DWORD PTR [edx+44]
	test	eax, eax
	js	$LN185@ImGui_Impl

; 121  :     return;
; 122  : 
; 123  :   for ( int n = 0;

	xor	ecx, ecx
	push	esi
	mov	DWORD PTR _n$1$[ebp], ecx

; 124  :             n < draw_data->CmdListsCount;

	cmp	DWORD PTR [ebx+8], ecx
	jle	$LN3@ImGui_Impl
$LL4@ImGui_Impl:

; 125  :             n++ )
; 126  :   {
; 127  :     const ImDrawList* cmd_list = draw_data->CmdLists [n];

	mov	eax, DWORD PTR [ebx+4]

; 128  :     const ImDrawVert* vtx_src  = cmd_list->VtxBuffer.Data;
; 129  : 
; 130  :     for (int i = 0; i < cmd_list->VtxBuffer.Size; i++)

	xor	edx, edx
	mov	DWORD PTR _i$1$[ebp], edx
	mov	ebx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _cmd_list$1$[ebp], ebx
	mov	edi, DWORD PTR [ebx+32]
	cmp	DWORD PTR [ebx+24], edx
	jle	$LN6@ImGui_Impl
	mov	ecx, DWORD PTR _vtx_dst$[ebp]
$LL7@ImGui_Impl:

; 131  :     {
; 132  :       vtx_dst->pos [0] = vtx_src->pos.x;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ecx], eax

; 133  :       vtx_dst->pos [1] = vtx_src->pos.y;

	mov	eax, DWORD PTR _vtx_dst$[ebp]
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+4], ecx

; 134  :       vtx_dst->pos [2] = 0.0f;

	mov	eax, DWORD PTR _vtx_dst$[ebp]
	mov	DWORD PTR [eax+8], 0

; 135  :       vtx_dst->col     = (vtx_src->col & 0xFF00FF00)      |

	mov	eax, DWORD PTR [edi+16]
	movzx	ecx, al
	and	eax, -16711936				; ff00ff00H
	shl	ecx, 16					; 00000010H
	or	ecx, eax
	movzx	eax, BYTE PTR [edi+18]
	or	ecx, eax
	mov	eax, DWORD PTR _vtx_dst$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 136  :                         ((vtx_src->col & 0xFF0000) >> 16) |
; 137  :                         ((vtx_src->col & 0xFF)     << 16); // RGBA --> ARGB for DirectX9
; 138  : 
; 139  :       if (config.imgui.render.disable_alpha)

	cmp	BYTE PTR ?config@@3Usk_config_t@@A+312, 0
	je	$LN38@ImGui_Impl

; 140  :       {
; 141  :         uint8_t alpha = (((vtx_dst->col & 0xFF000000U) >> 24U) & 0xFFU);

	mov	eax, DWORD PTR _vtx_dst$[ebp]
	mov	bl, BYTE PTR [eax+15]

; 142  : 
; 143  :         // Boost alpha for visibility
; 144  :         if (alpha < 93 && alpha != 0)

	cmp	bl, 93					; 0000005dH
	jae	SHORT $LN39@ImGui_Impl
	test	bl, bl
	je	SHORT $LN39@ImGui_Impl

; 145  :           alpha += (93 - alpha) / 2;

	movzx	ecx, bl
	mov	eax, 93					; 0000005dH
	sub	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	bl, al
$LN39@ImGui_Impl:

; 146  : 
; 147  :         float a = ((float)                              alpha / 255.0f);

	movzx	eax, bl
	movd	xmm1, eax

; 148  :         float r = ((float)((vtx_src->col & 0xFF0000U) >> 16U) / 255.0f);
; 149  :         float g = ((float)((vtx_src->col & 0x00FF00U) >>  8U) / 255.0f);
; 150  :         float b = ((float)((vtx_src->col & 0x0000FFU)       ) / 255.0f);

	movzx	eax, BYTE PTR [edi+16]
	cvtdq2ps xmm1, xmm1
	movd	xmm0, eax
	mulss	xmm1, DWORD PTR __real@3b808081
	shr	eax, 31					; 0000001fH
	cvtdq2pd xmm0, xmm0
	movss	DWORD PTR _a$1$[ebp], xmm1
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0

; 151  : 
; 152  :         vtx_dst->col =                    0xFF000000U  |

	mulss	xmm0, xmm1
	call	__ftoui3
	movzx	ecx, BYTE PTR [edi+17]
	mov	esi, eax
	or	esi, -256				; ffffff00H
	shl	esi, 8
	movd	xmm0, ecx
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR _a$1$[ebp]
	call	__ftoui3
	or	esi, eax
	movzx	eax, BYTE PTR [edi+18]
	shl	esi, 8
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR _a$1$[ebp]
	call	__ftoui3
	mov	edx, DWORD PTR _i$1$[ebp]
	or	esi, eax
	mov	eax, DWORD PTR _vtx_dst$[ebp]
	mov	ebx, DWORD PTR _cmd_list$1$[ebp]
	mov	DWORD PTR [eax+12], esi
$LN38@ImGui_Impl:

; 153  :                        ((UINT)((b * a) * 255U) << 16U) |
; 154  :                        ((UINT)((g * a) * 255U) <<  8U) |
; 155  :                        ((UINT)((r * a) * 255U)       );
; 156  :       }
; 157  : 
; 158  :       vtx_dst->uv  [0] = vtx_src->uv.x;

	mov	eax, DWORD PTR _vtx_dst$[ebp]
	inc	edx
	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR _i$1$[ebp], edx
	mov	DWORD PTR [eax+16], ecx

; 159  :       vtx_dst->uv  [1] = vtx_src->uv.y;

	mov	eax, DWORD PTR _vtx_dst$[ebp]
	mov	ecx, DWORD PTR [edi+12]

; 160  :       vtx_dst++;
; 161  :       vtx_src++;

	add	edi, 20					; 00000014H
	mov	DWORD PTR [eax+20], ecx
	mov	ecx, DWORD PTR _vtx_dst$[ebp]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR _vtx_dst$[ebp], ecx
	cmp	edx, DWORD PTR [ebx+24]
	jl	$LL7@ImGui_Impl
$LN6@ImGui_Impl:

; 162  :     }
; 163  : 
; 164  :     memcpy ( idx_dst,

	mov	eax, DWORD PTR [ebx+12]
	add	eax, eax
	push	eax
	push	DWORD PTR [ebx+20]
	push	DWORD PTR _idx_dst$[ebp]
	call	_memcpy

; 165  :                cmd_list->IdxBuffer.Data,
; 166  :                  cmd_list->IdxBuffer.Size * sizeof ImDrawIdx);
; 167  : 
; 168  :     idx_dst += cmd_list->IdxBuffer.Size;

	mov	ecx, DWORD PTR [ebx+12]
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _idx_dst$[ebp]
	mov	ebx, DWORD PTR _draw_data$[ebp]
	lea	eax, DWORD PTR [eax+ecx*2]
	mov	ecx, DWORD PTR _n$1$[ebp]
	inc	ecx
	mov	DWORD PTR _idx_dst$[ebp], eax
	mov	DWORD PTR _n$1$[ebp], ecx
	cmp	ecx, DWORD PTR [ebx+8]
	jl	$LL4@ImGui_Impl
	mov	edi, DWORD PTR _io$1$[ebp]
$LN3@ImGui_Impl:

; 169  :   }
; 170  : 
; 171  :   g_pVB->Unlock ();

	mov	eax, DWORD PTR ?g_pVB@@3PAUIDirect3DVertexBuffer9@@A
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+48]

; 172  :   g_pIB->Unlock ();

	mov	eax, DWORD PTR ?g_pIB@@3PAUIDirect3DIndexBuffer9@@A
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+48]

; 173  : 
; 174  :   g_pd3dDevice->SetStreamSource (0, g_pVB, 0, sizeof CUSTOMVERTEX);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	32					; 00000020H
	push	0
	push	DWORD PTR ?g_pVB@@3PAUIDirect3DVertexBuffer9@@A
	mov	ecx, DWORD PTR [eax]
	push	0
	push	eax
	call	DWORD PTR [ecx+400]

; 175  :   g_pd3dDevice->SetIndices      (g_pIB);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	DWORD PTR ?g_pIB@@3PAUIDirect3DIndexBuffer9@@A
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+416]

; 176  :   g_pd3dDevice->SetFVF          (D3DFVF_CUSTOMVERTEX);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	578					; 00000242H
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+356]

; 177  : 
; 178  :   // Setup viewport
; 179  :   D3DVIEWPORT9 vp;
; 180  : 
; 181  :   vp.X = vp.Y = 0;

	mov	DWORD PTR _vp$[ebp+4], 0
	mov	DWORD PTR _vp$[ebp], 0

; 182  :   vp.Width  = (DWORD)io.DisplaySize.x;

	movss	xmm0, DWORD PTR [edi]
	call	__ftoui3
	mov	DWORD PTR _vp$[ebp+8], eax

; 183  :   vp.Height = (DWORD)io.DisplaySize.y;

	movss	xmm0, DWORD PTR [edi+4]
	call	__ftoui3
	mov	DWORD PTR _vp$[ebp+12], eax

; 184  :   vp.MinZ   = 0.0f;
; 185  :   vp.MaxZ   = 1.0f;
; 186  :   g_pd3dDevice->SetViewport (&vp);

	lea	edx, DWORD PTR _vp$[ebp]
	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	mov	DWORD PTR _vp$[ebp+16], 0
	mov	DWORD PTR _vp$[ebp+20], 1065353216	; 3f800000H
	push	edx
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+188]

; 187  : 
; 188  :   // Setup render state: fixed-pipeline, alpha-blending, no face culling, no depth testing
; 189  :   g_pd3dDevice->SetPixelShader       (NULL);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+428]

; 190  :   g_pd3dDevice->SetVertexShader      (NULL);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+368]

; 191  : 
; 192  :   D3DCAPS9                      caps;
; 193  :   g_pd3dDevice->GetDeviceCaps (&caps);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	lea	edx, DWORD PTR _caps$[ebp]
	push	edx
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+28]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pBackBuffer$[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp

; 196  :   CComPtr <IDirect3DSurface9> rts [32];

	push	OFFSET ??1?$CComPtr@UIDirect3DSurface9@@@ATL@@QAE@XZ
	push	OFFSET ??0?$CComPtr@UIDirect3DSurface9@@@ATL@@QAE@XZ ; ATL::CComPtr<IDirect3DSurface9>::CComPtr<IDirect3DSurface9>
	push	32					; 00000020H
	push	4
	lea	eax, DWORD PTR _rts$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	call	??_L@YGXPAXIIP6EX0@Z1@Z
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pDS$[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp

; 199  :   for (UINT target = 0; target < caps.NumSimultaneousRTs; target++)

	xor	esi, esi
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR _caps$[ebp+240], esi
	jbe	SHORT $LN9@ImGui_Impl

; 169  :   }
; 170  : 
; 171  :   g_pVB->Unlock ();

	lea	edi, DWORD PTR _rts$[ebp]
	npad	3
$LL10@ImGui_Impl:

; 200  :   {
; 201  :     g_pd3dDevice->GetRenderTarget (target, &rts [target]);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	edi
	push	esi
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+152]
	inc	esi
	add	edi, 4
	cmp	esi, DWORD PTR _caps$[ebp+240]
	jb	SHORT $LL10@ImGui_Impl
	mov	edi, DWORD PTR _io$1$[ebp]
$LN9@ImGui_Impl:

; 202  :   }
; 203  : 
; 204  :   g_pd3dDevice->GetDepthStencilSurface (&pDS);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	lea	edx, DWORD PTR _pDS$[ebp]
	push	edx
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+160]

; 205  :   
; 206  :   if (SUCCEEDED (g_pd3dDevice->GetBackBuffer (0, 0, D3DBACKBUFFER_TYPE_MONO, &pBackBuffer)))

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	lea	edx, DWORD PTR _pBackBuffer$[ebp]
	push	edx
	push	0
	push	0
	mov	ecx, DWORD PTR [eax]
	push	0
	push	eax
	call	DWORD PTR [ecx+72]
	test	eax, eax
	js	SHORT $LN12@ImGui_Impl

; 207  :   {
; 208  :     g_pd3dDevice->SetRenderTarget        (0, pBackBuffer);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	DWORD PTR _pBackBuffer$[ebp]
	push	0
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+148]

; 209  :     g_pd3dDevice->SetDepthStencilSurface (nullptr);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	0
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+156]

; 210  : 
; 211  :     for (UINT target = 1; target < caps.NumSimultaneousRTs; target++)

	mov	esi, 1
	cmp	DWORD PTR _caps$[ebp+240], esi
	jbe	SHORT $LN12@ImGui_Impl
	npad	6
$LL13@ImGui_Impl:

; 212  :       g_pd3dDevice->SetRenderTarget (target, nullptr);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	0
	push	esi
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+148]
	inc	esi
	cmp	esi, DWORD PTR _caps$[ebp+240]
	jb	SHORT $LL13@ImGui_Impl
$LN12@ImGui_Impl:

; 213  :   }
; 214  : 
; 215  :   g_pd3dDevice->SetRenderState       (D3DRS_CULLMODE,          D3DCULL_NONE);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	1
	push	22					; 00000016H
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+228]

; 216  :   g_pd3dDevice->SetRenderState       (D3DRS_LIGHTING,          FALSE);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	0
	push	137					; 00000089H
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+228]

; 217  : 
; 218  :   g_pd3dDevice->SetRenderState       (D3DRS_ALPHABLENDENABLE,  TRUE);// : FALSE);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	1
	push	27					; 0000001bH
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+228]

; 219  :   g_pd3dDevice->SetRenderState       (D3DRS_ALPHATESTENABLE,   FALSE);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	0
	push	15					; 0000000fH
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+228]

; 220  :   g_pd3dDevice->SetRenderState       (D3DRS_BLENDOP,           D3DBLENDOP_ADD);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	1
	push	171					; 000000abH
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+228]

; 221  : //  g_pd3dDevice->SetRenderState       (D3DRS_BLENDOPALPHA,      D3DBLENDOP_ADD);
; 222  :   g_pd3dDevice->SetRenderState       (D3DRS_SRCBLEND,          D3DBLEND_SRCALPHA);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	5
	push	19					; 00000013H
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+228]

; 223  :   g_pd3dDevice->SetRenderState       (D3DRS_DESTBLEND,         D3DBLEND_INVSRCALPHA);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	6
	push	20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+228]

; 224  :   g_pd3dDevice->SetRenderState       (D3DRS_STENCILENABLE,     FALSE);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	0
	push	52					; 00000034H
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+228]

; 225  :   g_pd3dDevice->SetRenderState       (D3DRS_SCISSORTESTENABLE, TRUE);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	1
	push	174					; 000000aeH
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+228]

; 226  :   g_pd3dDevice->SetRenderState       (D3DRS_ZENABLE,           FALSE);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	0
	push	7
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+228]

; 227  : 
; 228  :   g_pd3dDevice->SetRenderState       (D3DRS_SRGBWRITEENABLE,   FALSE);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	0
	push	194					; 000000c2H
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+228]

; 229  :   g_pd3dDevice->SetRenderState       (D3DRS_COLORWRITEENABLE,  D3DCOLORWRITEENABLE_RED   | 

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	15					; 0000000fH
	push	168					; 000000a8H
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+228]

; 230  :                                                                D3DCOLORWRITEENABLE_GREEN | 
; 231  :                                                                D3DCOLORWRITEENABLE_BLUE  |
; 232  :                                                                D3DCOLORWRITEENABLE_ALPHA );
; 233  : 
; 234  :   g_pd3dDevice->SetTextureStageState   (0, D3DTSS_COLOROP,     D3DTOP_MODULATE);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	4
	push	1
	push	0
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+268]

; 235  :   g_pd3dDevice->SetTextureStageState   (0, D3DTSS_COLORARG1,   D3DTA_TEXTURE);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	mov	ecx, DWORD PTR [eax]
	push	2
	push	2
	push	0
	push	eax
	call	DWORD PTR [ecx+268]

; 236  :   g_pd3dDevice->SetTextureStageState   (0, D3DTSS_COLORARG2,   D3DTA_DIFFUSE);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	0
	push	3
	push	0
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+268]

; 237  :   g_pd3dDevice->SetTextureStageState   (0, D3DTSS_ALPHAOP,     D3DTOP_MODULATE);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	4
	push	4
	push	0
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+268]

; 238  :   g_pd3dDevice->SetTextureStageState   (0, D3DTSS_ALPHAARG1,   D3DTA_TEXTURE);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	2
	push	5
	push	0
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+268]

; 239  :   g_pd3dDevice->SetTextureStageState   (0, D3DTSS_ALPHAARG2,   D3DTA_DIFFUSE);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	0
	push	6
	push	0
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+268]

; 240  :   g_pd3dDevice->SetSamplerState        (0, D3DSAMP_MINFILTER,  D3DTEXF_LINEAR);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	2
	push	6
	push	0
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+276]

; 241  :   g_pd3dDevice->SetSamplerState        (0, D3DSAMP_MAGFILTER,  D3DTEXF_LINEAR);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	2
	push	5
	push	0
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+276]

; 242  : 
; 243  :   for (UINT i = 1; i < caps.MaxTextureBlendStages; i++) {

	mov	esi, 1
	cmp	DWORD PTR _caps$[ebp+148], esi
	jbe	SHORT $LN15@ImGui_Impl
	npad	2
$LL16@ImGui_Impl:

; 244  :     g_pd3dDevice->SetTextureStageState (i, D3DTSS_COLOROP,     D3DTOP_DISABLE);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	1
	push	1
	push	esi
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+268]

; 245  :     g_pd3dDevice->SetTextureStageState (i, D3DTSS_ALPHAOP,     D3DTOP_DISABLE);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	1
	push	4
	push	esi
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+268]
	inc	esi
	cmp	esi, DWORD PTR _caps$[ebp+148]
	jb	SHORT $LL16@ImGui_Impl
$LN15@ImGui_Impl:

; 246  :   }
; 247  : 
; 248  :   // Setup orthographic projection matrix
; 249  :   // Being agnostic of whether <d3dx9.h> or <DirectXMath.h> can be used, we aren't relying on D3DXMatrixIdentity()/D3DXMatrixOrthoOffCenterLH() or DirectX::XMMatrixIdentity()/DirectX::XMMatrixOrthographicOffCenterLH()
; 250  :   {
; 251  :     const float L = 0.5f,
; 252  :                 R = io.DisplaySize.x + 0.5f,

	movss	xmm4, DWORD PTR __real@3f000000

; 253  :                 T = 0.5f,
; 254  :                 B = io.DisplaySize.y + 0.5f;
; 255  : 
; 256  :     D3DMATRIX mat_identity =
; 257  :     {
; 258  :       1.0f, 0.0f, 0.0f, 0.0f,
; 259  :       0.0f, 1.0f, 0.0f, 0.0f,
; 260  :       0.0f, 0.0f, 1.0f, 0.0f,
; 261  :       0.0f, 0.0f, 0.0f, 1.0f
; 262  :     };
; 263  : 
; 264  :     D3DMATRIX mat_projection =
; 265  :     {
; 266  :         2.0f/(R-L),   0.0f,         0.0f,  0.0f,
; 267  :         0.0f,         2.0f/(T-B),   0.0f,  0.0f,
; 268  :         0.0f,         0.0f,         0.5f,  0.0f,
; 269  :         (L+R)/(L-R),  (T+B)/(B-T),  0.5f,  1.0f,
; 270  :     };
; 271  : 
; 272  :     g_pd3dDevice->SetTransform (D3DTS_WORLD,      &mat_identity);

	lea	edx, DWORD PTR _mat_identity$2[ebp]
	movaps	xmm0, XMMWORD PTR __xmm@0000000000000000000000003f800000
	movss	xmm2, DWORD PTR [edi]
	movss	xmm5, DWORD PTR __real@3f800000
	addss	xmm2, xmm4
	movups	XMMWORD PTR _mat_identity$2[ebp], xmm0
	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	movaps	xmm0, XMMWORD PTR __xmm@00000000000000003f80000000000000
	movaps	xmm1, xmm5
	movups	XMMWORD PTR _mat_identity$2[ebp+16], xmm0
	push	edx
	movaps	xmm0, XMMWORD PTR __xmm@000000003f8000000000000000000000
	movups	XMMWORD PTR _mat_identity$2[ebp+32], xmm0
	mov	DWORD PTR _mat_projection$4[ebp+40], 1056964608 ; 3f000000H
	movaps	xmm0, XMMWORD PTR __xmm@3f800000000000000000000000000000
	movups	XMMWORD PTR _mat_identity$2[ebp+48], xmm0
	mov	DWORD PTR _mat_projection$4[ebp+44], 0
	movss	xmm3, DWORD PTR [edi+4]
	movaps	xmm0, xmm2
	subss	xmm0, xmm4
	mov	DWORD PTR _mat_projection$4[ebp+56], 1056964608 ; 3f000000H
	addss	xmm3, xmm4
	mov	DWORD PTR _mat_projection$4[ebp+60], 1065353216 ; 3f800000H
	push	256					; 00000100H
	push	eax
	divss	xmm1, xmm0
	xorps	xmm0, xmm0
	movups	XMMWORD PTR _mat_projection$4[ebp+4], xmm0
	movaps	xmm0, xmm4
	addss	xmm1, xmm1
	subss	xmm0, xmm3
	movss	DWORD PTR _mat_projection$4[ebp], xmm1
	movaps	xmm1, xmm2
	divss	xmm5, xmm0
	xorps	xmm0, xmm0
	addss	xmm1, xmm4
	movups	XMMWORD PTR _mat_projection$4[ebp+24], xmm0
	movaps	xmm0, xmm4
	addss	xmm5, xmm5
	subss	xmm0, xmm2
	movss	DWORD PTR _mat_projection$4[ebp+20], xmm5
	divss	xmm1, xmm0
	movaps	xmm0, xmm3
	subss	xmm3, xmm4
	addss	xmm0, xmm4
	movss	DWORD PTR _mat_projection$4[ebp+48], xmm1
	divss	xmm0, xmm3
	movss	DWORD PTR _mat_projection$4[ebp+52], xmm0
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+176]

; 273  :     g_pd3dDevice->SetTransform (D3DTS_VIEW,       &mat_identity);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	lea	edx, DWORD PTR _mat_identity$2[ebp]
	push	edx
	push	2
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+176]

; 274  :     g_pd3dDevice->SetTransform (D3DTS_PROJECTION, &mat_projection);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	lea	edx, DWORD PTR _mat_projection$4[ebp]
	push	edx
	push	3
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+176]

; 275  :   }
; 276  : 
; 277  :   // Render command lists
; 278  :   int vtx_offset = 0;

	xor	esi, esi

; 279  :   int idx_offset = 0;
; 280  : 
; 281  :   for (int n = 0; n < draw_data->CmdListsCount; n++)

	xor	ecx, ecx
	mov	DWORD PTR _vtx_offset$1$[ebp], esi
	mov	DWORD PTR _idx_offset$1$[ebp], esi
	mov	DWORD PTR _n$1$[ebp], ecx
	cmp	DWORD PTR [ebx+8], ecx
	jle	$LN18@ImGui_Impl
	npad	4
$LL19@ImGui_Impl:

; 282  :   {
; 283  :     const ImDrawList* cmd_list =
; 284  :       draw_data->CmdLists [n];

	mov	eax, DWORD PTR [ebx+4]

; 285  : 
; 286  :     for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)

	mov	DWORD PTR _cmd_i$1$[ebp], 0
	mov	ebx, DWORD PTR [eax+ecx*4]
	cmp	DWORD PTR [ebx], 0
	jle	$LN21@ImGui_Impl

; 282  :   {
; 283  :     const ImDrawList* cmd_list =
; 284  :       draw_data->CmdLists [n];

	xor	ecx, ecx
	mov	DWORD PTR tv1826[ebp], ecx
	npad	5
$LL22@ImGui_Impl:

; 285  : 
; 286  :     for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)

	mov	edi, DWORD PTR [ebx+8]
	add	edi, ecx

; 287  :     {
; 288  :       const ImDrawCmd* pcmd =
; 289  :         &cmd_list->CmdBuffer [cmd_i];
; 290  : 
; 291  :       if (pcmd->UserCallback)

	mov	eax, DWORD PTR [edi+24]
	test	eax, eax
	je	SHORT $LN41@ImGui_Impl

; 292  :       {
; 293  :         pcmd->UserCallback (cmd_list, pcmd);

	push	edi
	push	ebx
	call	eax
	add	esp, 8

; 294  :       }
; 295  : 
; 296  :       else

	jmp	SHORT $LN42@ImGui_Impl
$LN41@ImGui_Impl:

; 297  :       {
; 298  :         const RECT r = {
; 299  :           static_cast <LONG> (pcmd->ClipRect.x), static_cast <LONG> (pcmd->ClipRect.y),

	xor	ecx, ecx
	lea	edx, DWORD PTR [edi+4]
	npad	6
$LL109@ImGui_Impl:
	cvttss2si eax, DWORD PTR [edx]
	lea	edx, DWORD PTR [edx+4]
	mov	DWORD PTR _r$3[ebp+ecx*4], eax
	inc	ecx
	cmp	ecx, 4
	jl	SHORT $LL109@ImGui_Impl

; 300  :           static_cast <LONG> (pcmd->ClipRect.z), static_cast <LONG> (pcmd->ClipRect.w)
; 301  :         };
; 302  : 
; 303  :         g_pd3dDevice->SetTexture           ( 0, (LPDIRECT3DTEXTURE9)pcmd->TextureId );

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	DWORD PTR [edi+20]
	push	0
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+260]

; 304  :         g_pd3dDevice->SetScissorRect       ( &r );

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	lea	edx, DWORD PTR _r$3[ebp]
	push	edx
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+300]

; 305  :         g_pd3dDevice->DrawIndexedPrimitive ( D3DPT_TRIANGLELIST,

	mov	ecx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	mov	eax, -1431655765			; aaaaaaabH
	mul	DWORD PTR [edi]
	mov	esi, DWORD PTR [ecx]
	shr	edx, 1
	push	edx
	push	DWORD PTR _idx_offset$1$[ebp]
	push	DWORD PTR [ebx+24]
	push	0
	push	DWORD PTR _vtx_offset$1$[ebp]
	push	4
	push	ecx
	call	DWORD PTR [esi+328]
$LN42@ImGui_Impl:

; 306  :                                                vtx_offset,
; 307  :                                                  0,
; 308  :                                static_cast <UINT> (cmd_list->VtxBuffer.Size),
; 309  :                                                      idx_offset,
; 310  :                                                        pcmd->ElemCount / 3 );
; 311  :       }
; 312  : 
; 313  :       idx_offset += pcmd->ElemCount;

	mov	eax, DWORD PTR _cmd_i$1$[ebp]
	mov	edx, DWORD PTR _idx_offset$1$[ebp]
	inc	eax
	mov	ecx, DWORD PTR tv1826[ebp]
	add	edx, DWORD PTR [edi]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR _idx_offset$1$[ebp], edx
	mov	DWORD PTR _cmd_i$1$[ebp], eax
	mov	DWORD PTR tv1826[ebp], ecx
	cmp	eax, DWORD PTR [ebx]
	jl	$LL22@ImGui_Impl
	mov	esi, DWORD PTR _vtx_offset$1$[ebp]
	mov	ecx, DWORD PTR _n$1$[ebp]
$LN21@ImGui_Impl:

; 314  :     }
; 315  : 
; 316  :     vtx_offset += cmd_list->VtxBuffer.Size;

	add	esi, DWORD PTR [ebx+24]
	inc	ecx
	mov	ebx, DWORD PTR _draw_data$[ebp]
	mov	DWORD PTR _vtx_offset$1$[ebp], esi
	mov	DWORD PTR _n$1$[ebp], ecx
	cmp	ecx, DWORD PTR [ebx+8]
	jl	$LL19@ImGui_Impl
$LN18@ImGui_Impl:

; 317  :   }
; 318  : 
; 319  :   for (UINT target = 0; target < caps.NumSimultaneousRTs; target++)

	xor	esi, esi
	cmp	DWORD PTR _caps$[ebp+240], esi
	jbe	SHORT $LN24@ImGui_Impl
	npad	8
$LL25@ImGui_Impl:

; 320  :     g_pd3dDevice->SetRenderTarget (target, rts [target]);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	DWORD PTR _rts$[ebp+esi*4]
	push	esi
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+148]
	inc	esi
	cmp	esi, DWORD PTR _caps$[ebp+240]
	jb	SHORT $LL25@ImGui_Impl
$LN24@ImGui_Impl:

; 321  : 
; 322  :   g_pd3dDevice->SetDepthStencilSurface (pDS);

	mov	eax, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	push	DWORD PTR _pDS$[ebp]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+156]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	mov	eax, DWORD PTR _pDS$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp

; 327  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN75@ImGui_Impl

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN75@ImGui_Impl:
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp

; 327  : }

	push	OFFSET ??1?$CComPtr@UIDirect3DSurface9@@@ATL@@QAE@XZ
	push	32					; 00000020H
	push	4
	lea	eax, DWORD PTR _rts$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	mov	eax, DWORD PTR _pBackBuffer$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp

; 327  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN185@ImGui_Impl

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN185@ImGui_Impl:
	pop	ebx
$LN27@ImGui_Impl:
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp

; 327  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ImGui_ImplDX9_RenderDrawLists@@YAXPAUImDrawData@@@Z$0:
	lea	ecx, DWORD PTR _pBackBuffer$[ebp]
	jmp	??1?$CComPtr@UIDirect3DSurface9@@@ATL@@QAE@XZ
__unwindfunclet$?ImGui_ImplDX9_RenderDrawLists@@YAXPAUImDrawData@@@Z$1:
	push	OFFSET ??1?$CComPtr@UIDirect3DSurface9@@@ATL@@QAE@XZ
	push	32					; 00000020H
	push	4
	lea	eax, DWORD PTR _rts$[ebp]
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	ret	0
__unwindfunclet$?ImGui_ImplDX9_RenderDrawLists@@YAXPAUImDrawData@@@Z$2:
	lea	ecx, DWORD PTR _pDS$[ebp]
	jmp	??1?$CComPtr@UIDirect3DSurface9@@@ATL@@QAE@XZ
__ehhandler$?ImGui_ImplDX9_RenderDrawLists@@YAXPAUImDrawData@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ImGui_ImplDX9_RenderDrawLists@@YAXPAUImDrawData@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ImGui_ImplDX9_RenderDrawLists@@YAXPAUImDrawData@@@Z ENDP ; ImGui_ImplDX9_RenderDrawLists
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
;	COMDAT ??__F_AtlWinModule@ATL@@YAXXZ
text$yd	SEGMENT
??__F_AtlWinModule@ATL@@YAXXZ PROC			; ATL::`dynamic atexit destructor for '_AtlWinModule'', COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2964 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

	push	DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+4
	push	OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
	call	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 216  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32
	test	eax, eax
	je	SHORT $LN29@dynamic

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 221  : 			m_aT = NULL;

	mov	DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32, 0
$LN29@dynamic:

; 222  : 		}
; 223  : 		m_nSize = 0;
; 224  : 		m_nAllocSize = 0;

	mov	DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+40, 0
	mov	DWORD PTR ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+36, 0
	ret	0
??__F_AtlWinModule@ATL@@YAXXZ ENDP			; ATL::`dynamic atexit destructor for '_AtlWinModule''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ??__E_AtlWinModule@ATL@@YAXXZ
text$di	SEGMENT
??__E_AtlWinModule@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for '_AtlWinModule'', COMDAT

; 2979 : __declspec(selectany) CAtlWinModule _AtlWinModule;

	mov	ecx, OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
	call	??0CAtlWinModule@ATL@@QAE@XZ		; ATL::CAtlWinModule::CAtlWinModule
	push	OFFSET ??__F_AtlWinModule@ATL@@YAXXZ	; ATL::`dynamic atexit destructor for '_AtlWinModule''
	call	_atexit
	pop	ecx
	ret	0
??__E_AtlWinModule@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for '_AtlWinModule''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ?Term@CAtlWinModule@ATL@@QAEXXZ
_TEXT	SEGMENT
?Term@CAtlWinModule@ATL@@QAEXXZ PROC			; ATL::CAtlWinModule::Term, COMDAT
; _this$ = ecx

; 2964 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

	push	DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+4
	push	ecx
	call	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm

; 2965 : 	}

	ret	0
?Term@CAtlWinModule@ATL@@QAEXXZ ENDP			; ATL::CAtlWinModule::Term
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ??1CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
??1CAtlWinModule@ATL@@QAE@XZ PROC			; ATL::CAtlWinModule::~CAtlWinModule, COMDAT
; _this$ = ecx

; 2958 : 	{

	npad	2
	push	esi

; 2964 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

	push	DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+4

; 2958 : 	{

	mov	esi, ecx

; 2964 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

	push	esi
	call	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 216  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN26@CAtlWinMod

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 221  : 			m_aT = NULL;

	mov	DWORD PTR [esi+32], 0
$LN26@CAtlWinMod:

; 222  : 		}
; 223  : 		m_nSize = 0;
; 224  : 		m_nAllocSize = 0;

	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+36], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2960 : 	}

	ret	0
??1CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::~CAtlWinModule
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CAtlWinModule@ATL@@QAE@XZ PROC			; ATL::CAtlWinModule::CAtlWinModule, COMDAT
; _this$ = ecx

; 2944 : 	CAtlWinModule()

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 151  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	movups	XMMWORD PTR [esi+4], xmm0
	lea	eax, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2944 : 	CAtlWinModule()

	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 151  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	movq	QWORD PTR [eax+16], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	0
	push	0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 119  : 		m_aT(NULL), m_nSize(0), m_nAllocSize(0)

	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2946 : 		cbSize = sizeof(_ATL_WIN_MODULE);

	mov	DWORD PTR [esi], 44			; 0000002cH

; 8412 : 	pWinModule->m_pCreateWndList = NULL;

	mov	DWORD PTR [esi+28], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	call	DWORD PTR __imp__InitializeCriticalSectionEx@12
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 171  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

	test	eax, eax
	jne	SHORT $LN26@CAtlWinMod

; 172  : 		{
; 173  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

	call	DWORD PTR __imp__GetLastError@0
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	test	eax, eax
	jle	SHORT $LN27@CAtlWinMod
	movzx	eax, ax
	or	eax, -2147024896			; 80070000H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2948 : 		if (FAILED(hr))

	test	eax, eax
$LN27@CAtlWinMod:

; 2953 : 			return;
; 2954 : 		}
; 2955 : 	}

	mov	eax, esi

; 2948 : 		if (FAILED(hr))

	jns	SHORT $LN2@CAtlWinMod

; 2949 : 		{
; 2950 : 			ATLASSERT(0);
; 2951 : 			CAtlBaseModule::m_bInitFailed = true;

	mov	BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed

; 2952 : 			cbSize = 0;

	mov	DWORD PTR [esi], 0
	pop	esi

; 2953 : 			return;
; 2954 : 		}
; 2955 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN26@CAtlWinMod:
	mov	eax, esi
$LN2@CAtlWinMod:
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??0CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::CAtlWinModule
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ??__F_AtlComModule@ATL@@YAXXZ
text$yd	SEGMENT
__$EHRec$ = -12						; size = 12
??__F_AtlComModule@ATL@@YAXXZ PROC			; ATL::`dynamic atexit destructor for '_AtlComModule'', COMDAT
	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??__F_AtlComModule@ATL@@YAXXZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 2615 : 		Term();

	mov	ecx, OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?Term@CAtlComModule@ATL@@QAEXXZ		; ATL::CAtlComModule::Term

; 2616 : 	}

	mov	ecx, OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
	call	??1_ATL_COM_MODULE70@ATL@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
text$yd	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??__F_AtlComModule@ATL@@YAXXZ:
	mov	eax, OFFSET __ehfuncinfo$??__F_AtlComModule@ATL@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??__F_AtlComModule@ATL@@YAXXZ ENDP			; ATL::`dynamic atexit destructor for '_AtlComModule''
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ??__E_AtlComModule@ATL@@YAXXZ
text$di	SEGMENT
??__E_AtlComModule@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for '_AtlComModule'', COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	0
	push	0
	push	OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A+16
	call	DWORD PTR __imp__InitializeCriticalSectionEx@12
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 171  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

	test	eax, eax
	jne	SHORT $LN4@dynamic

; 172  : 		{
; 173  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

	call	DWORD PTR __imp__GetLastError@0
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	test	eax, eax
	jle	SHORT $LN20@dynamic
	movzx	eax, ax
	or	eax, -2147024896			; 80070000H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2602 : 		if (FAILED(m_csObjMap.Init()))

	test	eax, eax
$LN20@dynamic:
	jns	SHORT $LN4@dynamic

; 2723 : __declspec(selectany) CAtlComModule _AtlComModule;

	push	OFFSET ??__F_AtlComModule@ATL@@YAXXZ	; ATL::`dynamic atexit destructor for '_AtlComModule''

; 2606 : 			CAtlBaseModule::m_bInitFailed = true;

	mov	BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed

; 2723 : __declspec(selectany) CAtlComModule _AtlComModule;

	call	_atexit
	pop	ecx
	ret	0
$LN4@dynamic:
	push	OFFSET ??__F_AtlComModule@ATL@@YAXXZ	; ATL::`dynamic atexit destructor for '_AtlComModule''

; 2610 : 		cbSize = sizeof(_ATL_COM_MODULE);

	mov	DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A, 40 ; 00000028H

; 2723 : __declspec(selectany) CAtlComModule _AtlComModule;

	call	_atexit
	pop	ecx
	ret	0
??__E_AtlComModule@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for '_AtlComModule''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ?Term@CAtlComModule@ATL@@QAEXXZ
_TEXT	SEGMENT
?Term@CAtlComModule@ATL@@QAEXXZ PROC			; ATL::CAtlComModule::Term, COMDAT
; _this$ = ecx

; 2620 : 	{

	npad	2
	push	edi
	mov	edi, ecx

; 2621 : 		if (cbSize == 0)

	cmp	DWORD PTR [edi], 0
	je	SHORT $LN1@Term

; 2622 : 			return;
; 2623 : 
; 2624 : 		for (_ATL_OBJMAP_ENTRY_EX** ppEntry = m_ppAutoObjMapFirst; ppEntry < m_ppAutoObjMapLast; ppEntry++)

	push	esi
	mov	esi, DWORD PTR [edi+8]
	cmp	esi, DWORD PTR [edi+12]
	jae	SHORT $LN3@Term
	push	ebx
$LL4@Term:

; 2625 : 		{
; 2626 : 			if (*ppEntry != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN2@Term

; 2627 : 			{
; 2628 : 				_ATL_OBJMAP_CACHE* pCache = (**ppEntry).pCache;

	mov	ebx, DWORD PTR [eax+16]

; 2629 : 
; 2630 : 				if (pCache->pCF != NULL)

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN2@Term

; 2631 : 				{
; 2632 : 					// Decode factory pointer if it's not null
; 2633 : 					IUnknown *factory = reinterpret_cast<IUnknown*>(::DecodePointer(pCache->pCF));

	push	eax
	call	DWORD PTR __imp__DecodePointer@4

; 2634 : 					_Analysis_assume_(factory != nullptr);
; 2635 : 					factory->Release();

	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]

; 2636 : 					pCache->pCF = NULL;

	mov	DWORD PTR [ebx], 0
$LN2@Term:

; 2622 : 			return;
; 2623 : 
; 2624 : 		for (_ATL_OBJMAP_ENTRY_EX** ppEntry = m_ppAutoObjMapFirst; ppEntry < m_ppAutoObjMapLast; ppEntry++)

	add	esi, 4
	cmp	esi, DWORD PTR [edi+12]
	jb	SHORT $LL4@Term
	pop	ebx
$LN3@Term:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 181  : 		DeleteCriticalSection(&m_sec);

	lea	eax, DWORD PTR [edi+16]
	push	eax
	call	DWORD PTR __imp__DeleteCriticalSection@4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2644 : 		cbSize = 0;

	mov	DWORD PTR [edi], 0
	pop	esi
$LN1@Term:
	pop	edi

; 2645 : 	}

	ret	0
?Term@CAtlComModule@ATL@@QAEXXZ ENDP			; ATL::CAtlComModule::Term
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ??1CAtlComModule@ATL@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1CAtlComModule@ATL@@QAE@XZ PROC			; ATL::CAtlComModule::~CAtlComModule, COMDAT
; _this$ = ecx

; 2614 : 	{

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1CAtlComModule@ATL@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp

; 2615 : 		Term();

	call	?Term@CAtlComModule@ATL@@QAEXXZ		; ATL::CAtlComModule::Term

; 2616 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CAtlComModule@ATL@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CAtlComModule@ATL@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CAtlComModule@ATL@@QAE@XZ ENDP			; ATL::CAtlComModule::~CAtlComModule
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ??0CAtlComModule@ATL@@QAE@XZ
_TEXT	SEGMENT
??0CAtlComModule@ATL@@QAE@XZ PROC			; ATL::CAtlComModule::CAtlComModule, COMDAT
; _this$ = ecx

; 2593 : 	CAtlComModule() throw()

	npad	2
	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0
	lea	eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 151  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	movups	XMMWORD PTR [eax], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 151  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	movq	QWORD PTR [eax+16], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	0
	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2595 : 		cbSize = 0;

	mov	DWORD PTR [esi], 0

; 2596 : 
; 2597 : 		m_hInstTypeLib = reinterpret_cast<HINSTANCE>(&__ImageBase);

	mov	DWORD PTR [esi+4], OFFSET ___ImageBase

; 2598 : 
; 2599 : 		m_ppAutoObjMapFirst = &__pobjMapEntryFirst + 1;

	mov	DWORD PTR [esi+8], OFFSET ___pobjMapEntryFirst+4

; 2600 : 		m_ppAutoObjMapLast = &__pobjMapEntryLast;

	mov	DWORD PTR [esi+12], OFFSET ___pobjMapEntryLast
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	call	DWORD PTR __imp__InitializeCriticalSectionEx@12
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 171  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

	test	eax, eax
	jne	SHORT $LN2@CAtlComMod

; 172  : 		{
; 173  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

	call	DWORD PTR __imp__GetLastError@0
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	test	eax, eax
	jle	SHORT $LN18@CAtlComMod
	movzx	eax, ax
	or	eax, -2147024896			; 80070000H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 2602 : 		if (FAILED(m_csObjMap.Init()))

	test	eax, eax
$LN18@CAtlComMod:
	jns	SHORT $LN2@CAtlComMod

; 2611 : 	}

	mov	eax, esi
	mov	BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed
	pop	esi
	ret	0
$LN2@CAtlComMod:

; 2603 : 		{
; 2604 : 			ATLTRACE(atlTraceCOM, 0, _T("ERROR : Unable to initialize critical section in CAtlComModule\n"));
; 2605 : 			ATLASSERT(0);
; 2606 : 			CAtlBaseModule::m_bInitFailed = true;
; 2607 : 			return;
; 2608 : 		}
; 2609 : 		// Set cbSize on success.
; 2610 : 		cbSize = sizeof(_ATL_COM_MODULE);

	mov	DWORD PTR [esi], 40			; 00000028H

; 2611 : 	}

	mov	eax, esi
	pop	esi
	ret	0
??0CAtlComModule@ATL@@QAE@XZ ENDP			; ATL::CAtlComModule::CAtlComModule
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z
_TEXT	SEGMENT
_pWinModule$ = 8					; size = 4
_hInst$ = 12						; size = 4
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z PROC ; ATL::AtlWinModuleTerm, COMDAT

; 7660 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	esi

; 7661 : 	if (pWinModule == NULL)

	mov	esi, DWORD PTR _pWinModule$[ebp]
	test	esi, esi
	jne	SHORT $LN5@AtlWinModu
$LN35@AtlWinModu:

; 7662 : 		return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	pop	esi

; 7674 : }

	pop	ebp
	ret	8
$LN5@AtlWinModu:

; 7663 : 	if (pWinModule->cbSize == 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN34@AtlWinModu

; 7664 : 		return S_OK;
; 7665 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN35@AtlWinModu

; 7666 : 		return E_INVALIDARG;
; 7667 : 
; 7668 : 	for (int i = 0; i < pWinModule->m_rgWindowClassAtoms.GetSize(); i++)

	push	edi
	xor	edi, edi
	cmp	DWORD PTR [esi+36], edi
	jle	SHORT $LN3@AtlWinModu

; 7669 : 		UnregisterClass((LPCTSTR)pWinModule->m_rgWindowClassAtoms[i], hInst);

	push	ebx
	mov	ebx, DWORD PTR _hInst$[ebp]
	npad	2
$LL4@AtlWinModu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 238  : 		if(nIndex < 0 || nIndex >= m_nSize)

	test	edi, edi
	js	SHORT $LN36@AtlWinModu
	cmp	edi, DWORD PTR [esi+36]
	jge	SHORT $LN36@AtlWinModu
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 7669 : 		UnregisterClass((LPCTSTR)pWinModule->m_rgWindowClassAtoms[i], hInst);

	mov	eax, DWORD PTR [esi+32]
	push	ebx
	movzx	eax, WORD PTR [eax+edi*2]
	push	eax
	call	DWORD PTR __imp__UnregisterClassW@8
	inc	edi
	cmp	edi, DWORD PTR [esi+36]
	jl	SHORT $LL4@AtlWinModu
	pop	ebx
$LN3@AtlWinModu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 216  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR [esi+32]
	pop	edi
	test	eax, eax
	je	SHORT $LN20@AtlWinModu

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 221  : 			m_aT = NULL;

	mov	DWORD PTR [esi+32], 0
$LN20@AtlWinModu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 181  : 		DeleteCriticalSection(&m_sec);

	lea	eax, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 223  : 		m_nSize = 0;

	mov	DWORD PTR [esi+36], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 181  : 		DeleteCriticalSection(&m_sec);

	push	eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 224  : 		m_nAllocSize = 0;

	mov	DWORD PTR [esi+40], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 181  : 		DeleteCriticalSection(&m_sec);

	call	DWORD PTR __imp__DeleteCriticalSection@4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 7672 : 	pWinModule->cbSize = 0;

	mov	DWORD PTR [esi], 0
$LN34@AtlWinModu:

; 7673 : 	return S_OK;

	xor	eax, eax
	pop	esi

; 7674 : }

	pop	ebp
	ret	8
$LN36@AtlWinModu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 240  : 			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);

	push	1
	push	-1073741684				; c000008cH
	call	?_AtlRaiseException@ATL@@YAXKK@Z	; ATL::_AtlRaiseException
$LN37@AtlWinModu:
$LN33@AtlWinModu:
	int	3
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ENDP ; ATL::AtlWinModuleTerm
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z
_TEXT	SEGMENT
_pWinModule$ = 8					; size = 4
?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z PROC ; ATL::AtlWinModuleInit, COMDAT

; 8404 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 8405 : 	if (pWinModule == NULL)

	mov	eax, DWORD PTR _pWinModule$[ebp]
	test	eax, eax
	jne	SHORT $LN2@AtlWinModu
$LN15@AtlWinModu:

; 8406 : 		return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H

; 8421 : }

	pop	ebp
	ret	4
$LN2@AtlWinModu:

; 8407 : 
; 8408 : 	// check only in the DLL
; 8409 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

	cmp	DWORD PTR [eax], 44			; 0000002cH
	jne	SHORT $LN15@AtlWinModu
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 170  : 		HRESULT hRes = S_OK;

	xor	esi, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 8412 : 	pWinModule->m_pCreateWndList = NULL;

	mov	DWORD PTR [eax+28], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	esi
	push	esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 171  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

	add	eax, 4
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	eax
	call	DWORD PTR __imp__InitializeCriticalSectionEx@12
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 171  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

	test	eax, eax
	jne	SHORT $LN14@AtlWinModu

; 172  : 		{
; 173  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

	call	DWORD PTR __imp__GetLastError@0
	mov	esi, eax
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	test	esi, esi
	jle	SHORT $LN14@AtlWinModu
	movzx	esi, si
	or	esi, -2147024896			; 80070000H
$LN14@AtlWinModu:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlbase.h

; 8420 : 	return hr;

	mov	eax, esi
	pop	esi

; 8421 : }

	pop	ebp
	ret	4
?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ENDP ; ATL::AtlWinModuleInit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
;	COMDAT ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
	npad	2
	push	esi
	mov	esi, ecx

; 216  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN19@ATL_WIN_MO

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 221  : 			m_aT = NULL;

	mov	DWORD PTR [esi+32], 0
$LN19@ATL_WIN_MO:

; 222  : 		}
; 223  : 		m_nSize = 0;
; 224  : 		m_nAllocSize = 0;

	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+36], 0
	pop	esi
	ret	0
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
;	COMDAT ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx
	xorps	xmm0, xmm0
	mov	DWORD PTR _this$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 151  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	movups	XMMWORD PTR [ecx+4], xmm0
	mov	eax, ecx
	movq	QWORD PTR [ecx+20], xmm0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h

; 119  : 		m_aT(NULL), m_nSize(0), m_nAllocSize(0)

	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+40], 0
	mov	esp, ebp
	pop	ebp
	ret	0
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
;	COMDAT ??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[], COMDAT
; _this$ = ecx

; 236  : 	{

	npad	2
	push	ebp
	mov	ebp, esp

; 237  : 		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
; 238  : 		if(nIndex < 0 || nIndex >= m_nSize)

	mov	edx, DWORD PTR _nIndex$[ebp]
	test	edx, edx
	js	SHORT $LN6@operator
	cmp	edx, DWORD PTR [ecx+4]
	jge	SHORT $LN6@operator

; 241  : 		}
; 242  : 		return m_aT[nIndex];

	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*2]

; 243  : 	}

	pop	ebp
	ret	4
$LN6@operator:

; 239  : 		{
; 240  : 			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);

	push	1
	push	-1073741684				; c000008cH
	call	?_AtlRaiseException@ATL@@YAXKK@Z	; ATL::_AtlRaiseException
$LN7@operator:
$LN5@operator:
	int	3
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll, COMDAT
; _this$ = ecx

; 215  : 	{

	npad	2
	push	esi
	mov	esi, ecx

; 216  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN11@RemoveAll

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 221  : 			m_aT = NULL;

	mov	DWORD PTR [esi], 0
$LN11@RemoveAll:

; 222  : 		}
; 223  : 		m_nSize = 0;
; 224  : 		m_nAllocSize = 0;

	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+4], 0
	pop	esi

; 225  :     }

	ret	0
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
;	COMDAT ?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ
_TEXT	SEGMENT
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize, COMDAT
; _this$ = ecx

; 161  : 		return m_nSize;

	mov	eax, DWORD PTR [ecx+4]

; 162  : 	}

	ret	0
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
;	COMDAT ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 310  : {

	npad	2
	push	esi
	mov	esi, ecx

; 216  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN13@CSimpleArr

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 221  : 			m_aT = NULL;

	mov	DWORD PTR [esi], 0
$LN13@CSimpleArr:

; 222  : 		}
; 223  : 		m_nSize = 0;
; 224  : 		m_nAllocSize = 0;

	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+4], 0
	pop	esi

; 311  : 	RemoveAll();
; 312  : }

	ret	0
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlsimpcoll.h
;	COMDAT ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 119  : 		m_aT(NULL), m_nSize(0), m_nAllocSize(0)

	mov	DWORD PTR [ecx], 0

; 121  : 	}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1_ATL_COM_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
??1_ATL_COM_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70, COMDAT
; _this$ = ecx
	ret	0
??1_ATL_COM_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_COM_MODULE70::~_ATL_COM_MODULE70
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
;	COMDAT ??0_ATL_COM_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
??0_ATL_COM_MODULE70@ATL@@QAE@XZ PROC			; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70, COMDAT
; _this$ = ecx
	xorps	xmm0, xmm0
	mov	eax, ecx

; 151  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	movups	XMMWORD PTR [ecx+16], xmm0
	movq	QWORD PTR [ecx+32], xmm0
	ret	0
??0_ATL_COM_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_COM_MODULE70::_ATL_COM_MODULE70
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
;	COMDAT ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ PROC ; ATL::CAtlBaseModule::GetModuleInstance, COMDAT
; _this$ = ecx

; 316  : 		return m_hInst;

	mov	eax, DWORD PTR [ecx+4]

; 317  : 	}

	ret	0
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ENDP ; ATL::CAtlBaseModule::GetModuleInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
;	COMDAT ?Term@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
?Term@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Term, COMDAT
; _this$ = ecx

; 180  : 	{

	npad	2

; 181  : 		DeleteCriticalSection(&m_sec);

	push	ecx
	call	DWORD PTR __imp__DeleteCriticalSection@4

; 182  : 		return S_OK;

	xor	eax, eax

; 183  : 	}

	ret	0
?Term@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Term
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
;	COMDAT ?Init@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
?Init@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Init, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	0
	push	0
	push	ecx
	call	DWORD PTR __imp__InitializeCriticalSectionEx@12
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 171  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

	test	eax, eax
	jne	SHORT $LN10@Init

; 172  : 		{
; 173  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

	call	DWORD PTR __imp__GetLastError@0
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	test	eax, eax
	jle	SHORT $LN9@Init
	movzx	eax, ax
	or	eax, -2147024896			; 80070000H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h

; 177  : 	}

	ret	0
$LN10@Init:

; 174  : 		}
; 175  : 
; 176  : 		return hRes;

	xor	eax, eax
$LN9@Init:

; 177  : 	}

	ret	0
?Init@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
;	COMDAT ??1CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
??1CComCriticalSection@ATL@@QAE@XZ PROC			; ATL::CComCriticalSection::~CComCriticalSection, COMDAT
; _this$ = ecx

; 156  : 	}

	ret	0
??1CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::~CComCriticalSection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcore.h
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
??0CComCriticalSection@ATL@@QAE@XZ PROC			; ATL::CComCriticalSection::CComCriticalSection, COMDAT
; _this$ = ecx

; 149  : 	CComCriticalSection() throw()

	xorps	xmm0, xmm0

; 150  : 	{
; 151  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));
; 152  : 	}

	mov	eax, ecx
	movups	XMMWORD PTR [ecx], xmm0
	movq	QWORD PTR [ecx+16], xmm0
	ret	0
??0CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::CComCriticalSection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlwinverapi.h
;	COMDAT ?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z
_TEXT	SEGMENT
_lpCriticalSection$ = 8					; size = 4
_dwSpinCount$ = 12					; size = 4
_Flags$ = 16						; size = 4
?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z PROC ; ATL::_AtlInitializeCriticalSectionEx, COMDAT

; 727  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 728  : #if (NTDDI_VERSION >= NTDDI_VISTA) && !defined(_USING_V110_SDK71_) && !defined(_ATL_XP_TARGETING)
; 729  : 	// InitializeCriticalSectionEx is available in Vista or later, desktop or store apps
; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

	push	DWORD PTR _Flags$[ebp]
	push	DWORD PTR _dwSpinCount$[ebp]
	push	DWORD PTR _lpCriticalSection$[ebp]
	call	DWORD PTR __imp__InitializeCriticalSectionEx@12

; 731  : #else
; 732  : 	UNREFERENCED_PARAMETER(Flags);
; 733  : 
; 734  : 	// ...otherwise fall back to using InitializeCriticalSectionAndSpinCount.
; 735  : 	return ::InitializeCriticalSectionAndSpinCount(lpCriticalSection, dwSpinCount);
; 736  : #endif
; 737  : }

	pop	ebp
	ret	0
?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ENDP ; ATL::_AtlInitializeCriticalSectionEx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlexcept.h
;	COMDAT ?_AtlRaiseException@ATL@@YAXKK@Z
_TEXT	SEGMENT
_dwExceptionCode$ = 8					; size = 4
_dwExceptionFlags$ = 12					; size = 4
?_AtlRaiseException@ATL@@YAXKK@Z PROC			; ATL::_AtlRaiseException, COMDAT

; 30   : {

	npad	2
	push	ebp
	mov	ebp, esp

; 31   : 	RaiseException( dwExceptionCode, dwExceptionFlags, 0, NULL );

	push	0
	push	0
	push	DWORD PTR _dwExceptionFlags$[ebp]
	push	DWORD PTR _dwExceptionCode$[ebp]
	call	DWORD PTR __imp__RaiseException@16

; 32   : }

	pop	ebp
	ret	0
?_AtlRaiseException@ATL@@YAXKK@Z ENDP			; ATL::_AtlRaiseException
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z PROC ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0EAAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP ; ATL::CTraceCategoryEx<4194304,0>::CTraceCategoryEx<4194304,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z PROC ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0CAAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP ; ATL::CTraceCategoryEx<2097152,0>::CTraceCategoryEx<2097152,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z PROC ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0BAAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP ; ATL::CTraceCategoryEx<1048576,0>::CTraceCategoryEx<1048576,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0EAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<262144,0>::CTraceCategoryEx<262144,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0CAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<131072,0>::CTraceCategoryEx<131072,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0BAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<65536,0>::CTraceCategoryEx<65536,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0IAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<32768,0>::CTraceCategoryEx<32768,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0EAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<16384,0>::CTraceCategoryEx<16384,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0BAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<4096,0>::CTraceCategoryEx<4096,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0IAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<2048,0>::CTraceCategoryEx<2048,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0EAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<1024,0>::CTraceCategoryEx<1024,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0CAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<512,0>::CTraceCategoryEx<512,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0BAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<256,0>::CTraceCategoryEx<256,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0IA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<128,0>::CTraceCategoryEx<128,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0EA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<64,0>::CTraceCategoryEx<64,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0CA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<32,0>::CTraceCategoryEx<32,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0BA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<16,0>::CTraceCategoryEx<16,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$07$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<8,0>::CTraceCategoryEx<8,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$03$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<4,0>::CTraceCategoryEx<4,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$01$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<2,0>::CTraceCategoryEx<2,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$00$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<1,0>::CTraceCategoryEx<1,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>, COMDAT
; _this$ = ecx

; 496  : 	(void)pszCategoryName;
; 497  : }

	mov	eax, ecx
	ret	4
??0?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<524288,0>::CTraceCategoryEx<524288,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp
_TEXT	SEGMENT
?ImGui_ImplDX9_CreateDeviceObjects@@YA_NXZ PROC		; ImGui_ImplDX9_CreateDeviceObjects

; 469  :   if (! g_pd3dDevice)

	cmp	DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A, 0 ; g_pd3dDevice
	jne	SHORT $LN2@ImGui_Impl

; 470  :       return false;

	xor	al, al

; 473  :       return false;
; 474  : 
; 475  :   return true;
; 476  : }

	ret	0
$LN2@ImGui_Impl:

; 471  : 
; 472  :   if (! ImGui_ImplDX9_CreateFontsTexture ())

	call	?ImGui_ImplDX9_CreateFontsTexture@@YA_NXZ ; ImGui_ImplDX9_CreateFontsTexture
	test	al, al
	setne	al

; 473  :       return false;
; 474  : 
; 475  :   return true;
; 476  : }

	ret	0
?ImGui_ImplDX9_CreateDeviceObjects@@YA_NXZ ENDP		; ImGui_ImplDX9_CreateDeviceObjects
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 8
$T2 = -8						; size = 8
_pparams$ = 8						; size = 4
?ImGui_ImplDX9_InvalidateDeviceObjects@@YAXPAU_D3DPRESENT_PARAMETERS_@@@Z PROC ; ImGui_ImplDX9_InvalidateDeviceObjects

; 480  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 481  :   extern void
; 482  :   SK_ImGui_ResetExternal (void);
; 483  :   SK_ImGui_ResetExternal ();

	call	?SK_ImGui_ResetExternal@@YAXXZ		; SK_ImGui_ResetExternal

; 484  : 
; 485  :   if (! g_pd3dDevice)

	cmp	DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A, 0 ; g_pd3dDevice
	je	$LN6@ImGui_Impl

; 486  :     return;
; 487  : 
; 488  :   ImGuiIO& io (ImGui::GetIO ());

	push	esi
	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO

; 489  : 
; 490  :   if (g_pVB)

	mov	edx, DWORD PTR ?g_pVB@@3PAUIDirect3DVertexBuffer9@@A
	mov	esi, eax
	test	edx, edx
	je	SHORT $LN3@ImGui_Impl

; 491  :   {
; 492  :     g_pVB->Release ();

	mov	ecx, DWORD PTR [edx]
	push	edx
	call	DWORD PTR [ecx+8]

; 493  :     g_pVB = NULL;

	mov	DWORD PTR ?g_pVB@@3PAUIDirect3DVertexBuffer9@@A, 0
$LN3@ImGui_Impl:

; 494  :   }
; 495  : 
; 496  :   if (g_pIB)

	mov	ecx, DWORD PTR ?g_pIB@@3PAUIDirect3DIndexBuffer9@@A
	test	ecx, ecx
	je	SHORT $LN4@ImGui_Impl

; 497  :   {
; 498  :     g_pIB->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 499  :     g_pIB = NULL;

	mov	DWORD PTR ?g_pIB@@3PAUIDirect3DIndexBuffer9@@A, 0
$LN4@ImGui_Impl:

; 500  :   }
; 501  : 
; 502  :   if ( LPDIRECT3DTEXTURE9 tex = (LPDIRECT3DTEXTURE9)io.Fonts->TexID )

	mov	eax, DWORD PTR [esi+128]
	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@ImGui_Impl

; 503  :   {
; 504  :     tex->Release ();

	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]

; 505  :     io.Fonts->TexID = 0;

	mov	eax, DWORD PTR [esi+128]
	mov	DWORD PTR [eax], 0
$LN5@ImGui_Impl:

; 506  :   }
; 507  : 
; 508  :   g_FontTexture = NULL;
; 509  : 
; 510  : 
; 511  :   if ( pparams != nullptr )

	mov	ecx, DWORD PTR _pparams$[ebp]
	mov	DWORD PTR ?g_FontTexture@@3PAUIDirect3DTexture9@@A, 0
	test	ecx, ecx
	je	SHORT $LN12@ImGui_Impl

; 512  :   {
; 513  :     float width = static_cast <float> (pparams->BackBufferWidth),

	mov	eax, DWORD PTR [ecx]
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]

; 514  :          height = static_cast <float> (pparams->BackBufferHeight);

	mov	eax, DWORD PTR [ecx+4]
	cvtpd2ps xmm1, xmm0
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp

; 514  :          height = static_cast <float> (pparams->BackBufferHeight);

	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]

; 516  :     io.DisplayFramebufferScale = ImVec2 ( width, height );

	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR [esi+144], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp

; 514  :          height = static_cast <float> (pparams->BackBufferHeight);

	cvtpd2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T2[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp

; 516  :     io.DisplayFramebufferScale = ImVec2 ( width, height );

	mov	eax, DWORD PTR $T2[ebp+4]
	mov	DWORD PTR [esi+148], eax

; 517  :     io.DisplaySize             = ImVec2 ( width, height );

	mov	eax, DWORD PTR $T1[ebp]
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp

; 517  :     io.DisplaySize             = ImVec2 ( width, height );

	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR [esi+4], eax
$LN12@ImGui_Impl:
	pop	esi
$LN6@ImGui_Impl:

; 518  :   }
; 519  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ImGui_ImplDX9_InvalidateDeviceObjects@@YAXPAU_D3DPRESENT_PARAMETERS_@@@Z ENDP ; ImGui_ImplDX9_InvalidateDeviceObjects
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp
_TEXT	SEGMENT
_pp$2 = -104						; size = 56
_rect$ = -48						; size = 16
_current_time$ = -32					; size = 8
$T3 = -24						; size = 8
$T4 = -24						; size = 8
tv306 = -20						; size = 4
_pSwapChain$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?ImGui_ImplDX9_NewFrame@@YAXXZ PROC			; ImGui_ImplDX9_NewFrame

; 531  : {

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?ImGui_ImplDX9_NewFrame@@YAXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 92					; 0000005cH
	push	esi

; 532  :   ImGuiIO& io (ImGui::GetIO ());

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO

; 533  : 
; 534  :   if (! g_FontTexture)

	cmp	DWORD PTR ?g_FontTexture@@3PAUIDirect3DTexture9@@A, 0
	mov	esi, eax
	jne	SHORT $LN3@ImGui_Impl

; 535  :     ImGui_ImplDX9_CreateDeviceObjects ();

	call	?ImGui_ImplDX9_CreateDeviceObjects@@YA_NXZ ; ImGui_ImplDX9_CreateDeviceObjects
$LN3@ImGui_Impl:

; 536  : 
; 537  :   static HMODULE hModTBFix =

	mov	edx, DWORD PTR __tls_index
	mov	ecx, DWORD PTR fs:__tls_array
	mov	eax, DWORD PTR ?$TSS0@?1??ImGui_ImplDX9_NewFrame@@YAXXZ@4HA
	mov	ecx, DWORD PTR [ecx+edx*4]
	cmp	eax, DWORD PTR __Init_thread_epoch[ecx]
	jle	SHORT $LN2@ImGui_Impl
	push	OFFSET ?$TSS0@?1??ImGui_ImplDX9_NewFrame@@YAXXZ@4HA
	call	__Init_thread_header
	add	esp, 4
	cmp	DWORD PTR ?$TSS0@?1??ImGui_ImplDX9_NewFrame@@YAXXZ@4HA, -1
	jne	SHORT $LN2@ImGui_Impl

; 538  :     GetModuleHandle (L"tbfix.dll");

	push	OFFSET $SG174822
	call	DWORD PTR __imp__GetModuleHandleW@4
	push	OFFSET ?$TSS0@?1??ImGui_ImplDX9_NewFrame@@YAXXZ@4HA
	mov	DWORD PTR ?hModTBFix@?1??ImGui_ImplDX9_NewFrame@@YAXXZ@4PAUHINSTANCE__@@A, eax
	call	__Init_thread_footer
	add	esp, 4
$LN2@ImGui_Impl:

; 539  : 
; 540  : 
; 541  :   // Setup display size (every frame to accommodate for window resizing)
; 542  :   RECT rect;
; 543  :   GetClientRect (g_hWnd, &rect);

	lea	eax, DWORD PTR _rect$[ebp]
	push	eax
	push	DWORD PTR ?g_hWnd@@3PAUHWND__@@A
	call	DWORD PTR __imp__GetClientRect@8

; 545  :   io.DisplayFramebufferScale =

	mov	eax, DWORD PTR _rect$[ebp+8]
	sub	eax, DWORD PTR _rect$[ebp]
	movd	xmm1, eax
	mov	eax, DWORD PTR _rect$[ebp+12]
	sub	eax, DWORD PTR _rect$[ebp+4]
	cvtdq2ps xmm1, xmm1
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp

; 545  :   io.DisplayFramebufferScale =

	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR [esi+144], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T4[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp

; 545  :   io.DisplayFramebufferScale =

	mov	eax, DWORD PTR $T4[ebp+4]
	mov	DWORD PTR [esi+148], eax

; 546  :     ImVec2 ( static_cast <float> (rect.right  - rect.left),
; 547  :              static_cast <float> (rect.bottom - rect.top ) );
; 548  : 
; 549  : 
; 550  :   if (! g_pd3dDevice)

	mov	ecx, DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A ; g_pd3dDevice
	test	ecx, ecx
	je	$LN27@ImGui_Impl
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 162  :         p = lp;

	mov	DWORD PTR _pSwapChain$[ebp], 0
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp

; 556  :   if (SUCCEEDED (g_pd3dDevice->GetSwapChain ( 0, &pSwapChain )))

	mov	eax, DWORD PTR [ecx]
	lea	edx, DWORD PTR _pSwapChain$[ebp]
	push	edx
	push	0
	push	ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	DWORD PTR [eax+56]
	test	eax, eax
	js	$LN7@ImGui_Impl

; 557  :   {
; 558  :     D3DPRESENT_PARAMETERS pp = { };

	push	56					; 00000038H
	lea	eax, DWORD PTR _pp$2[ebp]
	push	0
	push	eax
	call	_memset

; 559  : 
; 560  :     if (SUCCEEDED (pSwapChain->GetPresentParameters (&pp)))

	mov	eax, DWORD PTR _pSwapChain$[ebp]
	lea	edx, DWORD PTR _pp$2[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+36]
	test	eax, eax
	js	SHORT $LN7@ImGui_Impl

; 561  :     {
; 562  :       if (pp.BackBufferWidth != 0 && pp.BackBufferHeight != 0)

	mov	eax, DWORD PTR _pp$2[ebp]
	test	eax, eax
	je	SHORT $LN7@ImGui_Impl
	mov	ecx, DWORD PTR _pp$2[ebp+4]
	test	ecx, ecx
	je	SHORT $LN7@ImGui_Impl

; 563  :       {
; 564  :         io.DisplaySize.x = static_cast <float> (pp.BackBufferWidth);

	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm1, xmm0
	movd	xmm0, ecx

; 565  :         io.DisplaySize.y = static_cast <float> (pp.BackBufferHeight);

	cvtdq2pd xmm0, xmm0
	shr	ecx, 31					; 0000001fH
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp

; 565  :         io.DisplaySize.y = static_cast <float> (pp.BackBufferHeight);

	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]

; 567  :         io.DisplayFramebufferScale = 

	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR [esi+144], eax
	movss	DWORD PTR [esi], xmm1
	cvtpd2ps xmm0, xmm0
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T3[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp

; 567  :         io.DisplayFramebufferScale = 

	mov	eax, DWORD PTR $T3[ebp+4]
	movss	DWORD PTR [esi+4], xmm0
	mov	DWORD PTR [esi+148], eax
$LN7@ImGui_Impl:

; 568  :           ImVec2 ( static_cast <float> (pp.BackBufferWidth),
; 569  :                    static_cast <float> (pp.BackBufferHeight) );
; 570  :       }
; 571  :     }
; 572  :   }
; 573  : 
; 574  :   // Setup time step
; 575  :   INT64 current_time;
; 576  : 
; 577  :   QueryPerformanceCounter_Original (

	lea	eax, DWORD PTR _current_time$[ebp]
	push	eax
	call	DWORD PTR ?QueryPerformanceCounter_Original@@3P6GHPAT_LARGE_INTEGER@@@ZA ; QueryPerformanceCounter_Original

; 578  :     reinterpret_cast <LARGE_INTEGER *> (&current_time)
; 579  :   );
; 580  : 
; 581  :   io.DeltaTime = static_cast <float> (current_time - g_Time) /

	mov	ecx, DWORD PTR _current_time$[ebp]
	sub	ecx, DWORD PTR ?g_Time@@3_JA
	mov	edx, DWORD PTR _current_time$[ebp+4]
	sbb	edx, DWORD PTR ?g_Time@@3_JA+4
	call	__ltod3
	mov	edx, DWORD PTR ?g_TicksPerSecond@@3_JA+4
	mov	ecx, DWORD PTR ?g_TicksPerSecond@@3_JA
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv306[ebp], xmm0
	call	__ltod3
	movss	xmm1, DWORD PTR tv306[ebp]
	cvtsd2ss xmm0, xmm0
	divss	xmm1, xmm0
	movss	DWORD PTR [esi+8], xmm1

; 582  :                  static_cast <float> (g_TicksPerSecond);
; 583  :   g_Time       =                      current_time;

	mov	eax, DWORD PTR _current_time$[ebp]
	mov	DWORD PTR ?g_Time@@3_JA, eax
	mov	eax, DWORD PTR _current_time$[ebp+4]
	mov	DWORD PTR ?g_Time@@3_JA+4, eax

; 584  : 
; 585  :   // Read keyboard modifiers inputs
; 586  :   io.KeyCtrl   = (io.KeysDown [VK_CONTROL]) != 0;

	cmp	BYTE PTR [esi+246], 0
	setne	al
	mov	BYTE PTR [esi+225], al

; 587  :   io.KeyShift  = (io.KeysDown [VK_SHIFT])   != 0;

	cmp	BYTE PTR [esi+245], 0
	setne	al
	mov	BYTE PTR [esi+226], al

; 588  :   io.KeyAlt    = (io.KeysDown [VK_MENU])    != 0;

	cmp	BYTE PTR [esi+247], 0

; 589  : 
; 590  :   io.KeySuper  = false;

	mov	BYTE PTR [esi+228], 0
	setne	al
	mov	BYTE PTR [esi+227], al

; 591  : 
; 592  :   SK_ImGui_PollGamepad ();

	call	?SK_ImGui_PollGamepad@@YAXXZ		; SK_ImGui_PollGamepad

; 593  : 
; 594  : 
; 595  :   // For games that hijack the mouse cursor using Direct Input 8.
; 596  :   //
; 597  :   //  -- Acquire actually means release their exclusive ownership : )
; 598  :   //
; 599  :   //if (SK_ImGui_WantMouseCapture ())
; 600  :   //  SK_Input_DI8Mouse_Acquire ();
; 601  :   //else
; 602  :   //  SK_Input_DI8Mouse_Release ();
; 603  : 
; 604  : 
; 605  :   // Start the frame
; 606  :   ImGui::NewFrame ();

	call	?NewFrame@ImGui@@YAXXZ			; ImGui::NewFrame
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	mov	eax, DWORD PTR _pSwapChain$[ebp]
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp

; 607  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.10.25017\atlmfc\include\atlcomcli.h

; 176  :         if (p)

	test	eax, eax
	je	SHORT $LN27@ImGui_Impl

; 177  :             p->Release();

	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+8]
$LN27@ImGui_Impl:
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp

; 607  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ImGui_ImplDX9_NewFrame@@YAXXZ$0:
	lea	ecx, DWORD PTR _pSwapChain$[ebp]
	jmp	??1?$CComPtr@UIDirect3DSwapChain9@@@ATL@@QAE@XZ
__ehhandler$?ImGui_ImplDX9_NewFrame@@YAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?ImGui_ImplDX9_NewFrame@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ImGui_ImplDX9_NewFrame@@YAXXZ ENDP			; ImGui_ImplDX9_NewFrame
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp
_TEXT	SEGMENT
?ImGui_ImplDX9_Shutdown@@YAXXZ PROC			; ImGui_ImplDX9_Shutdown

; 393  :   ImGui_ImplDX9_InvalidateDeviceObjects ( nullptr );

	push	0
	call	?ImGui_ImplDX9_InvalidateDeviceObjects@@YAXPAU_D3DPRESENT_PARAMETERS_@@@Z ; ImGui_ImplDX9_InvalidateDeviceObjects
	add	esp, 4

; 394  :   ImGui::Shutdown                       (         );

	call	?Shutdown@ImGui@@YAXXZ			; ImGui::Shutdown

; 395  : 
; 396  :   g_pd3dDevice = nullptr;

	mov	DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A, 0 ; g_pd3dDevice

; 397  :   g_hWnd       = 0;

	mov	DWORD PTR ?g_hWnd@@3PAUHWND__@@A, 0

; 398  : }

	ret	0
?ImGui_ImplDX9_Shutdown@@YAXXZ ENDP			; ImGui_ImplDX9_Shutdown
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp
_TEXT	SEGMENT
$T1 = -8						; size = 8
_hwnd$ = 8						; size = 4
_device$ = 12						; size = 4
_pparams$ = 16						; size = 4
?ImGui_ImplDX9_Init@@YA_NPAXPAUIDirect3DDevice9@@PAU_D3DPRESENT_PARAMETERS_@@@Z PROC ; ImGui_ImplDX9_Init

; 334  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 335  :   g_hWnd       = static_cast <HWND> (hwnd);

	mov	eax, DWORD PTR _hwnd$[ebp]
	sub	esp, 8
	mov	DWORD PTR ?g_hWnd@@3PAUHWND__@@A, eax

; 336  :   g_pd3dDevice = device;

	mov	eax, DWORD PTR _device$[ebp]
	mov	DWORD PTR ?g_pd3dDevice@@3PAUIDirect3DDevice9@@A, eax ; g_pd3dDevice

; 337  : 
; 338  :   if (! QueryPerformanceFrequency        (reinterpret_cast <LARGE_INTEGER *> (&g_TicksPerSecond)))

	push	OFFSET ?g_TicksPerSecond@@3_JA
	call	DWORD PTR __imp__QueryPerformanceFrequency@4
	test	eax, eax
	jne	SHORT $LN2@ImGui_Impl
$LN8@ImGui_Impl:

; 339  :     return false;

	xor	al, al

; 387  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@ImGui_Impl:

; 340  : 
; 341  :   if (! QueryPerformanceCounter_Original (reinterpret_cast <LARGE_INTEGER *> (&g_Time)))

	push	OFFSET ?g_Time@@3_JA
	call	DWORD PTR ?QueryPerformanceCounter_Original@@3P6GHPAT_LARGE_INTEGER@@@ZA ; QueryPerformanceCounter_Original
	test	eax, eax
	je	SHORT $LN8@ImGui_Impl

; 342  :     return false;
; 343  : 
; 344  :   ImGuiIO& io (ImGui::GetIO ());

	call	?GetIO@ImGui@@YAAAUImGuiIO@@XZ		; ImGui::GetIO

; 345  : 
; 346  : 
; 347  :   // Keyboard mapping. ImGui will use those indices to peek into the io.KeyDown[] array that we will update during the application lifetime.
; 348  :   io.KeyMap [ImGuiKey_Tab]        = VK_TAB;
; 349  :   io.KeyMap [ImGuiKey_LeftArrow]  = VK_LEFT;
; 350  :   io.KeyMap [ImGuiKey_RightArrow] = VK_RIGHT;
; 351  :   io.KeyMap [ImGuiKey_UpArrow]    = VK_UP;
; 352  :   io.KeyMap [ImGuiKey_DownArrow]  = VK_DOWN;
; 353  :   io.KeyMap [ImGuiKey_PageUp]     = VK_PRIOR;
; 354  :   io.KeyMap [ImGuiKey_PageDown]   = VK_NEXT;
; 355  :   io.KeyMap [ImGuiKey_Home]       = VK_HOME;
; 356  :   io.KeyMap [ImGuiKey_End]        = VK_END;
; 357  :   io.KeyMap [ImGuiKey_Delete]     = VK_DELETE;
; 358  :   io.KeyMap [ImGuiKey_Backspace]  = VK_BACK;
; 359  :   io.KeyMap [ImGuiKey_Enter]      = VK_RETURN;
; 360  :   io.KeyMap [ImGuiKey_Escape]     = VK_ESCAPE;
; 361  :   io.KeyMap [ImGuiKey_A]          = 'A';
; 362  :   io.KeyMap [ImGuiKey_C]          = 'C';
; 363  :   io.KeyMap [ImGuiKey_V]          = 'V';
; 364  :   io.KeyMap [ImGuiKey_X]          = 'X';
; 365  :   io.KeyMap [ImGuiKey_Y]          = 'Y';
; 366  :   io.KeyMap [ImGuiKey_Z]          = 'Z';
; 367  : 
; 368  :   // Alternatively you can set this to NULL and call ImGui::GetDrawData() after ImGui::Render() to get the same ImDrawData pointer.
; 369  :   io.RenderDrawListsFn = ImGui_ImplDX9_RenderDrawLists;
; 370  :   io.ImeWindowHandle   = g_hWnd;
; 371  : 
; 372  : 
; 373  :   float width  = 0.0f,
; 374  :         height = 0.0f;
; 375  : 
; 376  :   if ( pparams != nullptr )

	mov	edx, DWORD PTR _pparams$[ebp]
	mov	ecx, eax
	mov	eax, DWORD PTR ?g_hWnd@@3PAUHWND__@@A
	xorps	xmm1, xmm1
	xorps	xmm0, xmm0
	mov	DWORD PTR [ecx+36], 9
	mov	DWORD PTR [ecx+48], 37			; 00000025H
	mov	DWORD PTR [ecx+52], 39			; 00000027H
	mov	DWORD PTR [ecx+40], 38			; 00000026H
	mov	DWORD PTR [ecx+44], 40			; 00000028H
	mov	DWORD PTR [ecx+56], 33			; 00000021H
	mov	DWORD PTR [ecx+60], 34			; 00000022H
	mov	DWORD PTR [ecx+64], 36			; 00000024H
	mov	DWORD PTR [ecx+68], 35			; 00000023H
	mov	DWORD PTR [ecx+72], 46			; 0000002eH
	mov	DWORD PTR [ecx+76], 8
	mov	DWORD PTR [ecx+80], 13			; 0000000dH
	mov	DWORD PTR [ecx+84], 27			; 0000001bH
	mov	DWORD PTR [ecx+88], 65			; 00000041H
	mov	DWORD PTR [ecx+92], 67			; 00000043H
	mov	DWORD PTR [ecx+96], 86			; 00000056H
	mov	DWORD PTR [ecx+100], 88			; 00000058H
	mov	DWORD PTR [ecx+104], 89			; 00000059H
	mov	DWORD PTR [ecx+108], 90			; 0000005aH
	mov	DWORD PTR [ecx+172], OFFSET ?ImGui_ImplDX9_RenderDrawLists@@YAXPAUImDrawData@@@Z ; ImGui_ImplDX9_RenderDrawLists
	mov	DWORD PTR [ecx+200], eax
	test	edx, edx
	je	SHORT $LN4@ImGui_Impl

; 377  :   {
; 378  :     width  = static_cast <float> (pparams->BackBufferWidth);

	mov	eax, DWORD PTR [edx]
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]

; 379  :     height = static_cast <float> (pparams->BackBufferHeight);

	mov	eax, DWORD PTR [edx+4]
	cvtpd2ps xmm1, xmm0
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
$LN4@ImGui_Impl:
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp], xmm1
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp

; 382  :   io.DisplayFramebufferScale = ImVec2 ( width, height );

	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR [ecx+144], eax
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	movss	DWORD PTR $T1[ebp+4], xmm0
; File c:\users\andon\source\repos\specialk\src\imgui\backends\imgui_d3d9.cpp

; 382  :   io.DisplayFramebufferScale = ImVec2 ( width, height );

	mov	eax, DWORD PTR $T1[ebp+4]
	mov	DWORD PTR [ecx+148], eax

; 383  :   //io.DisplaySize             = ImVec2 ( width, height );
; 384  : 
; 385  : 
; 386  :   return true;

	mov	al, 1

; 387  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ImGui_ImplDX9_Init@@YA_NPAXPAUIDirect3DDevice9@@PAU_D3DPRESENT_PARAMETERS_@@@Z ENDP ; ImGui_ImplDX9_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
;	COMDAT _HRESULT_FROM_WIN32
_TEXT	SEGMENT
_x$ = 8							; size = 4
_HRESULT_FROM_WIN32 PROC				; COMDAT

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _x$[ebp]
	test	eax, eax
	jle	SHORT $LN4@HRESULT_FR
	movzx	eax, ax
	or	eax, -2147024896			; 80070000H
$LN4@HRESULT_FR:
	pop	ebp
	ret	0
_HRESULT_FROM_WIN32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??A?$ImVector@UImDrawCmd@@@@QBEABUImDrawCmd@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??A?$ImVector@UImDrawCmd@@@@QBEABUImDrawCmd@@H@Z PROC	; ImVector<ImDrawCmd>::operator[], COMDAT
; _this$ = ecx

; 913  :     inline const value_type&    operator[](int i) const         { IM_ASSERT(i < Size); return Data[i]; }

	npad	2
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR [ecx+8]
	pop	ebp
	ret	4
??A?$ImVector@UImDrawCmd@@@@QBEABUImDrawCmd@@H@Z ENDP	; ImVector<ImDrawCmd>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\andon\source\repos\specialk\include\imgui\imgui.h
;	COMDAT ??0ImVec2@@QAE@MM@Z
_TEXT	SEGMENT
__x$ = 8						; size = 4
__y$ = 12						; size = 4
??0ImVec2@@QAE@MM@Z PROC				; ImVec2::ImVec2, COMDAT
; _this$ = ecx

; 98   :     ImVec2(float _x, float _y) { x = _x; y = _y; }

	npad	2
	push	ebp
	mov	ebp, esp
	movss	xmm0, DWORD PTR __x$[ebp]
	mov	eax, ecx
	movss	DWORD PTR [ecx], xmm0
	movss	xmm0, DWORD PTR __y$[ebp]
	movss	DWORD PTR [ecx+4], xmm0
	pop	ebp
	ret	8
??0ImVec2@@QAE@MM@Z ENDP				; ImVec2::ImVec2
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	npad	2
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___n$[ebp]
	test	esi, esi
	je	SHORT $LN6@vector
	push	ebx
	mov	ebx, DWORD PTR ___f$[ebp]
	push	edi
	mov	edi, DWORD PTR ___t$[ebp]
$LL2@vector:
	mov	ecx, edi
	call	ebx
	add	edi, DWORD PTR ___s$[ebp]
	sub	esi, 1
	jne	SHORT $LL2@vector
	pop	edi
	pop	ebx
$LN6@vector:
	pop	esi
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
